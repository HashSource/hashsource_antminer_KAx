/* This file was generated by the Hex-Rays decompiler version 9.2.0.250908.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
void sub_1E4AC();
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// void *calloc(size_t nmemb, size_t size);
// int __fastcall zlog_init(_DWORD); weak
// char *strstr(const char *haystack, const char *needle);
// int __fastcall zlog_get_category(_DWORD); weak
// int raise(int sig);
// int pthread_cond_broadcast(pthread_cond_t *cond);
// int _res_init(void);
// void _pthread_register_cancel(__pthread_unwind_buf_t *buf);
// int strcmp(const char *s1, const char *s2);
// int strtol(const char *nptr, char **endptr, int base);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// int printf(const char *format, ...);
// int pthread_attr_destroy(pthread_attr_t *attr);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int pthread_mutex_destroy(pthread_mutex_t *mutex);
// int fflush(FILE *stream);
// void *memmove(void *dest, const void *src, size_t n);
// void free(void *ptr);
// char *fgets(char *s, int n, FILE *stream);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// int pthread_detach(pthread_t th);
// int clock_gettime(clockid_t clock_id, struct timespec *tp);
// pthread_t pthread_self(void);
// void *memcpy(void *dest, const void *src, size_t n);
// int __fastcall mmap64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// __sighandler_t signal(int sig, __sighandler_t handler);
// time_t time(time_t *timer);
// int memcmp(const void *s1, const void *s2, size_t n);
// int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
// int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
// unsigned int sleep(unsigned int seconds);
// int __fastcall stpcpy(_DWORD, _DWORD); weak
// ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len);
// int pthread_setcancelstate(int state, int *oldstate);
// int pthread_condattr_init(pthread_condattr_t *attr);
// int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr);
// void *realloc(void *ptr, size_t size);
// int pthread_condattr_setclock(pthread_condattr_t *attr, __clockid_t clock_id);
// int pthread_cond_destroy(pthread_cond_t *cond);
// int strcasecmp(const char *s1, const char *s2);
// void perror(const char *s);
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// char *strcat(char *dest, const char *src);
// int ioctl(int fd, unsigned int request, ...);
// int __fastcall lseek64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// __int64 strtoll(const char *nptr, char **endptr, int base);
// int usleep(__useconds_t useconds);
// char *strcpy(char *dest, const char *src);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int sched_yield(void);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// int __fastcall open64(_DWORD); weak
// char *getenv(const char *name);
// int rand_r(unsigned int *seed);
// int puts(const char *s);
// int sysinfo(struct sysinfo *info);
// void *malloc(size_t size);
// int _libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)(), void *stack_end);
// char *strerror(int errnum);
// const __int32_t **_ctype_tolower_loc(void);
// int _gmon_start__(void); weak
// const unsigned __int16 **_ctype_b_loc(void);
// __pid_t getpid(void);
// void exit(int status);
// int syscall(int sysno, ...);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// size_t strlen(const char *s);
// char *strchr(const char *s, int c);
// int pthread_setcanceltype(int type, int *oldtype);
// int nice(int inc);
// int fcntl(int fd, int cmd, ...);
// double sqrt(double x);
// int pthread_attr_init(pthread_attr_t *attr);
// int *_errno_location(void);
// int strncasecmp(const char *s1, const char *s2, size_t n);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int _isoc99_sscanf(_DWORD, const char *, ...); weak
// char *_strdup(const char *s);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// void *memset(void *s, int c, size_t n);
// void _pthread_unregister_cancel(__pthread_unwind_buf_t *buf);
// int putchar(int c);
// char *strncpy(char *dest, const char *src, size_t n);
// int pthread_cancel(pthread_t th);
// int prctl(int option, ...);
// double strtod(const char *nptr, char **endptr);
// ssize_t write(int fd, const void *buf, size_t n);
// void _pthread_unwind_next(__pthread_unwind_buf_t *buf);
// void *memchr(const void *s, int c, size_t n);
// int vsprintf(char *s, const char *format, __gnuc_va_list arg);
// int access(const char *name, int type);
// int rand(void);
// int fclose(FILE *stream);
// void pthread_exit(void *retval);
// int __fastcall zlog_fini(_DWORD); weak
// int munmap(void *addr, size_t len);
// char *strtok(char *s, const char *delim);
// int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);
// int shutdown(int fd, int how);
// FILE *popen(const char *command, const char *modes);
// int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, socklen_t hostlen, char *serv, socklen_t servlen, unsigned int flags);
// int listen(int fd, int n);
// int __fastcall zlog_reload(_DWORD); weak
// int pthread_join(pthread_t th, void **thread_return);
// int _sigsetjmp(struct __jmp_buf_tag *env, int savemask);
// struct lconv *localeconv(void);
// int sprintf(char *s, const char *format, ...);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// int __fastcall fopen64(_DWORD, _DWORD); weak
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
// void freeaddrinfo(struct addrinfo *ai);
// int getaddrinfo(const char *name, const char *service, const struct addrinfo *req, struct addrinfo **pai);
// int socket(int domain, int type, int protocol);
// in_addr_t inet_addr(const char *cp);
// void pthread_testcancel(void);
// struct hostent *gethostbyname(const char *name);
// int fseek(FILE *stream, int off, int whence);
// int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int pthread_cond_signal(pthread_cond_t *cond);
// void abort(void);
// ssize_t recv(int fd, void *buf, size_t n, int flags);
// int close(int fd);
// ssize_t send(int fd, const void *buf, size_t n, int flags);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// int pclose(FILE *stream);
int __fastcall main(int argc, const char **argv, const char **envp);
void __noreturn start(void (*a1)(), int a2, int a3, int a4, ...); // idb
int sub_1F388();
int deregister_tm_clones(); // idb
int register_tm_clones(); // idb
int sub_1F3FC();
int __fastcall sub_1F418(int result, const char **a2);
void *__fastcall sub_1F534(_DWORD *a1);
void *__fastcall sub_1F644(_DWORD *a1, int a2, int a3, const char *a4);
int __fastcall sub_1F7CC(_DWORD *a1, int a2);
int __fastcall sub_1F978(int result, int a2, const char *a3);
int sub_20000(); // weak
int __fastcall sub_20788(_DWORD *a1, const char **a2);
int __fastcall sub_20B88(_DWORD *a1, const char **a2);
int __fastcall sub_210A8(_DWORD *a1, int a2);
int sub_2186C();
int *__fastcall sub_219FC(int *result);
int __fastcall sub_21A40(_DWORD *a1, const char *a2, int a3, unsigned int a4);
char *__fastcall sub_21C04(char *a1, int *a2);
int __fastcall sub_21D08(int result, _DWORD *a2, int a3);
int __fastcall sub_21EB0(int a1, _DWORD *a2);
int sub_21EFC();
ssize_t __fastcall sub_22010(int *a1, char *s);
char __fastcall set_elapsed_time_validity(char result);
time_t get_miner_elapsed_time();
int __fastcall sub_2237C(_DWORD *a1, int a2);
int __fastcall sub_23144(_DWORD *a1, int a2);
int __fastcall sub_2393C(_DWORD *a1, const char **a2);
int __fastcall sub_2424C(_DWORD *a1, const char **a2);
time_t set_miner_start_time();
int *api_flush(); // idb
void update_rate_ideal();
char *print_summary();
void *api();
void __noreturn work_generator_thread();
char *__fastcall godminer_chip_status_monitor(int a1);
char *__fastcall godminer_fan_monitor(int a1);
int __fastcall sub_27540(int a1);
int __fastcall get_currentalgo(char *a1, size_t a2); // idb
int __fastcall workio_submit_work(int a1, int *a2);
void __noreturn nonce_submit_thread();
int __fastcall update_recorded_timeout_value(unsigned __int64 a1); // idb
void __fastcall parse_config(_DWORD *a1);
int __fastcall parse_arg(int result, char *s); // idb
int make_fake_version(); // idb
int read_version_file();
int godminer_register_status_monitor(); // idb
int set_working_voltage_and_runtime_freq();
int __fastcall sub_28A20(char *a1, size_t a2, int a3);
int __fastcall get_miner_info(char *a1); // idb
int get_freq_scan_status();
int get_miner_sale_hashrate();
int get_miner_qualified_hashrate();
int get_theory_hashrate();
int __fastcall http_test_bm(int a1, char *a2, size_t a3);
void http_test_case_init();
_DWORD *__fastcall sub_294A8(char *s2);
bool __fastcall sub_29644(void **a1, _BYTE *a2, char *haystack);
int *__fastcall sub_29870(int *a1, char a2);
int sub_298C4();
int get_current_pool(); // idb
bool __fastcall current_pool_changed(int a1); // idb
int __fastcall wait_pool_to_be_current(int a1); // idb
int __fastcall wait_pool_to_be_current_timeout(int a1); // idb
int __fastcall set_current_pool(int a1); // idb
char *add_pool();
int sub_29C74();
int __fastcall set_url(char *a1); // idb
int __fastcall set_user(char *s); // idb
int __fastcall set_pass(char *s); // idb
int __fastcall pool_tset(int a1, _BYTE *a2, int a3); // idb
int __fastcall pool_tclear(int a1, _BYTE *a2, int a3); // idb
int __fastcall pool_tget(int a1, unsigned __int8 *a2); // idb
int __fastcall pool_twait_to_be_expected_and_set(int a1, _BYTE *a2, int a3, char a4, const struct timespec *a5); // idb
int switch_pools();
int *__fastcall pool_alive(int a1); // idb
int __fastcall pool_died(int *a1);
int check_pool_worker();
int __fastcall share_result(int a1, int a2, char *a3, double *a4);
__int64 *__fastcall update_pool_diff1_of_all_runtimes(int *a1);
int create_pool_stratum_threads(); // idb
void sub_2A8D4();
int __fastcall judge_load_config(char *a1);
int reload_pool();
char *__fastcall stratum_buffer_append(int a1, const char *a2); // idb
int __fastcall stratum_send_line(int *a1, char *a2);
char *__fastcall stratum_recv_line(int *a1);
int __fastcall stratum_socket_full(int a1, __time_t a2);
bool __fastcall stratum_connect(int a1);
int __fastcall stratum_disconnect(int *a1);
int __fastcall stratum_thread(int a1);
int __fastcall sub_2C7D8(int a1);
int __fastcall sub_2C858(int a1);
int __fastcall sub_2C888(const char *a1, int *a2);
int __fastcall extract_byte_from_hex(const char *a1, int a2);
int __fastcall format_hashrate_string(int a1, char *a2);
int __fastcall format_hashrate_double(int a1, double *a2, char *a3);
int __fastcall bin2hex(int s, int a2, int a3); // idb
void *__fastcall abin2hex(int a1, int a2); // idb
bool __fastcall hex2bin(int a1, unsigned __int8 *a2, int a3);
int __fastcall str2hex(int a1, int a2, int a3); // idb
int __fastcall valid_hex(const char *a1);
int __fastcall valid_ascii(const char *a1);
char *tq_new(); // idb
void __fastcall tq_free(char *a1); // idb
int __fastcall tq_freeze(int a1); // idb
int __fastcall tq_thaw(int a1); // idb
int __fastcall tq_push(int a1, int a2); // idb
int __fastcall tq_pop(int a1, const struct timespec *a2); // idb
int __fastcall cgtime(struct timeval *a1);
int __fastcall cgtimer_sub(int *a1, int *a2, _DWORD *a3); // idb
bool __fastcall get_server_port_from_url(char *a1, char *a2, _WORD *a3); // idb
float *__fastcall find_min_and_max_float(float *result, int a2, float *a3, float *a4); // idb
int *__fastcall find_min_and_max_int(int *result, int a2, _DWORD *a3, _DWORD *a4); // idb
int *__fastcall calc_mean(int *result, int a2); // idb
int __fastcall calc_stdd(double a1);
bool __fastcall check_value_valid_with_stdd(double a1, int a2);
int __fastcall sub_2D9CC(int a1, int a2, int a3, int a4);
int __fastcall sub_2DA94(int a1, _BYTE *a2, const char **a3, int *a4, int a5);
int __fastcall sub_2DCAC(int a1, int a2, char *a3, const char **a4, int *a5, char a6);
int __fastcall getopt(int a1, int a2, char *a3); // idb
int __fastcall EVPX_EncryptInit_ex(int a1, int a2, char *a3, const char **a4, int *a5); // idb
int __fastcall getopt_long_only(int a1, int a2, char *a3, const char **a4, int *a5); // idb
int __fastcall sub_2E300(void *src, size_t n, const void **a3);
int __fastcall sub_2E314(void *src, size_t n, _DWORD *a3);
size_t __fastcall sub_2E358(const void *a1, size_t a2, FILE *s);
int __fastcall sub_2E374(void *buf, size_t n, int *a3);
int __fastcall sub_2E39C(const char **a1, const char **a2);
int __fastcall sub_2E3A8(char *a1, int a2, int (__fastcall *a3)(const char *, int, int), int a4, unsigned int a5);
int __fastcall sub_2E630(char a1, int a2, int a3, int (__fastcall *a4)(char *, int, int), int a5);
int __fastcall sub_2E6E0(unsigned int *a1, const void *a2, char *s);
int __fastcall sub_2E738(_DWORD *a1, int a2, int a3, unsigned int *a4, int (__fastcall *a5)(char *, int, int), int a6);
int __fastcall json_dump_callback(_DWORD *a1, int (__fastcall *a2)(char *, int, int), int a3, int a4);
_BYTE *__fastcall json_dumps(_DWORD *a1, int a2); // idb
int __fastcall json_dumpb(_DWORD *a1, int a2, int a3, int a4); // idb
int __fastcall json_dumpf(_DWORD *a1, int a2, int a3);
int __fastcall json_dump_file(_DWORD *a1, int a2, int a3); // idb
int __fastcall json_dumpfd(_DWORD *a1, int a2, int a3); // idb
char *__fastcall sub_2F0A8(char *a1, char *s);
char *__fastcall jsonp_error_init(char *result, char *a2); // idb
char *__fastcall jsonp_error_set_source(char *a1, char *s);
int jsonp_error_set(int result, int a2, int a3, int a4, char a5, char *format, ...); // idb
int __fastcall jsonp_error_vset(int result, int a2, int a3, int a4, char a5, char *format, __gnuc_va_list arg); // idb
int __fastcall sub_2F20C(unsigned __int16 *a1, unsigned int a2, int a3);
int __fastcall sub_2F750(int a1, int *a2, char *s2, int a4);
void __fastcall sub_2F7C4(int a1);
int __fastcall hashtable_init(_DWORD *a1); // idb
void __fastcall hashtable_close(int a1);
int __fastcall hashtable_set(unsigned int *a1, char *a2, unsigned int a3); // idb
int __fastcall hashtable_get(int a1, char *s); // idb
int __fastcall hashtable_del(_DWORD *a1, char *s); // idb
int __fastcall hashtable_clear(_DWORD *a1); // idb
int __fastcall hashtable_iter(int a1);
int __fastcall hashtable_iter_at(int a1, char *s); // idb
int __fastcall hashtable_iter_next(int a1, int a2);
int __fastcall hashtable_iter_key(int a1);
int __fastcall hashtable_iter_value(int a1);
void __fastcall hashtable_iter_set(int a1, int a2); // idb
int __fastcall json_object_seed(int result); // idb
int __fastcall sub_2FF40(int a1);
int __fastcall sub_2FFA8(_DWORD *a1);
int __fastcall sub_2FFCC(int a1);
int __fastcall sub_2FFF0(_DWORD *a1);
int sub_3004C(int result, _DWORD *a2, int a3, const char *a4, ...);
void __fastcall sub_3017C(int a1);
int __fastcall sub_301BC(int *a1);
_DWORD *__fastcall sub_301E8(_DWORD *result, int a2);
int __fastcall sub_30244(int a1, int a2);
int __fastcall sub_303AC(int a1, int a2);
int __fastcall sub_303EC(_DWORD *a1, int a2);
unsigned int __fastcall sub_30404(int a1, int a2);
double *__fastcall sub_30BEC(int a1, int a2, int a3);
double *__fastcall sub_31090(_DWORD *a1, int a2, int a3);
double *__fastcall json_loads(int a1, int a2, char *a3); // idb
double *__fastcall json_loadb(int a1, int a2, int a3, char *a4); // idb
double *__fastcall json_loadf(int a1, int a2, char *a3); // idb
double *__fastcall json_loadfd(int a1, int a2, char *a3); // idb
double *__fastcall json_load_file(char *a1, int a2, char *a3); // idb
double *__fastcall json_load_callback(double *a1, int a2, int a3, char *a4); // idb
void *__fastcall jsonp_malloc(void *result);
void __fastcall jsonp_free(void *a1);
_BYTE *__fastcall jsonp_strndup(const void *a1, size_t a2); // idb
_BYTE *__fastcall jsonp_strdup(const char *a1);
int __fastcall json_set_alloc_funcs(__int64 a1);
_DWORD *__fastcall json_get_alloc_funcs(_DWORD *result, _DWORD *a2); // idb
char *sub_31760(int *a1, char *a2, char a3, char *format, ...);
_BYTE *__fastcall sub_317C0(_DWORD *a1);
int __fastcall sub_318F0(int a1, size_t **a2, const char *a3, size_t *a4, _DWORD *a5, int a6);
int __fastcall sub_31C24(int a1, _DWORD *a2, _QWORD ***a3);
void *__fastcall sub_32764(int a1, int **a2, int a3);
double *__fastcall sub_32840(int *a1, int **a2);
double *__fastcall json_vpack_ex(char *a1, int a2, _BYTE *a3, int *a4); // idb
double *qsnprintf(wchar_t *a1, int a2, wchar_t *a3, ...); // idb
double *json_pack(_BYTE *a1, ...); // idb
int __fastcall json_vunpack_ex(_DWORD *a1, char *a2, int a3, _BYTE *a4, _QWORD **a5); // idb
int json_unpack_ex(_DWORD *a1, char *a2, int a3, _BYTE *a4, ...); // idb
int json_unpack(_DWORD *a1, _BYTE *a2, ...); // idb
int __fastcall strbuffer_init(_DWORD *a1); // idb
void __fastcall strbuffer_close(int a1); // idb
int __fastcall strbuffer_clear(int result);
int __fastcall strbuffer_value(int a1);
int __fastcall strbuffer_steal_value(int *a1);
int __fastcall strbuffer_append_bytes(const void **a1, void *src, size_t n); // idb
int __fastcall fh_buffer_putc(const void **a1, char a2); // idb
int __fastcall strbuffer_pop(int *a1, char a2, int a3); // idb
int __fastcall jsonp_strtod(const char **a1, double *a2); // idb
int __fastcall jsonp_dtostr(char *a1, size_t a2, int a3, int a4); // idb
int __fastcall utf8_encode(int a1, _BYTE *a2, _DWORD *a3); // idb
int __fastcall utf8_check_first(int a1); // idb
bool __fastcall utf8_check_full(char *a1, unsigned int a2, int *a3);
char *__fastcall utf8_iterate(char *result, int a2, _DWORD *a3); // idb
int __fastcall utf8_check_string(int a1, unsigned int a2); // idb
_QWORD *__fastcall sub_33A28(int a1);
void *__fastcall sub_33A78(_DWORD *a1, int a2, int a3);
_DWORD *__fastcall sub_33B04(_BYTE *a1, size_t a2, int a3);
_DWORD *json_object(); // idb
_DWORD *__fastcall json_object_size(_DWORD *result);
int __fastcall json_object_get(_DWORD *a1, char *a2); // idb
bool __fastcall sub_33C1C(int *a1, int *a2);
int __fastcall json_object_del(_DWORD *a1, char *a2); // idb
int __fastcall json_object_clear(_DWORD *a1); // idb
int __fastcall json_object_iter(_DWORD *a1); // idb
int __fastcall json_object_iter_at(_DWORD *a1, char *a2);
int __fastcall json_object_iter_next(_DWORD *a1, int a2); // idb
int __fastcall json_object_iter_key(int a1);
int __fastcall json_object_iter_value(int a1);
int __fastcall json_object_key_to_iter(int result);
_DWORD *json_array(); // idb
_DWORD *__fastcall json_array_size(_DWORD *result);
_DWORD *__fastcall json_array_get(_DWORD *result, unsigned int a2); // idb
int __fastcall json_array_extend(_DWORD *a1, _DWORD *a2); // idb
char *__fastcall json_string_nocheck(char *result); // idb
_DWORD *__fastcall json_stringn_nocheck(_BYTE *a1, size_t a2);
_DWORD *__fastcall jsonp_stringn_nocheck_own(_BYTE *a1, size_t a2);
_DWORD *__fastcall json_stringn(_BYTE *a1, size_t a2); // idb
char *__fastcall BUFX_strdup(char *result); // idb
_DWORD *__fastcall json_string_value(_DWORD *result);
_DWORD *__fastcall json_string_length(_DWORD *result);
int __fastcall json_string_setn_nocheck(int a1, const void *a2, size_t a3); // idb
int __fastcall json_string_set_nocheck(int a1, const char *a2); // idb
int __fastcall json_string_setn(int a1, const void *a2, size_t a3); // idb
int __fastcall json_string_set(int a1, const char *a2);
_DWORD *__fastcall json_vsprintf(char *format, __gnuc_va_list arg); // idb
_DWORD *ipcomx_vprintf(char *a1, ...); // idb
_QWORD *__fastcall json_integer(__int64 a1); // idb
__int64 __fastcall json_integer_value(int a1); // idb
int __fastcall json_integer_set(int a1, __int64 a2); // idb
double *json_real(); // idb
void json_real_value(); // idb
int __fastcall json_real_set(int a1); // idb
int __fastcall json_number_value(int result); // idb
void *json_true();
void *json_false();
void *json_null();
void __fastcall json_delete(_DWORD *a1); // idb
int __fastcall json_array_clear(_DWORD *a1); // idb
int __fastcall json_object_iter_set_new(_DWORD *a1, int a2, _DWORD *a3); // idb
int __fastcall json_array_remove(_DWORD *a1, unsigned int a2); // idb
int __fastcall json_object_set_new_nocheck(_DWORD *a1, char *a2, _DWORD *a3); // idb
int __fastcall json_object_update_missing(_DWORD *a1, _DWORD *a2); // idb
int __fastcall json_object_set_new(_DWORD *a1, char *a2, _DWORD *a3); // idb
int __fastcall json_object_update(_DWORD *a1, _DWORD *a2); // idb
int __fastcall json_object_update_existing(_DWORD *a1, _DWORD *a2); // idb
int __fastcall json_array_insert_new(_DWORD *a1, unsigned int a2, _DWORD *a3); // idb
int __fastcall json_array_set_new(_DWORD *a1, unsigned int a2, _DWORD *a3); // idb
int __fastcall json_array_append_new(_DWORD *a1, _DWORD *a2); // idb
bool __fastcall json_equal(int *a1, int *a2);
double *__fastcall json_copy(int a1); // idb
double *__fastcall json_deep_copy(int a1); // idb
int __fastcall stratum_set_diff_or_target_base(int a1, int a2, _DWORD *a3);
const char *__fastcall stratum_handle_method_base(int (__fastcall **a1)(_DWORD, _DWORD, _DWORD), int a2, int a3);
int __fastcall stratum_subscribe_base(int a1, int *a2);
int __fastcall stratum_authorize_base(int a1, _DWORD *a2);
int __fastcall stratum_login_base(int a1, int a2);
int __fastcall stratum_handle_response_base(int a1, int a2, int a3);
int __fastcall sub_36370(int a1, int a2, _DWORD *a3, unsigned int a4);
int sub_366C4(); // weak
int __fastcall sub_366FC(int a1, pthread_mutex_t *a2, _DWORD *a3);
int __fastcall sub_36A74(int a1, int a2, char *a3);
_DWORD *frontend_runtime_ckb();
int __fastcall sub_36BE4(int a1, pthread_mutex_t *a2, _DWORD *a3, unsigned int a4);
int sub_36ED4(); // weak
bool __fastcall sub_36F0C(int a1, pthread_mutex_t *a2, _DWORD *a3);
int __fastcall sub_37B18(int a1, int a2, char *a3);
void *frontend_runtime_dash();
int __fastcall sub_37CD4(int a1, pthread_mutex_t *a2, _DWORD *a3, unsigned int a4);
bool __fastcall sub_3800C(int a1, pthread_mutex_t *a2, _DWORD *a3);
int sub_38B1C(); // weak
int __fastcall sub_38B84(int a1, int a2, char *a3);
void *frontend_runtime_dcr();
int __fastcall sub_38D74(int a1, int a2);
int __fastcall stratum_handle_response_hns(int a1, int a2, int a3);
int __fastcall sub_39074(int a1, pthread_mutex_t *a2, _DWORD *a3, unsigned int a4);
int __fastcall sub_39364(int a1, int a2, char *a3);
bool __fastcall sub_39468(int a1, pthread_mutex_t *a2, _DWORD *a3);
void *frontend_runtime_hns();
_DWORD *__fastcall set_frontend_runtime_type(int a1, int a2);
int frontend_runtime_instance();
int __fastcall sub_3A5A4(int a1, int a2);
int __fastcall sub_3A5D8(int a1, pthread_mutex_t *a2, _DWORD *a3, unsigned int a4);
int __fastcall sub_3A868(int a1, pthread_mutex_t *a2, _DWORD *a3);
int __fastcall sub_3AB38(int a1, int a2, char *a3);
void *frontend_runtime_kda();
int __fastcall sub_3ACC0(int a1, int a2);
void *machine_runtime_ctrl_ckb_2042();
int __fastcall sub_3AEA0(int a1, int a2);
void *machine_runtime_ctrl_dash_1766();
int __fastcall sub_3B080(int a1, int a2);
void *machine_runtime_ctrl_dcr_1727();
int __fastcall sub_3B26C(int a1, int a2);
void *machine_runtime_ctrl_hns_2130();
int __fastcall sub_3B458(int a1, int a2);
void *machine_runtime_ctrl_kda_2110();
void __fastcall __noreturn check_working_voltage(int a1);
int __fastcall set_baud_base(int a1, int a2);
int __fastcall check_bringup_temperature_base(int a1);
int __fastcall get_working_voltage_base(int (__fastcall **a1)(_DWORD, int));
int __fastcall start_voltage_monitor_base(void *arg); // idb
void __noreturn stop_voltage_monitor_base();
int __fastcall set_voltage_base(int a1, int a2); // idb
int __fastcall set_frequency_with_voltage_base(int a1);
int __fastcall check_asic_num_base(int a1);
int __fastcall start_mining_base(int a1);
int stop_mining_base();
int reset_mining_base();
int machine_info_init();
int __fastcall hardware_init(int a1);
void *__fastcall machine_runtime_init(int a1, int a2);
void __fastcall machine_runtime_exit(void *ptr);
int __fastcall diff_to_target_ckb(int a1);
int __fastcall target_to_diff_ckb(_DWORD); // weak
int __fastcall target_to_double_diff_ckb(unsigned __int64 *a1);
int __fastcall le256_target_to_double_diff_base_0(__int64 *a1); // idb
int __fastcall diff_to_target_dash(unsigned __int64 *a1);
int __fastcall le256_target_to_diff_base_0(int a1); // idb
int __fastcall target_to_double_diff_dcr(unsigned __int64 *a1);
void *__fastcall diff_to_target_dcr(char *a1); // idb
int __fastcall target_to_diff_dcr(int a1);
_DWORD *__fastcall dhash_content_init(int a1);
void __fastcall dhash_content_exit(void *ptr);
int sub_3D820();
int __fastcall sub_3D844(_DWORD *a1, __int64 *a2);
int __fastcall sub_3D9B4(_DWORD *a1, int a2, int a3);
_DWORD *dhash_content_hns_2130(); // idb
int __fastcall diff_to_target_hns(int a1);
int __fastcall target_to_double_diff_hns(unsigned __int64 *a1);
int __fastcall be256_target_to_diff_base_0(int a1); // idb
int __fastcall target_to_diff_word_hns(int a1);
int __fastcall sub_3DAF4(int a1, const char **a2);
int __fastcall sub_3DC08(int a1, pthread_mutex_t *a2, int a3);
int __fastcall sub_3DE08(_DWORD *a1, int a2, int a3);
_DWORD *dhash_content_kda_2110();
int __fastcall target_to_double_diff_kda(_DWORD *a1); // idb
int __fastcall diff_to_target_kda(_DWORD *a1); // idb
int __fastcall target_to_diff_kda(_DWORD *a1); // idb
int __fastcall le256todouble(__int64 *a1); // idb
int __fastcall le256_target_to_double_diff_base(__int64 *a1); // idb
int __fastcall diff_to_le256_target_base(unsigned __int64 *a1);
int __fastcall le256_target_to_diff_base(int a1);
int __fastcall be256todouble(unsigned __int64 *a1); // idb
int __fastcall be256_target_to_double_diff_base(unsigned __int64 *a1); // idb
int __fastcall diff_to_be256_target_base(int a1);
int __fastcall be256_target_to_diff_base(int a1);
int __fastcall sub_3E63C(int a1, __int64 *a2);
int __fastcall sub_3E6F0(int a1, int *a2, int a3);
int __fastcall sub_3E8A8(int a1, int a2, int a3);
_DWORD *dhash_content_ckb_2042(); // idb
int __fastcall sub_3E95C(int a1, __int64 *a2);
int __fastcall sub_3EA34(int a1, pthread_mutex_t *a2);
int __fastcall sub_3EC5C(_DWORD *a1, int a2, int a3);
_DWORD *dhash_content_ltc_1489(); // idb
int sub_3ED38();
int __fastcall sub_3ED5C(int a1, __int64 *a2);
int __fastcall sub_3EEFC(_DWORD *a1, int a2, int a3);
_DWORD *dhash_content_dcr_1727();
int check_fan_valiad();
void __noreturn heartbeat_on_device();
int psu_watchdog();
int start_heartbeat_thread();
void __fastcall __noreturn stop_heartbeat_thread(int a1);
int sub_3F8B8();
int sub_3F92C();
void __noreturn watchpool_thread();
int __fastcall sub_3FBBC(int a1);
int start_watchpool_thread();
int start_api_thread();
int check_pool_connect();
int __fastcall fan_get_check_fan_speed(int a1); // idb
int fan_pwm_get(); // idb
int __fastcall fan_pwm_set(unsigned int a1); // idb
int fan_pwm_set_max(); // idb
int sub_402D0();
int sub_40348();
int __fastcall sub_403C8(int a1);
int __fastcall read_feedback_voltage(int a1);
unsigned int power_on(); // idb
unsigned int power_off(); // idb
int __fastcall power_info_init(int a1, int a2, int a3, int a4, int a5); // idb
int __fastcall set_power_init_status(char a1);
int is_power_init();
int is_power_on();
int __fastcall set_voltage(int a1, int a2);
int __fastcall set_voltage_by_steps(int a1, int a2);
int get_current_voltage();
int get_working_voltage();
int get_max_voltage();
int __fastcall set_working_voltage(int a1); // idb
int is_check_asic_voltage_enable();
int __fastcall set_check_asic_voltage(int a1);
int power_init();
int sub_41428();
int sub_4167C();
int __fastcall sub_418C0(int a1);
int __fastcall get_temp(int a1); // idb
int set_pwm_by_temp();
int __fastcall fan_control_info_init(int a1, int a2, int a3, int a4, int a5, int a6, float a7, int a8, int a9, int a10, int a11, int a12, int a13);
int __fastcall show_sn(int a1);
int __fastcall get_miner_working_status(int result); // idb
int task_check_miner_status();
int sub_43588();
int sub_43650();
int sub_43718();
int sub_437E0();
int do_miner_monitor_start();
int __fastcall miner_monitor_init(int a1);
void miner_monitor_deinit(); // idb
int miner_monitor_start(); // idb
int miner_monitor_stop(); // idb
void *__fastcall read_status_from_monitor(void *a1, int a2);
int __fastcall add_temperature_observer(int a1);
int __fastcall add_hashrate_observer(int a1);
int __fastcall add_chip_status_observer(int a1);
int __fastcall add_fanspeed_observer(int a1);
int __fastcall read_system_status_from_monitor(int a1);
int sub_43D30();
char *__fastcall get_flag_from_monitor(int a1);
int __fastcall chip_speed_test(_DWORD *a1, int a2);
int __fastcall update_str_and_flag(int result, int a2, _DWORD *a3);
_DWORD *__fastcall update_chip_status(int a1, int a2, int a3);
int __fastcall update_fanspeed(int a1, _DWORD *a2, int a3);
_DWORD *__fastcall update_hashrate(int a1, int a2, _DWORD *a3);
void *__fastcall init_temp_senor_info(int a1);
int __fastcall update_temperature(int a1, _DWORD *a2, int a3);
_DWORD *__fastcall runtime_ctrl(int a1);
int query_device_num();
int __fastcall redirect_nonce_output(int result, int a2);
void *__fastcall get_all_created_runtime(_DWORD *a1); // idb
int check_and_destroy_abnormal_runtime();
int __fastcall sub_45E48(_DWORD *a1);
int __fastcall sub_46544(_DWORD *a1);
int __fastcall sub_473E4(_DWORD *a1);
int __fastcall sub_47BB4(_DWORD *a1);
int platform_is_adjustable_power();
int platform_is_check_asic_voltage_enable();
int platfrom_get_check_asic_voltage();
int platform_get_machine_name();
int platform_get_chain_num();
int platform_get_chain_domain_num();
int platform_get_chain_asic_num();
int platform_get_domain_asic_num();
int __fastcall platform_get_chip_type(int a1);
int __fastcall platform_get_asic_big_core_num(int a1);
int __fastcall platform_get_asic_little_core_num(int a1);
int __fastcall platform_get_core_little_core_num(int a1);
int __fastcall platform_get_asic_domain_num(int a1);
int platform_is_pic_mcu_en();
int __fastcall platform_get_asic_addr_interval(int a1);
int __fastcall platform_get_chain_sensor_mode(int a1);
int __fastcall platform_get_chain_sensor_num(int a1);
int __fastcall platform_get_sensor_addr(int a1, int a2); // idb
int platform_is_asic_sensor_air_in();
int __fastcall platform_get_sensor_max_chip_temp(int a1);
int __fastcall platform_get_sensor_max_pcb_temp(int a1);
int __fastcall platform_get_sensor_min_pcb_temp(int a1);
int __fastcall platform_get_sensor_max_uneffective_count(int a1);
int platform_get_fan_num();
int __fastcall platform_get_fan_max_speed(int a1);
int __fastcall platform_get_fan_min_speed(int a1);
float *__fastcall platform_get_fan_control_info(float *result); // idb
int __fastcall platform_get_pic_device_high(int a1);
int platform_get_psu_gpio_port();
int __fastcall platform_is_psu_supported(int a1); // idb
int platform_topol_init();
int __fastcall dev_ctrl(_DWORD); // weak
int sub_4AB90();
int get_chip_status_ckb();
int __fastcall get_theory_hashrate_ckb(int a1, double *a2);
int __fastcall get_qualify_nonce_num_ckb(int a1, float *a2);
int overclock_update_ckb();
unsigned int __fastcall get_packet_remain_len_ckb(int a1);
int __fastcall global_idx_init_ckb(int a1);
int __fastcall global_idx_free_ckb(int a1);
int __fastcall sub_4ACC4(int a1);
int __fastcall set_sensor_extern_mode_ckb(int a1);
int __fastcall sub_4ADEC(int *a1, int a2);
int __fastcall work_2_packet_ckb(int a1, int a2, _BYTE *a3, _DWORD *a4);
int __fastcall sub_4B398(int a1, int a2);
int __fastcall set_frequency_ckb(int a1, int a2);
int __fastcall sub_4B7E0(int a1, int a2);
int __fastcall sub_4B8D4(int a1, int a2);
int __fastcall sub_4B8EC(int a1, int *a2);
int __fastcall sub_4BC64(int a1, int a2);
int __fastcall sub_4C024(int a1, int a2);
int __fastcall sub_4C04C(int a1, int a2, char a3);
int __fastcall sub_4C3C8(int a1, int a2, char a3);
bool __fastcall sub_4C3E0(int a1, int a2, char **a3);
int __fastcall sub_4C8BC(int a1, int a2, char **a3);
int __fastcall sub_4C8D4(int a1);
int __fastcall sub_4CC84(int a1);
int __fastcall sub_4CCAC(int a1);
int __fastcall sub_4D060(int a1);
int __fastcall sub_4D088(int a1, int a2);
int __fastcall sub_4D330(int a1, int a2);
int __fastcall sub_4D348(int a1, int a2);
int __fastcall sub_4D44C(int a1, int a2);
int __fastcall check_nonce_ckb(int a1, int a2);
int __fastcall sub_4D778(int *a1, int a2);
int __fastcall sub_4DC98(int *a1);
int __fastcall parameter_update_ckb(int a1, char a2, int a3, char a4, int a5);
int __fastcall sub_4DD88(unsigned int *a1, int a2, int a3, _BYTE *a4, _DWORD *a5, signed int *a6, _DWORD *a7);
int __fastcall packet_2_nonce_ckb(unsigned int *a1, int a2, int a3, _BYTE *a4, _DWORD *a5, signed int *a6, _DWORD *a7);
int __fastcall get_sale_hashrate_ckb(int a1, double *a2, _DWORD *a3);
int __fastcall get_qualify_hashrate_ckb(int a1, double *a2);
int __fastcall sub_4E178(char *a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_4E2C0(char *a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_4E40C(unsigned int *a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_4E5F0(unsigned int *a1, unsigned __int8 *a2, _DWORD *a3, _DWORD *a4, unsigned __int8 a5);
int __fastcall softreset_all_chip_ckb(int *a1);
int __fastcall sub_4E754(_DWORD *a1, int a2, int a3, _DWORD *a4, _DWORD *a5);
int __fastcall read_sensor_temp_remote_ckb(int a1, int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __fastcall read_sensor_temp_local_ckb(_DWORD *a1, int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __fastcall set_baud_ckb_0(int a1, int a2);
int set_baud_ckb(); // weak
int __fastcall sub_4EC18(int a1);
int __fastcall top_init_ckb(int *a1);
int __fastcall dhash_start_ckb(int a1);
int get_pcba_test_level_ckb();
int __fastcall makeup_chip_addr_ae(_BYTE *a1, unsigned int a2); // idb
void __fastcall get_core_regdata_ckb_2042(int a1, __int16 a2);
int get_algo_type_ckb();
int update_chip_info_ckb();
void *runtime_ctrl_ckb_2042();
int get_chip_status_dash();
int __fastcall get_theory_hashrate_dash(int a1, double *a2);
int __fastcall get_sale_hashrate_dash(int a1, double *a2, _DWORD *a3);
int __fastcall get_qualify_hashrate_dash(int a1, double *a2);
int __fastcall get_qualify_nonce_num_dash(int a1, float *a2);
int get_packet_remain_len_dash();
int __fastcall sub_4F598(int a1, __int16 a2, int a3);
int __fastcall global_idx_init_dash(int a1);
int __fastcall sub_4F670(int a1);
int __fastcall global_idx_free_dash(int a1);
int __fastcall set_sensor_extern_mode_dash(int a1);
int __fastcall sub_4F7B0(int *a1, int a2);
int __fastcall work_2_packet_dash(int a1, int a2, _BYTE *a3, _DWORD *a4);
int __fastcall softreset_all_chip_dash(int *a1); // idb
int __fastcall sub_4FDD4(int a1, int a2);
int __fastcall set_frequency_dash(int a1, int a2);
int __fastcall sub_5021C(int a1, int a2);
int __fastcall sub_50310(int a1, int a2);
int __fastcall sub_50328(int a1, int *a2);
int __fastcall sub_506A0(int a1, int a2);
int __fastcall sub_50A60(int a1, int a2);
int __fastcall sub_50A88(int a1, int a2, char a3);
int __fastcall sub_50E04(int a1, int a2, char a3);
bool __fastcall sub_50E1C(int a1, int a2, char **a3);
int __fastcall sub_512F8(int a1, int a2, char **a3);
int __fastcall sub_51310(int a1);
int __fastcall sub_516C0(int a1);
int __fastcall sub_516E8(int a1);
int __fastcall sub_51A9C(int a1);
int __fastcall sub_51AC4(int a1, int a2);
int __fastcall sub_51D70(int a1, int a2);
int __fastcall sub_51D88(int a1, int a2);
int __fastcall sub_51E8C(int a1, int a2);
int __fastcall check_nonce_dash(int a1, int a2);
int __fastcall get_pcba_test_level_dash(_DWORD *a1, _DWORD *a2);
int __fastcall sub_52414(int *a1, int a2);
int __fastcall sub_52934(int *a1);
int __fastcall sub_52974(int a1, char a2, int a3, char a4, int a5);
int __fastcall parameter_update_dash(int a1, char a2, int a3, char a4, int a5);
int __fastcall sub_52AC4(int a1, int a2);
int __fastcall overclock_update_dash(int a1, int a2);
int __fastcall sub_52C90(_DWORD *a1, int a2, int a3, _BYTE *a4, _DWORD *a5, signed int *a6, _DWORD *a7);
int __fastcall packet_2_nonce_dash(_DWORD *a1, int a2, int a3, _BYTE *a4, _DWORD *a5, signed int *a6, _DWORD *a7);
int __fastcall sub_52EEC(char *a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_53034(char *a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_53180(unsigned int *a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_53364(unsigned int *a1, unsigned __int8 *a2, _DWORD *a3, _DWORD *a4, unsigned __int8 a5);
int __fastcall sub_53458(_DWORD *a1, int a2, int a3, _DWORD *a4, _DWORD *a5);
int __fastcall read_sensor_temp_remote_dash(int a1, int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __fastcall read_sensor_temp_local_dash(_DWORD *a1, int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __fastcall set_baud_dash_0(int a1, int a2);
int set_baud_dash(); // weak
int __fastcall sub_53940(int a1);
int __fastcall top_init_dash(int *a1);
int __fastcall dhash_start_dash(int a1);
int __fastcall makeup_chip_addr_dash(_BYTE *a1, unsigned int a2);
void __fastcall get_chip_regdata(int a1, __int16 a2);
int __fastcall set_chip_reg(int a1, char a2, char a3, int a4, int a5);
void __fastcall get_core_regdata(int a1, __int16 a2);
int __fastcall set_core_reg(int a1, char a2, int a3, int a4);
int __fastcall set_ticket_mask_dash(int a1, int a2);
int __fastcall set_core_mode_dash(int a1, int a2);
int __fastcall set_misc_ctrl_dash(int a1, int a2);
int get_algo_type_dash();
int set_boot_config_dash();
void *runtime_ctrl_dash_1766();
int get_chip_status_dcr();
int __fastcall get_theory_hashrate_dcr(int a1, double *a2);
int __fastcall get_sale_hashrate_dcr(int a1, double *a2, _DWORD *a3);
int __fastcall get_qualify_hashrate_dcr(int a1, double *a2);
int __fastcall get_qualify_nonce_num_dcr(int a1, float *a2);
int overclock_update_dcr();
unsigned int __fastcall get_packet_remain_len_dcr(int a1);
int __fastcall global_idx_init_dcr(int a1);
int __fastcall global_idx_free_dcr(int a1);
int __fastcall sub_5473C(int a1);
int __fastcall set_sensor_extern_mode_dcr(int a1);
int __fastcall sub_54864(int *a1, int a2);
int __fastcall work_2_packet_dcr(int a1, _DWORD *a2, _BYTE *a3, _DWORD *a4);
int __fastcall sub_54C54(int a1, int a2);
int __fastcall set_frequency_dcr(int a1, int a2);
int __fastcall sub_5509C(int a1, int a2);
int __fastcall sub_55190(int a1, int a2);
int __fastcall sub_551A8(int a1, int *a2);
int __fastcall sub_55520(int a1, int a2);
int __fastcall sub_558E0(int a1, int a2);
int __fastcall sub_55908(int a1, int a2, char a3);
int __fastcall sub_55C84(int a1, int a2, char a3);
bool __fastcall sub_55C9C(int a1, int a2, char **a3);
int __fastcall sub_56178(int a1, int a2, char **a3);
int __fastcall sub_56190(int a1);
int __fastcall sub_56540(int a1);
int __fastcall sub_56568(int a1);
int __fastcall sub_5691C(int a1);
int __fastcall sub_56944(int a1, int a2);
int __fastcall sub_56BEC(int a1, int a2);
int __fastcall sub_56C04(int a1, int a2);
int __fastcall sub_56D08(int a1, int a2);
int __fastcall check_nonce_dcr(int a1, int a2);
int __fastcall sub_57038(int *a1, int a2);
int __fastcall sub_57558(int *a1);
int __fastcall parameter_update_dcr(int a1, char a2, int a3, char a4, int a5);
int __fastcall sub_57648(unsigned int *a1, int a2, int a3, _BYTE *a4, _DWORD *a5, signed int *a6, _DWORD *a7);
int __fastcall packet_2_nonce_dcr(unsigned int *a1, int a2, int a3, _BYTE *a4, _DWORD *a5, signed int *a6, _DWORD *a7);
int __fastcall sub_57820(char *a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_57968(char *a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_57AB4(unsigned int *a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_57C98(unsigned int *a1, unsigned __int8 *a2, _DWORD *a3, _DWORD *a4, unsigned __int8 a5);
int __fastcall softreset_all_chip_dcr(int *a1);
int __fastcall sub_57DFC(_DWORD *a1, int a2, int a3, _DWORD *a4, _DWORD *a5);
int __fastcall read_sensor_temp_remote_dcr(int a1, int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __fastcall read_sensor_temp_local_dcr(_DWORD *a1, int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __fastcall set_baud_dcr_0(int a1, int a2);
int set_baud_dcr(); // weak
int __fastcall sub_582C0(int a1);
int __fastcall top_init_dcr(int *a1);
int __fastcall dhash_start_dcr(int a1);
int get_pcba_test_level_dcr();
int __fastcall makeup_chip_addr_dcr(_BYTE *a1, unsigned int a2);
int get_algo_type_dcr();
int update_chip_info_dcr();
void *runtime_ctrl_dcr_1727();
int get_chip_status_hns();
int __fastcall get_theory_hashrate_hns(int a1, double *a2);
int __fastcall get_sale_hashrate_hns(int a1, double *a2, _DWORD *a3);
int __fastcall get_qualify_hashrate_hns(int a1, double *a2);
int __fastcall get_qualify_nonce_num_hns(int a1, float *a2);
int overclock_update_hns();
unsigned int __fastcall get_packet_remain_len_hns(int a1);
int __fastcall sub_58BC0(int a1, __int16 a2, int a3);
int __fastcall global_idx_init_hns(int a1);
int __fastcall global_idx_free_hns(int a1);
int __fastcall sub_58C48(int a1);
int __fastcall set_sensor_extern_mode_hns(int a1);
int __fastcall sub_58D70(int *a1, int a2);
int __fastcall work_2_packet_hns(int a1, _DWORD *a2, _BYTE *a3, _DWORD *a4);
int __fastcall sub_590BC(int a1, int a2);
int __fastcall set_frequency_hns(int a1, int a2);
int __fastcall sub_59504(int a1, int a2);
int __fastcall sub_595F8(int a1, int a2);
int __fastcall sub_59610(int a1, int a2);
int __fastcall sub_599D0(int a1, int a2);
int __fastcall sub_599F8(int a1, int *a2);
int __fastcall sub_59D70(int a1, int a2, char a3);
int __fastcall sub_5A0EC(int a1, int a2, char a3);
bool __fastcall sub_5A104(int a1, int a2, char **a3);
int __fastcall sub_5A5E0(int a1, int a2, char **a3);
int __fastcall sub_5A5F8(int a1);
int __fastcall sub_5A9A8(int a1);
int __fastcall sub_5A9D0(int a1);
int __fastcall sub_5AD84(int a1);
int __fastcall sub_5ADAC(int a1, int a2);
int __fastcall sub_5B054(int a1, int a2);
int __fastcall sub_5B06C(int a1, int a2);
int __fastcall sub_5B170(int a1, int a2);
int __fastcall check_nonce_hns(int a1, int a2);
int __fastcall sub_5B3E4(int *a1, int a2);
int __fastcall sub_5B904(int *a1);
int __fastcall parameter_update_hns(int a1, char a2, int a3, char a4, int a5);
int __fastcall packet_2_nonce_hns(unsigned int *a1, int a2, int a3, _BYTE *a4, _DWORD *a5, signed int *a6, _DWORD *a7);
int __fastcall sub_5BB28(char *a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_5BC70(char *a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_5BDBC(unsigned int *a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_5BFA0(unsigned int *a1, unsigned __int8 *a2, _DWORD *a3, _DWORD *a4, unsigned __int8 a5);
int __fastcall sub_5C094(_DWORD *a1, int a2, int a3, _DWORD *a4, _DWORD *a5);
int __fastcall read_sensor_temp_remote_hns(int a1, int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __fastcall read_sensor_temp_local_hns(_DWORD *a1, int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __fastcall set_baud_hns_0(int a1, int a2);
int set_baud_hns(); // weak
int __fastcall sub_5C558(int a1);
int __fastcall top_init_hns(int *a1);
int __fastcall dhash_start_hns(int a1);
int get_pcba_test_level_hns();
int __fastcall makeup_chip_addr_hns(_BYTE *a1, unsigned int a2);
int __fastcall set_nonce_cycle_limit(int a1);
int __fastcall softreset_all_chip_hns(int *a1);
int get_algo_type_hns();
int update_chip_info_hns();
void *runtime_ctrl_hns_2130();
int get_chip_status_kda();
int __fastcall get_theory_hashrate_kda(int a1, double *a2);
int __fastcall get_sale_hashrate_kda(int a1, double *a2, _DWORD *a3);
int __fastcall get_qualify_hashrate_kda(int a1, double *a2);
int __fastcall get_qualify_nonce_num_kda(int a1, float *a2);
int overclock_update_kda();
unsigned int __fastcall get_packet_remain_len_kda(int a1);
int __fastcall global_idx_init_kda(int a1);
int __fastcall global_idx_free_kda(int a1);
int __fastcall sub_5CFFC(int a1);
int __fastcall set_sensor_extern_mode_kda(int a1);
int __fastcall sub_5D124(int *a1, int a2);
int __fastcall work_2_packet_kda(int a1, int a2, int a3, _DWORD *a4);
int __fastcall sub_5D770(int a1, int a2);
int __fastcall set_frequency_kda_2110(int a1, int a2);
int __fastcall sub_5DBB8(int a1, int a2);
int __fastcall sub_5DCAC(int a1, int a2);
int __fastcall sub_5DCC4(int a1, int *a2);
int __fastcall sub_5E03C(int a1, int a2);
int __fastcall sub_5E3FC(int a1, int a2);
int __fastcall sub_5E424(int a1, int a2, char a3);
int __fastcall sub_5E7A0(int a1, int a2, char a3);
bool __fastcall sub_5E7B8(int a1, int a2, char **a3);
int __fastcall sub_5EC94(int a1, int a2, char **a3);
int __fastcall sub_5ECAC(int a1);
int __fastcall sub_5F05C(int a1);
int __fastcall sub_5F084(int a1);
int __fastcall sub_5F438(int a1);
int __fastcall sub_5F460(int a1, int a2, int a3);
int __fastcall sub_5F560(int a1, int a2, int a3);
int __fastcall sub_5F578(int a1, int a2);
int __fastcall sub_5F820(int a1, int a2);
int __fastcall sub_5F838(int a1, int a2);
int __fastcall sub_5F93C(int a1, int a2);
int __fastcall check_nonce_kda(int a1, int a2);
int __fastcall sub_5FCA0(int *a1, int a2);
int __fastcall sub_601C0(int *a1);
int __fastcall parameter_update_kda(int a1, char a2, int a3, char a4, int a5);
int __fastcall sub_60298(int a1, int a2, int a3, _BYTE *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7);
int __fastcall packet_2_nonce_kda(int a1, int a2, int a3, _BYTE *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7);
int __fastcall sub_604D0(char *a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_60618(char *a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_60764(unsigned int *a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_60948(unsigned int *a1, unsigned __int8 *a2, _DWORD *a3, _DWORD *a4, unsigned __int8 a5);
int __fastcall softreset_all_chip_kda(int *a1);
int __fastcall sub_60AAC(_DWORD *a1, int a2, int a3, _DWORD *a4, _DWORD *a5);
int __fastcall read_sensor_temp_remote_kda(int a1, int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __fastcall read_sensor_temp_local_kda(_DWORD *a1, int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __fastcall set_baud_kda_2110_0(int a1, int a2);
int set_baud_kda_2110(); // weak
int __fastcall dhash_start_kda(int a1);
int __fastcall top_init_kda(int a1);
int get_pcba_test_level_kda();
int __fastcall makeup_chip_addr_kda(_BYTE *a1, unsigned int a2);
int get_algo_type_kda();
int update_chip_info_kda();
void *runtime_ctrl_kda_2110();
int __fastcall sub_61708(unsigned int a1);
int __fastcall sub_6183C(int a1, int a2, int a3, unsigned __int8 *a4);
char __fastcall set_pic_device_high(char result);
int __fastcall pic1704_get_sw_version(char a1, _BYTE *a2); // idb
int __fastcall pic1704_jump_to_app(char a1); // idb
int __fastcall pic1704_reset(char a1); // idb
int __fastcall pic1704_enable_disable_dc_dc(char a1, char a2); // idb
int __fastcall pic1704_erase_program(char a1); // idb
int __fastcall pic1704_heart_beat(char a1); // idb
int __fastcall pic1704_update_app_program(int a1);
int __fastcall pic1704_set_voltage(char a1, unsigned __int8 a2); // idb
int __fastcall pic1704_get_single_voltage(char a1, _DWORD *a2);
int __fastcall pic1704_get_an_voltage1(char a1); // idb
int __fastcall pic1704_get_all_voltage(char a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
int __fastcall pic1704_get_an_voltage2(char a1, int a2);
int __fastcall pic1704_voltage_clamp_ctrl(char a1, char a2); // idb
int __fastcall pic1704_get_PDCx(char a1, _DWORD *a2, _DWORD *a3, _DWORD *a4); // idb
int __fastcall pic1704_get_raw_crab_voltage(char a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5); // idb
int __fastcall pic1704_write_iic(char a1, char a2); // idb
int __fastcall pic1704_read_iic(char a1, char a2, _BYTE *a3); // idb
int __fastcall pic1704_write_flash(char a1, const void *a2, char a3, size_t a4); // idb
int __fastcall pic1704_read_flash(char a1, void *a2, char a3, size_t a4); // idb
int __fastcall open_pic(int a1); // idb
unsigned int __fastcall close_pic(unsigned int result);
int sub_62EF0();
int __fastcall sub_62F8C(int a1);
int __fastcall sub_63000(int a1);
int platform_init();
int platform_uninit(); // idb
void *__fastcall get_system_capability(void *result);
int __fastcall get_uuid(_DWORD *a1); // idb
int __fastcall get_mac_hal(int a1);
int __fastcall chain_reset_low(char a1); // idb
int __fastcall chain_reset_high(char a1); // idb
int __fastcall chain_reset(char a1);
unsigned int all_chain_reset_high(); // idb
unsigned int all_chain_reset_low(); // idb
int board_reset();
int get_hardware_type();
int __fastcall set_hardware_type(int a1);
int enable_bypass_mode();
int disable_bypass_mode();
int is_bypass_mode_enable();
int get_hardware_version();
int get_dhash_acc_control(); // idb
int __fastcall set_dhash_acc_control(int a1);
int disable_dhash_chip_work(); // idb
int fpga_chain_reset_all();
int __fastcall read_fpga_id(char *a1);
int __fastcall set_hardware_version(int a1);
int get_job_start_address(); // idb
int __fastcall set_job_start_address(int a1); // idb
int get_nonce2_and_job_id_store_address(); // idb
int __fastcall set_nonce2_and_job_id_store_address(int a1); // idb
unsigned int __fastcall get_fan_speed(_BYTE *a1, _DWORD *a2); // idb
int __fastcall set_time_out_control(int a1); // idb
int get_hash_counting_number(); // idb
int __fastcall set_hash_counting_number(int a1); // idb
int enable_mid_auto_gen_rx();
int disable_mid_auto_gen_rx();
int get_crc_count(); // idb
int __fastcall reset_crc_count(int a1);
int get_hash_on_plug(); // idb
int get_nonce_number_in_fifo(); // idb
int __fastcall get_return_nonce(_QWORD *a1); // idb
__int64 __fastcall get_return_nonce_128bit(__int64 *a1); // idb
int get_ticket_mask(); // idb
int __fastcall set_ticket_mask(int a1); // idb
int get_job_id(); // idb
int __fastcall set_job_id(int a1); // idb
int get_job_length(); // idb
int __fastcall set_job_length(int a1); // idb
int get_work_fifo_state(); // idb
int get_block_header_version(); // idb
int __fastcall set_block_header_version(int a1); // idb
int get_block_header_version_1(); // idb
int get_block_header_version_2(); // idb
int get_block_header_version_3(); // idb
int __fastcall set_block_header_version_1(int a1);
int __fastcall set_block_header_version_2(int a1);
int __fastcall set_block_header_version_3(int a1);
int __fastcall set_block_header_version_4(int a1);
int __fastcall set_block_header_version_5(int a1);
int __fastcall set_block_header_version_6(int a1);
int __fastcall set_block_header_version_7(int a1);
int get_time_stamp(); // idb
int __fastcall set_time_stamp(int a1); // idb
int get_target_bits(); // idb
int __fastcall set_target_bits(int a1); // idb
int __fastcall set_pre_header_hash(int a1); // idb
int __fastcall set_coinbase_length_and_nonce2_length(int a1); // idb
int __fastcall set_work_nonce2(int *a1); // idb
int __fastcall set_merkle_bin_number(unsigned __int16 a1); // idb
int get_nonce_fifo_interrupt(); // idb
int __fastcall set_nonce_fifo_interrupt(int a1); // idb
int set_BC_nullen_all_chain(); // idb
int __fastcall set_BC_baud(char a1); // idb
int __fastcall set_BC_nullen(int a1, int a2); // idb
int __fastcall send_BC_command(int *a1, int a2); // idb
int __fastcall set_TW_write_command(int a1); // idb
int __fastcall set_TW_write_command_vil(int *a1); // idb
int __fastcall set_TW_write_command_chunk0(int *a1); // idb
int __fastcall set_TW_write_command_x_midstate(int *a1, int a2); // idb
int get_QN_write_data_command(); // idb
int __fastcall set_QN_write_data_command(int a1); // idb
int get_temperature_0_3();
int get_temperature_4_7();
int get_temperature_8_11();
int get_temperature_12_15();
int __fastcall set_fan_control(int a1);
int __fastcall set_fan_control_1(int a1);
int get_bt8d_control();
int __fastcall set_bt8d_control(int a1);
int fan_init();
int fan_uninit(void); // weak
int __fastcall fan_get_realtime_speed(int a1);
int fpga_init();
void fpga_uninit();
int __fastcall fpga_read(int a1, _DWORD *a2); // idb
int __fastcall fpga_write(int a1, int a2);
int get_fpga_map_mem_addr();
int fpga_reset(void); // weak
int __fastcall sub_65510(_DWORD *a1, _DWORD *a2);
int gpio_init();
int gpio_uninit(); // idb
int __fastcall gpio_reg_callback(int a1, int a2);
int __fastcall gpio_unreg_callback(int a1, int a2);
int __fastcall gpio_export(int a1);
int __fastcall gpio_unexport(int a1);
int __fastcall gpio_direction(int a1, int a2);
int __fastcall gpio_read(int a1, _BYTE *a2);
int sub_666D4();
int __fastcall gpio_write(int a1, int a2);
int __fastcall is_gpio_exist(int a1);
int __fastcall iic_init(int a1);
int __fastcall iic_uninit(int a1);
int __fastcall iic_read(int a1, _BYTE *a2, int a3);
int __fastcall iic_write(int a1, int a2, int a3);
int __fastcall iic_read_reg(void *a1, unsigned __int8 *a2, int a3, int a4, unsigned int a5);
int __fastcall iic_write_reg(int a1, unsigned __int8 *a2, int a3, int a4, int a5);
int bitmain_power_on(); // idb
int bitmain_power_off_0(); // idb
int __fastcall set_bitmain_power_gpio_port(int result);
int __fastcall pwm_init(unsigned int a1, int a2);
int __fastcall pwm_uninit(int a1);
int __fastcall pwm_set(int a1, unsigned int a2);
int __fastcall pwm_get(int a1, int a2);
int __fastcall sub_679F4(int a1, _DWORD *a2, int *a3, int *a4, int *a5);
int __fastcall sub_67C4C(int a1);
int __fastcall sub_67E8C(int a1);
unsigned int __fastcall sub_6804C(int a1, int a2, unsigned int a3);
int uart_init();
int uart_uninit(void); // weak
size_t __fastcall uart_send(int a1, const void *a2, size_t a3);
unsigned int __fastcall uart_receive(int a1, int a2, unsigned int a3); // idb
int __fastcall uart_set_config(int a1, int a2, int *a3);
int __fastcall uart_get_config(int a1, int a2, _DWORD *a3, int a4);
int __fastcall high_speed_uart_set_config(int a1, int a2, _DWORD *a3);
int __fastcall high_speed_uart_get_config(int a1, int a2, int *a3, int a4);
int __fastcall clear_uart_rx_fifo(int a1);
int __fastcall uart_flush(int a1);
int __fastcall uart_flush_tx(int a1);
int __fastcall uart_flush_rx(int a1);
int __fastcall uart_get_readable_byte_num(int a1); // idb
int __fastcall sub_68D1C(_DWORD *a1, _DWORD *a2);
int sub_68D2C();
int *__fastcall sub_68E54(int *result, int *a2);
int __fastcall sub_68F20(int a1);
int __fastcall sub_68FB0(int a1, int a2);
int __fastcall sub_69018(int a1, int a2);
int ui_init();
int ui_uninit(); // idb
int red_led_on();
int red_led_off();
int red_led_flicker();
int green_led_on();
int green_led_off();
int green_led_flicker();
int beeper_on();
int beeper_off();
int beeper_flicker();
int __fastcall reg_key_callback(int a1);
int __fastcall unreg_key_callback(int a1);
int __fastcall lcd_show_result(char a1, int a2, unsigned int a3);
int lcd_clear_result();
int sub_69E70();
int __fastcall sub_6A070(int a1, void *a2);
int __fastcall sub_6A160(int a1, char *s); // idb
int __fastcall sub_6A24C(int a1, char *s); // idb
int __fastcall sub_6A338(int a1);
int __fastcall eeprom_open(unsigned int a1); // idb
int *__fastcall eeprom_close(unsigned int a1);
int __fastcall eeprom_write(unsigned int a1, unsigned __int8 a2, int a3, int a4);
int __fastcall eeprom_read(unsigned int a1, unsigned __int8 a2, int a3, int a4);
int __fastcall eeprom_dump_fixture(unsigned __int8 *a1);
int __fastcall add_eeprom_device(int a1, int a2); // idb
int __fastcall eeprom_load_one_chain(unsigned int a1, int a2);
int eeprom_load(); // idb
int __fastcall eeprom_get_voltage(int a1, _DWORD *a2);
int eeprom_get_max_voltage();
int __fastcall eeprom_get_freq(int a1, _DWORD *a2);
int eeprom_get_min_freq();
int is_eeprom_loaded();
int __fastcall api_get_eeprom_nonce_response_rate(int a1, _DWORD *a2);
int __fastcall api_get_eeprom_freq(int a1); // idb
int __fastcall api_get_eeprom_voltage(int a1);
int __fastcall api_get_eeprom_chip_bin(int a1);
int __fastcall api_get_eeprom_chip_ft(int a1);
int __fastcall api_get_eeprom_test_standard_code(int a1);
int __fastcall api_get_eeprom_chip_sn(int a1);
int __fastcall api_get_eeprom_miner_type(int a1, void *a2);
int __fastcall api_get_eeprom_chain_load_state(int a1);
int __fastcall api_get_eeprom_pcb_version(int a1, char *a2);
int __fastcall api_get_eeprom_bom_version(int a1, char *a2);
int __fastcall sub_6C9B8(void *a1, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int a5);
int sub_6CDB4();
int __fastcall sub_6CE54(void *a1, unsigned __int8 a2);
int sub_6CEB8();
int __fastcall sub_6CF54(void *a1, __int16 a2);
int sub_6CFC4();
int bitmain_power_close(); // idb
int bitmain_power_version();
int sub_6D270();
int bitmain_power_open(); // idb
int bitmain_get_sample_voltage();
int bitmain_get_power_status();
int __fastcall bitmain_set_watchdog(int a1);
int bitmain_power_fw_version();
int __fastcall bitmain_set_voltage_by_n(__int16 a1);
void bitmain_convert_N_to_V_calibration(); // idb
int bitmain_convert_V_to_N_calibration(); // idb
int bitmain_convert_V_to_N();
int bitmain_set_voltage();
void bitmain_convert_N_to_V();
void bitmain_get_voltage();
int __fastcall bitmain_power_read(__int16 a1, int a2, int a3);
int get_power_voltage_calibration_data();
int __fastcall sub_6E8F0(int a1);
int __fastcall sub_6E980(unsigned int a1, int a2);
int __fastcall tsensor_open(unsigned int a1, unsigned __int8 *a2, unsigned int a3);
int __fastcall tsensor_close(unsigned int a1);
int __fastcall tsensor_write(unsigned int a1, unsigned __int8 a2, unsigned __int8 a3, int a4, int a5);
int __fastcall tsensor_read(unsigned int a1, unsigned __int8 a2, unsigned __int8 a3, int a4, unsigned int a5);
int __fastcall get_response(int a1);
int __fastcall platform_check_repeat_nonce(int *a1, int a2, char *s2);
int __fastcall scanhash(int a1);
int __fastcall backend_exit_base(int a1);
int __fastcall async_push_work_base(int a1, char *a2);
int __fastcall push_work_base(int a1, int a2);
int __fastcall send_work(int a1);
int __fastcall pop_ans_base(int a1, char *a2);
int __fastcall try_pop_ans_base(int a1, char *a2);
int __fastcall backend_init_base(int a1);
int __fastcall reset_base(int a1);
int __fastcall dhash_mining_start_base(int a1);
int __fastcall dhash_mining_stop_base(int a1);
int __fastcall dhash_mining_reset_base(int a1);
int __fastcall set_chipaddr_base(int a1, int a2, int a3);
int __fastcall set_inactive_base(int a1);
int __fastcall sync_get_chip_reg_base(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
int __fastcall set_chip_reg_base(int a1, int a2);
int __fastcall set_core_reg_base(int a1, int a2);
int __fastcall sync_get_core_reg_base(int a1, int a2, int a3, int a4, int *a5, unsigned __int64 a6);
int __fastcall sub_70788(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5);
int __fastcall sub_7097C(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5);
int __fastcall sync_get_status_unclear_base(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5);
int __fastcall sync_get_dag_base(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5);
int __fastcall sync_get_dag_node_base(int a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int64 a6);
int __fastcall set_core_reg_base_9(int a1, int *a2);
int __fastcall sync_get_core_reg_base_3(int a1, int a2, int a3, int a4, int *a5, unsigned __int64 a6);
int __fastcall sync_get_status_base2(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5);
int __fastcall sync_get_chip_reg_base2(int a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int64 a6);
int __fastcall set_core_reg_base2(int a1, int a2);
int __fastcall sync_get_core_reg_base2(int a1, int a2, int a3, int a4, int *a5, unsigned __int64 a6);
int __fastcall set_core_enable_base(int result, int a2, __useconds_t a3);
int __fastcall set_core_enable_base2(int a1, int a2, __useconds_t a3);
int __fastcall sync_get_status_base(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5);
int __fastcall sync_get_core_reg_base3(int a1, int a2, int a3, int a4, int *a5, unsigned __int64 a6);
int __fastcall get_fake_regio_runtime(int a1);
int __fastcall set_chipaddr_by_id(int a1, int a2, int a3);
int __fastcall set_inactive_by_id(int a1);
int __fastcall set_chip_reg_by_id(int a1, int a2);
int __fastcall set_core_reg_by_id(int a1, int a2);
int __fastcall sync_get_chip_reg_by_id(int a1, int a2, int a3, int a4, int a5);
int __fastcall sync_get_core_reg_by_id(int a1, int a2, int a3, int a4, int a5);
int __fastcall reverse_byte_order_16(unsigned int a1);
unsigned int __fastcall reverse_byte_order_32(unsigned int a1);
int __fastcall send_command_packet(int a1, int a2, unsigned int a3);
int __fastcall convert_offset_to_chain_id(int a1);
int scan_miner_device_hal();
int __fastcall dev_is_valid_hal(int a1);
_DWORD *__fastcall set_dev_invalid_hal(int a1); // idb
int dev_get_nonce_reg_fifo_size_hal();
int dev_get_reg_fifo_capacity_hal();
int dev_dma_rw_dispatcher_hal();
int __fastcall sub_dev_init_hal(unsigned int a1); // idb
int __fastcall dev_config_hal(int a1); // idb
int dev_init_hal();
int __fastcall dev_config_one_chain_baud(int a1, int a2); // idb
size_t __fastcall dev_send_work_cmd_hal(int a1, char *a2, unsigned int a3); // idb
size_t __fastcall dev_send_reg_cmd_hal(int a1, const void *a2, size_t a3);
unsigned int __fastcall dev_read_nonce_reg_data_hal(int a1, int a2, unsigned int a3);
int dev_exit_hal();
int __fastcall chain_reset_low_hal(int a1); // idb
unsigned int __fastcall softreset_hal(int a1); // idb
int __fastcall power_on_hal(int a1, unsigned __int16 a2, int a3);
int __fastcall hardreset_hal(int a1); // idb
int __fastcall chain_reset_high_hal(int a1); // idb
int __fastcall sub_72B7C(int a1);
int __fastcall dev_init_pic_for_one_chain(int a1); // idb
int sub_72D08();
int dev_init_hal_pcba(); // idb
int __fastcall power_off_hal(int a1); // idb
int __fastcall heartbeat_to_hal(int a1); // idb
int __fastcall sub_72EAC(int a1, int a2, unsigned int a3, void *a4);
int __fastcall pic_operation_to_hal(int a1, int a2, unsigned int a3, void *a4); // idb
int dev_get_work_fifo_capacity_hal();
int __fastcall dump_log_hal(const char *a1, int a2, int a3, int a4); // idb
int (**dev_ctrl_hal())();
int __fastcall sub_73094(int a1);
void *__fastcall sub_730B0(int a1, const void *a2, size_t a3);
int *__fastcall sub_73110(int a1);
_DWORD *__fastcall new_c_map(int a1, int a2, int a3); // idb
int __fastcall insert_c_map(int *a1, const void *a2, size_t a3, const void *a4, size_t a5);
int *__fastcall exists_c_map(int *result, int a2); // idb
int __fastcall remove_c_map(int *a1, int a2); // idb
int __fastcall find_c_map(int *a1, int a2, _DWORD *a3); // idb
int __fastcall delete_c_map(void (__fastcall ***a1)(_DWORD)); // idb
_DWORD *__fastcall new_iterator_c_map(int a1); // idb
void delete_iterator_c_map(void *ptr);
int **__fastcall sub_7330C(int **result, int *a2);
_DWORD *__fastcall sub_73360(_DWORD *result, _DWORD *a2);
int __fastcall sub_733B4(int result, _DWORD *a2);
int __fastcall sub_733E8(int result, _DWORD *a2);
int __fastcall sub_7341C(int result, _DWORD *a2, int a3, _DWORD *a4);
int __fastcall sub_73480(_DWORD *a1);
_DWORD *__fastcall new_c_rb(int a1, int a2, int a3); // idb
_DWORD *__fastcall find_c_rb(int a1, int a2); // idb
int __fastcall insert_c_rb(int a1, const void *a2, size_t a3, const void *a4, size_t a5); // idb
int *__fastcall remove_c_rb(int a1, int a2); // idb
int __fastcall delete_c_rb(void (__fastcall **ptr)(_DWORD)); // idb
_DWORD *__fastcall minimum_c_rb(int a1, _DWORD *a2); // idb
int __fastcall maximum_c_rb(int a1, int a2); // idb
bool __fastcall empty_c_rb(_DWORD *a1);
int *__fastcall tree_successor(int *a1, int a2); // idb
_DWORD *__fastcall new_clib_object(const void *a1, size_t a2); // idb
int __fastcall get_raw_clib_object(int a1, _DWORD *a2); // idb
void *__fastcall replace_raw_clib_object(void **a1, const void *a2, size_t a3); // idb
void __fastcall destroy_sample_buffer(void **a1); // idb
int __fastcall sub_73DE4(unsigned __int8 a1, int a2, char a3, char *a4, int a5);
int __fastcall sub_74090(unsigned __int8 a1, char a2, _BYTE *a3);
int __fastcall sub_742E4(unsigned __int8 a1, char a2, _WORD *a3);
int __fastcall get_chain_isl_voltage(unsigned __int8 a1, int a2, int a3);
int __fastcall set_chain_isl_voltage(unsigned __int8 a1, int a2);
int __fastcall sub_746C0(_DWORD *a1, _DWORD *a2);
unsigned int sub_746D0();
unsigned int __fastcall sub_7472C(_BYTE *a1);
int i2c_init();
int __fastcall i2c_uninit(int a1);
int __fastcall i2c_read(int a1, _BYTE *a2, int a3);
int __fastcall i2c_write(int a1, int a2, int a3);
int __fastcall i2c_read_reg(void *a1, unsigned __int8 *a2, int a3, int a4, unsigned int a5);
int __fastcall i2c_write_reg(int a1, unsigned __int8 *a2, int a3, int a4, int a5);
int __fastcall i2c_ioctl(int a1, int a2, int a3);
int __fastcall i2c_select(int a1, int a2);
int __fastcall lcd_init(int a1);
int __fastcall lcd_write(int a1, int a2, int a3, unsigned int a4);
int lcd_flush();
int __fastcall lcd_clear(int a1);
int __fastcall lcd_uninit(int a1);
unsigned int __fastcall sph_blake224_0(unsigned int *a1, char *a2, size_t a3); // idb
void *__fastcall sph_blake384_0(int a1, char *a2, size_t a3); // idb
unsigned int *__fastcall sub_7ADD0(unsigned int *a1, char a2, int a3, int a4, int a5);
unsigned int __fastcall sub_7AF5C(int a1, char a2, int a3, int a4, int a5);
int __fastcall sub_7B180(int a1, int *a2);
int __fastcall sub_7B20C(_DWORD *a1, int *a2);
int __fastcall sph_blake224_init(_DWORD *a1);
int __fastcall sph_blake224_addbits_and_close(unsigned int *a1, char a2, int a3, int a4); // idb
int __fastcall sph_blake224_close(unsigned int *a1, int a2);
int __fastcall sph_blake256_init(_DWORD *a1);
int __fastcall sph_blake256_addbits_and_close(unsigned int *a1, char a2, int a3, int a4); // idb
int __fastcall sph_blake256_close(unsigned int *a1, int a2);
int __fastcall sph_blake256_set_rounds(int result);
int __fastcall sph_blake384_init(int a1);
int __fastcall sph_blake384_addbits_and_close(int a1, char a2, int a3, int a4); // idb
int __fastcall sph_blake384_close(int a1, int a2);
int __fastcall sph_blake512_init(int a1);
int __fastcall sph_blake512_addbits_and_close(int a1, char a2, int a3, int a4);
int __fastcall sph_blake512_close(int a1, int a2);
int __fastcall decred_hash(int a1, char *a2); // idb
int __fastcall blake2s_init_param(int *a1, int *a2); // idb
int __fastcall blake2s_init(int *a1, int a2); // idb
int __fastcall blake2s_compress(_DWORD *a1, int *a2); // idb
int __fastcall blake2s_update(_DWORD *a1, char *src, unsigned __int64 n); // idb
int __fastcall blake2s_init_key(int *a1, int a2, const void *a3, size_t a4); // idb
int __fastcall blake2s_final(int a1, void *a2, size_t a3); // idb
int __fastcall blake2s(void *a1, char *a2, const void *a3, size_t a4, unsigned __int64 a5, unsigned __int8 a6); // idb
int __fastcall PrintState(int a1); // idb
int __fastcall EaglesongPermutation(int result); // idb
unsigned int __fastcall EaglesongSponge(int a1, unsigned int a2, int a3, unsigned int a4, unsigned __int8 a5); // idb
unsigned int __fastcall EaglesongHash(int a1, int a2, unsigned int a3); // idb
int __fastcall sub_7D7F8(_DWORD *a1, unsigned __int64 *a2);
void *__fastcall sub_82590(int a1, unsigned __int64 *src, size_t n);
int __fastcall hs_blake2b_init_param(_DWORD *a1, unsigned __int8 *a2); // idb
int __fastcall hs_blake2b_init(_DWORD *a1, int a2); // idb
int __fastcall hs_blake2b_init_key(_DWORD *a1, int a2, const void *a3, size_t a4); // idb
int __fastcall hs_blake2b_update(int a1, unsigned __int64 *a2, size_t a3); // idb
int __fastcall hs_blake2b_final(int a1, void *a2, unsigned int a3); // idb
int __fastcall hs_blake2b(void *a1, unsigned int a2, unsigned __int64 *a3, size_t a4, const void *a5, size_t a6); // idb
int __fastcall target_to_diff(int a1, int a2); // idb
int __fastcall hns_hash(int a1, void *a2); // idb
int __fastcall sub_82D0C(const void **a1, _DWORD *a2, void *dest, size_t n);
void *__fastcall sub_82D4C(int a1);
int __fastcall hs_header_init(int a1);
void *hs_header_alloc(); // idb
int __fastcall hs_header_read(const void **a1, _DWORD *a2, _DWORD *a3); // idb
int __fastcall hs_header_decode(const void *a1, int a2, _DWORD *a3); // idb
int __fastcall hs_header_write(int a1, int *a2); // idb
int hs_header_size();
int __fastcall QImagePixmapCleanupHooks::removeImageHook(QImagePixmapCleanupHooks *this, void (__fastcall *a2)(__int64)); // idb
int __fastcall hs_header_pre_write(int a1, int *a2); // idb
int __fastcall hs_header_pre_size(int a1);
int __fastcall hs_header_pre_encode(int a1, int a2);
int __fastcall hs_header_sub_write(_DWORD *a1, int *a2); // idb
int __fastcall hs_header_share_write(int a1, int *a2); // idb
int __fastcall hs_header_share_encode(int a1, int a2);
int hs_header_sub_size();
int __fastcall hs_header_sub_encode(_DWORD *a1, int a2);
int __fastcall hs_header_sub_hash(_DWORD *a1, void *a2); // idb
int __fastcall hs_header_padding(int result, int a2, int a3); // idb
int __fastcall hs_header_share_pow(unsigned __int64 *a1, char *a2, void *a3); // idb
int __fastcall hs_header_pow(_BYTE *a1, void *a2); // idb
int __fastcall hs_header_verify_pow(_BYTE *a1, const void *a2); // idb
int __fastcall hs_header_print(_DWORD *a1, const char *a2); // idb
int __fastcall sub_83E40(int *a1, int a2, unsigned int a3);
_DWORD *__fastcall hs_sha3_224_init(void *a1);
_DWORD *__fastcall hs_sha3_256_init(void *a1);
_DWORD *__fastcall hs_sha3_384_init(void *a1);
_DWORD *__fastcall hs_sha3_512_init(void *a1);
int *__fastcall hs_sha3_update(int *result, char *a2, size_t a3); // idb
char *__fastcall hs_sha3_final(int *a1, void *a2); // idb
char *__fastcall hs_keccak_final(int *a1, void *a2); // idb
int __fastcall sub_84AE8(int a1, int a2, _BYTE *a3);
__int64 hs_now();
int __fastcall hs_date(int result, int a2, unsigned int *a3, unsigned int *a4, _DWORD *a5, int *a6, int *a7, _DWORD *a8); // idb
int __fastcall hs_ymdh(unsigned int *a1, unsigned int *a2, _DWORD *a3, int *a4); // idb
int __fastcall hs_ymd(unsigned int *a1, unsigned int *a2, _DWORD *a3); // idb
__int64 hs_nonce();
int __fastcall hs_hex_encode_size(int a1);
int __fastcall hs_hex_encode(int a1, int a2, _BYTE *a3); // idb
_BYTE *__fastcall hs_hex_encode32(int a1); // idb
_BYTE *__fastcall hs_hex_encode20(int a1); // idb
size_t __fastcall hs_hex_decode_size(const char *a1); // idb
bool __fastcall hs_hex_decode(_BYTE *a1, int a2); // idb
_BYTE *__fastcall hs_to_lower(_BYTE *result); // idb
int __fastcall sha256_transf(int result, unsigned __int8 *a2, int a3); // idb
_DWORD *__fastcall sha256_init(_DWORD *result); // idb
void *__fastcall sha256_update(unsigned __int8 *a1, char *a2, size_t n); // idb
int __fastcall sha256_final(_DWORD *a1, _BYTE *a2); // idb
int __fastcall sha256(char *a1, size_t n, _BYTE *a3); // idb
int __fastcall Xhash(_DWORD, _DWORD); // idb
FILE *x11_log_work(); // idb
unsigned int __fastcall BM_CRC16(unsigned __int8 *a1, int a2); // idb
unsigned int __fastcall BM_CRC16_WITH_KEY(unsigned __int8 *a1, int a2, unsigned int a3); // idb
int BM_CRC8();
int __fastcall BM_CRC5(_BYTE *a1, int a2); // idb
int __fastcall POWER_CRC16(int a1, int a2); // idb
int __fastcall sub_97B4C(_DWORD *a1, _DWORD *a2, char *s2);
void __fastcall map_deinit_(char **a1); // idb
int __fastcall map_get_(_DWORD *a1, char *s2); // idb
int __fastcall map_set_(void **a1, char *s2, const void *a3, size_t a4); // idb
void __fastcall map_remove_(_DWORD *a1, char *s2); // idb
_DWORD *__fastcall map_iter_(_DWORD *result);
unsigned int __fastcall map_next_(_DWORD *a1, unsigned int *a2); // idb
int __fastcall statusServiceThread(int a1);
int httpListenThread(); // weak
int start_http_thread();
int log_init(); // idb
int __fastcall log_uninit(int a1); // idb
int log_reload(); // idb
int logfmt_raw(char *a1, size_t n, int a3, ...);
int V_LOCK();
int V_UNLOCK();
_DWORD *__fastcall V_STR(_DWORD *a1, char *s, const char *a3); // idb
int __fastcall V_FLOAT(int a1, char *s); // idb
int __fastcall V_BOOL(int a1, char *s, char a3); // idb
int __fastcall V_INT(int a1, char *s, __int64 a3); // idb
void *new_observable_subject();
void destroy_observable_subject(void *ptr);
int __fastcall subject_observe(int result, int a2);
int __fastcall subject_notify_all(int result, int a2); // idb
int __fastcall send_line(int a1, char *s); // idb
int __fastcall socket_full(int a1, __time_t a2);
int __fastcall keep_sockalive(int a1); // idb
int __fastcall task_timer_thread(int a1);
void *new_task_timer();
int __fastcall add_new_task(int a1, int a2, int a3); // idb
int __fastcall _exec_all_task(int result); // idb
int __fastcall start_task_timer(_DWORD *arg); // idb
int __fastcall stop_task_timer(int result); // idb
void __fastcall destroy_task_timer(_DWORD *ptr); // idb
int __fastcall force_exec_all_task(int a1); // idb
int __fastcall _init_pipe_of_queue(int *a1, int a2, int a3); // idb
void __fastcall _deinit_pipe_of_queue(int *a1); // idb
char *__fastcall queue_new(int a1, int a2); // idb
void __fastcall queue_free(int a1); // idb
int __fastcall queue_enqueue(int a1, char *a2, int a3); // idb
void __fastcall queue_dequeue(int a1, char *a2, unsigned int a3);
int __fastcall queue_dequeue_for(int a1, char *a2, unsigned int a3, int *a4);
int __fastcall queue_clear(int a1);
int __fastcall queue_try_dequeue(int a1, char *a2, unsigned int a3);
int __fastcall queue_element_num(int a1);
int __fastcall queue_force_wakeup(int a1); // idb
int __fastcall xxtea_encode(unsigned int *a1, unsigned int a2, int a3);
int __fastcall xxtea_decode(unsigned int *a1, unsigned int a2, int a3);
int __fastcall data_enc(unsigned int *a1, unsigned int a2, int a3, int a4);
int __fastcall data_dec(unsigned int *a1, unsigned int a2, int a3, int a4);
void *__fastcall sph_cubehash224_0(_DWORD *a1, char *a2, size_t a3); // idb
unsigned int __fastcall sub_9D714(_DWORD *a1, char a2, char a3, _WORD *a4, int a5);
void *__fastcall sph_cubehash224_init_0(int a1); // idb
void *__fastcall sph_cubehash224_addbits_and_close(_DWORD *a1, char a2, char a3, _WORD *a4); // idb
void *__fastcall sph_cubehash224_close(_DWORD *a1, _WORD *a2);
void *__fastcall sph_cubehash256_init_0(int a1); // idb
void *__fastcall sph_cubehash256_addbits_and_close(_DWORD *a1, char a2, char a3, _WORD *a4); // idb
void *__fastcall sph_cubehash256_close(_DWORD *a1, _WORD *a2);
void *__fastcall sph_cubehash384_init(int a1);
void *__fastcall sph_cubehash384_addbits_and_close(_DWORD *a1, char a2, char a3, _WORD *a4); // idb
void *__fastcall sph_cubehash384_close(_DWORD *a1, _WORD *a2);
void *__fastcall sph_cubehash512_init(int a1);
void *__fastcall sph_cubehash512_addbits_and_close(_DWORD *a1, char a2, char a3, _WORD *a4); // idb
void *__fastcall sph_cubehash512_close(_DWORD *a1, _WORD *a2);
_DWORD *__fastcall sub_A0A90(_DWORD *result, int a2);
unsigned int *__fastcall sub_A0B2C(unsigned int *a1);
unsigned int *__fastcall sph_echo224_0(unsigned int *result, char *src, size_t n); // idb
_DWORD *__fastcall sub_A40FC(unsigned int *a1);
unsigned int *__fastcall sph_echo384_0(unsigned int *result, char *src, size_t n); // idb
void *__fastcall sub_A7678(int a1, char a2, int a3, void *a4, int a5);
_DWORD *__fastcall sub_A7834(int a1, char a2, int a3, void *a4, int a5);
_DWORD *__fastcall sph_echo224_init(_DWORD *result); // idb
void *__fastcall sph_echo224_close(int a1, void *a2); // idb
void *__fastcall sph_echo224_addbits_and_close(int a1, char a2, int a3, void *a4);
_DWORD *__fastcall sph_echo256_init(_DWORD *result); // idb
void *__fastcall sph_echo256_close(int a1, void *a2); // idb
void *__fastcall sph_echo256_addbits_and_close(int a1, char a2, int a3, void *a4);
_DWORD *__fastcall sph_echo384_init(_DWORD *a1);
_DWORD *__fastcall sph_echo384_close(int a1, void *a2); // idb
_DWORD *__fastcall sph_echo384_addbits_and_close(int a1, char a2, int a3, void *a4);
_DWORD *__fastcall sph_echo512_init(_DWORD *a1);
_DWORD *__fastcall sph_echo512_close(int a1, void *a2); // idb
_DWORD *__fastcall sph_echo512_addbits_and_close(int a1, char a2, int a3, void *a4);
void *__fastcall sph_groestl224_0(_DWORD *a1, char *a2, size_t a3); // idb
void *__fastcall sph_groestl384_0(int a1, char *a2, size_t a3); // idb
_DWORD *__fastcall sub_B0DA4(_DWORD *a1, char a2, char a3, void *a4, size_t n);
__int64 __fastcall sub_B279C(int a1, char a2, char a3, void *a4, size_t n);
int __fastcall sph_groestl224_init(int result); // idb
_DWORD *__fastcall sph_groestl224_close(_DWORD *a1, void *a2); // idb
_DWORD *__fastcall sph_groestl224_addbits_and_close(_DWORD *a1, char a2, char a3, void *a4);
int __fastcall sph_groestl256_init(int result); // idb
_DWORD *__fastcall sph_groestl256_close(_DWORD *a1, void *a2); // idb
_DWORD *__fastcall sph_groestl256_addbits_and_close(_DWORD *a1, char a2, char a3, void *a4);
int __fastcall sph_groestl384_init(int a1); // idb
__int64 __fastcall sph_groestl384_close(int a1, void *a2); // idb
__int64 __fastcall sph_groestl384_addbits_and_close(int a1, char a2, char a3, void *a4);
int __fastcall sph_groestl512_init(int a1); // idb
__int64 __fastcall sph_groestl512_close(int a1, void *a2); // idb
__int64 __fastcall sph_groestl512_addbits_and_close(int a1, char a2, char a3, void *a4);
void *__fastcall sph_jh224_0(int a1, char *a2, size_t a3); // idb
void *__fastcall sub_BAF94(_DWORD *a1, int a2, unsigned int a3, void *a4, int a5, void *src);
void *__fastcall sph_jh224_init_0(int a1); // idb
void *__fastcall sph_jh224_close(_DWORD *a1, void *a2); // idb
void *__fastcall sph_jh224_addbits_and_close(_DWORD *a1, int a2, unsigned int a3, void *a4); // idb
void *__fastcall sph_jh256_init(int a1);
void *__fastcall sph_jh256_close(_DWORD *a1, void *a2); // idb
void *__fastcall sph_jh256_addbits_and_close(_DWORD *a1, int a2, unsigned int a3, void *a4); // idb
void *__fastcall sph_jh384_init(int a1);
void *__fastcall sph_jh384_close(_DWORD *a1, void *a2); // idb
void *__fastcall sph_jh384_addbits_and_close(_DWORD *a1, int a2, unsigned int a3, void *a4); // idb
void *__fastcall sph_jh512_init(int a1);
void *__fastcall sph_jh512_close(_DWORD *a1, void *a2); // idb
void *__fastcall sph_jh512_addbits_and_close(_DWORD *a1, int a2, unsigned int a3, void *a4); // idb
unsigned int __fastcall sph_luffa224_0(unsigned int result, char *a2, size_t a3); // idb
unsigned int __fastcall sub_BBD10(unsigned int *a1, char a2, char a3, _BYTE *a4, int a5);
void *__fastcall sph_luffa224_init_0(int a1); // idb
void *__fastcall sph_luffa224_addbits_and_close(unsigned int *a1, char a2, char a3, _BYTE *a4); // idb
void *__fastcall sph_luffa224_close(unsigned int *a1, _BYTE *a2);
void *__fastcall sph_luffa256_addbits_and_close(unsigned int *a1, char a2, char a3, _BYTE *a4); // idb
void *__fastcall sph_luffa256_close(unsigned int *a1, _BYTE *a2);
void *__fastcall sph_luffa384_init(int a1);
unsigned int __fastcall sph_luffa384(unsigned int result, char *a2, size_t a3); // idb
void *__fastcall sph_luffa384_addbits_and_close(unsigned int *a1, char a2, char a3, _BYTE *a4); // idb
void *__fastcall sph_luffa384_close(unsigned int *a1, _BYTE *a2);
void *__fastcall sph_luffa512_init(int a1); // idb
unsigned int __fastcall sph_luffa512(unsigned int result, char *a2, size_t a3); // idb
unsigned int *__fastcall sph_luffa512_addbits_and_close(unsigned int *a1, char a2, char a3, _BYTE *a4); // idb
unsigned int *__fastcall sph_luffa512_close(unsigned int *a1, _BYTE *a2);
int __fastcall sub_C13E8(_DWORD *a1, _DWORD *a2);
int __fastcall sub_C6880(_DWORD *a1, unsigned int *a2);
_DWORD *__fastcall sph_shavite224_0(_DWORD *result, char *src, unsigned int a3); // idb
unsigned int *__fastcall sph_shavite384_0(unsigned int *result, char *src, unsigned int a3); // idb
unsigned int __fastcall sub_CD834(int a1, char a2, int a3, int a4, unsigned int a5);
unsigned int __fastcall sub_CD988(int a1, char a2, int a3, int a4, unsigned int a5);
int __fastcall sph_shavite224_init_0(_DWORD *a1); // idb
int __fastcall sph_shavite224_close(_DWORD *a1, int a2); // idb
int __fastcall sph_shavite224_addbits_and_close(_DWORD *a1, char a2, int a3, int a4); // idb
int __fastcall sph_shavite256_init(_DWORD *a1);
int __fastcall sph_shavite256_close(_DWORD *a1, int a2); // idb
int __fastcall sph_shavite256_addbits_and_close(_DWORD *a1, char a2, int a3, int a4); // idb
int __fastcall sph_shavite384_init_0(_DWORD *a1); // idb
int __fastcall sph_shavite384_close(_DWORD *a1, int a2); // idb
int __fastcall sph_shavite384_addbits_and_close(_DWORD *a1, char a2, int a3, int a4); // idb
int __fastcall sph_shavite512_init(_DWORD *a1);
int __fastcall sph_shavite512_close(_DWORD *a1, int a2); // idb
int __fastcall sph_shavite512_addbits_and_close(_DWORD *a1, char a2, int a3, int a4); // idb
int __fastcall sub_CE010(unsigned __int8 *a1, int a2);
unsigned __int8 *__fastcall sph_simd224_0(unsigned __int8 *result, char *src, size_t a3); // idb
unsigned int __fastcall sub_D2AF4(_DWORD *s, char a2, int a3, int a4, int a5);
int __fastcall sub_D2BFC(unsigned __int8 *a1, _DWORD *a2);
int __fastcall sub_D3600(int a1, int a2);
_DWORD *__fastcall sph_simd384_0(_DWORD *result, char *src, size_t a3); // idb
unsigned int __fastcall sub_DBB6C(_DWORD *s, char a2, int a3, int a4, int a5);
int __fastcall sph_simd224_init_0(_DWORD *a1); // idb
int __fastcall sph_simd224_addbits_and_close(_DWORD *a1, char a2, int a3, int a4); // idb
int __fastcall sph_simd224_close(_DWORD *a1, int a2);
int __fastcall sph_simd256_init(_DWORD *a1);
int __fastcall sph_simd256_addbits_and_close(_DWORD *a1, char a2, int a3, int a4); // idb
int __fastcall sph_simd256_close(_DWORD *a1, int a2);
void *__fastcall sph_simd384_init(_DWORD *a1); // idb
void *__fastcall sph_simd384_addbits_and_close(_DWORD *a1, char a2, int a3, int a4); // idb
void *__fastcall sph_simd384_close(_DWORD *a1, int a2);
void *__fastcall sph_simd512_init(_DWORD *a1);
void *__fastcall sph_simd512_addbits_and_close(_DWORD *a1, char a2, int a3, int a4); // idb
void *__fastcall sph_simd512_close(_DWORD *a1, int a2);
void __fastcall sub_DBF20(int a1);
_DWORD *__fastcall sub_DBF5C(_DWORD *result, int *a2, unsigned int a3);
int __fastcall pipe_elem_size(int a1);
_DWORD *__fastcall pipe_new(int a1, int a2); // idb
int __fastcall pipe_producer_new(int a1); // idb
int __fastcall pipe_consumer_new(int a1); // idb
void __fastcall pipe_free(int a1); // idb
void __fastcall pipe_producer_free(int a1); // idb
void __fastcall pipe_consumer_free(int a1); // idb
_DWORD *__fastcall _pipe_push(_DWORD *result, char *a2, size_t a3); // idb
_DWORD *__fastcall pipe_push(_DWORD *a1, char *a2, int a3);
unsigned int __fastcall pipe_pop(int *a1, char *a2, int a3);
unsigned int __fastcall pipe_pop_eager(int a1, char *a2, int a3); // idb
int __fastcall pipe_reserve(pthread_mutex_t *mutex, int a2); // idb
int __fastcall sub_DCE94(unsigned int a1, unsigned int a2);
int __fastcall sub_DCEB0(int a1, unsigned int a2);
int __fastcall divsi3_skip_div0_test(int result, unsigned int a2); // idb
int __fastcall sub_DD144(int a1, unsigned int a2);
int __fastcall sub_DD46C(__int64 a1);
int __fastcall sub_DD47C(__int64 a1);
int __fastcall sub_DD668(__int64 a1);
int __fastcall sub_DD794(unsigned __int64 a1, unsigned __int64 a2);
int __fastcall _udivmoddi4(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 *a3);
int __fastcall init(int a1, int a2, int a3);
int _libc_csu_fini(); // weak
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_2CF0C; // weak
_UNKNOWN loc_2D1A0; // weak
_UNKNOWN loc_30D40; // weak
_UNKNOWN loc_4DEA0; // weak
_UNKNOWN loc_61A80; // weak
_UNKNOWN loc_7A120; // weak
_UNKNOWN loc_DCEF8; // weak
__int16 word_DEA70 = 44; // weak
char *off_DEC5C[9] =
{
  "ckb_2040",
  "ckb_2042",
  "kda_2110",
  "hns_2130",
  "dcr_1727",
  "dash_1766",
  "eth_1798",
  "ltc_1489",
  "unkonw"
}; // weak
char *off_DEC60[8] =
{
  "ckb_2042",
  "kda_2110",
  "hns_2130",
  "dcr_1727",
  "dash_1766",
  "eth_1798",
  "ltc_1489",
  "unkonw"
}; // weak
char *off_DECA8 = "algo"; // weak
_UNKNOWN unk_DEDB8; // weak
char aGetValueFromLo[25] = "get_value_from_lower_hex"; // weak
char *off_E1240 = "object"; // weak
char aSetBaudBase_0[14] = "set_baud_base"; // weak
char *off_E4E38[2] = { "air_out", "unkonw" }; // weak
_UNKNOWN unk_E4E58; // weak
char *off_E4F24[2] = { "AT24C02D", "unknow" }; // weak
char aGlobalIdxInitD_1[21] = "global_idx_init_dash"; // weak
_UNKNOWN unk_E7048; // weak
char aPqt[4] = "PQT"; // weak
_UNKNOWN unk_EC098; // weak
_UNKNOWN unk_EC458; // weak
_UNKNOWN unk_EC498; // weak
int dword_EC508[8] =
{
  -1056596264,
  914150663,
  812702999,
  -150054599,
  -4191439,
  1750603025,
  1694076839,
  -1090891868
}; // weak
int dword_EC528[8] =
{
  1779033703,
  -1150833019,
  1013904242,
  -1521486534,
  1359893119,
  -1694144372,
  528734635,
  1541459225
}; // weak
int dword_EC548[16] =
{
  -1056596264,
  -876896931,
  914150663,
  1654270250,
  812702999,
  -1856437926,
  -150054599,
  355462360,
  -4191439,
  1731405415,
  1750603025,
  -1900787065,
  1694076839,
  -619958771,
  -1090891868,
  1203062813
}; // weak
int dword_EC588[16] =
{
  -205731576,
  1779033703,
  -2067093701,
  -1150833019,
  -23791573,
  1013904242,
  1595750129,
  -1521486534,
  -1377402159,
  1359893119,
  725511199,
  -1694144372,
  -79577749,
  528734635,
  327033209,
  1541459225
}; // weak
_UNKNOWN unk_EC5E8; // weak
_UNKNOWN unk_EC700; // weak
_UNKNOWN unk_EC7B8; // weak
_WORD crc_itu_t_table[256] =
{
  0,
  4129,
  8258,
  12387,
  16516,
  20645,
  24774,
  28903,
  -32504,
  -28375,
  -24246,
  -20117,
  -15988,
  -11859,
  -7730,
  -3601,
  4657,
  528,
  12915,
  8786,
  21173,
  17044,
  29431,
  25302,
  -27847,
  -31976,
  -19589,
  -23718,
  -11331,
  -15460,
  -3073,
  -7202,
  9314,
  13379,
  1056,
  5121,
  25830,
  29895,
  17572,
  21637,
  -23190,
  -19125,
  -31448,
  -27383,
  -6674,
  -2609,
  -14932,
  -10867,
  13907,
  9842,
  5649,
  1584,
  30423,
  26358,
  22165,
  18100,
  -18597,
  -22662,
  -26855,
  -30920,
  -2081,
  -6146,
  -10339,
  -14404,
  18628,
  22757,
  26758,
  30887,
  2112,
  6241,
  10242,
  14371,
  -13876,
  -9747,
  -5746,
  -1617,
  -30392,
  -26263,
  -22262,
  -18133,
  23285,
  19156,
  31415,
  27286,
  6769,
  2640,
  14899,
  10770,
  -9219,
  -13348,
  -1089,
  -5218,
  -25735,
  -29864,
  -17605,
  -21734,
  27814,
  31879,
  19684,
  23749,
  11298,
  15363,
  3168,
  7233,
  -4690,
  -625,
  -12820,
  -8755,
  -21206,
  -17141,
  -29336,
  -25271,
  32407,
  28342,
  24277,
  20212,
  15891,
  11826,
  7761,
  3696,
  -97,
  -4162,
  -8227,
  -12292,
  -16613,
  -20678,
  -24743,
  -28808,
  -28280,
  -32343,
  -20022,
  -24085,
  -12020,
  -16083,
  -3762,
  -7825,
  4224,
  161,
  12482,
  8419,
  20484,
  16421,
  28742,
  24679,
  -31815,
  -27752,
  -23557,
  -19494,
  -15555,
  -11492,
  -7297,
  -3234,
  689,
  4752,
  8947,
  13010,
  16949,
  21012,
  25207,
  29270,
  -18966,
  -23093,
  -27224,
  -31351,
  -2706,
  -6833,
  -10964,
  -15091,
  13538,
  9411,
  5280,
  1153,
  29798,
  25671,
  21540,
  17413,
  -22565,
  -18438,
  -30823,
  -26696,
  -6305,
  -2178,
  -14563,
  -10436,
  9939,
  14066,
  1681,
  5808,
  26199,
  30326,
  17941,
  22068,
  -9908,
  -13971,
  -1778,
  -5841,
  -26168,
  -30231,
  -18038,
  -22101,
  22596,
  18533,
  30726,
  26663,
  6336,
  2273,
  14466,
  10403,
  -13443,
  -9380,
  -5313,
  -1250,
  -29703,
  -25640,
  -21573,
  -17510,
  19061,
  23124,
  27191,
  31254,
  2801,
  6864,
  10931,
  14994,
  -722,
  -4849,
  -8852,
  -12979,
  -16982,
  -21109,
  -25112,
  -29239,
  31782,
  27655,
  23652,
  19525,
  15522,
  11395,
  7392,
  3265,
  -4321,
  -194,
  -12451,
  -8324,
  -20581,
  -16454,
  -28711,
  -24584,
  28183,
  32310,
  20053,
  24180,
  11923,
  16050,
  3793,
  7920
}; // weak
unsigned __int8 chCRCHTalbe[256] =
{
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u
}; // weak
_UNKNOWN unk_ECFCC; // weak
_UNKNOWN unk_ED744; // weak
_UNKNOWN unk_ED7C4; // weak
_UNKNOWN unk_ED844; // weak
_UNKNOWN unk_ED8C4; // weak
_DWORD dword_ED944[1025] =
{
  -1520213050,
  -2072216328,
  -1720223762,
  -1921287178,
  234025727,
  -1117033514,
  -1318096930,
  1422247313,
  1345335392,
  50397442,
  -1452841010,
  2099981142,
  436141799,
  1658312629,
  -424957107,
  -1703512340,
  1170918031,
  -1652391393,
  1086966153,
  -2021818886,
  368769775,
  -346465870,
  -918075506,
  200339707,
  -324162239,
  1742001331,
  -39673249,
  -357585083,
  -1080255453,
  -140204973,
  -1770884380,
  1539358875,
  -1028147339,
  486407649,
  -1366060227,
  1780885068,
  1513502316,
  1094664062,
  49805301,
  1338821763,
  1546925160,
  -190470831,
  887481809,
  150073849,
  -1821281822,
  1943591083,
  1395732834,
  1058346282,
  201589768,
  1388824469,
  1696801606,
  1589887901,
  672667696,
  -1583966665,
  251987210,
  -1248159185,
  151455502,
  907153956,
  -1686077413,
  1038279391,
  652995533,
  1764173646,
  -843926913,
  -1619692054,
  453576978,
  -1635548387,
  1949051992,
  773462580,
  756751158,
  -1301385508,
  -296068428,
  -73359269,
  -162377052,
  1295727478,
  1641469623,
  -827083907,
  2066295122,
  1055122397,
  1898917726,
  -1752923117,
  -179088474,
  1758581177,
  0,
  753790401,
  1612718144,
  536673507,
  -927878791,
  -312779850,
  -1100322092,
  1187761037,
  -641810841,
  1262041458,
  -565556588,
  -733197160,
  -396863312,
  1255133061,
  1808847035,
  720367557,
  -441800113,
  385612781,
  -985447546,
  -682799718,
  1429418854,
  -1803188975,
  -817543798,
  284817897,
  100794884,
  -2122350594,
  -263171936,
  1144798328,
  -1163944155,
  -475486133,
  -212774494,
  -22830243,
  -1069531008,
  -1970303227,
  -1382903233,
  -1130521311,
  1211644016,
  83228145,
  -541279133,
  -1044990345,
  1977277103,
  1663115586,
  806359072,
  452984805,
  250868733,
  1842533055,
  1288555905,
  336333848,
  890442534,
  804056259,
  -513843266,
  -1567123659,
  -867941240,
  957814574,
  1472513171,
  -223893675,
  -2105639172,
  1195195770,
  -1402706744,
  -413311558,
  723065138,
  -1787595802,
  -1604296512,
  -1736343271,
  -783331426,
  2145180835,
  1713513028,
  2116692564,
  -1416589253,
  -2088204277,
  -901364084,
  703524551,
  -742868885,
  1007948840,
  2044649127,
  -497131844,
  487262998,
  1994120109,
  1004593371,
  1446130276,
  1312438900,
  503974420,
  -615954030,
  168166924,
  1814307912,
  -463709000,
  1573044895,
  1859376061,
  -273896381,
  -1503501628,
  -1466855111,
  -1533700815,
  937747667,
  -1954973198,
  854058965,
  1137232011,
  1496790894,
  -1217565222,
  -1936880383,
  1691735473,
  -766620004,
  -525751991,
  -1267962664,
  -95005012,
  133494003,
  636152527,
  -1352309302,
  -1904575756,
  -374428089,
  403179536,
  -709182865,
  -2005370640,
  1864705354,
  1915629148,
  605822008,
  -240736681,
  -944458637,
  1371981463,
  602466507,
  2094914977,
  -1670089496,
  555687742,
  -582268010,
  -591544991,
  -2037675251,
  -2054518257,
  -1871679264,
  1111375484,
  -994724495,
  -1436129588,
  -666351472,
  84083462,
  32962295,
  302911004,
  -1553899070,
  1597322602,
  -111716434,
  -793134743,
  -1853454825,
  1489093017,
  656219450,
  -1180787161,
  954327513,
  335083755,
  -1281845205,
  856756514,
  -1150719534,
  1893325225,
  -1987146233,
  -1483434957,
  -1231316179,
  572399164,
  -1836611819,
  552200649,
  1238290055,
  -11184726,
  2015897680,
  2061492133,
  -1886614525,
  -123625127,
  -2138470135,
  386731290,
  -624967835,
  837215959,
  -968736124,
  -1201116976,
  -1019133566,
  -1332111063,
  1999449434,
  286199582,
  -877612933,
  -61582168,
  -692339859,
  974525996,
  -962239645,
  -125535108,
  -291932297,
  -158499973,
  -15863054,
  -692229269,
  -558796945,
  -1856715323,
  1615867952,
  33751297,
  -827758745,
  1451043627,
  -417726722,
  -1251813417,
  1306962859,
  -325421450,
  -1891251510,
  530416258,
  -1992242743,
  -91783811,
  -283772166,
  -1293199015,
  -1899411641,
  -83103504,
  1106029997,
  -1285040940,
  1610457762,
  1173008303,
  599760028,
  1408738468,
  -459902350,
  -1688485696,
  1975695287,
  -518193667,
  1034851219,
  1282024998,
  1817851446,
  2118205247,
  -184354825,
  -2091922228,
  1750873140,
  1374987685,
  -785062427,
  -116854287,
  -493653647,
  -1418471208,
  1649619249,
  708777237,
  135005188,
  -1789737017,
  1181033251,
  -1654733885,
  807933976,
  933336726,
  168756485,
  800430746,
  235472647,
  607523346,
  463175808,
  -549592350,
  -853087253,
  1315514151,
  2144187058,
  -358648459,
  303761673,
  496927619,
  1484008492,
  875436570,
  908925723,
  -592286098,
  -1259447718,
  1543217312,
  -1527360942,
  1984772923,
  -1218324778,
  2110698419,
  1383803177,
  -583080989,
  1584475951,
  328696964,
  -1493871789,
  -1184312879,
  0,
  -1054020115,
  1080041504,
  -484442884,
  2043195825,
  -1225958565,
  -725718422,
  -1924740149,
  1742323390,
  1917532473,
  -1797371318,
  -1730917300,
  -1326950312,
  -2058694705,
  -1150562096,
  -987041809,
  1340451498,
  -317260805,
  -2033892541,
  -1697166003,
  1716859699,
  294946181,
  -1966127803,
  -384763399,
  67502594,
  -25067649,
  -1594863536,
  2017737788,
  632987551,
  1273211048,
  -1561112239,
  1576969123,
  -2134884288,
  92966799,
  1068339858,
  566009245,
  1883781176,
  -251333131,
  1675607228,
  2009183926,
  -1351230758,
  1113792801,
  540020752,
  -451215361,
  -49351693,
  -1083321646,
  -2125673011,
  403966988,
  641012499,
  -1020269332,
  -1092526241,
  899848087,
  -1999879100,
  775493399,
  -1822964540,
  1441965991,
  -58556802,
  2051489085,
  -928226204,
  -1159242403,
  841685273,
  -426413197,
  -1063231392,
  429425025,
  -1630449841,
  -1551901476,
  1147544098,
  1417554474,
  1001099408,
  193169544,
  -1932900794,
  -953553170,
  1809037496,
  675025940,
  -1485185314,
  -1126015394,
  371002123,
  -1384719397,
  -616832800,
  1683370546,
  1951283770,
  337512970,
  -1831122615,
  201983494,
  1215046692,
  -1192993700,
  -1621245246,
  -1116810285,
  1139780780,
  -995728798,
  967348625,
  832869781,
  -751311644,
  -225740423,
  -718084121,
  -1958491960,
  1851340599,
  -625513107,
  25988493,
  -1318791723,
  -1663938994,
  1239460265,
  -659264404,
  -1392880042,
  -217582348,
  -819598614,
  -894474907,
  -191989126,
  1206496942,
  270010376,
  1876277946,
  -259491720,
  1248797989,
  1550986798,
  941890588,
  1475454630,
  1942467764,
  -1756248378,
  -886839064,
  -1585652259,
  -392399756,
  1042358047,
  -1763882165,
  1641856445,
  226921355,
  260409994,
  -527404944,
  2084716094,
  1908716981,
  -861247898,
  -1864873912,
  100991747,
  -150866186,
  470945294,
  -1029480095,
  1784624437,
  -1359390889,
  1775286713,
  395413126,
  -1722236479,
  975641885,
  666476190,
  -650583583,
  -351012616,
  733190296,
  573772049,
  -759469719,
  -1452221991,
  126455438,
  866620564,
  766942107,
  1008868894,
  361924487,
  -920589847,
  -2025206066,
  -1426107051,
  1350051880,
  -1518673953,
  59739276,
  1509466529,
  159418761,
  437718285,
  1708834751,
  -684595482,
  -2067381694,
  -793221016,
  -2101132991,
  699439513,
  1517759789,
  504434447,
  2076946608,
  -1459858348,
  1842789307,
  742004246,
  1667483301,
  2088564868,
  2004348569,
  2071721613,
  -218956019,
  1802229437,
  1869602481,
  -976907948,
  808476752,
  16843267,
  1734856361,
  724260477,
  -16849127,
  -673729182,
  -1414836762,
  1987505306,
  -892694715,
  -2105401443,
  -909539008,
  2105408135,
  -84218091,
  1499050731,
  1195871945,
  -252642549,
  -1381154324,
  -724257945,
  -1566416899,
  -1347467798,
  -1667488833,
  -1532734473,
  1920132246,
  -1061119141,
  -1212713534,
  -33693412,
  -1819066962,
  640044138,
  909536346,
  1061125697,
  -134744830,
  -859012273,
  875849820,
  -1515892236,
  -437923532,
  -235800312,
  1903288979,
  -656888973,
  825320019,
  353708607,
  67373068,
  -943221422,
  589514341,
  -1010590370,
  404238376,
  -1768540255,
  84216335,
  -1701171275,
  117902857,
  303178806,
  -2139087973,
  -488448195,
  -336868058,
  656887401,
  -1296924723,
  1970662047,
  151589403,
  -2088559202,
  741103732,
  437924910,
  454768173,
  1852759218,
  1515893998,
  -1600103429,
  1381147894,
  993752653,
  -690571423,
  -1280082482,
  690573947,
  -471605954,
  791633521,
  -2071719017,
  1397991157,
  -774784664,
  0,
  -303185620,
  538984544,
  -50535649,
  -1313769016,
  1532737261,
  1785386174,
  -875852474,
  -1094817831,
  960066123,
  1246401758,
  1280088276,
  1482207464,
  -808483510,
  -791626901,
  -269499094,
  -1431679003,
  -67375850,
  1128498885,
  1296931543,
  859006549,
  -2054876780,
  1162185423,
  -101062384,
  33686534,
  2139094657,
  1347461360,
  1010595908,
  -1616960070,
  -1465365533,
  1364304627,
  -1549574658,
  1077969088,
  -1886452342,
  -1835909203,
  -1650646596,
  943222856,
  -168431356,
  -1128504353,
  -1229555775,
  -623202443,
  555827811,
  269492272,
  -6886,
  -202113778,
  -757940371,
  -842170036,
  202119188,
  320022069,
  -320027857,
  1600110305,
  -1751698014,
  1145342156,
  387395129,
  -993750185,
  -1482205710,
  2122251394,
  1027439175,
  1684326572,
  1566423783,
  421081643,
  1936975509,
  1616953504,
  -2122245736,
  1330618065,
  -589520001,
  572671078,
  707417214,
  -1869595733,
  -2004350077,
  1179028682,
  -286341335,
  -1195873325,
  336865340,
  -555833479,
  1583267042,
  185275933,
  -606360202,
  -522134725,
  842163286,
  976909390,
  168432670,
  1229558491,
  101059594,
  606357612,
  1549580516,
  -1027432611,
  -741098130,
  -1397996561,
  1650640038,
  -1852753496,
  -1785384540,
  -454765769,
  2038035083,
  -404237006,
  -926381245,
  926379609,
  1835915959,
  -1920138868,
  -707415708,
  1313774802,
  -1448523296,
  1819072692,
  1448520954,
  -185273593,
  -353710299,
  1701169839,
  2054878350,
  -1364310039,
  134746136,
  -1162186795,
  2021191816,
  623200879,
  774790258,
  471611428,
  -1499047951,
  -1263242297,
  -960063663,
  -387396829,
  -572677764,
  1953818780,
  522141217,
  1263245021,
  -1111662116,
  -1953821306,
  -1970663547,
  1886445712,
  1044282434,
  -1246400060,
  1718013098,
  1212715224,
  50529797,
  -151587071,
  235805714,
  1633796771,
  892693087,
  1465364217,
  -1179031088,
  -2038032495,
  -1044276904,
  488454695,
  -1633802311,
  -505292488,
  -117904621,
  -1734857805,
  286335539,
  1768542907,
  -640046736,
  -1903294583,
  -1802226777,
  -1684329034,
  505297954,
  -2021190254,
  -370554592,
  -825325751,
  1431677695,
  673730680,
  -538991238,
  -1936981105,
  -1583261192,
  -1987507840,
  218962455,
  -1077975590,
  -421079247,
  1111655622,
  1751699640,
  1094812355,
  -1718015568,
  757946999,
  252648977,
  -1330611253,
  1414834428,
  -1145344554,
  370551866,
  1673962851,
  2096661628,
  2012125559,
  2079755643,
  -218165774,
  1809235307,
  1876865391,
  -980331323,
  811618352,
  16909057,
  1741597031,
  727088427,
  -18408962,
  -675978537,
  -1420958037,
  1995217526,
  -896580150,
  -2111857278,
  -913751863,
  2113570685,
  -84994566,
  1504897881,
  1200539975,
  -251982864,
  -1388188499,
  -726439980,
  -1570767454,
  -1354372433,
  -1675378788,
  -1538000988,
  1927583346,
  -1063560256,
  -1217019209,
  -35578627,
  -1824674157,
  642542118,
  913070646,
  1065238847,
  -134937865,
  -863809588,
  879254580,
  -1521355611,
  -439274267,
  -235337487,
  1910674289,
  -659852328,
  828527409,
  355090197,
  67636228,
  -946515257,
  591815971,
  -1013096765,
  405809176,
  -1774739050,
  84545285,
  -1708149350,
  118360327,
  304363026,
  -2145674368,
  -488686110,
  -338876693,
  659450151,
  -1300247118,
  1978310517,
  152181513,
  -2095210877,
  743994412,
  439627290,
  456535323,
  1859957358,
  1521806938,
  -1604584544,
  1386542674,
  997608763,
  -692624938,
  -1283600717,
  693271337,
  -472039709,
  794718511,
  -2079090812,
  1403450707,
  -776378159,
  0,
  -306107155,
  541089824,
  -52224004,
  -1317418831,
  1538714971,
  1792327274,
  -879933749,
  -1100490306,
  963791673,
  1251270218,
  1285084236,
  1487988824,
  -813348145,
  -793023536,
  -272291089,
  -1437604438,
  -68348165,
  1132905795,
  1301993293,
  862344499,
  -2062445435,
  1166724933,
  -102166279,
  33818114,
  2147385727,
  1352724560,
  1014514748,
  -1624917345,
  -1471421528,
  1369633617,
  -1554121053,
  1082179648,
  -1895462257,
  -1841320558,
  -1658733411,
  946882616,
  -168753931,
  -1134305348,
  -1233665610,
  -626035238,
  557998881,
  270544912,
  -1762561,
  -201519373,
  -759206446,
  -847164211,
  202904588,
  321271059,
  -322752532,
  1606345055,
  -1758092649,
  1149815876,
  388905239,
  -996976700,
  -1487539545,
  2130477694,
  1031423805,
  1690872932,
  1572530013,
  422718233,
  1944491379,
  1623236704,
  -2129028991,
  1335808335,
  -593264676,
  574907938,
  710180394,
  -1875137648,
  -2012511352,
  1183631942,
  -288937490,
  -1200893000,
  338181140,
  -559449634,
  1589437022,
  185998603,
  -609388837,
  -522503200,
  845436466,
  980700730,
  169090570,
  1234361161,
  101452294,
  608726052,
  1555620956,
  -1029743166,
  -742560045,
  -1404833876,
  1657054818,
  -1858492271,
  -1791908715,
  -455919644,
  2045938553,
  -405458201,
  -930397240,
  929978679,
  1843050349,
  -1929278323,
  -709794603,
  1318900302,
  -1454776151,
  1826141292,
  1454176854,
  -185399308,
  -355523094,
  1707781989,
  2062847610,
  -1371018834,
  135272456,
  -1167075910,
  2029029496,
  625635109,
  777810478,
  473441308,
  -1504185946,
  -1267480652,
  -963161658,
  -389340184,
  -576619299,
  1961401460,
  524165407,
  1268178251,
  -1117659971,
  -1962047861,
  -1978694262,
  1893765232,
  1048330814,
  -1250835275,
  1724688998,
  1217452104,
  50726147,
  -151584266,
  236720654,
  1640145761,
  896163637,
  1471084887,
  -1184247623,
  -2045275770,
  -1046914879,
  490350365,
  -1641563746,
  -505857823,
  -118811656,
  -1741966440,
  287453969,
  1775418217,
  -643206951,
  -1912108658,
  -1808554092,
  -1691502949,
  507257374,
  -2028629369,
  -372694807,
  -829994546,
  1437269845,
  676362280,
  -542803233,
  -1945923700,
  -1587939167,
  -1995865975,
  219813645,
  -1083843905,
  -422104602,
  1115997762,
  1758509160,
  1099088705,
  -1725321063,
  760903469,
  253628687,
  -1334064208,
  1420360788,
  -1150429509,
  371997206,
  0
}; // weak
_QWORD qword_EE948[256] =
{
  -4132730006030503226LL,
  -539047019380510728LL,
  -1253751459939328274LL,
  -680615785620800778LL,
  -68146532174010113LL,
  -2973018020288656682LL,
  -2399952645993785634LL,
  -7974685284245934703LL,
  6940259164160561248LL,
  144964032577996546LL,
  -3555161031839830322LL,
  6232327157277249878LL,
  -1794168595447821081LL,
  -5376610045693389899LL,
  5613343524669979725LL,
  -1397589549593044500LL,
  -8123079965105241969LL,
  2278045966340498207LL,
  -8556828570679228023LL,
  -394083029752846086LL,
  -1218851249403735825LL,
  -5554205910300715854LL,
  -8157981275169173874LL,
  -356931036449478917LL,
  4750314849306635841LL,
  -5519304651777172813LL,
  6916893634425799519LL,
  5037991028614062149LL,
  2575855417214826787LL,
  6050487156059820371LL,
  -1975158695585036828LL,
  -7252152277477263717LL,
  8485602336333178997LL,
  -2225665366713645599LL,
  4444625026341786685LL,
  5506381438015959628LL,
  7807791422239572588LL,
  9097830637817281918LL,
  -791805576357678091LL,
  -8984929946756361597LL,
  7520115157031488616LL,
  5905523166432155217LL,
  -3371866415327048239LL,
  -501895069027474951LL,
  -2120105058666394398LL,
  -6092440566617522517LL,
  7085223196738557794LL,
  3044244512336603946LL,
  579856130311986184LL,
  -7687026679944420459LL,
  5072615240255924550LL,
  -7107205905805836387LL,
  3470129582080280624LL,
  4008607157484834615LL,
  724820128529718026LL,
  3437758089523424047LL,
  1011370493763851534LL,
  2609352586403937828LL,
  1989243818338594075LL,
  -2360548904282908449LL,
  -3664098953908279347LL,
  5650219536259741006LL,
  9209296418857825151LL,
  -1540284147086765846LL,
  1304676293201968914LL,
  2134207842326520861LL,
  6373913558653912152LL,
  3760057578515744308LL,
  3903895711119786294LL,
  -2543790735647501860LL,
  -5409259478498828876LL,
  6628091486423895387LL,
  -6559964539331172956LL,
  8524730079150317942LL,
  -5232771947449609033LL,
  9065458294843847805LL,
  5943525060815740754LL,
  -2504387036886949923LL,
  6805427853385256286LL,
  1411639487974519059LL,
  -6416126415317196122LL,
  -5086699538363186759LL,
  0LL,
  -4527074801173088831LL,
  4638849042495889472LL,
  -2080701368495914269LL,
  8775530246867991161LL,
  -5265421354484852042LL,
  -3116856144302633516LL,
  -8266918097709283443LL,
  7483239239932450663LL,
  8235927982688808818LL,
  -7719676112749859436LL,
  -7434269359936634984LL,
  -5699169934288645200LL,
  -8842235271952049275LL,
  -4941735505785190725LL,
  -4239416128151045179LL,
  5757181648683957071LL,
  -1362689382007777299LL,
  -8735550249359846778LL,
  -7289305370308970342LL,
  7374025361920596326LL,
  1266675498346853905LL,
  -8444513962316611446LL,
  -1652599854977721879LL,
  289928065155993092LL,
  -107550273884887298LL,
  -6849874926400459872LL,
  8666316343085937784LL,
  2718567606894587941LL,
  5468379569402574155LL,
  -6704910902412530526LL,
  6773055510411822173LL,
  -9169298760443110528LL,
  399143085646643205LL,
  4588463150355764031LL,
  2430891427587161633LL,
  8090963950110812272LL,
  -1079464180659192335LL,
  7196688960598972771LL,
  8629440425986895735LL,
  -5803655993621532497LL,
  4783813075073886018LL,
  2319424521247944736LL,
  -1938006693691601947LL,
  -211984664778051587LL,
  -4652951001509721921LL,
  -9129893944974092927LL,
  1735064791040140312LL,
  2753190719007979814LL,
  -4382110802955357501LL,
  -4692355842748938562LL,
  3864769067831117877LL,
  -8589477951944276088LL,
  3330794877570737454LL,
  -7829721286028203373LL,
  6193199414460110933LL,
  -251388363538603524LL,
  8811280341303669626LL,
  -3986657708614932536LL,
  -4978888598616897350LL,
  3615093614658277170LL,
  -1831320571571059994LL,
  -4566478517113766976LL,
  1844279794350664217LL,
  -7002772614441011554LL,
  -6665506112713710941LL,
  4928777107651882564LL,
  6088489024673207892LL,
  4299661002353859899LL,
  829531626435155211LL,
  -8301819364822890100LL,
  -4095578029907264313LL,
  7769789553626187115LL,
  2899280514118872104LL,
  -6378973339665617753LL,
  -4836193932402654788LL,
  1593478389663478038LL,
  -5947494126225573971LL,
  -2649333408558377253LL,
  7230187229316554340LL,
  8380891946546275956LL,
  1449640257059436052LL,
  -7864622544551746414LL,
  867532395520070156LL,
  5218705172807875656LL,
  -5123852588244561992LL,
  -6963367773201794913LL,
  -4796789134113763395LL,
  4895278838934300995LL,
  -4276568130044480060LL,
  4154696978365930041LL,
  3577092819803162161LL,
  -3226902417109316909LL,
  -969400341436664590LL,
  -3084207811025533995LL,
  -8411864538101231989LL,
  7951629520483353966LL,
  -2686485401861744422LL,
  111466906339216897LL,
  -5664268649994904143LL,
  -7146610704094727780LL,
  5323415545414644297LL,
  -2831449391489409064LL,
  -5982395393339180628LL,
  -934500182441461005LL,
  -3520260821304237873LL,
  -3841693718987267894LL,
  -824453909634777612LL,
  5181829118267778887LL,
  1159712260623972368LL,
  8058591632907570031LL,
  -1114364365424593936LL,
  5363669171025607498LL,
  6661589755141474908LL,
  4045481975055406136LL,
  6337037504113827671LL,
  8342890077932888435LL,
  -7543188581700639593LL,
  -3809045394300227893LL,
  -6810470110931442271LL,
  -1685248136714430488LL,
  4476996269786750270LL,
  -7575837988735882602LL,
  7051724970971307617LL,
  974495581702560781LL,
  1118333705716538127LL,
  -2265069082654323744LL,
  8953992539573500540LL,
  8197926088305223281LL,
  -3698999121493546548LL,
  -8009586568539675760LL,
  433766197760035078LL,
  -647967478113897225LL,
  2022740987527703068LL,
  -4421514493125837630LL,
  7665079155249220458LL,
  -5838557303685464402LL,
  7624825529638257257LL,
  1698189836028526359LL,
  -7397116310055259751LL,
  4190445973273137978LL,
  2862405696548304679LL,
  -2794297441136373287LL,
  -1507635822399725845LL,
  3148956010242041131LL,
  2464388553825941282LL,
  -3261802576104520494LL,
  -6237404599195518551LL,
  542981175300359943LL,
  3722056809430827315LL,
  3293919965509446701LL,
  4333158171542968892LL,
  1554351746374809621LL,
  -3954009426878223927LL,
  -8698397173708268409LL,
  -6125089990832901974LL,
  5798561028237744208LL,
  -6522811437909398619LL,
  256430895966882051LL,
  6483127462435965529LL,
  684567602447225353LL,
  1880028789257872154LL,
  7339401150278733925LL,
  -2940369712781753129LL,
  -8879388373373823612LL,
  -3406766600092449840LL,
  -9024334736455181182LL,
  3003991986254111273LL,
  6518877556871643994LL,
  2166579085771484446LL,
  8920494270855921019LL,
  -6270053980460566616LL,
  7914753508893592685LL,
  3186956779326956076LL
}; // weak
_DWORD dword_EF148[514] =
{
  -190450638,
  -960060009,
  -1752918161,
  -117930773,
  -1332105122,
  -286352953,
  -1936880518,
  -151613961,
  386734056,
  -61979,
  -591537142,
  -690569801,
  -927873002,
  -555830873,
  -61539219,
  -1852746695,
  -263130992,
  1616924864,
  84083975,
  33686276,
  -525737938,
  -825316985,
  -2021816367,
  1448508844,
  723069900,
  -404284971,
  -1503484397,
  -1246403983,
  837169532,
  1296950938,
  -1248152231,
  -320038205,
  -817508544,
  -1886436091,
  -1130513245,
  522165566,
  -1069498295,
  -1987493879,
  -1836608920,
  -84244497,
  1058357200,
  -269543995,
  652945044,
  -1296897153,
  1086931150,
  -1903245049,
  487267814,
  -67433491,
  804007790,
  1094839426,
  -1452824294,
  -1280088195,
  486349891,
  1600126398,
  636101984,
  1162209930,
  -624960775,
  589545286,
  49742417,
  1398011814,
  -1583963835,
  -454781229,
  -312742538,
  -1684317395,
  1573018920,
  1970651882,
  605824197,
  -505340711,
  -374412844,
  1027452538,
  -1100300558,
  1280076440,
  -296030590,
  1819040472,
  -1019100227,
  2122203644,
  100796147,
  -168492303,
  -783298222,
  -2088546531,
  -463674228,
  1751669968,
  133433174,
  1364325538,
  1546935437,
  -774818631,
  403183841,
  -101119767,
  -1366053300,
  -488467489,
  -1787587266,
  -1414827187,
  -179047017,
  1650611140,
  1094664555,
  707411796,
  336335900,
  134745104,
  -162335133,
  -1785376207,
  -1352290327,
  1179018636,
  -497098113,
  -1650631135,
  2015918152,
  808462432,
  -123602737,
  926392686,
  286200091,
  168431380,
  -994720533,
  791655774,
  453581589,
  235800860,
  1513511550,
  606352968,
  -1231309139,
  454794038,
  1195198360,
  -539017819,
  1780902567,
  -842193279,
  -1150698507,
  1313761692,
  1288522803,
  2139082238,
  -1163937200,
  -353722417,
  756755775,
  303176484,
  -1180780124,
  488480314,
  -1670079292,
  1482192048,
  1915646534,
  875834984,
  1999468353,
  909520236,
  -843920111,
  -589516125,
  703474077,
  -1263210893,
  385553997,
  1532754870,
  32899493,
  -1532692909,
  -682764383,
  1987464684,
  -1553882348,
  -1212718731,
  1238255924,
  2105396986,
  -1921282593,
  1381137316,
  1111376543,
  -572703071,
  -1821273139,
  1583247804,
  -1567120719,
  320050982,
  83166370,
  -1499007657,
  -1201096703,
  -1179031447,
  0,
  0,
  1949070517,
  -1044304743,
  -1604280096,
  1077960832,
  555688386,
  -471654435,
  1137197882,
  2038024434,
  753740954,
  -1229525641,
  -641804019,
  -724255053,
  -901330361,
  -1920121343,
  1893298199,
  1734859214,
  -582230609,
  1920093156,
  2044623341,
  -1802183117,
  1741973503,
  -1734814677,
  602416019,
  -1330583429,
  -565518757,
  -2054862319,
  -1117012730,
  -1145345171,
  2116714171,
  -976934255,
  887436411,
  1330636190,
  974535383,
  -303229247,
  1422218450,
  -2037988073,
  1658282744,
  -1701128401,
  -11141223,
  1717982668,
  -1483429962,
  286364706,
  1255099072,
  -1970614513,
  806367449,
  -370601783,
  168167950,
  67372552,
  -1736337306,
  -16875033,
  200281003,
  -1600065445,
  -867906380,
  2021147888,
  -709175824,
  623229514,
  1055080053,
  1263264662,
  250810028,
  -1566379169,
  436083012,
  1566441146,
  1539333083,
  -2139045861,
  -2054519424,
  84249098,
  -324145965,
  1061137790,
  -541270018,
  555859010,
  -666314584,
  1886406880,
  201592061,
  -235862791,
  2061466137,
  1667489734,
  1489066031,
  2004337134,
  -1619681488,
  -1347455675,
  -1520196121,
  1111647108,
  1345343600,
  538980416,
  773467851,
  -437970223,
  302912239,
  -33747231,
  -1217546488,
  -1077973659,
  -733162411,
  -2122232807,
  1007959076,
  404231216,
  1597333369,
  640038220,
  1898934706,
  -1010618467,
  954284166,
  -1094786713,
  -39649848,
  892707434,
  1338789831,
  -2004300789,
  1262046053,
  774781276,
  -111675030,
  -1819060419,
  233966936,
  1431696042,
  -1652384415,
  -50560285,
  -918042189,
  2054834164,
  -273879257,
  -926372725,
  854012552,
  -1162156177,
  2100002127,
  842148708,
  -1533696958,
  -421095977,
  -73336005,
  -1061117797,
  -1281838166,
  421107762,
  1758554358,
  -1633758937,
  -2122350302,
  -1549566115,
  -1436112146,
  1145333384,
  -2105638186,
  1414823592,
  -424941859,
  993766262,
  -1635541355,
  185303830,
  1170884041,
  -1936930301,
  2066316220,
  -943249003,
  1859350021,
  1802228694,
  1144800364,
  673725520,
  -1954968788,
  -1482196651,
  1038237057,
  -1128471965,
  656222001,
  370548012,
  -1703503305,
  -1381140927,
  1295732118,
  -606389331,
  -94963042,
  1684297416,
  -766586202,
  1953779432,
  572400182,
  336862760,
  1994094308,
  -1835869377,
  503979538,
  202115608,
  -1267944196,
  1212705936,
  937703311,
  -1195842453,
  -413276296,
  -1616945883,
  -1301368305,
  -1111658911,
  720317033,
  1128525702,
  -240717515,
  -993745261,
  -475470886,
  960079986,
  -140183610,
  825336930,
  1496799626,
  -741132355,
  -2037676428,
  -218985473,
  1446139523,
  -707448143,
  -985414322,
  -1953807603,
  -346428539,
  1852725724,
  -1028144616,
  -623200337,
  -1886613618,
  16878594,
  -1402688483,
  -1313774471,
  1842507249,
  -1667444189,
  1004551026,
  1229578386,
  -944453857,
  -656886613,
  368711097,
  -1397949885,
  151456250,
  -202176515,
  1864724384,
  -808508027,
  -357570016,
  -892686449,
  -1987147395,
  -185299213,
  552149095,
  1195895182,
  672671800,
  269490208,
  1691706379,
  1869600222,
  -2088205453,
  -252671749,
  -1318080005,
  1246392212,
  -1770875190,
  1549562552,
  1814326356,
  943203440,
  150014047,
  1465381294,
  1388794401,
  1936967654,
  -212733084,
  -1751690955,
  1696818606,
  -875879539,
  -2072214491,
  -1583252391,
  -1080246441,
  -387408693,
  1663132509,
  1044259196,
  2094890218,
  -1768497865,
  2145156894,
  1633803458,
  -1853451876,
  218990106,
  -1803184997,
  252675358,
  -1416582325,
  -522153765,
  -968702278,
  2088518392,
  1472485158,
  1903281378,
  -441785047,
  -859002237,
  1943565283,
  -1869555653,
  251989769,
  101057804,
  50398196,
  -134807051,
  907163178,
  471601720,
  -22806980,
  -1027431521,
  -513810037,
  1785356244,
  284758206,
  -1364264633,
  1808820994,
  1768542418,
  -1466849089,
  387420462,
  -396826511,
  -1718003671,
  1764190547,
  976889716,
  -793128713,
  656914766,
  1211648145,
  -640075607,
  890451422,
  -336915507,
  -827076891,
  724284246,
  1429427575,
  572666692,
  -692333052,
  -757941313,
  -1871671239,
  -1448513463,
  -2138472313,
  117934350,
  -223874367,
  859023206,
  -1044987412,
  757970522,
  1713530458,
  1010573944,
  -1382896200,
  353735210,
  1612734633,
  -909565815,
  -615916708,
  -2021177067,
  452926128,
  -1431634097,
  -2005366568,
  1347451040,
  -1904570837,
  -1515881903,
  -1970304375,
  50564870,
  335024970,
  1499068594,
  -1686070382,
  151617554,
  957823267,
  437917492,
  1977251088,
  1701173962,
  1395741572,
  -673762891,
  1371951573,
  -2071673325,
  -742862077,
  -791627589,
  1589862108,
  -2105359585,
  -877605918,
  690597970,
  -1720215101,
  1515878324,
  856765229,
  505286972,
  1187726909,
  2071710710,
  536616887,
  -1465320373,
  1641439500,
  1835914970,
  1312444002,
  741096024,
  -197998906,
  -1516768091
}; // weak
_QWORD qword_EF950[256] =
{
  -8868828445443884808LL,
  -7365724491405660434LL,
  -8216944455539034378LL,
  1001231837162962943LL,
  -4776106171804494122LL,
  -5645322941993918754LL,
  6069159414800945553LL,
  5818914948986724448LL,
  217304192548012546LL,
  -6230764539228533042LL,
  9055761923954529878LL,
  1861441408096593895LL,
  7093633830708557237LL,
  -1830095433830216371LL,
  -7294787295337911060LL,
  4973609262237388687LL,
  -7116042975538110689LL,
  4614430677554268553LL,
  -8651535248180839686LL,
  1568729405706006511LL,
  -1477419361347784014LL,
  -3961126114129178994LL,
  859375037481155579LL,
  -1404507442331631295LL,
  7457302820679234483LL,
  -162660663112278177LL,
  -1546381834468702907LL,
  -4663799846548200669LL,
  -601790240288320685LL,
  -7578536079611534108LL,
  6570168410485201819LL,
  -4401602596433267339LL,
  2078732406302826977LL,
  -5874125826494808771LL,
  7681098530159742028LL,
  6546244132699008108LL,
  4754889993820667518LL,
  211957263239476725LL,
  5700942844065383299LL,
  6688096534267717736LL,
  -819083437551496879LL,
  3799169140624576977LL,
  642070844933274105LL,
  -7791316881019968798LL,
  8308461211226123179LL,
  6036219141534736994LL,
  4563344062369442346LL,
  869216770192050184LL,
  5922785821150385557LL,
  7317416345848071750LL,
  6782951410951495069LL,
  2909457474493362224LL,
  -6814235811617229001LL,
  1086512166512298506LL,
  -5377644620061921489LL,
  656429371612270094LL,
  3911475465864225828LL,
  -7262416569187362021LL,
  4442034935990640607LL,
  2774615558667619789LL,
  7610163533148671566LL,
  -3603358207219368065LL,
  -6931116106311472406LL,
  1955737732932112914LL,
  -7045114575697208035LL,
  8408392528960968792LL,
  3344048267133858868LL,
  3273122066349504054LL,
  -5574385745926169380LL,
  -1264620967483820876LL,
  -309034256761529509LL,
  -697211361211079516LL,
  5615099564754302582LL,
  7022698833697355703LL,
  -3532429807378465411LL,
  8909401524646400594LL,
  4512961136775126493LL,
  8195587537927757406LL,
  -7555172552714153197LL,
  -768139761052113242LL,
  7523747412402354617LL,
  0LL,
  3213727543391011265LL,
  6953734161536401472LL,
  2296027802622944227LL,
  -3967033794359559815LL,
  -1335549367324854602LL,
  -4705177771963460396LL,
  5044535463021874573LL,
  -2752138243085998233LL,
  5468739165446173298LL,
  -2435468977041992556LL,
  -3158316551694739304LL,
  -1694721354838593360LL,
  5337291446550234501LL,
  7741051604950236091LL,
  3067371542195979717LL,
  -1901023833671119025LL,
  1639655606490492397LL,
  -4244830917265029498LL,
  -2941023354431694182LL,
  6182597133298394726LL,
  -7772465749977329391LL,
  -3526517729034990966LL,
  1209550821022886377LL,
  434608385096025092LL,
  -9086126040821596418LL,
  -1127294156110323552LL,
  4967694984853878904LL,
  -5022967435948448475LL,
  -2047379834866939061LL,
  -909992162619514206LL,
  -91732263271375523LL,
  -4603985312323239808LL,
  -8499834516716649211LL,
  -5945054226335711425LL,
  -4881093043811376863LL,
  5251434972898160752LL,
  358330856890036721LL,
  -2322033457618132125LL,
  -4472539792500885641LL,
  8450335603361361839LL,
  7171038354084414018LL,
  3476867080768200736LL,
  1932376405107795429LL,
  1072158037947448829LL,
  7882908404632043455LL,
  5483647447745266049LL,
  1454728737246681112LL,
  3840549265079871014LL,
  3431022939711128515LL,
  -2204730952607416642LL,
  -6743298615549610699LL,
  -3743810926298036088LL,
  4133261267469413934LL,
  6286454811121062803LL,
  -960940237233040043LL,
  -9015188844753847044LL,
  5184990381174127226LL,
  -6013449351397390136LL,
  -1770140159966659910LL,
  3126761667041374770LL,
  -7649464479452567834LL,
  -6873623737422593856LL,
  -7479718562678302439LL,
  -3375614147072450914LL,
  9177634000278299555LL,
  7388342546632426564LL,
  9126688124738884692LL,
  -6091427819984962757LL,
  -9000832517114885365LL,
  -3890188918061429620LL,
  2996436545184778183LL,
  -3182234232327672981LL,
  4346048666049194024LL,
  8743047605751949223LL,
  -2133793756539667268LL,
  2102098132240242198LL,
  8521261804145847725LL,
  4300178136308833243LL,
  6253523334082749540LL,
  5686025765538657396LL,
  2173024333024597012LL,
  -2648267370905955694LL,
  727364368623340556LL,
  7822950931728451656LL,
  -1987433357229705032LL,
  6712025210167009183LL,
  7953834605416529341LL,
  -1187214245068455101LL,
  -6443540942523349820LL,
  -6308729813475903175LL,
  -6601441815868067535LL,
  4016464536944694227LL,
  -8358814449561963790LL,
  3652795546974016981LL,
  4831734870102150027LL,
  6475309135687937646LL,
  -5210732149353162022LL,
  -8357960124579577599LL,
  7240007424359117233LL,
  -3304676951004701540LL,
  -2264681828357879479LL,
  -5428025346616207144LL,
  -413462576937456468LL,
  575626253210153971LL,
  2703689357883133903LL,
  -5796156154134345014LL,
  -8146016055698000652LL,
  -1617319030536321209LL,
  1738433540384100368LL,
  -3035878231131852945LL,
  -8576116443052773136LL,
  8040246328048699978LL,
  8266522534938827868LL,
  2625717486449080376LL,
  -1031877433300658345LL,
  -4042452599488547981LL,
  5851850824139184023LL,
  2561814965747895243LL,
  8960338603958182305LL,
  -7148409303574517528LL,
  2412912495415868990LL,
  -2506397376883026282LL,
  -2539326654881308319LL,
  -8783548116078162675LL,
  -8854476515919065329LL,
  -8008618874510778144LL,
  4825824990831737980LL,
  -4259745796751724175LL,
  -6159827343160783668LL,
  -2865569364396765040LL,
  363682184311670278LL,
  141022266228275191LL,
  1312858743224540188LL,
  -6656321743931784510LL,
  6905391930587966058LL,
  -484399773005205842LL,
  -3399536225818613399LL,
  -7985259745726490857LL,
  6352864217937320345LL,
  2843012882769328698LL,
  -5093904632016066777LL,
  4082873943760951769LL,
  1426855013570767851LL,
  -5524000621257741525LL,
  3694171273316213282LL,
  -4917976165827423534LL,
  8091157018678241705LL,
  -8570771712784267513LL,
  -6384148618604891341LL,
  -5306716220221018835LL,
  2483847492426939452LL,
  -7914322549658872555LL,
  2344510773200013769LL,
  5266356449539032967LL,
  -49791387911017814LL,
  8692097332098388048LL,
  8813982602763150757LL,
  -8140666927316401405LL,
  -526336250252469927LL,
  -9218134510605825783LL,
  1672024133566929434LL,
  -2681201047018379931LL,
  3581860549962815447LL,
  -4173902517423995772LL,
  -5135278159318232880LL,
  -4386683318832430462LL,
  -5741302614748681943LL,
  8625687925281217114LL,
  1241923746213469726LL,
  -3749731800868619397LL,
  -267084585174062936LL,
  -2964949831290950291LL,
  4204196264480484396LL,
  -7497185011422542171LL
}; // weak
_QWORD qword_F0150[254] =
{
  -1470560967359661948LL,
  -4057574281474806119LL,
  -608956215103916403LL,
  -1939066718215209203LL,
  -5198071117120088387LL,
  -6356635401098174799LL,
  4178307997439725908LL,
  -4544043029872222128LL,
  289641071162556931LL,
  -8655731703483019607LL,
  -6014700755043854723LL,
  -3086345443720304871LL,
  8189341437854594402LL,
  -7335829217796600346LL,
  -4344396161840517990LL,
  418630046812442437LL,
  4520661559489273757LL,
  702632736481446208LL,
  -1183734689148765561LL,
  -4233641760872468715LL,
  9162269042867876587LL,
  522638836955516617LL,
  -1360919289338791157LL,
  -9065767836416130580LL,
  9054882501800211303LL,
  -4747641609324109827LL,
  -8492124076087360022LL,
  5105604074781483967LL,
  -6484348924133682185LL,
  -3197108641049811818LL,
  3309402376642468699LL,
  -1558876190633790014LL,
  -2800082124053290724LL,
  8856802461512187310LL,
  -7440392166028063638LL,
  -2815212736623121318LL,
  -233270446739521983LL,
  -1079172831822613246LL,
  2148586257683546959LL,
  -3394486082452559780LL,
  -6771175202378133004LL,
  -5090135906714529484LL,
  -1650560360467793656LL,
  -2328761580480437613LL,
  5590501597289098099LL,
  -4254401958709665197LL,
  6071203322875488831LL,
  1158564284650227724LL,
  3600156170315470162LL,
  -8309310981267896731LL,
  2441618274884885854LL,
  6951350521918664744LL,
  7996319228396779425LL,
  1445953521505143311LL,
  6828782792364470197LL,
  2025222469355179529LL,
  5213539280926024758LL,
  3942509732700035995LL,
  -6537188956388204739LL,
  -9121435855761847002LL,
  -7153007327152550295LL,
  -122497362680643635LL,
  -3478292139619980641LL,
  2606769640463012379LL,
  4231587845050801566LL,
  -5720569210009528204LL,
  7526128995628495918LL,
  7815765668543215149LL,
  -6643457281463886670LL,
  8298425650913785070LL,
  -5325793436113347589LL,
  5981332267059160310LL,
  -1380549172243564979LL,
  8476726276696553313LL,
  -411571077119115826LL,
  -6589474830505848197LL,
  -6826825629269369538LL,
  -4858414693382988175LL,
  2783954244679701399LL,
  6270405981464078069LL,
  7617953909209413992LL,
  0LL,
  -7389232208830938836LL,
  -9178229796507729824LL,
  -2512692887231929569LL,
  -989727302021973560LL,
  8587499365318702829LL,
  -5487144831525006146LL,
  128993373931277638LL,
  -3571115429052586023LL,
  -1955323247705558453LL,
  3709240383374660830LL,
  3127702009367009492LL,
  8873190930349338856LL,
  1287548862353212746LL,
  7907594980338416491LL,
  -7962880367339911894LL,
  -7046755503358128155LL,
  -4523278433753633514LL,
  1681185529015994053LL,
  3414528287577905879LL,
  -3675124214632389035LL,
  2497127966435250580LL,
  1101920978810342095LL,
  -3949639071203464944LL,
  579282142325113862LL,
  -1758513162925179263LL,
  6560601215109996784LL,
  -1095424963366062012LL,
  5392421556865803706LL,
  -7620403662068954141LL,
  6849679327628534515LL,
  -5036715323762582018LL,
  1971380762661912768LL,
  758164418264892810LL,
  9145876175950659501LL,
  4818777796537033148LL,
  -2244964318868115384LL,
  -501021004698357500LL,
  -4144754791536172065LL,
  -1272054310234523711LL,
  5016857836491091829LL,
  -8888588725345172893LL,
  4634257138600910896LL,
  -3373730282562263782LL,
  -2228703391096374002LL,
  7329447551461998445LL,
  1861197020862185804LL,
  3475675260959332372LL,
  5503175953840743989LL,
  -7101842972009577681LL,
  7437942417497439969LL,
  7709497347997513122LL,
  815094700599445708LL,
  6650472270725525049LL,
  4465697234261087063LL,
  -6193027773434079758LL,
  -2045335043290891134LL,
  -808035726511146425LL,
  -8363275839839090516LL,
  8012720891273853671LL,
  7240991593081221675LL,
  -2908034926644894059LL,
  -7206989777776623456LL,
  3653431620147943832LL,
  2839749813801492177LL,
  6737806710131630975LL,
  -8598947654182615962LL,
  -6304337427958573954LL,
  8567724349161421739LL,
  1629884832283298691LL,
  235816956589804746LL,
  -7675495528497952983LL,
  -2995224232664011821LL,
  5783814086020573244LL,
  6164154153643255673LL,
  7151120537131728098LL,
  3181543715925005853LL,
  4727221163609927030LL,
  -5959041527511786693LL,
  -3964760887547108266LL,
  -1670185845158284210LL,
  2891907043010286622LL,
  4573083775328752347LL,
  1737837630479666186LL,
  -8019665511857502100LL,
  7725894613062957284LL,
  2731254947766050653LL,
  7039810878580833646LL,
  -8778941558171679761LL,
  -7786258725827459930LL,
  8278646236609329576LL,
  7131349919053459876LL,
  -4802746669893168329LL,
  -34186537554742645LL,
  -5668287733838785230LL,
  992273807610448707LL,
  -2527827897747607975LL,
  -5781856927321761097LL,
  184520657936122252LL,
  8767493264978850148LL,
  2552927933435780306LL,
  -7909481774621046304LL,
  -6068683205532657484LL,
  4834044746268454138LL,
  -213631767876996345LL,
  -8831799182880682203LL,
  -8076449561628194129LL,
  -898029929508834162LL,
  -8205302195688093719LL,
  2317128569300455448LL,
  -2421576073953185835LL,
  -323264650073280376LL,
  -7732276275002586513LL,
  -5145799532258501518LL,
  8100889877420718116LL,
  -5906205893034813455LL,
  -1850197341333392441LL,
  3887541009157429073LL,
  -8258155422082675933LL,
  6450417473310269820LL,
  -3765118417830877028LL,
  8963044394047258145LL,
  3998314097779578589LL,
  -4431581069780622884LL,
  1914459276555652486LL,
  2203532990994124677LL,
  -2617839692998975344LL,
  -520655285615035326LL,
  -2137023619577843260LL,
  -8942553583848731478LL,
  4284005662810214616LL,
  868918815239833093LL,
  -791787992980654335LL,
  4050444938710359058LL,
  -6917911665258085725LL,
  -3107096845597644193LL,
  5120866626634166009LL,
  -3284302345216103984LL,
  3362097275778570129LL,
  3019761305513466200LL,
  8388279114275633703LL,
  5679243437265070009LL,
  -6248682598640789192LL,
  -3659998000074462445LL,
  6255134633653644211LL,
  4923898209763467827LL,
  -4623301439570914629LL,
  5300860526160095600LL,
  1044986298664159113LL,
  7418176197297910695LL,
  6539709077925998006LL,
  8675659555171744802LL,
  3075275395379303826LL,
  -8547796493211678432LL,
  1574933701195171657LL,
  5700148768488991487LL,
  -6879115901668405128LL,
  5876769314801296762LL,
  471346936180573071LL,
  -5614871548665439752LL,
  1340806719731206528LL,
  3763064497814247959LL,
  -3857937309451852326LL,
  -5380902894996826319LL,
  1392111814611076294LL,
  -4912379552089452360LL,
  2260458875180450499LL,
  5966056521101552048LL,
  -5433179973154612617LL,
  4337829777585872401LL,
  -700649189469881397LL,
  5413322490278095100LL,
  -2710649788391658026LL
}; // weak
_UNKNOWN unk_F0940; // weak
_QWORD qword_F0948[257] =
{
  -817979258377427561LL,
  -7528726169882426133LL,
  -5721347929815475769LL,
  -8318838476926185993LL,
  1661010127064337893LL,
  -2540632675654910537LL,
  -3985184194692206169LL,
  -264308930584161223LL,
  -1130139003587112768LL,
  361137922776367876LL,
  -2258027246506825337LL,
  -8683635173334024788LL,
  3105561577112672725LL,
  -6457416312112717199LL,
  3595615762444576410LL,
  -5360773008599508285LL,
  -3511172458272045819LL,
  -4855517414447669954LL,
  -4593460197845286903LL,
  -7888175242731157521LL,
  4545609565511554501LL,
  2804377613063351167LL,
  4668333744645392647LL,
  2092799329750944749LL,
  3453187164874075266LL,
  -6239832826549409923LL,
  2088856877858291134LL,
  2732037219362925194LL,
  -2684186089318269114LL,
  213642055637006246LL,
  -6803072865531554093LL,
  -1343218970167387347LL,
  6756064819359892202LL,
  2601995117030087897LL,
  -1608090919154897286LL,
  -4725754911100474728LL,
  -1271441700846544168LL,
  -4377002144188972548LL,
  432916159054283505LL,
  -3364240244298526947LL,
  -1991465643506377520LL,
  573091119895803042LL,
  6644037114458617017LL,
  1731661415564511465LL,
  -5867154244286376993LL,
  -7677628843335912627LL,
  -769001080810744892LL,
  4701548464522805076LL,
  1444551691105471504LL,
  -697224084717219279LL,
  -5808042727983127156LL,
  -2135020135593976287LL,
  8658302535061219424LL,
  -530869712184696466LL,
  1229220031125655316LL,
  -4272292157103032994LL,
  1948118091058514204LL,
  6500482609974621768LL,
  -5288432482816124106LL,
  5133337872188784037LL,
  7648918286080222849LL,
  -4942212453807265380LL,
  5534163301174332926LL,
  -4999072204656566321LL,
  3250241304987310884LL,
  -5071412015858344390LL,
  -7172935939384642384LL,
  8227639215101587048LL,
  8587651186431503724LL,
  -3624609273476238685LL,
  3021398157330542195LL,
  1655941809489836982LL,
  141302249252255315LL,
  -2932450693871153684LL,
  -6673873863409442443LL,
  5318268699763658490LL,
  -8251845901927941212LL,
  4773325909448801953LL,
  -7822308567505014340LL,
  -6730732236668954842LL,
  357196842072995159LL,
  -5158671055602489239LL,
  0LL,
  8371194131363474585LL,
  -6890330544865779584LL,
  2386663448460337117LL,
  4884227714308491506LL,
  3237292750151282039LL,
  -2756527268475650381LL,
  -3871184421012027903LL,
  8131653848015559118LL,
  -2500661422465070108LL,
  8781590384726040115LL,
  7481719228443710507LL,
  2587357103155898491LL,
  -2428884564349466095LL,
  -4797533141416055955LL,
  9091218142742784657LL,
  3811510363855250846LL,
  4185597602771572417LL,
  6108381732774790423LL,
  7122270155594979119LL,
  -47851186704460340LL,
  -6371283172410158046LL,
  5390609469804302095LL,
  3463321825938313417LL,
  722275845552735752LL,
  -7457511939816652313LL,
  860200360589979739LL,
  -3727629516068600592LL,
  -3045886970570622390LL,
  4531534323560211350LL,
  1077220870497432415LL,
  1872962276447616698LL,
  6611385251291775003LL,
  -8824093734992508406LL,
  -1392196317744222850LL,
  -2324737025059472318LL,
  -2861799345241437984LL,
  865831313187341561LL,
  8853929641893945286LL,
  6395489906733859310LL,
  -6956479017949104827LL,
  -6529192622089411708LL,
  5778206764421886016LL,
  3322019128409397969LL,
  1300998164324355809LL,
  -5229322344102662811LL,
  -3148908575728776167LL,
  4329151267530609712LL,
  6860494581304538444LL,
  8155862462793723805LL,
  4098619287260815719LL,
  -170294799558663574LL,
  5750058542653033483LL,
  5420446524455663964LL,
  -479640599153912003LL,
  1004880339897021098LL,
  -7096937018600684829LL,
  -3942961176048416780LL,
  -1176302448499184501LL,
  3667955984346310511LL,
  9019440457837587300LL,
  -6587178272710814249LL,
  -314975739860442981LL,
  -5505453001313511374LL,
  7552933458509484327LL,
  -9115425135000322211LL,
  -6168054699313043832LL,
  -9043647144663941464LL,
  -1825111386112677002LL,
  -7024596630795222250LL,
  5028908665861360131LL,
  8874760591446059413LL,
  7985847533814141910LL,
  4916880124502621264LL,
  -8396527006347986603LL,
  4459194208476783203LL,
  2818452033581227308LL,
  -7316490980689086911LL,
  5565127074875390893LL,
  -407863158034377016LL,
  -3292462665201070360LL,
  2458440062251310632LL,
  8564569840458849087LL,
  2164575633765304856LL,
  -5445778853760308080LL,
  4027405057195041899LL,
  -1775008172853994203LL,
  -5589334306842644895LL,
  3093738100615278470LL,
  -1033873851198167405LL,
  -2042131904610064270LL,
  -602084019559881630LL,
  6428705445888866237LL,
  -8751753614014116865LL,
  6211121960325558961LL,
  -4232322283658853619LL,
  -1487899243553334820LL,
  -4415847497606711377LL,
  -8102943789481358334LL,
  -6024501157979659143LL,
  7913508379725451811LL,
  4314513805062824082LL,
  -4056398424757979989LL,
  1583602106184301123LL,
  650499644617590781LL,
  8008930248820204933LL,
  -1535751521347915889LL,
  -8534733069746925837LL,
  2371462306736892302LL,
  2889103382210943008LL,
  7265823574109181406LL,
  -8968774123921569541LL,
  -5661110513740124268LL,
  -7605851024798223688LL,
  7792472364234056816LL,
  644305427270988206LL,
  5964826535099877350LL,
  -913681636013944523LL,
  7287780423433397133LL,
  -8900093466430571431LL,
  -4639623131807834933LL,
  7143099736113684860LL,
  8997484977546779959LL,
  9213378706152742082LL,
  -7960515191910857190LL,
  -7744620590500182754LL,
  -6084174754193829669LL,
  -4160544601482181896LL,
  6324275599358674146LL,
  -1897452325290857853LL,
  8347549330551396411LL,
  1082287816882652428LL,
  216458607757558261LL,
  3896236182117028408LL,
  -97955229952990305LL,
  -2206797303486193708LL,
  1223027184968333639LL,
  7768827015316754642LL,
  -6300068865034972882LL,
  -1704356884353820631LL,
  7577140704254240628LL,
  -3406461883196655282LL,
  5203989160688957609LL,
  3824459740124746701LL,
  -3552268197398072490LL,
  6139344687198253892LL,
  -2973547812742841409LL,
  -8038766757522345911LL,
  -9184668647618541298LL,
  -961533083818678426LL,
  -4488186758513707430LL,
  7359557278820475512LL,
  -5939493952408939990LL,
  6926642509246963849LL,
  -2645342115646191339LL,
  1945302910127243087LL,
  -8612983824704309088LL,
  -8180069455051261359LL,
  -8462392853740155130LL,
  1438921290992449714LL,
  -7241617149292609518LL,
  4113819607550793524LL,
  8492228760641592010LL,
  5994664409028833717LL,
  5892487139954050579LL,
  -3190568322650294085LL,
  6828405761199227679LL,
  -3769288715895459758LL,
  -7388267599364458572LL,
  3679778639410237756LL,
  5101248232805878774LL,
  2304751982975974475LL,
  7049928972698506970LL,
  5636904067162454616LL,
  -6488505333816387596LL
}; // weak
_QWORD qword_F1150[255] =
{
  -8892515824107721833LL,
  -7372288209707219024LL,
  -8247081616505178228LL,
  943478833150813463LL,
  -4765922387822790692LL,
  -5636229787179440184LL,
  6123890065292933628LL,
  5832320261051957488LL,
  217587862202418181LL,
  -6205908820751185952LL,
  9045428545345399943LL,
  1813768571333498155LL,
  7108390733004042662LL,
  -1859568499666019791LL,
  -7298828746967301195LL,
  5030310294124299727LL,
  -7080605160063549764LL,
  4665810069017856448LL,
  -8677758104835199086LL,
  1531172127256200511LL,
  -1502349930454614234LL,
  -3944926161900337344LL,
  801050278664858909LL,
  -1427801330295209425LL,
  7469530816082050473LL,
  -208217405854466532LL,
  -1574746644054111707LL,
  -4622108138223483174LL,
  -647865978055055870LL,
  -7592710647379995743LL,
  6624081037630320109LL,
  -4441349172565448099LL,
  2027963306158643492LL,
  -5842905682043569431LL,
  7691851623108876478LL,
  6552317910056622318LL,
  4738839583905676483LL,
  146072275639267590LL,
  5751468923926027729LL,
  6693629326234800356LL,
  -862625896350834169LL,
  3773046520127207772LL,
  583464615485696280LL,
  -7805216566838829138LL,
  8328631992928390549LL,
  6049908123254375669LL,
  4558042126717244481LL,
  870351448809672724LL,
  5978075049487380982LL,
  7327331606793129135LL,
  6837167499228619234LL,
  2916160130525978744LL,
  -6775437803315433736LL,
  1085678715105383441LL,
  -5348891869512900924LL,
  656141320821742619LL,
  3916581519643527258LL,
  -7226398220130502986LL,
  4415666046950548807LL,
  2768209423324578154LL,
  7618952911299124411LL,
  -3653488575006245300LL,
  -6937143306121916486LL,
  1958290759821763629LL,
  -7009390900067550535LL,
  8402806888486711452LL,
  3346814663117400178LL,
  3276158955028311159LL,
  -5562770324439522355LL,
  -1285322819182365911LL,
  -354010465921419754LL,
  -720112338841742591LL,
  5609129391076273367LL,
  7035489822171035043LL,
  -3582274315010246071LL,
  8903017583045485709LL,
  4486323954062893378LL,
  8184110753057455251LL,
  -7520253732264139102LL,
  -791328797860997372LL,
  7545783072850471352LL,
  0LL,
  3203385078741506420LL,
  6962811590477381792LL,
  2243288373431098657LL,
  -4016302149275684285LL,
  -1356539278201620692LL,
  -4694705928803535911LL,
  5100968201236644298LL,
  -2778695237196198288LL,
  5466718428776359133LL,
  -2415638502699027591LL,
  -3141261184203478169LL,
  -1719368245633844445LL,
  5394850032661434846LL,
  7763368736029633981LL,
  3062091254749368702LL,
  -1930782759662019020LL,
  1601830034368545082LL,
  -4227522674965538988LL,
  -2926503464930955422LL,
  6196840277367704831LL,
  -7735013650559917401LL,
  -3509781258315034806LL,
  1166671902149757232LL,
  435175724404836362LL,
  -9108417000979175528LL,
  -1149636573479806197LL,
  4957535719334932684LL,
  -4983813370278163755LL,
  -2072089812287646146LL,
  -932618258300575986LL,
  -137003145858467303LL,
  -4585830450584347813LL,
  -8465219165516854651LL,
  -5914119942039568660LL,
  -4836868056519261473LL,
  5249130566573940952LL,
  291887291444820236LL,
  -2343532741424855430LL,
  -4514806436282110376LL,
  8475546554855671199LL,
  7180399452679799973LL,
  3481405795238690896LL,
  1886669482166505774LL,
  1014136740263158034LL,
  7905797290515588535LL,
  5536143856653572564LL,
  1458080065262989372LL,
  3845925811554438239LL,
  3418710146013961585LL,
  -2217874662675617992LL,
  -6701980539598771459LL,
  -3724538977587557553LL,
  4128504732433603659LL,
  6339215132565388793LL,
  -1005050018296321523LL,
  -9034957538239257699LL,
  5172862985630643401LL,
  -5985521636438406161LL,
  -1787215766531641550LL,
  3133747992728396925LL,
  -7663927106399250524LL,
  -6846813109435196421LL,
  -7443418734332988749LL,
  -3357162361074931864LL,
  9187662801030569345LL,
  7397987314882218154LL,
  9116084253434488962LL,
  -6059913002106521882LL,
  -8962562333750389090LL,
  -3871466699160419515LL,
  2989190343916361083LL,
  -3211623525339900306LL,
  4342714860421533764LL,
  8758142998932968843LL,
  -2144415199935700163LL,
  2100701722121677863LL,
  8546204461968015770LL,
  4273237492464594253LL,
  6267495985456793850LL,
  5679785099165362386LL,
  2171357430210766882LL,
  -2632665613971275914LL,
  729040032631494686LL,
  7833163039287054516LL,
  -2001973485804164297LL,
  6766509592116274663LL,
  7976455197627933106LL,
  -1213041411999431126LL,
  -6417288874797132815LL,
  -6276933516309007645LL,
  -6559556417653284105LL,
  3988371587399662937LL,
  -8392892268758171770LL,
  3627231504321655126LL,
  4883395732197019077LL,
  6479419198246870251LL,
  -5205570891035463742LL,
  -8318273851757952369LL,
  7254205748809595308LL,
  -3283702898335014035LL,
  -2289110326490131909LL,
  -5420328610307986489LL,
  -426230438429048043LL,
  507212358717275401LL,
  2697551516212233583LL,
  -5770763917165883414LL,
  -8175865157485923447LL,
  -1648203907770773984LL,
  1740702897619345448LL,
  -3070316472714273180LL,
  -8609910583937401981LL,
  8048490305582765233LL,
  8257009464867207318LL,
  2624565283286970476LL,
  -1078507282012983800LL,
  -4084165132324182446LL,
  5905174138654373363LL,
  2550636954284952933LL,
  8972337733758114180LL,
  -7151901025394439233LL,
  2405869147857714275LL,
  -2486854961718282372LL,
  -2558292659720633729LL,
  -8750041021128762735LL,
  -8821255281124761964LL,
  -8022234882018059349LL,
  4811738295715428550LL,
  -4298925050619960745LL,
  -6132449358011268123LL,
  -2849683929150506125LL,
  364520016315747343LL,
  73171364806259971LL,
  1312282641643485238LL,
  -6629794794255966210LL,
  6908956592530511073LL,
  -499689901168965872LL,
  -3428644039542386069LL,
  -7950895036222067032LL,
  6406495374451157480LL,
  2839892549582681193LL,
  -5057270633994826032LL,
  4055651829285431624LL,
  1384257565328919861LL,
  -5490198922138528050LL,
  3698993657441109077LL,
  -4911733040075784234LL,
  8111046329749227920LL,
  -8538676429233516928LL,
  -6344796499357505806LL,
  -5277677609516901695LL,
  2478767859667466342LL,
  -7877437772505404755LL,
  2333051291105790304LL,
  5321949121828427227LL,
  -64544997583663334LL,
  8685429720843067528LL,
  8831043909765976462LL,
  -8103513933462174070LL,
  -571030980123905517LL,
  -9179582847952874853LL,
  1673407331558700089LL,
  -2705237973479536011LL,
  3554330593488647507LL,
  -4156306215946284207LL,
  -5128751355255014445LL,
  -4368812135405117602LL,
  -5707219436341013813LL,
  8618134154782422169LL,
  1239383929833733171LL,
  -3799281635073198522LL,
  -279302716856186081LL,
  -2999102212718273951LL,
  4201403444243355726LL
}; // weak
_DWORD dword_F1948[512] =
{
  -1516768091,
  -197998906,
  -2064935036,
  -1754269448,
  -1714966375,
  -1335955730,
  -1913156467,
  -1938098442,
  233117453,
  401145855,
  -1112023875,
  -603269418,
  -1314404175,
  -938025250,
  1413086292,
  -59928175,
  1354821712,
  -258973600,
  50595075,
  84345346,
  -1450712919,
  -533803314,
  2108458877,
  -2016324010,
  433400601,
  734848999,
  1651615330,
  -1508657739,
  -426102298,
  830229837,
  -1698450022,
  -1252397844,
  1158008645,
  -817852529,
  -1656832867,
  -1130160353,
  1074380864,
  -1068922487,
  -2014342521,
  -1838613766,
  365248277,
  1070657519,
  -343988501,
  647279282,
  -922271543,
  1087278734,
  200088843,
  501677051,
  -327012372,
  795754817,
  1736288615,
  -1457867853,
  -37872387,
  474177375,
  -360045078,
  627066181,
  -1085875521,
  -621206749,
  -140115209,
  38884179,
  -1764515434,
  -1589254940,
  1529736539,
  -310994021,
  -1024827966,
  1562932597,
  483992604,
  616948193,
  -1367676498,
  -371966659,
  1788395114,
  -1091417012,
  1524166234,
  -293442452,
  1107084097,
  -1010991490,
  49350146,
  116651509,
  1327354191,
  -783121533,
  1557193820,
  -460560280,
  -190707724,
  123097425,
  884562996,
  1552798161,
  149493768,
  417462777,
  -1814057325,
  -1370692894,
  1934464371,
  -1791054933,
  1405416787,
  -174628254,
  1062486335,
  1097542186,
  202380300,
  337381384,
  1379006034,
  -161245803,
  1703718757,
  -1343666618,
  1579278942,
  -494953059,
  677410856,
  2017996848,
  -1586562911,
  -120637641,
  252973327,
  286984714,
  -1252080459,
  -991219921,
  152836873,
  454364686,
  910711350,
  1518216228,
  -1690913125,
  -1230169317,
  1034241853,
  1201201119,
  646015526,
  1789382093,
  1771879273,
  -1141551538,
  -838972211,
  1278443391,
  -1613776225,
  -1169102102,
  455355675,
  759108114,
  -1640318562,
  -1180426979,
  1957731444,
  -1664853928,
  778596910,
  1917203508,
  762083117,
  2000762422,
  -1297887822,
  -854467364,
  -294442514,
  698201268,
  -71952645,
  374168411,
  -162332170,
  27632804,
  1307367245,
  -677284234,
  1635099489,
  -1558923337,
  -822457906,
  1228176765,
  2074381691,
  -1914744238,
  1050755646,
  1117773277,
  1908183921,
  -1815257506,
  -1759075689,
  -1565453549,
  -178846475,
  77768358,
  1751758952,
  -1207846471,
  0,
  0,
  748254252,
  1958068673,
  1619042400,
  -1595916224,
  534585631,
  566420451,
  -923647032,
  1127905657,
  -310956819,
  748336822,
  -1095509570,
  -653404972,
  1174522438,
  -901280371,
  -640782119,
  1880581991,
  1273290059,
  -575704462,
  -567051810,
  2045613204,
  -735352876,
  1744803992,
  -394583064,
  596881584,
  1242685002,
  -564427387,
  1802354027,
  -1123632197,
  714178090,
  2126235077,
  -442616603,
  880496463,
  381762070,
  987229677,
  -988326715,
  1423083142,
  -684760361,
  1660459674,
  1439498069,
  -6723994,
  -1809668204,
  -1481240303,
  -821081393,
  1254132362,
  281620496,
  819587561,
  101190150,
  168690692,
  -2115528575,
  -1738080514,
  -262468624,
  195797152,
  1156631620,
  -860587912,
  -1169500742,
  -705682139,
  -476692765,
  1047874379,
  -211874061,
  246194850,
  -21358082,
  423910749,
  -1071948864,
  1541111936,
  -1979021942,
  -2055207675,
  -1384190803,
  -321700033,
  -1136468036,
  -536993503,
  1222694984,
  -660049808,
  83430404,
  217969137,
  -540640545,
  2048484195,
  -1041344319,
  1479505783,
  1967497077,
  -1624199249,
  1669637475,
  -1511570878,
  809521200,
  1349525536,
  449916442,
  785114597,
  249631246,
  317718013,
  1835382637,
  -1224163393,
  1276761164,
  -732593791,
  338705428,
  1008998424,
  894197557,
  1601775142,
  798847279,
  1907540931,
  -513328927,
  948354750,
  -1570046558,
  -37210827,
  -871673908,
  1338476680,
  962349881,
  1264922158,
  1463679319,
  -110455917,
  -223736334,
  223892821,
  -2099012222,
  -1654522628,
  1207224647,
  -910984582,
  -1400115284,
  -282605368,
  -412142873,
  847821498,
  728005931,
  2102342194,
  -1781029739,
  -1539119386,
  -1600390240,
  -79970112,
  -1741507688,
  -1280698087,
  -785946415,
  1760992926,
  2136834431,
  -2128436317,
  1720232550,
  -1427225532,
  2124972670,
  -2099882924,
  -1418271061,
  -421708997,
  -2095669629,
  -1634399477,
  -905755190,
  1170836620,
  697662249,
  2075969479,
  -740921645,
  1845848939,
  1011893308,
  1147938856,
  2035649401,
  -1960007769,
  -496812574,
  1031912636,
  489432861,
  657528342,
  1984010870,
  -1707627091,
  1001213243,
  1301732315,
  1456011862,
  -90282908,
  1323881038,
  -760843148,
  505946654,
  573969428,
  -616597797,
  1994691218,
  169352714,
  504499212,
  1821422700,
  -1258534840,
  -462735388,
  932165816,
  1562765149,
  -411525217,
  1851896430,
  -1307591235,
  -276419857,
  711541571,
  -1500253786,
  -248134460,
  -1468865624,
  -472237767,
  -1537017948,
  -138006223,
  935156023,
  1502270419,
  -1946188149,
  -2039155982,
  850482738,
  1451480533,
  1124975939,
  -984708213,
  1507650393,
  -343576978,
  -1213218121,
  -1038558502,
  -1945989236,
  -1886519039,
  1685695588,
  -1407340111,
  -769430062,
  1844550812,
  -527287328,
  997345609,
  -1263810636,
  -954214184,
  -96266758,
  364489900,
  134023431,
  167441395,
  629501733,
  1872809935,
  -1349522769,
  -366949686,
  -1896642162,
  -1988233996,
  -376561431,
  543639367,
  404760600,
  674762768,
  -706845483,
  1678471023,
  -1996782712,
  -2089553680,
  1872015727,
  -1308931510,
  1924699762,
  -1765122980,
  611347492,
  1817458744,
  -240252687,
  140466007,
  -941206841,
  1377923955,
  1362490193,
  -211511401,
  596469027,
  1705954251,
  2086241404,
  -2077908575,
  -1664368740,
  -1084757784,
  561799969,
  1667055166,
  -583566115,
  2095748758,
  -591233060,
  2132697441,
  -2045079162,
  -1852044019,
  -2061593467,
  -1801777393,
  -1864651888,
  -1421090592,
  1123599938,
  -960856964,
  -991799356,
  1462137201,
  -1434196566,
  -450245428,
  -667192360,
  1944293520,
  84676357,
  252249606,
  32834305,
  66385911,
  305673746,
  908729372,
  -1549795677,
  -29572414,
  1607786847,
  -510956950,
  -112783111,
  280932014,
  -791516208,
  1795320169,
  -1859213167,
  -1463871721,
  1479141464,
  -395208295,
  661940519,
  1767062074,
  -1186017095,
  -789108953,
  950618168,
  1217518041,
  332215571,
  903801835,
  -1286156621,
  -823842005,
  860116275,
  1433870882,
  -1145055557,
  -704326958,
  1883869296,
  -1875269207,
  -1995538295,
  -2138634489,
  -1486425433,
  -222219469,
  -1235566154,
  -1041486547,
  578315810,
  1717189692,
  -1842696814,
  -1380444907,
  545873952,
  1621739977,
  1226169161,
  -614692985,
  -11592961,
  447785642,
  2023786616,
  -1999089584,
  2052165242,
  -1909742171,
  -1895396721,
  -1970732285,
  -122547208,
  323639641,
  -2146264192,
  -1684928247,
  389298455,
  958601754,
  -624265766,
  1964008805,
  833966897,
  1401214935,
  -971812410,
  1372947588,
  -1195650120,
  -754724656,
  -1021354301,
  1591509634,
  -1336751184,
  -874370775,
  2008324471,
  -1715250598,
  289157905,
  858594846,
  -873052469,
  1178434427,
  -62185476,
  532129960,
  -690331178,
  1628204397,
  978865722,
  1315056684
}; // weak
_DWORD dword_F2148[512] =
{
  -1745574412,
  851887781,
  -342391657,
  1878587524,
  -944727632,
  1592716953,
  -141783668,
  2063005325,
  -451474153,
  -385876211,
  -1210270244,
  181851837,
  -1480019512,
  383704753,
  972838140,
  1838256468,
  -1057992464,
  -1872732080,
  67437317,
  117572099,
  -2015319584,
  785305257,
  -1400406649,
  -782870915,
  -718595797,
  -857217255,
  1906729638,
  330675554,
  -1708005839,
  2085440998,
  -1011508555,
  1508699290,
  97469903,
  1083150149,
  1052548540,
  -1558241379,
  163594432,
  1233750336,
  -275609710,
  1761278599,
  -985721537,
  -789582059,
  2133256998,
  -1800228117,
  121686336,
  -829518135,
  -316863715,
  -419693813,
  -2110788561,
  1849770476,
  2108254121,
  447984487,
  -1105396452,
  1130323965,
  -1977226715,
  1615152618,
  1188741082,
  -115137601,
  -1509755134,
  1364415479,
  -744384863,
  1172628630,
  770530285,
  1989909339,
  -362954147,
  678786498,
  -651944924,
  -975052516,
  2062135017,
  -734184018,
  -1732351298,
  -229880726,
  -655467794,
  -2106823590,
  -54312509,
  -1115783615,
  -251264506,
  -201984766,
  500256721,
  1384350543,
  -790340380,
  -1939314596,
  -1576537081,
  1448169972,
  -1185139620,
  -1915629260,
  -384301032,
  -503711480,
  -542207058,
  1289937555,
  1301640085,
  1051437939,
  -990555147,
  -1755159981,
  1413562177,
  1797925439,
  269749268,
  470288396,
  838226678,
  1670747474,
  -1934662225,
  -381270427,
  568483554,
  2141035870,
  1618487416,
  1211117608,
  1861788152,
  -818464863,
  336662289,
  453642767,
  1589949892,
  -349229131,
  471533851,
  353242633,
  1213871706,
  2116297782,
  917937078,
  -1390732389,
  -1522057913,
  -1730158787,
  -2123749782,
  -1479684826,
  -1665439301,
  -179417495,
  -28521140,
  863993805,
  -809852998,
  1357572767,
  606935853,
  1058148891,
  985243321,
  -1541595746,
  -1331923812,
  -1000843148,
  1752313458,
  1177826350,
  1819749751,
  1094071853,
  -1546800435,
  299687090,
  1932127785,
  -1649101586,
  -1240007914,
  1297832955,
  1392637441,
  -1515936522,
  -321434153,
  -1586071987,
  1973641635,
  347584353,
  -95826359,
  880639438,
  -1534231667,
  -548253061,
  -1589494206,
  -1612849858,
  -1131187821,
  -849453455,
  648189858,
  -1324149865,
  1459942660,
  -1566136587,
  1773693112,
  28948840,
  0,
  0,
  -1720439692,
  -1245593300,
  -2136973152,
  -532660128,
  -585031903,
  -1025252577,
  -230438845,
  981039560,
  1999433004,
  -1699301651,
  -1277575463,
  232051902,
  30033610,
  1200459078,
  -831465104,
  392652761,
  -455259171,
  -1351454133,
  863624825,
  -309029666,
  728224871,
  -6776620,
  2065950755,
  -1817136920,
  299780830,
  1535477066,
  1841130429,
  112966507,
  -1854002562,
  -1144666838,
  -1640700620,
  2068795365,
  -1053157830,
  -672273130,
  391431508,
  -762935611,
  795006818,
  -124085545,
  -855681537,
  -1721342379,
  581407911,
  -1240395372,
  256560970,
  -1064662321,
  -919597008,
  -638981872,
  134874634,
  235144198,
  -409435752,
  1727987329,
  1527509003,
  -1415536400,
  -255048500,
  -1267173308,
  1255520981,
  -266000966,
  -1774263490,
  1967868899,
  1594815246,
  -1398627597,
  -1172701671,
  1146969598,
  458997851,
  -612335424,
  176523909,
  -2147154550,
  2129440236,
  -750829651,
  1121959135,
  -31383108,
  -522696488,
  -1469026232,
  -116653044,
  -34475772,
  -965025926,
  425944031,
  -296173224,
  796358593,
  1168078239,
  816820085,
  -2069535835,
  -415088029,
  1078997072,
  1881153584,
  -785507794,
  -874126054,
  -518910446,
  -268567282,
  1706519991,
  146784109,
  433343700,
  1434550604,
  809243708,
  605558804,
  1281307999,
  2032543285,
  -1653526671,
  -1295793361,
  1731780920,
  -2034319647,
  1795007229,
  -936036958,
  189779023,
  -947353396,
  1548433739,
  1697525305,
  1039751161,
  1788056407,
  -1441926643,
  1481987570,
  -476216675,
  1643969666,
  -188135479,
  -1283818937,
  -1947226897,
  667469996,
  1865606962,
  -2001028377,
  1685924733,
  1328689707,
  -677079644,
  1122428565,
  -1678008069,
  1002487968,
  850630835,
  -1441195624,
  661180776,
  -157376815,
  1568767873,
  581149567,
  -2002098518,
  -297515930,
  -1467842942,
  -699116418,
  1994828774,
  -583320661,
  379487134,
  -1794438269,
  54905413,
  -913535798,
  -1787090565,
  -1127758039,
  -697379986,
  90926035,
  1346649156,
  1814571068,
  1435203979,
  749184889,
  1664999997,
  -2118337310,
  740760871,
  823531037,
  1100641946,
  934129014,
  -1387447475,
  -1763976389,
  -923117830,
  -1637587882,
  -388870446,
  -1502317490,
  673324578,
  907285534,
  1064754038,
  -460156197,
  404621854,
  302779402,
  -1867223884,
  -62371732,
  1798825015,
  -1883719452,
  635919847,
  2023726941,
  1639083698,
  264093038,
  -2044006614,
  1766015983,
  -1812879631,
  902087846,
  1927522531,
  -633783896,
  1660396791,
  -969854556,
  -1118226599,
  -1965829321,
  -7959674,
  1962078859,
  -1319751082,
  -2083138254,
  231031749,
  1317768003,
  -588555797,
  -2056360359,
  -1346193470,
  416996023,
  42962063,
  -1912536692,
  2041341100,
  498184548,
  594399853,
  -241394478,
  -1841569733,
  1917405664,
  -1412975417,
  534304948,
  1125513749,
  -1179865862,
  -49740023,
  -84675833,
  -2056313489,
  -1596993755,
  -1880444950,
  550161071,
  -209088887,
  2113205390,
  -1910445792,
  1732724713,
  539498536,
  940576792,
  -563817116,
  191852501,
  -75265917,
  1945170056,
  -1800310863,
  -79017361,
  -1198099818,
  -899916686,
  1886135404,
  1412970532,
  -1375145720,
  1599559665,
  -430782638,
  561214407,
  905138675,
  1687656273,
  -1922751643,
  -1362375901,
  1501854852,
  631349628,
  -876634945,
  1474881692,
  2086871395,
  1564360225,
  930930044,
  -359229731,
  -1031807873,
  509698524,
  445744785,
  -1676866170,
  513050004,
  -1693511803,
  -609513301,
  1273028752,
  -121224506,
  -1166246846,
  -497564585,
  644968900,
  -2082100507,
  701287594,
  997447795,
  -477065000,
  202310927,
  151389701,
  -184352509,
  -185075967,
  943067702,
  706485266,
  -1610701826,
  1019396771,
  -723427359,
  -1955960225,
  1192294672,
  -1095848199,
  -764686229,
  40462800,
  782799272,
  -1089005679,
  703092968,
  1905891672,
  1953048425,
  1396324903,
  1322301904,
  -148428871,
  -1454884792,
  -1847994056,
  -852159691,
  -554964205,
  1456387022,
  -450155597,
  1146434389,
  1998725683,
  -1076446250,
  80925371,
  1234202768,
  967420272,
  243304832,
  -2029582455,
  1727178738,
  -1053609049,
  1522644673,
  -332583498,
  2019959398,
  1513896994,
  716018349,
  -1206577774,
  -1990188960,
  -1446393568,
  366692827,
  1552385865,
  1327169306,
  -1330992385,
  -1601668984,
  -665825160,
  1368291982,
  732276090,
  109744010,
  -1996291185,
  -1307314157,
  1247369720,
  312180891,
  -1844901504,
  876156729,
  588913175,
  -898246027,
  275080666,
  -1252839085,
  -2066229455,
  324126289,
  -712735546,
  -1143752493,
  64016568,
  526304094,
  -595426621,
  1389080779,
  -500618832,
  -1265010791,
  -1017488777,
  1009979699,
  756948497,
  -163132602,
  1031502795,
  1260387359,
  -1213683460,
  -631122335,
  208498134,
  1481521742,
  1647062074
}; // weak
_UNKNOWN unk_F2948; // weak
_UNKNOWN unk_F2DA8; // weak
_UNKNOWN unk_F2E88; // weak
_UNKNOWN unk_F2F08; // weak
_UNKNOWN unk_F2F88; // weak
_UNKNOWN unk_F3008; // weak
_DWORD dword_F3088[8] =
{
  809079974,
  -1058647399,
  1824733714,
  -598304706,
  503320719,
  2013282877,
  -1889830782,
  -1763583214
}; // weak
_DWORD dword_F30A8[8] =
{
  -533497832,
  1142663437,
  2134168642,
  -1819729537,
  -441926426,
  1383381748,
  646486951,
  -1709019491
}; // weak
_DWORD dword_F30C8[8] =
{
  -1226960659,
  1895070382,
  117941204,
  471764817,
  1887059269,
  -1364032158,
  -1161161335,
  1084518206
}; // weak
_DWORD dword_F30E8[8] =
{
  23617341,
  94469364,
  -1123431734,
  -198759640,
  340452812,
  -89674197,
  776532417,
  -1188837628
}; // weak
_DWORD dword_F3108[8] =
{
  -64955950,
  877997605,
  2061009295,
  -2076674486,
  -1150427086,
  -306741048,
  -645631146,
  -1563982796
}; // weak
_DWORD dword_F3128[8] =
{
  -497126719,
  -433865870,
  1549313188,
  507044583,
  2028178333,
  660104985,
  921544063,
  1882893543
}; // weak
_UNKNOWN unk_F3148; // weak
_DWORD dword_F31E8[8] =
{
  -1307332699,
  -934363499,
  1314949666,
  1457019134,
  876286863,
  -789819843,
  753617026,
  -1280499192
}; // weak
_DWORD dword_F3208[8] =
{
  -534197825,
  1148546961,
  2123353650,
  -1788524354,
  -31908894,
  1018308325,
  1497670286,
  -1580940459
}; // weak
_DWORD dword_F3228[8] =
{
  -254613021,
  -1408116742,
  466314994,
  1865259977,
  2019567177,
  -1898256046,
  996910408,
  -307325664
}; // weak
_DWORD dword_F3248[8] =
{
  1351669111,
  756622763,
  -1268476244,
  -778937680,
  689117878,
  264262595,
  1057050380,
  -66765775
}; // weak
_DWORD dword_F3268[1014] =
{
  -1520213050,
  -2072216328,
  -1720223762,
  -1921287178,
  234025727,
  -1117033514,
  -1318096930,
  1422247313,
  1345335392,
  50397442,
  -1452841010,
  2099981142,
  436141799,
  1658312629,
  -424957107,
  -1703512340,
  1170918031,
  -1652391393,
  1086966153,
  -2021818886,
  368769775,
  -346465870,
  -918075506,
  200339707,
  -324162239,
  1742001331,
  -39673249,
  -357585083,
  -1080255453,
  -140204973,
  -1770884380,
  1539358875,
  -1028147339,
  486407649,
  -1366060227,
  1780885068,
  1513502316,
  1094664062,
  49805301,
  1338821763,
  1546925160,
  -190470831,
  887481809,
  150073849,
  -1821281822,
  1943591083,
  1395732834,
  1058346282,
  201589768,
  1388824469,
  1696801606,
  1589887901,
  672667696,
  -1583966665,
  251987210,
  -1248159185,
  151455502,
  907153956,
  -1686077413,
  1038279391,
  652995533,
  1764173646,
  -843926913,
  -1619692054,
  453576978,
  -1635548387,
  1949051992,
  773462580,
  756751158,
  -1301385508,
  -296068428,
  -73359269,
  -162377052,
  1295727478,
  1641469623,
  -827083907,
  2066295122,
  1055122397,
  1898917726,
  -1752923117,
  -179088474,
  1758581177,
  0,
  753790401,
  1612718144,
  536673507,
  -927878791,
  -312779850,
  -1100322092,
  1187761037,
  -641810841,
  1262041458,
  -565556588,
  -733197160,
  -396863312,
  1255133061,
  1808847035,
  720367557,
  -441800113,
  385612781,
  -985447546,
  -682799718,
  1429418854,
  -1803188975,
  -817543798,
  284817897,
  100794884,
  -2122350594,
  -263171936,
  1144798328,
  -1163944155,
  -475486133,
  -212774494,
  -22830243,
  -1069531008,
  -1970303227,
  -1382903233,
  -1130521311,
  1211644016,
  83228145,
  -541279133,
  -1044990345,
  1977277103,
  1663115586,
  806359072,
  452984805,
  250868733,
  1842533055,
  1288555905,
  336333848,
  890442534,
  804056259,
  -513843266,
  -1567123659,
  -867941240,
  957814574,
  1472513171,
  -223893675,
  -2105639172,
  1195195770,
  -1402706744,
  -413311558,
  723065138,
  -1787595802,
  -1604296512,
  -1736343271,
  -783331426,
  2145180835,
  1713513028,
  2116692564,
  -1416589253,
  -2088204277,
  -901364084,
  703524551,
  -742868885,
  1007948840,
  2044649127,
  -497131844,
  487262998,
  1994120109,
  1004593371,
  1446130276,
  1312438900,
  503974420,
  -615954030,
  168166924,
  1814307912,
  -463709000,
  1573044895,
  1859376061,
  -273896381,
  -1503501628,
  -1466855111,
  -1533700815,
  937747667,
  -1954973198,
  854058965,
  1137232011,
  1496790894,
  -1217565222,
  -1936880383,
  1691735473,
  -766620004,
  -525751991,
  -1267962664,
  -95005012,
  133494003,
  636152527,
  -1352309302,
  -1904575756,
  -374428089,
  403179536,
  -709182865,
  -2005370640,
  1864705354,
  1915629148,
  605822008,
  -240736681,
  -944458637,
  1371981463,
  602466507,
  2094914977,
  -1670089496,
  555687742,
  -582268010,
  -591544991,
  -2037675251,
  -2054518257,
  -1871679264,
  1111375484,
  -994724495,
  -1436129588,
  -666351472,
  84083462,
  32962295,
  302911004,
  -1553899070,
  1597322602,
  -111716434,
  -793134743,
  -1853454825,
  1489093017,
  656219450,
  -1180787161,
  954327513,
  335083755,
  -1281845205,
  856756514,
  -1150719534,
  1893325225,
  -1987146233,
  -1483434957,
  -1231316179,
  572399164,
  -1836611819,
  552200649,
  1238290055,
  -11184726,
  2015897680,
  2061492133,
  -1886614525,
  -123625127,
  -2138470135,
  386731290,
  -624967835,
  837215959,
  -968736124,
  -1201116976,
  -1019133566,
  -1332111063,
  1999449434,
  286199582,
  -877612933,
  -61582168,
  -692339859,
  974525996,
  -962239645,
  -125535108,
  -291932297,
  -158499973,
  -15863054,
  -692229269,
  -558796945,
  -1856715323,
  1615867952,
  33751297,
  -827758745,
  1451043627,
  -417726722,
  -1251813417,
  1306962859,
  -325421450,
  -1891251510,
  530416258,
  -1992242743,
  -91783811,
  -283772166,
  -1293199015,
  -1899411641,
  -83103504,
  1106029997,
  -1285040940,
  1610457762,
  1173008303,
  599760028,
  1408738468,
  -459902350,
  -1688485696,
  1975695287,
  -518193667,
  1034851219,
  1282024998,
  1817851446,
  2118205247,
  -184354825,
  -2091922228,
  1750873140,
  1374987685,
  -785062427,
  -116854287,
  -493653647,
  -1418471208,
  1649619249,
  708777237,
  135005188,
  -1789737017,
  1181033251,
  -1654733885,
  807933976,
  933336726,
  168756485,
  800430746,
  235472647,
  607523346,
  463175808,
  -549592350,
  -853087253,
  1315514151,
  2144187058,
  -358648459,
  303761673,
  496927619,
  1484008492,
  875436570,
  908925723,
  -592286098,
  -1259447718,
  1543217312,
  -1527360942,
  1984772923,
  -1218324778,
  2110698419,
  1383803177,
  -583080989,
  1584475951,
  328696964,
  -1493871789,
  -1184312879,
  0,
  -1054020115,
  1080041504,
  -484442884,
  2043195825,
  -1225958565,
  -725718422,
  -1924740149,
  1742323390,
  1917532473,
  -1797371318,
  -1730917300,
  -1326950312,
  -2058694705,
  -1150562096,
  -987041809,
  1340451498,
  -317260805,
  -2033892541,
  -1697166003,
  1716859699,
  294946181,
  -1966127803,
  -384763399,
  67502594,
  -25067649,
  -1594863536,
  2017737788,
  632987551,
  1273211048,
  -1561112239,
  1576969123,
  -2134884288,
  92966799,
  1068339858,
  566009245,
  1883781176,
  -251333131,
  1675607228,
  2009183926,
  -1351230758,
  1113792801,
  540020752,
  -451215361,
  -49351693,
  -1083321646,
  -2125673011,
  403966988,
  641012499,
  -1020269332,
  -1092526241,
  899848087,
  -1999879100,
  775493399,
  -1822964540,
  1441965991,
  -58556802,
  2051489085,
  -928226204,
  -1159242403,
  841685273,
  -426413197,
  -1063231392,
  429425025,
  -1630449841,
  -1551901476,
  1147544098,
  1417554474,
  1001099408,
  193169544,
  -1932900794,
  -953553170,
  1809037496,
  675025940,
  -1485185314,
  -1126015394,
  371002123,
  -1384719397,
  -616832800,
  1683370546,
  1951283770,
  337512970,
  -1831122615,
  201983494,
  1215046692,
  -1192993700,
  -1621245246,
  -1116810285,
  1139780780,
  -995728798,
  967348625,
  832869781,
  -751311644,
  -225740423,
  -718084121,
  -1958491960,
  1851340599,
  -625513107,
  25988493,
  -1318791723,
  -1663938994,
  1239460265,
  -659264404,
  -1392880042,
  -217582348,
  -819598614,
  -894474907,
  -191989126,
  1206496942,
  270010376,
  1876277946,
  -259491720,
  1248797989,
  1550986798,
  941890588,
  1475454630,
  1942467764,
  -1756248378,
  -886839064,
  -1585652259,
  -392399756,
  1042358047,
  -1763882165,
  1641856445,
  226921355,
  260409994,
  -527404944,
  2084716094,
  1908716981,
  -861247898,
  -1864873912,
  100991747,
  -150866186,
  470945294,
  -1029480095,
  1784624437,
  -1359390889,
  1775286713,
  395413126,
  -1722236479,
  975641885,
  666476190,
  -650583583,
  -351012616,
  733190296,
  573772049,
  -759469719,
  -1452221991,
  126455438,
  866620564,
  766942107,
  1008868894,
  361924487,
  -920589847,
  -2025206066,
  -1426107051,
  1350051880,
  -1518673953,
  59739276,
  1509466529,
  159418761,
  437718285,
  1708834751,
  -684595482,
  -2067381694,
  -793221016,
  -2101132991,
  699439513,
  1517759789,
  504434447,
  2076946608,
  -1459858348,
  1842789307,
  742004246,
  1667483301,
  2088564868,
  2004348569,
  2071721613,
  -218956019,
  1802229437,
  1869602481,
  -976907948,
  808476752,
  16843267,
  1734856361,
  724260477,
  -16849127,
  -673729182,
  -1414836762,
  1987505306,
  -892694715,
  -2105401443,
  -909539008,
  2105408135,
  -84218091,
  1499050731,
  1195871945,
  -252642549,
  -1381154324,
  -724257945,
  -1566416899,
  -1347467798,
  -1667488833,
  -1532734473,
  1920132246,
  -1061119141,
  -1212713534,
  -33693412,
  -1819066962,
  640044138,
  909536346,
  1061125697,
  -134744830,
  -859012273,
  875849820,
  -1515892236,
  -437923532,
  -235800312,
  1903288979,
  -656888973,
  825320019,
  353708607,
  67373068,
  -943221422,
  589514341,
  -1010590370,
  404238376,
  -1768540255,
  84216335,
  -1701171275,
  117902857,
  303178806,
  -2139087973,
  -488448195,
  -336868058,
  656887401,
  -1296924723,
  1970662047,
  151589403,
  -2088559202,
  741103732,
  437924910,
  454768173,
  1852759218,
  1515893998,
  -1600103429,
  1381147894,
  993752653,
  -690571423,
  -1280082482,
  690573947,
  -471605954,
  791633521,
  -2071719017,
  1397991157,
  -774784664,
  0,
  -303185620,
  538984544,
  -50535649,
  -1313769016,
  1532737261,
  1785386174,
  -875852474,
  -1094817831,
  960066123,
  1246401758,
  1280088276,
  1482207464,
  -808483510,
  -791626901,
  -269499094,
  -1431679003,
  -67375850,
  1128498885,
  1296931543,
  859006549,
  -2054876780,
  1162185423,
  -101062384,
  33686534,
  2139094657,
  1347461360,
  1010595908,
  -1616960070,
  -1465365533,
  1364304627,
  -1549574658,
  1077969088,
  -1886452342,
  -1835909203,
  -1650646596,
  943222856,
  -168431356,
  -1128504353,
  -1229555775,
  -623202443,
  555827811,
  269492272,
  -6886,
  -202113778,
  -757940371,
  -842170036,
  202119188,
  320022069,
  -320027857,
  1600110305,
  -1751698014,
  1145342156,
  387395129,
  -993750185,
  -1482205710,
  2122251394,
  1027439175,
  1684326572,
  1566423783,
  421081643,
  1936975509,
  1616953504,
  -2122245736,
  1330618065,
  -589520001,
  572671078,
  707417214,
  -1869595733,
  -2004350077,
  1179028682,
  -286341335,
  -1195873325,
  336865340,
  -555833479,
  1583267042,
  185275933,
  -606360202,
  -522134725,
  842163286,
  976909390,
  168432670,
  1229558491,
  101059594,
  606357612,
  1549580516,
  -1027432611,
  -741098130,
  -1397996561,
  1650640038,
  -1852753496,
  -1785384540,
  -454765769,
  2038035083,
  -404237006,
  -926381245,
  926379609,
  1835915959,
  -1920138868,
  -707415708,
  1313774802,
  -1448523296,
  1819072692,
  1448520954,
  -185273593,
  -353710299,
  1701169839,
  2054878350,
  -1364310039,
  134746136,
  -1162186795,
  2021191816,
  623200879,
  774790258,
  471611428,
  -1499047951,
  -1263242297,
  -960063663,
  -387396829,
  -572677764,
  1953818780,
  522141217,
  1263245021,
  -1111662116,
  -1953821306,
  -1970663547,
  1886445712,
  1044282434,
  -1246400060,
  1718013098,
  1212715224,
  50529797,
  -151587071,
  235805714,
  1633796771,
  892693087,
  1465364217,
  -1179031088,
  -2038032495,
  -1044276904,
  488454695,
  -1633802311,
  -505292488,
  -117904621,
  -1734857805,
  286335539,
  1768542907,
  -640046736,
  -1903294583,
  -1802226777,
  -1684329034,
  505297954,
  -2021190254,
  -370554592,
  -825325751,
  1431677695,
  673730680,
  -538991238,
  -1936981105,
  -1583261192,
  -1987507840,
  218962455,
  -1077975590,
  -421079247,
  1111655622,
  1751699640,
  1094812355,
  -1718015568,
  757946999,
  252648977,
  -1330611253,
  1414834428,
  -1145344554,
  370551866,
  1673962851,
  2096661628,
  2012125559,
  2079755643,
  -218165774,
  1809235307,
  1876865391,
  -980331323,
  811618352,
  16909057,
  1741597031,
  727088427,
  -18408962,
  -675978537,
  -1420958037,
  1995217526,
  -896580150,
  -2111857278,
  -913751863,
  2113570685,
  -84994566,
  1504897881,
  1200539975,
  -251982864,
  -1388188499,
  -726439980,
  -1570767454,
  -1354372433,
  -1675378788,
  -1538000988,
  1927583346,
  -1063560256,
  -1217019209,
  -35578627,
  -1824674157,
  642542118,
  913070646,
  1065238847,
  -134937865,
  -863809588,
  879254580,
  -1521355611,
  -439274267,
  -235337487,
  1910674289,
  -659852328,
  828527409,
  355090197,
  67636228,
  -946515257,
  591815971,
  -1013096765,
  405809176,
  -1774739050,
  84545285,
  -1708149350,
  118360327,
  304363026,
  -2145674368,
  -488686110,
  -338876693,
  659450151,
  -1300247118,
  1978310517,
  152181513,
  -2095210877,
  743994412,
  439627290,
  456535323,
  1859957358,
  1521806938,
  -1604584544,
  1386542674,
  997608763,
  -692624938,
  -1283600717,
  693271337,
  -472039709,
  794718511,
  -2079090812,
  1403450707,
  -776378159,
  0,
  -306107155,
  541089824,
  -52224004,
  -1317418831,
  1538714971,
  1792327274,
  -879933749,
  -1100490306,
  963791673,
  1251270218,
  1285084236,
  1487988824,
  -813348145,
  -793023536,
  -272291089,
  -1437604438,
  -68348165,
  1132905795,
  1301993293,
  862344499,
  -2062445435,
  1166724933,
  -102166279,
  33818114,
  2147385727,
  1352724560,
  1014514748,
  -1624917345,
  -1471421528,
  1369633617,
  -1554121053,
  1082179648,
  -1895462257,
  -1841320558,
  -1658733411,
  946882616,
  -168753931,
  -1134305348,
  -1233665610,
  -626035238,
  557998881,
  270544912,
  -1762561,
  -201519373,
  -759206446,
  -847164211,
  202904588,
  321271059,
  -322752532,
  1606345055,
  -1758092649,
  1149815876,
  388905239,
  -996976700,
  -1487539545,
  2130477694,
  1031423805,
  1690872932,
  1572530013,
  422718233,
  1944491379,
  1623236704,
  -2129028991,
  1335808335,
  -593264676,
  574907938,
  710180394,
  -1875137648,
  -2012511352,
  1183631942,
  -288937490,
  -1200893000,
  338181140,
  -559449634,
  1589437022,
  185998603,
  -609388837,
  -522503200,
  845436466,
  980700730,
  169090570,
  1234361161,
  101452294,
  608726052,
  1555620956,
  -1029743166,
  -742560045,
  -1404833876,
  1657054818,
  -1858492271,
  -1791908715,
  -455919644,
  2045938553,
  -405458201,
  -930397240,
  929978679,
  1843050349,
  -1929278323,
  -709794603,
  1318900302,
  -1454776151,
  1826141292,
  1454176854,
  -185399308,
  -355523094,
  1707781989,
  2062847610,
  -1371018834,
  135272456,
  -1167075910,
  2029029496,
  625635109,
  777810478,
  473441308,
  -1504185946,
  -1267480652,
  -963161658,
  -389340184,
  -576619299,
  1961401460,
  524165407,
  1268178251,
  -1117659971,
  -1962047861,
  -1978694262,
  1893765232,
  1048330814,
  -1250835275,
  1724688998,
  1217452104,
  50726147,
  -151584266,
  236720654,
  1640145761,
  896163637,
  1471084887,
  -1184247623,
  -2045275770,
  -1046914879,
  490350365,
  -1641563746,
  -505857823,
  -118811656,
  -1741966440,
  287453969,
  1775418217,
  -643206951,
  -1912108658,
  -1808554092,
  -1691502949,
  507257374,
  -2028629369,
  -372694807,
  -829994546,
  1437269845,
  676362280,
  -542803233,
  -1945923700,
  -1587939167,
  -1995865975,
  219813645,
  -1083843905,
  -422104602
}; // weak
_UNKNOWN unk_F4240; // weak
_UNKNOWN unk_F42A8; // weak
_UNKNOWN unk_F42E8; // weak
_UNKNOWN unk_F4328; // weak
_UNKNOWN unk_F4338; // weak
_UNKNOWN unk_F4348; // weak
_UNKNOWN unk_F4368; // weak
_UNKNOWN unk_F4728; // weak
_UNKNOWN unk_F4828; // weak
_UNKNOWN unk_F4928; // weak
_UNKNOWN unk_F4B28; // weak
_UNKNOWN unk_F4D28; // weak
_UNKNOWN unk_F4D68; // weak
_UNKNOWN unk_F4DA8; // weak
_UNKNOWN unk_F4E28; // weak
_UNKNOWN *off_105EF0 = (_UNKNOWN *)0x1F415; // weak
_UNKNOWN *off_105EF4 = (_UNKNOWN *)0x1F3FD; // weak
char *opt_api_description = "jansson 2.12"; // weak
_UNKNOWN *old_cmds = (_UNKNOWN *)0xDEAEC; // weak
_UNKNOWN *new_cmds = (_UNKNOWN *)0xDEAEC; // weak
int opt_bitmain_work_mode = 2; // weak
_UNKNOWN *off_106338 = (_UNKNOWN *)0xDFCB4; // weak
int opt_algo = 8; // weak
int freq_scan_status = 1; // weak
_UNKNOWN *off_1063B8 = (_UNKNOWN *)0xEC054; // weak
int optind = 1; // weak
int optopt = 63; // weak
int dword_1063C4 = -1; // weak
int dword_1063C8 = -1; // weak
int dword_1063CC = -1; // weak
void *(*off_1063D4)(size_t size) = &malloc; // weak
void (*off_1063D8)(void *ptr) = &free; // weak
_UNKNOWN unk_1063DC; // weak
_UNKNOWN unk_1063E4; // weak
_UNKNOWN unk_1063EC; // weak
char *workpadding = "000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"; // weak
int dword_1063F8 = -64; // weak
int fan_pwm = 100; // weak
int dword_106400 = 2147483647; // weak
int dword_106404 = 2147483648; // weak
int dword_106408 = 3; // weak
int dword_10640C = 0; // weak
int dword_106410 = 0; // weak
int dword_106414 = 4; // weak
int dword_106418 = 0; // weak
int dword_10641C = 4; // weak
float flt_106420 = 0.0; // weak
int dword_106424 = 0; // weak
int dword_106428 = 0; // weak
int dword_10642C = 0; // weak
int dword_106430 = 0; // weak
int dword_106434 = 0; // weak
int dword_106438 = 0; // weak
char byte_10643C = '\x01'; // weak
_UNKNOWN *sensor_info_ckb_2042 = &sensors_ckb_2042; // weak
__int64 qword_106444 = 8589934592LL; // weak
__int64 qword_10644C = 343597383775LL; // weak
__int64 qword_106454 = 8589934572LL; // weak
_UNKNOWN *sensor_info_dash_1766 = &sensors_dash_1766; // weak
__int64 qword_106490 = 8589934592LL; // weak
__int64 qword_106498 = 343597383775LL; // weak
__int64 qword_1064A0 = 8589934572LL; // weak
_UNKNOWN *sensor_info_dcr_1727 = &sensors_dcr_1727; // weak
__int64 qword_1064DC = 8589934592LL; // weak
__int64 qword_1064E4 = 343597383775LL; // weak
__int64 qword_1064EC = 8589934572LL; // weak
_UNKNOWN *sensor_info_hns_2130 = &sensors_hns_2130; // weak
__int64 qword_106528 = 8589934592LL; // weak
__int64 qword_106530 = 343597383775LL; // weak
__int64 qword_106538 = 8589934572LL; // weak
_UNKNOWN *sensor_info_kda_2110 = &sensors_kda_2110; // weak
__int64 qword_106574 = 8589934592LL; // weak
__int64 qword_10657C = 343597383775LL; // weak
__int64 qword_106584 = 8589934572LL; // weak
int dword_1065BC = 907; // weak
int dword_1065C0 = -1; // weak
char *lcd_path = "/dev/bitmain-lcd"; // weak
int (*off_106628[26])() =
{
  &scan_miner_device_hal,
  &sub_dev_init_hal,
  &dev_init_hal,
  &dev_init_hal_pcba,
  &dev_config_hal,
  &dev_config_one_chain_baud,
  &power_on_hal,
  &power_off_hal,
  &hardreset_hal,
  &chain_reset_high_hal,
  &chain_reset_low_hal,
  &softreset_hal,
  &convert_offset_to_chain_id,
  &dev_send_work_cmd_hal,
  &dev_send_reg_cmd_hal,
  &dev_read_nonce_reg_data_hal,
  &dev_get_reg_fifo_capacity_hal,
  &dev_get_work_fifo_capacity_hal,
  &dev_get_nonce_reg_fifo_size_hal,
  &dev_dma_rw_dispatcher_hal,
  &heartbeat_to_hal,
  &pic_operation_to_hal,
  &dev_exit_hal,
  &dev_is_valid_hal,
  &set_dev_invalid_hal,
  &dev_init_pic_for_one_chain
}; // weak
int blake256_rounds = 14; // weak
int num_rounds = 43; // weak
_UNKNOWN bit_matrix; // weak
_UNKNOWN coefficients; // weak
int rate = 256; // weak
void *(*off_107620)(void *s, int c, size_t n) = &memset; // weak
_DWORD sha256_k[63] =
{
  1116352408,
  1899447441,
  -1245643825,
  -373957723,
  961987163,
  1508970993,
  -1841331548,
  -1424204075,
  -670586216,
  310598401,
  607225278,
  1426881987,
  1925078388,
  -2132889090,
  -1680079193,
  -1046744716,
  -459576895,
  -272742522,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  -1740746414,
  -1473132947,
  -1341970488,
  -1084653625,
  -958395405,
  -710438585,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  -2117940946,
  -1838011259,
  -1564481375,
  -1474664885,
  -1035236496,
  -949202525,
  -778901479,
  -694614492,
  -200395387,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  -2067236844,
  -1933114872,
  -1866530822,
  -1538233109,
  -1090935817
}; // weak
_UNKNOWN unk_107720; // weak
_UNKNOWN unk_107740; // weak
int listen_sockfd = -1; // weak
_UNKNOWN xxtea_key; // weak
int stdin; // weak
char byte_107944; // weak
int dword_107948; // weak
char s1[]; // idb
int dword_107950; // weak
int dword_107954; // weak
int dword_107958; // weak
char byte_10795C; // weak
char byte_10795D; // weak
int dword_107960; // weak
int dword_107964; // weak
int dword_107968; // weak
double dbl_107970; // weak
int dword_107978; // weak
char byte_107980; // weak
_QWORD max_timeout_value[26]; // weak
char opt_api_remote; // weak
int opt_version_path; // weak
int default_config; // weak
char opt_protocol; // weak
char g_miner_compiletime[64]; // idb
char g_miner_type[64]; // idb
int opt_machine_type; // weak
char g_miner_version[64]; // idb
int opt_custom_freq; // weak
int opt_custom_voltage; // weak
char opt_custom_voltage_swith; // weak
int dword_107B50[]; // weak
pthread_mutex_t mutex; // idb
int dword_107B6C; // weak
pthread_cond_t cond; // idb
int total_pools; // weak
int pools; // weak
int dword_107BA8; // weak
int dword_107BAC; // weak
int dword_107BB0; // weak
pthread_mutex_t stru_107BB4; // idb
int dword_107CD0; // weak
_UNKNOWN unk_107CD4; // weak
char pools_active; // weak
pthread_t newthread; // idb
int hashtable_seed; // weak
unsigned __int8 byte_1085E0[4]; // weak
int dword_1085E4; // weak
int dword_1085E8; // weak
int dword_1085EC; // weak
int dword_1085F0; // weak
int dword_1085F4; // weak
int dword_1085F8; // weak
int dword_1085FC; // weak
int dword_108600; // weak
int dword_108604; // weak
int dword_108608; // weak
int dword_10860C; // weak
int dword_108610; // weak
int dword_108614; // weak
int dword_108618; // weak
int dword_10861C; // weak
int dword_108620; // weak
int dword_108634; // weak
int dword_108638; // weak
int dword_10863C; // weak
int dword_108640; // weak
int dword_108644; // weak
int dword_108648; // weak
int dword_10864C; // weak
int dword_108650; // weak
int dword_108654; // weak
int dword_108658; // weak
int dword_10865C; // weak
int dword_108660; // weak
int dword_108664; // weak
int dword_108668; // weak
int dword_10866C; // weak
int dword_108670; // weak
int dword_108684; // weak
_UNKNOWN unk_1086A4; // weak
int dword_1086C4; // weak
int dword_1086C8; // weak
int dword_1086CC; // weak
int dword_1086D0; // weak
int dword_1086D4; // weak
int dword_1086D8; // weak
int dword_1086DC; // weak
int dword_1086E0; // weak
int dword_1086E4; // weak
int dword_1086E8; // weak
int dword_1086EC; // weak
int dword_1086F0; // weak
int dword_1086F4; // weak
int dword_1086F8; // weak
int dword_1086FC; // weak
int dword_108700; // weak
int dword_108714; // weak
int dword_108718; // weak
int dword_10871C; // weak
int dword_108720; // weak
int dword_108724; // weak
int dword_108728; // weak
int dword_10872C; // weak
int dword_108730; // weak
int dword_108734; // weak
int dword_108738; // weak
int dword_10873C; // weak
int dword_108740; // weak
int dword_108744; // weak
int dword_108748; // weak
int dword_10874C; // weak
int dword_108750; // weak
int dword_108754; // weak
int dword_108768; // weak
int dword_10876C; // weak
int dword_108770; // weak
_UNKNOWN unk_108778; // weak
__int64 qword_108898; // weak
int dword_1088A0; // weak
int dword_1088A4; // weak
int dword_1088A8; // weak
char byte_1088AC; // weak
int dword_1088B0; // weak
char fan_pwm_fixed; // weak
char byte_1088B8; // weak
char byte_1088BC; // weak
_UNKNOWN unk_1088C0; // weak
int dword_1088C4; // weak
char byte_1088C8; // weak
int dword_1088CC; // weak
char byte_1088D0; // weak
char byte_1088D1; // weak
int dword_1088D4; // weak
int dword_1088D8; // weak
char byte_1088E0; // weak
struct timespec stru_1088E4; // idb
int dword_1088EC; // weak
int dword_1088F0; // weak
int dword_1088F8; // weak
float flt_108900; // weak
float flt_108904; // weak
float flt_108908; // weak
float flt_10890C; // weak
float flt_108910; // weak
float flt_108914; // weak
float flt_108918; // weak
float flt_10891C; // weak
float flt_108920; // weak
float flt_108924; // weak
float flt_108928; // weak
int g_miner_sn_file_path; // weak
char byte_108930; // weak
char byte_108934; // weak
char byte_108935; // weak
char byte_108936; // weak
char byte_108937; // weak
char byte_108938; // weak
char byte_108939; // weak
char byte_10893A; // weak
char byte_10893B; // weak
char byte_10893C; // weak
pthread_mutex_t stru_108940; // idb
struct timespec stru_10895C; // idb
struct timespec stru_108964; // idb
_DWORD dword_108978[320]; // weak
_UNKNOWN unk_108E78; // weak
int dword_108ED4; // weak
int dword_108ED8; // weak
int dword_109BF8; // weak
int dword_109BFC; // weak
int dword_109C00; // weak
int dword_109C04; // weak
int dword_109C08; // weak
int dword_109C0C; // weak
unsigned __int8 byte_109C10[16]; // weak
_DWORD dword_109C20[852]; // weak
char fan_inited; // weak
_UNKNOWN unk_10DC28; // weak
_UNKNOWN unk_10DC38; // weak
_UNKNOWN unk_10DD38; // weak
_UNKNOWN unk_10DE38; // weak
_UNKNOWN unk_10DF38; // weak
_UNKNOWN unk_10DFB8; // weak
_DWORD dword_1194B8[96]; // weak
pthread_mutex_t stru_119638; // weak
int dword_119650; // weak
_UNKNOWN unk_119654; // weak
int dword_119754; // weak
int dword_119758; // weak
int dword_11975C; // weak
int dword_119760; // weak
int dword_119764; // weak
int dword_119768; // weak
int dword_11976C; // weak
char byte_119770; // weak
int dword_119774; // weak
int dword_119778; // weak
int dword_11977C; // weak
int dword_119780; // weak
int dword_119784; // weak
int dword_119788; // weak
int dword_11978C; // weak
int dword_119790; // weak
int dword_119794; // weak
int dword_119798; // weak
int dword_11979C; // weak
float flt_1197A0; // weak
float flt_1197A4; // weak
float flt_1197A8; // weak
float flt_1197AC; // weak
int dword_1197B0; // weak
int dword_1197B4; // weak
char byte_1197B8; // weak
char byte_1197B9; // weak
int dword_1197BC; // weak
int dword_1197C0; // weak
int dword_1197C4; // weak
int dword_1197CC; // weak
int dword_1197D4; // weak
int dword_1197D8; // weak
int dword_1197DC; // weak
pthread_mutex_t i2c_mutex_all; // weak
char byte_1197FC; // weak
int platform_inited; // weak
_UNKNOWN unk_119804; // weak
pthread_mutex_t bc_cmd_acc_mutex; // idb
pthread_mutex_t tw_cmd_acc_mutex; // idb
int dword_119958; // weak
int dword_11995C; // weak
int dword_119960; // weak
int dword_119964; // weak
int dword_119968; // weak
pthread_mutex_t stru_11996C; // idb
int dword_119984; // weak
pthread_mutex_t stru_119988; // idb
int dword_1199A0; // weak
int dword_1199A4; // weak
pthread_mutex_t stru_1199A8; // weak
int dword_1199C0[]; // weak
_BYTE algn_1199C4[12]; // weak
_UNKNOWN unk_1199D0; // weak
_UNKNOWN unk_119B50; // weak
int dword_119CD0[]; // weak
pthread_mutex_t stru_119CD4; // idb
int dword_119CEC; // weak
_UNKNOWN *off_119CF0; // weak
int dword_119CF4; // weak
int dword_119CF8; // weak
int dword_119CFC; // weak
int dword_119D00; // weak
int dword_119D04; // weak
int dword_119D08; // weak
int dword_119D0C[]; // weak
int dword_119D10; // weak
_DWORD dword_119D14[17]; // weak
_DWORD dword_119D58[32]; // weak
_UNKNOWN power_mutex; // weak
_UNKNOWN unk_119DEF; // weak
int dword_119DF0; // weak
int dword_119DF4; // weak
int dword_119DF8; // weak
_BYTE algn_119DFC[4]; // weak
char byte_119E00[96]; // weak
_UNKNOWN unk_119E01; // weak
_UNKNOWN unk_119E10; // weak
int dword_119E60; // weak
unsigned __int8 byte_119E68[1088]; // weak
_DWORD dword_11A2A8[256]; // weak
int total_chain; // weak
int dword_11A6AC; // weak
int dword_11A6B0; // weak
pthread_mutex_t stru_11A6B4; // idb
int dword_11A6CC; // weak
int dword_11A6D0; // weak
pthread_mutex_t stru_11A6D4; // idb
_UNKNOWN unk_11A6EC; // weak
_BYTE byte_11A72C[68]; // weak
_BYTE byte_11A770[44]; // weak
int g_logwork_file; // weak
char ExitServer; // weak
_UNKNOWN *http_test_case; // weak
int opt_zlog_conf_file; // weak
int g_zc; // weak
int g_temp_zc; // weak
int g_fan_zc; // weak
int g_hash_zc; // weak
int dword_11A7BC; // weak
pthread_mutex_t stru_11A7C0; // idb
int total_stale; // weak
int dword_11A7DC; // weak
double total_diff_accepted; // weak
int total_discarded; // weak
double total_diff_rejected; // weak
int total_ro; // weak
int last_getwork; // weak
int total_go; // weak
__int64 total_accepted; // weak
int total_getworks; // weak
int dword_11A814; // weak
double total_diff_stale; // weak
int new_blocks; // weak
int local_work; // weak
int total_rejected; // weak
int dword_11A82C; // weak
__int64 total_diff1; // weak
int send_job_timer; // weak
int dword_11A83C; // weak
struct timespec tp; // idb
_UNKNOWN stratum_thr_info; // weak
int thr_info; // weak
pthread_t dword_11AE4C[11]; // weak
pthread_attr_t stru_11AE50; // weak
int dword_11AE78; // weak
pthread_t dword_11AE7C[11]; // weak
int dword_11AEA8; // weak
int dword_11AEAC; // weak
pthread_attr_t attr; // idb
int dword_11AED8; // weak
pthread_t dword_11AEDC[35]; // weak
int search_failed_info[64]; // weak
int reject_reason_map; // weak
int dword_11B06C; // weak
int dword_11B070; // weak
int dword_11B074; // weak
int dword_11B078; // weak
int optreset; // weak
int optarg; // weak
_UNKNOWN last_header_ckb; // weak
_UNKNOWN last_header_dash; // weak
_UNKNOWN last_header_dcr; // weak
_UNKNOWN last_header_hns; // weak
_UNKNOWN last_header_kda; // weak
_DWORD g_bitmain_pic_state[32]; // weak
_DWORD g_chain_info[32]; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (0001E4A0) --------------------------------------------------------
// Alternative name is '_init'
int init_proc()
{
  return sub_1F388();
}

//----- (0001E4AC) --------------------------------------------------------
void sub_1E4AC()
{
  JUMPOUT(0);
}
// 1E4B8: control flows out of bounds to 0

//----- (0001EAF0) --------------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v5; // r6
  char *v6; // r7
  char *v7; // r8
  int v8; // r10
  size_t i; // r6
  const unsigned __int16 **v10; // r0
  int v11; // t1
  const char *v12; // r1
  size_t v13; // r2
  int v14; // r4
  int v16; // r0
  _DWORD *v17; // r0
  void *v18; // r7
  _DWORD *v19; // r5
  int hardware_version; // r8
  _DWORD *all_created_runtime; // r8
  int v22; // r12
  int v23; // r9
  time_t started; // r0
  int v25; // r3
  int v26; // r1
  unsigned int v27; // [sp+0h] [bp-1074h]
  char dest[32]; // [sp+10h] [bp-1064h] BYREF
  char command[64]; // [sp+30h] [bp-1044h] BYREF
  char s[4100]; // [sp+70h] [bp-1004h] BYREF

  memset(s, 0, 0x100u);
  memset(command, 0, sizeof(command));
  snprintf(command, 0x40u, "pidof %s", "godminer");
  v5 = popen(command, "r");
  if ( v5 )
  {
    do
      v6 = fgets(s, 256, v5);
    while ( v6 );
    v7 = s;
    pclose(v5);
    v8 = 0;
    for ( i = 1; strlen(s) >= i; ++i )
    {
      memset(dest, 0, sizeof(dest));
      v10 = _ctype_b_loc();
      v11 = (unsigned __int8)*v7++;
      if ( ((*v10)[v11] & 0x2000) != 0 )
      {
        v12 = &s[(_DWORD)v6];
        v13 = i - (_DWORD)v6 - 1;
        v6 = (char *)i;
        strncpy(dest, v12, v13);
        if ( strtol(dest, 0, 10) > 0 )
          ++v8;
      }
    }
    if ( v8 )
    {
      printf("%d instance of %s is already Running on this machine", v8, "godminer");
      if ( v8 != 1 )
      {
        v14 = 1;
        printf("godminer is forbidden to start again as it is already started, will exit immediately.");
        return v14;
      }
    }
  }
  if ( log_init() )
    puts("log init error!");
  V_LOCK();
  logfmt_raw(s, 0x1000u, 0, "release version");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/god-miner.c",
    139,
    "main",
    4,
    891,
    40,
    s);
  V_LOCK();
  logfmt_raw(s, 0x1000u, 0, "asic mode");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/god-miner.c",
    139,
    "main",
    4,
    896,
    40,
    s);
  while ( 1 )
  {
    v16 = EVPX_EncryptInit_ex(argc, (int)argv, "a:c:hp:Po:u:v:F", (const char **)&off_DECA8, 0);
    if ( v16 < 0 )
      break;
    parse_arg(v16, (char *)optarg);
  }
  if ( argc > optind )
  {
    V_LOCK();
    logfmt_raw(s, 0x1000u, 0, "%s: unsupported non-option argument -- '%s'", *argv, argv[optind]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/god-miner.c",
      139,
      "parse_cmdline",
      13,
      533,
      100,
      s);
    exit(1);
  }
  V_LOCK();
  logfmt_raw(s, 0x1000u, 0, "opt_algo %d, %s", opt_algo, off_DEC5C[opt_algo]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/god-miner.c",
    139,
    "main",
    4,
    900,
    60,
    s);
  if ( !total_pools )
  {
    V_LOCK();
    v14 = 1;
    logfmt_raw(s, 0x1000u, 0, "Need to specify at least one pool server.");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/god-miner.c",
      139,
      "main",
      4,
      906,
      80,
      s);
    V_LOCK();
    logfmt_raw(s, 0x1000u, 0, "Pool setup failed!");
    V_UNLOCK();
    v25 = 907;
    LOWORD(v26) = (unsigned __int16)"/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp"
                                    "/release/build/godminer-origin_godminer-new/god-miner.c";
    v27 = 4;
    goto LABEL_40;
  }
  if ( opt_version_path )
    read_version_file();
  else
    make_fake_version();
  if ( opt_api_remote )
    start_api_thread();
  v17 = dhash_content_init(opt_algo);
  v18 = v17;
  if ( !v17 )
  {
    printf("invalid pointer(%s)!\n", "dhash_content");
    return 3;
  }
  set_frontend_runtime_type((int)v17, opt_algo);
  check_pool_worker();
  if ( check_pool_connect() == 35 )
    return 1;
  v14 = hardware_init(opt_algo);
  if ( !v14 )
  {
    v19 = machine_runtime_init(opt_machine_type, opt_algo);
    if ( !v19 )
    {
      printf("invalid pointer(%s)!\n", "machine_runtime");
      return 3;
    }
    hardware_version = get_hardware_version();
    V_LOCK();
    logfmt_raw(
      s,
      0x1000u,
      0,
      "godminer Version = 0x%04X %s",
      (unsigned __int16)hardware_version,
      "2.0.0_release_dirty_godminer-new_d3bbb0b4626cffb60bb52fb528749eb04d7c4de0_Sep 14 2022 01:04:53");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/god-miner.c",
      139,
      "init_miner_version",
      18,
      610,
      40,
      s);
    sprintf(g_miner_version, "%d.%d-%s", (unsigned __int8)hardware_version, BYTE2(hardware_version), "2.0.0");
    *(_DWORD *)s = 0;
    all_created_runtime = get_all_created_runtime(s);
    if ( is_eeprom_loaded() )
    {
      while ( v14 < *(int *)s )
      {
        v22 = all_created_runtime[v14++];
        (*(void (__fastcall **)(int, int, int))(v22 + 148))(v22, 1, opt_custom_freq);
      }
    }
    show_sn(v19[21]);
    v14 = ((int (__fastcall *)(_DWORD *))v19[7])(v19);
    if ( !v14 )
    {
      signal(2, (__sighandler_t)sub_27540);
      signal(3, (__sighandler_t)sub_27540);
      signal(15, (__sighandler_t)sub_27540);
      signal(11, (__sighandler_t)sub_27540);
      signal(10, (__sighandler_t)sub_27540);
      signal(13, (__sighandler_t)1);
      V_LOCK();
      logfmt_raw(s, 0x1000u, 0, "always catch signal!");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/god-miner.c",
        139,
        "main",
        4u,
        967,
        40,
        s);
      thr_info = 0;
      pthread_attr_init(&stru_11AE50);
      v23 = pthread_create(dword_11AE4C, &stru_11AE50, (void *(*)(void *))work_generator_thread, &thr_info);
      pthread_attr_destroy(&stru_11AE50);
      if ( v23 )
      {
        V_LOCK();
        v14 = 1;
        logfmt_raw(s, 0x1000u, 0, "work generator thread %d create failed");
        V_UNLOCK();
        v25 = 973;
      }
      else
      {
        dword_11AE78 = 1;
        pthread_attr_init((pthread_attr_t *)&dword_11AE7C[1]);
        v14 = pthread_create(
                dword_11AE7C,
                (const pthread_attr_t *)&dword_11AE7C[1],
                (void *(*)(void *))nonce_submit_thread,
                &dword_11AE78);
        pthread_attr_destroy((pthread_attr_t *)&dword_11AE7C[1]);
        if ( !v14 )
        {
          set_elapsed_time_validity(1);
          started = set_miner_start_time();
          miner_monitor_init(started);
          add_chip_status_observer((int)godminer_chip_status_monitor);
          add_fanspeed_observer((int)godminer_fan_monitor);
          miner_monitor_start();
          start_watchpool_thread();
          sleep(0xAu);
          ((void (__fastcall *)(_DWORD *))v19[2])(v19);
          http_test_case_init();
          start_http_thread();
          pthread_join(dword_11AE4C[0], 0);
          V_LOCK();
          logfmt_raw(s, 0x1000u, 0, "workio threads dead, exiting.");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/god-miner.c",
            139,
            "main",
            4u,
            1009,
            80,
            s);
          print_summary();
          dhash_content_exit(v18);
          ((void (*)(void))v19[3])();
          machine_runtime_exit(0);
          return v14;
        }
        V_LOCK();
        v14 = 1;
        logfmt_raw(s, 0x1000u, 0, "simulation submit thread create failed");
        V_UNLOCK();
        v25 = 981;
      }
      LOWORD(v26) = -3308;
      v27 = 4u;
LABEL_40:
      HIWORD(v26) = (unsigned int)"/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/r"
                                  "elease/build/godminer-origin_godminer-new/god-miner.c" >> 16;
      zlog(g_zc, v26, 139, "main", v27, v25, 100, s);
    }
  }
  return v14;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// DEC5C: using guessed type char *[9];
// DECA8: using guessed type char *off_DECA8;
// 1063B0: using guessed type int opt_algo;
// 1063BC: using guessed type int optind;
// 107A58: using guessed type char opt_api_remote;
// 107A5C: using guessed type int opt_version_path;
// 107AE8: using guessed type int opt_machine_type;
// 107B2C: using guessed type int opt_custom_freq;
// 107B30: using guessed type int opt_custom_voltage;
// 107BA0: using guessed type int total_pools;
// 11A7AC: using guessed type int g_zc;
// 11AE48: using guessed type int thr_info;
// 11AE4C: using guessed type pthread_t dword_11AE4C[11];
// 11AE50: using guessed type pthread_attr_t;
// 11AE78: using guessed type int dword_11AE78;
// 11AE7C: using guessed type pthread_t[11];
// 11B080: using guessed type int optarg;

//----- (0001F358) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(void (*a1)(), int a2, int a3, int a4, ...)
{
  int v4; // [sp-4h] [bp-4h]
  va_list va; // [sp+0h] [bp+0h] BYREF

  va_start(va, a4);
  _libc_start_main(
    (int (*)(int, char **, char **))main,
    v4,
    (char **)va,
    (void (*)())init,
    (void (*)())_libc_csu_fini,
    a1,
    va);
  abort();
}
// 1F362: positive sp value 4 has been found
// 1F374: variable 'v4' is possibly undefined
// DD950: using guessed type int init();
// DD98C: using guessed type int _libc_csu_fini();

//----- (0001F388) --------------------------------------------------------
int sub_1F388()
{
  int result; // r0

  if ( &__gmon_start__ )
    return _gmon_start__();
  return result;
}
// 1E7C0: using guessed type int _gmon_start__(void);

//----- (0001F3AC) --------------------------------------------------------
int deregister_tm_clones()
{
  return 1079616;
}

//----- (0001F3D0) --------------------------------------------------------
int register_tm_clones()
{
  return 1079616;
}

//----- (0001F3FC) --------------------------------------------------------
int sub_1F3FC()
{
  int result; // r0

  if ( !byte_107944 )
  {
    result = deregister_tm_clones();
    byte_107944 = 1;
  }
  return result;
}
// 107944: using guessed type char byte_107944;

//----- (0001F418) --------------------------------------------------------
int __fastcall sub_1F418(int result, const char **a2)
{
  bool v2; // zf
  _DWORD *v4; // r5
  _DWORD *v5; // r6
  char *v6; // r0
  _DWORD *v7; // r0
  char *v8; // r0
  char *v9; // r0
  _DWORD v10[4]; // [sp+0h] [bp-20h] BYREF
  _DWORD v11[4]; // [sp+10h] [bp-10h] BYREF

  v2 = a2 == 0;
  if ( a2 )
    v2 = result == 0;
  memset(v10, 0, sizeof(v10));
  memset(v11, 0, sizeof(v11));
  if ( !v2 )
  {
    v4 = (_DWORD *)result;
    v5 = json_object();
    v6 = BUFX_strdup("S");
    json_object_set_new(v5, "STATUS", v6);
    v7 = json_integer(dword_107948);
    json_object_set_new(v5, "when", v7);
    snprintf((char *)v10, 0x10u, "%s", *a2);
    v8 = BUFX_strdup((char *)v10);
    json_object_set_new(v5, "Msg", v8);
    snprintf((char *)v11, 0x10u, "%s", a2[1]);
    v9 = BUFX_strdup((char *)v11);
    json_object_set_new(v5, "api_version", v9);
    return json_object_set_new(v4, "STATUS", v5);
  }
  return result;
}
// 107948: using guessed type int dword_107948;

//----- (0001F534) --------------------------------------------------------
void *__fastcall sub_1F534(_DWORD *a1)
{
  void *result; // r0
  _DWORD *v3; // r5
  char *v4; // r0
  char *v5; // r0
  char *v6; // r0
  char v7[64]; // [sp+0h] [bp-C4h] BYREF
  char s[64]; // [sp+40h] [bp-84h] BYREF
  char v9[68]; // [sp+80h] [bp-44h] BYREF

  memset(v7, 0, sizeof(v7));
  memset(s, 0, sizeof(s));
  result = memset(v9, 0, 0x40u);
  if ( a1 )
  {
    v3 = json_object();
    snprintf(v7, 0x40u, "%s", g_miner_version);
    v4 = BUFX_strdup(v7);
    json_object_set_new(v3, "miner_version", v4);
    snprintf(s, 0x40u, "%s", g_miner_compiletime);
    v5 = BUFX_strdup(s);
    json_object_set_new(v3, "CompileTime", v5);
    snprintf(v9, 0x40u, "%s", g_miner_type);
    v6 = BUFX_strdup(v9);
    json_object_set_new(v3, "type", v6);
    return (void *)json_object_set_new(a1, "INFO", v3);
  }
  return result;
}

//----- (0001F644) --------------------------------------------------------
void *__fastcall sub_1F644(_DWORD *a1, int a2, int a3, const char *a4)
{
  void *result; // r0
  bool v9; // zf
  _DWORD *v10; // r9
  _DWORD *v11; // r6
  __int16 v12; // r3
  char *v13; // r0
  _DWORD *v14; // r0
  _DWORD *v15; // r0
  const char *v16; // r2
  _DWORD *v17; // r3
  char *v18; // r0
  char *v19; // r0
  _DWORD *v20; // r0
  __int16 v21; // [sp+4h] [bp-38h] BYREF
  char s[48]; // [sp+8h] [bp-34h] BYREF

  v21 = 0;
  result = memset(s, 0, sizeof(s));
  v9 = a4 == 0;
  if ( a4 )
    v9 = a1 == 0;
  if ( !v9 )
  {
    v10 = json_array();
    v11 = json_object();
    if ( a2 )
      v12 = 83;
    else
      v12 = 69;
    v21 = v12;
    v13 = BUFX_strdup((char *)&v21);
    json_object_set_new(v11, "STATUS", v13);
    v14 = json_integer(dword_107948);
    json_object_set_new(v11, "When", v14);
    v15 = json_integer(a3);
    json_object_set_new(v11, "Code", v15);
    if ( a3 == 7 )
      LOWORD(v17) = 31648;
    else
      LOWORD(v16) = 6180;
    if ( a3 == 7 )
    {
      HIWORD(v17) = 16;
      snprintf(s, 0x30u, a4, *v17);
    }
    else
    {
      HIWORD(v16) = 14;
      snprintf(s, 0x30u, v16, a4);
    }
    v18 = BUFX_strdup(s);
    json_object_set_new(v11, "Msg", v18);
    v19 = BUFX_strdup(opt_api_description);
    json_object_set_new(v11, "Description", v19);
    json_array_append_new(v10, v11);
    result = (void *)json_object_set_new(a1, "STATUS", v10);
    if ( !a2 )
    {
      v20 = json_integer(1);
      return (void *)json_object_set_new(a1, "id", v20);
    }
  }
  return result;
}
// 1F728: variable 'v17' is possibly undefined
// 1F738: variable 'v16' is possibly undefined
// 106228: using guessed type char *opt_api_description;
// 107948: using guessed type int dword_107948;

//----- (0001F7CC) --------------------------------------------------------
int __fastcall sub_1F7CC(_DWORD *a1, int a2)
{
  _BOOL4 v2; // r4
  _DWORD *v4; // r7
  _DWORD *v5; // r5
  char *v6; // r0
  char *v7; // r0
  char *v8; // r0
  char *v9; // r0
  char *v10; // r0
  _DWORD *v11; // r0
  char v13[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( a2 )
    v2 = a1 == 0;
  else
    v2 = 1;
  if ( v2 )
  {
    V_LOCK();
    logfmt_raw(v13, 0x1000u, 0, "%s: input bad api param\n", "get_version_old");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/api_new.c",
      137,
      "get_version_old",
      15,
      1395,
      100,
      v13);
    return -2147483646;
  }
  else
  {
    sub_1F644(a1, 1, 22, *(const char **)(a2 + 8));
    v4 = json_array();
    v5 = json_object();
    v6 = BUFX_strdup("2.12");
    json_object_set_new(v5, "BMMiner", v6);
    v7 = BUFX_strdup("3.1");
    json_object_set_new(v5, "API", v7);
    v8 = BUFX_strdup(g_miner_version);
    json_object_set_new(v5, "Miner", v8);
    v9 = BUFX_strdup(g_miner_compiletime);
    json_object_set_new(v5, "CompileTime", v9);
    v10 = BUFX_strdup(g_miner_type);
    json_object_set_new(v5, "Type", v10);
    json_array_append_new(v4, v5);
    json_object_set_new(a1, "VERSION", v4);
    v11 = json_integer(1);
    json_object_set_new(a1, "id", v11);
    return 0;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0001F978) --------------------------------------------------------
int __fastcall sub_1F978(int result, int a2, const char *a3)
{
  int *v4; // r4
  int *v5; // r6
  size_t v6; // r0
  int v7; // t1

  if ( a2 <= 0 )
    result = -1;
  if ( a2 > 0 )
  {
    v4 = (int *)result;
    v5 = (int *)(result + 4 * a2);
    v6 = 0;
    do
    {
      v7 = *v4++;
      sprintf((char *)&a3[v6], "%d-", v7);
      v6 = strlen(a3);
    }
    while ( v4 != v5 );
    result = v6 - 1;
  }
  a3[result] = 0;
  return result;
}

//----- (00020788) --------------------------------------------------------
int __fastcall sub_20788(_DWORD *a1, const char **a2)
{
  int v2; // r4
  char *all_created_runtime; // r7
  int v5; // r0
  int v6; // r5
  double v7; // d8
  char *v8; // r0
  _DWORD *v9; // r9
  int v10; // r5
  int v11; // r3
  char *v12; // r0
  int v13; // r9
  char *v14; // r10
  float *v15; // r8
  _DWORD *v16; // r0
  int v17; // t1
  _DWORD *v18; // r7
  char *v19; // r0
  _DWORD *v20; // r5
  float *v21; // r11
  float v22; // s14
  _DWORD *v23; // r0
  char *v25; // r6
  char *v26; // r0
  char *v27; // r7
  char *v28; // r8
  int v29; // t1
  bool v30; // cc
  unsigned __int64 v31; // r6
  double v32; // d0
  int v33; // [sp+14h] [bp-1048h]
  _DWORD *v34; // [sp+18h] [bp-1044h]
  _DWORD *v35; // [sp+2Ch] [bp-1030h]
  _QWORD *v36; // [sp+30h] [bp-102Ch]
  char *ptr; // [sp+38h] [bp-1024h]
  _DWORD *v39; // [sp+3Ch] [bp-1020h]
  int v40; // [sp+44h] [bp-1018h] BYREF
  char s[4]; // [sp+48h] [bp-1014h] BYREF
  int v42; // [sp+4Ch] [bp-1010h]
  _DWORD v43[2]; // [sp+50h] [bp-100Ch] BYREF
  double v44[512]; // [sp+58h] [bp-1004h] BYREF

  v2 = 0;
  v40 = 0;
  *(_DWORD *)s = 0;
  v43[0] = 0;
  v42 = 0;
  v43[1] = 0;
  all_created_runtime = (char *)get_all_created_runtime(&v40);
  v5 = frontend_runtime_instance();
  if ( a2 )
  {
    v6 = v5;
    sub_1F418((int)a1, a2);
    sub_1F534(a1);
    if ( v40 > 0 )
    {
      v36 = malloc(216 * v40);
      v25 = (char *)v36;
      v26 = (char *)malloc(4 * v40);
      ptr = v26;
      if ( v40 > 0 )
      {
        v27 = all_created_runtime - 4;
        v28 = v26 - 4;
        do
        {
          v29 = *((_DWORD *)v27 + 1);
          v27 += 4;
          read_status_from_monitor(v25, v29);
          ++v2;
          v25 += 216;
          v30 = v40 <= v2;
          *((_DWORD *)v28 + 1) = *(_DWORD *)(*(_DWORD *)v27 + 200);
          v28 += 4;
        }
        while ( !v30 );
      }
      v31 = v36[26];
      v32 = *((double *)v36 + 6);
      if ( v31 > 0x18 )
        LODWORD(v31) = 24;
      v33 = v31;
      format_hashrate_double(*(_DWORD *)(*(_DWORD *)(v6 + 68) + 12), v44, (char *)v43);
      v7 = v32;
    }
    else
    {
      ptr = 0;
      v36 = 0;
      v33 = 0;
      v7 = 1.0;
    }
    v39 = json_array();
    v35 = json_object();
    if ( !v40 )
    {
      format_hashrate_double(*(_DWORD *)(*(_DWORD *)(v6 + 68) + 12), v44, (char *)v43);
      v7 = 1.0;
    }
    v8 = BUFX_strdup((char *)v43);
    json_object_set_new(v35, "unit", v8);
    v9 = json_array();
    if ( v33 )
    {
      v10 = 15;
      do
      {
        v11 = v10;
        *(_DWORD *)s = 0;
        v10 += 15;
        v42 = 0;
        snprintf(s, 8u, "%dmin", v11);
        v12 = BUFX_strdup(s);
        json_array_append_new(v9, v12);
      }
      while ( v10 != 15 * (v33 + 1) );
    }
    json_object_set_new(v35, "xAxis", v9);
    v34 = json_array();
    if ( v40 > 0 )
    {
      v13 = 0;
      v14 = ptr - 4;
      v15 = (float *)(v36 + 13);
      do
      {
        v16 = json_object();
        v17 = *((_DWORD *)v14 + 1);
        v14 += 4;
        *(_DWORD *)s = 0;
        v42 = 0;
        v18 = v16;
        snprintf(s, 8u, "chain%d", v17);
        v19 = BUFX_strdup(s);
        json_object_set_new(v18, "name", v19);
        v20 = json_array();
        if ( v33 )
        {
          v21 = v15;
          do
          {
            v22 = *v21++;
            v44[0] = v22 * v7;
            v23 = json_integer((__int64)v44[0]);
            json_array_append_new(v20, v23);
          }
          while ( &v15[v33] != v21 );
        }
        ++v13;
        json_object_set_new(v18, "data", v20);
        json_array_append_new(v34, v18);
        v15 += 54;
      }
      while ( v40 > v13 );
    }
    json_object_set_new(v35, "series", v34);
    json_array_append_new(v39, v35);
    json_object_set_new(a1, "RATE", v39);
    if ( v40 > 0 )
    {
      free(ptr);
      free(v36);
    }
    return 0;
  }
  else
  {
    V_LOCK();
    logfmt_raw((char *)v44, 0x1000u, 0, "%s: input bad api param\n", "get_rate");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/api_new.c",
      137,
      "get_rate",
      8,
      771,
      100,
      v44);
    return -2147483646;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00020B88) --------------------------------------------------------
int __fastcall sub_20B88(_DWORD *a1, const char **a2)
{
  bool v4; // zf
  __int64 v5; // kr00_8
  int v6; // r5
  _DWORD *v7; // r4
  _DWORD *v8; // r0
  char *v9; // r0
  char *v10; // r0
  int v11; // r2
  int *v12; // r3
  int v13; // r1
  char *v14; // r0
  _DWORD *v15; // r0
  _DWORD *v16; // r0
  _DWORD *v17; // r0
  _DWORD *v18; // r0
  _DWORD *v19; // r0
  _DWORD *v20; // r0
  char *v21; // r0
  _DWORD *v22; // r0
  double *v23; // r0
  _DWORD *v24; // r0
  _DWORD *v25; // r0
  _DWORD *v26; // r0
  int v27; // r3
  bool v28; // cc
  unsigned int v29; // lr
  char *v30; // r0
  _DWORD *v32; // [sp+14h] [bp-1150h]
  int v34; // [sp+2Ch] [bp-1138h] BYREF
  int v35; // [sp+30h] [bp-1134h]
  int v36; // [sp+34h] [bp-1130h]
  char v37[4]; // [sp+38h] [bp-112Ch] BYREF
  int v38; // [sp+3Ch] [bp-1128h]
  int v39; // [sp+40h] [bp-1124h]
  int v40; // [sp+44h] [bp-1120h]
  char v41[4]; // [sp+48h] [bp-111Ch] BYREF
  int v42; // [sp+4Ch] [bp-1118h]
  int v43; // [sp+50h] [bp-1114h]
  int v44; // [sp+54h] [bp-1110h]
  int v45; // [sp+58h] [bp-110Ch]
  int v46; // [sp+5Ch] [bp-1108h]
  char s[128]; // [sp+60h] [bp-1104h] BYREF
  char v48[128]; // [sp+E0h] [bp-1084h] BYREF
  char v49[4100]; // [sp+160h] [bp-1004h] BYREF

  memset(s, 0, sizeof(s));
  memset(v48, 0, sizeof(v48));
  v4 = a1 == 0;
  if ( a1 )
    v4 = a2 == 0;
  v35 = 0;
  v36 = 0;
  v34 = 0;
  *(_DWORD *)v37 = 0;
  *(_DWORD *)v41 = 0;
  v38 = 0;
  v39 = 0;
  v40 = 0;
  v42 = 0;
  v43 = 0;
  v44 = 0;
  v45 = 0;
  v46 = 0;
  if ( v4 )
  {
    V_LOCK();
    logfmt_raw(v49, 0x1000u, 0, "%s: input bad api param\n", "get_pools");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/api_new.c",
      137,
      "get_pools",
      9,
      477,
      100,
      v49);
    return -2147483646;
  }
  else
  {
    sub_1F418((int)a1, a2);
    sub_1F534(a1);
    v32 = json_array();
    if ( total_pools > 0 )
    {
      v5 = 0;
      do
      {
        v6 = *(_DWORD *)(pools + 4 * v5);
        if ( v6 )
        {
          v7 = json_object();
          v8 = json_integer(v5);
          json_object_set_new(v7, "index", v8);
          memset(s, 0, sizeof(s));
          snprintf(s, 0x80u, "%s", *(const char **)(v6 + 8));
          v9 = BUFX_strdup(s);
          json_object_set_new(v7, "url", v9);
          memset(v48, 0, sizeof(v48));
          snprintf(v48, 0x80u, "%s", *(const char **)(v6 + 12));
          v10 = BUFX_strdup(v48);
          json_object_set_new(v7, "user", v10);
          v11 = *(unsigned __int8 *)(v6 + 1896);
          v35 = 0;
          v34 = 0;
          v36 = 0;
          if ( v11 )
            LOWORD(v12) = -8480;
          else
            LOWORD(v12) = -8472;
          HIWORD(v12) = 13;
          v13 = v12[1];
          v34 = *v12;
          if ( v11 )
            LOBYTE(v35) = v13;
          else
            LOWORD(v35) = v13;
          v14 = BUFX_strdup((char *)&v34);
          json_object_set_new(v7, "status", v14);
          v15 = json_integer(*(int *)(v6 + 4));
          json_object_set_new(v7, "priority", v15);
          v16 = json_integer(*(unsigned int *)(v6 + 1624));
          json_object_set_new(v7, "getworks", v16);
          v17 = json_integer(*(_QWORD *)(v6 + 1920));
          json_object_set_new(v7, "accepted", v17);
          v18 = json_integer(*(_QWORD *)(v6 + 1928));
          json_object_set_new(v7, "rejected", v18);
          v19 = json_integer(*(unsigned int *)(v6 + 1936));
          json_object_set_new(v7, "discarded", v19);
          v20 = json_integer(*(unsigned int *)(v6 + 1632));
          json_object_set_new(v7, "stale", v20);
          *(_DWORD *)v37 = 0;
          v38 = 0;
          v39 = 0;
          v40 = 0;
          snprintf(v37, 0x10u, "%s", (const char *)(v6 + 1968));
          v21 = BUFX_strdup(v37);
          json_object_set_new(v7, "diff", v21);
          v22 = json_integer(*(_QWORD *)(v6 + 1984));
          json_object_set_new(v7, "diff1", v22);
          v23 = json_real();
          json_object_set_new(v7, "diffa", v23);
          v24 = json_integer((__int64)*(double *)(v6 + 1960));
          json_object_set_new(v7, "diffr", v24);
          v25 = json_integer((__int64)*(double *)(v6 + 1808));
          json_object_set_new(v7, "diffs", v25);
          v26 = json_integer((__int64)*(double *)(v6 + 1616));
          json_object_set_new(v7, "lsdiff", v26);
          v27 = *(_DWORD *)(v6 + 1608);
          *(_DWORD *)v41 = 0;
          v42 = 0;
          v28 = v27 <= 0;
          v43 = 0;
          if ( v27 <= 0 )
            LOWORD(v27) = 48;
          v44 = 0;
          v45 = 0;
          v46 = 0;
          if ( v28 )
          {
            *(_WORD *)v41 = v27;
          }
          else
          {
            v29 = time(0) - *(_DWORD *)(v6 + 1608);
            snprintf(v41, 0x18u, "%d:%d:%d", v29 / 0xE10, v29 % 0xE10 / 0x3C, v29 % 0xE10 % 0x3C);
          }
          v30 = BUFX_strdup(v41);
          json_object_set_new(v7, "lstime", v30);
          json_array_append_new(v32, v7);
        }
        ++v5;
      }
      while ( (int)v5 < total_pools );
    }
    json_object_set_new(a1, "POOLS", v32);
    return 0;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 107BA0: using guessed type int total_pools;
// 107BA4: using guessed type int pools;
// 11A7AC: using guessed type int g_zc;

//----- (000210A8) --------------------------------------------------------
int __fastcall sub_210A8(_DWORD *a1, int a2)
{
  bool v4; // zf
  int v5; // r5
  __int64 v6; // kr00_8
  _DWORD *v7; // r2
  _DWORD *v8; // r0
  char *v9; // r0
  _DWORD *v10; // r0
  double *v11; // r0
  double v12; // d5
  double v13; // d7
  double *v14; // r0
  double v15; // d7
  double *v16; // r0
  int v17; // r5
  _DWORD *v18; // r4
  _DWORD *v19; // r0
  char *v20; // r0
  int v21; // r2
  int *v22; // r3
  int v23; // r1
  char *v24; // r0
  _DWORD *v25; // r0
  _DWORD *v26; // r0
  char *v27; // r0
  _DWORD *v28; // r0
  _DWORD *v29; // r0
  _DWORD *v30; // r0
  _DWORD *v31; // r0
  _DWORD *v32; // r0
  _DWORD *v33; // r0
  _DWORD *v34; // r0
  char *v35; // r0
  int v36; // r3
  bool v37; // cc
  unsigned int v38; // r0
  char *v39; // r0
  double *v40; // r8
  double *v41; // r9
  char *v42; // r0
  _DWORD *v43; // r0
  char *v44; // r0
  char *v45; // r0
  double *v46; // r0
  double *v47; // r0
  double *v48; // r0
  double *v49; // r0
  _DWORD *v50; // r0
  _DWORD *v52; // [sp+24h] [bp-1140h]
  int v54; // [sp+3Ch] [bp-1128h] BYREF
  int v55; // [sp+40h] [bp-1124h]
  int v56; // [sp+44h] [bp-1120h]
  char v57[4]; // [sp+48h] [bp-111Ch] BYREF
  int v58; // [sp+4Ch] [bp-1118h]
  int v59; // [sp+50h] [bp-1114h]
  int v60; // [sp+54h] [bp-1110h]
  int v61; // [sp+58h] [bp-110Ch]
  int v62; // [sp+5Ch] [bp-1108h]
  char s[128]; // [sp+60h] [bp-1104h] BYREF
  char v64[128]; // [sp+E0h] [bp-1084h] BYREF
  char v65[4100]; // [sp+160h] [bp-1004h] BYREF

  memset(s, 0, sizeof(s));
  memset(v64, 0, sizeof(v64));
  v4 = a1 == 0;
  if ( a1 )
    v4 = a2 == 0;
  v55 = 0;
  v56 = 0;
  v54 = 0;
  *(_DWORD *)v57 = 0;
  v58 = 0;
  v59 = 0;
  v60 = 0;
  v61 = 0;
  v62 = 0;
  if ( v4 )
  {
    v5 = -2147483646;
    V_LOCK();
    logfmt_raw(v65, 0x1000u, 0, "%s: input bad api param\n", "get_pools_old");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/api_new.c",
      137,
      "get_pools_old",
      13,
      1015,
      100,
      v65);
  }
  else
  {
    v5 = total_pools;
    if ( total_pools )
    {
      sub_1F644(a1, 1, 7, *(const char **)(a2 + 8));
      v52 = json_array();
      if ( total_pools > 0 )
      {
        v6 = 0;
        do
        {
          v17 = *(_DWORD *)(pools + 4 * v6);
          v18 = json_object();
          v19 = json_integer(v6);
          json_object_set_new(v18, "POOL", v19);
          memset(s, 0, sizeof(s));
          snprintf(s, 0x80u, "%s", *(_DWORD *)(v17 + 8));
          v20 = BUFX_strdup(s);
          json_object_set_new(v18, "URL", v20);
          v21 = *(unsigned __int8 *)(v17 + 1896);
          v54 = 0;
          v55 = 0;
          v56 = 0;
          if ( v21 )
            LOWORD(v22) = -8312;
          else
            LOWORD(v22) = -8472;
          HIWORD(v22) = 13;
          v23 = v22[1];
          v54 = *v22;
          if ( v21 )
            LOBYTE(v55) = v23;
          else
            LOWORD(v55) = v23;
          v24 = BUFX_strdup((char *)&v54);
          json_object_set_new(v18, "Status", v24);
          v25 = json_integer(*(int *)(v17 + 4));
          json_object_set_new(v18, "Priority", v25);
          v26 = json_integer(*(int *)(v17 + 1628));
          json_object_set_new(v18, "Quota", v26);
          v27 = BUFX_strdup("N");
          json_object_set_new(v18, "Long Poll", v27);
          v28 = json_integer(*(unsigned int *)(v17 + 1624));
          json_object_set_new(v18, "Getworks", v28);
          v29 = json_integer(*(_QWORD *)(v17 + 1920));
          json_object_set_new(v18, "Accepted", v29);
          v30 = json_integer(*(_QWORD *)(v17 + 1928));
          json_object_set_new(v18, "Rejected", v30);
          v31 = json_integer(*(unsigned int *)(v17 + 1936));
          json_object_set_new(v18, "Discarded", v31);
          v32 = json_integer(*(unsigned int *)(v17 + 1632));
          json_object_set_new(v18, "Stale", v32);
          v33 = json_integer(*(unsigned int *)(v17 + 1940));
          json_object_set_new(v18, "Get Failures", v33);
          v34 = json_integer(*(unsigned int *)(v17 + 1944));
          json_object_set_new(v18, "Remote Failures", v34);
          memset(v64, 0, sizeof(v64));
          snprintf(v64, 0x80u, "%s", *(_DWORD *)(v17 + 12));
          v35 = BUFX_strdup(v64);
          json_object_set_new(v18, "User", v35);
          v36 = *(_DWORD *)(v17 + 1608);
          *(_DWORD *)v57 = 0;
          v58 = 0;
          v37 = v36 <= 0;
          v59 = 0;
          if ( v36 <= 0 )
            LOWORD(v36) = 48;
          v60 = 0;
          v61 = 0;
          v62 = 0;
          if ( v37 )
          {
            *(_WORD *)v57 = v36;
          }
          else
          {
            v38 = time(0) - *(_DWORD *)(v17 + 1608);
            snprintf(v57, 0x18u, "%d:%d:%d", v38 / 0xE10, v38 % 0xE10 / 0x3C, v38 % 0xE10 % 0x3C);
          }
          v39 = BUFX_strdup(v57);
          json_object_set_new(v18, "Last Share Time", v39);
          v40 = (double *)(v17 + 1808);
          v41 = (double *)(v17 + 1952);
          sprintf((char *)(v17 + 1968), "%8.4f", *(double *)(v17 + 1800));
          v42 = BUFX_strdup((char *)(v17 + 1968));
          json_object_set_new(v18, "Diff", v42);
          v43 = json_integer(*(_QWORD *)(v17 + 1984));
          json_object_set_new(v18, "Diff1 Shares", v43);
          v44 = BUFX_strdup("");
          json_object_set_new(v18, "Proxy Type", v44);
          v45 = BUFX_strdup("");
          json_object_set_new(v18, "Proxy", v45);
          sub_DD47C((__int64)(*(double *)(v17 + 1952) * 100.0));
          v46 = json_real();
          json_object_set_new(v18, "Difficulty Accepted", v46);
          sub_DD47C((__int64)(*(double *)(v17 + 1960) * 100.0));
          v47 = json_real();
          json_object_set_new(v18, "Difficulty Rejected", v47);
          sub_DD47C((__int64)(*(double *)(v17 + 1808) * 100.0));
          v48 = json_real();
          json_object_set_new(v18, "Difficulty Stale", v48);
          sub_DD47C((__int64)(*(double *)(v17 + 1616) * 100.0));
          v49 = json_real();
          json_object_set_new(v18, "Last Share Difficulty", v49);
          if ( *(_BYTE *)(v17 + 24) )
            v7 = json_true();
          else
            v7 = json_false();
          json_object_set_new(v18, "Has Stratum", v7);
          v8 = json_true();
          json_object_set_new(v18, "Stratum Active", v8);
          v9 = BUFX_strdup("");
          json_object_set_new(v18, "Stratum URL", v9);
          v10 = json_false();
          json_object_set_new(v18, "Has GBT", v10);
          v11 = json_real();
          json_object_set_new(v18, "Best Share", v11);
          v12 = *(double *)(v17 + 1960);
          v13 = v12 + *v41 + *v40;
          if ( v13 != 0.0 )
            sub_DD47C((__int64)(v12 / v13 * 100.0));
          v14 = json_real();
          json_object_set_new(v18, "Pool Rejected%", v14);
          v15 = *v41 + *(double *)(v17 + 1960) + *v40;
          if ( v15 != 0.0 )
            sub_DD47C((__int64)(*v40 / v15 * 100.0));
          v16 = json_real();
          json_object_set_new(v18, "Pool Stale%%", v16);
          json_array_append_new(v52, v18);
          ++v6;
        }
        while ( total_pools > (int)v6 );
      }
      v5 = 0;
      json_object_set_new(a1, "POOLS", v52);
      v50 = json_integer(1);
      json_object_set_new(a1, "id", v50);
    }
    else
    {
      sub_1F644(a1, 0, 8, "No pools");
    }
  }
  return v5;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 107BA0: using guessed type int total_pools;
// 107BA4: using guessed type int pools;
// 11A7AC: using guessed type int g_zc;

//----- (0002186C) --------------------------------------------------------
int sub_2186C()
{
  int v0; // r8
  char v2[4100]; // [sp+10h] [bp-1004h] BYREF

  V_LOCK();
  logfmt_raw(v2, 0x1000u, 0, "<<<<<<<<<<<<<<<<<<<<exec %s start>>>>>>>>>>>>>>>>", "reload_config");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/api_new.c",
    137,
    "reload_config",
    13,
    856,
    20,
    v2);
  v0 = strcmp(s1, "127.0.0.1");
  if ( v0 )
    return -2147483643;
  V_LOCK();
  logfmt_raw(v2, 0x1000u, 0, "START %s", "load_default_config_without_restart");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/api_new.c",
    137,
    "load_default_config_without_restart",
    35,
    839,
    20,
    v2);
  if ( default_config
    && !access((const char *)default_config, 4)
    && (judge_load_config((char *)default_config) & 1) != 0 )
  {
    reload_pool();
  }
  V_LOCK();
  logfmt_raw(v2, 0x1000u, 0, "<<<<<<<<<<<<<<<<<<<<exec %s end>>>>>>>>>>>>>>>>>>", "reload_config");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/api_new.c",
    137,
    "reload_config",
    13,
    863,
    20,
    v2);
  return v0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 107A60: using guessed type int default_config;
// 11A7AC: using guessed type int g_zc;

//----- (000219FC) --------------------------------------------------------
int *__fastcall sub_219FC(int *result)
{
  int v1; // r2
  int *v2; // r4

  v1 = *result;
  byte_10795C = 1;
  if ( v1 != -1 )
  {
    v2 = result;
    shutdown(v1, 2);
    result = (int *)close(*v2);
    *v2 = -1;
  }
  return result;
}
// 10795C: using guessed type char byte_10795C;

//----- (00021A40) --------------------------------------------------------
int __fastcall sub_21A40(_DWORD *a1, const char *a2, int a3, unsigned int a4)
{
  int result; // r0
  const char *v9; // r1
  int v10; // r4
  const char *v11; // r1
  _UNKNOWN **v12; // r8
  const char *v13; // t1
  char *v14; // r0
  char dest[4]; // [sp+4h] [bp-78h] BYREF
  int v16; // [sp+8h] [bp-74h]
  int v17; // [sp+Ch] [bp-70h]
  int v18; // [sp+10h] [bp-6Ch]
  char s[104]; // [sp+14h] [bp-68h] BYREF

  memset(s, 0, 0x64u);
  if ( !a1 || a4 > 2 )
    return -2147483646;
  result = strlen(a2);
  v16 = 0;
  *(_DWORD *)dest = 0;
  v17 = 0;
  v18 = 0;
  if ( (unsigned int)(result - 1) > 0xF )
  {
    if ( a4 )
      return result;
    goto LABEL_23;
  }
  strncpy(dest, a2, result);
  if ( a4 )
  {
    v9 = (const char *)old_cmds;
    if ( !old_cmds )
      return (int)sub_1F644(a1, 0, 14, "Invalid command");
    v10 = 0;
    while ( strcmp(dest, v9) )
    {
      ++v10;
      v9 = (const char *)*(&old_cmds + 4 * v10);
      if ( !v9 )
        return (int)sub_1F644(a1, 0, 14, "Invalid command");
    }
    return ((int (__fastcall *)(_DWORD *, _UNKNOWN **, int))(&opt_api_description)[4 * v10 + 4])(
             a1,
             &old_cmds + 4 * v10,
             a3);
  }
  v11 = (const char *)new_cmds;
  if ( !new_cmds )
  {
LABEL_20:
    snprintf(s, 0x64u, "not support (%s)", a2);
    goto LABEL_19;
  }
  v12 = &new_cmds;
  while ( strcmp(dest, v11) )
  {
    v13 = (const char *)v12[3];
    v12 += 3;
    v11 = v13;
    ++a4;
    if ( !v13 )
      goto LABEL_20;
  }
  result = ((int (__fastcall *)(_DWORD *, _UNKNOWN **))(&opt_api_description)[3 * a4 + 51])(a1, &new_cmds + 3 * a4);
  if ( result < 0 )
  {
    if ( result != -2147483646 )
    {
LABEL_19:
      v14 = BUFX_strdup(s);
      return json_object_set_new(a1, "error_message", v14);
    }
LABEL_23:
    strcpy(s, "bad param");
    goto LABEL_19;
  }
  return result;
}
// 106228: using guessed type char *opt_api_description;
// 10622C: using guessed type _UNKNOWN *old_cmds;
// 1062EC: using guessed type _UNKNOWN *new_cmds;

//----- (00021C04) --------------------------------------------------------
char *__fastcall sub_21C04(char *a1, int *a2)
{
  double v2; // d0
  char *result; // r0
  int v6; // r3
  __int64 v7; // r0
  const char *v8; // r0
  _DWORD s[65]; // [sp+8h] [bp-104h] BYREF

  result = (char *)memset(s, 0, 0x100u);
  if ( a2 )
  {
    v6 = *a2;
    if ( *a2 == 6 )
    {
      strcpy((char *)s, "false");
    }
    else
    {
      switch ( v6 )
      {
        case 5:
          strcpy((char *)s, "true");
          break;
        case 3:
          v7 = json_integer_value((int)a2);
          snprintf((char *)s, 0x100u, "%lld", v7);
          break;
        case 4:
          json_real_value();
          snprintf((char *)s, 0x100u, "%.2lf", v2);
          break;
        case 2:
          v8 = (const char *)json_string_value(a2);
          snprintf((char *)s, 0x100u, "%s", v8);
          break;
      }
    }
    return strcat(a1, (const char *)s);
  }
  return result;
}
// 21CDC: variable 'v2' is possibly undefined

//----- (00021D08) --------------------------------------------------------
int __fastcall sub_21D08(int result, _DWORD *a2, int a3)
{
  int v3; // r4
  _DWORD *v4; // r12
  int v5; // r3
  int v6; // t1
  _DWORD *v7; // r6
  char *v9; // r0
  _DWORD *v10; // r0
  char *v11; // r2
  int v12; // r5

  v3 = a2[2];
  if ( v3 > 0 )
  {
    v4 = (_DWORD *)a2[4];
    if ( a3 == *v4 )
    {
      v12 = 0;
LABEL_7:
      v7 = (_DWORD *)result;
      v9 = BUFX_strdup(*(char **)(a2[3] + v12));
      json_object_set_new(v7, "status", v9);
      v10 = json_integer(*(int *)(a2[4] + v12));
      json_object_set_new(v7, "code", v10);
      v11 = BUFX_strdup(*(char **)(a2[5] + v12));
      return json_object_set_new(v7, "msg", v11);
    }
    else
    {
      v5 = 0;
      while ( 1 )
      {
        ++v5;
        v12 = 4 * v5;
        if ( v5 == v3 )
          break;
        v6 = v4[1];
        ++v4;
        if ( v6 == a3 )
          goto LABEL_7;
      }
    }
  }
  return result;
}

//----- (00021EB0) --------------------------------------------------------
int __fastcall sub_21EB0(int a1, _DWORD *a2)
{
  int result; // r0
  _BYTE v5[16]; // [sp+4h] [bp-10h] BYREF

  result = get_miner_working_status((int)v5);
  if ( a1 )
  {
    if ( a2 )
      return sub_21D08(a1, a2, -v5[5]);
  }
  return result;
}

//----- (00021EFC) --------------------------------------------------------
int sub_21EFC()
{
  char v1[4100]; // [sp+10h] [bp-1004h] BYREF

  V_LOCK();
  logfmt_raw(v1, 0x1000u, 0, "%s: input bad api param\n", "reset_fpga_baud_old");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/api_new.c",
    137,
    "reset_fpga_baud_old",
    19,
    1687,
    100,
    v1);
  return -2147483646;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00022010) --------------------------------------------------------
ssize_t __fastcall sub_22010(int *a1, char *s)
{
  int v3; // r9
  char *v4; // r7
  signed int v5; // r6
  fd_set *p_tv_usec; // r3
  int v7; // r0
  int v8; // lr
  int v9; // r0
  ssize_t result; // r0
  _BOOL4 v11; // r3
  int *v12; // r0
  int *v13; // r10
  char *v14; // r0
  int v15; // r2
  int v16; // r10
  signed int v17; // [sp+10h] [bp-1094h]
  struct timeval timeout; // [sp+18h] [bp-108Ch] BYREF
  fd_set writefds; // [sp+20h] [bp-1084h] BYREF
  char v20[4100]; // [sp+A0h] [bp-1004h] BYREF

  v3 = 0;
  v4 = s;
  v5 = strlen(s) + 1;
  v17 = v5;
  while ( 1 )
  {
    p_tv_usec = (fd_set *)&timeout.tv_usec;
    timeout.tv_sec = 0;
    timeout.tv_usec = 50000;
    do
    {
      p_tv_usec->__fds_bits[1] = 0;
      p_tv_usec = (fd_set *)((char *)p_tv_usec + 4);
    }
    while ( p_tv_usec != (fd_set *)&writefds.__fds_bits[31] );
    v7 = *a1;
    LOBYTE(v8) = *a1 & 0x1F;
    if ( *a1 <= 0 )
      v8 = -(-v7 & 0x1F);
    writefds.__fds_bits[*a1 / 32] |= 1 << v8;
    v9 = select(v7 + 1, 0, &writefds, 0, &timeout);
    if ( v9 <= 0 )
      break;
    result = send(*a1, v4, v5, 0);
    if ( result < 0 )
    {
      v12 = _errno_location();
      if ( *v12 != 11 )
      {
        v13 = v12;
        V_LOCK();
        v14 = strerror(*v13);
        logfmt_raw(v20, 0x1000u, 0, "%s: send (%d:%d) failed %s", "send_api_result", v17, v17 - v5, v14);
        V_UNLOCK();
        v15 = 1988;
        return zlog(
                 g_zc,
                 "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godm"
                 "iner-origin_godminer-new/api_new.c",
                 137,
                 "send_api_result",
                 15,
                 v15,
                 100,
                 v20);
      }
      V_LOCK();
      ++v3;
      logfmt_raw(v20, 0x1000u, 0, "%s: send EAGAIN ", "send_api_result");
      V_UNLOCK();
      result = zlog(
                 g_zc,
                 "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godm"
                 "iner-origin_godminer-new/api_new.c",
                 137,
                 "send_api_result",
                 15,
                 1984,
                 20,
                 v20);
      v11 = v3 > 2;
      if ( v5 <= 0 )
        v11 = 1;
    }
    else
    {
      if ( !result )
        ++v3;
      v5 -= result;
      v4 += result;
      v11 = v3 > 2;
      if ( v5 <= 0 )
        v11 = 1;
    }
    if ( v11 )
      return result;
  }
  v16 = v9;
  V_LOCK();
  logfmt_raw(v20, 0x1000u, 0, "%s: send select failed, ret = %d", "send_api_result", v16);
  V_UNLOCK();
  v15 = 1976;
  return zlog(
           g_zc,
           "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-o"
           "rigin_godminer-new/api_new.c",
           137,
           "send_api_result",
           15,
           v15,
           100,
           v20);
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00022274) --------------------------------------------------------
char __fastcall set_elapsed_time_validity(char result)
{
  byte_10795D = result;
  return result;
}
// 10795D: using guessed type char byte_10795D;

//----- (00022284) --------------------------------------------------------
time_t get_miner_elapsed_time()
{
  time_t result; // r0
  int v1; // r5
  char *v2; // r0
  struct sysinfo info; // [sp+10h] [bp-1044h] BYREF
  char v4[4100]; // [sp+50h] [bp-1004h] BYREF

  if ( sysinfo(&info) )
  {
    V_LOCK();
    v1 = *_errno_location();
    v2 = strerror(v1);
    logfmt_raw(v4, 0x1000u, 0, "Failed to get sysinfo, errno:%u, reason:%s", v1, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/api_new.c",
      137,
      "get_miner_elapsed_time",
      22,
      302,
      40,
      v4);
    result = time(0);
    dword_107960 = result;
  }
  else
  {
    dword_107960 = info.uptime;
    return info.uptime;
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10795D: using guessed type char byte_10795D;
// 107960: using guessed type int dword_107960;
// 107964: using guessed type int dword_107964;
// 11A7AC: using guessed type int g_zc;

//----- (0002237C) --------------------------------------------------------
int __fastcall sub_2237C(_DWORD *a1, int a2)
{
  int v3; // r5
  _DWORD *v4; // r4
  char *v5; // r0
  char *v6; // r0
  char *v7; // r0
  char *v8; // r0
  int v9; // r8
  float v10; // s24
  float v11; // s18
  float v12; // s20
  double v13; // d11
  char *all_created_runtime; // r4
  __int64 v15; // r6
  _DWORD *v16; // r4
  _DWORD *v17; // r0
  char *v18; // r0
  _DWORD *v19; // r0
  double *v20; // r0
  double *v21; // r0
  double *v22; // r0
  double *v23; // r0
  _DWORD *v24; // r0
  _DWORD *v25; // r0
  int *v26; // r3
  __int64 v27; // r0
  int v28; // r2
  _DWORD *v29; // r0
  _DWORD *v30; // r0
  int v31; // r5
  int v32; // r6
  int v33; // t1
  _DWORD *v34; // r0
  int v35; // r12
  unsigned int v36; // r0
  char *v37; // r1
  int v38; // r2
  int v39; // r3
  _DWORD *v40; // r0
  int v41; // r10
  char *v42; // r5
  int v43; // r11
  int *v44; // r0
  int v45; // r9
  int v46; // r3
  int v47; // r8
  int v48; // r2
  _DWORD *v49; // r0
  int *v50; // r0
  int v51; // r2
  int v52; // r8
  _DWORD *v53; // r0
  int *v54; // r8
  char *v55; // r7
  int v56; // r5
  int v57; // t1
  int v58; // r1
  int v59; // t1
  char *v60; // r0
  char *v61; // r7
  char *v62; // r5
  int v63; // r6
  int v64; // t1
  char *v65; // r0
  char *v66; // r7
  char *v67; // r5
  int v68; // r6
  int v69; // t1
  char *v70; // r0
  char *v71; // r10
  char *v72; // r5
  int v73; // r6
  int v74; // t1
  char *v75; // r0
  _DWORD *v76; // r0
  char *v77; // r7
  int v78; // r6
  char *v79; // r9
  char *v80; // r8
  const char **v81; // r5
  int v82; // t1
  int v83; // r0
  _DWORD *v84; // r0
  int v85; // r6
  int v86; // t1
  char *v87; // r0
  char *v88; // r10
  char *v89; // r6
  int v90; // r8
  __int64 v91; // kr00_8
  int v92; // t1
  unsigned int v93; // r7
  unsigned int v94; // r11
  _DWORD *v95; // r0
  __int64 v96; // r0
  _DWORD *v97; // r0
  char *v98; // r7
  int v99; // r6
  char *v100; // r9
  char *v101; // r8
  char *v102; // r5
  int v103; // t1
  double *v104; // r0
  int v105; // r6
  int v106; // t1
  char *v107; // r0
  char *v108; // r10
  char *v109; // r7
  int v110; // r5
  int v111; // t1
  int v112; // r0
  _DWORD *v113; // r0
  char *v114; // r0
  char *v115; // r0
  _DWORD *v116; // r0
  char *v118; // r6
  char *v119; // r0
  char *v120; // r4
  char *v121; // r7
  int v122; // t1
  bool v123; // cc
  char *v124; // [sp+10h] [bp-1234h]
  int v125; // [sp+14h] [bp-1230h]
  int *v126; // [sp+18h] [bp-122Ch]
  char *ptr; // [sp+28h] [bp-121Ch]
  int v129; // [sp+30h] [bp-1214h]
  _DWORD *v130; // [sp+34h] [bp-1210h]
  __int64 v131; // [sp+38h] [bp-120Ch]
  int v132; // [sp+48h] [bp-11FCh] BYREF
  int v133; // [sp+4Ch] [bp-11F8h] BYREF
  int v134; // [sp+50h] [bp-11F4h] BYREF
  int v135; // [sp+54h] [bp-11F0h] BYREF
  double v136; // [sp+58h] [bp-11ECh] BYREF
  char v137[12]; // [sp+64h] [bp-11E0h] BYREF
  char v138[4]; // [sp+70h] [bp-11D4h] BYREF
  int v139; // [sp+74h] [bp-11D0h]
  int v140; // [sp+78h] [bp-11CCh]
  int v141; // [sp+7Ch] [bp-11C8h]
  char s[32]; // [sp+80h] [bp-11C4h] BYREF
  char v143[32]; // [sp+A0h] [bp-11A4h] BYREF
  char v144[32]; // [sp+C0h] [bp-1184h] BYREF
  char v145[32]; // [sp+E0h] [bp-1164h] BYREF
  char v146[32]; // [sp+100h] [bp-1144h] BYREF
  char v147[4]; // [sp+120h] [bp-1124h] BYREF
  char v148[256]; // [sp+140h] [bp-1104h] BYREF
  char v149[4]; // [sp+240h] [bp-1004h] BYREF
  int v150; // [sp+244h] [bp-1000h]
  int v151; // [sp+248h] [bp-FFCh]
  float v152; // [sp+24Ch] [bp-FF8h]
  float v153; // [sp+250h] [bp-FF4h]
  float v154; // [sp+254h] [bp-FF0h]
  double v155; // [sp+258h] [bp-FECh]

  v139 = 0;
  v140 = 0;
  v141 = 0;
  v3 = a1 == 0;
  *(_DWORD *)v138 = 0;
  memset(s, 0, sizeof(s));
  memset(v148, 0, sizeof(v148));
  v132 = 0;
  if ( !a2 )
    v3 = 1;
  if ( v3 )
  {
    V_LOCK();
    logfmt_raw(v149, 0x1000u, 0, "%s: input bad api param\n", "get_stats_old");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/api_new.c",
      137,
      "get_stats_old",
      13,
      1158,
      100,
      v149);
    return -2147483646;
  }
  else
  {
    sub_1F644(a1, 1, 70, *(const char **)(a2 + 8));
    v130 = json_array();
    v4 = json_object();
    v5 = BUFX_strdup("2.12");
    json_object_set_new(v4, "BMMiner", v5);
    v6 = BUFX_strdup(g_miner_version);
    json_object_set_new(v4, "Miner", v6);
    v7 = BUFX_strdup(g_miner_compiletime);
    json_object_set_new(v4, "CompileTime", v7);
    v8 = BUFX_strdup(g_miner_type);
    json_object_set_new(v4, "Type", v8);
    json_array_append_new(v130, v4);
    read_system_status_from_monitor((int)v149);
    v9 = v150;
    v10 = v152;
    v11 = v153;
    v12 = v154;
    v13 = v155;
    all_created_runtime = (char *)get_all_created_runtime(&v132);
    v129 = frontend_runtime_instance();
    if ( v132 > 0 )
    {
      v126 = (int *)malloc(216 * v132);
      v118 = (char *)v126;
      v119 = (char *)malloc(4 * v132);
      ptr = v119;
      if ( v132 <= 0 )
      {
        v15 = 0;
      }
      else
      {
        v120 = all_created_runtime - 4;
        v121 = v119 - 4;
        do
        {
          v122 = *((_DWORD *)v120 + 1);
          v120 += 4;
          read_status_from_monitor(v118, v122);
          ++v3;
          v118 += 216;
          v123 = v132 <= v3;
          *((_DWORD *)v121 + 1) = *(_DWORD *)(*(_DWORD *)v120 + 200) + 1;
          v121 += 4;
        }
        while ( !v123 );
        v15 = v3;
      }
    }
    else
    {
      v15 = 0;
      ptr = 0;
      v126 = 0;
    }
    v16 = json_object();
    v17 = json_integer(v15);
    json_object_set_new(v16, "STATS", v17);
    snprintf(v138, 0x10u, "BTM_SOC%d", v3);
    v18 = BUFX_strdup(v138);
    json_object_set_new(v16, "ID", v18);
    format_hashrate_string(*(_DWORD *)(*(_DWORD *)(v129 + 68) + 12), v143);
    format_hashrate_string(*(_DWORD *)(*(_DWORD *)(v129 + 68) + 12), v144);
    format_hashrate_string(*(_DWORD *)(*(_DWORD *)(v129 + 68) + 12), v145);
    format_hashrate_string(*(_DWORD *)(*(_DWORD *)(v129 + 68) + 12), v146);
    format_hashrate_double(*(_DWORD *)(*(_DWORD *)(v129 + 68) + 12), &v136, v137);
    get_miner_elapsed_time();
    v19 = json_integer((__int64)v13);
    json_object_set_new(v16, "Elapsed", v19);
    sub_DD47C((__int64)(v10 * v13 * 100.0));
    v20 = json_real();
    json_object_set_new(v16, "GHS 5s", v20);
    sub_DD47C((__int64)(v12 * v13 * 100.0));
    v21 = json_real();
    json_object_set_new(v16, "GHS av", v21);
    sub_DD47C((__int64)(v11 * v13 * 100.0));
    v22 = json_real();
    json_object_set_new(v16, "rate_30m", v22);
    sub_DD47C((__int64)(v136 * 100.0));
    v23 = json_real();
    json_object_set_new(v16, "total_rateideal", v23);
    v24 = json_integer(opt_bitmain_work_mode);
    json_object_set_new(v16, "Mode", v24);
    v25 = json_integer(v132);
    json_object_set_new(v16, "miner_count", v25);
    if ( v132 <= 0 )
    {
      v27 = 0x7FFFFFFF;
    }
    else
    {
      v26 = v126;
      LODWORD(v27) = 0x7FFFFFFF;
      do
      {
        v28 = v26[18];
        v26 += 54;
        if ( (int)v27 >= v28 )
          LODWORD(v27) = v28;
      }
      while ( &v126[54 * v132] != v26 );
      v27 = (int)v27;
    }
    v29 = json_integer(v27);
    json_object_set_new(v16, "frequency", v29);
    v30 = json_integer(v9);
    json_object_set_new(v16, "fan_num", v30);
    if ( v9 > 0 )
    {
      v31 = 0;
      v32 = v151 - 4;
      do
      {
        ++v31;
        memset(s, 0, sizeof(s));
        snprintf(s, 0x20u, "fan%d", v31);
        v33 = *(_DWORD *)(v32 + 4);
        v32 += 4;
        v34 = json_integer(v33);
        json_object_set_new(v16, s, v34);
      }
      while ( v31 != v9 );
    }
    if ( v132 <= 0 )
    {
      v131 = -100;
      v36 = 0;
    }
    else
    {
      v35 = -100;
      LOBYTE(v36) = 0;
      v37 = (char *)v126;
      do
      {
        v38 = *((_DWORD *)v37 + 4);
        v39 = *((_DWORD *)v37 + 6);
        v37 += 216;
        if ( v35 < v38 )
          v35 = v38;
        LOBYTE(v36) = v36 + v39 + *((_DWORD *)v37 - 47);
      }
      while ( &v126[54 * v132] != (int *)v37 );
      v36 = (unsigned __int8)v36;
      v131 = v35;
    }
    v40 = json_integer(v36);
    json_object_set_new(v16, "temp_num", v40);
    if ( v132 > 0 )
    {
      v41 = 0;
      v42 = (char *)v126;
      v124 = ptr - 4;
      do
      {
        v43 = *((_DWORD *)v42 + 6);
        v44 = *(int **)v42;
        v133 = 0;
        ++v41;
        v134 = 0;
        v135 = 0;
        v42 += 216;
        *(_DWORD *)v147 = 0;
        find_min_and_max_int(v44, v43, &v133, &v134);
        v45 = *((_DWORD *)v42 - 47);
        find_min_and_max_int(*((int **)v42 - 52), v45, &v135, v147);
        v46 = *(_DWORD *)v147;
        v47 = *((_DWORD *)v124 + 1);
        if ( *(int *)v147 < v134 )
          v46 = v134;
        v48 = *((_DWORD *)v124 + 1);
        v124 += 4;
        v125 = v46;
        sprintf(s, "temp%d", v48);
        v49 = json_integer(v125);
        json_object_set_new(v16, s, v49);
        v50 = (int *)*((_DWORD *)v42 - 53);
        *(_DWORD *)v147 = 0;
        v135 = 0;
        v134 = 0;
        v133 = 0;
        find_min_and_max_int(v50, v43, &v133, &v134);
        find_min_and_max_int(*((int **)v42 - 51), v45, &v135, v147);
        v51 = v47;
        v52 = v134;
        if ( *(int *)v147 >= v134 )
          v52 = *(_DWORD *)v147;
        sprintf(s, "temp2_%d", v51);
        v53 = json_integer(v52);
        json_object_set_new(v16, s, v53);
      }
      while ( v132 > v41 );
      v54 = v126;
      if ( v132 > 0 )
      {
        v55 = ptr - 4;
        v56 = 0;
        do
        {
          ++v56;
          memset(s, 0, sizeof(s));
          memset(v148, 0, sizeof(v148));
          v57 = *((_DWORD *)v55 + 1);
          v55 += 4;
          snprintf(s, 0x20u, "temp_in_pcb_%d", v57);
          v58 = v54[6];
          v59 = *v54;
          v54 += 54;
          sub_1F978(v59, v58, v148);
          v60 = BUFX_strdup(v148);
          json_object_set_new(v16, s, v60);
        }
        while ( v132 > v56 );
        if ( v132 > 0 )
        {
          v61 = ptr - 4;
          v62 = (char *)v126;
          v63 = 0;
          do
          {
            ++v63;
            memset(s, 0, sizeof(s));
            v62 += 216;
            memset(v148, 0, sizeof(v148));
            v64 = *((_DWORD *)v61 + 1);
            v61 += 4;
            snprintf(s, 0x20u, "temp_out_pcb_%d", v64);
            sub_1F978(*((_DWORD *)v62 - 52), *((_DWORD *)v62 - 47), v148);
            v65 = BUFX_strdup(v148);
            json_object_set_new(v16, s, v65);
          }
          while ( v132 > v63 );
          if ( v132 > 0 )
          {
            v66 = ptr - 4;
            v67 = (char *)v126;
            v68 = 0;
            do
            {
              ++v68;
              memset(s, 0, sizeof(s));
              v67 += 216;
              memset(v148, 0, sizeof(v148));
              v69 = *((_DWORD *)v66 + 1);
              v66 += 4;
              snprintf(s, 0x20u, "temp_in_chip_%d", v69);
              sub_1F978(*((_DWORD *)v67 - 53), *((_DWORD *)v67 - 48), v148);
              v70 = BUFX_strdup(v148);
              json_object_set_new(v16, s, v70);
            }
            while ( v132 > v68 );
            if ( v132 > 0 )
            {
              v71 = ptr - 4;
              v72 = (char *)v126;
              v73 = 0;
              do
              {
                ++v73;
                memset(s, 0, sizeof(s));
                v72 += 216;
                memset(v148, 0, sizeof(v148));
                v74 = *((_DWORD *)v71 + 1);
                v71 += 4;
                snprintf(s, 0x20u, "temp_out_chip_%d", v74);
                sub_1F978(*((_DWORD *)v72 - 52), *((_DWORD *)v72 - 47), v148);
                v75 = BUFX_strdup(v148);
                json_object_set_new(v16, s, v75);
              }
              while ( v132 > v73 );
            }
          }
        }
      }
    }
    v76 = json_integer(v131);
    json_object_set_new(v16, "temp_max", v76);
    if ( v132 <= 0 )
      goto LABEL_67;
    v77 = (char *)v126;
    v78 = 0;
    v79 = ptr - 4;
    v80 = ptr - 4;
    v81 = (const char **)v126;
    do
    {
      ++v78;
      memset(s, 0, sizeof(s));
      v82 = *((_DWORD *)v79 + 1);
      v79 += 4;
      snprintf(s, 0x20u, "chain_acn%d", v82);
      v83 = *((_DWORD *)v77 + 16);
      v77 += 216;
      v84 = json_integer(v83);
      json_object_set_new(v16, s, v84);
    }
    while ( v132 > v78 );
    if ( v132 <= 0 )
      goto LABEL_67;
    v85 = 0;
    do
    {
      v86 = *((_DWORD *)v80 + 1);
      v80 += 4;
      ++v85;
      v81 += 54;
      sprintf(v147, "chain_acs%d", v86);
      memset(s, 0, sizeof(s));
      memset(v148, 0, sizeof(v148));
      snprintf(s, 0x20u, "chain_acs%d", v86);
      snprintf(v148, 0x100u, "%s", *(v81 - 37));
      v87 = BUFX_strdup(v148);
      json_object_set_new(v16, s, v87);
    }
    while ( v132 > v85 );
    if ( v132 <= 0 )
    {
LABEL_67:
      v96 = 0;
    }
    else
    {
      v88 = ptr - 4;
      v89 = (char *)v126;
      v90 = 0;
      v91 = 0;
      do
      {
        ++v90;
        memset(s, 0, sizeof(s));
        v92 = *((_DWORD *)v88 + 1);
        v88 += 4;
        snprintf(s, 0x20u, "chain_hw%d", v92);
        v93 = *((_DWORD *)v89 + 20);
        v89 += 216;
        v94 = *((_DWORD *)v89 - 33);
        v95 = json_integer(__SPAIR64__(v94, v93));
        json_object_set_new(v16, s, v95);
        v91 += __PAIR64__(v94, v93);
      }
      while ( v132 > v90 );
      v96 = v91;
    }
    v97 = json_integer(v96);
    json_object_set_new(v16, "no_matching_work", v97);
    if ( v132 > 0 )
    {
      v98 = (char *)v126;
      v99 = 0;
      v100 = ptr - 4;
      v101 = ptr - 4;
      v102 = (char *)v126;
      do
      {
        ++v99;
        memset(s, 0, sizeof(s));
        v103 = *((_DWORD *)v100 + 1);
        v100 += 4;
        snprintf(s, 0x20u, "chain_rate%d", v103);
        v98 += 216;
        v104 = json_real();
        json_object_set_new(v16, s, v104);
      }
      while ( v132 > v99 );
      if ( v132 > 0 )
      {
        v105 = 0;
        do
        {
          ++v105;
          v102 += 216;
          format_hashrate_string(*(_DWORD *)(*(_DWORD *)(v129 + 68) + 12), v147);
          v106 = *((_DWORD *)v101 + 1);
          v101 += 4;
          snprintf(s, 0x20u, "CHAIN AVG HASHRATE%d", v106);
          v107 = BUFX_strdup(v147);
          json_object_set_new(v16, s, v107);
        }
        while ( v132 > v105 );
        if ( v132 > 0 )
        {
          v108 = ptr - 4;
          v109 = (char *)v126;
          v110 = 0;
          do
          {
            ++v110;
            memset(s, 0, sizeof(s));
            v111 = *((_DWORD *)v108 + 1);
            v108 += 4;
            snprintf(s, 0x20u, "freq%d", v111);
            v112 = *((_DWORD *)v109 + 18);
            v109 += 216;
            v113 = json_integer(v112);
            json_object_set_new(v16, s, v113);
          }
          while ( v132 > v110 );
        }
      }
    }
    v114 = BUFX_strdup(g_miner_version);
    json_object_set_new(v16, "miner_version", v114);
    v115 = BUFX_strdup(0);
    json_object_set_new(v16, "miner_id", v115);
    json_array_append_new(v130, v16);
    json_object_set_new(a1, "STATS", v130);
    v116 = json_integer(1);
    json_object_set_new(a1, "id", v116);
    if ( v132 > 0 )
    {
      free(ptr);
      free(v126);
    }
    return 0;
  }
}
// 2237C: too many cbuild loops
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 106334: using guessed type int opt_bitmain_work_mode;
// 11A7AC: using guessed type int g_zc;

//----- (00023144) --------------------------------------------------------
int __fastcall sub_23144(_DWORD *a1, int a2)
{
  int v4; // r0
  bool v5; // zf
  int v6; // r5
  _DWORD *v7; // r4
  float v8; // s18
  double v9; // d8
  double v10; // d11
  float v11; // s20
  double v12; // d11
  double v13; // d9
  double v14; // d10
  double v15; // r0
  double v16; // d12
  _DWORD *v17; // r0
  double *v18; // r0
  double *v19; // r0
  double *v20; // r0
  _DWORD *v21; // r0
  _DWORD *v22; // r0
  _DWORD *v23; // r0
  _DWORD *v24; // r0
  _DWORD *v25; // r0
  double *v26; // r0
  _DWORD *v27; // r0
  _DWORD *v28; // r0
  _DWORD *v29; // r0
  _DWORD *v30; // r0
  _DWORD *v31; // r0
  _DWORD *v32; // r0
  double *v33; // r0
  double *v34; // r0
  double *v35; // r0
  double *v36; // r0
  double *v37; // r0
  _DWORD *v38; // r0
  __int64 v39; // r0
  double *v40; // r0
  double v41; // r0
  double *v42; // r0
  double v43; // d7
  double *v44; // r0
  double v45; // d7
  double *v46; // r0
  _DWORD *v47; // r0
  char *v48; // r0
  char *v49; // r0
  char *v50; // r0
  _DWORD *v51; // r0
  int v53; // r1
  double v54; // d9
  double v55; // r0
  __int64 v56; // [sp+10h] [bp-10BCh]
  unsigned int v57; // [sp+1Ch] [bp-10B0h]
  _DWORD *v58; // [sp+20h] [bp-10ACh]
  unsigned int v59; // [sp+24h] [bp-10A8h]
  int v60; // [sp+2Ch] [bp-10A0h] BYREF
  double v61; // [sp+30h] [bp-109Ch] BYREF
  char v62[12]; // [sp+3Ch] [bp-1090h] BYREF
  char v63[32]; // [sp+48h] [bp-1084h] BYREF
  char v64[32]; // [sp+68h] [bp-1064h] BYREF
  char v65[32]; // [sp+88h] [bp-1044h] BYREF
  char v66[32]; // [sp+A8h] [bp-1024h] BYREF
  char v67[12]; // [sp+C8h] [bp-1004h] BYREF
  float v68; // [sp+D4h] [bp-FF8h]
  float v69; // [sp+D8h] [bp-FF4h]
  float v70; // [sp+DCh] [bp-FF0h]
  double v71; // [sp+E0h] [bp-FECh]
  unsigned int v72; // [sp+F0h] [bp-FDCh]
  unsigned int v73; // [sp+F4h] [bp-FD8h]

  v60 = 0;
  get_all_created_runtime(&v60);
  v4 = frontend_runtime_instance();
  v5 = a1 == 0;
  if ( a1 )
    v5 = a2 == 0;
  if ( v5 )
  {
    V_LOCK();
    logfmt_raw(v67, 0x1000u, 0, "%s: input bad api param\n", "get_summary_old");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/api_new.c",
      137,
      "get_summary_old",
      15,
      928,
      100,
      v67);
    return -2147483646;
  }
  else
  {
    v6 = v4;
    sub_1F644(a1, 1, 11, *(const char **)(a2 + 8));
    v58 = json_array();
    v7 = json_object();
    read_system_status_from_monitor((int)v67);
    v8 = v69;
    v9 = v71;
    v10 = v68;
    v11 = v70;
    format_hashrate_string(*(_DWORD *)(*(_DWORD *)(v6 + 68) + 12), v63);
    format_hashrate_string(*(_DWORD *)(*(_DWORD *)(v6 + 68) + 12), v64);
    format_hashrate_string(*(_DWORD *)(*(_DWORD *)(v6 + 68) + 12), v65);
    format_hashrate_string(*(_DWORD *)(*(_DWORD *)(v6 + 68) + 12), v66);
    format_hashrate_double(*(_DWORD *)(*(_DWORD *)(v6 + 68) + 12), &v61, v62);
    v12 = v10 * v9;
    v59 = v72;
    v13 = v8 * v9;
    v57 = v73;
    v14 = v11 * v9;
    get_miner_elapsed_time();
    LODWORD(v15) = sub_DD47C(total_accepted);
    v16 = v15;
    if ( v9 != 0.0 )
      v16 = v15 / v9;
    v17 = json_integer((__int64)v9);
    json_object_set_new(v7, "Elapsed", v17);
    sub_DD47C((__int64)(v12 * 100.0));
    v18 = json_real();
    json_object_set_new(v7, "GHS 5s", v18);
    sub_DD47C((__int64)(v14 * 100.0));
    v19 = json_real();
    json_object_set_new(v7, "GHS av", v19);
    sub_DD47C((__int64)(v13 * 100.0));
    v20 = json_real();
    json_object_set_new(v7, "GHS 30m", v20);
    v21 = json_integer((unsigned int)dword_107968);
    json_object_set_new(v7, "Found Blocks", v21);
    v22 = json_integer(*(__int64 *)&total_getworks);
    json_object_set_new(v7, "Getwork", v22);
    v23 = json_integer(total_accepted);
    json_object_set_new(v7, "Accepted", v23);
    v24 = json_integer(*(__int64 *)&total_rejected);
    json_object_set_new(v7, "Rejected", v24);
    v25 = json_integer(__SPAIR64__(v57, v59));
    json_object_set_new(v7, "Hardware Errors", v25);
    sub_DD47C((__int64)(v16 * 60.0 * 100.0));
    v26 = json_real();
    json_object_set_new(v7, "Utility", v26);
    v27 = json_integer(*(__int64 *)&total_discarded);
    json_object_set_new(v7, "Discarded", v27);
    v28 = json_integer(*(__int64 *)&total_stale);
    json_object_set_new(v7, "Stale", v28);
    v29 = json_integer((unsigned int)total_go);
    json_object_set_new(v7, "Get Failures", v29);
    v30 = json_integer((unsigned int)local_work);
    json_object_set_new(v7, "Local Work", v30);
    v31 = json_integer((unsigned int)total_ro);
    json_object_set_new(v7, "Remote Failures", v31);
    v32 = json_integer((unsigned int)new_blocks);
    json_object_set_new(v7, "Network Blocks", v32);
    sub_DD47C((__int64)(dbl_107970 * 100.0));
    v33 = json_real();
    json_object_set_new(v7, "Total MH", v33);
    v34 = json_real();
    json_object_set_new(v7, "Work Utility", v34);
    sub_DD47C((__int64)(total_diff_accepted * 100.0));
    v35 = json_real();
    json_object_set_new(v7, "Difficulty Accepted", v35);
    sub_DD47C((__int64)(total_diff_rejected * 100.0));
    v36 = json_real();
    json_object_set_new(v7, "Difficulty Rejected", v36);
    sub_DD47C((__int64)(total_diff_stale * 100.0));
    v37 = json_real();
    json_object_set_new(v7, "Difficulty Stale", v37);
    v38 = json_integer(*(__int64 *)&dword_107978);
    json_object_set_new(v7, "Best Share", v38);
    HIDWORD(v39) = v57;
    v56 = __PAIR64__(v57, v59) + total_diff1;
    if ( __PAIR64__(v57, v59) + total_diff1 )
    {
      LODWORD(v39) = v59;
      LODWORD(v54) = sub_DD46C(v39);
      HIDWORD(v54) = v53;
      LODWORD(v55) = sub_DD46C(v56);
      sub_DD47C((__int64)(v54 / v55 * 100.0));
    }
    v40 = json_real();
    json_object_set_new(v7, "Device Hardware%", v40);
    if ( total_diff1 )
    {
      LODWORD(v41) = sub_DD47C(total_diff1);
      sub_DD47C((__int64)(total_diff_rejected / v41 * 100.0));
    }
    v42 = json_real();
    json_object_set_new(v7, "Device Rejected%", v42);
    v43 = total_diff_rejected + total_diff_accepted + total_diff_stale;
    if ( v43 != 0.0 )
      sub_DD47C((__int64)(total_diff_rejected / v43 * 100.0));
    v44 = json_real();
    json_object_set_new(v7, "Pool Rejected%", v44);
    v45 = total_diff_accepted + total_diff_rejected + total_diff_stale;
    if ( v45 != 0.0 )
      sub_DD47C((__int64)(total_diff_stale / v45 * 100.0));
    v46 = json_real();
    json_object_set_new(v7, "Pool Stale%", v46);
    v47 = json_integer(last_getwork);
    json_object_set_new(v7, "Last getwork", v47);
    v48 = BUFX_strdup(v63);
    json_object_set_new(v7, "RT HASHRATE", v48);
    v49 = BUFX_strdup(v65);
    json_object_set_new(v7, "AV HASHRATE", v49);
    v50 = BUFX_strdup(v66);
    json_object_set_new(v7, "THEORY HASHRATE", v50);
    json_array_append_new(v58, v7);
    json_object_set_new(a1, "SUMMARY", v58);
    v51 = json_integer(1);
    json_object_set_new(a1, "id", v51);
    return 0;
  }
}
// 23144: too many cbuild loops
// 232B0: variable 'v15' is possibly undefined
// 23888: variable 'v53' is possibly undefined
// 23898: variable 'v55' is possibly undefined
// 236C8: variable 'v41' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 107968: using guessed type int dword_107968;
// 107970: using guessed type double dbl_107970;
// 107978: using guessed type int dword_107978;
// 11A7AC: using guessed type int g_zc;
// 11A7D8: using guessed type int total_stale;
// 11A7E0: using guessed type double total_diff_accepted;
// 11A7E8: using guessed type int total_discarded;
// 11A7F0: using guessed type double total_diff_rejected;
// 11A7F8: using guessed type int total_ro;
// 11A7FC: using guessed type int last_getwork;
// 11A800: using guessed type int total_go;
// 11A808: using guessed type __int64 total_accepted;
// 11A810: using guessed type int total_getworks;
// 11A818: using guessed type double total_diff_stale;
// 11A820: using guessed type int new_blocks;
// 11A824: using guessed type int local_work;
// 11A828: using guessed type int total_rejected;
// 11A830: using guessed type __int64 total_diff1;

//----- (0002393C) --------------------------------------------------------
int __fastcall sub_2393C(_DWORD *a1, const char **a2)
{
  int v2; // r5
  char *all_created_runtime; // r11
  int v4; // r0
  int v5; // r10
  double v6; // d0
  int v7; // r4
  double v8; // d12
  unsigned int v9; // r10
  double v10; // d11
  double v11; // d9
  _DWORD *v12; // r0
  double *v13; // r0
  double *v14; // r0
  double *v15; // r0
  double *v16; // r0
  char *v17; // r0
  _DWORD *v18; // r0
  _DWORD *v19; // r0
  _DWORD *v20; // r5
  int *v21; // r11
  int *v22; // r4
  int v23; // t1
  _DWORD *v24; // r0
  __int64 v25; // r0
  __int64 v26; // r6
  double *v27; // r0
  char *v28; // r6
  _DWORD *v29; // r8
  int v30; // r0
  _DWORD *v31; // r0
  _DWORD *v32; // r0
  double v33; // d8
  double v34; // d6
  double *v35; // r0
  double *v36; // r0
  _DWORD *v37; // r0
  int v38; // r1
  _DWORD *v39; // r0
  __int64 v40; // r4
  _DWORD *v41; // r7
  int v42; // r10
  _DWORD *v43; // r0
  int v44; // r10
  _DWORD *v45; // r0
  _DWORD *v46; // r7
  int v47; // r10
  int v48; // r11
  int v49; // t1
  _DWORD *v50; // r0
  int *v51; // r11
  int *v52; // r10
  int v53; // t1
  _DWORD *v54; // r0
  _DWORD *v55; // r7
  int v56; // r10
  int v57; // r11
  int v58; // t1
  _DWORD *v59; // r0
  int v60; // r10
  int v61; // t1
  _DWORD *v62; // r0
  _DWORD *v63; // r0
  _DWORD *v64; // r2
  char *eeprom_chip_sn; // r0
  char *v66; // r0
  int v69; // r1
  double v70; // d8
  double v71; // r0
  _DWORD *v72; // r2
  char *v73; // r7
  size_t v74; // r5
  size_t v75; // r2
  bool v76; // cf
  int v77; // r3
  int v78; // t1
  bool v79; // zf
  char *v80; // r0
  char *v81; // r8
  char *v82; // r0
  char *v83; // r11
  unsigned int v84; // r7
  int v85; // r10
  char *v86; // r4
  int v87; // t1
  int v88; // r3
  unsigned int v90; // [sp+14h] [bp-1078h]
  int v91; // [sp+14h] [bp-1078h]
  char *v92; // [sp+18h] [bp-1074h]
  _DWORD *v93; // [sp+20h] [bp-106Ch]
  _DWORD *v94; // [sp+2Ch] [bp-1060h]
  char *v96; // [sp+34h] [bp-1058h]
  char *ptr; // [sp+38h] [bp-1054h]
  _DWORD *v98; // [sp+3Ch] [bp-1050h]
  int v99; // [sp+44h] [bp-1048h] BYREF
  double v100; // [sp+48h] [bp-1044h] BYREF
  _DWORD v101[2]; // [sp+50h] [bp-103Ch] BYREF
  _DWORD v102[2]; // [sp+58h] [bp-1034h] BYREF
  int *v103; // [sp+60h] [bp-102Ch]
  float v104; // [sp+64h] [bp-1028h]
  float v105; // [sp+68h] [bp-1024h]
  float v106; // [sp+6Ch] [bp-1020h]
  double v107; // [sp+70h] [bp-101Ch]
  unsigned int v108; // [sp+80h] [bp-100Ch]
  unsigned int v109; // [sp+84h] [bp-1008h]
  char v110[4100]; // [sp+88h] [bp-1004h] BYREF

  v101[1] = 0;
  v2 = a1 == 0;
  v101[0] = 0;
  v99 = 0;
  all_created_runtime = (char *)get_all_created_runtime(&v99);
  v4 = frontend_runtime_instance();
  if ( !a2 )
    v2 = 1;
  if ( v2 )
  {
    V_LOCK();
    logfmt_raw(v110, 0x1000u, 0, "%s: input bad api param\n", "get_stats");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/api_new.c",
      137,
      "get_stats",
      9,
      600,
      100,
      v110);
    return -2147483646;
  }
  else
  {
    v5 = v4;
    sub_1F418((int)a1, a2);
    sub_1F534(a1);
    v98 = json_array();
    read_system_status_from_monitor((int)v102);
    v6 = v107;
    v7 = v102[1];
    format_hashrate_double(*(_DWORD *)(*(_DWORD *)(v5 + 68) + 12), &v100, (char *)v101);
    v8 = v104 * v6;
    v90 = v108;
    v9 = v109;
    v10 = v105 * v6;
    v11 = v106 * v6;
    if ( v99 > 0 )
    {
      v96 = (char *)malloc(216 * v99);
      v81 = v96;
      v82 = (char *)malloc(4 * v99);
      ptr = v82;
      if ( v99 > 0 )
      {
        v83 = all_created_runtime - 4;
        v84 = v9;
        v85 = v7;
        v86 = v82;
        do
        {
          v87 = *((_DWORD *)v83 + 1);
          v83 += 4;
          read_status_from_monitor(v81, v87);
          v88 = v99;
          v81 += 216;
          *(_DWORD *)&v86[4 * v2++] = *(_DWORD *)(*(_DWORD *)v83 + 200);
        }
        while ( v88 > v2 );
        v7 = v85;
        v9 = v84;
      }
    }
    else
    {
      ptr = 0;
      v96 = 0;
    }
    v94 = json_object();
    get_miner_elapsed_time();
    v12 = json_integer((__int64)v6);
    json_object_set_new(v94, "elapsed", v12);
    sub_DD47C((__int64)(v8 * 100.0));
    v13 = json_real();
    json_object_set_new(v94, "rate_5s", v13);
    sub_DD47C((__int64)(v10 * 100.0));
    v14 = json_real();
    json_object_set_new(v94, "rate_30m", v14);
    sub_DD47C((__int64)(v11 * 100.0));
    v15 = json_real();
    json_object_set_new(v94, "rate_avg", v15);
    sub_DD47C((__int64)(v100 * 100.0));
    v16 = json_real();
    json_object_set_new(v94, "rate_ideal", v16);
    v17 = BUFX_strdup((char *)v101);
    json_object_set_new(v94, "rate_unit", v17);
    v18 = json_integer(v99);
    json_object_set_new(v94, "chain_num", v18);
    v19 = json_integer(v7);
    json_object_set_new(v94, "fan_num", v19);
    v20 = json_array();
    if ( v7 > 0 )
    {
      v21 = v103;
      v22 = &v103[v7];
      do
      {
        v23 = *v21++;
        v24 = json_integer(v23);
        json_array_append_new(v20, v24);
      }
      while ( v22 != v21 );
    }
    json_object_set_new(v94, "fan", v20);
    LODWORD(v25) = v90;
    v26 = __PAIR64__(v9, v90) + total_diff1;
    if ( __PAIR64__(v9, v90) + total_diff1 )
    {
      HIDWORD(v25) = v9;
      LODWORD(v70) = sub_DD46C(v25);
      HIDWORD(v70) = v69;
      LODWORD(v71) = sub_DD46C(v26);
      sub_DD47C((__int64)(v70 / v71 * 100.0 * 10000.0));
    }
    v27 = json_real();
    json_object_set_new(v94, "hwp_total", v27);
    v93 = json_array();
    if ( v99 > 0 )
    {
      v28 = v96;
      v92 = ptr - 4;
      v91 = 0;
      while ( 1 )
      {
        v29 = json_object();
        v30 = *((_DWORD *)v92 + 1);
        v92 += 4;
        v31 = json_integer(v30);
        json_object_set_new(v29, "index", v31);
        v32 = json_integer(*((int *)v28 + 18));
        json_object_set_new(v29, "freq_avg", v32);
        v33 = *((float *)v28 + 9);
        v34 = v6 * *((double *)v28 + 6) * 100.0;
        v100 = v6 * *((double *)v28 + 6);
        sub_DD47C((__int64)v34);
        v35 = json_real();
        json_object_set_new(v29, "rate_ideal", v35);
        sub_DD47C((__int64)(v33 * v6 * 100.0));
        v36 = json_real();
        json_object_set_new(v29, "rate_real", v36);
        v37 = json_integer(*((int *)v28 + 16));
        json_object_set_new(v29, "asic_num", v37);
        v38 = *((_DWORD *)v28 + 17);
        if ( v38 )
        {
          v73 = v110;
          v74 = 0;
          v75 = stpcpy(v110, v38) - (_DWORD)v110;
          while ( 1 )
          {
            v76 = v74++ >= v75;
            if ( v76 )
              break;
            while ( 1 )
            {
              v78 = (unsigned __int8)*v73++;
              v77 = v78;
              v79 = v78 == 111;
              if ( v78 != 111 )
                v79 = v77 == 32;
              if ( v79 )
                break;
              *(v73 - 1) = 120;
              v75 = strlen(v110);
              v76 = v74++ >= v75;
              if ( v76 )
                goto LABEL_52;
            }
          }
LABEL_52:
          v80 = BUFX_strdup(v110);
          json_object_set_new(v29, "asic", v80);
        }
        v39 = json_array();
        v40 = *((_QWORD *)v28 + 3);
        v41 = v39;
        if ( (int)v40 <= 0 )
          break;
        v42 = 0;
        do
        {
          v43 = json_integer(0);
          ++v42;
          json_array_append_new(v41, v43);
        }
        while ( v42 != (_DWORD)v40 );
        if ( v40 > 0 )
          goto LABEL_18;
        json_object_set_new(v29, "temp_pic", v41);
        v46 = json_array();
LABEL_21:
        v47 = 0;
        v48 = *(_DWORD *)v28 - 4;
        do
        {
          v49 = *(_DWORD *)(v48 + 4);
          v48 += 4;
          ++v47;
          v50 = json_integer(v49);
          json_array_append_new(v46, v50);
        }
        while ( v47 < (int)v40 );
        if ( v40 > 0 )
          goto LABEL_24;
LABEL_57:
        json_object_set_new(v29, "temp_pcb", v46);
        v55 = json_array();
        if ( (int)v40 > 0 )
          goto LABEL_27;
LABEL_32:
        json_object_set_new(v29, "temp_chip", v55);
        v63 = json_integer(*((_QWORD *)v28 + 10));
        json_object_set_new(v29, "hw", v63);
        if ( is_eeprom_loaded() )
        {
          if ( is_eeprom_loaded() )
            v64 = json_true();
          else
            v64 = json_false();
          json_object_set_new(v29, "eeprom_loaded", v64);
          if ( api_get_eeprom_chip_sn(v91) )
          {
            eeprom_chip_sn = (char *)api_get_eeprom_chip_sn(v91);
            v66 = BUFX_strdup(eeprom_chip_sn);
            json_object_set_new(v29, "sn", v66);
          }
        }
        else
        {
          if ( is_eeprom_loaded() )
            v72 = json_true();
          else
            v72 = json_false();
          json_object_set_new(v29, "eeprom_loaded", v72);
        }
        json_array_append_new(v93, v29);
        v28 += 216;
        if ( v99 <= ++v91 )
          goto LABEL_39;
      }
      if ( SHIDWORD(v40) <= 0 )
      {
        json_object_set_new(v29, "temp_pic", v39);
        v46 = json_array();
        goto LABEL_57;
      }
LABEL_18:
      v44 = 0;
      do
      {
        v45 = json_integer(0);
        ++v44;
        json_array_append_new(v41, v45);
      }
      while ( v44 < SHIDWORD(v40) );
      json_object_set_new(v29, "temp_pic", v41);
      v46 = json_array();
      if ( (int)v40 <= 0 )
      {
LABEL_24:
        v51 = (int *)*((_DWORD *)v28 + 2);
        v52 = &v51[HIDWORD(v40)];
        do
        {
          v53 = *v51++;
          v54 = json_integer(v53);
          json_array_append_new(v46, v54);
        }
        while ( v52 != v51 );
        json_object_set_new(v29, "temp_pcb", v46);
        v55 = json_array();
        if ( (int)v40 > 0 )
        {
LABEL_27:
          v56 = 0;
          v57 = *((_DWORD *)v28 + 1) - 4;
          do
          {
            v58 = *(_DWORD *)(v57 + 4);
            v57 += 4;
            ++v56;
            v59 = json_integer(v58);
            json_array_append_new(v55, v59);
          }
          while ( v56 < (int)v40 );
          if ( v40 <= 0 )
            goto LABEL_32;
        }
        LODWORD(v40) = 0;
        v60 = *((_DWORD *)v28 + 3) - 4;
        do
        {
          v61 = *(_DWORD *)(v60 + 4);
          v60 += 4;
          LODWORD(v40) = v40 + 1;
          v62 = json_integer(v61);
          json_array_append_new(v55, v62);
        }
        while ( (int)v40 < SHIDWORD(v40) );
        goto LABEL_32;
      }
      goto LABEL_21;
    }
LABEL_39:
    json_object_set_new(v94, "chain", v93);
    json_array_append_new(v98, v94);
    json_object_set_new(a1, "STATS", v98);
    if ( v99 > 0 )
    {
      free(ptr);
      free(v96);
    }
    return 0;
  }
}
// 2400C: variable 'v69' is possibly undefined
// 24024: variable 'v71' is possibly undefined
// 1E64C: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;
// 11A830: using guessed type __int64 total_diff1;

//----- (0002424C) --------------------------------------------------------
int __fastcall sub_2424C(_DWORD *a1, const char **a2)
{
  char *v4; // r6
  int v5; // r8
  char *all_created_runtime; // r0
  char *v7; // r4
  _DWORD *v8; // r10
  _DWORD *v9; // r5
  double v10; // d0
  double v11; // d11
  double v12; // d10
  double v13; // d9
  _DWORD *v14; // r0
  double *v15; // r0
  double *v16; // r0
  double *v17; // r0
  double *v18; // r0
  char *v19; // r0
  _DWORD *v20; // r0
  _DWORD *v21; // r0
  _DWORD *v22; // r8
  char **v23; // r11
  _DWORD *v24; // r4
  char *v25; // r0
  char *v26; // t1
  char *v28; // r8
  int v29; // r4
  char *v30; // r11
  int v31; // t1
  int v32; // r1
  __int64 v33; // [sp+10h] [bp-102Ch]
  char *ptr; // [sp+1Ch] [bp-1020h]
  int v35; // [sp+24h] [bp-1018h] BYREF
  double v36; // [sp+28h] [bp-1014h] BYREF
  _DWORD v37[2]; // [sp+30h] [bp-100Ch] BYREF
  char v38[12]; // [sp+38h] [bp-1004h] BYREF
  float v39; // [sp+44h] [bp-FF8h]
  float v40; // [sp+48h] [bp-FF4h]
  float v41; // [sp+4Ch] [bp-FF0h]
  double v42; // [sp+50h] [bp-FECh]
  __int64 v43; // [sp+60h] [bp-FDCh]

  v4 = (char *)v37;
  v37[0] = 0;
  v35 = 0;
  v37[1] = 0;
  v5 = frontend_runtime_instance();
  all_created_runtime = (char *)get_all_created_runtime(&v35);
  if ( a2 )
  {
    v7 = all_created_runtime;
    sub_1F418((int)a1, a2);
    sub_1F534(a1);
    v8 = json_array();
    v9 = json_object();
    read_system_status_from_monitor((int)v38);
    v10 = v42;
    format_hashrate_double(*(_DWORD *)(*(_DWORD *)(v5 + 68) + 12), &v36, (char *)v37);
    if ( v35 <= 0 )
      v4 = 0;
    v11 = v39 * v10;
    if ( v35 <= 0 )
      ptr = v4;
    v33 = v43;
    v12 = v40 * v10;
    v13 = v41 * v10;
    if ( v35 > 0 )
    {
      ptr = (char *)malloc(216 * v35);
      v4 = (char *)malloc(4 * v35);
      if ( v35 > 0 )
      {
        v28 = v7 - 4;
        v29 = 0;
        v30 = ptr;
        do
        {
          v31 = *((_DWORD *)v28 + 1);
          v28 += 4;
          read_status_from_monitor(v30, v31);
          v32 = v35;
          v30 += 216;
          *(_DWORD *)&v4[4 * v29++] = *(_DWORD *)(*(_DWORD *)v28 + 200);
        }
        while ( v32 > v29 );
      }
    }
    get_miner_elapsed_time();
    v14 = json_integer((__int64)v10);
    json_object_set_new(v9, "elapsed", v14);
    sub_DD47C((__int64)(v11 * 100.0));
    v15 = json_real();
    json_object_set_new(v9, "rate_5s", v15);
    sub_DD47C((__int64)(v12 * 100.0));
    v16 = json_real();
    json_object_set_new(v9, "rate_30m", v16);
    sub_DD47C((__int64)(v13 * 100.0));
    v17 = json_real();
    json_object_set_new(v9, "rate_avg", v17);
    sub_DD47C((__int64)(v36 * 100.0));
    v18 = json_real();
    json_object_set_new(v9, "rate_ideal", v18);
    v19 = BUFX_strdup((char *)v37);
    json_object_set_new(v9, "rate_unit", v19);
    v20 = json_integer(v33);
    json_object_set_new(v9, "hw_all", v20);
    v21 = json_integer(*(__int64 *)&dword_107978);
    json_object_set_new(v9, "bestshare", v21);
    v22 = json_array();
    if ( v22 && off_106338 )
    {
      v23 = (char **)&off_106338;
      do
      {
        v24 = json_object();
        v25 = BUFX_strdup(*v23);
        json_object_set_new(v24, "type", v25);
        ((void (__fastcall *)(_DWORD *, char **))v23[1])(v24, v23);
        json_array_append_new(v22, v24);
        v26 = v23[6];
        v23 += 6;
      }
      while ( v26 );
    }
    json_object_set_new(v9, "status", v22);
    json_array_append_new(v8, v9);
    json_object_set_new(a1, "SUMMARY", v8);
    if ( v35 > 0 )
    {
      free(v4);
      free(ptr);
    }
    return 0;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v38, 0x1000u, 0, "%s: input bad api param\n", "get_summary");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/api_new.c",
      137,
      "get_summary",
      11,
      410,
      100,
      v38);
    return -2147483646;
  }
}
// 24528: variable 'ptr' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 106338: using guessed type _UNKNOWN *off_106338;
// 107978: using guessed type int dword_107978;
// 11A7AC: using guessed type int g_zc;

//----- (00024624) --------------------------------------------------------
time_t set_miner_start_time()
{
  time_t result; // r0
  int v1; // r4
  char *v2; // r0
  struct sysinfo info; // [sp+10h] [bp-1140h] BYREF
  char s[256]; // [sp+50h] [bp-1100h] BYREF
  char v5[4096]; // [sp+150h] [bp-1000h] BYREF

  if ( sysinfo(&info) )
  {
    v1 = *_errno_location();
    v2 = strerror(v1);
    sprintf(s, "Failed to get sysinfo, errno:%u, reason:%s", v1, v2);
    result = time(0);
    dword_107960 = result + 1;
    dword_107964 = result;
  }
  else
  {
    dword_107964 = info.uptime;
    dword_107960 = info.uptime + 1;
    sprintf(s, "%s total_tv_start_sys=%ld total_tv_end_sys=%ld", "set_miner_start_time", info.uptime, info.uptime + 1);
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "%s", s);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer"
             "-origin_godminer-new/api_new.c",
             137,
             "set_miner_start_time",
             20,
             332,
             60,
             v5);
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 107960: using guessed type int dword_107960;
// 107964: using guessed type int dword_107964;
// 11A7AC: using guessed type int g_zc;

//----- (0002473C) --------------------------------------------------------
int *api_flush()
{
  local_work = 0;
  last_getwork = 0;
  new_blocks = 0;
  total_go = 0;
  total_ro = 0;
  dword_107968 = 0;
  *(_QWORD *)&total_stale = 0;
  *(_QWORD *)&dword_107978 = 0;
  dbl_107970 = 0.0;
  *(_QWORD *)&total_accepted = 0;
  *(_QWORD *)&total_discarded = 0;
  *(_QWORD *)&total_rejected = 0;
  *(_QWORD *)&total_getworks = 0;
  *(_QWORD *)&total_diff1 = 0;
  total_diff_accepted = 0.0;
  total_diff_rejected = 0.0;
  total_diff_stale = 0.0;
  return &total_diff1;
}
// 107968: using guessed type int dword_107968;
// 107970: using guessed type double dbl_107970;
// 107978: using guessed type int dword_107978;
// 11A7D8: using guessed type int total_stale;
// 11A7E0: using guessed type double total_diff_accepted;
// 11A7E8: using guessed type int total_discarded;
// 11A7F0: using guessed type double total_diff_rejected;
// 11A7F8: using guessed type int total_ro;
// 11A7FC: using guessed type int last_getwork;
// 11A800: using guessed type int total_go;
// 11A808: using guessed type int total_accepted;
// 11A810: using guessed type int total_getworks;
// 11A818: using guessed type double total_diff_stale;
// 11A820: using guessed type int new_blocks;
// 11A824: using guessed type int local_work;
// 11A828: using guessed type int total_rejected;
// 11A830: using guessed type int total_diff1;

//----- (00024818) --------------------------------------------------------
void update_rate_ideal()
{
  ;
}

//----- (000249D0) --------------------------------------------------------
char *print_summary()
{
  double v0; // d0
  double v1; // d11
  double v2; // r0
  double v3; // d9
  double v4; // d8
  char *result; // r0
  _DWORD *v6; // r12
  int v7; // r0
  int v8; // r3
  int v9; // r6
  int v10; // r8
  int v11; // r5
  __int64 *v12; // r4
  __int64 *v13; // r5
  int v14; // r9
  __int64 v15; // t1
  __int64 v16; // r4
  int v17; // r1
  double v18; // d10
  double v19; // r0
  int v20; // r4
  _QWORD *v21; // r8
  __int64 v22; // r4
  int v23; // r1
  double v24; // d8
  double v25; // r0
  int v26; // [sp+4h] [bp-2070h]
  int v27; // [sp+18h] [bp-205Ch]
  char *v28; // [sp+1Ch] [bp-2058h]
  int v29; // [sp+20h] [bp-2054h]
  int v30; // [sp+20h] [bp-2054h]
  int i; // [sp+2Ch] [bp-2048h]
  int v32; // [sp+3Ch] [bp-2038h] BYREF
  float v33[12]; // [sp+40h] [bp-2034h] BYREF
  char v34[4048]; // [sp+70h] [bp-2004h] BYREF
  char v35[4100]; // [sp+1070h] [bp-1004h] BYREF

  read_system_status_from_monitor((int)v33);
  v1 = v33[5] / 1000.0 / 1000.0 / 1000.0;
  get_miner_elapsed_time();
  LODWORD(v2) = sub_DD47C(*(__int64 *)&total_accepted);
  v3 = v2 / v0 * 60.0;
  v4 = (total_diff_accepted + total_diff_rejected + total_diff_stale) / v0 * 60.0;
  V_LOCK();
  logfmt_raw(v35, 0x1000u, 0, "Summary of runtime statistics:");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/api_new.c",
    137,
    "print_summary",
    13,
    1723,
    80,
    v35);
  V_LOCK();
  logfmt_raw(v35, 0x1000u, 0, "Runtime: %d hrs : %d mins : %d secs", (int)v0 / 3600, (int)v0 % 3600 / 60, (int)v0 % 60);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/api_new.c",
    137,
    "print_summary",
    13,
    1724,
    80,
    v35);
  V_LOCK();
  logfmt_raw(v35, 0x1000u, 0, "Average hashrate: %.1f Ghash/s", v1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/api_new.c",
    137,
    "print_summary",
    13,
    1725,
    80,
    v35);
  V_LOCK();
  logfmt_raw(v35, 0x1000u, 0, "Total got job from pools: %lld", total_getworks, dword_11A814);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/api_new.c",
    137,
    "print_summary",
    13,
    1726,
    80,
    v35);
  V_LOCK();
  logfmt_raw(v35, 0x1000u, 0, "Total generated local work  %d", local_work);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/api_new.c",
    137,
    "print_summary",
    13,
    1727,
    80,
    v35);
  V_LOCK();
  logfmt_raw(v35, 0x1000u, 0, "Solved blocks: %d", dword_107968);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/api_new.c",
    137,
    "print_summary",
    13,
    1728,
    80,
    v35);
  V_LOCK();
  logfmt_raw(v35, 0x1000u, 0, "Share submissions: %lld", *(_QWORD *)&total_accepted + *(_QWORD *)&total_rejected);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/api_new.c",
    137,
    "print_summary",
    13,
    1729,
    80,
    v35);
  V_LOCK();
  logfmt_raw(v35, 0x1000u, 0, "Accepted shares: %lld", total_accepted, dword_11A80C);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/api_new.c",
    137,
    "print_summary",
    13,
    1730,
    80,
    v35);
  V_LOCK();
  logfmt_raw(v35, 0x1000u, 0, "Rejected shares: %lld", total_rejected, dword_11A82C);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/api_new.c",
    137,
    "print_summary",
    13,
    1731,
    80,
    v35);
  V_LOCK();
  logfmt_raw(v35, 0x1000u, 0, "Accepted difficulty shares: %1.f", total_diff_accepted);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/api_new.c",
    137,
    "print_summary",
    13,
    1732,
    80,
    v35);
  V_LOCK();
  logfmt_raw(v35, 0x1000u, 0, "Rejected difficulty shares: %1.f", total_diff_rejected);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/api_new.c",
    137,
    "print_summary",
    13,
    1733,
    80,
    v35);
  V_LOCK();
  logfmt_raw(v35, 0x1000u, 0, "Total Hardware errors %llu", v33[10], v33[11]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/api_new.c",
    137,
    "print_summary",
    13,
    1734,
    80,
    v35);
  if ( *(_QWORD *)&total_accepted || *(_QWORD *)&total_rejected )
  {
    V_LOCK();
    v16 = *(_QWORD *)&total_rejected;
    LODWORD(v18) = sub_DD47C(100LL * *(_QWORD *)&total_rejected);
    HIDWORD(v18) = v17;
    LODWORD(v19) = sub_DD47C(v16 + *(_QWORD *)&total_accepted);
    logfmt_raw(v35, 0x1000u, 0, "Reject ratio: %.1f%%", v18 / v19);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/api_new.c",
      137,
      "print_summary",
      13,
      1737,
      80,
      v35);
  }
  V_LOCK();
  logfmt_raw(v35, 0x1000u, 0, "Utility (accepted shares / min): %.2f/min", v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/api_new.c",
    137,
    "print_summary",
    13,
    1739,
    80,
    v35);
  V_LOCK();
  logfmt_raw(v35, 0x1000u, 0, "Work Utility (diff1 shares solved / min): %.2f/min", v4);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/api_new.c",
    137,
    "print_summary",
    13,
    1740,
    80,
    v35);
  V_LOCK();
  logfmt_raw(v35, 0x1000u, 0, "Stale submissions discarded due to new blocks: %lld", total_stale, dword_11A7DC);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/api_new.c",
    137,
    "print_summary",
    13,
    1741,
    80,
    v35);
  V_LOCK();
  logfmt_raw(v35, 0x1000u, 0, "Unable to get work from server occasions: %d", total_go);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/api_new.c",
    137,
    "print_summary",
    13,
    1742,
    80,
    v35);
  V_LOCK();
  logfmt_raw(v35, 0x1000u, 0, "Submitting work remotely delay occasions: %d", total_ro);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/api_new.c",
    137,
    "print_summary",
    13,
    1743,
    80,
    v35);
  V_LOCK();
  logfmt_raw(v35, 0x1000u, 0, "New blocks detected on network: %d", new_blocks);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/api_new.c",
    137,
    "print_summary",
    13,
    1744,
    80,
    v35);
  if ( total_pools > 0 )
  {
    V_LOCK();
    logfmt_raw(v35, 0x1000u, 0, "Summary of pool statistics:");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/api_new.c",
      137,
      "print_summary",
      13,
      1748,
      80,
      v35);
    if ( total_pools > 0 )
    {
      v30 = 0;
      do
      {
        v20 = *(_DWORD *)(pools + 4 * v30);
        V_LOCK();
        v21 = (_QWORD *)(v20 + 1920);
        logfmt_raw(v35, 0x1000u, 0, "Pool: %s", *(_DWORD *)(v20 + 8));
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/api_new.c",
          137,
          "print_summary",
          13,
          1753,
          80,
          v35);
        V_LOCK();
        logfmt_raw(v35, 0x1000u, 0, "User: %s", *(_DWORD *)(v20 + 12));
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/api_new.c",
          137,
          "print_summary",
          13,
          1754,
          80,
          v35);
        V_LOCK();
        logfmt_raw(v35, 0x1000u, 0, "Share submissions: %lld", *(_QWORD *)(v20 + 1920) + *(_QWORD *)(v20 + 1928));
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/api_new.c",
          137,
          "print_summary",
          13,
          1755,
          80,
          v35);
        V_LOCK();
        logfmt_raw(v35, 0x1000u, 0, "Accepted shares: %lld", *(_DWORD *)(v20 + 1920), *(_DWORD *)(v20 + 1924));
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/api_new.c",
          137,
          "print_summary",
          13,
          1756,
          80,
          v35);
        V_LOCK();
        logfmt_raw(v35, 0x1000u, 0, "Rejected shares: %lld", *(_DWORD *)(v20 + 1928), *(_DWORD *)(v20 + 1932));
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/api_new.c",
          137,
          "print_summary",
          13,
          1757,
          80,
          v35);
        V_LOCK();
        logfmt_raw(
          v35,
          0x1000u,
          0,
          "Accepted difficulty shares: %1.f",
          *(_DWORD *)(v20 + 1952),
          *(_DWORD *)(v20 + 1956));
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/api_new.c",
          137,
          "print_summary",
          13,
          1758,
          80,
          v35);
        V_LOCK();
        logfmt_raw(
          v35,
          0x1000u,
          0,
          "Rejected difficulty shares: %1.f",
          *(_DWORD *)(v20 + 1960),
          *(_DWORD *)(v20 + 1964));
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/api_new.c",
          137,
          "print_summary",
          13,
          1759,
          80,
          v35);
        if ( *(_QWORD *)(v20 + 1920) || *(_QWORD *)(v20 + 1928) )
        {
          V_LOCK();
          v22 = *(_QWORD *)(v20 + 1928);
          LODWORD(v24) = sub_DD47C(100 * v22);
          HIDWORD(v24) = v23;
          LODWORD(v25) = sub_DD47C(v22 + *v21);
          logfmt_raw(v35, 0x1000u, 0, "Reject ratio: %.1f%%", v24 / v25);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/api_new.c",
            137,
            "print_summary",
            13,
            1762,
            80,
            v35);
        }
        ++v30;
      }
      while ( total_pools > v30 );
    }
  }
  V_LOCK();
  logfmt_raw(v35, 0x1000u, 0, "Summary of per device statistics:");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/api_new.c",
    137,
    "print_summary",
    13,
    1767,
    80,
    v35);
  v32 = 0;
  result = (char *)get_all_created_runtime(&v32);
  if ( v32 > 0 )
  {
    v28 = result - 4;
    for ( i = 0; i < v32; ++i )
    {
      v6 = (_DWORD *)*((_DWORD *)v28 + 1);
      v28 += 4;
      v7 = snprintf(
             v34,
             0x1000u,
             "chain %d device %d wc %llu nc %llu detail: ",
             v6[50],
             v6[49],
             v26,
             v6[96],
             v6[97],
             v6[98],
             v6[99]);
      v8 = *(_DWORD *)v28;
      v9 = v7;
      v29 = *(_DWORD *)(*(_DWORD *)v28 + 280);
      if ( v29 > 0 )
      {
        v10 = 0;
        v27 = 0;
        while ( 1 )
        {
          v11 = *(_DWORD *)(v8 + 400);
          v12 = (__int64 *)(v11 + v10);
          v10 += 48;
          v13 = (__int64 *)(v11 + v10);
          ++v27;
          v14 = snprintf(&v34[v9], 4096 - v9, "%d:") + v9;
          do
          {
            v15 = *v12++;
            v14 += snprintf(&v34[v14], 4096 - v14, " %llu", v15);
          }
          while ( v13 != v12 );
          v9 = v14 + 2;
          snprintf(&v34[v14], 4096 - v14, " /");
          if ( v27 == v29 )
            break;
          v8 = *(_DWORD *)v28;
        }
      }
      V_LOCK();
      logfmt_raw(v35, 0x1000u, 0, "%s", v34);
      V_UNLOCK();
      result = (char *)zlog(
                         g_zc,
                         "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/bu"
                         "ild/godminer-origin_godminer-new/api_new.c",
                         137,
                         "print_summary",
                         13,
                         1784,
                         80,
                         v35);
    }
  }
  return result;
}
// 24A68: variable 'v2' is possibly undefined
// 24A68: variable 'v0' is possibly undefined
// 25338: variable 'v26' is possibly undefined
// 2542C: variable 'v17' is possibly undefined
// 25450: variable 'v19' is possibly undefined
// 2590C: variable 'v23' is possibly undefined
// 25930: variable 'v25' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 107968: using guessed type int dword_107968;
// 107BA0: using guessed type int total_pools;
// 107BA4: using guessed type int pools;
// 11A7AC: using guessed type int g_zc;
// 11A7D8: using guessed type int total_stale;
// 11A7DC: using guessed type int dword_11A7DC;
// 11A7E0: using guessed type double total_diff_accepted;
// 11A7F0: using guessed type double total_diff_rejected;
// 11A7F8: using guessed type int total_ro;
// 11A800: using guessed type int total_go;
// 11A808: using guessed type int total_accepted;
// 11A80C: using guessed type int dword_11A80C;
// 11A810: using guessed type int total_getworks;
// 11A814: using guessed type int dword_11A814;
// 11A818: using guessed type double total_diff_stale;
// 11A820: using guessed type int new_blocks;
// 11A824: using guessed type int local_work;
// 11A828: using guessed type int total_rejected;
// 11A82C: using guessed type int dword_11A82C;

//----- (000259A4) --------------------------------------------------------
void *api()
{
  void *result; // r0
  int v1; // r4
  struct addrinfo *v2; // r4
  struct addrinfo *i; // r3
  int v4; // r0
  int v5; // r6
  time_t v6; // r9
  int *v7; // r0
  char *v8; // r5
  int servlen; // r4
  int v10; // r0
  ssize_t v11; // r3
  double *v12; // r0
  double *v13; // r5
  _DWORD *v14; // r0
  _DWORD *v15; // r6
  unsigned int *v16; // r3
  unsigned int v17; // r2
  unsigned int v18; // r2
  _DWORD *v19; // r4
  double *v20; // r0
  double *v21; // r5
  char *v22; // r0
  char *v23; // r5
  unsigned int *v24; // r3
  unsigned int v25; // r2
  unsigned int v26; // r2
  _DWORD *v27; // r0
  _DWORD *v28; // r0
  _DWORD *v29; // r8
  int v30; // r0
  int v31; // r6
  size_t v32; // r0
  int v33; // r0
  int v34; // r0
  int v35; // r0
  int *v36; // r4
  char **v37; // r6
  unsigned int v38; // r5
  const char *v39; // r7
  char *v40; // t1
  _DWORD *v41; // r0
  unsigned int *v42; // r3
  unsigned int v43; // r2
  unsigned int v44; // r2
  _DWORD *v45; // r0
  unsigned int *v46; // r3
  unsigned int v47; // r2
  unsigned int v48; // r2
  _DWORD *v49; // r0
  unsigned int v50; // r4
  _DWORD *v51; // r8
  _DWORD *v52; // r0
  bool v53; // zf
  int v54; // r7
  const char *v55; // r0
  char *v56; // r0
  char *v57; // r4
  unsigned int *v58; // r3
  unsigned int v59; // r2
  unsigned int v60; // r2
  unsigned int *v61; // r3
  unsigned int v62; // r2
  unsigned int v63; // r2
  int *v64; // r0
  char *v65; // r0
  _DWORD *v66; // r8
  unsigned int v67; // r6
  _DWORD *v68; // r0
  _DWORD *v69; // r7
  int v70; // r0
  int v71; // r5
  size_t v72; // r0
  int v73; // r0
  int v74; // r0
  int v75; // r0
  int *v76; // r8
  char *v77; // r6
  int v78; // r12
  const char *v79; // r0
  _DWORD *v80; // r0
  _DWORD *v81; // r0
  unsigned int v82; // r1
  unsigned int *v83; // r3
  unsigned int v84; // r2
  unsigned int v85; // r2
  const char *v86; // r0
  int *v87; // r0
  char *v88; // r0
  unsigned int v89; // [sp+10h] [bp-F554h]
  unsigned int protocol; // [sp+18h] [bp-F54Ch]
  _DWORD *v91; // [sp+1Ch] [bp-F548h]
  unsigned int v92; // [sp+20h] [bp-F544h]
  int v93; // [sp+24h] [bp-F540h]
  _DWORD *v94; // [sp+2Ch] [bp-F538h]
  _DWORD *v95; // [sp+34h] [bp-F530h]
  _DWORD *v96; // [sp+40h] [bp-F524h]
  int v97; // [sp+4Ch] [bp-F518h] BYREF
  int fd; // [sp+50h] [bp-F514h] BYREF
  socklen_t addr_len; // [sp+54h] [bp-F510h] BYREF
  struct addrinfo *pai; // [sp+58h] [bp-F50Ch] BYREF
  int optval; // [sp+5Ch] [bp-F508h] BYREF
  char service[12]; // [sp+60h] [bp-F504h] BYREF
  char v103[4]; // [sp+6Ch] [bp-F4F8h] BYREF
  int v104; // [sp+70h] [bp-F4F4h]
  int v105; // [sp+74h] [bp-F4F0h]
  int v106; // [sp+78h] [bp-F4ECh]
  char v107[4]; // [sp+7Ch] [bp-F4E8h] BYREF
  int v108; // [sp+80h] [bp-F4E4h]
  int v109; // [sp+84h] [bp-F4E0h]
  int v110; // [sp+88h] [bp-F4DCh]
  char s1[4]; // [sp+8Ch] [bp-F4D8h] BYREF
  int v112; // [sp+90h] [bp-F4D4h]
  int v113; // [sp+94h] [bp-F4D0h]
  int v114; // [sp+98h] [bp-F4CCh]
  _DWORD v115[5]; // [sp+9Ch] [bp-F4C8h] BYREF
  struct addrinfo v116; // [sp+B0h] [bp-F4B4h] BYREF
  struct sockaddr addr; // [sp+D0h] [bp-F494h] BYREF
  char v118[16]; // [sp+150h] [bp-F414h] BYREF
  char v119[252]; // [sp+24Ch] [bp-F318h] BYREF
  char src[256]; // [sp+348h] [bp-F21Ch] BYREF
  _DWORD v121[70]; // [sp+448h] [bp-F11Ch] BYREF
  char s[4096]; // [sp+560h] [bp-F004h] BYREF
  char v123[4064]; // [sp+1560h] [bp-E004h] BYREF
  char v124[4064]; // [sp+2560h] [bp-D004h] BYREF
  char v125[4000]; // [sp+3560h] [bp-C004h] BYREF
  char v126[4000]; // [sp+4560h] [bp-B004h] BYREF
  char v127[4000]; // [sp+5560h] [bp-A004h] BYREF
  char v128[4000]; // [sp+6560h] [bp-9004h] BYREF
  char v129[4000]; // [sp+7560h] [bp-8004h] BYREF
  char v130[4000]; // [sp+8560h] [bp-7004h] BYREF
  char v131[4000]; // [sp+9560h] [bp-6004h] BYREF
  char v132[4000]; // [sp+A560h] [bp-5004h] BYREF
  char v133[4000]; // [sp+B560h] [bp-4004h] BYREF
  char v134[4000]; // [sp+C560h] [bp-3004h] BYREF
  char v135[8196]; // [sp+D560h] [bp-2004h] BYREF

  v97 = -1;
  fd = -1;
  v89 = 2;
  memset(v135, 0, 0x2000u);
  result = memset(s, 0, sizeof(s));
  v1 = (unsigned __int8)byte_107980;
  v104 = 0;
  v108 = 0;
  *(_DWORD *)v103 = 0;
  v105 = 0;
  v106 = 0;
  *(_DWORD *)v107 = 0;
  v109 = 0;
  v110 = 0;
  if ( !byte_107980 )
  {
    V_LOCK();
    logfmt_raw(v123, 0x1000u, v1, "Start api function");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/api_new.c",
      137,
      "api",
      3,
      2252,
      60,
      v123);
    v2 = (struct addrinfo *)_sigsetjmp((struct __jmp_buf_tag *)v121, v1);
    if ( v2 )
    {
      sub_219FC(&v97);
      _pthread_unwind_next((__pthread_unwind_buf_t *)v121);
    }
    else
    {
      _pthread_register_cancel((__pthread_unwind_buf_t *)v121);
      sprintf(service, "%d", 4028);
      memset(&v116.ai_family, 0, 28);
      v116.ai_flags = 1;
      protocol = getaddrinfo("0.0.0.0", service, &v116, &pai);
      if ( protocol )
      {
        V_LOCK();
        v77 = v129;
        logfmt_raw(v129, 0x1000u, 0, "%s: exec getaddrinfo() failed\n", "api_init_socket");
        V_UNLOCK();
        v78 = 1860;
LABEL_123:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/api_new.c",
          137,
          "api_init_socket",
          15,
          v78,
          100,
          v77);
LABEL_120:
        V_LOCK();
        logfmt_raw(v124, 0x1000u, 0, "%s: init socket failed", "api");
        V_UNLOCK();
        return (void *)zlog(
                         g_zc,
                         "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/bu"
                         "ild/godminer-origin_godminer-new/api_new.c",
                         137,
                         "api",
                         3,
                         2258,
                         100,
                         v124);
      }
      v2 = pai;
      if ( pai )
      {
        for ( i = pai; ; i = pai )
        {
          v4 = socket(i->ai_family, 1, protocol);
          if ( v4 > 0 )
          {
            v5 = v4;
            goto LABEL_10;
          }
          v2 = v2->ai_next;
          if ( !v2 )
            break;
        }
        v5 = v4;
        if ( v4 == -1 )
        {
          V_LOCK();
          v77 = v130;
          logfmt_raw(v130, 0x1000u, 0, "%s: exec socket() failed\n", "api_init_socket");
          V_UNLOCK();
          v78 = 1873;
          goto LABEL_123;
        }
        goto LABEL_10;
      }
    }
    v5 = (int)v2;
LABEL_10:
    optval = 1;
    setsockopt(v5, 1, 2, &optval, 4u);
    v6 = time(0);
    while ( bind(v5, v2->ai_addr, v2->ai_addrlen) < 0 )
    {
      v7 = _errno_location();
      v8 = strerror(*v7);
      if ( time(0) - v6 > 61 )
      {
        freeaddrinfo(pai);
        V_LOCK();
        logfmt_raw(v132, 0x1000u, 0, "api bind to port %d, failed (%s)", 4028, v8);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/api_new.c",
          137,
          "api_init_socket",
          15,
          1896,
          100,
          v132);
        goto LABEL_120;
      }
      V_LOCK();
      logfmt_raw(v131, 0x1000u, 0, "%s: api bind to port %d failed, trying again in 30sec", "api_init_socket", 4028);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/api_new.c",
        137,
        "api_init_socket",
        15,
        1888,
        80,
        v131);
      sleep(0x1Eu);
    }
    freeaddrinfo(pai);
    if ( listen(v5, 100) >= 0 )
    {
      if ( v5 < 0 )
        goto LABEL_120;
      v97 = v5;
      byte_107980 = 1;
      while ( 1 )
      {
        servlen = (unsigned __int8)byte_10795C;
        if ( byte_10795C )
        {
LABEL_103:
          _pthread_unregister_cancel((__pthread_unwind_buf_t *)v121);
          sub_219FC(&v97);
          byte_107980 = 0;
          V_LOCK();
          logfmt_raw(v128, 0x1000u, 0, "End api function !!!");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/api_new.c",
            137,
            "api",
            3,
            2326,
            60,
            v128);
          return (void *)close(v97);
        }
        addr_len = 128;
        v10 = accept(v97, &addr, &addr_len);
        fd = v10;
        if ( v10 < 0 )
        {
          V_LOCK();
          v64 = _errno_location();
          v65 = strerror(*v64);
          logfmt_raw(v125, 0x1000u, servlen, "%s: exec accept failed (%s)", "api", v65);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/api_new.c",
            137,
            "api",
            3,
            2268,
            100,
            v125);
          goto LABEL_103;
        }
        v11 = recv(v10, v135, 0xFFFu, servlen);
        if ( v11 < 0 )
        {
          v135[0] = servlen;
          goto LABEL_18;
        }
        *(_DWORD *)::s1 = servlen;
        dword_107950 = servlen;
        dword_107954 = servlen;
        dword_107958 = servlen;
        v135[v11] = servlen;
        *(_DWORD *)v103 = servlen;
        *(_DWORD *)v107 = servlen;
        v104 = servlen;
        v105 = servlen;
        v106 = servlen;
        v108 = servlen;
        v109 = servlen;
        v110 = servlen;
        dword_107948 = time((time_t *)servlen);
        getnameinfo(&addr, 0x80u, ::s1, 0x10u, (char *)servlen, servlen, 1u);
        V_LOCK();
        logfmt_raw(v126, 0x1000u, servlen, "connect_addr: %s", ::s1);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/api_new.c",
          137,
          "api",
          3,
          2284,
          20,
          v126);
        v112 = servlen;
        *(_DWORD *)s1 = servlen;
        v113 = servlen;
        v114 = servlen;
        v12 = json_loads((int)v135, servlen, v118);
        v13 = v12;
        if ( v12 && !*(_DWORD *)v12 )
        {
          v14 = (_DWORD *)json_object_get(v12, "command");
          v15 = v14;
          if ( v14 && *v14 == 1 )
          {
            v49 = (_DWORD *)json_object_get(v13, "new_api");
            if ( v49 )
              v92 = *v49 != 5;
            else
              v92 = 1;
            v50 = protocol;
            v93 = protocol;
            v51 = json_object();
            while ( (unsigned int)json_array_size(v15) > v50 )
            {
              v52 = json_array_get(v15, v50);
              v53 = v52 == 0;
              if ( v52 )
                v53 = v50 == 11;
              v54 = v53;
              if ( v53 )
                break;
              if ( *v52 == 2 )
              {
                *(_DWORD *)s1 = v54;
                v112 = v54;
                v113 = v54;
                v114 = v54;
                v55 = (const char *)json_string_value(v52);
                snprintf(s1, 0x10u, "%s", v55);
                if ( strcmp(s1, "reload") | v92 )
                {
                  v95 = json_object();
                  sub_21A40(v95, s1, v54, v92);
                  json_object_set_new(v51, s1, v95);
                }
                else
                {
                  v93 = 1;
                }
              }
              ++v50;
            }
            v56 = json_dumps(v51, 24576);
            v57 = v56;
            if ( v56 )
              sub_22010(&fd, v56);
            free(v57);
            if ( v93 == 1 )
              sub_21A40(v51, "reload", 0, 0);
            if ( v51 )
            {
              if ( v51[1] != -1 )
              {
                v58 = v51 + 1;
                __dmb(0xBu);
                do
                {
                  v59 = __ldrex(v58);
                  v60 = v59 - 1;
                }
                while ( __strex(v60, v58) );
                if ( !v60 )
                  json_delete(v51);
              }
            }
            if ( *((_DWORD *)v13 + 1) != -1 )
            {
              v61 = (unsigned int *)v13 + 1;
              __dmb(0xBu);
              do
              {
                v62 = __ldrex(v61);
                v63 = v62 - 1;
              }
              while ( __strex(v63, v61) );
              if ( !v63 )
                json_delete(v13);
            }
            goto LABEL_18;
          }
          if ( *((_DWORD *)v13 + 1) != -1 )
          {
            v16 = (unsigned int *)v13 + 1;
            __dmb(0xBu);
            do
            {
              v17 = __ldrex(v16);
              v18 = v17 - 1;
            }
            while ( __strex(v18, v16) );
            if ( !v18 )
              json_delete(v13);
          }
        }
        v19 = json_object();
        v20 = json_loads((int)v135, 0, v119);
        v21 = v20;
        if ( !v20 || *(_DWORD *)v20 )
        {
          v89 = 2;
          snprintf(v103, 0x10u, "%s", v135);
          sub_21A40(v19, v103, (int)v107, 2u);
          goto LABEL_34;
        }
        v45 = (_DWORD *)json_object_get(v20, "command");
        if ( v45 && *v45 == 2 )
        {
          v79 = (const char *)json_string_value(v45);
          snprintf(v103, 0x10u, "%s", v79);
          v80 = (_DWORD *)json_object_get(v21, "new_api");
          if ( v80 && *v80 == 5 )
          {
            if ( *((_DWORD *)v21 + 1) == -1 )
            {
              v89 = protocol;
              sub_21A40(v19, v103, (int)v107, protocol);
              goto LABEL_34;
            }
            v82 = protocol;
          }
          else
          {
            v81 = (_DWORD *)json_object_get(v21, "parameter");
            if ( v81 && *v81 == 2 )
            {
              v86 = (const char *)json_string_value(v81);
              snprintf(v107, 0x10u, "%s", v86);
            }
            if ( *((_DWORD *)v21 + 1) == -1 )
            {
              v89 = 1;
              sub_21A40(v19, v103, (int)v107, 1u);
              goto LABEL_34;
            }
            v82 = 1;
          }
          v83 = (unsigned int *)v21 + 1;
          __dmb(0xBu);
          do
          {
            v84 = __ldrex(v83);
            v85 = v84 - 1;
          }
          while ( __strex(v85, v83) );
          v89 = v82;
          if ( v85 )
          {
            sub_21A40(v19, v103, (int)v107, v82);
          }
          else
          {
            json_delete(v21);
            sub_21A40(v19, v103, (int)v107, v89);
          }
        }
        else
        {
          V_LOCK();
          logfmt_raw(v134, 0x1000u, 0, "%s error: format error about command\n", "parse_recv_buf");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/api_new.c",
            137,
            "parse_recv_buf",
            14,
            1934,
            100,
            v134);
          if ( *((_DWORD *)v21 + 1) != -1 )
          {
            v46 = (unsigned int *)v21 + 1;
            __dmb(0xBu);
            do
            {
              v47 = __ldrex(v46);
              v48 = v47 - 1;
            }
            while ( __strex(v48, v46) );
            if ( !v48 )
              json_delete(v21);
          }
          V_LOCK();
          logfmt_raw(v127, 0x1000u, 0, "%s: input invaild param format", "api");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/api_new.c",
            137,
            "api",
            3,
            2297,
            100,
            v127);
          sub_1F644(v19, 0, 24, "Missing JSON 'command'");
        }
LABEL_34:
        if ( v89 == 2 )
        {
          memset(s, 0, sizeof(s));
          if ( v19 )
          {
            v27 = (_DWORD *)json_object_get(v19, "STATUS");
            if ( v27 )
            {
              if ( *v27 == 1 )
              {
                v28 = json_array_get(v27, 0);
                v29 = v28;
                if ( v28 )
                {
                  if ( !*v28 )
                  {
                    v30 = json_object_iter(v28);
                    v31 = json_object_iter_key(v30);
                    if ( v31 )
                    {
                      v94 = v19;
                      do
                      {
                        v35 = json_object_key_to_iter(v31);
                        v36 = (int *)json_object_iter_value(v35);
                        if ( !v36 )
                          break;
                        v32 = strlen(s);
                        *(_WORD *)stpcpy(&s[v32], v31) = 61;
                        sub_21C04(s, v36);
                        *(_WORD *)&s[strlen(s)] = 44;
                        v33 = json_object_key_to_iter(v31);
                        v34 = json_object_iter_next(v29, v33);
                        v31 = json_object_iter_key(v34);
                      }
                      while ( v31 );
                      v19 = v94;
                    }
                    v37 = (char **)v115;
                    *((_BYTE *)&v121[69] + strlen(s) + 3) = 124;
                    memset(src, 0, sizeof(src));
                    v38 = protocol;
                    v115[0] = "SUMMARY";
                    v115[1] = "POOLS";
                    v115[2] = "STATS";
                    v115[3] = "DEVS";
                    v115[4] = "VERSION";
                    while ( 1 )
                    {
                      v40 = *v37++;
                      v39 = v40;
                      v41 = (_DWORD *)json_object_get(v19, v40);
                      if ( v41 )
                      {
                        if ( *v41 == 1 )
                          break;
                      }
                      if ( ++v38 == 5 )
                        goto LABEL_58;
                    }
                    v66 = v41;
                    if ( (v38 & 0xFFFFFFFB) == 0 )
                    {
                      snprintf(src, 0x100u, "%s,", v39);
                      strcat(s, src);
                    }
                    v91 = json_array_size(v66);
                    if ( (int)v91 > 0 )
                    {
                      v67 = protocol;
                      do
                      {
                        v68 = json_array_get(v66, v67);
                        v69 = v68;
                        if ( v68 && !*v68 )
                        {
                          v70 = json_object_iter(v68);
                          v71 = json_object_iter_key(v70);
                          if ( v71 )
                          {
                            v96 = v66;
                            do
                            {
                              v75 = json_object_key_to_iter(v71);
                              v76 = (int *)json_object_iter_value(v75);
                              if ( !v76 )
                                break;
                              v72 = strlen(s);
                              *(_WORD *)stpcpy(&s[v72], v71) = 61;
                              sub_21C04(s, v76);
                              *(_WORD *)&s[strlen(s)] = 44;
                              v73 = json_object_key_to_iter(v71);
                              v74 = json_object_iter_next(v69, v73);
                              v71 = json_object_iter_key(v74);
                            }
                            while ( v71 );
                            v66 = v96;
                          }
                          *((_BYTE *)&v121[69] + strlen(s) + 3) = 124;
                          if ( (_DWORD *)((char *)v91 - 1) != (_DWORD *)v67 )
                            s[strlen(s)] = 44;
                        }
                        ++v67;
                      }
                      while ( v91 != (_DWORD *)v67 );
                    }
                  }
                }
              }
            }
          }
LABEL_58:
          sub_22010(&fd, s);
          if ( v19 )
          {
            if ( v19[1] != -1 )
            {
              v42 = v19 + 1;
              __dmb(0xBu);
              do
              {
                v43 = __ldrex(v42);
                v44 = v43 - 1;
              }
              while ( __strex(v44, v42) );
              if ( !v44 )
                json_delete(v19);
            }
          }
        }
        else
        {
          v22 = json_dumps(v19, 24576);
          v23 = v22;
          if ( v22 )
            sub_22010(&fd, v22);
          if ( v19 && v19[1] != -1 )
          {
            v24 = v19 + 1;
            __dmb(0xBu);
            do
            {
              v25 = __ldrex(v24);
              v26 = v25 - 1;
            }
            while ( __strex(v26, v24) );
            if ( !v26 )
              json_delete(v19);
          }
          free(v23);
        }
LABEL_18:
        close(fd);
      }
    }
    V_LOCK();
    v87 = _errno_location();
    v88 = strerror(*v87);
    logfmt_raw(v133, 0x1000u, 0, "%s: exec listen() failed (%s)", "api_init_socket", v88);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/api_new.c",
      137,
      "api_init_socket",
      15,
      1901,
      100,
      v133);
    close(v5);
    goto LABEL_120;
  }
  return result;
}
// 26094: variable 'protocol' is possibly undefined
// 1E64C: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// DEA70: using guessed type __int16 word_DEA70;
// 107948: using guessed type int dword_107948;
// 107950: using guessed type int dword_107950;
// 107954: using guessed type int dword_107954;
// 107958: using guessed type int dword_107958;
// 10795C: using guessed type char byte_10795C;
// 107980: using guessed type char byte_107980;
// 11A7AC: using guessed type int g_zc;

//----- (00026A08) --------------------------------------------------------
void __noreturn work_generator_thread()
{
  int v0; // r5
  int *all_created_runtime; // r6
  int *v2; // r0
  unsigned __int64 v3; // r2
  int v4; // t1
  unsigned __int64 v5; // r8
  int v6; // r9
  char *v7; // r7
  int v8; // r0
  int current_pool; // r0
  pthread_mutex_t *v10; // r7
  int v11; // r0
  int v12; // r12
  int v13; // r6
  char *v14; // r8
  int v15; // r2
  time_t v16; // r0
  int v17; // r3
  int v18; // t1
  unsigned __int64 *v19; // r2
  int v20; // r12
  int v21; // r3
  unsigned __int64 v22; // r6
  unsigned __int64 v23; // r8
  unsigned __int64 v24; // r0
  unsigned __int64 v25; // t1
  bool v26; // cf
  int v27; // r12
  int v28; // r0
  void *v29; // r0
  unsigned int nusers; // r2
  const char *kind; // r0
  int v32; // [sp+1Ch] [bp-14B0h]
  int v33; // [sp+20h] [bp-14ACh]
  char *v34; // [sp+38h] [bp-1494h]
  int v35; // [sp+4Ch] [bp-1480h] BYREF
  struct timespec v36; // [sp+50h] [bp-147Ch] BYREF
  _DWORD s[284]; // [sp+58h] [bp-1474h] BYREF
  struct timespec v38[512]; // [sp+4C8h] [bp-1004h] BYREF

  v35 = 0;
  v0 = frontend_runtime_instance();
  all_created_runtime = (int *)get_all_created_runtime(&v35);
  memset(s, 0, sizeof(s));
  if ( v35 <= 0 )
  {
    v33 = 0;
    v32 = -1000;
  }
  else
  {
    v2 = all_created_runtime;
    v3 = -1;
    do
    {
      v4 = *v2++;
      v5 = *(_QWORD *)(v4 + 920);
      if ( v3 > v5 )
        v3 = v5;
    }
    while ( &all_created_runtime[v35] != v2 );
    v33 = (int)v3 / 1000000;
    v32 = 1000 * (v3 - (_DWORD)&unk_F4240 * ((int)v3 / 1000000));
  }
  v6 = 0;
  v7 = (char *)calloc(1u, 0x40u);
  snprintf(v7, 0x40u, "%.10s_%d", "work_generator_thread", 0);
  V_LOCK();
  v8 = syscall(224);
  logfmt_raw((char *)v38, 0x1000u, 0, "%s on pid %ld", v7, v8);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/god-miner.c",
    139,
    "work_generator_thread",
    21,
    198,
    40,
    v38);
  v34 = (char *)(all_created_runtime - 1);
  prctl(15, v7);
  clock_gettime(1, (struct timespec *)&send_job_timer);
  while ( 1 )
  {
LABEL_9:
    while ( 1 )
    {
      current_pool = get_current_pool();
      v10 = (pthread_mutex_t *)current_pool;
      if ( current_pool )
        break;
LABEL_34:
      V_LOCK();
      logfmt_raw((char *)v38, 0x1000u, (int)v10, "work generator: current pool is NULL");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/god-miner.c",
        139,
        "work_generator_thread",
        21,
        218,
        20,
        v38);
    }
    while ( 1 )
    {
      if ( pool_tget(current_pool, (unsigned __int8 *)&v10[79]) )
        goto LABEL_37;
      clock_gettime(1, v38);
      v36.tv_nsec = (v32 + v38[0].tv_nsec) % 1000000000;
      v36.tv_sec = (v32 + v38[0].tv_nsec) / 1000000000 + v38[0].tv_sec + v33;
      v11 = pool_twait_to_be_expected_and_set((int)v10, &v10[79].__size[12], 1, 0, &v36);
      if ( v11 == 1 )
        break;
      if ( v11 == 110 )
      {
        V_LOCK();
        logfmt_raw((char *)v38, 0x1000u, 0, "Wait for new job timeout");
        V_UNLOCK();
        v12 = 234;
      }
      else
      {
        V_LOCK();
        logfmt_raw((char *)v38, 0x1000u, 0, "New job has come");
        V_UNLOCK();
        v12 = 236;
      }
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/god-miner.c",
        139,
        "work_generator_thread",
        21,
        v12,
        20,
        v38);
      pthread_mutex_lock(v10 + 66);
      if ( pool_tget((int)v10, (unsigned __int8 *)&v10[65].__size[16]) )
      {
        pthread_mutex_unlock(v10 + 66);
        V_LOCK();
        logfmt_raw(
          (char *)v38,
          0x1000u,
          0,
          "work generator: jobid %p cancel %d",
          v10[65].__kind,
          (unsigned __int8)v10[65].__size[16]);
        V_UNLOCK();
        v27 = 242;
        v28 = g_zc;
        goto LABEL_36;
      }
      if ( (*(int (__fastcall **)(_DWORD *, pthread_mutex_t *))(v0 + 32))(s, v10) == 2 )
      {
        V_LOCK();
        logfmt_raw((char *)v38, 0x1000u, 0, "work generator switched to new job %s", v10[65].__kind);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/god-miner.c",
          139,
          "work_generator_thread",
          21,
          248,
          20,
          v38);
        v29 = (void *)s[281];
        nusers = v10[67].__nusers;
        ++*(_QWORD *)&total_getworks;
        v10[67].__nusers = nusers + 1;
        if ( v29 )
        {
          free(v29);
          s[281] = 0;
        }
        v6 = 1;
        memcpy(s, &v10[18].__align + 4, sizeof(s));
        kind = (const char *)v10[65].__kind;
        if ( kind )
          s[281] = _strdup(kind);
      }
      pthread_mutex_unlock(v10 + 66);
      if ( !s[281] )
        goto LABEL_9;
      if ( v35 > 0 )
      {
        v13 = 0;
        v14 = v34;
        do
        {
          if ( v13 )
            v15 = 0;
          else
            v15 = v6;
          ++v13;
          (**(void (__fastcall ***)(_DWORD *, pthread_mutex_t *, int))(v0 + 68))(s, v10, v15);
          ++local_work;
          v16 = time(0);
          v17 = *(_DWORD *)(v0 + 68);
          last_getwork = v16;
          v18 = *((_DWORD *)v14 + 1);
          v14 += 4;
          (*(void (__fastcall **)(int, _DWORD *))(v17 + 4))(v18, s);
        }
        while ( v35 > v13 );
      }
      V_LOCK();
      clock_gettime(1, &tp);
      if ( v6 )
      {
        logfmt_raw(
          (char *)v38,
          0x1000u,
          0,
          "New job pushed after %lld ms",
          1000LL * (tp.tv_sec - send_job_timer) + (tp.tv_nsec - dword_11A83C) / 1000000);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/god-miner.c",
          139,
          "work_generator_thread",
          21,
          273,
          20,
          v38);
      }
      else
      {
        logfmt_raw(
          (char *)v38,
          0x1000u,
          0,
          "Updated job pushed after %lld ms",
          1000LL * (tp.tv_sec - send_job_timer) + (tp.tv_nsec - dword_11A83C) / 1000000);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/god-miner.c",
          139,
          "work_generator_thread",
          21,
          275,
          20,
          v38);
      }
      clock_gettime(1, &tp);
      v19 = max_timeout_value;
      v20 = 0;
      v21 = 0;
      v22 = -1;
      v23 = (int)&unk_F4240 * (__int64)(tp.tv_sec - send_job_timer) + (tp.tv_nsec - dword_11A83C) / 1000;
      do
      {
        v25 = *v19++;
        v24 = v25;
        v26 = v25 >= v22;
        if ( v25 < v22 )
          v20 = v21;
        ++v21;
        if ( !v26 )
          v22 = v24;
      }
      while ( v21 != 10 );
      if ( v23 > v22 )
        max_timeout_value[v20] = v23;
      v6 = 0;
      clock_gettime(1, (struct timespec *)&send_job_timer);
      current_pool = get_current_pool();
      v10 = (pthread_mutex_t *)current_pool;
      if ( !current_pool )
        goto LABEL_34;
    }
    V_LOCK();
    logfmt_raw((char *)v38, 0x1000u, 0, "pool has been changed");
    V_UNLOCK();
    v27 = 230;
    v28 = g_zc;
LABEL_36:
    zlog(
      v28,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/god-miner.c",
      139,
      "work_generator_thread",
      21,
      v27,
      20,
      v38);
LABEL_37:
    sleep(0);
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 107988: using guessed type _QWORD max_timeout_value[26];
// 11A7AC: using guessed type int g_zc;
// 11A7FC: using guessed type int last_getwork;
// 11A810: using guessed type int total_getworks;
// 11A824: using guessed type int local_work;
// 11A838: using guessed type int send_job_timer;
// 11A83C: using guessed type int dword_11A83C;

//----- (000271DC) --------------------------------------------------------
char *__fastcall godminer_chip_status_monitor(int a1)
{
  char *result; // r0
  int v3; // r1
  char *v4; // r5
  _DWORD v5[7]; // [sp+28h] [bp-1040h] BYREF
  int v6; // [sp+44h] [bp-1024h]
  _DWORD v7[7]; // [sp+48h] [bp-1020h] BYREF
  int v8; // [sp+64h] [bp-1004h]
  char v9[4096]; // [sp+68h] [bp-1000h] BYREF

  ++*((_DWORD *)&max_timeout_value[10] + *(_DWORD *)(a1 + 196));
  result = get_flag_from_monitor(a1);
  v3 = *((_DWORD *)result + 12);
  v4 = result;
  if ( (v3 & 2) != 0 )
  {
    V_LOCK();
    V_INT((int)v5, "chain", *(int *)(a1 + 200));
    logfmt_raw(v9, 0x1000u, 0, v6, v5[0], v5[1], v5[2], v5[3], v5[4], v5[5], v5[6], v6, "some chip working slow");
    V_UNLOCK();
    result = (char *)zlog(
                       g_zc,
                       "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/buil"
                       "d/godminer-origin_godminer-new/god-miner.c",
                       139,
                       "godminer_chip_status_monitor",
                       28,
                       680,
                       20,
                       v9);
    v3 = *((_DWORD *)v4 + 12);
    *((_DWORD *)v4 + 14) |= 2u;
  }
  if ( (v3 & 4) != 0 )
  {
    V_LOCK();
    V_INT((int)v7, "chain", *(int *)(a1 + 200));
    logfmt_raw(v9, 0x1000u, 0, v8, v7[0], v7[1], v7[2], v7[3], v7[4], v7[5], v7[6], v8, "some chip working slow");
    V_UNLOCK();
    result = (char *)zlog(
                       g_zc,
                       "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/buil"
                       "d/godminer-origin_godminer-new/god-miner.c",
                       139,
                       "godminer_chip_status_monitor",
                       28,
                       685,
                       20,
                       v9);
    *((_DWORD *)v4 + 14) |= 4u;
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 107988: using guessed type _QWORD max_timeout_value[26];
// 11A7AC: using guessed type int g_zc;

//----- (00027398) --------------------------------------------------------
char *__fastcall godminer_fan_monitor(int a1)
{
  char *result; // r0
  int v2; // r1
  char *v3; // r5
  _DWORD v4[7]; // [sp+28h] [bp-1044h] BYREF
  int v5; // [sp+44h] [bp-1028h]
  _DWORD v6[7]; // [sp+48h] [bp-1024h] BYREF
  int v7; // [sp+64h] [bp-1008h]
  char v8[4100]; // [sp+68h] [bp-1004h] BYREF

  ++*((_DWORD *)&max_timeout_value[18] + *(_DWORD *)(a1 + 196));
  result = get_flag_from_monitor(a1);
  v2 = *((_DWORD *)result + 8);
  v3 = result;
  if ( (v2 & 2) != 0 )
  {
    V_LOCK();
    V_STR(v4, "error", "fan lost");
    logfmt_raw(v8, 0x1000u, 0, v5, v4[0], v4[1], v4[2], v4[3], v4[4], v4[5], v4[6], v5, "fan lost happend");
    V_UNLOCK();
    result = (char *)zlog(
                       g_zc,
                       "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/buil"
                       "d/godminer-origin_godminer-new/god-miner.c",
                       139,
                       "godminer_fan_monitor",
                       20,
                       697,
                       20,
                       v8);
    v2 = *((_DWORD *)v3 + 8);
    *((_DWORD *)v3 + 10) |= 2u;
  }
  if ( (v2 & 1) != 0 )
  {
    V_LOCK();
    V_STR(v6, "error", "fan slow");
    logfmt_raw(v8, 0x1000u, 0, v7, v6[0], v6[1], v6[2], v6[3], v6[4], v6[5], v6[6], v7, "fan slow happend");
    V_UNLOCK();
    result = (char *)zlog(
                       g_zc,
                       "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/buil"
                       "d/godminer-origin_godminer-new/god-miner.c",
                       139,
                       "godminer_fan_monitor",
                       20,
                       702,
                       20,
                       v8);
    *((_DWORD *)v3 + 10) |= 1u;
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 107988: using guessed type _QWORD max_timeout_value[26];
// 11A7AC: using guessed type int g_zc;

//----- (00027540) --------------------------------------------------------
int __fastcall sub_27540(int a1)
{
  int v1; // r2
  int result; // r0
  char v3[4096]; // [sp+10h] [bp-1000h] BYREF

  switch ( a1 )
  {
    case 2:
      V_LOCK();
      logfmt_raw(v3, 0x1000u, 0, "SIGINT received, exiting");
      V_UNLOCK();
      v1 = 543;
      goto LABEL_3;
    case 3:
      V_LOCK();
      logfmt_raw(v3, 0x1000u, 0, "SIGQUIT received, exiting");
      V_UNLOCK();
      v1 = 548;
      goto LABEL_3;
    case 10:
      V_LOCK();
      logfmt_raw(v3, 0x1000u, 0, "SIGUSR1 received, reload log");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/god-miner.c",
        139,
        "signal_handler",
        14,
        563,
        80,
        v3);
      return log_reload();
    case 11:
      V_LOCK();
      logfmt_raw(v3, 0x1000u, 0, "SIGSEGV received, exiting");
      V_UNLOCK();
      v1 = 558;
      goto LABEL_3;
    case 15:
      V_LOCK();
      logfmt_raw(v3, 0x1000u, 0, "SIGTERM received, exiting");
      V_UNLOCK();
      v1 = 553;
LABEL_3:
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/god-miner.c",
        139,
        "signal_handler",
        14,
        v1,
        80,
        v3);
      print_summary();
      exit(0);
      return result;
    default:
      V_LOCK();
      logfmt_raw(v3, 0x1000u, 0, "catch signal %d, it should not be here");
      V_UNLOCK();
      return zlog(
               g_zc,
               "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godmin"
               "er-origin_godminer-new/god-miner.c",
               139,
               "signal_handler",
               14,
               567,
               80,
               v3);
  }
}
// 27558: control flows out of bounds to 2755C
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00027788) --------------------------------------------------------
int __fastcall get_currentalgo(char *a1, size_t a2)
{
  return snprintf(a1, a2, "%s", *(const char **)(4 * opt_algo + 912380 + 0x60));
}
// 1063B0: using guessed type int opt_algo;

//----- (000277B0) --------------------------------------------------------
int __fastcall workio_submit_work(int a1, int *a2)
{
  int v4; // r6
  int v5; // r7
  int v6; // r5
  int v8; // r3
  int v9; // [sp+28h] [bp-1428h]
  _DWORD v10[7]; // [sp+30h] [bp-1420h] BYREF
  int v11; // [sp+4Ch] [bp-1404h]
  _DWORD v12[7]; // [sp+50h] [bp-1400h] BYREF
  int v13; // [sp+6Ch] [bp-13E4h]
  char v14[4096]; // [sp+450h] [bp-1000h] BYREF

  v4 = frontend_runtime_instance();
  v5 = pool_tget((int)a2, (unsigned __int8 *)a2 + 1896);
  if ( v5 )
  {
    V_LOCK();
    V_INT((int)v12, "poolno", *a2);
    logfmt_raw(
      v14,
      0x1000u,
      0,
      v13,
      v12[0],
      v12[1],
      v12[2],
      v12[3],
      v12[4],
      v12[5],
      v12[6],
      v13,
      "submit idle pool's nonce.");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/god-miner.c",
      139,
      "workio_submit_work",
      18,
      138,
      20,
      v14);
    return 0;
  }
  else
  {
    update_pool_diff1_of_all_runtimes(a2);
    (*(void (__fastcall **)(int, int *, _DWORD *))(v4 + 28))(a1, a2, v12);
    do
    {
      v6 = (*(int (__fastcall **)(int *, _DWORD *))(v4 + 12))(a2, v12);
      if ( v6 )
        break;
      v8 = total_ro + 1;
      ++a2[486];
      total_ro = v8;
      V_LOCK();
      V_INT((int)v10, "poolno", *a2);
      v9 = v5++;
      logfmt_raw(
        v14,
        0x1000u,
        0,
        v11,
        v10[0],
        v10[1],
        v10[2],
        v10[3],
        v10[4],
        v10[5],
        v10[6],
        v11,
        "submit_upstream_work stratum_send_line failed %d count %d",
        0,
        v9);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/god-miner.c",
        139,
        "workio_submit_work",
        18,
        151,
        100,
        v14);
    }
    while ( v5 != 4 );
    return v6;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;
// 11A7F8: using guessed type int total_ro;

//----- (000279A4) --------------------------------------------------------
void __noreturn nonce_submit_thread()
{
  int v0; // r11
  int *all_created_runtime; // r7
  char *v2; // r4
  int v3; // r0
  pthread_t v4; // r0
  int v5; // r7
  int v6; // r4
  const char *v7; // r0
  double v8; // d7
  double v9; // d5
  double v10; // d7
  __int64 v11; // kr08_8
  int v12; // [sp+14h] [bp-1890h]
  int v13; // [sp+2Ch] [bp-1878h] BYREF
  _QWORD v14[128]; // [sp+30h] [bp-1874h] BYREF
  void *dest[284]; // [sp+430h] [bp-1474h] BYREF
  char v16[4100]; // [sp+8A0h] [bp-1004h] BYREF

  v0 = frontend_runtime_instance();
  all_created_runtime = (int *)get_all_created_runtime(&v13);
  v2 = (char *)calloc(1u, 0x40u);
  snprintf(v2, 0x40u, "%.10s_%d", "nonce_submit_thread", 0);
  V_LOCK();
  v3 = syscall(224);
  logfmt_raw(v16, 0x1000u, 0, "%s on pid %ld", v2, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/god-miner.c",
    139,
    "nonce_submit_thread",
    19,
    301,
    40,
    v16);
  prctl(15, v2);
  v4 = pthread_self();
  pthread_detach(v4);
  v5 = *all_created_runtime;
  while ( 1 )
  {
    while ( 1 )
    {
      (*(void (__fastcall **)(int, _QWORD *))(v5 + 32))(v5, v14);
      if ( v14[0] < (unsigned __int64)total_pools )
      {
        v6 = *(_DWORD *)(pools + 4 * LODWORD(v14[0]));
        if ( v6 )
          break;
      }
      V_LOCK();
      logfmt_raw(v16, 0x1000u, 0, "the pool is NULL");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/god-miner.c",
        139,
        "nonce_submit_thread",
        19,
        316,
        80,
        v16);
    }
    pthread_mutex_lock((pthread_mutex_t *)(v6 + 1584));
    if ( dest[281] )
    {
      free(dest[281]);
      dest[281] = 0;
    }
    memcpy(dest, (const void *)(v6 + 448), sizeof(dest));
    v7 = *(const char **)(v6 + 1572);
    if ( v7 )
      dest[281] = _strdup(v7);
    v12 = (*(int (__fastcall **)(void **, int, _QWORD *))(*(_DWORD *)(v0 + 68) + 8))(dest, v6, v14);
    pthread_mutex_unlock((pthread_mutex_t *)(v6 + 1584));
    if ( v12 == 1 )
    {
      v8 = *(double *)(v6 + 1800);
      v9 = total_diff_stale + v8;
      v10 = *(double *)(v6 + 1808) + v8;
      v11 = *(_QWORD *)&total_stale + 1LL;
      ++*(_DWORD *)(v6 + 1632);
      total_stale = v11;
      total_diff_stale = v9;
      *(double *)(v6 + 1808) = v10;
      dword_11A7DC = HIDWORD(v11);
    }
    else
    {
      workio_submit_work((int)dest, (int *)v6);
    }
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 107BA0: using guessed type int total_pools;
// 107BA4: using guessed type int pools;
// 11A7AC: using guessed type int g_zc;
// 11A7D8: using guessed type int total_stale;
// 11A7DC: using guessed type int dword_11A7DC;
// 11A818: using guessed type double total_diff_stale;

//----- (00027C24) --------------------------------------------------------
int __fastcall update_recorded_timeout_value(unsigned __int64 a1)
{
  int v1; // r3
  unsigned __int64 *v2; // r2
  int v3; // r12
  unsigned __int64 v4; // r6
  unsigned __int64 v5; // r4
  unsigned __int64 v6; // t1
  bool v7; // cf

  v1 = 0;
  v2 = max_timeout_value;
  v3 = 0;
  v4 = -1;
  do
  {
    v6 = *v2++;
    v5 = v6;
    v7 = v6 >= v4;
    if ( v6 < v4 )
      v3 = v1;
    ++v1;
    if ( !v7 )
      v4 = v5;
  }
  while ( v1 != 10 );
  if ( v4 < a1 )
    max_timeout_value[v3] = a1;
  return a1;
}
// 107988: using guessed type _QWORD max_timeout_value[26];

//----- (00027C7C) --------------------------------------------------------
void __fastcall parse_config(_DWORD *a1)
{
  double v1; // d0
  char *v2; // r10
  char **i; // r4
  char *v5; // t1
  _DWORD *v6; // r0
  _DWORD *v7; // r5
  int v8; // r3
  const char *v9; // r0
  char *v10; // r5
  int v11; // r0
  unsigned int j; // r10
  _DWORD *v13; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  v2 = "algo";
  for ( i = &off_DECA8; ; i += 4 )
  {
    v6 = (_DWORD *)json_object_get(a1, v2);
    v7 = v6;
    if ( !v6 )
      goto LABEL_7;
    v8 = *v6;
    if ( i[1] )
      break;
    if ( v8 != 5 )
      goto LABEL_7;
    parse_arg((int)i[3], "");
    if ( &unk_DEDB8 == (_UNKNOWN *)i )
      return;
LABEL_8:
    v5 = i[4];
    v2 = v5;
    if ( !v5 )
      return;
  }
  if ( v8 != 2 )
  {
    switch ( v8 )
    {
      case 3:
        v11 = json_integer_value((int)v6);
        sprintf(s, "%d", v11);
        parse_arg((int)i[3], s);
        break;
      case 4:
        json_real_value();
        sprintf(s, "%f", v1);
        parse_arg((int)i[3], s);
        break;
      case 1:
        for ( j = 0; (unsigned int)json_array_size(v7) > j; ++j )
        {
          v13 = json_array_get(v7, j);
          if ( !v13 )
            break;
          if ( *v13 )
          {
            V_LOCK();
            logfmt_raw(s, 0x1000u, 0, "JSON %s array value invalid", *i);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godmine"
              "r-origin_godminer-new/god-miner.c",
              139,
              "parse_config",
              12,
              509,
              100,
              s);
          }
          else
          {
            parse_config();
          }
        }
        break;
      default:
        V_LOCK();
        logfmt_raw(s, 0x1000u, 0, "JSON option %s invalid", v2);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/god-miner.c",
          139,
          "parse_config",
          12,
          517,
          100,
          s);
        break;
    }
LABEL_7:
    if ( &unk_DEDB8 == (_UNKNOWN *)i )
      return;
    goto LABEL_8;
  }
  v9 = (const char *)json_string_value(v6);
  v10 = _strdup(v9);
  if ( v10 )
  {
    parse_arg((int)i[3], v10);
    free(v10);
    goto LABEL_7;
  }
}
// 27DEC: variable 'v1' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// DECA8: using guessed type char *off_DECA8;
// 11A7AC: using guessed type int g_zc;

//----- (00027EA8) --------------------------------------------------------
int __fastcall parse_arg(int result, char *s)
{
  int v3; // lr
  double *file; // r0
  double *v5; // r5
  int v6; // r2
  int v7; // r5
  int v8; // r2
  int v9; // r0
  int v10; // r1
  const char *v11; // r7
  const char **v12; // r8
  size_t v13; // r6
  int v14; // r5
  const char *v15; // t1
  int v16; // r5
  int v17; // r5
  int v18; // r3
  char *v19; // r4
  unsigned int *v20; // r3
  unsigned int v21; // r2
  unsigned int v22; // r2
  int v23[23]; // [sp+14h] [bp-10FCh] BYREF
  _BYTE v24[160]; // [sp+70h] [bp-10A0h] BYREF
  char v25[4096]; // [sp+110h] [bp-1000h] BYREF

  if ( result == 117 )
  {
    result = set_user(s);
    v16 = result;
    if ( !result )
      return result;
    V_LOCK();
    logfmt_raw(v25, 0x1000u, 0, "%s", v16);
    V_UNLOCK();
    v8 = 405;
    v9 = g_zc;
    LOWORD(v10) = -3308;
    goto LABEL_47;
  }
  if ( result <= 117 )
  {
    if ( result == 99 )
    {
      file = json_load_file(s, 0, (char *)v23);
      v5 = file;
      if ( file && !*(_DWORD *)file )
      {
        parse_config(file);
        if ( *((_DWORD *)v5 + 1) != -1 )
        {
          v20 = (unsigned int *)v5 + 1;
          __dmb(0xBu);
          do
          {
            v21 = __ldrex(v20);
            v22 = v21 - 1;
          }
          while ( __strex(v22, v20) );
          if ( !v22 )
            json_delete(v5);
        }
      }
      else
      {
        if ( v23[0] < 0 )
        {
          V_LOCK();
          logfmt_raw(v25, 0x1000u, 0, "%s", v24);
          V_UNLOCK();
          v6 = 373;
        }
        else
        {
          V_LOCK();
          logfmt_raw(v25, 0x1000u, 0, "%s:%d: %s", s, v23[0], v24);
          V_UNLOCK();
          v6 = 375;
        }
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/god-miner.c",
          139,
          "parse_arg",
          9,
          v6,
          100,
          v25);
      }
      if ( default_config )
      {
        free((void *)default_config);
        default_config = 0;
      }
      result = (int)_strdup(s);
      default_config = result;
      return result;
    }
    if ( result <= 99 )
    {
      switch ( result )
      {
        case 'P':
          opt_protocol = 1;
          break;
        case 'a':
          v11 = "ckb_2040";
          v12 = (const char **)off_DEC60;
          v13 = 8;
          v14 = 0;
          while ( 1 )
          {
            if ( v13 )
            {
              result = strncasecmp(s, v11, v13);
              if ( !result && !s[v13] )
                break;
            }
            if ( ++v14 == 8 )
            {
              V_LOCK();
              logfmt_raw(v25, 0x1000u, 0, "Unknown algo parameter '%s'", s);
              V_UNLOCK();
              v8 = 356;
              v9 = g_zc;
              LOWORD(v10) = -3308;
              goto LABEL_47;
            }
            v15 = *v12++;
            v11 = v15;
            v13 = strlen(v15);
          }
          opt_algo = v14;
          break;
        case 'F':
          fan_pwm_fixed = 1;
          break;
        default:
LABEL_8:
          V_LOCK();
          logfmt_raw(v25, 0x1000u, 0, "unknow config parameter!");
          V_UNLOCK();
          v3 = 471;
          goto LABEL_9;
      }
      return result;
    }
    if ( result == 111 )
    {
      result = set_url(s);
      v7 = result;
      if ( !result )
        return result;
      V_LOCK();
      logfmt_raw(v25, 0x1000u, 0, "%s", v7);
      V_UNLOCK();
      v8 = 413;
      v9 = g_zc;
      LOWORD(v10) = (unsigned __int16)"/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/t"
                                      "mp/release/build/godminer-origin_godminer-new/god-miner.c";
    }
    else
    {
      if ( result != 112 )
      {
        if ( result == 104 )
        {
          V_LOCK();
          logfmt_raw(
            v25,
            0x1000u,
            0,
            "Usage: GODMINER [OPTIONS]\n"
            "Options:\n"
            "  -a, --algo=ALGO       specify the algorithm to use\n"
            "                          eth_1798         ethash\n"
            "                          ckb_2040         eaglesong\n"
            "                          ckb_2042         eaglesong\n"
            "                          kda_2110         blake2s\n"
            "                          dcr_1727         blaker14\n"
            "                          hns_2130         blake2s\n"
            "                          dash_1766        x11\n"
            "  -o, --url=URL         URL of mining server\n"
            "  -u, --user=USERNAME   username for mining server\n"
            "  -p, --pass=PASSWORD   password for mining server\n"
            "  -P, --protocol        verbose dump of protocol-level activities\n"
            "      --api-remote      Allow remote control\n"
            "  -c, --config=FILE     load a JSON-format configuration file\n"
            "  -v, --version         display version information and exit\n"
            "  -F, --bitmain-fan-ctrl  set if fixed fan's pwm\n"
            "      --bitmain-fan-pwm=N set pwm value when fan pwm fixed\n"
            "      --bitmain-freq=N  set working freq\n"
            "      --bitmain-voltage=N  set working power voltage\n"
            "  -z, --zlog=FILE       load a zlog configuration file\n"
            "  -h, --help            display this help text and exit\n");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/god-miner.c",
            139,
            "parse_arg",
            9,
            458,
            40,
            v25);
          exit(0);
        }
        goto LABEL_8;
      }
      result = set_pass(s);
      v17 = result;
      if ( !result )
      {
        if ( *s )
        {
          v18 = (unsigned __int8)s[1];
          *s = 120;
          v19 = s + 1;
          if ( v18 )
          {
            do
              *v19++ = 0;
            while ( *v19 );
          }
        }
        return result;
      }
      V_LOCK();
      logfmt_raw(v25, 0x1000u, 0, "%s", v17);
      V_UNLOCK();
      v8 = 392;
      v9 = g_zc;
      LOWORD(v10) = -3308;
    }
LABEL_47:
    HIWORD(v10) = (unsigned int)"/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/rel"
                                "ease/build/godminer-origin_godminer-new/god-miner.c" >> 16;
    return zlog(v9, v10, 139, "parse_arg", 9, v8, 100, v25);
  }
  if ( result > 1033 )
  {
    if ( result == 1034 )
    {
      result = strtol(s, 0, 10);
      if ( (unsigned int)result > 0x64 )
      {
        V_LOCK();
        logfmt_raw(v25, 0x1000u, 0, "fan_pwm value error!");
        V_UNLOCK();
        v3 = 448;
LABEL_9:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/god-miner.c",
          139,
          "parse_arg",
          9,
          v3,
          100,
          v25);
        exit(1);
      }
      fan_pwm = result;
    }
    else if ( result > 1036 )
    {
      goto LABEL_8;
    }
  }
  else if ( result < 1032 )
  {
    switch ( result )
    {
      case 122:
        if ( opt_zlog_conf_file )
          free((void *)opt_zlog_conf_file);
        result = (int)_strdup(s);
        opt_zlog_conf_file = result;
        break;
      case 1030:
        opt_api_remote = 1;
        break;
      case 118:
        opt_version_path = (int)s;
        break;
      default:
        goto LABEL_8;
    }
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// DEC60: using guessed type char *off_DEC60[8];
// 1063B0: using guessed type int opt_algo;
// 1063FC: using guessed type int fan_pwm;
// 107A58: using guessed type char opt_api_remote;
// 107A5C: using guessed type int opt_version_path;
// 107A60: using guessed type int default_config;
// 107A64: using guessed type char opt_protocol;
// 1088B4: using guessed type char fan_pwm_fixed;
// 11A7A8: using guessed type int opt_zlog_conf_file;
// 11A7AC: using guessed type int g_zc;

//----- (00028480) --------------------------------------------------------
int make_fake_version()
{
  char v1[64]; // [sp+0h] [bp-40h] BYREF

  sprintf(v1, "%s %s", 915164, 915152);
  strcpy(g_miner_compiletime, v1);
  strcpy(g_miner_type, "Antminer unknow");
  return *(_DWORD *)"Antminer unknow";
}

//----- (000284D8) --------------------------------------------------------
int read_version_file()
{
  FILE *v0; // r6
  signed int v1; // r6
  char *v2; // r0
  char *v3; // r7
  char *v4; // r7
  char *v5; // r0
  size_t v6; // r2
  size_t v7; // r0
  int v8; // r3
  size_t v9; // r0
  int v10; // r3
  int *v11; // r5
  char v13[256]; // [sp+10h] [bp-1104h] BYREF
  char v14[4100]; // [sp+110h] [bp-1004h] BYREF

  v0 = (FILE *)fopen64(opt_version_path, "rb");
  memset(v13, 0, sizeof(v13));
  if ( v0 )
  {
    v1 = fread(v13, 1u, 0x100u, v0);
    if ( v1 <= 0 )
    {
      V_LOCK();
      v11 = &g_zc;
      logfmt_raw(v14, 0x1000u, 0, "Read miner version file %s error %d", opt_version_path, v1);
      V_UNLOCK();
      v4 = g_miner_type;
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/god-miner.c",
        139,
        "read_version_file",
        17,
        635,
        100,
        v14);
    }
    else
    {
      v2 = strchr(v13, 10);
      v3 = v2;
      if ( v2 )
      {
        memcpy(g_miner_compiletime, v13, v2 - v13);
        v4 = (char *)stpcpy(v13, v3 + 1);
        v5 = strchr(v13, 10);
        if ( v5 )
          v4 = g_miner_type;
        else
          v6 = v4 - v13;
        if ( v5 )
          v6 = v5 - v13;
        else
          v4 = g_miner_type;
        if ( !v5 )
          ++v6;
        memcpy(v4, v13, v6);
      }
      else
      {
        v4 = g_miner_type;
        strcpy(g_miner_compiletime, v13);
      }
      v7 = strlen(g_miner_compiletime) - 1;
      v8 = *((unsigned __int8 *)&max_timeout_value[28] + v7);
      if ( v8 == 10 )
      {
        *((_BYTE *)&max_timeout_value[28] + v7) = 0;
        v7 = strlen(g_miner_compiletime) - 1;
        v8 = *((unsigned __int8 *)&max_timeout_value[28] + v7);
      }
      if ( v8 == 13 )
        *((_BYTE *)&max_timeout_value[28] + v7) = 0;
      v9 = strlen(g_miner_type) - 1;
      v10 = *((unsigned __int8 *)&max_timeout_value[36] + v9);
      if ( v10 == 10 )
      {
        *((_BYTE *)&max_timeout_value[36] + v9) = 0;
        v9 = strlen(g_miner_type) - 1;
        v10 = *((unsigned __int8 *)&max_timeout_value[36] + v9);
      }
      v11 = &g_zc;
      if ( v10 == 13 )
        *((_BYTE *)&max_timeout_value[36] + v9) = 0;
    }
  }
  else
  {
    V_LOCK();
    v11 = &g_zc;
    logfmt_raw(v14, 0x1000u, 0, "Open miner version file %s error", opt_version_path);
    V_UNLOCK();
    v4 = g_miner_type;
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/god-miner.c",
      139,
      "read_version_file",
      17,
      630,
      100,
      v14);
  }
  V_LOCK();
  logfmt_raw(v14, 0x1000u, 0, "Miner compile time: %s type: %s", g_miner_compiletime, v4);
  V_UNLOCK();
  return zlog(
           *v11,
           "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-o"
           "rigin_godminer-new/god-miner.c",
           139,
           "read_version_file",
           17,
           670,
           60,
           v14);
}
// 28594: variable 'v6' is possibly undefined
// 1E64C: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 1EA0C: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 107988: using guessed type _QWORD max_timeout_value[26];
// 107A5C: using guessed type int opt_version_path;
// 11A7AC: using guessed type int g_zc;

//----- (000287A0) --------------------------------------------------------
int godminer_register_status_monitor()
{
  int v0; // r0
  int v1; // r0

  LOWORD(v0) = 29148;
  HIWORD(v0) = (unsigned int)&loc_2CF0C >> 16;
  add_chip_status_observer(v0);
  LOWORD(v1) = 29592;
  HIWORD(v1) = (unsigned int)&loc_2D1A0 >> 16;
  return add_fanspeed_observer(v1);
}

//----- (000287C0) --------------------------------------------------------
int set_working_voltage_and_runtime_freq()
{
  char v0; // r10
  int working_voltage; // r8
  int current_voltage; // r7
  int result; // r0
  int v4; // r11
  int v5; // r6
  int v6; // r2
  int v7; // r3
  int v8; // r9
  int v9; // r4
  int v10; // r5
  int v11; // r0
  int v12; // t1
  int v13; // r5
  char *v14; // r4
  char *v15; // r9
  int v16; // t1
  int i; // r6
  int v18; // t1
  char *all_created_runtime; // [sp+14h] [bp-1018h]
  int v20; // [sp+18h] [bp-1014h]
  int v21; // [sp+24h] [bp-1008h] BYREF
  char v22[4100]; // [sp+28h] [bp-1004h] BYREF

  v0 = 0;
  working_voltage = get_working_voltage();
  current_voltage = get_current_voltage();
  v21 = 0;
  all_created_runtime = (char *)get_all_created_runtime(&v21);
  result = is_power_init();
  v4 = result;
  if ( result )
  {
    if ( opt_algo == 7 )
    {
      v5 = 0;
      if ( working_voltage < current_voltage )
        v6 = -7;
      else
        v6 = 7;
      v20 = v6;
LABEL_18:
      if ( v21 > 0 )
      {
        v13 = 0;
        v14 = all_created_runtime - 4;
        v15 = all_created_runtime - 4;
        do
        {
          v16 = *((_DWORD *)v15 + 1);
          v15 += 4;
          ++v5;
          v13 |= (*(int (**)(void))(v16 + 172))();
        }
        while ( v21 > v5 );
        v5 = v13 == 0;
        if ( v13 )
        {
          usleep((__useconds_t)&loc_30D40);
          if ( v21 > 0 )
          {
            for ( i = 0; i < v21; ++i )
            {
              v18 = *((_DWORD *)v14 + 1);
              v14 += 4;
              v13 |= (*(int (**)(void))(v18 + 172))();
            }
            v5 = v13 == 0;
          }
        }
      }
      else
      {
        v5 = v4;
      }
      while ( 1 )
      {
        v7 = current_voltage - working_voltage;
        if ( current_voltage - working_voltage < 0 )
          v7 = working_voltage - current_voltage;
        if ( v7 > 7 )
        {
          current_voltage += v20;
          set_voltage(current_voltage, 1);
          if ( working_voltage == current_voltage )
          {
            v8 = v5;
            v0 = v4;
          }
          else
          {
            v8 = (unsigned __int8)(v5 & v0);
          }
        }
        else
        {
          v8 = v5;
          if ( working_voltage == current_voltage )
          {
            current_voltage = working_voltage;
            v0 = v4;
          }
          else
          {
            current_voltage = working_voltage;
            v0 = v4;
            set_voltage(working_voltage, 1);
          }
        }
        v9 = 0;
        *(_DWORD *)v22 = 0;
        result = (int)get_all_created_runtime(v22);
        if ( *(int *)v22 > 0 )
        {
          v10 = result - 4;
          do
          {
            v11 = dev_ctrl(result);
            v12 = *(_DWORD *)(v10 + 4);
            v10 += 4;
            ++v9;
            result = (*(int (__fastcall **)(_DWORD))(v11 + 80))(*(_DWORD *)(v12 + 196));
          }
          while ( v9 < *(int *)v22 );
        }
        if ( v8 )
          break;
        if ( !v5 )
          goto LABEL_18;
      }
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v22, 0x1000u, 0, "%s, power has not init!", "set_working_voltage_and_runtime_freq");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/god-miner.c",
      139,
      "set_working_voltage_and_runtime_freq",
      36,
      827,
      100,
      v22);
    return -1;
  }
  return result;
}
// 28840: conditional instruction was optimized away because r10.4==0
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4AB8C: using guessed type int __fastcall dev_ctrl(_DWORD);
// 1063B0: using guessed type int opt_algo;
// 11A7AC: using guessed type int g_zc;

//----- (00028A20) --------------------------------------------------------
int __fastcall sub_28A20(char *a1, size_t a2, int a3)
{
  if ( freq_scan_status == 1 )
  {
    snprintf(a1, a2, "%d", a3);
    return 0;
  }
  else
  {
    if ( freq_scan_status == 2 )
      snprintf(a1, a2, "%s:%s", "searchfailed", (const char *)search_failed_info);
    else
      snprintf(a1, a2, "searching", a3);
    return 0;
  }
}
// 1063B4: using guessed type int freq_scan_status;
// 11AF68: using guessed type int search_failed_info[64];

//----- (00028AA4) --------------------------------------------------------
int __fastcall get_miner_info(char *a1)
{
  int v1; // r4
  int v3; // r2
  char *v4; // r0
  int v5; // r5
  int v6; // r4
  int v7; // r4
  int v8; // r4
  int v9; // r0
  int v10; // r0
  int v12; // [sp+4h] [bp-4h] BYREF

  v1 = 0;
  v12 = 0;
  get_all_created_runtime(&v12);
  v3 = v12;
  if ( v12 > 0 )
  {
    v5 = 0;
    do
    {
      v6 = sprintf(&a1[v1], "chain%d_voltage=%d;", ++v5, 12) + v1;
      v7 = v6 + sprintf(&a1[v6], "chain%d_voladded=%d;", v5, 0);
      v8 = v7 + sprintf(&a1[v7], "chain%d_basefreq=%d;", v5, 0);
      v9 = sprintf(&a1[v8], "chain%d_badcore=%d;", v5, 0);
      v3 = v12;
      v1 = v8 + v9;
    }
    while ( v5 < v12 );
    v4 = &a1[v1];
  }
  else
  {
    v4 = a1;
  }
  v10 = sprintf(v4, "chainnum=%d;", v3);
  return sprintf(&a1[v10 + v1], "version=%s;", 1079912);
}

//----- (00028B94) --------------------------------------------------------
int get_freq_scan_status()
{
  return freq_scan_status;
}
// 1063B4: using guessed type int freq_scan_status;

//----- (00028BA4) --------------------------------------------------------
int get_miner_sale_hashrate()
{
  int v0; // r4
  char *all_created_runtime; // r0
  double v2; // d8
  char *v3; // r5
  int v4; // r6
  int v5; // t1
  int v6; // r0
  unsigned int v7; // r4
  int v9; // [sp+0h] [bp-28h] BYREF
  unsigned int v10; // [sp+4h] [bp-24h]
  double v11[2]; // [sp+8h] [bp-20h] BYREF
  char v12[12]; // [sp+1Ch] [bp-Ch] BYREF

  v0 = 0;
  v9 = 0;
  all_created_runtime = (char *)get_all_created_runtime(&v9);
  v2 = 0.0;
  v10 = 1;
  v11[0] = 0.0;
  if ( v9 > 0 )
  {
    v3 = all_created_runtime - 4;
    v4 = 0;
    do
    {
      v5 = *((_DWORD *)v3 + 1);
      v3 += 4;
      ++v0;
      v4 |= (*(int (**)(void))(v5 + 124))();
      v2 = v2 + v11[1];
    }
    while ( v9 > v0 );
    if ( v4 )
    {
      freq_scan_status = 2;
      strcpy((char *)search_failed_info, "R:1");
    }
  }
  v6 = frontend_runtime_instance();
  format_hashrate_double(*(_DWORD *)(*(_DWORD *)(v6 + 68) + 12), v11, v12);
  v7 = v10;
  return sub_DCEB0((int)v11[0], v10) * v7;
}
// 1063B4: using guessed type int freq_scan_status;
// 11AF68: using guessed type int search_failed_info[64];

//----- (00028C98) --------------------------------------------------------
int get_miner_qualified_hashrate()
{
  int v0; // r0
  double v1; // d0
  float v2; // s16
  double v3; // d9
  double v6; // [sp+0h] [bp-4Ch] BYREF
  char v7[12]; // [sp+Ch] [bp-40h] BYREF
  _BYTE v8[20]; // [sp+18h] [bp-34h] BYREF
  float v9; // [sp+2Ch] [bp-20h]
  double v10; // [sp+38h] [bp-14h]

  read_system_status_from_monitor((int)v8);
  v0 = frontend_runtime_instance();
  v1 = v10;
  format_hashrate_double(*(_DWORD *)(*(_DWORD *)(v0 + 68) + 12), &v6, v7);
  v2 = v9;
  v3 = v6;
  get_miner_elapsed_time();
  if ( v1 < 1200.0 )
  {
    freq_scan_status = 0;
    return get_miner_sale_hashrate();
  }
  else
  {
    if ( (int)(v2 * v1) < (int)v3 && v1 > 1200.0 )
    {
      freq_scan_status = 2;
      strcpy((char *)search_failed_info, "R:1");
    }
    else
    {
      freq_scan_status = 1;
    }
    return get_miner_sale_hashrate();
  }
}
// 28C98: too many cbuild loops
// 1063B4: using guessed type int freq_scan_status;
// 11AF68: using guessed type int search_failed_info[64];

//----- (00028D98) --------------------------------------------------------
int get_theory_hashrate()
{
  int v0; // r4
  char *all_created_runtime; // r0
  double v2; // d8
  char *v3; // r5
  int v4; // r6
  int v5; // t1
  int v6; // r0
  int v8; // r0
  int v9; // [sp+4h] [bp-2Ch]
  int v10; // [sp+Ch] [bp-24h] BYREF
  double v11[2]; // [sp+10h] [bp-20h] BYREF
  char v12[12]; // [sp+24h] [bp-Ch] BYREF

  v0 = 0;
  v10 = 0;
  all_created_runtime = (char *)get_all_created_runtime(&v10);
  v2 = 0.0;
  v11[0] = 0.0;
  if ( v10 <= 0 )
  {
    v8 = frontend_runtime_instance();
    format_hashrate_double(*(_DWORD *)(*(_DWORD *)(v8 + 68) + 12), v11, v12);
LABEL_5:
    freq_scan_status = 1;
    return (int)v11[0];
  }
  v3 = all_created_runtime - 4;
  v4 = 0;
  do
  {
    v5 = *((_DWORD *)v3 + 1);
    v3 += 4;
    ++v0;
    v4 |= (*(int (**)(void))(v5 + 120))();
    v2 = v2 + v11[1];
  }
  while ( v10 > v0 );
  v6 = frontend_runtime_instance();
  format_hashrate_double(*(_DWORD *)(*(_DWORD *)(v6 + 68) + 12), v11, v12);
  if ( !v4 )
    goto LABEL_5;
  freq_scan_status = 2;
  strcpy((char *)search_failed_info, "R:1");
  return v9;
}
// 28E74: variable 'v9' is possibly undefined
// 1063B4: using guessed type int freq_scan_status;
// 11AF68: using guessed type int search_failed_info[64];

//----- (00028EB0) --------------------------------------------------------
int __fastcall http_test_bm(int a1, char *a2, size_t a3)
{
  const char *v4; // r5
  char *v6; // r4
  int theory_hashrate; // r0
  int miner_qualified_hashrate; // r0
  int v10; // r0
  size_t v11; // r0
  const char *v12; // lr
  char *v13; // r12
  int v14; // r0
  int v15; // r1
  int v16; // r2
  int v17; // r3
  __int16 v18; // r2
  char v19; // r3
  FILE *v20; // r3
  int v21; // [sp+14h] [bp-1020h] BYREF
  int v22; // [sp+18h] [bp-101Ch] BYREF
  _DWORD v23[4]; // [sp+1Ch] [bp-1018h] BYREF
  __int16 v24; // [sp+2Ch] [bp-1008h]
  char v25[4100]; // [sp+30h] [bp-1004h] BYREF

  v4 = (const char *)(a1 + 4);
  v21 = -1;
  v22 = -1;
  v6 = strstr((const char *)(a1 + 4), "/rate");
  if ( v6 )
  {
    V_LOCK();
    v6 = 0;
    logfmt_raw(v25, 0x1000u, 0, "cmd : get rate");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/http_test.c",
      139,
      "http_test_bm",
      12,
      190,
      20,
      v25);
    miner_qualified_hashrate = get_miner_qualified_hashrate();
    sub_28A20(a2, a3, miner_qualified_hashrate);
    return (int)v6;
  }
  if ( strstr(v4, "/test") )
  {
    _isoc99_sscanf(v4, "/test.%d.%d", &v21, &v22);
    V_LOCK();
    logfmt_raw(v25, 0x1000u, 0, "cmd : get test = %d", v21);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/http_test.c",
      139,
      "http_test_bm",
      12,
      197,
      20,
      v25);
    if ( v21 != 523 )
    {
      sprintf(a2, "OK get test=%d", v21);
      return 0;
    }
    get_miner_info(a2);
    return (int)v6;
  }
  v6 = strstr(v4, "/ideal_rate");
  if ( !v6 )
  {
    if ( strstr(v4, "/max_rate") )
    {
      V_LOCK();
      logfmt_raw(v25, 0x1000u, 0, "cmd : get max rate");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/http_test.c",
        139,
        "http_test_bm",
        12,
        217,
        20,
        v25);
      theory_hashrate = get_theory_hashrate();
      sub_28A20(a2, a3, 102 * theory_hashrate / 100);
    }
    else if ( strstr(v4, "/miner_status") )
    {
      V_LOCK();
      v6 = 0;
      logfmt_raw(v25, 0x1000u, 0, "cmd : get miner status");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/http_test.c",
        139,
        "http_test_bm",
        12,
        223,
        20,
        v25);
    }
    else if ( strstr(v4, "/productName") )
    {
      v6 = 0;
      V_LOCK();
      v11 = strlen(g_miner_type);
      logfmt_raw(v25, 0x1000u, 0, "cmd : get miner type[%d] %s", v11, g_miner_type);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/http_test.c",
        139,
        "http_test_bm",
        12,
        228,
        20,
        v25);
      strcpy(a2, g_miner_type);
    }
    else
    {
      v6 = (char *)strncmp(v4, "/get_sn", 7u);
      if ( v6 )
      {
        v6 = (char *)strncmp(v4, "/set_sn", 7u);
        if ( v6 )
        {
          return -1;
        }
        else
        {
          V_LOCK();
          logfmt_raw(v25, 0x1000u, 0, "cmd : set miner sn, doesn't spport");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/http_test.c",
            139,
            "http_test_bm",
            12,
            309,
            80,
            v25);
          v12 = "doesn't support sn set in Release mode";
          v13 = a2;
          do
          {
            v13 += 16;
            v14 = *(_DWORD *)v12;
            v15 = *((_DWORD *)v12 + 1);
            v16 = *((_DWORD *)v12 + 2);
            v17 = *((_DWORD *)v12 + 3);
            v12 += 16;
            *((_DWORD *)v13 - 4) = v14;
            *((_DWORD *)v13 - 3) = v15;
            *((_DWORD *)v13 - 2) = v16;
            *((_DWORD *)v13 - 1) = v17;
          }
          while ( v12 != "e mode" );
          v18 = *((_WORD *)v12 + 2);
          v19 = v12[6];
          *(_DWORD *)v13 = *(_DWORD *)v12;
          *((_WORD *)v13 + 2) = v18;
          v13[6] = v19;
        }
      }
      else
      {
        memset(v23, 0, sizeof(v23));
        v24 = 0;
        V_LOCK();
        logfmt_raw(v25, 0x1000u, 0, "cmd : get miner sn");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/http_test.c",
          139,
          "http_test_bm",
          12,
          236,
          20,
          v25);
        v20 = (FILE *)fopen64(g_miner_sn_file_path, "r");
        if ( v20 && (fread(v23, 0x11u, 1u, v20), LOBYTE(v23[0])) )
          snprintf(a2, 0x12u, "%s", (const char *)v23);
        else
          strcpy(a2, "no miner sn stored on board");
      }
    }
    return (int)v6;
  }
  V_LOCK();
  logfmt_raw(v25, 0x1000u, 0, "cmd : get ideal rate");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/http_test.c",
    139,
    "http_test_bm",
    12,
    211,
    20,
    v25);
  v10 = get_theory_hashrate();
  sub_28A20(a2, a3, v10);
  return 0;
}
// 1E880: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 1EA0C: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10892C: using guessed type int g_miner_sn_file_path;
// 11A7AC: using guessed type int g_zc;

//----- (00029490) --------------------------------------------------------
void http_test_case_init()
{
  http_test_case = http_test_bm;
}
// 11A7A4: using guessed type _UNKNOWN *http_test_case;

//----- (000294A8) --------------------------------------------------------
_DWORD *__fastcall sub_294A8(char *s2)
{
  _DWORD *result; // r0
  char v3[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( dword_107B50[0] > 0x13u )
  {
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, "only support %d reject reasons", dword_107B50[0]);
    V_UNLOCK();
    return (_DWORD *)zlog(
                       g_zc,
                       "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/buil"
                       "d/godminer-origin_godminer-new/pool.c",
                       134,
                       "reject_reason_history_update",
                       28,
                       39,
                       20,
                       v3);
  }
  else
  {
    if ( !dword_107B50[0] )
    {
      V_LOCK();
      logfmt_raw(v3, 0x1000u, 0, "reject reason init %d", dword_107B50[0]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/pool.c",
        134,
        "reject_reason_history_update",
        28,
        44,
        40,
        v3);
      reject_reason_map = 0;
      dword_11B06C = 0;
      dword_11B070 = 0;
      dword_11B074 = 0;
      dword_11B078 = 0;
    }
    result = (_DWORD *)map_get_(&reject_reason_map, s2);
    dword_11B074 = (int)result;
    if ( result )
    {
      ++*result;
    }
    else
    {
      dword_11B078 = 1;
      ++dword_107B50[0];
      return (_DWORD *)map_set_((void **)&reject_reason_map, s2, &dword_11B078, 4u);
    }
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 107B50: using guessed type int dword_107B50[];
// 11A7AC: using guessed type int g_zc;
// 11B068: using guessed type int reject_reason_map;
// 11B06C: using guessed type int dword_11B06C;
// 11B070: using guessed type int dword_11B070;
// 11B074: using guessed type int dword_11B074;
// 11B078: using guessed type int dword_11B078;

//----- (00029644) --------------------------------------------------------
bool __fastcall sub_29644(void **a1, _BYTE *a2, char *haystack)
{
  char *v6; // r0
  const char *v7; // r6
  char *v8; // r5
  _BOOL4 result; // r0
  int v10; // r5
  size_t v11; // r0
  char *v12; // r0
  char v13[4096]; // [sp+10h] [bp-1000h] BYREF

  v6 = strstr(haystack, "://");
  if ( v6 )
  {
    v7 = v6 + 3;
    if ( haystack != v6 + 3 )
    {
      if ( strncasecmp(haystack, "http://", 7u)
        && strncasecmp(haystack, "https://", 8u)
        && strncasecmp(haystack, "stratum+tcp://", 0xEu) )
      {
        V_LOCK();
        logfmt_raw(v13, 0x1000u, 0, "unknown protocol -- '%s'\n", haystack);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/pool.c",
          134,
          "setup_url",
          9,
          173,
          100,
          v13);
      }
      if ( *a1 )
        free(*a1);
      v8 = _strdup(haystack);
      *a1 = v8;
      strcpy(&v8[v7 - haystack], v7);
      goto LABEL_10;
    }
  }
  else
  {
    v7 = haystack;
  }
  v10 = *(unsigned __int8 *)v7;
  if ( *v7 )
  {
    if ( *a1 )
      free(*a1);
    v11 = strlen(v7);
    v12 = (char *)malloc(v11 + 128);
    *a1 = v12;
    sprintf(v12, "stratum+tcp://%s", v7);
    v8 = (char *)*a1;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v13, 0x1000u, v10, "invalid URL -- '%s'\n", haystack);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/pool.c",
      134,
      "setup_url",
      9,
      182,
      100,
      v13);
    if ( *a1 )
      free(*a1);
    v8 = (char *)calloc(1u, 1u);
    *a1 = v8;
  }
LABEL_10:
  result = strncasecmp(v8, "stratum", 7u) == 0;
  *a2 = result;
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00029870) --------------------------------------------------------
int *__fastcall sub_29870(int *a1, char a2)
{
  int *result; // r0
  int v5; // r1
  int *v6; // r2
  int v7; // t1
  int v8; // [sp+4h] [bp-8h] BYREF

  v8 = 0;
  result = (int *)get_all_created_runtime(&v8);
  if ( v8 > 0 )
  {
    v5 = *a1;
    v6 = &result[v8];
    do
    {
      v7 = *result++;
      *(_BYTE *)(v7 + v5 + 472) = a2;
    }
    while ( result != v6 );
  }
  return result;
}

//----- (000298C4) --------------------------------------------------------
int sub_298C4()
{
  char v1[4096]; // [sp+10h] [bp-1000h] BYREF

  V_LOCK();
  logfmt_raw(v1, 0x1000u, 0, "stratum thread create failed");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/pool.c",
    134,
    "create_pool_stratum_threads",
    27,
    568,
    100,
    v1);
  return -1;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00029944) --------------------------------------------------------
int get_current_pool()
{
  int v0; // r4

  pthread_mutex_lock(&mutex);
  v0 = dword_107B6C;
  pthread_mutex_unlock(&mutex);
  return v0;
}
// 107B6C: using guessed type int dword_107B6C;

//----- (00029970) --------------------------------------------------------
bool __fastcall current_pool_changed(int a1)
{
  int v2; // r4

  pthread_mutex_lock(&mutex);
  v2 = dword_107B6C;
  pthread_mutex_unlock(&mutex);
  return a1 != v2;
}
// 107B6C: using guessed type int dword_107B6C;

//----- (000299A4) --------------------------------------------------------
int __fastcall wait_pool_to_be_current(int a1)
{
  pthread_mutex_lock(&mutex);
  while ( dword_107B6C != a1 )
    pthread_cond_wait(&cond, &mutex);
  return pthread_mutex_unlock(&mutex);
}
// 107B6C: using guessed type int dword_107B6C;

//----- (000299F8) --------------------------------------------------------
int __fastcall wait_pool_to_be_current_timeout(int a1)
{
  struct timespec v3; // [sp+0h] [bp-14h] BYREF
  struct timespec tp; // [sp+8h] [bp-Ch] BYREF

  clock_gettime(1, &tp);
  v3.tv_sec = tp.tv_sec + (tp.tv_nsec + 1000) / 1000000000;
  v3.tv_nsec = (tp.tv_nsec + 1000) % 1000000000;
  pthread_mutex_lock(&mutex);
  if ( dword_107B6C != a1 )
    pthread_cond_timedwait(&cond, &mutex, &v3);
  return pthread_mutex_unlock(&mutex);
}
// 107B6C: using guessed type int dword_107B6C;

//----- (00029A84) --------------------------------------------------------
int __fastcall set_current_pool(int a1)
{
  pthread_mutex_lock(&mutex);
  dword_107B6C = a1;
  pthread_cond_broadcast(&cond);
  return pthread_mutex_unlock(&mutex);
}
// 107B6C: using guessed type int dword_107B6C;

//----- (00029AB8) --------------------------------------------------------
char *add_pool()
{
  char *v0; // r4
  int v1; // r3
  void *v2; // r0
  int v3; // r1
  _DWORD *v4; // r0
  int v5; // r2
  char v7[4100]; // [sp+10h] [bp-1004h] BYREF

  v0 = (char *)calloc(0x7C8u, 1u);
  if ( !v0 )
  {
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, "Failed to malloc pool in add_pool");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/pool.c",
      134,
      "add_pool",
      8,
      121,
      100,
      v7);
    exit(1);
  }
  v1 = total_pools;
  v2 = (void *)pools;
  v3 = total_pools + 2;
  *((_DWORD *)v0 + 1) = total_pools;
  *(_DWORD *)v0 = v1;
  v4 = realloc(v2, 4 * v3);
  v5 = total_pools;
  pools = (int)v4;
  ++total_pools;
  v4[v5] = v0;
  *((_DWORD *)v0 + 8) = -1;
  *((_DWORD *)v0 + 10) = 0;
  v0[1640] = 0;
  v0[1648] = 0;
  *((_DWORD *)v0 + 435) = 0;
  *((_DWORD *)v0 + 437) = 0;
  v0[24] = 1;
  *((_QWORD *)v0 + 220) = 0;
  *((_DWORD *)v0 + 442) = 0;
  memset(v0 + 1676, 0, 0x40u);
  *((_QWORD *)v0 + 225) = 0;
  pthread_mutex_init((pthread_mutex_t *)v0 + 66, 0);
  pthread_mutex_init((pthread_mutex_t *)(v0 + 1816), 0);
  pthread_condattr_init((pthread_condattr_t *)v0 + 460);
  pthread_condattr_setclock((pthread_condattr_t *)v0 + 460, 1);
  pthread_cond_init((pthread_cond_t *)(v0 + 1848), (const pthread_condattr_t *)v0 + 460);
  pthread_mutex_init((pthread_mutex_t *)(v0 + 44), 0);
  pthread_mutex_init((pthread_mutex_t *)v0 + 66, 0);
  pthread_mutex_init((pthread_mutex_t *)(v0 + 1772), 0);
  pthread_mutex_init((pthread_mutex_t *)(v0 + 1652), 0);
  v0[1896] = 1;
  v0[1908] = 0;
  *((_DWORD *)v0 + 475) = -1;
  return v0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 107BA0: using guessed type int total_pools;
// 107BA4: using guessed type int pools;
// 11A7AC: using guessed type int g_zc;

//----- (00029C74) --------------------------------------------------------
int sub_29C74()
{
  int v0; // r3

  v0 = ++dword_107BA8;
  if ( dword_107BA8 > total_pools )
  {
    add_pool();
    v0 = dword_107BA8;
  }
  return *(_DWORD *)(pools + 4 * (v0 + 0x3FFFFFFF));
}
// 107BA0: using guessed type int total_pools;
// 107BA4: using guessed type int pools;
// 107BA8: using guessed type int dword_107BA8;

//----- (00029CB0) --------------------------------------------------------
int __fastcall set_url(char *a1)
{
  int v2; // r0

  v2 = sub_29C74();
  sub_29644((void **)(v2 + 8), (_BYTE *)(v2 + 24), a1);
  return 0;
}

//----- (00029CD4) --------------------------------------------------------
int __fastcall set_user(char *s)
{
  int v2; // r3
  int v3; // r4
  void *v4; // r0

  v2 = ++dword_107BAC;
  if ( dword_107BAC > total_pools )
  {
    add_pool();
    v2 = dword_107BAC;
  }
  v3 = *(_DWORD *)(pools + 4 * (v2 + 0x3FFFFFFF));
  v4 = *(void **)(v3 + 12);
  if ( v4 )
    free(v4);
  *(_DWORD *)(v3 + 12) = _strdup(s);
  return 0;
}
// 107BA0: using guessed type int total_pools;
// 107BA4: using guessed type int pools;
// 107BAC: using guessed type int dword_107BAC;

//----- (00029D38) --------------------------------------------------------
int __fastcall set_pass(char *s)
{
  int v2; // r3
  int v3; // r4
  void *v4; // r0

  v2 = ++dword_107BB0;
  if ( dword_107BB0 > total_pools )
  {
    add_pool();
    v2 = dword_107BB0;
  }
  v3 = *(_DWORD *)(pools + 4 * (v2 + 0x3FFFFFFF));
  v4 = *(void **)(v3 + 16);
  if ( v4 )
    free(v4);
  *(_DWORD *)(v3 + 16) = _strdup(s);
  return 0;
}
// 107BA0: using guessed type int total_pools;
// 107BA4: using guessed type int pools;
// 107BB0: using guessed type int dword_107BB0;

//----- (00029D9C) --------------------------------------------------------
int __fastcall pool_tset(int a1, _BYTE *a2, int a3)
{
  pthread_mutex_t *v3; // r4
  bool v7; // zf
  int v8; // r7

  v3 = (pthread_mutex_t *)(a1 + 1816);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1816));
  v7 = a3 == 0;
  v8 = (unsigned __int8)*a2;
  *a2 = 1;
  if ( !v7 )
    pthread_cond_broadcast((pthread_cond_t *)(a1 + 1848));
  pthread_mutex_unlock(v3);
  return v8;
}

//----- (00029DEC) --------------------------------------------------------
int __fastcall pool_tclear(int a1, _BYTE *a2, int a3)
{
  pthread_mutex_t *v3; // r4
  bool v7; // zf
  int v8; // r7

  v3 = (pthread_mutex_t *)(a1 + 1816);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1816));
  v7 = a3 == 0;
  v8 = (unsigned __int8)*a2;
  *a2 = 0;
  if ( !v7 )
    pthread_cond_broadcast((pthread_cond_t *)(a1 + 1848));
  pthread_mutex_unlock(v3);
  return v8;
}

//----- (00029E3C) --------------------------------------------------------
int __fastcall pool_tget(int a1, unsigned __int8 *a2)
{
  pthread_mutex_t *v2; // r4
  pthread_mutex_t *v4; // r0
  int v5; // r4

  v2 = (pthread_mutex_t *)(a1 + 1816);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1816));
  v4 = v2;
  v5 = *a2;
  pthread_mutex_unlock(v4);
  return v5;
}

//----- (00029E68) --------------------------------------------------------
int __fastcall pool_twait_to_be_expected_and_set(int a1, _BYTE *a2, int a3, char a4, const struct timespec *a5)
{
  pthread_mutex_t *v5; // r4
  int v9; // r11
  int v10; // r0
  int v12; // r11
  pthread_cond_t *v13; // r9
  int v14; // r0

  v5 = (pthread_mutex_t *)(a1 + 1816);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1816));
  if ( a5 )
  {
    while ( 2 )
    {
      v9 = 0;
      do
      {
        if ( (unsigned __int8)*a2 == a3 )
        {
          if ( v9 )
            goto LABEL_8;
          goto LABEL_7;
        }
        v10 = pthread_cond_timedwait((pthread_cond_t *)(a1 + 1848), v5, a5);
        v9 = v10;
        if ( v10 == 110 )
          goto LABEL_8;
      }
      while ( v10 );
      pthread_mutex_lock(&mutex);
      v12 = dword_107B6C;
      pthread_mutex_unlock(&mutex);
      if ( a1 == v12 )
        continue;
      break;
    }
    v9 = 1;
  }
  else
  {
    if ( (unsigned __int8)*a2 == a3 )
      goto LABEL_7;
    v13 = (pthread_cond_t *)(a1 + 1848);
    do
    {
      v14 = pthread_cond_wait(v13, v5);
      v9 = v14;
    }
    while ( (unsigned __int8)*a2 != a3 );
    if ( !v14 )
    {
LABEL_7:
      v9 = 0;
      *a2 = a4;
    }
  }
LABEL_8:
  pthread_mutex_unlock(v5);
  return v9;
}
// 107B6C: using guessed type int dword_107B6C;

//----- (00029F70) --------------------------------------------------------
int switch_pools()
{
  char *v0; // r8
  int v1; // r6
  _DWORD *v2; // r7
  int v3; // r12
  int v4; // r4
  int v5; // r3
  int v6; // r2
  int *v7; // r11
  int *v8; // t1
  int v9; // r9
  _DWORD *v10; // r4
  int result; // r0
  int v12; // [sp+14h] [bp-1010h]
  char v13[4100]; // [sp+20h] [bp-1004h] BYREF

  pthread_mutex_lock(&mutex);
  v1 = dword_107B6C;
  v2 = (_DWORD *)(unsigned __int16)&g_zc;
  v3 = total_pools;
  if ( total_pools <= 0 )
  {
    v0 = v13;
    HIWORD(v2) = (unsigned int)&g_zc >> 16;
  }
  v12 = *(_DWORD *)dword_107B6C;
  if ( total_pools > 0 )
  {
    HIWORD(v2) = 17;
    v4 = 0;
    v0 = v13;
    while ( 1 )
    {
      v5 = 0;
      v6 = pools - 4;
      while ( 1 )
      {
        v8 = *(int **)(v6 + 4);
        v6 += 4;
        v7 = v8;
        ++v5;
        if ( v8[1] == v4 )
          break;
        if ( v3 <= v5 )
        {
          V_LOCK();
          logfmt_raw(v13, 0x1000u, 0, "WTF No pool %d found!", v4);
          V_UNLOCK();
          zlog(
            *v2,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/pool.c",
            134,
            "priority_pool",
            13,
            249,
            100,
            v13);
          v7 = *(int **)(pools + 4 * v4);
          break;
        }
      }
      pthread_mutex_lock((pthread_mutex_t *)(v7 + 454));
      v9 = *((unsigned __int8 *)v7 + 1896);
      pthread_mutex_unlock((pthread_mutex_t *)(v7 + 454));
      if ( !v9 )
        break;
      v3 = total_pools;
      if ( total_pools <= ++v4 )
        goto LABEL_11;
    }
    v12 = *v7;
  }
LABEL_11:
  v10 = *(_DWORD **)(pools + 4 * v12);
  pthread_mutex_unlock(&mutex);
  set_current_pool((int)v10);
  V_LOCK();
  logfmt_raw(v0, 0x1000u, 0, "Switching pool %d to pool %d", *(_DWORD *)v1, *v10);
  V_UNLOCK();
  result = zlog(
             *v2,
             "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer"
             "-origin_godminer-new/pool.c",
             134,
             "switch_pools",
             12,
             361,
             40,
             v0);
  if ( (_DWORD *)v1 != v10 )
  {
    pthread_mutex_lock((pthread_mutex_t *)(v1 + 1816));
    pthread_cond_broadcast((pthread_cond_t *)(v1 + 1848));
    return pthread_mutex_unlock((pthread_mutex_t *)(v1 + 1816));
  }
  return result;
}
// 2A0C0: variable 'v0' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 107B6C: using guessed type int dword_107B6C;
// 107BA0: using guessed type int total_pools;
// 107BA4: using guessed type int pools;
// 11A7AC: using guessed type int g_zc;

//----- (0002A150) --------------------------------------------------------
int *__fastcall pool_alive(int a1)
{
  pthread_mutex_t *v1; // r4
  int v3; // r7
  int *result; // r0

  v1 = (pthread_mutex_t *)(a1 + 1816);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1816));
  v3 = *(unsigned __int8 *)(a1 + 1896);
  *(_BYTE *)(a1 + 1896) = 0;
  result = (int *)pthread_mutex_unlock(v1);
  if ( v3 )
    return sub_29870((int *)a1, 0);
  return result;
}

//----- (0002A194) --------------------------------------------------------
int __fastcall pool_died(int *a1)
{
  pthread_mutex_t *v1; // r5
  int v3; // r6
  int result; // r0
  int v5; // r7
  _DWORD v6[7]; // [sp+28h] [bp-1044h] BYREF
  int v7; // [sp+44h] [bp-1028h]
  _DWORD v8[7]; // [sp+48h] [bp-1024h] BYREF
  int v9; // [sp+64h] [bp-1008h]
  char v10[4100]; // [sp+68h] [bp-1004h] BYREF

  v1 = (pthread_mutex_t *)(a1 + 454);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 454));
  v3 = *((unsigned __int8 *)a1 + 1896);
  *((_BYTE *)a1 + 1896) = 1;
  result = pthread_mutex_unlock(v1);
  if ( !v3 )
  {
    cgtime((struct timeval *)(a1 + 475));
    sub_29870(a1, 1);
    pthread_mutex_lock(&mutex);
    v5 = dword_107B6C;
    pthread_mutex_unlock(&mutex);
    V_LOCK();
    if ( a1 == (int *)v5 )
    {
      V_INT((int)v6, "poolno", *a1);
      logfmt_raw(v10, 0x1000u, 0, v7, v6[0], v6[1], v6[2], v6[3], v6[4], v6[5], v6[6], v7, "not responding!");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/pool.c",
        134,
        "pool_died",
        9,
        399,
        80,
        v10);
      return switch_pools();
    }
    else
    {
      V_INT((int)v8, "poolno", *a1);
      logfmt_raw(v10, 0x1000u, 0, v9, v8[0], v8[1], v8[2], v8[3], v8[4], v8[5], v8[6], v9, "failed to return work");
      V_UNLOCK();
      return zlog(
               g_zc,
               "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godmin"
               "er-origin_godminer-new/pool.c",
               134,
               "pool_died",
               9,
               402,
               20,
               v10);
    }
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 107B6C: using guessed type int dword_107B6C;
// 11A7AC: using guessed type int g_zc;

//----- (0002A360) --------------------------------------------------------
int check_pool_worker()
{
  int v0; // r4
  int v1; // r6
  int v2; // r3
  _BYTE *v3; // r3
  int v4; // r10
  char v6[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( total_pools <= 0 )
    goto LABEL_10;
  v0 = 0;
  v1 = 0;
  do
  {
    while ( 1 )
    {
      v2 = *(_DWORD *)(pools + 4 * v0);
      if ( **(_BYTE **)(v2 + 8) )
        break;
LABEL_3:
      if ( total_pools <= ++v0 )
        goto LABEL_8;
    }
    v3 = *(_BYTE **)(v2 + 12);
    v4 = (unsigned __int8)*v3;
    if ( *v3 )
    {
      ++v1;
      goto LABEL_3;
    }
    ++v0;
    V_LOCK();
    logfmt_raw(v6, 0x1000u, v4, "Blank worker exists.");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/pool.c",
      134,
      "check_pool_worker",
      17,
      416,
      100,
      v6);
  }
  while ( total_pools > v0 );
LABEL_8:
  if ( v1 )
    return 0;
LABEL_10:
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "No valid pools, please configure them first!");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/pool.c",
    134,
    "check_pool_worker",
    17,
    422,
    100,
    v6);
  return -1;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 107BA0: using guessed type int total_pools;
// 107BA4: using guessed type int pools;
// 11A7AC: using guessed type int g_zc;

//----- (0002A4CC) --------------------------------------------------------
int __fastcall share_result(int a1, int a2, char *a3, double *a4)
{
  double v7; // d5
  double v8; // d7
  int v9; // r2
  __int64 v10; // kr10_8
  int v11; // r1
  int v12; // r2
  double v14; // d5
  __int64 v15; // r2
  double v16; // d7
  double v17; // d6
  time_t v18; // r0
  __int64 v19; // r6
  _DWORD v20[7]; // [sp+28h] [bp-1044h] BYREF
  int v21; // [sp+44h] [bp-1028h]
  _DWORD v22[7]; // [sp+48h] [bp-1024h] BYREF
  int v23; // [sp+64h] [bp-1008h]
  char v24[4100]; // [sp+68h] [bp-1004h] BYREF

  pthread_mutex_lock(&stru_107BB4);
  if ( a1 )
  {
    v14 = a4[225];
    LODWORD(v15) = *((_DWORD *)a4 + 480);
    v16 = a4[244] + v14;
    ++total_accepted;
    HIDWORD(v15) = *((_DWORD *)a4 + 481);
    v17 = total_diff_accepted + v14;
    *((_QWORD *)a4 + 240) = v15 + 1;
    a4[244] = v16;
    total_diff_accepted = v17;
    v18 = time(0);
    v19 = *((_QWORD *)a4 + 225);
    *((_DWORD *)a4 + 402) = v18;
    *((_QWORD *)a4 + 202) = v19;
    pthread_mutex_unlock(&stru_107BB4);
    return 1;
  }
  else
  {
    v7 = a4[225];
    v8 = total_diff_rejected + v7;
    v9 = total_rejected;
    v10 = *((_QWORD *)a4 + 241) + 1LL;
    a4[245] = a4[245] + v7;
    *((_DWORD *)a4 + 482) = v10;
    v11 = dword_11A82C;
    total_diff_rejected = v8;
    *((_DWORD *)a4 + 483) = HIDWORD(v10);
    *(_QWORD *)&total_rejected = __PAIR64__(v11, v9) + 1;
    pthread_mutex_unlock(&stru_107BB4);
    if ( a3 )
    {
      sub_294A8(a3);
      V_LOCK();
      V_INT((int)v20, "poolno", *(int *)a4);
      logfmt_raw(
        v24,
        0x1000u,
        0,
        v21,
        v20[0],
        v20[1],
        v20[2],
        v20[3],
        v20[4],
        v20[5],
        v20[6],
        v21,
        "reject reason: %s",
        a3);
      V_UNLOCK();
      v12 = 523;
    }
    else
    {
      sub_294A8("NULL");
      V_LOCK();
      V_INT((int)v22, "poolno", *(int *)a4);
      logfmt_raw(
        v24,
        0x1000u,
        0,
        v23,
        v22[0],
        v22[1],
        v22[2],
        v22[3],
        v22[4],
        v22[5],
        v22[6],
        v23,
        "reject reason:: NULL");
      V_UNLOCK();
      v12 = 526;
    }
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/pool.c",
      134,
      "share_result",
      12,
      v12,
      80,
      v24);
    return 1;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;
// 11A7E0: using guessed type double total_diff_accepted;
// 11A7F0: using guessed type double total_diff_rejected;
// 11A808: using guessed type __int64 total_accepted;
// 11A828: using guessed type int total_rejected;
// 11A82C: using guessed type int dword_11A82C;

//----- (0002A730) --------------------------------------------------------
__int64 *__fastcall update_pool_diff1_of_all_runtimes(int *a1)
{
  int *all_created_runtime; // r0
  int v3; // r6
  __int64 v4; // r2
  int *v5; // r5
  int v6; // lr
  unsigned int v7; // r12
  int v8; // t1
  unsigned int v10; // lr
  unsigned int v11; // r1
  unsigned int v12; // r5
  unsigned __int64 v13; // kr10_8
  int v14; // r3
  int v15; // r12
  int v16; // [sp+4h] [bp-4h] BYREF

  v16 = 0;
  all_created_runtime = (int *)get_all_created_runtime(&v16);
  v3 = *a1;
  if ( v16 <= 0 )
  {
    LODWORD(v4) = 0;
    v7 = 0;
  }
  else
  {
    LODWORD(v4) = 0;
    v5 = &all_created_runtime[v16];
    v6 = 8 * (v3 + 63);
    v7 = 0;
    do
    {
      v8 = *all_created_runtime++;
      HIDWORD(v4) = *(_DWORD *)(v8 + v6 + 4);
      v7 = (v4 + __PAIR64__(v7, *(_DWORD *)(v8 + v6))) >> 32;
      LODWORD(v4) = v4 + *(_DWORD *)(v8 + v6);
    }
    while ( v5 != all_created_runtime );
  }
  HIDWORD(v4) = &dword_107B50[2 * v3];
  v10 = total_diff1;
  v11 = *(_DWORD *)(HIDWORD(v4) + 128);
  v12 = *(_DWORD *)(HIDWORD(v4) + 132);
  *(_DWORD *)(HIDWORD(v4) + 128) = v4;
  *(_DWORD *)(HIDWORD(v4) + 132) = v7;
  v13 = __PAIR64__(v7, v4) - __PAIR64__(v12, v11);
  v14 = a1[496];
  v15 = a1[497];
  total_diff1 = __PAIR64__(HIDWORD(total_diff1), v10) + v13;
  a1[496] = v14 + v13;
  a1[497] = HIDWORD(v13) + __CFADD__(v14, (_DWORD)v13) + v15;
  return &total_diff1;
}
// 107B50: using guessed type int dword_107B50[];
// 11A830: using guessed type __int64 total_diff1;

//----- (0002A804) --------------------------------------------------------
int create_pool_stratum_threads()
{
  int v0; // r5
  int v1; // r4
  int v2; // r7
  char *v3; // r0
  int v4; // r7

  set_current_pool(*(_DWORD *)pools);
  if ( total_pools <= 0 )
    return 0;
  v0 = 1157192;
  v1 = 0;
  while ( 1 )
  {
    v2 = *(_DWORD *)(pools + 4 * v1);
    if ( !*(_BYTE *)(v2 + 24) )
      goto LABEL_3;
    *(_DWORD *)v0 = v1 + 4;
    v3 = tq_new();
    *(_DWORD *)(v0 + 44) = v3;
    if ( !v3 )
      return -1;
    tq_push((int)v3, v2);
    pthread_attr_init((pthread_attr_t *)(v0 + 8));
    v4 = pthread_create(
           (pthread_t *)(v0 + 4),
           (const pthread_attr_t *)(v0 + 8),
           (void *(*)(void *))stratum_thread,
           (void *)v0);
    pthread_attr_destroy((pthread_attr_t *)(v0 + 8));
    if ( v4 )
      return sub_298C4();
LABEL_3:
    ++v1;
    v0 += 48;
    if ( total_pools <= v1 )
      return 0;
  }
}
// 2C1A8: using guessed type int stratum_thread();
// 107BA0: using guessed type int total_pools;
// 107BA4: using guessed type int pools;

//----- (0002A8D4) --------------------------------------------------------
void sub_2A8D4()
{
  pthread_t v0; // r0
  int v1; // r6
  _DWORD *v2; // r8
  char *v3; // r6
  int v4; // r8
  int v5; // r0
  char *v6; // r0
  int v7; // r6
  _DWORD *v8; // r8
  int **v9; // r6
  char *v10; // r9
  pthread_t v11; // r0
  int *v12; // r7
  char *v13; // r0
  int v14; // r10
  int v15; // lr
  int *v16; // r2
  int v17; // r12
  int v18; // r1
  int v19; // t1
  int v20; // r3
  int v21; // r3
  _DWORD *v22; // r2
  _DWORD *v23; // r1
  int *all_created_runtime; // r0
  int *v25; // r12
  int v26; // t1
  int v27; // r3
  int v28; // r2
  int v29; // r6
  _DWORD *v30; // r8
  int v31; // r6
  int v32; // r3
  int v33; // r6
  int v34; // r6
  void **v35; // r6
  void *v36; // r0
  void *v37; // t1
  _DWORD *v38; // r8
  int v39; // [sp+10h] [bp-1094h]
  int v40; // [sp+14h] [bp-1090h]
  _DWORD v41[32]; // [sp+20h] [bp-1084h] BYREF
  _DWORD v42[1025]; // [sp+A0h] [bp-1004h] BYREF

  v39 = total_pools;
  V_LOCK();
  logfmt_raw((char *)v42, 0x1000u, 0, "pool_change_function");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/pool.c",
    134,
    "pool_change_function",
    20,
    717,
    20,
    v42);
  v0 = pthread_self();
  pthread_detach(v0);
  if ( dword_11AEAC )
  {
    v40 = 1;
    pthread_cancel(dword_11AEAC);
    dword_11AEAC = 0;
    usleep((__useconds_t)"rl_kda_2110");
  }
  else
  {
    v40 = 0;
  }
  if ( v39 > 0 )
  {
    v1 = 0;
    do
    {
      v2 = *(_DWORD **)(pools + 4 * v1++);
      V_LOCK();
      logfmt_raw((char *)v42, 0x1000u, 0, "before add pool, pool->pool_no = %d, pool->rpc_url = %s", *v2, v2[2]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/pool.c",
        134,
        "pool_change_function",
        20,
        733,
        20,
        v42);
    }
    while ( v39 != v1 );
  }
  if ( dword_107CD0 > 0 )
  {
    v3 = (char *)&unk_107CD4;
    v4 = 0;
    do
    {
      v5 = sub_29C74();
      ++v4;
      sub_29644((void **)(v5 + 8), (_BYTE *)(v5 + 24), v3);
      set_user(v3 + 256);
      v6 = v3 + 512;
      v3 += 768;
      set_pass(v6);
    }
    while ( dword_107CD0 > v4 );
  }
  if ( total_pools == v39 )
  {
    V_LOCK();
    logfmt_raw((char *)v42, 0x1000u, 0, "Input pool error, try again");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/pool.c",
      134,
      "pool_change_function",
      20,
      743,
      100,
      v42);
  }
  else
  {
    V_LOCK();
    logfmt_raw((char *)v42, 0x1000u, 0, "total_pools = %d, need to remove %d pools", total_pools, v39);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/pool.c",
      134,
      "pool_change_function",
      20,
      747,
      20,
      v42);
    if ( total_pools > 0 )
    {
      v7 = 0;
      do
      {
        v8 = *(_DWORD **)(pools + 4 * v7++);
        V_LOCK();
        logfmt_raw((char *)v42, 0x1000u, 0, "after add pool, pool->pool_no = %d, pool->rpc_url = %s", *v8, v8[2]);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/pool.c",
          134,
          "pool_change_function",
          20,
          750,
          20,
          v42);
      }
      while ( total_pools > v7 );
    }
    if ( v39 > 0 )
    {
      v9 = (int **)v41;
      v10 = (char *)&stratum_thr_info;
      do
      {
        v11 = *((_DWORD *)v10 + 1);
        v12 = *(int **)pools;
        if ( v11 )
        {
          pthread_cancel(v11);
          *((_DWORD *)v10 + 1) = 0;
        }
        v13 = (char *)*((_DWORD *)v10 + 11);
        if ( v13 )
        {
          tq_free(v13);
          *((_DWORD *)v10 + 11) = 0;
        }
        pthread_mutex_lock((pthread_mutex_t *)(v12 + 454));
        *((_BYTE *)v12 + 1908) = 0;
        pthread_mutex_unlock((pthread_mutex_t *)(v12 + 454));
        pthread_mutex_lock((pthread_mutex_t *)(v12 + 454));
        *((_BYTE *)v12 + 1896) = 1;
        pthread_mutex_unlock((pthread_mutex_t *)(v12 + 454));
        v14 = total_pools;
        v15 = total_pools - 1;
        --dword_107BB0;
        --dword_107BAC;
        --dword_107BA8;
        if ( total_pools > 0 )
        {
          v16 = (int *)pools;
          v17 = pools + 4 * total_pools;
          do
          {
            v19 = *v16++;
            v18 = v19;
            v20 = *(_DWORD *)(v19 + 4);
            if ( v20 > v12[1] )
              *(_DWORD *)(v18 + 4) = v20 - 1;
          }
          while ( (int *)v17 != v16 );
        }
        v21 = *v12;
        if ( v15 > *v12 )
        {
          v22 = (_DWORD *)(pools + 4 * v21);
          do
          {
            v23 = (_DWORD *)v22[1];
            *v22++ = v23;
            *v23 = v21++;
          }
          while ( v21 != v15 );
        }
        *v9++ = v12;
        *v12 = v14;
        v10 += 48;
        total_pools = v14 - 1;
      }
      while ( v9 != &v41[v39] );
    }
    v42[0] = 0;
    all_created_runtime = (int *)get_all_created_runtime(v42);
    if ( v42[0] > 0 )
    {
      v25 = &all_created_runtime[v42[0]];
      do
      {
        v26 = *all_created_runtime++;
        v27 = v26 + 471;
        v28 = v26 + 503;
        do
          *(_BYTE *)++v27 = 1;
        while ( v28 != v27 );
      }
      while ( v25 != all_created_runtime );
    }
    V_LOCK();
    logfmt_raw((char *)v42, 0x1000u, 0, "total_pools after removed = %d", total_pools);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/pool.c",
      134,
      "pool_change_function",
      20,
      775,
      20,
      v42);
    if ( total_pools > 0 )
    {
      v29 = 0;
      do
      {
        v30 = *(_DWORD **)(pools + 4 * v29++);
        V_LOCK();
        logfmt_raw((char *)v42, 0x1000u, 0, "after reload pool, pool->pool_no = %d, pool->rpc_url = %s", *v30, v30[2]);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/pool.c",
          134,
          "pool_change_function",
          20,
          778,
          20,
          v42);
      }
      while ( total_pools > v29 );
    }
    v31 = 0;
    create_pool_stratum_threads();
    do
    {
      ++v31;
      sleep(1u);
      if ( v31 == 8 )
        v32 = 0;
      else
        v32 = ((unsigned __int8)pools_active ^ 1) & 1;
    }
    while ( v32 );
    set_miner_start_time();
    api_flush();
    v33 = (unsigned __int8)pools_active;
    if ( !pools_active )
    {
      V_LOCK();
      logfmt_raw((char *)v42, 0x1000u, v33, "error pool input");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/pool.c",
        134,
        "pool_change_function",
        20,
        792,
        100,
        v42);
      if ( total_pools > 0 )
      {
        do
        {
          v38 = *(_DWORD **)(pools + 4 * v33++);
          V_LOCK();
          logfmt_raw((char *)v42, 0x1000u, 0, "pool%d, url = %s, user = %s, pass = %s\n", *v38, v38[2], v38[3], v38[4]);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/pool.c",
            134,
            "pool_change_function",
            20,
            795,
            100,
            v42);
        }
        while ( total_pools > v33 );
      }
    }
  }
  if ( v40 )
  {
    dword_11AEA8 = 2;
    pthread_attr_init(&attr);
    v34 = pthread_create((pthread_t *)&dword_11AEAC, &attr, (void *(*)(void *))watchpool_thread, &dword_11AEA8);
    pthread_attr_destroy(&attr);
    if ( v34 )
    {
      V_LOCK();
      logfmt_raw((char *)v42, 0x1000u, 0, "watchpool thread create failed!");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/pool.c",
        134,
        "pool_change_function",
        20,
        805,
        100,
        v42);
      exit(1);
    }
  }
  sleep(0xAu);
  if ( v39 > 0 )
  {
    v35 = (void **)v41;
    do
    {
      v37 = *v35++;
      v36 = v37;
      if ( v37 )
        free(v36);
    }
    while ( &v41[v39] != v35 );
  }
  newthread = 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 107BA0: using guessed type int total_pools;
// 107BA4: using guessed type int pools;
// 107BA8: using guessed type int dword_107BA8;
// 107BAC: using guessed type int dword_107BAC;
// 107BB0: using guessed type int dword_107BB0;
// 107CD0: using guessed type int dword_107CD0;
// 1085D4: using guessed type char pools_active;
// 11A7AC: using guessed type int g_zc;
// 11AEA8: using guessed type int dword_11AEA8;
// 11AEAC: using guessed type int dword_11AEAC;

//----- (0002B070) --------------------------------------------------------
int __fastcall judge_load_config(char *a1)
{
  unsigned int *file; // r0
  unsigned int *v3; // r6
  unsigned int v4; // r7
  int v5; // r8
  int v6; // r0
  int v7; // r12
  int v8; // r2
  _DWORD *v10; // r0
  _DWORD *v11; // r10
  _DWORD *v12; // r0
  _DWORD *v13; // r0
  unsigned int *v14; // r3
  unsigned int v15; // r2
  unsigned int v16; // r2
  const char *v17; // r0
  int v18; // r0
  char *v19; // r9
  _DWORD *v20; // r0
  _DWORD *v21; // r8
  unsigned int v22; // r6
  int v23; // r6
  _DWORD *v24; // r0
  _DWORD *v25; // r0
  _DWORD *v26; // r0
  _DWORD *v27; // r0
  _DWORD *v28; // r0
  _DWORD *v29; // r0
  const char *v30; // r11
  int v31; // r9
  int v32; // r8
  int v33; // r10
  int v34; // r0
  const char *v35; // r1
  int v36; // r7
  int v37; // t1
  char *v38; // [sp+4h] [bp-1130h]
  unsigned int *v39; // [sp+28h] [bp-110Ch]
  char v40[92]; // [sp+34h] [bp-1100h] BYREF
  char v41[160]; // [sp+90h] [bp-10A4h] BYREF
  char v42[4100]; // [sp+130h] [bp-1004h] BYREF

  V_LOCK();
  logfmt_raw(v42, 0x1000u, 0, "start %s", "judge_load_config");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/pool.c",
    134,
    "judge_load_config",
    17,
    578,
    20,
    v42);
  if ( a1 )
  {
    file = (unsigned int *)json_load_file(a1, 0, v40);
    v3 = file;
    if ( !file || (v4 = *file) != 0 )
    {
      V_LOCK();
      v38 = a1;
      v5 = 0;
      logfmt_raw(v42, 0x1000u, 0, "%s: JSON decode of file '%s' failed %s", "judge_load_config", v38, v41);
      V_UNLOCK();
      v6 = g_zc;
      v7 = 100;
      v8 = 593;
LABEL_5:
      zlog(
        v6,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/pool.c",
        134,
        "judge_load_config",
        17,
        v8,
        v7,
        v42);
      return v5;
    }
    V_LOCK();
    logfmt_raw(v42, 0x1000u, 0, "%s: after json_load_file", "judge_load_config");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/pool.c",
      134,
      "judge_load_config",
      17,
      596,
      20,
      v42);
    v10 = (_DWORD *)json_object_get(v3, "pools");
    v11 = v10;
    if ( !v10 || *v10 != 1 )
      goto LABEL_8;
    v19 = (char *)&unk_107CD4;
    dword_107CD0 = (int)json_array_size(v10);
    v39 = v3;
    while ( (unsigned int)json_array_size(v11) > v4 )
    {
      v20 = json_array_get(v11, v4);
      v21 = v20;
      if ( !v20 )
        break;
      v22 = __clz(v4 - 3);
      ++v4;
      v23 = v22 >> 5;
      if ( *v20 )
        v23 = 1;
      if ( v23 )
        break;
      v24 = (_DWORD *)json_object_get(v20, "url");
      if ( !v24 )
        break;
      if ( *v24 != 2 )
        break;
      v25 = json_string_value(v24);
      snprintf(v19, 0x100u, "%s", v25);
      v26 = (_DWORD *)json_object_get(v21, "user");
      if ( !v26 )
        break;
      if ( *v26 != 2 )
        break;
      v27 = json_string_value(v26);
      snprintf(v19 + 256, 0x100u, "%s", v27);
      v28 = (_DWORD *)json_object_get(v21, "pass");
      if ( !v28 || *v28 != 2 )
        break;
      v29 = json_string_value(v28);
      snprintf(v19 + 512, 0x100u, "%s", v29);
      V_LOCK();
      logfmt_raw(v42, 0x1000u, 0, "%s\n%s\n%s", v19, v19 + 256, v19 + 512);
      V_UNLOCK();
      v19 += 768;
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/pool.c",
        134,
        "judge_load_config",
        17,
        620,
        20,
        v42);
    }
    v3 = v39;
    v30 = (const char *)&unk_107CD4;
    v31 = total_pools;
    if ( total_pools == dword_107CD0 )
    {
      if ( total_pools <= 0 )
      {
LABEL_8:
        v5 = 0;
        goto LABEL_9;
      }
      v32 = 0;
      v33 = pools - 4;
      while ( 1 )
      {
        v37 = *(_DWORD *)(v33 + 4);
        v33 += 4;
        v36 = v37;
        ++v32;
        if ( strcmp(*(const char **)(v37 + 8), v30) )
          break;
        v34 = strcmp(*(const char **)(v36 + 12), v30 + 256);
        v35 = v30 + 512;
        v30 += 768;
        if ( v34 || strcmp(*(const char **)(v36 + 16), v35) )
          break;
        if ( v31 == v32 )
          goto LABEL_8;
      }
    }
    v5 = 1;
LABEL_9:
    json_object_get(v3, "bitmain-freq-level");
    v12 = (_DWORD *)json_object_get(v3, "bitmain-fan-ctrl");
    if ( v12 && (unsigned int)(*v12 - 5) <= 1 && fan_pwm_fixed != (*v12 == 5) )
    {
      v5 |= 4u;
      fan_pwm_fixed = *v12 == 5;
    }
    v13 = (_DWORD *)json_object_get(v3, "bitmain-fan-pwm");
    if ( v13 )
    {
      if ( *v13 == 2 )
      {
        v17 = (const char *)json_string_value(v13);
        v18 = strtol(v17, 0, 10);
        if ( fan_pwm != v18 )
        {
          v5 |= 8u;
          fan_pwm = v18;
        }
      }
    }
    if ( v3[1] != -1 )
    {
      v14 = v3 + 1;
      __dmb(0xBu);
      do
      {
        v15 = __ldrex(v14);
        v16 = v15 - 1;
      }
      while ( __strex(v16, v14) );
      if ( !v16 )
        json_delete(v3);
    }
    V_LOCK();
    logfmt_raw(v42, 0x1000u, 0, "ret = 0x%x", v5);
    V_UNLOCK();
    v6 = g_zc;
    v7 = 20;
    v8 = 679;
    goto LABEL_5;
  }
  V_LOCK();
  logfmt_raw(v42, 0x1000u, 0, "%s: bad param", "judge_load_config");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/pool.c",
    134,
    "judge_load_config",
    17,
    587,
    100,
    v42);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1063FC: using guessed type int fan_pwm;
// 107BA0: using guessed type int total_pools;
// 107BA4: using guessed type int pools;
// 107CD0: using guessed type int dword_107CD0;
// 1088B4: using guessed type char fan_pwm_fixed;
// 11A7AC: using guessed type int g_zc;

//----- (0002B5CC) --------------------------------------------------------
int reload_pool()
{
  int result; // r0
  int v1; // r2
  int v2; // r0
  int v3; // r1
  char v4[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( newthread )
  {
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, "config too fast, pool is changing, please wait");
    V_UNLOCK();
    v1 = 827;
    v2 = g_zc;
    LOWORD(v3) = (unsigned __int16)"/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/"
                                   "release/build/godminer-origin_godminer-new/pool.c";
LABEL_5:
    HIWORD(v3) = (unsigned int)"/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/rele"
                               "ase/build/godminer-origin_godminer-new/pool.c" >> 16;
    return zlog(v2, v3, 134, "reload_pool", 11, v1, 100, v4);
  }
  result = pthread_create(&newthread, 0, (void *(*)(void *))sub_2A8D4, 0);
  if ( result )
  {
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, "Failed to create pool_change_thread");
    V_UNLOCK();
    v1 = 825;
    v2 = g_zc;
    LOWORD(v3) = -328;
    goto LABEL_5;
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0002B6D4) --------------------------------------------------------
char *__fastcall stratum_buffer_append(int a1, const char *a2)
{
  char *v3; // r4
  size_t v5; // r6
  size_t v6; // r0
  size_t v7; // r1

  v3 = *(char **)(a1 + 40);
  v5 = strlen(v3);
  v6 = strlen(a2) + v5 + 1;
  if ( *(_DWORD *)(a1 + 36) <= v6 )
  {
    v7 = (v6 & 0xFFFFC000) + 0x4000;
    *(_DWORD *)(a1 + 36) = v7;
    v3 = (char *)realloc(v3, v7);
    *(_DWORD *)(a1 + 40) = v3;
  }
  return strcpy(&v3[v5], a2);
}

//----- (0002B73C) --------------------------------------------------------
int __fastcall stratum_send_line(int *a1, char *a2)
{
  pthread_mutex_t *v4; // r4
  int v5; // r5
  _DWORD v7[7]; // [sp+28h] [bp-1024h] BYREF
  int v8; // [sp+44h] [bp-1008h]
  char v9[4100]; // [sp+48h] [bp-1004h] BYREF

  if ( opt_protocol )
  {
    V_LOCK();
    V_INT((int)v7, "poolno", *a1);
    logfmt_raw(v9, 0x1000u, 0, v8, v7[0], v7[1], v7[2], v7[3], v7[4], v7[5], v7[6], v8, "> %s", a2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/stratum_handler.c",
      145,
      "stratum_send_line",
      17,
      26,
      60,
      v9);
  }
  v4 = (pthread_mutex_t *)(a1 + 11);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 11));
  v5 = send_line(a1[8], a2);
  pthread_mutex_unlock(v4);
  return v5;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 107A64: using guessed type char opt_protocol;
// 11A7AC: using guessed type int g_zc;

//----- (0002B834) --------------------------------------------------------
char *__fastcall stratum_recv_line(int *a1)
{
  pthread_mutex_t *v1; // r7
  char *v3; // r10
  signed int v4; // r5
  char *v5; // r0
  char *v6; // r6
  size_t v7; // r0
  _BYTE *v8; // r3
  ssize_t v10; // r10
  int *v11; // r11
  int v12; // r0
  int v13; // r2
  time_t v14; // [sp+2Ch] [bp-5028h] BYREF
  _DWORD v15[7]; // [sp+30h] [bp-5024h] BYREF
  int v16; // [sp+4Ch] [bp-5008h]
  _DWORD v17[7]; // [sp+50h] [bp-5004h] BYREF
  int v18; // [sp+6Ch] [bp-4FE8h]
  char v19[16388]; // [sp+1050h] [bp-4004h] BYREF

  v1 = (pthread_mutex_t *)(a1 + 11);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 11));
  v3 = (char *)a1[10];
  if ( !strchr(v3, 10) && a1[8] != -1 )
  {
    time(&v14);
    while ( 1 )
    {
      memset(v19, 0, 0x4000u);
      v10 = recv(a1[8], v19, 0x3FFCu, 0);
      if ( !v10 )
      {
        V_LOCK();
        logfmt_raw((char *)v17, 0x1000u, 0, "stratum_recv_line read 0 bytes");
        V_UNLOCK();
        v12 = g_zc;
        v13 = 53;
        goto LABEL_20;
      }
      if ( v10 < 0 )
      {
        V_LOCK();
        v11 = _errno_location();
        logfmt_raw((char *)v17, 0x1000u, 0, "stratum_recv_line recv failed err %zd %d", v10, *v11);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/stratum_handler.c",
          145,
          "stratum_recv_line",
          17,
          58,
          20,
          v17);
        if ( *v11 != 11 || !socket_full(a1[8], 1) )
        {
          V_LOCK();
          logfmt_raw((char *)v17, 0x1000u, 0, "stratum_recv_line recv failed detailed error %d", *v11);
          V_UNLOCK();
          v12 = g_zc;
          v13 = 60;
LABEL_20:
          zlog(
            v12,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/stratum_handler.c",
            145,
            "stratum_recv_line",
            17,
            v13,
            20,
            v17);
          V_LOCK();
          V_INT((int)v15, "poolno", *a1);
          logfmt_raw(
            v19,
            0x1000u,
            0,
            v16,
            v15[0],
            v15[1],
            v15[2],
            v15[3],
            v15[4],
            v15[5],
            v15[6],
            v16,
            "stratum_recv_line failed");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/stratum_handler.c",
            145,
            "stratum_recv_line",
            17,
            69,
            20,
            v19);
          goto LABEL_21;
        }
      }
      else
      {
        stratum_buffer_append((int)a1, v19);
      }
      if ( time(0) - v14 > 59 )
        break;
      v3 = (char *)a1[10];
      if ( strchr(v3, 10) )
        goto LABEL_2;
    }
    v3 = (char *)a1[10];
  }
LABEL_2:
  v4 = strlen(v3);
  v5 = strtok(v3, "\n");
  if ( v5 )
  {
    v6 = _strdup(v5);
    v7 = strlen(v6);
    v8 = (_BYTE *)a1[10];
    if ( (int)(v7 + 1) < v4 )
      memmove((void *)a1[10], &v8[v7 + 1], v4 - v7 + 1);
    else
      *v8 = 0;
    pthread_mutex_unlock(v1);
    if ( opt_protocol )
    {
      V_LOCK();
      V_INT((int)v17, "poolno", *a1);
      logfmt_raw(v19, 0x1000u, 0, v18, v17[0], v17[1], v17[2], v17[3], v17[4], v17[5], v17[6], v18, "< %s", v6);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/stratum_handler.c",
        145,
        "stratum_recv_line",
        17,
        91,
        60,
        v19);
    }
    return v6;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v19, 0x1000u, 0, "stratum_recv_line failed to parse a newline-terminated string");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/stratum_handler.c",
      145,
      "stratum_recv_line",
      17,
      77,
      100,
      v19);
LABEL_21:
    pthread_mutex_unlock(v1);
    return 0;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 107A64: using guessed type char opt_protocol;
// 11A7AC: using guessed type int g_zc;

//----- (0002BC6C) --------------------------------------------------------
int __fastcall stratum_socket_full(int a1, __time_t a2)
{
  size_t v4; // r0
  char v6[4096]; // [sp+10h] [bp-1000h] BYREF

  V_LOCK();
  v4 = strlen(*(const char **)(a1 + 40));
  logfmt_raw(v6, 0x1000u, 0, "stratum_socket_full sockbuf len %zu", v4);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/stratum_handler.c",
    145,
    "stratum_socket_full",
    19,
    97,
    20,
    v6);
  if ( **(_BYTE **)(a1 + 40) )
    return 1;
  else
    return socket_full(*(_DWORD *)(a1 + 32), a2);
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0002BD1C) --------------------------------------------------------
bool __fastcall stratum_connect(int a1)
{
  pthread_mutex_t *v1; // r7
  int v3; // r4
  _BOOL4 server_port_from_url; // r8
  _BYTE *v6; // r0
  int v7; // r0
  bool v8; // nf
  int v9; // r0
  int v10; // r0
  int *v11; // r0
  char *v12; // r0
  struct hostent *v13; // r0
  char *v14; // r3
  unsigned __int16 v15; // [sp+2Eh] [bp-1126h] BYREF
  _DWORD optval[7]; // [sp+30h] [bp-1124h] BYREF
  int v17; // [sp+4Ch] [bp-1108h]
  char cp[256]; // [sp+50h] [bp-1104h] BYREF
  struct sockaddr v19[256]; // [sp+150h] [bp-1004h] BYREF

  v1 = (pthread_mutex_t *)(a1 + 44);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 44));
  v3 = *(_DWORD *)(a1 + 28);
  if ( !strncasecmp((const char *)v3, "stratum+tcp://", 0xEu)
    && (server_port_from_url = get_server_port_from_url((char *)(v3 + 14), cp, &v15)) )
  {
    V_LOCK();
    logfmt_raw((char *)v19, 0x1000u, 0, "url: %s, server: %s, port: %d", *(_DWORD *)(a1 + 28), cp, v15);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/stratum_handler.c",
      145,
      "stratum_connect",
      15,
      113,
      20,
      v19);
    v6 = *(_BYTE **)(a1 + 40);
    if ( !v6 )
    {
      v6 = calloc(0x4000u, 1u);
      *(_DWORD *)(a1 + 40) = v6;
      *(_DWORD *)(a1 + 36) = 0x4000;
    }
    *v6 = 0;
    if ( *(_DWORD *)(a1 + 32) == -1 )
    {
      v10 = socket(2, 1, 6);
      *(_DWORD *)(a1 + 32) = v10;
      if ( v10 == -1 )
      {
        server_port_from_url = 0;
        goto LABEL_4;
      }
      optval[0] = 1;
      if ( setsockopt(v10, 1, 2, optval, 4u) )
      {
        V_LOCK();
        v11 = _errno_location();
        v12 = strerror(*v11);
        logfmt_raw((char *)v19, 0x1000u, 0, "API setsockopt SO_REUSEADDR failed (ignored): %s", v12);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/stratum_handler.c",
          145,
          "stratum_connect",
          15,
          137,
          100,
          v19);
      }
    }
    if ( inet_addr(cp) == -1 )
    {
      if ( _res_init() < 0 )
      {
        server_port_from_url = 0;
        close(*(_DWORD *)(a1 + 32));
        *(_DWORD *)(a1 + 32) = -1;
        V_LOCK();
        logfmt_raw((char *)v19, 0x1000u, 0, "poolno %d res_init error", *(_DWORD *)a1);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/stratum_handler.c",
          145,
          "stratum_connect",
          15,
          152,
          100,
          v19);
        goto LABEL_4;
      }
      v13 = gethostbyname(cp);
      if ( !v13 )
      {
        server_port_from_url = 0;
        close(*(_DWORD *)(a1 + 32));
        *(_DWORD *)(a1 + 32) = -1;
        goto LABEL_4;
      }
      v14 = *v13->h_addr_list;
      if ( v14 )
        *(_DWORD *)&v19[0].sa_data[2] = *(_DWORD *)v14;
    }
    else
    {
      *(_DWORD *)&v19[0].sa_data[2] = inet_addr(cp);
    }
    v19[0].sa_family = 2;
    v7 = *(_DWORD *)(a1 + 32);
    *(_WORD *)v19[0].sa_data = __rev16(v15);
    v8 = connect(v7, v19, 0x10u) < 0;
    v9 = *(_DWORD *)(a1 + 32);
    if ( v8 )
    {
      close(v9);
      server_port_from_url = 0;
      *(_DWORD *)(a1 + 32) = -1;
    }
    else
    {
      keep_sockalive(v9);
    }
  }
  else
  {
    server_port_from_url = 0;
    V_LOCK();
    V_STR(optval, "pool", *(const char **)(a1 + 28));
    logfmt_raw(
      (char *)v19,
      0x1000u,
      0,
      v17,
      optval[0],
      optval[1],
      optval[2],
      optval[3],
      optval[4],
      optval[5],
      optval[6],
      v17,
      "prase url err!");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/stratum_handler.c",
      145,
      "stratum_connect",
      15,
      110,
      100,
      v19);
  }
LABEL_4:
  pthread_mutex_unlock(v1);
  return server_port_from_url;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0002C0AC) --------------------------------------------------------
int __fastcall stratum_disconnect(int *a1)
{
  pthread_mutex_t *v1; // r6
  int v3; // r0
  _BYTE *v4; // r3
  _DWORD v6[7]; // [sp+28h] [bp-1020h] BYREF
  int v7; // [sp+44h] [bp-1004h]
  char v8[4096]; // [sp+48h] [bp-1000h] BYREF

  v1 = (pthread_mutex_t *)(a1 + 11);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 11));
  v3 = a1[8];
  if ( v3 != -1 )
  {
    shutdown(v3, 2);
    close(a1[8]);
    v4 = (_BYTE *)a1[10];
    a1[8] = -1;
    *v4 = 0;
    V_LOCK();
    V_INT((int)v6, "poolno", *a1);
    logfmt_raw(v8, 0x1000u, 0, v7, v6[0], v6[1], v6[2], v6[3], v6[4], v6[5], v6[6], v7, "pool disconnect");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/stratum_handler.c",
      145,
      "stratum_disconnect",
      18,
      214,
      20,
      v8);
  }
  return pthread_mutex_unlock(v1);
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0002C1A8) --------------------------------------------------------
int __fastcall stratum_thread(int a1)
{
  int v2; // r7
  pthread_t v3; // r0
  int *v4; // r4
  char *v5; // r5
  int v6; // r0
  char *v7; // r0
  unsigned int v8; // r6
  unsigned int v9; // r5
  int *v10; // r0
  bool v11; // zf
  int *v12; // r1
  signed __int64 v13; // r0
  int v14; // r0
  void *v15; // r5
  int v16; // r8
  _DWORD *current_pool; // r0
  int v18; // r3
  void (__fastcall *v19)(int *); // r2
  _BYTE *v21; // [sp+30h] [bp-108Ch]
  int v22; // [sp+34h] [bp-1088h]
  int v23; // [sp+3Ch] [bp-1080h]
  __time_t v24; // [sp+40h] [bp-107Ch]
  _DWORD v25[7]; // [sp+58h] [bp-1064h] BYREF
  int v26; // [sp+74h] [bp-1048h]
  _DWORD v27[7]; // [sp+78h] [bp-1044h] BYREF
  int v28; // [sp+94h] [bp-1028h]
  int v29; // [sp+98h] [bp-1024h] BYREF
  int v30; // [sp+9Ch] [bp-1020h]
  int v31; // [sp+A0h] [bp-101Ch]
  int v32; // [sp+A4h] [bp-1018h]
  int v33; // [sp+A8h] [bp-1014h]
  int v34; // [sp+ACh] [bp-1010h]
  int v35; // [sp+B0h] [bp-100Ch]
  int v36; // [sp+B4h] [bp-1008h]
  char v37[4100]; // [sp+B8h] [bp-1004h] BYREF

  v2 = frontend_runtime_instance();
  v3 = pthread_self();
  pthread_detach(v3);
  v24 = *(_DWORD *)(*(_DWORD *)(v2 + 68) + 16);
  v4 = (int *)tq_pop(*(_DWORD *)(a1 + 44), 0);
  if ( v4 )
  {
    V_LOCK();
    logfmt_raw(v37, 0x1000u, 0, "stratum_thread pool %s", v4[2]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/stratum_handler.c",
      145,
      "stratum_thread",
      14,
      236,
      20,
      v37);
    v5 = (char *)calloc(1u, 0x40u);
    snprintf(v5, 0x40u, "%.10s_%d", "stratum_thread", *v4);
    V_LOCK();
    v6 = syscall(224);
    logfmt_raw(v37, 0x1000u, 0, "%s on pid %ld", v5, v6);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/stratum_handler.c",
      145,
      "stratum_thread",
      14,
      238,
      40,
      v37);
    prctl(15, v5);
    v7 = _strdup((const char *)v4[2]);
    v4[7] = (int)v7;
    if ( v7 )
    {
      v21 = v4 + 477;
      v23 = 1;
      pool_tset((int)v4, (_BYTE *)v4 + 1896, 0);
      pool_tclear((int)v4, (_BYTE *)v4 + 1908, 0);
      while ( 1 )
      {
        while ( 1 )
        {
          v8 = 0;
          v9 = 0;
          while ( 1 )
          {
            v10 = v4;
            if ( v4[8] != -1 )
              break;
            while ( 1 )
            {
              v11 = (*(int (__fastcall **)(int *))v2)(v10) == 0;
              v12 = v4;
              if ( !v11 )
              {
                if ( (*(int (__fastcall **)(int, int *))(v2 + 16))(v2, v4) )
                  break;
              }
              (*(void (__fastcall **)(int *, int *))(v2 + 4))(v4, v12);
              pool_tclear((int)v4, v21, 0);
              pool_died(v4);
              v13 = __PAIR64__(v9, v8);
              v9 = (__PAIR64__(v9, v8) + 1) >> 32;
              if ( !(v13 % 50) )
              {
                V_LOCK();
                V_INT((int)v25, "poolno", *v4);
                logfmt_raw(
                  v37,
                  0x1000u,
                  0,
                  v26,
                  v25[0],
                  v25[1],
                  v25[2],
                  v25[3],
                  v25[4],
                  v25[5],
                  v25[6],
                  v26,
                  "...retry after %d seconds failures %d",
                  30,
                  v8 + 1,
                  v9);
                V_UNLOCK();
                zlog(
                  g_zc,
                  "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/god"
                  "miner-origin_godminer-new/stratum_handler.c",
                  145,
                  "stratum_thread",
                  14,
                  256,
                  100,
                  v37);
              }
              ++v8;
              sleep(0x1Eu);
              v10 = v4;
              if ( v4[8] != -1 )
                goto LABEL_11;
            }
            V_LOCK();
            v16 = v4[7];
            v22 = *v4;
            current_pool = (_DWORD *)get_current_pool();
            logfmt_raw(v37, 0x1000u, 0, "pool %d is active, pool url %s, current_pool %d", v22, v16, *current_pool);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godmine"
              "r-origin_godminer-new/stratum_handler.c",
              145,
              "stratum_thread",
              14,
              260,
              20,
              v37);
            pool_alive((int)v4);
            if ( v23 )
            {
              v23 = 0;
              switch_pools();
            }
          }
LABEL_11:
          if ( v4 != (int *)get_current_pool() )
            wait_pool_to_be_current_timeout((int)v4);
          if ( stratum_socket_full((int)v4, v24) )
            break;
          V_LOCK();
          V_INT((int)v27, "poolno", *v4);
          logfmt_raw(
            v37,
            0x1000u,
            0,
            v28,
            v27[0],
            v27[1],
            v27[2],
            v27[3],
            v27[4],
            v27[5],
            v27[6],
            v28,
            "stratum connection timeout");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/stratum_handler.c",
            145,
            "stratum_thread",
            14,
            285,
            100,
            v37);
LABEL_21:
          v18 = v4[485] + 1;
          pools_active = 0;
          v19 = *(void (__fastcall **)(int *))(v2 + 4);
          ++total_go;
          v4[485] = v18;
          v19(v4);
          pool_tclear((int)v4, v21, 0);
          pool_died(v4);
          V_LOCK();
          V_INT((int)&v29, "poolno", *v4);
          logfmt_raw(v37, 0x1000u, 0, v36, v29, v30, v31, v32, v33, v34, v35, v36, "stratum connection interrupted");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/stratum_handler.c",
            145,
            "stratum_thread",
            14,
            297,
            20,
            v37);
          sleep(0x1Eu);
        }
        v14 = (*(int (__fastcall **)(int *))(v2 + 8))(v4);
        v15 = (void *)v14;
        if ( !v14 )
          goto LABEL_21;
        if ( !(*(int (__fastcall **)(int, int *, int))(v2 + 20))(v2, v4, v14) )
          (*(void (__fastcall **)(int, void *, int *))(v2 + 24))(v2, v15, v4);
        free(v15);
        pools_active = 1;
      }
    }
  }
  V_LOCK();
  V_INT((int)&v29, "poolno", *v4);
  logfmt_raw(v37, 0x1000u, 0, v36, v29, v30, v31, v32, v33, v34, v35, v36, "stratum thread out");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/stratum_handler.c",
    145,
    "stratum_thread",
    14,
    310,
    60,
    v37);
  return 0;
}
// 2C3D8: variable 'v12' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1085D4: using guessed type char pools_active;
// 11A7AC: using guessed type int g_zc;
// 11A800: using guessed type int total_go;

//----- (0002C7D8) --------------------------------------------------------
int __fastcall sub_2C7D8(int a1)
{
  char v3[4100]; // [sp+10h] [bp-1004h] BYREF

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/util.h",
    134,
    "get_value_from_lower_hex",
    24,
    41,
    100,
    v3);
  return -1;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0002C858) --------------------------------------------------------
int __fastcall sub_2C858(int a1)
{
  if ( (unsigned __int8)(a1 - 48) <= 9u )
    return a1 - 48;
  if ( (unsigned int)(a1 - 97) > 5 )
    return sub_2C7D8(a1);
  return a1 - 87;
}

//----- (0002C888) --------------------------------------------------------
int __fastcall sub_2C888(const char *a1, int *a2)
{
  int result; // r0
  int v5; // r4
  char *endptr; // [sp+14h] [bp-1004h] BYREF
  char v7[4096]; // [sp+18h] [bp-1000h] BYREF

  result = strtol(a1, &endptr, 0);
  v5 = result;
  if ( *endptr || !*a1 )
  {
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, "'%s' is not a number", a1);
    V_UNLOCK();
    result = zlog(
               g_zc,
               "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godmin"
               "er-origin_godminer-new/util.c",
               134,
               "opt_set_longval",
               15,
               448,
               100,
               v7);
    if ( (unsigned int)(v5 + 0x7FFFFFFF) <= 0xFFFFFFFD )
      goto LABEL_4;
  }
  else if ( (unsigned int)(result + 0x7FFFFFFF) <= 0xFFFFFFFD )
  {
LABEL_4:
    *a2 = v5;
    return result;
  }
  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "'%s' is out of range", a1);
  V_UNLOCK();
  result = zlog(
             g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer"
             "-origin_godminer-new/util.c",
             134,
             "opt_set_longval",
             15,
             450,
             100,
             v7);
  *a2 = v5;
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0002C9CC) --------------------------------------------------------
int __fastcall extract_byte_from_hex(const char *a1, int a2)
{
  const __int32_t **v4; // r0
  int v5; // r4
  int v6; // r5
  int v7; // r4
  int v8; // r4
  char v10[4096]; // [sp+10h] [bp-1000h] BYREF

  if ( (strlen(a1) & 1) != 0 )
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, 920800, a1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/util.c",
      134,
      "extract_byte_from_hex",
      21,
      28,
      100,
      v10);
  }
  v4 = _ctype_tolower_loc();
  v5 = LOBYTE((*v4)[(unsigned __int8)a1[a2]]);
  v6 = LOBYTE((*v4)[(unsigned __int8)a1[a2 + 1]]);
  if ( (unsigned int)(v5 - 97) > 5 && (unsigned int)(v5 - 48) > 9 )
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, 920832, v5);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/util.c",
      134,
      "extract_byte_from_hex",
      21,
      35,
      100,
      v10);
  }
  if ( (unsigned int)(v6 - 97) > 5 && (unsigned int)(v6 - 48) > 9 )
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, 920832, v6);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/util.c",
      134,
      "extract_byte_from_hex",
      21,
      38,
      100,
      v10);
  }
  v7 = 16 * sub_2C858(v5);
  v8 = v7 + sub_2C858(v6);
  if ( v8 > 255 )
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, 920864, a1, a2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/util.c",
      134,
      "extract_byte_from_hex",
      21,
      45,
      100,
      v10);
  }
  return (unsigned __int8)v8;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0002CC0C) --------------------------------------------------------
int __fastcall format_hashrate_string(int a1, char *a2)
{
  double v2; // d0
  double v5; // d8
  int v6; // r3
  double v7; // d0
  double v8; // d8
  char v10[4096]; // [sp+10h] [bp-1000h] BYREF

  v5 = v2;
  V_LOCK();
  logfmt_raw(v10, 0x1000u, 0, 920920, v2, a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/util.c",
    134,
    "format_hashrate_string",
    22,
    55,
    20,
    v10);
  if ( v2 < 10000.0 )
    return sprintf(a2, "%.2f %s/s", v2, a1);
  if ( v2 < 10000000.0 )
  {
    v6 = 75;
    v8 = v2 * 0.001;
  }
  else
  {
    if ( v2 >= 1.0e10 )
      v6 = 71;
    else
      v6 = 77;
    if ( v2 >= 1.0e10 )
      v7 = 0.000000001;
    else
      v7 = 0.000001;
    v8 = v5 * v7;
  }
  return sprintf(a2, "%.2f %c%s/s", v8, v6, a1);
}
// 2CC24: variable 'v2' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0002CD64) --------------------------------------------------------
int __fastcall format_hashrate_double(int a1, double *a2, char *a3)
{
  double v3; // d0
  int v8; // r2
  double v9; // d9
  char v10[4100]; // [sp+10h] [bp-1004h] BYREF

  V_LOCK();
  logfmt_raw(v10, 0x1000u, 0, 920976, v3, a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/util.c",
    134,
    "format_hashrate_double",
    22,
    90,
    20,
    v10);
  if ( v3 >= 10000.0 )
  {
    if ( v3 < 10000000.0 )
    {
      v8 = 75;
      *a2 = v3 * 0.001;
    }
    else
    {
      if ( v3 < 1.0e10 )
        v8 = 77;
      else
        v8 = 71;
      if ( v3 < 1.0e10 )
        v9 = 0.000001;
      else
        v9 = 0.000000001;
      *a2 = v3 * v9;
    }
    return sprintf(a3, "%c%s/s", v8, a1);
  }
  else
  {
    *a2 = v3;
    return sprintf(a3, "%s/s", a1);
  }
}
// 2CDA8: variable 'v3' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0002CEC4) --------------------------------------------------------
int __fastcall bin2hex(int s, int a2, int a3)
{
  int v3; // r4
  int v4; // r6
  int v5; // r5
  int v6; // t1
  char *v7; // r0

  if ( a3 )
  {
    v3 = a2 - 1;
    v4 = a2 - 1 + a3;
    v5 = s;
    do
    {
      v6 = *(unsigned __int8 *)++v3;
      v7 = (char *)v5;
      v5 += 2;
      s = sprintf(v7, "%02x", v6);
    }
    while ( v3 != v4 );
  }
  return s;
}

//----- (0002CF04) --------------------------------------------------------
void *__fastcall abin2hex(int a1, int a2)
{
  void *v4; // r0
  void *v5; // r8
  int v6; // r4
  int v7; // r6
  char *v8; // r5
  int v9; // t1
  char *v10; // r0

  v4 = malloc(2 * a2 + 1);
  v5 = v4;
  if ( v4 && a2 )
  {
    v6 = a1 - 1;
    v7 = v6 + a2;
    v8 = (char *)v4;
    do
    {
      v9 = *(unsigned __int8 *)++v6;
      v10 = v8;
      v8 += 2;
      sprintf(v10, "%02x", v9);
    }
    while ( v6 != v7 );
  }
  return v5;
}

//----- (0002CF64) --------------------------------------------------------
bool __fastcall hex2bin(int a1, unsigned __int8 *a2, int a3)
{
  int v3; // r3
  int v4; // r5
  char v5; // r12
  unsigned __int8 *v6; // r4
  int v7; // r6
  char v8; // r0
  char *v9; // r3
  int v10; // r2
  char v12[4]; // [sp+10h] [bp-1008h] BYREF
  char *endptr; // [sp+14h] [bp-1004h] BYREF
  char v14[4096]; // [sp+18h] [bp-1000h] BYREF

  v3 = *a2;
  v4 = a3;
  v12[2] = 0;
  if ( !v3 )
    return v4 == 0;
  if ( !a3 )
    return 1;
  v5 = a2[1];
  if ( v5 )
  {
    v6 = a2;
    v7 = a1 - 1;
    while ( 1 )
    {
      v12[0] = v3;
      v12[1] = v5;
      --v4;
      v8 = strtol(v12, &endptr, 16);
      v9 = endptr;
      *(_BYTE *)++v7 = v8;
      if ( *v9 )
        break;
      v3 = v6[2];
      v6 += 2;
      if ( !v3 )
        return v4 == 0;
      if ( !v4 )
        return 1;
      v5 = v6[1];
      if ( !v5 )
        goto LABEL_14;
    }
    V_LOCK();
    logfmt_raw(v14, 0x1000u, 0, "hex2bin failed on '%s'", v12);
    V_UNLOCK();
    v10 = 153;
  }
  else
  {
LABEL_14:
    V_LOCK();
    logfmt_raw(v14, 0x1000u, 0, "hex2bin str truncated");
    V_UNLOCK();
    v10 = 146;
  }
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/util.c",
    134,
    "hex2bin",
    7,
    v10,
    100,
    v14);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0002D0D0) --------------------------------------------------------
int __fastcall str2hex(int a1, int a2, int a3)
{
  char v3; // r5
  char v4; // r6
  int i; // r3
  int v6; // r4
  int v7; // lr

  if ( a3 <= 0 )
    return a3 / 2;
  for ( i = 0; i < a3; i += 2 )
  {
    v6 = *(unsigned __int8 *)(a2 + i);
    if ( (unsigned __int8)(v6 - 48) > 9u )
    {
      if ( (unsigned int)(v6 - 97) > 5 )
      {
        if ( (unsigned int)(v6 - 65) <= 5 )
          v3 = v6 - 55;
      }
      else
      {
        v3 = v6 - 87;
      }
    }
    else
    {
      v3 = v6 - 48;
    }
    v7 = *(unsigned __int8 *)(a2 + i + 1);
    if ( (unsigned __int8)(v7 - 48) > 9u )
    {
      if ( (unsigned int)(v7 - 97) > 5 )
      {
        if ( (unsigned int)(v7 - 65) <= 5 )
          v4 = v7 - 55;
      }
      else
      {
        v4 = v7 - 87;
      }
    }
    else
    {
      v4 = v7 - 48;
    }
    *(_BYTE *)(a1 + (i >> 1)) = v4 | (16 * v3);
  }
  return a3 / 2;
}
// 2D15C: variable 'v4' is possibly undefined
// 2D15C: variable 'v3' is possibly undefined

//----- (0002D188) --------------------------------------------------------
int __fastcall valid_hex(const char *a1)
{
  size_t v2; // r0
  const char *v3; // r2
  const char *v4; // r0
  int v5; // t1
  int v6; // r2
  int v7; // r0
  int v8; // r1
  char v10[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( !a1 )
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "Null string passed to valid_hex");
    V_UNLOCK();
    v6 = 213;
    v7 = g_zc;
    LOWORD(v8) = 3136;
    goto LABEL_9;
  }
  v2 = strlen(a1);
  if ( v2 )
  {
    if ( *(int *)&aGetValueFromLo[4 * *(unsigned __int8 *)a1 + 136] >= 0 )
    {
      v3 = a1;
      v4 = &a1[v2 - 1];
      while ( v3 != v4 )
      {
        v5 = *(unsigned __int8 *)++v3;
        if ( *(int *)&aGetValueFromLo[4 * v5 + 136] < 0 )
          goto LABEL_8;
      }
      return 1;
    }
LABEL_8:
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "Invalid charpassed to valid_hex");
    V_UNLOCK();
    v6 = 223;
    v7 = g_zc;
    LOWORD(v8) = (unsigned __int16)"/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/"
                                   "release/build/godminer-origin_godminer-new/util.c";
LABEL_9:
    HIWORD(v8) = (unsigned int)"/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/rele"
                               "ase/build/godminer-origin_godminer-new/util.c" >> 16;
    zlog(v7, v8, 134, "valid_hex", 9, v6, 20, v10);
    return 0;
  }
  return 1;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0002D2B8) --------------------------------------------------------
int __fastcall valid_ascii(const char *a1)
{
  signed int v2; // r0
  const char *v3; // r2
  int v4; // t1
  int v5; // r0
  int v6; // r1
  int v8; // r2
  char v9[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( !a1 )
  {
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, "Null string passed to valid_ascii");
    V_UNLOCK();
    v8 = 238;
    v5 = g_zc;
    LOWORD(v6) = 3136;
LABEL_9:
    HIWORD(v6) = (unsigned int)"/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/rele"
                               "ase/build/godminer-origin_godminer-new/util.c" >> 16;
    zlog(v5, v6, 134, "valid_ascii", 11, v8, 20, v9);
    return 0;
  }
  v2 = strlen(a1);
  if ( !v2 )
  {
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, "Zero length string passed to valid_ascii");
    V_UNLOCK();
    v8 = 244;
LABEL_8:
    v5 = g_zc;
    LOWORD(v6) = (unsigned __int16)"/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/"
                                   "release/build/godminer-origin_godminer-new/util.c";
    goto LABEL_9;
  }
  v3 = a1;
  do
  {
    v4 = *(unsigned __int8 *)v3++;
    if ( (unsigned int)(v4 - 32) > 0x5E )
    {
      V_LOCK();
      logfmt_raw(v9, 0x1000u, 0, "Invalid char passed to valid_ascii");
      V_UNLOCK();
      v8 = 253;
      goto LABEL_8;
    }
  }
  while ( v3 - a1 < v2 );
  return 1;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0002D400) --------------------------------------------------------
char *tq_new()
{
  char *v0; // r0
  char *v1; // r4

  v0 = (char *)calloc(1u, 0x58u);
  v1 = v0;
  if ( v0 )
  {
    *(_DWORD *)v0 = v0;
    *((_DWORD *)v0 + 1) = v0;
    pthread_mutex_init((pthread_mutex_t *)(v0 + 12), 0);
    pthread_cond_init((pthread_cond_t *)(v1 + 40), 0);
  }
  return v1;
}

//----- (0002D440) --------------------------------------------------------
void __fastcall tq_free(char *a1)
{
  int v2; // r2
  _DWORD *v3; // r0
  _DWORD *v4; // r4
  _DWORD *v5; // r3
  bool v6; // zf

  if ( a1 )
  {
    v2 = **(_DWORD **)a1;
    v3 = (_DWORD *)(*(_DWORD *)a1 - 4);
    v4 = (_DWORD *)(v2 - 4);
    if ( a1 != *(char **)a1 )
    {
      do
      {
        v5 = (_DWORD *)v3[2];
        *(_DWORD *)(v2 + 4) = v5;
        *v5 = v2;
        free(v3);
        v3 = v4;
        v2 = v4[1];
        v6 = v4 + 1 == (_DWORD *)a1;
        v4 = (_DWORD *)(v2 - 4);
      }
      while ( !v6 );
    }
    pthread_cond_destroy((pthread_cond_t *)(a1 + 40));
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 12));
    free(a1);
  }
}

//----- (0002D4A8) --------------------------------------------------------
int __fastcall tq_freeze(int a1)
{
  pthread_mutex_t *v1; // r5

  v1 = (pthread_mutex_t *)(a1 + 12);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 12));
  *(_BYTE *)(a1 + 8) = 1;
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  return pthread_mutex_unlock(v1);
}

//----- (0002D4D8) --------------------------------------------------------
int __fastcall tq_thaw(int a1)
{
  pthread_mutex_t *v1; // r5

  v1 = (pthread_mutex_t *)(a1 + 12);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 12));
  *(_BYTE *)(a1 + 8) = 0;
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  return pthread_mutex_unlock(v1);
}

//----- (0002D508) --------------------------------------------------------
int __fastcall tq_push(int a1, int a2)
{
  _DWORD *v4; // r0
  _DWORD *v5; // r4
  int v6; // r7
  _DWORD *v7; // r6
  _DWORD *v8; // r3

  v4 = calloc(1u, 0xCu);
  v5 = v4;
  if ( !v4 )
    return 0;
  *v4 = a2;
  v7 = v4 + 1;
  v4[1] = v4 + 1;
  v4[2] = v4 + 1;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 12));
  if ( *(_BYTE *)(a1 + 8) )
  {
    v6 = 0;
    free(v5);
  }
  else
  {
    v8 = *(_DWORD **)(a1 + 4);
    v6 = 1;
    v5[1] = a1;
    *(_DWORD *)(a1 + 4) = v7;
    v5[2] = v8;
    *v8 = v7;
  }
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 12));
  return v6;
}

//----- (0002D594) --------------------------------------------------------
int __fastcall tq_pop(int a1, const struct timespec *a2)
{
  pthread_mutex_t *v2; // r6
  int *v5; // r4
  _DWORD *v6; // r2
  int v7; // r1
  int v8; // r5
  pthread_cond_t *v10; // r0
  int v11; // r0

  v2 = (pthread_mutex_t *)(a1 + 12);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 12));
  v5 = *(int **)a1;
  if ( a1 == *(_DWORD *)a1 )
  {
    v10 = (pthread_cond_t *)(a1 + 40);
    if ( a2 )
      v11 = pthread_cond_timedwait(v10, v2, a2);
    else
      v11 = pthread_cond_wait(v10, v2);
    if ( v11 )
    {
      v8 = 0;
      goto LABEL_3;
    }
    if ( v5 == *(int **)a1 )
    {
      v8 = 0;
      goto LABEL_3;
    }
    v5 = *(int **)a1;
  }
  v6 = (_DWORD *)v5[1];
  v7 = *v5;
  v8 = *(v5 - 1);
  *(_DWORD *)(v7 + 4) = v6;
  *v6 = v7;
  *v5 = 0;
  v5[1] = 0;
  free(v5 - 1);
LABEL_3:
  pthread_mutex_unlock(v2);
  return v8;
}

//----- (0002D640) --------------------------------------------------------
int __fastcall cgtime(struct timeval *a1)
{
  return gettimeofday(a1, 0);
}

//----- (0002D648) --------------------------------------------------------
int __fastcall cgtimer_sub(int *a1, int *a2, _DWORD *a3)
{
  int v3; // r3
  int v4; // r12
  int result; // r0
  int v6; // r1
  int v7; // r3
  bool v8; // nf
  int v9; // r1
  int v10; // r3

  v3 = a1[1];
  v4 = a2[1];
  result = *a1;
  v6 = *a2;
  v7 = v3 - v4;
  v8 = v7 < 0;
  a3[1] = v7;
  v9 = result - v6;
  v10 = v7 + (v7 < 0 ? 0xF4000 : 0);
  *a3 = v9;
  if ( v8 )
  {
    *a3 = v9 - 1;
    a3[1] = v10 + 576;
  }
  return result;
}

//----- (0002D680) --------------------------------------------------------
bool __fastcall get_server_port_from_url(char *a1, char *a2, _WORD *a3)
{
  char *v6; // r0
  char *v7; // r6
  _BOOL4 v8; // r5
  int v10; // r9
  const char *v11; // r6
  int v12; // [sp+4h] [bp-8h] BYREF

  if ( !a1 )
    return 0;
  v6 = strchr(a1, 58);
  v7 = v6;
  v8 = a1 != v6;
  if ( !v6 )
    v8 = 0;
  if ( !v8 )
    return 0;
  v10 = v6 - a1;
  strncpy(a2, a1, v6 - a1);
  v11 = v7 + 1;
  a2[v10] = 0;
  if ( v11 - a1 >= strlen(a1) )
    return 0;
  sub_2C888(v11, &v12);
  *a3 = v12;
  return v8;
}

//----- (0002D720) --------------------------------------------------------
float *__fastcall find_min_and_max_float(float *result, int a2, float *a3, float *a4)
{
  float v4; // s14
  float v5; // s13
  float *v6; // r1
  float v7; // s15

  v4 = -INFINITY;
  v5 = INFINITY;
  if ( a2 > 0 )
  {
    v6 = &result[a2];
    do
    {
      v7 = *result++;
      if ( v7 < v5 )
        v5 = v7;
      if ( v7 > v4 )
        v4 = v7;
    }
    while ( result != v6 );
  }
  *a3 = v5;
  *a4 = v4;
  return result;
}

//----- (0002D76C) --------------------------------------------------------
int *__fastcall find_min_and_max_int(int *result, int a2, _DWORD *a3, _DWORD *a4)
{
  int v4; // lr
  int v5; // r4
  int *v6; // r1
  int v7; // r12
  int v8; // t1

  if ( a2 > 0 )
  {
    v4 = *result;
    if ( a2 == 1 )
    {
      v5 = *result;
    }
    else
    {
      v6 = &result[a2];
      v5 = *result++;
      do
      {
        v8 = *result++;
        v7 = v8;
        if ( v4 >= v8 )
          v4 = v7;
        if ( v5 < v7 )
          v5 = v7;
      }
      while ( result != v6 );
    }
    *a3 = v4;
    *a4 = v5;
  }
  return result;
}

//----- (0002D7BC) --------------------------------------------------------
int *__fastcall calc_mean(int *result, int a2)
{
  int *v2; // r12
  int v3; // r3
  int v4; // t1

  if ( a2 > 0 )
  {
    v2 = &result[a2];
    v3 = 0;
    do
    {
      v4 = *result++;
      v3 += v4;
    }
    while ( v2 != result );
  }
  return result;
}

//----- (0002D808) --------------------------------------------------------
int __fastcall calc_stdd(double a1)
{
  double v1; // d4
  int v2; // r2
  int *v3; // r3
  int v4; // t1
  double v5; // d6
  int v6; // s14

  v1 = (double)SHIDWORD(a1);
  if ( *(__int64 *)&a1 <= 0 )
  {
    v5 = 0.0;
  }
  else
  {
    HIDWORD(a1) = LODWORD(a1) + 4 * HIDWORD(a1);
    v2 = 0;
    v3 = (int *)LODWORD(a1);
    do
    {
      v4 = *v3++;
      v2 += v4;
    }
    while ( (int *)HIDWORD(a1) != v3 );
    v5 = 0.0;
    do
    {
      v6 = *(_DWORD *)LODWORD(a1);
      LODWORD(a1) += 4;
      v5 = v5 + ((double)v6 - (double)v2 / v1) * ((double)v6 - (double)v2 / v1);
    }
    while ( v3 != (int *)LODWORD(a1) );
  }
  if ( v5 / v1 < 0.0 )
    a1 = sqrt(a1);
  return LODWORD(a1);
}

//----- (0002D8A0) --------------------------------------------------------
bool __fastcall check_value_valid_with_stdd(double a1, int a2)
{
  double v2; // d0
  int *v4; // r3
  int v5; // r2
  int v6; // t1
  double v7; // d7
  double v8; // d10
  double v9; // d8
  char v11[4096]; // [sp+28h] [bp-1000h] BYREF

  if ( *(__int64 *)&a1 <= 0 )
  {
    v7 = 0.0;
  }
  else
  {
    v4 = (int *)LODWORD(a1);
    v5 = 0;
    do
    {
      v6 = *v4++;
      v5 += v6;
    }
    while ( (int *)(LODWORD(a1) + 4 * HIDWORD(a1)) != v4 );
    v7 = (double)v5;
  }
  v8 = v7 / (double)SHIDWORD(a1);
  calc_stdd(a1);
  V_LOCK();
  v9 = (double)a2;
  logfmt_raw(
    v11,
    0x1000u,
    0,
    "mean:%.4f, stdd:%.4f, min_value:%.4f, max_value:%.4f, to_check:%.4f",
    v8,
    v2,
    v8 - v2,
    v2 + v8,
    v9);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/util.c",
    134,
    "check_value_valid_with_stdd",
    27,
    545,
    20,
    v11);
  return v9 >= v8 - v2 && v9 <= v2 + v8 || v2 < 2.0;
}
// 2D930: variable 'v2' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0002D9CC) --------------------------------------------------------
int __fastcall sub_2D9CC(int a1, int a2, int a3, int a4)
{
  int v4; // r6
  int v5; // r7
  signed int v10; // r1
  signed int v11; // r8
  int v12; // r0
  signed int v13; // r1
  int result; // r0
  int *v15; // r3
  int v16; // r8
  int v17; // r9
  int v18; // r2
  int v19; // lr
  int v20; // r1
  int v21; // r12

  v4 = a3 - a2;
  v5 = a2 - a1;
  sub_DD144(a2 - a1, a3 - a2);
  v11 = v10;
  if ( v10 )
  {
    v12 = v4;
    while ( 1 )
    {
      sub_DD144(v12, v11);
      v12 = v11;
      if ( !v13 )
        break;
      v11 = v13;
    }
  }
  else
  {
    v11 = v4;
  }
  result = sub_DCEB0(a3 - a1, v11);
  if ( v11 > 0 )
  {
    v15 = (int *)(a4 + 4 * a2);
    v16 = v11 + a2;
    v17 = a2;
    do
    {
      v18 = v17;
      if ( result > 0 )
      {
        v19 = *v15;
        v20 = 0;
        do
        {
          ++v20;
          if ( a2 > v18 )
            v18 += v4;
          else
            v18 -= v5;
          v21 = *(_DWORD *)(a4 + 4 * v18);
          *(_DWORD *)(a4 + 4 * v18) = v19;
          *v15 = v21;
          v19 = v21;
        }
        while ( result != v20 );
      }
      ++v17;
      ++v15;
    }
    while ( v16 != v17 );
  }
  return result;
}
// 2D9F4: variable 'v10' is possibly undefined
// 2DA04: variable 'v13' is possibly undefined

//----- (0002DA94) --------------------------------------------------------
int __fastcall sub_2DA94(int a1, _BYTE *a2, const char **a3, int *a4, int a5)
{
  const char *v6; // r7
  char *v7; // r0
  size_t v8; // r5
  const char *v9; // r4
  int v10; // r8
  int v11; // r11
  int v12; // r3
  bool v13; // zf
  const char **v14; // r6
  const char *v15; // r2
  int *v16; // r1
  int v17; // r3
  int result; // r0
  int v19; // r3
  int v20; // [sp+0h] [bp-1Ch]
  int v23; // [sp+Ch] [bp-10h]
  int v24; // [sp+10h] [bp-Ch]

  v6 = (const char *)off_1063B8;
  v24 = optind;
  v23 = ++optind;
  v7 = strchr((const char *)off_1063B8, 61);
  v20 = (int)v7;
  if ( v7 )
  {
    v8 = v7 - v6;
    v20 = (int)(v7 + 1);
  }
  else
  {
    v8 = strlen(v6);
  }
  v9 = *a3;
  if ( *a3 )
  {
    v10 = -1;
    v11 = 0;
    do
    {
      if ( !strncmp(v6, v9, v8) )
      {
        if ( strlen(v9) == v8 )
          goto LABEL_16;
        if ( v8 == 1 )
          v12 = a5 & 1;
        else
          v12 = 0;
        if ( !v12 )
        {
          v13 = v10 == -1;
          v10 = v11;
          if ( !v13 )
            goto LABEL_32;
        }
      }
      ++v11;
      v9 = a3[4 * v11];
    }
    while ( v9 );
    if ( v10 == -1 )
      goto LABEL_31;
    v11 = v10;
LABEL_16:
    v14 = &a3[4 * v11];
    v15 = v14[1];
    v16 = (int *)v14[2];
    if ( v15 )
    {
      if ( (unsigned int)(v15 - 1) <= 1 )
      {
        if ( v20 )
        {
          optarg = v20;
        }
        else if ( v15 == (const char *)1 )
        {
          optarg = *(_DWORD *)(a1 + 4 * v23);
          optind = v24 + 2;
          if ( !optarg )
          {
            if ( v16 )
              v19 = 0;
            else
              v19 = (int)v14[3];
            optopt = v19;
            optind = v23;
            if ( *a2 != 58 )
              return 63;
            return 58;
          }
        }
      }
    }
    else
    {
      v17 = v20;
      if ( v20 )
      {
        if ( v16 )
          optopt = 0;
        else
          v17 = (int)v14[3];
        if ( !v16 )
          optopt = v17;
        if ( *a2 != 58 )
          return 63;
        return 58;
      }
    }
    if ( a4 )
      *a4 = v11;
    result = (int)v14[3];
    if ( v16 )
    {
      *v16 = result;
      return 0;
    }
  }
  else
  {
LABEL_31:
    if ( a5 )
    {
      optind = v24;
      return -1;
    }
    else
    {
LABEL_32:
      optopt = 0;
      return 63;
    }
  }
  return result;
}
// 1063B8: using guessed type _UNKNOWN *off_1063B8;
// 1063BC: using guessed type int optind;
// 1063C0: using guessed type int optopt;
// 11B080: using guessed type int optarg;

//----- (0002DCAC) --------------------------------------------------------
int __fastcall sub_2DCAC(int a1, int a2, char *a3, const char **a4, int *a5, char a6)
{
  char v6; // r7
  int v9; // r0
  int v10; // r3
  int v11; // r3
  int v12; // r2
  int v13; // r2
  char *v14; // r5
  int v15; // r1
  int v16; // r6
  int v17; // r5
  char *v18; // r3
  int v19; // r6
  void *v20; // r7
  int v21; // r5
  char *v22; // r0
  int v23; // r1
  _BOOL4 v24; // r2
  int v25; // r3
  char *v26; // r0
  int v27; // r8
  int v28; // r0
  int v29; // r5
  int v30; // r6
  int v32; // r3
  int v33; // r2
  int v34; // r1
  int v35; // r5
  int v36; // r2
  char *s; // [sp+8h] [bp-14h]
  char *v38; // [sp+Ch] [bp-10h]
  int v39; // [sp+Ch] [bp-10h]

  s = a3;
  v6 = a6;
  if ( !a3 )
    return -1;
  v9 = dword_1063C4;
  if ( dword_1063C4 == -1 )
  {
    v9 = getenv("POSIXLY_CORRECT") != 0;
    dword_1063C4 = v9;
  }
  v10 = (unsigned __int8)*s;
  if ( v9 )
  {
    v6 = a6 & 0xFE;
    if ( (((_BYTE)v10 - 43) & 0xFD) != 0 )
      goto LABEL_6;
LABEL_37:
    ++s;
    goto LABEL_38;
  }
  if ( v10 != 43 )
  {
    if ( v10 != 45 )
    {
LABEL_6:
      v11 = optind;
      if ( optind )
        goto LABEL_7;
      goto LABEL_39;
    }
    v6 = a6 | 2;
    goto LABEL_37;
  }
  v6 = a6 & 0xFE;
  ++s;
LABEL_38:
  v11 = optind;
  if ( optind )
  {
LABEL_7:
    v12 = optreset;
    optarg = 0;
    if ( !optreset )
      goto LABEL_8;
    goto LABEL_40;
  }
LABEL_39:
  v12 = 1;
  optreset = 1;
  optind = 1;
  optarg = v11;
LABEL_40:
  dword_1063C8 = -1;
  dword_1063CC = -1;
LABEL_8:
  if ( !v12 )
    goto LABEL_18;
  while ( 1 )
  {
    v13 = optind;
    optreset = 0;
    if ( optind >= a1 )
    {
      v29 = dword_1063C8;
      v30 = dword_1063CC;
      off_1063B8 = "";
      if ( dword_1063C8 == -1 )
      {
        if ( dword_1063CC != -1 )
          optind = dword_1063CC;
      }
      else
      {
        sub_2D9CC(dword_1063CC, dword_1063C8, optind, a2);
        optind -= v29 - v30;
      }
      goto LABEL_57;
    }
    v14 = *(char **)(a2 + 4 * optind);
    v15 = (unsigned __int8)*v14;
    off_1063B8 = v14;
    if ( v15 == 45 )
      break;
LABEL_11:
    off_1063B8 = "";
    if ( (v6 & 2) != 0 )
    {
      optind = v13 + 1;
      optarg = (int)v14;
      return 1;
    }
    if ( (v6 & 1) == 0 )
      return -1;
    v16 = dword_1063CC;
    if ( dword_1063CC == -1 )
    {
      dword_1063CC = v13;
      optind = v13 + 1;
LABEL_18:
      v18 = (char *)off_1063B8;
      v19 = *(unsigned __int8 *)off_1063B8;
      if ( *(_BYTE *)off_1063B8 )
        goto LABEL_19;
    }
    else
    {
      v17 = dword_1063C8;
      if ( dword_1063C8 == -1 )
      {
        optind = v13 + 1;
        goto LABEL_18;
      }
      sub_2D9CC(dword_1063CC, dword_1063C8, v13, a2);
      dword_1063C8 = -1;
      dword_1063CC = optind - (v17 - v16);
      ++optind;
      if ( !optreset )
        goto LABEL_18;
    }
  }
  v19 = (unsigned __int8)v14[1];
  if ( v14[1] )
  {
    v27 = dword_1063CC;
    if ( dword_1063CC != -1 )
    {
LABEL_44:
      if ( dword_1063C8 == -1 )
        dword_1063C8 = v13;
      if ( !v19 )
        goto LABEL_65;
    }
    v18 = v14 + 1;
    off_1063B8 = v14 + 1;
    if ( v19 != 45 )
    {
LABEL_19:
      if ( !a4 || v18 == *(char **)(a2 + 4 * optind) )
        goto LABEL_23;
      if ( v19 != 45 )
      {
        if ( (v6 & 4) == 0 )
          goto LABEL_23;
        v28 = v19 != 58 && strchr(s, v19) != 0;
        goto LABEL_52;
      }
LABEL_51:
      v28 = 0;
      off_1063B8 = v18 + 1;
LABEL_52:
      v21 = sub_2DA94(a2, s, a4, a5, v28);
      if ( v21 != -1 )
      {
LABEL_53:
        off_1063B8 = "";
        return v21;
      }
      v18 = (char *)off_1063B8;
      v19 = *(unsigned __int8 *)off_1063B8;
LABEL_23:
      v20 = v18 + 1;
      off_1063B8 = v18 + 1;
      v21 = v19;
      if ( v19 == 58 )
        goto LABEL_99;
      if ( v19 == 45 )
      {
        v14 = v18;
        goto LABEL_66;
      }
      v38 = v18;
      v22 = strchr(s, v19);
      v18 = v38;
      if ( !v22 )
      {
LABEL_99:
        if ( !v18[1] )
          ++optind;
LABEL_78:
        optopt = v21;
        return 63;
      }
      v23 = (unsigned __int8)v22[1];
      v24 = v19 == 87;
      if ( !a4 )
        v24 = 0;
      if ( v24 && v23 == 59 )
      {
        if ( !v38[1] )
        {
          v25 = optind + 1;
          optind = v25;
          if ( v25 >= a1 )
          {
            optopt = 87;
            off_1063B8 = "";
            if ( *s != 58 )
              return 63;
            return 58;
          }
          off_1063B8 = *(_UNKNOWN **)(a2 + 4 * v25);
        }
        v21 = sub_2DA94(a2, s, a4, a5, 0);
        goto LABEL_53;
      }
LABEL_69:
      if ( v23 != 58 )
      {
        if ( !*(_BYTE *)v20 )
          ++optind;
        return v21;
      }
      v32 = optind;
      optarg = 0;
      v33 = optind + 1;
      if ( *(_BYTE *)v20 )
      {
        optarg = (int)v20;
      }
      else if ( v22[2] != 58 )
      {
        ++optind;
        if ( a1 <= v33 )
        {
          optopt = v21;
          off_1063B8 = "";
          if ( *s != 58 )
            return 63;
          return 58;
        }
        v34 = *(_DWORD *)(a2 + 4 * v33);
        v33 = v32 + 2;
        optarg = v34;
      }
      optind = v33;
      off_1063B8 = "";
      return v21;
    }
    if ( v14[2] )
    {
      if ( !a4 )
      {
        v20 = v14 + 2;
        ++v14;
        off_1063B8 = v20;
        goto LABEL_66;
      }
      if ( v18 == *(char **)(a2 + 4 * optind) )
        goto LABEL_23;
      goto LABEL_51;
    }
    v35 = dword_1063C8;
    v36 = v13 + 1;
    optind = v36;
    off_1063B8 = "";
    if ( dword_1063C8 != -1 )
    {
      sub_2D9CC(v27, dword_1063C8, v36, a2);
      optind -= v35 - v27;
    }
LABEL_57:
    dword_1063C8 = -1;
    dword_1063CC = -1;
    return -1;
  }
  v39 = optind;
  v26 = strchr(s, 45);
  v13 = v39;
  if ( !v26 )
    goto LABEL_11;
  v27 = dword_1063CC;
  if ( dword_1063CC != -1 )
    goto LABEL_44;
LABEL_65:
  v20 = v14 + 1;
  off_1063B8 = v14 + 1;
LABEL_66:
  if ( !v14[1] )
  {
    v22 = strchr(s, 45);
    if ( v22 )
    {
      v23 = (unsigned __int8)v22[1];
      v21 = 45;
      goto LABEL_69;
    }
  }
  if ( *(_BYTE *)v20 )
  {
    v21 = 45;
    goto LABEL_78;
  }
  return -1;
}
// 1063B8: using guessed type _UNKNOWN *off_1063B8;
// 1063BC: using guessed type int optind;
// 1063C0: using guessed type int optopt;
// 1063C4: using guessed type int dword_1063C4;
// 1063C8: using guessed type int dword_1063C8;
// 1063CC: using guessed type int dword_1063CC;
// 11B07C: using guessed type int optreset;
// 11B080: using guessed type int optarg;

//----- (0002E29C) --------------------------------------------------------
int __fastcall getopt(int a1, int a2, char *a3)
{
  return sub_2DCAC(a1, a2, a3, 0, 0, 0);
}

//----- (0002E2C0) --------------------------------------------------------
int __fastcall EVPX_EncryptInit_ex(int a1, int a2, char *a3, const char **a4, int *a5)
{
  return sub_2DCAC(a1, a2, a3, a4, a5, 1);
}

//----- (0002E2E0) --------------------------------------------------------
int __fastcall getopt_long_only(int a1, int a2, char *a3, const char **a4, int *a5)
{
  return sub_2DCAC(a1, a2, a3, a4, a5, 5);
}

//----- (0002E300) --------------------------------------------------------
int __fastcall sub_2E300(void *src, size_t n, const void **a3)
{
  return strbuffer_append_bytes(a3, src, n);
}

//----- (0002E314) --------------------------------------------------------
int __fastcall sub_2E314(void *src, size_t n, _DWORD *a3)
{
  int v4; // r12
  size_t v5; // r3

  v4 = a3[1];
  v5 = v4 + n;
  if ( v4 + n <= *a3 )
  {
    memcpy((void *)(a3[2] + v4), src, n);
    v5 = n + a3[1];
  }
  a3[1] = v5;
  return 0;
}

//----- (0002E358) --------------------------------------------------------
size_t __fastcall sub_2E358(const void *a1, size_t a2, FILE *s)
{
  size_t result; // r0

  result = fwrite(a1, a2, 1u, s) - 1;
  if ( result )
    return -1;
  return result;
}

//----- (0002E374) --------------------------------------------------------
int __fastcall sub_2E374(void *buf, size_t n, int *a3)
{
  int result; // r0

  result = n - write(*a3, buf, n);
  if ( result )
    return -1;
  return result;
}

//----- (0002E39C) --------------------------------------------------------
int __fastcall sub_2E39C(const char **a1, const char **a2)
{
  return strcmp(*a1, *a2);
}

//----- (0002E3A8) --------------------------------------------------------
int __fastcall sub_2E3A8(char *a1, int a2, int (__fastcall *a3)(const char *, int, int), int a4, unsigned int a5)
{
  unsigned int v9; // r8
  char *i; // r10
  char *v12; // r5
  bool v13; // zf
  int v14; // r1
  char *v15; // r0
  int v16; // r1
  unsigned int v17; // r3
  int v18; // [sp+0h] [bp-2Ch]
  int v19; // [sp+14h] [bp-18h] BYREF
  char s[20]; // [sp+18h] [bp-14h] BYREF

  v19 = 0;
  if ( a3("\"", 1, a4) )
    return -1;
  v9 = (unsigned int)&a1[a2];
  for ( i = a1; (unsigned int)i < v9; i = v12 )
  {
    v12 = utf8_iterate(i, v9 - (_DWORD)i, &v19);
    if ( !v12 )
      return -1;
    v13 = v19 == 34;
    if ( v19 != 34 )
      v13 = v19 == 92;
    v14 = v13;
    if ( v19 <= 31 )
      v14 |= 1u;
    if ( !v14 && ((v19 == 47) & (a5 >> 10)) == 0 && ((v19 > 127) & (a5 >> 6)) == 0 )
      continue;
    if ( a1 != i && a3(a1, i - a1, a4) )
      return -1;
    if ( i == v12 )
      return a3("\"", 1, a4);
    if ( v19 == 12 )
    {
      v16 = 2;
      v15 = "\\f";
      goto LABEL_26;
    }
    if ( v19 <= 12 )
    {
      switch ( v19 )
      {
        case 9:
          v15 = "\\t";
          v16 = 2;
          goto LABEL_26;
        case 10:
          v15 = "\\n";
          v16 = 2;
          goto LABEL_26;
        case 8:
          v15 = "\\b";
          v16 = 2;
          goto LABEL_26;
      }
LABEL_32:
      if ( v19 >= 0x10000 )
      {
        v17 = ((unsigned int)(v19 - 0x10000) >> 10) & 0x3FF | 0xD800;
        v18 = (v19 - 0x10000) & 0x3FF | 0xDC00;
        v19 -= 0x10000;
        snprintf(s, 0xDu, "\\u%04X\\u%04X", v17, v18);
        v15 = s;
        v16 = 12;
        goto LABEL_26;
      }
LABEL_33:
      snprintf(s, 0xDu, "\\u%04X");
      v15 = s;
      v16 = 6;
      goto LABEL_26;
    }
    if ( v19 == 34 )
    {
      v15 = "\\\"";
      v16 = 2;
      goto LABEL_26;
    }
    if ( v19 <= 34 )
    {
      if ( v19 == 13 )
      {
        v15 = "\\r";
        v16 = 2;
        goto LABEL_26;
      }
      goto LABEL_33;
    }
    if ( v19 == 47 )
    {
      v15 = "\\/";
      v16 = 2;
      goto LABEL_26;
    }
    if ( v19 != 92 )
      goto LABEL_32;
    v15 = "\\\\";
    v16 = 2;
LABEL_26:
    if ( a3(v15, v16, a4) )
      return -1;
    a1 = v12;
  }
  if ( a1 == i || !a3(a1, i - a1, a4) )
    return a3("\"", 1, a4);
  return -1;
}
// 2E548: conditional instruction was optimized away because %var_18.4 is in (E..21)

//----- (0002E630) --------------------------------------------------------
int __fastcall sub_2E630(char a1, int a2, int a3, int (__fastcall *a4)(char *, int, int), int a5)
{
  unsigned int v6; // r4
  int v7; // r5

  if ( (a1 & 0x1F) != 0 )
  {
    v6 = (a1 & 0x1F) * a2;
    if ( a4("\n", 1, a5) )
      return -1;
    if ( v6 )
    {
      while ( 1 )
      {
        v7 = v6 >= 0x20 ? 32 : v6;
        if ( a4("                                ", v7, a5) )
          break;
        v6 -= v7;
        if ( !v6 )
          return 0;
      }
      return -1;
    }
    return 0;
  }
  if ( !a3 || (a1 & 0x20) != 0 )
    return 0;
  return a4(" ", 1, a5);
}

//----- (0002E6E0) --------------------------------------------------------
int __fastcall sub_2E6E0(unsigned int *a1, const void *a2, char *s)
{
  void *v5; // r0

  snprintf(s, 0xBu, "%p", a2);
  if ( hashtable_get((int)a1, s) )
    return -1;
  v5 = json_null();
  return hashtable_set(a1, s, (unsigned int)v5);
}

//----- (0002E738) --------------------------------------------------------
int __fastcall sub_2E738(_DWORD *a1, int a2, int a3, unsigned int *a4, int (__fastcall *a5)(char *, int, int), int a6)
{
  unsigned int *v7; // r5
  int v8; // r9
  unsigned int v9; // r8
  char v11; // r10
  char *v12; // r3
  int v13; // r3
  int v14; // r7
  char *v16; // r5
  _DWORD *v17; // r0
  __int64 v18; // r0
  int v19; // r0
  int v20; // r3
  int v21; // r1
  int v22; // r11
  int v23; // r6
  int v24; // r10
  char *v25; // r9
  size_t v26; // r0
  bool v27; // zf
  int v28; // r0
  int v29; // r0
  unsigned int v30; // r10
  int v31; // r6
  _DWORD *v32; // r0
  bool v33; // cc
  char *v34; // r0
  int v35; // r5
  char *v36; // r10
  char *v37; // r9
  unsigned int v38; // r7
  char *v39; // t1
  int v40; // r10
  size_t v41; // r0
  char *v42; // [sp+8h] [bp-94h]
  _DWORD *v43; // [sp+8h] [bp-94h]
  int v44; // [sp+Ch] [bp-90h]
  int v45; // [sp+Ch] [bp-90h]
  int v46; // [sp+Ch] [bp-90h]
  int v47; // [sp+10h] [bp-8Ch]
  size_t nmemb; // [sp+14h] [bp-88h]
  int v49; // [sp+18h] [bp-84h]
  void *base; // [sp+1Ch] [bp-80h]
  void *basea; // [sp+1Ch] [bp-80h]
  unsigned int *v52; // [sp+20h] [bp-7Ch]
  char *v53; // [sp+24h] [bp-78h]
  int v54; // [sp+28h] [bp-74h]
  char s[104]; // [sp+34h] [bp-68h] BYREF

  if ( !a1 )
    return -1;
  v7 = a4;
  v8 = a2 & 0x10000;
  v9 = a2 & 0xFFFEFFFF;
  v11 = a2;
  switch ( *a1 )
  {
    case 0:
      v12 = ":";
      if ( (a2 & 0x20) == 0 )
        v12 = ": ";
      v42 = v12;
      if ( (a2 & 0x20) != 0 )
        v13 = 1;
      else
        v13 = 2;
      v44 = v13;
      v14 = sub_2E6E0(v7, a1, s);
      if ( v14 )
        return -1;
      v47 = json_object_iter(a1);
      if ( v8 )
      {
        if ( !v47 )
          goto LABEL_47;
      }
      else
      {
        if ( a5("{", 1, a6) )
          return -1;
        if ( !v47 )
        {
          hashtable_del(v7, s);
          return a5("}", 1, a6);
        }
      }
      v49 = a3 + 1;
      v14 = sub_2E630(v9, a3 + 1, 0, a5, a6);
      if ( v14 )
        return -1;
      if ( (v11 & 0x80) == 0 )
      {
        v22 = v44;
        v45 = a3;
        v23 = v47;
        base = (void *)v8;
        while ( 1 )
        {
          v24 = json_object_iter_next(a1, v23);
          v25 = (char *)json_object_iter_key(v23);
          v26 = strlen(v25);
          sub_2E3A8(v25, v26, (int (__fastcall *)(const char *, int, int))a5, a6, v9);
          v27 = a5(v42, v22, a6) == 0;
          v28 = v23;
          v23 = v24;
          if ( !v27 )
            return -1;
          v29 = json_object_iter_value(v28);
          if ( sub_2E738(v29, v9, v49, v7, a5, a6) )
            return -1;
          if ( !v24 )
          {
            v8 = (int)base;
            v14 = 0;
            if ( !sub_2E630(v9, v45, 0, a5, a6) )
              goto LABEL_65;
            return -1;
          }
          if ( a5((char *)&word_DEA70, 1, a6) || sub_2E630(v9, v49, 1, a5, a6) )
            return -1;
        }
      }
      nmemb = (size_t)json_object_size(a1);
      v34 = (char *)jsonp_malloc((void *)(4 * nmemb));
      basea = v34;
      if ( !v34 )
        return -1;
      v52 = v7;
      v35 = v47;
      v36 = v34 - 4;
      v53 = v34 - 4;
      do
      {
        *((_DWORD *)v36 + 1) = json_object_iter_key(v35);
        v36 += 4;
        v35 = json_object_iter_next(a1, v35);
      }
      while ( v35 );
      v7 = v52;
      qsort(basea, nmemb, 4u, (__compar_fn_t)sub_2E39C);
      if ( nmemb )
      {
        v54 = v8;
        v37 = v53;
        v38 = 0;
        do
        {
          v39 = (char *)*((_DWORD *)v37 + 1);
          v37 += 4;
          v40 = json_object_get(a1, v39);
          v41 = strlen(v39);
          sub_2E3A8(v39, v41, (int (__fastcall *)(const char *, int, int))a5, a6, v9);
          if ( a5(v42, v44, a6) || sub_2E738(v40, v9, v49, v52, a5, a6) )
          {
LABEL_70:
            v14 = -1;
            jsonp_free(basea);
            return v14;
          }
          v33 = nmemb - 1 > v38++;
          if ( v33 )
          {
            if ( a5((char *)&word_DEA70, 1, a6) || sub_2E630(v9, v49, 1, a5, a6) )
              goto LABEL_70;
          }
          else if ( sub_2E630(v9, a3, 0, a5, a6) )
          {
            goto LABEL_70;
          }
        }
        while ( nmemb != v38 );
        v14 = 0;
        v8 = v54;
      }
      jsonp_free(basea);
LABEL_65:
      hashtable_del(v7, s);
      if ( !v8 )
        return a5("}", 1, a6);
      return v14;
    case 1:
      v14 = sub_2E6E0(a4, a1, s);
      if ( v14 )
        return -1;
      v43 = json_array_size(a1);
      if ( v8 )
      {
        if ( !v43 )
        {
LABEL_47:
          hashtable_del(v7, s);
          return v14;
        }
      }
      else
      {
        if ( a5("[", 1, a6) )
          return -1;
        if ( !v43 )
        {
          hashtable_del(v7, s);
          return a5("]", 1, a6);
        }
      }
      v30 = sub_2E630(v9, a3 + 1, 0, a5, a6);
      if ( v30 )
        return -1;
      v46 = a3;
      v31 = a3 + 1;
      break;
    case 2:
      v16 = (char *)json_string_value(a1);
      v17 = json_string_length(a1);
      return sub_2E3A8(v16, (int)v17, (int (__fastcall *)(const char *, int, int))a5, a6, v9);
    case 3:
      v18 = json_integer_value((int)a1);
      v19 = snprintf(s, 0x64u, "%lld", v18);
      return a5(s, v19, a6);
    case 4:
      json_real_value();
      v21 = jsonp_dtostr(s, 0x64u, (unsigned __int16)v9 >> 11, v20);
      if ( v21 < 0 )
        return -1;
      return a5(s, v21, a6);
    case 5:
      return a5("true", 4, a6);
    case 6:
      return a5("false", 5, a6);
    case 7:
      return a5("null", 4, a6);
    default:
      return -1;
  }
  do
  {
    v32 = json_array_get(a1, v30);
    v14 = sub_2E738(v32, v9, v31, v7, a5, a6);
    if ( v14 )
      return -1;
    v33 = (unsigned int)v43 - 1 > v30++;
    if ( v33 )
    {
      if ( a5((char *)&word_DEA70, 1, a6) || sub_2E630(v9, v31, 1, a5, a6) )
        return -1;
    }
    else if ( sub_2E630(v9, v46, 0, a5, a6) )
    {
      return -1;
    }
  }
  while ( v43 != (_DWORD *)v30 );
  hashtable_del(v7, s);
  if ( !v8 )
    return a5("]", 1, a6);
  return v14;
}
// 2E768: control flows out of bounds to 2E76C
// 2E928: variable 'v20' is possibly undefined
// DEA70: using guessed type __int16 word_DEA70;

//----- (0002EEE4) --------------------------------------------------------
int __fastcall json_dump_callback(_DWORD *a1, int (__fastcall *a2)(char *, int, int), int a3, int a4)
{
  int v8; // r4
  unsigned int v10[8]; // [sp+Ch] [bp-20h] BYREF

  if ( (a4 & 0x200) == 0 && (!a1 || *a1 > 1u) || hashtable_init(v10) )
    return -1;
  v8 = sub_2E738(a1, a4, 0, v10, a2, a3);
  hashtable_close((int)v10);
  return v8;
}

//----- (0002EF5C) --------------------------------------------------------
_BYTE *__fastcall json_dumps(_DWORD *a1, int a2)
{
  _BYTE *v4; // r4
  const char *v6; // r0
  _DWORD v7[3]; // [sp+4h] [bp-Ch] BYREF

  v4 = (_BYTE *)strbuffer_init(v7);
  if ( v4 )
    return 0;
  if ( !json_dump_callback(a1, (int (__fastcall *)(char *, int, int))sub_2E300, (int)v7, a2) )
  {
    v6 = (const char *)strbuffer_value((int)v7);
    v4 = jsonp_strdup(v6);
  }
  strbuffer_close((int)v7);
  return v4;
}

//----- (0002EFC8) --------------------------------------------------------
int __fastcall json_dumpb(_DWORD *a1, int a2, int a3, int a4)
{
  int v5; // [sp+4h] [bp-Ch] BYREF
  int v6; // [sp+8h] [bp-8h]
  int v7; // [sp+Ch] [bp-4h]

  v7 = a2;
  v5 = a3;
  v6 = 0;
  if ( json_dump_callback(a1, (int (__fastcall *)(char *, int, int))sub_2E314, (int)&v5, a4) )
    return 0;
  else
    return v6;
}

//----- (0002F004) --------------------------------------------------------
int __fastcall json_dumpf(_DWORD *a1, int a2, int a3)
{
  return json_dump_callback(a1, (int (__fastcall *)(char *, int, int))sub_2E358, a2, a3);
}

//----- (0002F018) --------------------------------------------------------
int __fastcall json_dump_file(_DWORD *a1, int a2, int a3)
{
  FILE *v5; // r4
  int v6; // r5

  v5 = (FILE *)fopen64(a2, 940972);
  if ( !v5 )
    return -1;
  v6 = json_dump_callback(a1, (int (__fastcall *)(char *, int, int))sub_2E358, (int)v5, a3);
  if ( fclose(v5) )
    return -1;
  return v6;
}
// 1EA0C: using guessed type int __fastcall fopen64(_DWORD, _DWORD);

//----- (0002F07C) --------------------------------------------------------
int __fastcall json_dumpfd(_DWORD *a1, int a2, int a3)
{
  int v4; // [sp+4h] [bp-8h] BYREF

  v4 = a2;
  return json_dump_callback(a1, (int (__fastcall *)(char *, int, int))sub_2E374, (int)&v4, a3);
}

//----- (0002F0A8) --------------------------------------------------------
char *__fastcall sub_2F0A8(char *a1, char *s)
{
  size_t v4; // r0

  v4 = strlen(s);
  if ( v4 <= 0x4F )
    return strncpy(a1 + 12, s, v4 + 1);
  *((_WORD *)a1 + 6) = 11822;
  a1[14] = 46;
  return strncpy(a1 + 15, &s[v4 - 76], 0x4Du);
}

//----- (0002F10C) --------------------------------------------------------
char *__fastcall jsonp_error_init(char *result, char *a2)
{
  if ( result )
  {
    result[92] = 0;
    *((_DWORD *)result + 2) = 0;
    *(_DWORD *)result = -1;
    *((_DWORD *)result + 1) = -1;
    if ( a2 )
      return sub_2F0A8(result, a2);
    else
      result[12] = 0;
  }
  return result;
}

//----- (0002F14C) --------------------------------------------------------
char *__fastcall jsonp_error_set_source(char *a1, char *s)
{
  bool v2; // zf

  v2 = s == 0;
  if ( s )
    v2 = a1 == 0;
  if ( !v2 )
    return sub_2F0A8(a1, s);
  return a1;
}

//----- (0002F15C) --------------------------------------------------------
int jsonp_error_set(int result, int a2, int a3, int a4, char a5, char *format, ...)
{
  int v6; // r4
  va_list arg; // [sp+20h] [bp+14h] BYREF

  va_start(arg, format);
  v6 = result;
  if ( result )
  {
    if ( !*(_BYTE *)(result + 92) )
    {
      *(_DWORD *)result = a2;
      *(_DWORD *)(result + 4) = a3;
      *(_DWORD *)(result + 8) = a4;
      result = vsnprintf((char *)(result + 92), 0x9Fu, format, arg);
      *(_BYTE *)(v6 + 250) = 0;
      *(_BYTE *)(v6 + 251) = a5;
    }
  }
  return result;
}

//----- (0002F1C0) --------------------------------------------------------
int __fastcall jsonp_error_vset(int result, int a2, int a3, int a4, char a5, char *format, __gnuc_va_list arg)
{
  int v7; // r4

  v7 = result;
  if ( result )
  {
    if ( !*(_BYTE *)(result + 92) )
    {
      *(_DWORD *)result = a2;
      *(_DWORD *)(result + 4) = a3;
      *(_DWORD *)(result + 8) = a4;
      result = vsnprintf((char *)(result + 92), 0x9Fu, format, arg);
      *(_BYTE *)(v7 + 250) = 0;
      *(_BYTE *)(v7 + 251) = a5;
    }
  }
  return result;
}

//----- (0002F20C) --------------------------------------------------------
int __fastcall sub_2F20C(unsigned __int16 *a1, unsigned int a2, int a3)
{
  unsigned int v3; // r12
  unsigned __int16 *v4; // r4
  int v5; // r3
  int v6; // lr
  int v7; // r6
  int v8; // r5
  int v9; // r3
  int v10; // lr
  int v11; // r2
  int v12; // r3
  int v13; // r5
  int v14; // r2
  int v15; // r12
  int v16; // r2
  int v17; // lr
  int v18; // r3
  int v19; // r2
  int v20; // r2
  int v21; // r3
  unsigned __int16 *v22; // r4
  int v23; // r6
  int v24; // r5
  int v25; // r7
  int v26; // r2
  int v27; // r3
  int v28; // r12
  int v29; // lr
  int v30; // r2
  int v31; // lr
  int v32; // r3
  int v33; // r12
  int v34; // r2
  int v35; // r5
  int v36; // r2
  int v37; // r3
  int v38; // r2
  unsigned __int16 *v39; // r4
  int v40; // r6
  int v41; // r2
  int v42; // r7
  int v43; // r8
  int v44; // r3
  int v45; // r12
  int v46; // lr
  int v47; // r2
  int v48; // lr
  int v49; // r3
  int v50; // r12
  int v51; // r2
  int v52; // r5
  int v53; // r2
  int v54; // r3
  int v55; // r2
  int v56; // r12
  int v57; // r3
  int v58; // r12
  int v59; // lr
  int v60; // r3
  int v61; // r12
  int v62; // r12
  int v64; // r4

  v3 = a3 - 559038737 + a2;
  if ( ((unsigned __int8)a1 & 3) == 0 )
  {
    if ( a2 <= 0xC )
    {
      v5 = a3 - 559038737 + a2;
      v6 = v5;
    }
    else
    {
      v4 = a1 + 6;
      v5 = a3 - 559038737 + a2;
      v6 = v5;
      do
      {
        a2 -= 12;
        v7 = *((_DWORD *)v4 - 3);
        v8 = *((_DWORD *)v4 - 2);
        a1 = v4;
        v9 = v5 + *((_DWORD *)v4 - 1);
        v4 += 6;
        v10 = v6 + v8;
        v11 = (v7 - v9 + v3) ^ __ROR4__(v9, 28);
        v12 = v10 + v9;
        v13 = v11 + v12;
        v14 = (v10 - v11) ^ __ROR4__(v11, 26);
        v15 = v14 + v13;
        v16 = (v12 - v14) ^ __ROR4__(v14, 24);
        v17 = v16 + v15;
        v18 = (v13 - v16) ^ __ROR4__(v16, 16);
        v19 = v15 - v18;
        v3 = v18 + v17;
        v20 = v19 ^ __ROR4__(v18, 13);
        v21 = v17 - v20;
        v6 = v20 + v3;
        v5 = v21 ^ __ROR4__(v20, 28);
      }
      while ( a2 > 0xC );
    }
    switch ( a2 )
    {
      case 1u:
        goto LABEL_27;
      case 2u:
        goto LABEL_32;
      case 3u:
        v56 = (*(_DWORD *)a1 & 0xFFFFFF) + v3;
        goto LABEL_28;
      case 4u:
        v56 = v3 + *(_DWORD *)a1;
        goto LABEL_28;
      case 5u:
        v6 += *((unsigned __int8 *)a1 + 4);
        v56 = v3 + *(_DWORD *)a1;
        goto LABEL_28;
      case 6u:
        v6 += a1[2];
        v56 = v3 + *(_DWORD *)a1;
        goto LABEL_28;
      case 7u:
        v56 = v3 + *(_DWORD *)a1;
        v6 += *((_DWORD *)a1 + 1) & 0xFFFFFF;
        goto LABEL_28;
      case 8u:
        v6 += *((_DWORD *)a1 + 1);
        v56 = v3 + *(_DWORD *)a1;
        goto LABEL_28;
      case 9u:
        v64 = *((unsigned __int8 *)a1 + 8);
        goto LABEL_35;
      case 0xAu:
        v64 = a1[4];
        goto LABEL_35;
      case 0xBu:
        v5 += *((_DWORD *)a1 + 2) & 0xFFFFFF;
        v6 += *((_DWORD *)a1 + 1);
        v56 = v3 + *(_DWORD *)a1;
        goto LABEL_28;
      case 0xCu:
        v64 = *((_DWORD *)a1 + 2);
LABEL_35:
        v5 += v64;
        v6 += *((_DWORD *)a1 + 1);
        v56 = v3 + *(_DWORD *)a1;
        goto LABEL_28;
      default:
        return v5;
    }
  }
  if ( ((unsigned __int8)a1 & 1) == 0 )
  {
    if ( a2 <= 0xC )
    {
      v5 = a3 - 559038737 + a2;
      v6 = v5;
    }
    else
    {
      v22 = a1 + 6;
      v5 = a3 - 559038737 + a2;
      v6 = v5;
      do
      {
        v23 = *(v22 - 1);
        a2 -= 12;
        v24 = *(v22 - 2);
        v25 = *(v22 - 5);
        a1 = v22;
        v26 = *(v22 - 6);
        v22 += 6;
        v27 = v24 + (v23 << 16) + v5;
        v28 = (v26 + (v25 << 16) - v27 + v3) ^ __ROR4__(v27, 28);
        v29 = *(v22 - 10) + (*(v22 - 9) << 16) + v6;
        v30 = v29 - v28;
        v31 = v29 + v27;
        v32 = v30 ^ __ROR4__(v28, 26);
        v33 = v28 + v31;
        v34 = (v31 - v32) ^ __ROR4__(v32, 24);
        v35 = v34 + v32 + v33;
        v36 = (v33 - v34) ^ __ROR4__(v34, 16);
        v37 = v32 + v33 - v36;
        v3 = v36 + v35;
        v38 = v37 ^ __ROR4__(v36, 13);
        v6 = v38 + v3;
        v5 = (v35 - v38) ^ __ROR4__(v38, 28);
      }
      while ( a2 > 0xC );
    }
    switch ( a2 )
    {
      case 1u:
        goto LABEL_27;
      case 2u:
        goto LABEL_32;
      case 3u:
        v3 += *((unsigned __int8 *)a1 + 2) << 16;
LABEL_32:
        v56 = *a1 + v3;
        goto LABEL_28;
      case 4u:
        goto LABEL_50;
      case 5u:
        v6 += *((unsigned __int8 *)a1 + 4);
LABEL_50:
        v56 = *a1 + v3 + (a1[1] << 16);
        goto LABEL_28;
      case 6u:
        goto LABEL_44;
      case 7u:
        v6 += *((unsigned __int8 *)a1 + 6) << 16;
LABEL_44:
        v56 = *a1 + v3 + (a1[1] << 16);
        v6 += a1[2];
        goto LABEL_28;
      case 8u:
        goto LABEL_46;
      case 9u:
        v5 += *((unsigned __int8 *)a1 + 8);
LABEL_46:
        v6 += a1[2] + (a1[3] << 16);
        v56 = *a1 + v3 + (a1[1] << 16);
        goto LABEL_28;
      case 0xAu:
        goto LABEL_48;
      case 0xBu:
        v5 += *((unsigned __int8 *)a1 + 10) << 16;
LABEL_48:
        v6 += a1[2] + (a1[3] << 16);
        v56 = *a1 + v3 + (a1[1] << 16);
        v5 += a1[4];
        goto LABEL_28;
      case 0xCu:
        v5 += a1[4] + (a1[5] << 16);
        v6 += a1[2] + (a1[3] << 16);
        v56 = *a1 + v3 + (a1[1] << 16);
        goto LABEL_28;
      default:
        return v5;
    }
  }
  if ( a2 > 0xC )
  {
    v39 = a1 + 6;
    v5 = a3 - 559038737 + a2;
    v6 = v5;
    do
    {
      v40 = *((unsigned __int8 *)v39 - 2);
      a2 -= 12;
      v41 = *((unsigned __int8 *)v39 - 10);
      v42 = *((unsigned __int8 *)v39 - 3);
      a1 = v39;
      v43 = *((unsigned __int8 *)v39 - 11);
      v39 += 6;
      v44 = (v40 << 16) + (v42 << 8) + *((unsigned __int8 *)v39 - 16) + (*((unsigned __int8 *)v39 - 13) << 24) + v5;
      v45 = ((v41 << 16)
           + (v43 << 8)
           + *((unsigned __int8 *)v39 - 24)
           + (*((unsigned __int8 *)v39 - 21) << 24)
           - v44
           + v3)
          ^ __ROR4__(v44, 28);
      v46 = (*((unsigned __int8 *)v39 - 18) << 16)
          + (*((unsigned __int8 *)v39 - 19) << 8)
          + *((unsigned __int8 *)v39 - 20)
          + (*((unsigned __int8 *)v39 - 17) << 24)
          + v6;
      v47 = v46 - v45;
      v48 = v46 + v44;
      v49 = v47 ^ __ROR4__(v45, 26);
      v50 = v45 + v48;
      v51 = (v48 - v49) ^ __ROR4__(v49, 24);
      v52 = v51 + v49 + v50;
      v53 = (v50 - v51) ^ __ROR4__(v51, 16);
      v54 = v49 + v50 - v53;
      v3 = v53 + v52;
      v55 = v54 ^ __ROR4__(v53, 13);
      v6 = v55 + v3;
      v5 = (v52 - v55) ^ __ROR4__(v55, 28);
    }
    while ( a2 > 0xC );
  }
  else
  {
    v5 = a3 - 559038737 + a2;
    v6 = v5;
  }
  switch ( a2 )
  {
    case 1u:
      goto LABEL_27;
    case 2u:
      goto LABEL_26;
    case 3u:
      goto LABEL_25;
    case 4u:
      goto LABEL_24;
    case 5u:
      goto LABEL_23;
    case 6u:
      goto LABEL_22;
    case 7u:
      goto LABEL_21;
    case 8u:
      goto LABEL_20;
    case 9u:
      goto LABEL_19;
    case 0xAu:
      goto LABEL_18;
    case 0xBu:
      goto LABEL_17;
    case 0xCu:
      v5 += *((unsigned __int8 *)a1 + 11) << 24;
LABEL_17:
      v5 += *((unsigned __int8 *)a1 + 10) << 16;
LABEL_18:
      v5 += *((unsigned __int8 *)a1 + 9) << 8;
LABEL_19:
      v5 += *((unsigned __int8 *)a1 + 8);
LABEL_20:
      v6 += *((unsigned __int8 *)a1 + 7) << 24;
LABEL_21:
      v6 += *((unsigned __int8 *)a1 + 6) << 16;
LABEL_22:
      v6 += *((unsigned __int8 *)a1 + 5) << 8;
LABEL_23:
      v6 += *((unsigned __int8 *)a1 + 4);
LABEL_24:
      v3 += *((unsigned __int8 *)a1 + 3) << 24;
LABEL_25:
      v3 += *((unsigned __int8 *)a1 + 2) << 16;
LABEL_26:
      v3 += *((unsigned __int8 *)a1 + 1) << 8;
LABEL_27:
      v56 = *(unsigned __int8 *)a1 + v3;
LABEL_28:
      v57 = (v5 ^ v6) - __ROR4__(v6, 18);
      v58 = (v56 ^ v57) - __ROR4__(v57, 21);
      v59 = (v6 ^ v58) - __ROR4__(v58, 7);
      v60 = (v57 ^ v59) - __ROR4__(v59, 16);
      v61 = (v58 ^ v60) - __ROR4__(v60, 28);
      v62 = (v59 ^ v61) - __ROR4__(v61, 18);
      v5 = (v60 ^ v62) - __ROR4__(v62, 8);
      break;
    default:
      return v5;
  }
  return v5;
}
// 2F2BC: control flows out of bounds to 2F2C0
// 2F3A4: control flows out of bounds to 2F3A8
// 2F4C8: control flows out of bounds to 2F4CC

//----- (0002F750) --------------------------------------------------------
int __fastcall sub_2F750(int a1, int *a2, char *s2, int a4)
{
  int v4; // r4

  v4 = *a2;
  if ( *a2 == a1 + 12 && v4 == a2[1] )
    return 0;
  while ( *(_DWORD *)(v4 + 16) != a4 || strcmp((const char *)(v4 + 24), s2) )
  {
    if ( a2[1] == v4 )
      return 0;
    v4 = *(_DWORD *)(v4 + 4);
  }
  return v4;
}

//----- (0002F7C4) --------------------------------------------------------
void __fastcall sub_2F7C4(int a1)
{
  _DWORD *v1; // r6
  _DWORD *v2; // r4
  _DWORD *v3; // r0
  _DWORD *v4; // r5
  unsigned int *v5; // r3
  unsigned int v6; // r2
  unsigned int v7; // r2
  void *v8; // r0

  v1 = (_DWORD *)(a1 + 12);
  v2 = *(_DWORD **)(a1 + 16);
  if ( v2 != (_DWORD *)(a1 + 12) )
  {
    do
    {
      v3 = (_DWORD *)v2[5];
      v4 = (_DWORD *)v2[1];
      if ( v3 )
      {
        v5 = v3 + 1;
        if ( v3[1] != -1 )
        {
          __dmb(0xBu);
          do
          {
            v6 = __ldrex(v5);
            v7 = v6 - 1;
          }
          while ( __strex(v7, v5) );
          if ( !v7 )
            json_delete(v3);
        }
      }
      v8 = v2;
      v2 = v4;
      jsonp_free(v8);
    }
    while ( v4 != v1 );
  }
}

//----- (0002F834) --------------------------------------------------------
int __fastcall hashtable_init(_DWORD *a1)
{
  _DWORD *v2; // r0
  int v3; // r12
  _DWORD *v4; // r3
  _DWORD *v5; // r2

  *a1 = 0;
  a1[2] = 3;
  v2 = jsonp_malloc((void *)0x40);
  a1[1] = v2;
  if ( !v2 )
    return -1;
  v3 = a1[2];
  v4 = a1 + 3;
  a1[4] = a1 + 3;
  a1[3] = a1 + 3;
  a1[6] = a1 + 5;
  a1[5] = a1 + 5;
  if ( 1 << v3 )
  {
    v5 = (_DWORD *)((char *)v2 + (8 << v3));
    do
    {
      v2[1] = v4;
      *v2 = v4;
      v2 += 2;
    }
    while ( v2 != v5 );
  }
  return 0;
}

//----- (0002F8B0) --------------------------------------------------------
void __fastcall hashtable_close(int a1)
{
  sub_2F7C4(a1);
  jsonp_free(*(void **)(a1 + 4));
}

//----- (0002F8C8) --------------------------------------------------------
int __fastcall hashtable_set(unsigned int *a1, char *a2, unsigned int a3)
{
  unsigned int v4; // r8
  unsigned int v7; // r8
  unsigned int **v8; // r5
  unsigned int *v9; // r1
  unsigned int **v10; // r3
  unsigned int *v11; // r3
  int v12; // r8
  unsigned int v13; // lr
  unsigned int *v14; // r12
  int v15; // r0
  unsigned int *v16; // r2
  unsigned int **v17; // r0
  unsigned int v18; // r2
  size_t v19; // r10
  int v20; // r9
  int *v21; // r5
  int v22; // r0
  int v23; // r8
  _DWORD *v24; // r0
  unsigned int *v25; // r3
  unsigned int v26; // r2
  unsigned int v27; // r2
  void *v29; // r0
  unsigned int *v30; // r8
  unsigned int *v31; // r3
  unsigned int v32; // r2
  unsigned int v33; // r1
  int v34; // r3

  v4 = a1[2];
  if ( *a1 >> v4 )
  {
    v7 = v4 + 1;
    v8 = (unsigned int **)jsonp_malloc((void *)(8 << v7));
    if ( !v8 )
      return -1;
    jsonp_free((void *)a1[1]);
    a1[1] = (unsigned int)v8;
    a1[2] = v7;
    v9 = a1 + 3;
    if ( 1 << v7 )
    {
      v10 = v8;
      do
      {
        v10[1] = v9;
        *v10 = v9;
        v10 += 2;
      }
      while ( (unsigned int **)((char *)v8 + (8 << v7)) != v10 );
    }
    v11 = (unsigned int *)a1[4];
    a1[3] = (unsigned int)v9;
    v12 = ~(-1 << v7);
    a1[4] = (unsigned int)v9;
    if ( v11 != v9 )
    {
      do
      {
        while ( 1 )
        {
          v14 = (unsigned int *)v11[1];
          v15 = v11[4] & v12;
          v16 = v8[2 * v15];
          v17 = &v8[2 * v15];
          if ( v16 == v9 && v9 == v17[1] )
            break;
          v13 = *v16;
          v11[1] = (unsigned int)v16;
          *v11 = v13;
          *(_DWORD *)(*v16 + 4) = v11;
          *v16 = (unsigned int)v11;
          *v17 = v11;
          v11 = v14;
          if ( v14 == v9 )
            goto LABEL_12;
        }
        v18 = a1[3];
        v11[1] = (unsigned int)v9;
        *v11 = v18;
        *(_DWORD *)(a1[3] + 4) = v11;
        a1[3] = (unsigned int)v11;
        v17[1] = v11;
        *v17 = v11;
        v11 = v14;
      }
      while ( v14 != v9 );
LABEL_12:
      v8 = (unsigned int **)a1[1];
      v12 = ~(-1 << a1[2]);
    }
  }
  else
  {
    v8 = (unsigned int **)a1[1];
    v12 = ~(-1 << v4);
  }
  v19 = strlen(a2);
  v20 = sub_2F20C((unsigned __int16 *)a2, v19, hashtable_seed);
  v21 = (int *)&v8[2 * (v12 & v20)];
  v22 = sub_2F750((int)a1, v21, a2, v20);
  v23 = v22;
  if ( v22 )
  {
    v24 = *(_DWORD **)(v22 + 20);
    if ( v24 && v24[1] != -1 )
    {
      v25 = v24 + 1;
      __dmb(0xBu);
      do
      {
        v26 = __ldrex(v25);
        v27 = v26 - 1;
      }
      while ( __strex(v27, v25) );
      if ( !v27 )
        json_delete(v24);
    }
    *(_DWORD *)(v23 + 20) = a3;
    return 0;
  }
  v29 = jsonp_malloc((void *)(v19 + 25));
  v30 = (unsigned int *)v29;
  if ( !v29 )
    return -1;
  *((_DWORD *)v29 + 4) = v20;
  strncpy((char *)v29 + 24, a2, v19 + 1);
  v31 = (unsigned int *)*v21;
  v32 = (unsigned int)(v30 + 2);
  v30[5] = a3;
  v30[1] = (unsigned int)v30;
  *v30 = (unsigned int)v30;
  v30[3] = (unsigned int)(v30 + 2);
  v30[2] = (unsigned int)(v30 + 2);
  if ( v31 == a1 + 3 && v31 == (unsigned int *)v21[1] )
  {
    *v30 = a1[3];
    v30[1] = (unsigned int)v31;
    *(_DWORD *)(a1[3] + 4) = v30;
    a1[3] = (unsigned int)v30;
    v21[1] = (int)v30;
    *v21 = (int)v30;
  }
  else
  {
    *v30 = *v31;
    v30[1] = (unsigned int)v31;
    *(_DWORD *)(*v31 + 4) = v30;
    *v31 = (unsigned int)v30;
    *v21 = (int)v30;
  }
  v33 = a1[5];
  v34 = *a1;
  v30[3] = (unsigned int)(a1 + 5);
  v30[2] = v33;
  *(_DWORD *)(a1[5] + 4) = v32;
  a1[5] = v32;
  *a1 = v34 + 1;
  return 0;
}
// 1085DC: using guessed type int hashtable_seed;

//----- (0002FB5C) --------------------------------------------------------
int __fastcall hashtable_get(int a1, char *s)
{
  size_t v4; // r0
  int v5; // r0
  int result; // r0

  v4 = strlen(s);
  v5 = sub_2F20C((unsigned __int16 *)s, v4, hashtable_seed);
  result = sub_2F750(a1, (int *)(*(_DWORD *)(a1 + 4) + 8 * (v5 & ~(-1 << *(_DWORD *)(a1 + 8)))), s, v5);
  if ( result )
    return *(_DWORD *)(result + 20);
  return result;
}
// 1085DC: using guessed type int hashtable_seed;

//----- (0002FBBC) --------------------------------------------------------
int __fastcall hashtable_del(_DWORD *a1, char *s)
{
  size_t v4; // r0
  int v5; // r0
  int v6; // r9
  int v7; // r5
  int *v8; // r7
  _DWORD *v9; // r0
  _DWORD *v10; // r4
  _DWORD *v11; // r1
  int v12; // r2
  int v13; // r3
  int *v14; // r1
  int v15; // r2
  _DWORD *v16; // r0
  int v17; // r3
  unsigned int *v19; // r3
  unsigned int v20; // r2
  unsigned int v21; // r2
  bool v22; // zf

  v4 = strlen(s);
  v5 = sub_2F20C((unsigned __int16 *)s, v4, hashtable_seed);
  v6 = a1[1];
  v7 = v5 & ~(-1 << a1[2]);
  v8 = (int *)(v6 + 8 * v7);
  v9 = (_DWORD *)sub_2F750((int)a1, v8, s, v5);
  v10 = v9;
  if ( !v9 )
    return -1;
  v11 = (_DWORD *)v8[1];
  v12 = v9[1];
  v13 = *v9;
  if ( v9 == *(_DWORD **)(v6 + 8 * v7) )
  {
    v22 = v9 == v11;
    if ( v9 == v11 )
      v11 = a1 + 3;
    else
      *(_DWORD *)(v6 + 8 * v7) = v12;
    if ( v22 )
    {
      v8[1] = (int)v11;
      *(_DWORD *)(v6 + 8 * v7) = v11;
    }
  }
  else if ( v9 == v11 )
  {
    v8[1] = v13;
  }
  *(_DWORD *)(v13 + 4) = v12;
  v14 = (int *)v9[1];
  v15 = v9[3];
  v16 = (_DWORD *)v9[5];
  *v14 = v13;
  v17 = v10[2];
  *(_DWORD *)(v17 + 4) = v15;
  *(_DWORD *)v10[3] = v17;
  if ( v16 && v16[1] != -1 )
  {
    v19 = v16 + 1;
    __dmb(0xBu);
    do
    {
      v20 = __ldrex(v19);
      v21 = v20 - 1;
    }
    while ( __strex(v21, v19) );
    if ( !v21 )
      json_delete(v16);
  }
  jsonp_free(v10);
  --*a1;
  return 0;
}
// 1085DC: using guessed type int hashtable_seed;

//----- (0002FCDC) --------------------------------------------------------
int __fastcall hashtable_clear(_DWORD *a1)
{
  _DWORD *v2; // r2
  int result; // r0
  _DWORD *v4; // r3
  _DWORD *v5; // r1

  sub_2F7C4((int)a1);
  v2 = a1 + 3;
  result = a1[2];
  if ( 1 << result )
  {
    v4 = (_DWORD *)a1[1];
    v5 = (_DWORD *)((char *)v4 + (8 << result));
    do
    {
      v4[1] = v2;
      *v4 = v2;
      v4 += 2;
    }
    while ( v4 != v5 );
  }
  a1[4] = v2;
  a1[3] = v2;
  a1[6] = a1 + 5;
  a1[5] = a1 + 5;
  *a1 = 0;
  return result;
}

//----- (0002FD38) --------------------------------------------------------
int __fastcall hashtable_iter(int a1)
{
  if ( *(_DWORD *)(a1 + 24) == a1 + 20 )
    return 0;
  else
    return *(_DWORD *)(a1 + 24);
}

//----- (0002FD50) --------------------------------------------------------
int __fastcall hashtable_iter_at(int a1, char *s)
{
  size_t v4; // r0
  int v5; // r0
  int result; // r0

  v4 = strlen(s);
  v5 = sub_2F20C((unsigned __int16 *)s, v4, hashtable_seed);
  result = sub_2F750(a1, (int *)(*(_DWORD *)(a1 + 4) + 8 * (v5 & ~(-1 << *(_DWORD *)(a1 + 8)))), s, v5);
  if ( result )
    result += 8;
  return result;
}
// 1085DC: using guessed type int hashtable_seed;

//----- (0002FDB0) --------------------------------------------------------
int __fastcall hashtable_iter_next(int a1, int a2)
{
  if ( *(_DWORD *)(a2 + 4) == a1 + 20 )
    return 0;
  else
    return *(_DWORD *)(a2 + 4);
}

//----- (0002FDC8) --------------------------------------------------------
int __fastcall hashtable_iter_key(int a1)
{
  return a1 + 16;
}

//----- (0002FDD0) --------------------------------------------------------
int __fastcall hashtable_iter_value(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (0002FDD8) --------------------------------------------------------
void __fastcall hashtable_iter_set(int a1, int a2)
{
  _DWORD *v3; // r0
  unsigned int *v4; // r3
  unsigned int v5; // r2
  unsigned int v6; // r2

  v3 = *(_DWORD **)(a1 + 12);
  if ( !v3 )
    goto LABEL_6;
  if ( v3[1] == -1 )
    goto LABEL_6;
  v4 = v3 + 1;
  __dmb(0xBu);
  do
  {
    v5 = __ldrex(v4);
    v6 = v5 - 1;
  }
  while ( __strex(v6, v4) );
  if ( v6 )
  {
LABEL_6:
    *(_DWORD *)(a1 + 12) = a2;
  }
  else
  {
    json_delete(v3);
    *(_DWORD *)(a1 + 12) = a2;
  }
}

//----- (0002FE44) --------------------------------------------------------
int __fastcall json_object_seed(int result)
{
  int v1; // r1
  unsigned __int8 v2; // r2
  int v3; // r3
  int v4; // r0
  int v5; // r5
  ssize_t v6; // r7
  int v7; // r5
  struct timeval v8; // [sp+0h] [bp-Ch] BYREF

  if ( !hashtable_seed )
  {
    v1 = result;
    result = 1;
    do
      v2 = __ldrex(byte_1085E0);
    while ( __strex(1u, byte_1085E0) );
    if ( v2 )
    {
      do
      {
        result = sched_yield();
        v3 = hashtable_seed;
        __dmb(0xBu);
      }
      while ( !v3 );
    }
    else
    {
      if ( !v1 )
      {
        v4 = open64("/dev/urandom");
        v5 = v4;
        if ( v4 == -1 || (v6 = read(v4, &v8, 4u), close(v5), v6 != 4) )
        {
          gettimeofday(&v8, 0);
          v7 = v8.tv_usec ^ v8.tv_sec;
          result = getpid();
          v1 = result ^ v7;
        }
        else
        {
          result = LOBYTE(v8.tv_sec);
          v1 = HIBYTE(v8.tv_sec) | ((BYTE2(v8.tv_sec) | ((BYTE1(v8.tv_sec) | (LOBYTE(v8.tv_sec) << 8)) << 8)) << 8);
        }
        if ( !v1 )
          v1 = 1;
      }
      __dmb(0xBu);
      hashtable_seed = v1;
    }
  }
  return result;
}
// 1E754: using guessed type int __fastcall open64(_DWORD);
// 1085DC: using guessed type int hashtable_seed;
// 1085E0: using guessed type unsigned __int8[4];

//----- (0002FF40) --------------------------------------------------------
int __fastcall sub_2FF40(int a1)
{
  int v1; // r3
  int v2; // r4
  int v3; // r1
  int v4; // r2
  int v5; // t1
  unsigned int v6; // lr
  int v7; // r3
  unsigned int v8; // r12
  int v9; // r2

  v1 = 0;
  v2 = a1 + 4;
  while ( 1 )
  {
    v3 = 16 * v1;
    v5 = *(unsigned __int8 *)++a1;
    v4 = v5;
    v6 = v5 - 97;
    v1 = v5 - 48 + 16 * v1;
    if ( (unsigned __int8)(v5 - 48) > 9u )
      break;
LABEL_6:
    if ( a1 == v2 )
      return v1;
  }
  v7 = v4 - 55;
  v8 = v4 - 65;
  v9 = v4 - 87;
  v1 = v7 + v3;
  if ( v6 <= 0x19 )
  {
    v1 = v9 + v3;
    goto LABEL_6;
  }
  if ( v8 <= 0x19 )
    goto LABEL_6;
  return -1;
}

//----- (0002FFA8) --------------------------------------------------------
int __fastcall sub_2FFA8(_DWORD *a1)
{
  int v1; // r2
  int v2; // r3
  bool v3; // zf

  v1 = a1[1];
  v2 = *(unsigned __int8 *)(*a1 + v1);
  v3 = v2 == 0;
  if ( *(_BYTE *)(*a1 + v1) )
    ++v1;
  else
    v2 = -1;
  if ( !v3 )
    a1[1] = v1;
  return v2;
}

//----- (0002FFCC) --------------------------------------------------------
int __fastcall sub_2FFCC(int a1)
{
  __int64 v1; // r2

  v1 = *(_QWORD *)(a1 + 4);
  if ( HIDWORD(v1) >= (unsigned int)v1 )
    return -1;
  LODWORD(v1) = HIDWORD(v1) + 1;
  HIDWORD(v1) = *(unsigned __int8 *)(*(_DWORD *)a1 + HIDWORD(v1));
  *(_DWORD *)(a1 + 8) = v1;
  return HIDWORD(v1);
}

//----- (0002FFF0) --------------------------------------------------------
int __fastcall sub_2FFF0(_DWORD *a1)
{
  unsigned int v1; // r3
  int (__fastcall *v3)(_DWORD *, int, _DWORD); // r3
  int v4; // r0
  int result; // r0

  v1 = a1[257];
  if ( v1 < a1[256] )
    goto LABEL_4;
  v3 = (int (__fastcall *)(_DWORD *, int, _DWORD))a1[258];
  a1[257] = 0;
  v4 = v3(a1, 1024, a1[259]);
  a1[256] = v4;
  if ( (unsigned int)(v4 - 1) <= 0xFFFFFFFD )
  {
    v1 = a1[257];
LABEL_4:
    result = *((unsigned __int8 *)a1 + v1);
    a1[257] = v1 + 1;
    return result;
  }
  return -1;
}

//----- (0003004C) --------------------------------------------------------
int sub_3004C(int result, _DWORD *a2, int a3, const char *a4, ...)
{
  int v4; // r6
  const char *v7; // r0
  int v8; // r8
  int v9; // r7
  int v10; // r9
  char *v11; // r3
  char s[160]; // [sp+18h] [bp-144h] BYREF
  char v13[159]; // [sp+B8h] [bp-A4h] BYREF
  char v14; // [sp+157h] [bp-5h]
  const char *varg_r3; // [sp+17Ch] [bp+20h]
  va_list va; // [sp+180h] [bp+24h] BYREF

  va_start(va, a4);
  varg_r3 = a4;
  v4 = result;
  if ( result )
  {
    vsnprintf(s, 0xA0u, varg_r3, va);
    s[159] = 0;
    if ( a2 )
    {
      v7 = (const char *)strbuffer_value((int)(a2 + 10));
      v8 = a2[6];
      v9 = a2[7];
      v10 = a2[9];
      if ( v7 && *v7 )
      {
        if ( a2[11] <= 0x14u )
        {
          snprintf(v13, 0xA0u, "%s near '%s'", s, v7);
          v11 = v13;
          v14 = 0;
          return jsonp_error_set(v4, v8, v9, v10, a3, "%s", v11);
        }
      }
      else
      {
        if ( a3 == 8 )
          LOBYTE(a3) = 6;
        if ( a2[5] != -2 )
        {
          snprintf(v13, 0xA0u, "%s near end of file", s);
          v11 = v13;
          v14 = 0;
          return jsonp_error_set(v4, v8, v9, v10, a3, "%s", v11);
        }
      }
      v11 = s;
    }
    else
    {
      v9 = -1;
      v11 = s;
      v10 = 0;
      v8 = -1;
    }
    return jsonp_error_set(v4, v8, v9, v10, a3, "%s", v11);
  }
  return result;
}

//----- (0003017C) --------------------------------------------------------
void __fastcall sub_3017C(int a1)
{
  if ( *(_DWORD *)(a1 + 60) == 256 )
  {
    jsonp_free(*(void **)(a1 + 64));
    *(_DWORD *)(a1 + 64) = 0;
    *(_DWORD *)(a1 + 68) = 0;
    strbuffer_close(a1 + 40);
  }
  else
  {
    strbuffer_close(a1 + 40);
  }
}

//----- (000301BC) --------------------------------------------------------
int __fastcall sub_301BC(int *a1)
{
  _BYTE buf[5]; // [sp+7h] [bp-5h] BYREF

  if ( read(*a1, buf, 1u) == 1 )
    return buf[0];
  else
    return -1;
}

//----- (000301E8) --------------------------------------------------------
_DWORD *__fastcall sub_301E8(_DWORD *result, int a2)
{
  _DWORD *v2; // r4
  int v3; // r2

  v2 = result;
  --result[9];
  if ( a2 == 10 )
  {
    v3 = result[8];
    --result[6];
    result[7] = v3;
  }
  else
  {
    result = (_DWORD *)utf8_check_first((unsigned __int8)a2);
    if ( result )
      --v2[7];
  }
  --v2[4];
  return result;
}

//----- (00030244) --------------------------------------------------------
int __fastcall sub_30244(int a1, int a2)
{
  int v2; // r2
  int v4; // r3
  int v5; // r6
  int v6; // r1
  int v8; // r0
  int v9; // r5
  int v11; // r3
  int v12; // r2
  unsigned int v13; // r0
  unsigned int v14; // r8
  _BYTE *v15; // r6
  _BYTE *v16; // r9
  int v17; // r2
  char arg[4]; // [sp+0h] [bp-8h]

  v2 = *(_DWORD *)(a1 + 16);
  v4 = a1 + v2;
  v5 = *(unsigned __int8 *)(a1 + v2 + 8);
  if ( *(_BYTE *)(a1 + v2 + 8) )
  {
    v6 = v2 + 1;
    goto LABEL_8;
  }
  v8 = (*(int (__fastcall **)(_DWORD))a1)(*(_DWORD *)(a1 + 4));
  v9 = v8;
  if ( v8 == -1 )
  {
    *(_DWORD *)(a1 + 20) = -1;
    return v9;
  }
  *(_DWORD *)(a1 + 16) = v5;
  *(_BYTE *)(a1 + 8) = v8;
  if ( (unsigned int)(v8 - 128) <= 0x7F )
  {
    v13 = utf8_check_first((unsigned __int8)v8);
    v14 = v13;
    if ( !v13 )
      goto LABEL_20;
    if ( v13 > 1 )
    {
      v15 = (_BYTE *)(a1 + 9);
      v16 = (_BYTE *)(a1 + 8 + v13);
      do
        *v15++ = (*(int (__fastcall **)(_DWORD))a1)(*(_DWORD *)(a1 + 4));
      while ( v16 != v15 );
    }
    if ( !utf8_check_full((char *)(a1 + 8), v14, 0) )
    {
LABEL_20:
      *(_DWORD *)arg = v9;
      v9 = -2;
      *(_DWORD *)(a1 + 20) = -2;
      sub_3004C(a2, (_DWORD *)a1, 5, "unable to decode byte 0x%x", *(_DWORD *)arg);
      return v9;
    }
    *(_BYTE *)(a1 + v14 + 8) = 0;
    v17 = *(_DWORD *)(a1 + 16);
    v6 = v17 + 1;
    v4 = a1 + v17;
  }
  else
  {
    v6 = 1;
    v4 = a1;
    *(_BYTE *)(a1 + 9) = v5;
  }
LABEL_8:
  *(_DWORD *)(a1 + 16) = v6;
  v9 = *(unsigned __int8 *)(v4 + 8);
  ++*(_DWORD *)(a1 + 36);
  if ( v9 != 10 )
  {
    if ( utf8_check_first(v9) )
      ++*(_DWORD *)(a1 + 28);
    return v9;
  }
  v11 = *(_DWORD *)(a1 + 24);
  v12 = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 24) = v11 + 1;
  *(_DWORD *)(a1 + 32) = v12;
  return 10;
}

//----- (000303AC) --------------------------------------------------------
int __fastcall sub_303AC(int a1, int a2)
{
  int v3; // r4

  v3 = *(_DWORD *)(a1 + 20);
  if ( !v3 )
    v3 = sub_30244(a1, a2);
  if ( (unsigned int)(v3 + 2) > 1 )
    fh_buffer_putc((const void **)(a1 + 40), v3);
  return v3;
}

//----- (000303EC) --------------------------------------------------------
int __fastcall sub_303EC(_DWORD *a1, int a2)
{
  char v3; // r1
  int v4; // r2

  sub_301E8(a1, a2);
  return strbuffer_pop(a1 + 10, v3, v4);
}
// 30400: variable 'v3' is possibly undefined
// 30400: variable 'v4' is possibly undefined

//----- (00030404) --------------------------------------------------------
unsigned int __fastcall sub_30404(int a1, int a2)
{
  const void **v2; // r7
  unsigned int v5; // r4
  bool v6; // cc
  int v7; // r3
  int v8; // r4
  bool v9; // zf
  _BOOL4 v10; // r2
  bool v11; // cc
  int v12; // r0
  const char *v13; // r4
  int v15; // r1
  int v16; // r0
  unsigned int v17; // r4
  int v18; // r0
  bool v19; // zf
  unsigned int v20; // r0
  bool v21; // zf
  double v22; // r2
  char i; // r1
  int v24; // r3
  int v25; // r2
  int v26; // r8
  unsigned int v27; // r3
  unsigned int v28; // r4
  bool v29; // cc
  unsigned int v30; // r0
  _BYTE *v31; // r8
  unsigned __int8 *j; // r4
  int v33; // r3
  unsigned int v34; // r3
  int v35; // r0
  int v36; // r11
  int v37; // r0
  const char *v38; // r7
  int *v39; // r4
  __int64 v40; // r0
  unsigned int v41; // r1
  int v42; // r2
  const char *v43; // r3
  const char *v44; // r3
  char arg[4]; // [sp+0h] [bp-1Ch]
  int v46; // [sp+Ch] [bp-10h]
  double endptr; // [sp+10h] [bp-Ch] BYREF

  v2 = (const void **)(a1 + 40);
  strbuffer_clear(a1 + 40);
  if ( *(_DWORD *)(a1 + 60) == 256 )
  {
    jsonp_free(*(void **)(a1 + 64));
    *(_DWORD *)(a1 + 64) = 0;
    *(_DWORD *)(a1 + 68) = 0;
  }
  do
  {
    v5 = *(_DWORD *)(a1 + 20);
    if ( !v5 )
      v5 = sub_30244(a1, a2);
    v6 = v5 > 0x20;
    if ( v5 != 32 )
      v6 = v5 - 9 > 1;
    v7 = !v6;
  }
  while ( !v6 || v5 == 13 );
  if ( v5 == -1 )
  {
    *(_DWORD *)(a1 + 60) = v7;
    return v7;
  }
  if ( v5 == -2 )
    goto LABEL_37;
  fh_buffer_putc(v2, v5);
  if ( (((v5 & 0xFFFFFFDF) - 91) & 0xFFFFFFFD) == 0 )
    goto LABEL_40;
  v9 = v5 == 44;
  if ( v5 != 44 )
    v9 = v5 == 58;
  v10 = v9;
  if ( v9 )
    goto LABEL_40;
  if ( v5 != 34 )
  {
    v11 = v5 > 0x2D;
    if ( v5 != 45 )
      v11 = v5 - 48 > 9;
    if ( !v11 )
    {
      *(_DWORD *)(a1 + 60) = -1;
      if ( v5 == 45 )
      {
        v30 = sub_303AC(a1, a2);
        if ( v30 == 48 )
        {
LABEL_60:
          v20 = sub_303AC(a1, a2);
          if ( v20 - 48 <= 9 )
          {
LABEL_61:
            sub_303EC((_DWORD *)a1, v20);
            return *(_DWORD *)(a1 + 60);
          }
LABEL_63:
          if ( (*(_DWORD *)(a1 + 52) & 8) == 0 )
          {
            v21 = (v20 & 0xFFFFFFDF) == 69;
            if ( (v20 & 0xFFFFFFDF) != 0x45 )
              v21 = v20 == 46;
            if ( !v21 )
            {
              if ( v20 + 2 > 1 )
                sub_303EC((_DWORD *)a1, v20);
              v38 = (const char *)strbuffer_value((int)v2);
              v39 = _errno_location();
              *v39 = 0;
              v40 = strtoll(v38, (char **)&endptr, 10);
              if ( *v39 == 34 )
              {
                if ( v40 >= 0 )
                  LOWORD(v44) = 4240;
                else
                  LOWORD(v44) = 4212;
                HIWORD(v44) = 14;
                sub_3004C(a2, (_DWORD *)a1, 15, v44);
                return *(_DWORD *)(a1 + 60);
              }
              else
              {
                v8 = 257;
                *(_QWORD *)(a1 + 64) = v40;
                *(_DWORD *)(a1 + 60) = 257;
              }
              return v8;
            }
          }
          if ( v20 == 46 )
          {
            v41 = *(_DWORD *)(a1 + 20);
            if ( !v41 )
              v41 = sub_30244(a1, a2);
            if ( v41 - 48 > 9 )
            {
              if ( v41 < 0xFFFFFFFE )
              {
                sub_301E8((_DWORD *)a1, v41);
                return *(_DWORD *)(a1 + 60);
              }
              return *(_DWORD *)(a1 + 60);
            }
            fh_buffer_putc(v2, v41);
            do
              v20 = sub_303AC(a1, a2);
            while ( v20 - 48 <= 9 );
          }
          if ( (v20 & 0xFFFFFFDF) != 0x45 )
          {
LABEL_70:
            if ( v20 + 2 > 1 )
              sub_303EC((_DWORD *)a1, v20);
            if ( !jsonp_strtod((const char **)v2, &endptr) )
            {
              v22 = endptr;
              v8 = 258;
              *(_DWORD *)(a1 + 60) = 258;
              *(double *)(a1 + 64) = v22;
              return v8;
            }
            sub_3004C(a2, (_DWORD *)a1, 15, "real number overflow");
            return *(_DWORD *)(a1 + 60);
          }
          v20 = sub_303AC(a1, a2);
          if ( ((v20 - 43) & 0xFFFFFFFD) == 0 )
            v20 = sub_303AC(a1, a2);
          if ( v20 - 48 <= 9 )
          {
            do
              v20 = sub_303AC(a1, a2);
            while ( v20 - 48 <= 9 );
            goto LABEL_70;
          }
          if ( v20 < 0xFFFFFFFE )
            goto LABEL_61;
          return *(_DWORD *)(a1 + 60);
        }
        if ( v30 - 48 > 9 )
        {
          if ( v30 < 0xFFFFFFFE )
            sub_303EC((_DWORD *)a1, v30);
          return *(_DWORD *)(a1 + 60);
        }
      }
      else if ( v5 == 48 )
      {
        goto LABEL_60;
      }
      do
        v20 = sub_303AC(a1, a2);
      while ( v20 - 48 <= 9 );
      goto LABEL_63;
    }
    if ( (v5 & 0xFFFFFFDF) - 65 <= 0x19 )
    {
      do
        v12 = sub_303AC(a1, a2);
      while ( (v12 & 0xFFFFFFDF) - 65 <= 0x19 );
      if ( (unsigned int)(v12 + 2) > 1 )
        sub_303EC((_DWORD *)a1, v12);
      v13 = (const char *)strbuffer_value((int)v2);
      if ( !strcmp(v13, "true") )
      {
        v8 = 259;
        *(_DWORD *)(a1 + 60) = 259;
        return v8;
      }
      if ( strcmp(v13, "false") )
      {
        if ( !strcmp(v13, "null") )
        {
          v8 = 261;
          *(_DWORD *)(a1 + 60) = 261;
          return v8;
        }
        goto LABEL_37;
      }
      v5 = 260;
LABEL_40:
      *(_DWORD *)(a1 + 60) = v5;
      return v5;
    }
    for ( i = *(_BYTE *)(a1 + *(_DWORD *)(a1 + 16) + 8); i; i = *(_BYTE *)(a1 + v24 + 8) )
    {
      fh_buffer_putc(v2, i);
      v24 = *(_DWORD *)(a1 + 16) + 1;
      v25 = *(_DWORD *)(a1 + 36) + 1;
      *(_DWORD *)(a1 + 16) = v24;
      *(_DWORD *)(a1 + 36) = v25;
    }
LABEL_37:
    v8 = -1;
    *(_DWORD *)(a1 + 60) = -1;
    return v8;
  }
  *(_DWORD *)(a1 + 64) = v10;
  *(_DWORD *)(a1 + 60) = -1;
LABEL_42:
  v15 = a2;
  v16 = a1;
  while ( 1 )
  {
    v17 = sub_303AC(v16, v15);
LABEL_44:
    if ( v17 == 34 )
    {
      v31 = jsonp_malloc((void *)(*(_DWORD *)(a1 + 44) + 1));
      if ( !v31 )
        goto LABEL_57;
      *(_DWORD *)(a1 + 64) = v31;
      for ( j = (unsigned __int8 *)(strbuffer_value((int)v2) + 1); ; j += 2 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            v33 = *j;
            if ( v33 == 34 )
            {
              *v31 = 0;
              v8 = 256;
              v42 = *(_DWORD *)(a1 + 64);
              *(_DWORD *)(a1 + 60) = 256;
              *(_DWORD *)(a1 + 68) = &v31[-v42];
              return v8;
            }
            if ( v33 == 92 )
              break;
            *v31 = v33;
            ++j;
            ++v31;
          }
          v34 = j[1];
          if ( v34 != 117 )
            break;
          v35 = sub_2FF40((int)(j + 1));
          v36 = v35;
          if ( v35 < 0 )
          {
            LOWORD(v43) = (unsigned __int16)"invalid Unicode escape '%.6s'";
            *(_DWORD *)arg = j;
LABEL_146:
            HIWORD(v43) = (unsigned int)"invalid Unicode escape '%.6s'" >> 16;
            sub_3004C(a2, (_DWORD *)a1, 8, v43, *(_DWORD *)arg);
            goto LABEL_57;
          }
          v46 = v35 - 55296;
          if ( (unsigned int)(v35 - 55296) >= 0x400 )
          {
            if ( (unsigned int)(v35 - 56320) < 0x400 )
              goto LABEL_153;
            j += 6;
          }
          else
          {
            if ( j[6] != 92 || j[7] != 117 )
            {
LABEL_153:
              sub_3004C(a2, (_DWORD *)a1, 8, "invalid Unicode '\\u%04X'", v35);
              goto LABEL_57;
            }
            v37 = sub_2FF40((int)(j + 7));
            if ( v37 < 0 )
            {
              LOWORD(v43) = 4120;
              *(_DWORD *)arg = j + 6;
              goto LABEL_146;
            }
            j += 12;
            if ( (unsigned int)(v37 - 56320) >= 0x400 )
            {
              sub_3004C(a2, (_DWORD *)a1, 8, "invalid Unicode '\\u%04X\\u%04X'", v36, v37);
              goto LABEL_57;
            }
            v36 = v37 - 56320 + (v46 << 10) + 0x10000;
          }
          utf8_encode(v36, v31, &endptr);
          v31 += LODWORD(endptr);
        }
        if ( v34 == 98 )
        {
          *v31 = 8;
          goto LABEL_109;
        }
        if ( v34 <= 0x62 )
        {
          if ( v34 == 47 || v34 == 92 || v34 == 34 )
            goto LABEL_108;
        }
        else
        {
          if ( v34 == 110 )
          {
            *v31 = 10;
            goto LABEL_109;
          }
          if ( v34 <= 0x6E )
          {
            if ( v34 == 102 )
              *v31 = 12;
          }
          else
          {
            if ( v34 == 114 )
            {
              *v31 = 13;
              goto LABEL_109;
            }
            if ( v34 == 116 )
            {
              LOBYTE(v34) = 9;
LABEL_108:
              *v31 = v34;
            }
          }
        }
LABEL_109:
        ++v31;
      }
    }
    if ( v17 == -2 )
      goto LABEL_57;
    if ( v17 == -1 )
    {
      sub_3004C(a2, (_DWORD *)a1, 6, "premature end of input");
      goto LABEL_57;
    }
    if ( v17 <= 0x1F )
      break;
    v15 = a2;
    v16 = a1;
    if ( v17 == 92 )
    {
      v18 = sub_303AC(a1, a2);
      if ( v18 == 117 )
      {
        v26 = 4;
        v17 = sub_303AC(a1, a2);
        while ( 1 )
        {
          v27 = v17 & 0xFFFFFFDF;
          v28 = v17 - 48;
          v27 -= 65;
          v29 = v27 > 5;
          if ( v27 > 5 )
            v29 = v28 > 9;
          if ( v29 )
            break;
          --v26;
          v17 = sub_303AC(a1, a2);
          if ( !v26 )
            goto LABEL_44;
        }
LABEL_56:
        sub_3004C(a2, (_DWORD *)a1, 8, "invalid escape");
        goto LABEL_57;
      }
      v19 = v18 == 92;
      if ( v18 != 92 )
        v19 = (v18 & 0xFFFFFFBF) == 34;
      if ( !v19 && v18 != 47 && (v18 & 0xFFFFFFF7) != 0x66 && ((v18 - 114) & 0xFFFFFFFD) != 0 )
        goto LABEL_56;
      goto LABEL_42;
    }
  }
  sub_303EC((_DWORD *)a1, v17);
  if ( v17 == 10 )
    sub_3004C(a2, (_DWORD *)a1, 8, "unexpected newline");
  else
    sub_3004C(a2, (_DWORD *)a1, 8, "control character 0x%x", v17);
LABEL_57:
  jsonp_free(*(void **)(a1 + 64));
  v8 = *(_DWORD *)(a1 + 60);
  *(_DWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 68) = 0;
  return v8;
}

//----- (00030BEC) --------------------------------------------------------
double *__fastcall sub_30BEC(int a1, int a2, int a3)
{
  unsigned int v5; // r3
  int v6; // r3
  double *v7; // r6
  _BYTE *v10; // r7
  size_t v11; // r9
  int v12; // r3
  void *v13; // r7
  size_t v14; // r2
  _DWORD *v15; // r2
  int v16; // r3
  unsigned int *v17; // r3
  unsigned int v18; // r2
  unsigned int v19; // r2
  int v20; // r3
  int v21; // r3
  _DWORD *v22; // r1
  unsigned int *v23; // r3
  unsigned int v24; // r2
  double *v25; // r0

  v5 = *(_DWORD *)(a1 + 56) + 1;
  *(_DWORD *)(a1 + 56) = v5;
  if ( v5 > 0x800 )
  {
    v7 = 0;
    sub_3004C(a3, (_DWORD *)a1, 2, "maximum parsing depth reached");
    return v7;
  }
  v6 = *(_DWORD *)(a1 + 60);
  if ( v6 == 257 )
  {
    v7 = (double *)json_integer(*(_QWORD *)(a1 + 64));
    goto LABEL_9;
  }
  if ( v6 <= 257 )
  {
    if ( v6 == 91 )
    {
      v7 = (double *)json_array();
      if ( !v7 )
        return 0;
      sub_30404(a1, a3);
      v20 = *(_DWORD *)(a1 + 60);
      if ( v20 == 93 )
        goto LABEL_10;
      if ( v20 )
      {
        while ( 1 )
        {
          v22 = (_DWORD *)sub_30BEC(a1, a2, a3);
          if ( !v22 || json_array_append_new(v7, v22) )
            break;
          sub_30404(a1, a3);
          v21 = *(_DWORD *)(a1 + 60);
          if ( v21 != 44 )
          {
            if ( v21 == 93 )
              goto LABEL_10;
            goto LABEL_62;
          }
          sub_30404(a1, a3);
          if ( !*(_DWORD *)(a1 + 60) )
            goto LABEL_62;
        }
      }
      else
      {
LABEL_62:
        sub_3004C(a3, (_DWORD *)a1, 8, "']' expected");
      }
      if ( *((_DWORD *)v7 + 1) == -1 )
        return 0;
      v23 = (unsigned int *)v7 + 1;
      __dmb(0xBu);
      do
      {
        v24 = __ldrex(v23);
        v19 = v24 - 1;
      }
      while ( __strex(v19, v23) );
    }
    else
    {
      if ( v6 <= 91 )
      {
        if ( v6 == -1 )
        {
          v7 = 0;
          sub_3004C(a3, (_DWORD *)a1, 8, "invalid token");
          return v7;
        }
        goto LABEL_57;
      }
      if ( v6 != 123 )
      {
        if ( v6 != 256 )
          goto LABEL_57;
        v10 = *(_BYTE **)(a1 + 64);
        v11 = *(_DWORD *)(a1 + 68);
        if ( (a2 & 0x10) == 0 && memchr(*(const void **)(a1 + 64), 0, *(_DWORD *)(a1 + 68)) )
        {
          v7 = 0;
          sub_3004C(a3, (_DWORD *)a1, 11, "\\u0000 is not allowed without JSON_ALLOW_NUL");
          return v7;
        }
        v7 = (double *)jsonp_stringn_nocheck_own(v10, v11);
        *(_DWORD *)(a1 + 64) = 0;
        *(_DWORD *)(a1 + 68) = 0;
        goto LABEL_9;
      }
      v7 = (double *)json_object();
      if ( !v7 )
        return 0;
      sub_30404(a1, a3);
      v12 = *(_DWORD *)(a1 + 60);
      if ( v12 == 125 )
        goto LABEL_10;
      if ( v12 == 256 )
      {
        v13 = *(void **)(a1 + 64);
        v14 = *(_DWORD *)(a1 + 68);
        *(_DWORD *)(a1 + 64) = 0;
        *(_DWORD *)(a1 + 68) = 0;
        if ( !v13 )
          return 0;
        while ( 1 )
        {
          if ( memchr(v13, 0, v14) )
          {
            jsonp_free(v13);
            sub_3004C(a3, (_DWORD *)a1, 13, "NUL byte in object key not supported");
            goto LABEL_36;
          }
          if ( (a2 & 1) != 0 && json_object_get(v7, (char *)v13) )
          {
            jsonp_free(v13);
            sub_3004C(a3, (_DWORD *)a1, 14, "duplicate object key");
            goto LABEL_36;
          }
          sub_30404(a1, a3);
          if ( *(_DWORD *)(a1 + 60) != 58 )
          {
            jsonp_free(v13);
            sub_3004C(a3, (_DWORD *)a1, 8, "':' expected");
            goto LABEL_36;
          }
          sub_30404(a1, a3);
          v15 = (_DWORD *)sub_30BEC(a1, a2, a3);
          if ( !v15 || json_object_set_new_nocheck(v7, (char *)v13, v15) )
          {
            jsonp_free(v13);
            goto LABEL_36;
          }
          jsonp_free(v13);
          sub_30404(a1, a3);
          v16 = *(_DWORD *)(a1 + 60);
          if ( v16 != 44 )
            break;
          sub_30404(a1, a3);
          if ( *(_DWORD *)(a1 + 60) != 256 )
            goto LABEL_63;
          v13 = *(void **)(a1 + 64);
          v14 = *(_DWORD *)(a1 + 68);
          *(_DWORD *)(a1 + 64) = 0;
          *(_DWORD *)(a1 + 68) = 0;
          if ( !v13 )
            return 0;
        }
        if ( v16 == 125 )
          goto LABEL_10;
        sub_3004C(a3, (_DWORD *)a1, 8, "'}' expected");
      }
      else
      {
LABEL_63:
        sub_3004C(a3, (_DWORD *)a1, 8, "string or '}' expected");
      }
LABEL_36:
      if ( *((_DWORD *)v7 + 1) == -1 )
        return 0;
      v17 = (unsigned int *)v7 + 1;
      __dmb(0xBu);
      do
      {
        v18 = __ldrex(v17);
        v19 = v18 - 1;
      }
      while ( __strex(v19, v17) );
    }
    if ( !v19 )
    {
      v25 = v7;
      v7 = 0;
      json_delete(v25);
      return v7;
    }
    return 0;
  }
  if ( v6 == 259 )
  {
    v7 = (double *)json_true();
  }
  else if ( v6 < 259 )
  {
    v7 = json_real();
  }
  else
  {
    if ( v6 != 260 )
    {
      if ( v6 == 261 )
      {
        v7 = (double *)json_null();
        goto LABEL_9;
      }
LABEL_57:
      v7 = 0;
      sub_3004C(a3, (_DWORD *)a1, 8, "unexpected token");
      return v7;
    }
    v7 = (double *)json_false();
  }
LABEL_9:
  if ( v7 )
  {
LABEL_10:
    --*(_DWORD *)(a1 + 56);
    return v7;
  }
  return 0;
}

//----- (00031090) --------------------------------------------------------
double *__fastcall sub_31090(_DWORD *a1, int a2, int a3)
{
  double *v6; // r7
  unsigned int *v8; // r3
  unsigned int v9; // r2
  unsigned int v10; // r2
  double *v11; // r0

  a1[14] = 0;
  sub_30404((int)a1, a3);
  v6 = (double *)(a2 & 4);
  if ( (a2 & 4) == 0 && (a1[15] & 0xFFFFFFDF) != 0x5B )
  {
    sub_3004C(a3, a1, 8, "'[' or '{' expected");
    return v6;
  }
  v6 = sub_30BEC((int)a1, a2, a3);
  if ( v6 )
  {
    if ( (a2 & 2) != 0 || (sub_30404((int)a1, a3), !a1[15]) )
    {
      if ( a3 )
        *(_DWORD *)(a3 + 8) = a1[9];
      return v6;
    }
    sub_3004C(a3, a1, 7, "end of file expected");
    if ( *((_DWORD *)v6 + 1) != -1 )
    {
      v8 = (unsigned int *)v6 + 1;
      __dmb(0xBu);
      do
      {
        v9 = __ldrex(v8);
        v10 = v9 - 1;
      }
      while ( __strex(v10, v8) );
      if ( !v10 )
      {
        v11 = v6;
        v6 = 0;
        json_delete(v11);
        return v6;
      }
    }
  }
  return 0;
}

//----- (00031194) --------------------------------------------------------
double *__fastcall json_loads(int a1, int a2, char *a3)
{
  double *v6; // r4
  _DWORD v8[2]; // [sp+0h] [bp-54h] BYREF
  _DWORD v9[2]; // [sp+8h] [bp-4Ch] BYREF
  char v10; // [sp+10h] [bp-44h]
  int v11; // [sp+18h] [bp-3Ch]
  int v12; // [sp+1Ch] [bp-38h]
  int v13; // [sp+20h] [bp-34h]
  int v14; // [sp+24h] [bp-30h]
  int v15; // [sp+2Ch] [bp-28h]
  _DWORD v16[9]; // [sp+30h] [bp-24h] BYREF

  jsonp_error_init(a3, "<string>");
  if ( a1 )
  {
    v6 = 0;
    v8[0] = a1;
    v9[0] = 196520;
    v8[1] = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v14 = 0;
    v15 = 0;
    v9[1] = v8;
    v13 = 1;
    if ( !strbuffer_init(v16) )
    {
      v16[3] = a2;
      v16[5] = -1;
      v6 = sub_31090(v9, a2, (int)a3);
      sub_3017C((int)v9);
    }
  }
  else
  {
    v6 = 0;
    sub_3004C((int)a3, 0, 4, "wrong arguments");
  }
  return v6;
}

//----- (0003125C) --------------------------------------------------------
double *__fastcall json_loadb(int a1, int a2, int a3, char *a4)
{
  double *v8; // r4
  _DWORD v10[3]; // [sp+4h] [bp-54h] BYREF
  _DWORD v11[2]; // [sp+10h] [bp-48h] BYREF
  char v12; // [sp+18h] [bp-40h]
  int v13; // [sp+20h] [bp-38h]
  int v14; // [sp+24h] [bp-34h]
  int v15; // [sp+28h] [bp-30h]
  int v16; // [sp+2Ch] [bp-2Ch]
  int v17; // [sp+34h] [bp-24h]
  _DWORD v18[8]; // [sp+38h] [bp-20h] BYREF

  jsonp_error_init(a4, "<buffer>");
  if ( a1 )
  {
    v8 = 0;
    v10[0] = a1;
    v10[1] = a2;
    v11[0] = 196556;
    v10[2] = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v16 = 0;
    v17 = 0;
    v11[1] = v10;
    v15 = 1;
    if ( !strbuffer_init(v18) )
    {
      v18[3] = a3;
      v18[5] = -1;
      v8 = sub_31090(v11, a3, (int)a4);
      sub_3017C((int)v11);
    }
  }
  else
  {
    v8 = 0;
    sub_3004C((int)a4, 0, 4, "wrong arguments");
  }
  return v8;
}

//----- (00031330) --------------------------------------------------------
double *__fastcall json_loadf(int a1, int a2, char *a3)
{
  char *v6; // r1
  double *v7; // r4
  _DWORD v9[2]; // [sp+0h] [bp-4Ch] BYREF
  char v10; // [sp+8h] [bp-44h]
  int v11; // [sp+10h] [bp-3Ch]
  int v12; // [sp+14h] [bp-38h]
  int v13; // [sp+18h] [bp-34h]
  int v14; // [sp+1Ch] [bp-30h]
  int v15; // [sp+24h] [bp-28h]
  _DWORD v16[9]; // [sp+28h] [bp-24h] BYREF

  if ( stdin == a1 )
    v6 = "<stdin>";
  else
    v6 = "<stream>";
  jsonp_error_init(a3, v6);
  if ( a1 )
  {
    v7 = 0;
    v9[1] = a1;
    v9[0] = 125152;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v14 = 0;
    v15 = 0;
    v13 = 1;
    if ( !strbuffer_init(v16) )
    {
      v16[3] = a2;
      v16[5] = -1;
      v7 = sub_31090(v9, a2, (int)a3);
      sub_3017C((int)v9);
    }
  }
  else
  {
    v7 = 0;
    sub_3004C((int)a3, 0, 4, "wrong arguments");
  }
  return v7;
}
// 107940: using guessed type int stdin;

//----- (00031410) --------------------------------------------------------
double *__fastcall json_loadfd(int a1, int a2, char *a3)
{
  char *v4; // r1
  int v6; // r3
  double *v7; // r4
  int v9; // [sp+4h] [bp-4Ch] BYREF
  _DWORD v10[2]; // [sp+8h] [bp-48h] BYREF
  char v11; // [sp+10h] [bp-40h]
  int v12; // [sp+18h] [bp-38h]
  int v13; // [sp+1Ch] [bp-34h]
  int v14; // [sp+20h] [bp-30h]
  int v15; // [sp+24h] [bp-2Ch]
  int v16; // [sp+2Ch] [bp-24h]
  _DWORD v17[8]; // [sp+30h] [bp-20h] BYREF

  v9 = a1;
  if ( a1 )
    v4 = "<stream>";
  else
    v4 = "<stdin>";
  jsonp_error_init(a3, v4);
  if ( v9 < 0 )
  {
    v7 = 0;
    sub_3004C((int)a3, 0, 4, "wrong arguments");
  }
  else
  {
    LOWORD(v6) = 444;
    v7 = 0;
    HIWORD(v6) = (unsigned int)json_array_append_new >> 16;
    v10[0] = v6;
    v10[1] = &v9;
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v15 = 0;
    v16 = 0;
    v14 = 1;
    if ( !strbuffer_init(v17) )
    {
      v17[3] = a2;
      v17[5] = -1;
      v7 = sub_31090(v10, a2, (int)a3);
      sub_3017C((int)v10);
    }
  }
  return v7;
}

//----- (000314EC) --------------------------------------------------------
double *__fastcall json_load_file(char *a1, int a2, char *a3)
{
  int v6; // r0
  FILE *v7; // r7
  double *v8; // r6
  int *v10; // r0
  char *v11; // r0

  jsonp_error_init(a3, a1);
  if ( a1 )
  {
    v6 = fopen64(a1, "rb");
    v7 = (FILE *)v6;
    if ( v6 )
    {
      v8 = json_loadf(v6, a2, a3);
      fclose(v7);
    }
    else
    {
      v10 = _errno_location();
      v8 = 0;
      v11 = strerror(*v10);
      sub_3004C((int)a3, 0, 3, "unable to open %s: %s", a1, v11);
    }
  }
  else
  {
    v8 = 0;
    sub_3004C((int)a3, 0, 4, "wrong arguments");
  }
  return v8;
}
// 1EA0C: using guessed type int __fastcall fopen64(_DWORD, _DWORD);

//----- (000315A4) --------------------------------------------------------
double *__fastcall json_load_callback(double *a1, int a2, int a3, char *a4)
{
  _DWORD v9[2]; // [sp+0h] [bp-45Ch] BYREF
  char v10; // [sp+8h] [bp-454h]
  int v11; // [sp+10h] [bp-44Ch]
  int v12; // [sp+14h] [bp-448h]
  int v13; // [sp+18h] [bp-444h]
  int v14; // [sp+1Ch] [bp-440h]
  int v15; // [sp+24h] [bp-438h]
  _DWORD v16[8]; // [sp+28h] [bp-434h] BYREF
  _DWORD s[261]; // [sp+48h] [bp-414h] BYREF

  memset(s, 0, 0x410u);
  s[259] = a2;
  s[258] = a1;
  jsonp_error_init(a4, "<callback>");
  if ( a1 )
  {
    a1 = 0;
    v9[1] = s;
    v9[0] = 196592;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v14 = 0;
    v15 = 0;
    v13 = 1;
    if ( !strbuffer_init(v16) )
    {
      v16[3] = a3;
      v16[5] = -1;
      a1 = sub_31090(v9, a3, (int)a4);
      sub_3017C((int)v9);
    }
  }
  else
  {
    sub_3004C((int)a4, 0, 4, "wrong arguments");
  }
  return a1;
}

//----- (00031688) --------------------------------------------------------
void *__fastcall jsonp_malloc(void *result)
{
  if ( result )
    return off_1063D4((size_t)result);
  return result;
}
// 1063D4: using guessed type void *(*off_1063D4)(size_t size);

//----- (000316A0) --------------------------------------------------------
void __fastcall jsonp_free(void *a1)
{
  if ( a1 )
    off_1063D8(a1);
}
// 1063D8: using guessed type void (*off_1063D8)(void *ptr);

//----- (000316B8) --------------------------------------------------------
_BYTE *__fastcall jsonp_strndup(const void *a1, size_t a2)
{
  _BYTE *v2; // r5
  _BYTE *v5; // r0

  v2 = (_BYTE *)(a2 + 1);
  if ( a2 != -1 )
  {
    v5 = (_BYTE *)off_1063D4(a2 + 1);
    v2 = v5;
    if ( v5 )
    {
      memcpy(v5, a1, a2);
      v2[a2] = 0;
    }
  }
  return v2;
}
// 1063D4: using guessed type void *(*off_1063D4)(size_t size);

//----- (00031704) --------------------------------------------------------
_BYTE *__fastcall jsonp_strdup(const char *a1)
{
  size_t v2; // r1

  v2 = strlen(a1);
  return jsonp_strndup(a1, v2);
}

//----- (00031720) --------------------------------------------------------
int __fastcall json_set_alloc_funcs(__int64 a1)
{
  *(_QWORD *)&off_1063D4 = a1;
  return a1;
}
// 1063D4: using guessed type void *(*off_1063D4)(size_t size);

//----- (00031730) --------------------------------------------------------
_DWORD *__fastcall json_get_alloc_funcs(_DWORD *result, _DWORD *a2)
{
  if ( result )
    *result = off_1063D4;
  if ( a2 )
    *a2 = off_1063D8;
  return result;
}
// 1063D4: using guessed type void *(*off_1063D4)(size_t size);
// 1063D8: using guessed type void (*off_1063D8)(void *ptr);

//----- (00031760) --------------------------------------------------------
char *sub_31760(int *a1, char *a2, char a3, char *format, ...)
{
  va_list __varargs; // [sp+30h] [bp+14h] BYREF

  va_start(__varargs, format);
  jsonp_error_vset(a1[14], a1[6], a1[7], a1[8], a3, format, __varargs);
  return jsonp_error_set_source((char *)a1[14], a2);
}

//----- (000317C0) --------------------------------------------------------
_BYTE *__fastcall sub_317C0(_DWORD *a1)
{
  _DWORD *v1; // lr
  int v2; // r5
  int v4; // r1
  int v5; // r2
  int v6; // r3
  _BYTE *result; // r0
  __int64 v8; // r4
  int v9; // lr
  int v10; // r1
  int v11; // r3
  bool v12; // zf
  int v13; // r2
  int v14; // t1
  bool v15; // zf
  int v16; // r2
  int v17; // r1
  int v18; // r2
  int v19; // r3

  v1 = a1 + 6;
  v2 = a1[10];
  v4 = a1[7];
  v5 = a1[8];
  v6 = a1[9];
  a1[2] = a1[6];
  a1[3] = v4;
  a1[4] = v5;
  a1[5] = v6;
  if ( v2 )
  {
    result = (_BYTE *)a1[10];
    v17 = a1[11];
    v18 = a1[12];
    v19 = a1[13];
    *v1 = result;
    v1[1] = v17;
    v1[2] = v18;
    v1[3] = v19;
    a1[10] = 0;
  }
  else
  {
    result = (_BYTE *)a1[1];
    if ( *((_BYTE *)a1 + 36) || *result )
    {
      LODWORD(v8) = a1[16];
      v9 = a1[17] + 1;
      v10 = a1[18] + 1;
      a1[17] = v9;
      a1[18] = v10;
      v11 = (unsigned __int8)*result;
      v12 = v11 == 32;
      if ( v11 != 32 )
        v12 = v11 == 44;
      v13 = v12;
      if ( v11 == 58 )
        v13 |= 1u;
      if ( (unsigned int)(v11 - 9) <= 1 )
        v13 |= 1u;
      if ( v13 )
      {
        HIDWORD(v8) = 1;
        do
        {
          if ( v11 == 10 )
          {
            LODWORD(v8) = v8 + 1;
            *((_QWORD *)a1 + 8) = v8;
          }
          else
          {
            ++a1[17];
          }
          a1[18] = ++v10;
          v14 = (unsigned __int8)*++result;
          v11 = v14;
          v15 = v14 == 44;
          if ( v14 != 44 )
            v15 = v11 == 32;
          v16 = v15;
          if ( v11 == 58 )
            v16 |= 1u;
          if ( (unsigned int)(v11 - 9) <= 1 )
            v16 |= 1u;
        }
        while ( v16 );
        v9 = a1[17];
      }
      *((_BYTE *)a1 + 36) = v11;
      a1[6] = v8;
      a1[7] = v9;
      a1[8] = v10;
      if ( *result )
        ++result;
      a1[1] = result;
    }
  }
  return result;
}

//----- (000318F0) --------------------------------------------------------
int __fastcall sub_318F0(int a1, size_t **a2, const char *a3, size_t *a4, _DWORD *a5, int a6)
{
  _DWORD *v6; // r5
  _DWORD *v8; // r7
  _DWORD *v10; // r6
  int v11; // r1
  int v12; // r2
  int v13; // r3
  const char *v14; // lr
  bool v15; // zf
  int v16; // r1
  int v17; // r2
  int v18; // r3
  int v19; // r12
  int v20; // r12
  int v21; // r1
  int v22; // r2
  int v23; // r3
  int v24; // r1
  int v25; // r2
  int v26; // r3
  size_t v27; // r2
  size_t *v28; // r3
  char *v29; // r9
  int v30; // r3
  int v31; // r1
  int v32; // r2
  int v33; // r3
  int v34; // r12
  int v35; // r1
  int v36; // r2
  int v37; // r3
  const char *v38; // r5
  const char **v40; // r3
  size_t v41; // r6
  char *v42; // r3
  char *v43; // r1
  char v44; // r2
  const char *v45; // [sp+0h] [bp-2Ch]
  int v48; // [sp+1Ch] [bp-10h] BYREF
  unsigned int v49; // [sp+20h] [bp-Ch]

  v6 = (_DWORD *)(a1 + 24);
  v8 = (_DWORD *)(a1 + 40);
  v10 = (_DWORD *)(a1 + 8);
  sub_317C0((_DWORD *)a1);
  v11 = v6[1];
  v12 = v6[2];
  v13 = v6[3];
  v14 = (const char *)*(unsigned __int8 *)(a1 + 36);
  *v8 = *v6;
  v8[1] = v11;
  v8[2] = v12;
  v8[3] = v13;
  v15 = ((unsigned __int8)v14 & 0xF7) == 35;
  if ( ((unsigned __int8)v14 & 0xF7) != 0x23 )
    v15 = v14 == (const char *)37;
  v16 = v10[1];
  v17 = v10[2];
  v18 = v10[3];
  v19 = !v15;
  *v6 = *v10;
  v6[1] = v16;
  v6[2] = v17;
  v6[3] = v18;
  *a5 = 0;
  if ( v15 )
  {
    if ( a6 )
    {
      v42 = "Cannot use '%c' on optional strings";
      v43 = "<format>";
      v44 = 9;
      v45 = v14;
      goto LABEL_36;
    }
    if ( strbuffer_init(&v48) )
    {
      sub_31760((int *)a1, "<internal>", 1, "Out of memory");
      *(_DWORD *)(a1 + 76) = 1;
    }
    while ( 1 )
    {
      v28 = (*a2)++;
      v29 = (char *)*v28;
      if ( !*v28 )
      {
        sub_31760((int *)a1, "<args>", 12, "NULL %s", a3);
        *(_DWORD *)(a1 + 76) = 1;
      }
      sub_317C0((_DWORD *)a1);
      v30 = *(unsigned __int8 *)(a1 + 36);
      if ( v30 == 35 )
        break;
      v20 = *(_DWORD *)(a1 + 76);
      if ( v30 == 37 )
      {
        v27 = *(*a2)++;
LABEL_21:
        if ( !v20 )
          goto LABEL_14;
        goto LABEL_16;
      }
      v21 = v6[1];
      v22 = v6[2];
      v23 = v6[3];
      *v8 = *v6;
      v8[1] = v21;
      v8[2] = v22;
      v8[3] = v23;
      v24 = v10[1];
      v25 = v10[2];
      v26 = v10[3];
      *v6 = *v10;
      v6[1] = v24;
      v6[2] = v25;
      v6[3] = v26;
      if ( !v20 )
      {
        v27 = strlen(v29);
LABEL_14:
        if ( strbuffer_append_bytes((const void **)&v48, v29, v27) == -1 )
        {
          sub_31760((int *)a1, "<internal>", 1, "Out of memory");
          *(_DWORD *)(a1 + 76) = 1;
        }
      }
LABEL_16:
      sub_317C0((_DWORD *)a1);
      if ( *(_BYTE *)(a1 + 36) != 43 )
      {
        v31 = v6[1];
        v32 = v6[2];
        v33 = v6[3];
        v34 = *(_DWORD *)(a1 + 76);
        *v8 = *v6;
        v8[1] = v31;
        v8[2] = v32;
        v8[3] = v33;
        v35 = v10[1];
        v36 = v10[2];
        v37 = v10[3];
        *v6 = *v10;
        v6[1] = v35;
        v6[2] = v36;
        v6[3] = v37;
        if ( v34 )
        {
          v38 = 0;
          strbuffer_close((int)&v48);
        }
        else
        {
          v38 = (const char *)utf8_check_string(v48, v49);
          if ( v38 )
          {
            *a4 = v49;
            *a5 = 1;
            return strbuffer_steal_value(&v48);
          }
          else
          {
            sub_31760((int *)a1, "<args>", 5, "Invalid UTF-8 %s", a3);
            strbuffer_close((int)&v48);
            *(_DWORD *)(a1 + 76) = 1;
          }
        }
        return (int)v38;
      }
    }
    v20 = *(_DWORD *)(a1 + 76);
    v27 = *(*a2)++;
    goto LABEL_21;
  }
  v40 = (const char **)(*a2)++;
  v38 = *v40;
  if ( *v40 )
  {
    v41 = strlen(*v40);
    v19 = utf8_check_string((int)v38, v41);
    if ( v19 )
    {
      *a4 = v41;
      return (int)v38;
    }
    v42 = "Invalid UTF-8 %s";
    v43 = "<args>";
    v45 = a3;
    v44 = 5;
LABEL_36:
    v38 = (const char *)v19;
    sub_31760((int *)a1, v43, v44, v42, v45);
    *(_DWORD *)(a1 + 76) = 1;
    return (int)v38;
  }
  if ( !a6 )
  {
    sub_31760((int *)a1, "<args>", 12, "NULL %s", a3);
    *(_DWORD *)(a1 + 76) = 1;
  }
  return (int)v38;
}

//----- (00031C24) --------------------------------------------------------
int __fastcall sub_31C24(int a1, _DWORD *a2, _QWORD ***a3)
{
  __int64 v3; // d0
  int v5; // r0
  int v8; // r6
  int v9; // r8
  bool v10; // zf
  int v11; // r9
  char **v12; // r3
  char *v13; // r8
  void *v14; // r0
  bool v15; // zf
  int v16; // r2
  int v17; // r2
  _QWORD **v18; // r3
  _QWORD *v19; // r4
  int v20; // r2
  _QWORD **v21; // r3
  _QWORD *v22; // r4
  int v23; // r3
  unsigned int *v24; // r3
  unsigned int v25; // r2
  _DWORD **v26; // r3
  _DWORD *v27; // r3
  int v28; // r2
  int v29; // r6
  unsigned int v30; // r8
  bool v31; // zf
  bool v32; // zf
  int v33; // r2
  int v34; // r2
  _DWORD **v35; // r3
  int v36; // r2
  _QWORD **v37; // r3
  _QWORD *v38; // r4
  _DWORD **v39; // r3
  _DWORD *v40; // r4
  int v41; // r2
  _DWORD **v43; // r3
  int v44; // r2
  _DWORD **v45; // r3
  _DWORD *v46; // r8
  _DWORD *v47; // r12
  _DWORD *v48; // lr
  int v49; // r0
  int v50; // r1
  int v51; // r2
  int v52; // r3
  _DWORD *v53; // r4
  int v54; // r1
  int v55; // r2
  int v56; // r3
  char *v57; // r3
  char *v58; // r1
  _DWORD *v59; // r0
  int v60; // r0
  char *v61; // r7
  int appended; // r8
  int v63; // r9
  int v64; // r0
  int v65; // r0
  int v66; // r0
  size_t v67; // r0
  _DWORD **v68; // r3
  _DWORD *v69; // r7
  const char *v70; // r0
  _DWORD *v71; // r0
  char *v72; // r3
  char *v73; // r1
  char *v74; // r12
  int *v75; // r0
  int v76; // [sp+0h] [bp-30h]
  const void *v77[3]; // [sp+8h] [bp-28h] BYREF
  unsigned int v78[7]; // [sp+14h] [bp-1Ch] BYREF

  v5 = *(unsigned __int8 *)(a1 + 36);
  switch ( v5 )
  {
    case 'F':
      if ( !a2 )
        goto LABEL_104;
      v17 = *a2;
      if ( (unsigned int)(*a2 - 3) > 1 )
      {
        v72 = "Expected real or integer, got %s";
        LOWORD(v73) = 4864;
        v74 = (&off_E1240)[v17];
        v75 = (int *)a1;
        goto LABEL_158;
      }
      v8 = *(_DWORD *)(a1 + 60) & 1;
      if ( v8 )
        return 0;
      v18 = (*a3)++;
      v19 = *v18;
      json_number_value((int)a2);
      *v19 = v3;
      return v8;
    case 'I':
      if ( !a2 )
        goto LABEL_104;
      v20 = *a2;
      if ( *a2 != 3 )
        goto LABEL_157;
      v8 = *(_DWORD *)(a1 + 60) & 1;
      if ( v8 )
        return 0;
      v21 = (*a3)++;
      v22 = *v21;
      *v22 = json_integer_value((int)a2);
      return v8;
    case 'O':
      v23 = *(_DWORD *)(a1 + 60) & 1;
      if ( !a2 )
        goto LABEL_90;
      if ( v23 )
        return 0;
      if ( a2[1] == -1 )
      {
        v43 = (_DWORD **)(*a3)++;
        goto LABEL_92;
      }
      v24 = a2 + 1;
      do
        v25 = __ldrex(v24);
      while ( __strex(v25 + 1, v24) );
      __dmb(0xBu);
      if ( (*(_DWORD *)(a1 + 60) & 1) == 0 )
      {
        v26 = (_DWORD **)(*a3)++;
        v27 = *v26;
        goto LABEL_93;
      }
      return 0;
    case '[':
      if ( a2 && (v28 = *a2, *a2 != 1) )
      {
        v72 = "Expected array, got %s";
        LOWORD(v73) = 4864;
        v74 = (&off_E1240)[v28];
        v75 = (int *)a1;
LABEL_158:
        HIWORD(v73) = (unsigned int)"<validation>" >> 16;
        v8 = -1;
        sub_31760(v75, v73, 10, v72, v74);
      }
      else
      {
        sub_317C0((_DWORD *)a1);
        v29 = *(unsigned __int8 *)(a1 + 36);
        if ( v29 == 93 )
        {
          v30 = 0;
LABEL_137:
          if ( (*(_DWORD *)(a1 + 60) & 2) == 0 )
            return 0;
LABEL_109:
          if ( a2 && json_array_size(a2) != (_DWORD *)v30 )
          {
            v8 = -1;
            v59 = json_array_size(a2);
            sub_31760((int *)a1, "<validation>", 7, "%li array item(s) left unpacked", (char *)v59 - v30);
            return v8;
          }
          return 0;
        }
        if ( !*(_BYTE *)(a1 + 36) )
        {
LABEL_132:
          sub_31760((int *)a1, "<format>", 9, "Unexpected end of format string");
          return -1;
        }
        v31 = v29 == 33;
        if ( v29 != 33 )
          v31 = v29 == 42;
        v30 = v31;
        if ( v31 )
        {
          v30 = 0;
LABEL_68:
          if ( v29 == 33 )
          {
            sub_317C0((_DWORD *)a1);
            v33 = *(unsigned __int8 *)(a1 + 36);
            if ( v33 == 93 )
              goto LABEL_109;
          }
          else
          {
            sub_317C0((_DWORD *)a1);
            v33 = *(unsigned __int8 *)(a1 + 36);
            if ( v33 == 93 )
              return 0;
            v29 = 42;
          }
          sub_31760((int *)a1, "<format>", 9, "Expected ']' after '%c', got '%c'", v29, v33);
          return -1;
        }
        while ( strchr("{[siIbfFOon", v29) )
        {
          if ( a2 && !json_array_get(a2, v30) )
          {
            v8 = -1;
            sub_31760((int *)a1, "<validation>", 17, "Array index %lu out of range", v30);
            return v8;
          }
          ++v30;
          if ( sub_31C24(a1) )
            return -1;
          sub_317C0((_DWORD *)a1);
          v29 = *(unsigned __int8 *)(a1 + 36);
          if ( v29 == 93 )
            goto LABEL_137;
          if ( !*(_BYTE *)(a1 + 36) )
            goto LABEL_132;
          v32 = v29 == 42;
          if ( v29 != 42 )
            v32 = v29 == 33;
          if ( v32 )
            goto LABEL_68;
        }
        LOWORD(v57) = 5128;
        LOWORD(v58) = 4788;
        v76 = v29;
LABEL_102:
        HIWORD(v57) = (unsigned int)"Unexpected format character '%c'" >> 16;
        HIWORD(v58) = (unsigned int)"<format>" >> 16;
        v8 = -1;
        sub_31760((int *)a1, v58, 9, v57, v76);
      }
      return v8;
    case 'b':
      if ( !a2 )
        goto LABEL_104;
      v34 = *a2;
      if ( (unsigned int)(*a2 - 5) > 1 )
      {
        v72 = "Expected true or false, got %s";
        LOWORD(v73) = 4864;
        v74 = (&off_E1240)[v34];
        v75 = (int *)a1;
        goto LABEL_158;
      }
      v8 = *(_DWORD *)(a1 + 60) & 1;
      if ( v8 )
        return 0;
      v35 = (_DWORD **)(*a3)++;
      **v35 = v34 == 5;
      return v8;
    case 'f':
      if ( !a2 )
        goto LABEL_104;
      v36 = *a2;
      if ( *a2 != 4 )
      {
        v72 = "Expected real, got %s";
        LOWORD(v73) = 4864;
        v74 = (&off_E1240)[v36];
        v75 = (int *)a1;
        goto LABEL_158;
      }
      v8 = *(_DWORD *)(a1 + 60) & 1;
      if ( v8 )
        return 0;
      v37 = (*a3)++;
      v38 = *v37;
      json_real_value();
      *v38 = v3;
      return v8;
    case 'i':
      if ( !a2 )
      {
LABEL_104:
        if ( (*(_DWORD *)(a1 + 60) & 1) == 0 )
          ++*a3;
        return 0;
      }
      v20 = *a2;
      if ( *a2 != 3 )
      {
LABEL_157:
        v72 = "Expected integer, got %s";
        LOWORD(v73) = (unsigned __int16)"<validation>";
        v74 = (&off_E1240)[v20];
        v75 = (int *)a1;
        goto LABEL_158;
      }
      v8 = *(_DWORD *)(a1 + 60) & 1;
      if ( v8 )
        return 0;
      v39 = (_DWORD **)(*a3)++;
      v40 = *v39;
      *v40 = json_integer_value((int)a2);
      return v8;
    case 'n':
      if ( !a2 )
        return 0;
      v41 = *a2;
      if ( *a2 == 7 )
        return 0;
      v72 = "Expected null, got %s";
      LOWORD(v73) = 4864;
      v74 = (&off_E1240)[v41];
      v75 = (int *)a1;
      goto LABEL_158;
    case 'o':
      v23 = *(_DWORD *)(a1 + 60) & 1;
LABEL_90:
      if ( !v23 )
      {
        v43 = (_DWORD **)(*a3)++;
        if ( a2 )
        {
LABEL_92:
          v27 = *v43;
LABEL_93:
          *v27 = a2;
        }
      }
      return 0;
    case 's':
      if ( a2 )
      {
        v44 = *a2;
        if ( *a2 != 2 )
        {
          v72 = "Expected string, got %s";
          LOWORD(v73) = 4864;
          v74 = (&off_E1240)[v44];
          v75 = (int *)a1;
          goto LABEL_158;
        }
      }
      v8 = *(_DWORD *)(a1 + 60) & 1;
      if ( v8 )
        return 0;
      v45 = (_DWORD **)(*a3)++;
      v46 = *v45;
      if ( *v45 )
      {
        sub_317C0((_DWORD *)a1);
        if ( *(_BYTE *)(a1 + 36) == 37 )
        {
          v68 = (_DWORD **)(*a3)++;
          v69 = *v68;
          if ( *v68 )
          {
            if ( !a2 )
              return 0;
            *v46 = json_string_value(a2);
            *v69 = json_string_length(a2);
          }
          else
          {
            sub_31760((int *)a1, "<args>", 12, "NULL string length argument");
            return -1;
          }
        }
        else
        {
          v47 = (_DWORD *)(a1 + 24);
          v48 = (_DWORD *)(a1 + 40);
          v49 = *(_DWORD *)(a1 + 24);
          v50 = *(_DWORD *)(a1 + 28);
          v51 = *(_DWORD *)(a1 + 32);
          v52 = *(_DWORD *)(a1 + 36);
          v53 = (_DWORD *)(a1 + 8);
          *v48 = v49;
          v48[1] = v50;
          v48[2] = v51;
          v48[3] = v52;
          v54 = v53[1];
          v55 = v53[2];
          v56 = v53[3];
          *v47 = *v53;
          v47[1] = v54;
          v47[2] = v55;
          v47[3] = v56;
          if ( !a2 )
            return 0;
          *v46 = json_string_value(a2);
        }
      }
      else
      {
        sub_31760((int *)a1, "<args>", 12, "NULL string argument");
        return -1;
      }
      return v8;
    case '{':
      v8 = hashtable_init(v78);
      if ( v8 )
      {
        sub_31760((int *)a1, "<internal>", 1, "Out of memory");
        return -1;
      }
      if ( a2 && *a2 )
      {
        v8 = -1;
        sub_31760((int *)a1, "<validation>", 10, "Expected object, got %s", (&off_E1240)[*a2]);
        goto LABEL_30;
      }
      sub_317C0((_DWORD *)a1);
      v9 = *(unsigned __int8 *)(a1 + 36);
      if ( v9 != 125 )
      {
        if ( *(_BYTE *)(a1 + 36) )
        {
          v10 = v9 == 33;
          if ( v9 != 33 )
            v10 = v9 == 42;
          v11 = v10;
          if ( v10 )
          {
            v11 = 0;
LABEL_25:
            if ( v9 == 33 )
            {
              sub_317C0((_DWORD *)a1);
              v16 = *(unsigned __int8 *)(a1 + 36);
              if ( v16 == 125 )
                goto LABEL_115;
            }
            else
            {
              sub_317C0((_DWORD *)a1);
              v16 = *(unsigned __int8 *)(a1 + 36);
              if ( v16 == 125 )
                goto LABEL_30;
              v9 = 42;
            }
            v8 = -1;
            sub_31760((int *)a1, "<format>", 9, "Expected '}' after '%c', got '%c'", v9, v16);
          }
          else
          {
            while ( 1 )
            {
              if ( v9 != 115 )
              {
                v8 = -1;
                sub_31760((int *)a1, "<format>", 9, "Expected format 's', got '%c'", v9);
                goto LABEL_30;
              }
              v12 = (char **)(*a3)++;
              v13 = *v12;
              if ( !*v12 )
              {
                sub_31760((int *)a1, "<args>", 12, "NULL object key");
                v8 = -1;
                goto LABEL_30;
              }
              sub_317C0((_DWORD *)a1);
              if ( *(_BYTE *)(a1 + 36) == 63 )
              {
                sub_317C0((_DWORD *)a1);
                v11 = 1;
                if ( a2 )
                  json_object_get(a2, v13);
              }
              else if ( a2 && !json_object_get(a2, v13) )
              {
                v8 = -1;
                sub_31760((int *)a1, "<validation>", 16, "Object item not found: %s", v13);
                goto LABEL_30;
              }
              if ( sub_31C24(a1) )
              {
                v8 = -1;
                goto LABEL_30;
              }
              v14 = json_null();
              hashtable_set(v78, v13, (unsigned int)v14);
              sub_317C0((_DWORD *)a1);
              v9 = *(unsigned __int8 *)(a1 + 36);
              if ( v9 == 125 )
                break;
              if ( !*(_BYTE *)(a1 + 36) )
                goto LABEL_140;
              v15 = v9 == 42;
              if ( v9 != 42 )
                v15 = v9 == 33;
              if ( v15 )
                goto LABEL_25;
            }
            if ( (*(_DWORD *)(a1 + 60) & 2) == 0 )
              goto LABEL_30;
LABEL_115:
            if ( a2 )
            {
              if ( v11 )
                goto LABEL_117;
              goto LABEL_155;
            }
          }
        }
        else
        {
LABEL_140:
          sub_31760((int *)a1, "<format>", 9, "Unexpected end of format string");
          v8 = -1;
        }
LABEL_30:
        hashtable_close((int)v78);
        return v8;
      }
      if ( (*(_DWORD *)(a1 + 60) & 2) == 0 || !a2 )
        goto LABEL_30;
LABEL_155:
      v71 = json_object_size(a2);
      if ( v71 == (_DWORD *)v78[0] )
        goto LABEL_30;
LABEL_117:
      v60 = json_object_iter(a2);
      v61 = (char *)json_object_iter_key(v60);
      if ( !v61 )
        goto LABEL_30;
      appended = 1;
      v63 = 0;
      break;
    default:
      LOWORD(v57) = (unsigned __int16)"Unexpected format character '%c'";
      LOWORD(v58) = (unsigned __int16)"<format>";
      v76 = v5;
      goto LABEL_102;
  }
  while ( 1 )
  {
    v66 = json_object_key_to_iter((int)v61);
    if ( !json_object_iter_value(v66) )
    {
LABEL_148:
      if ( v63 )
      {
        if ( appended )
          v70 = "<unknown>";
        else
          v70 = (const char *)strbuffer_value((int)v77);
        sub_31760((int *)a1, "<validation>", 7, "%li object item(s) left unpacked: %s", v63, v70);
        v8 = -1;
        strbuffer_close((int)v77);
      }
      goto LABEL_30;
    }
    if ( !hashtable_get((int)v78, v61) )
    {
      ++v63;
      if ( appended == 1 )
      {
        appended = strbuffer_init(v77);
LABEL_126:
        if ( !appended )
        {
          v67 = strlen(v61);
          appended = strbuffer_append_bytes(v77, v61, v67);
        }
        goto LABEL_120;
      }
      if ( !appended )
      {
        appended = strbuffer_append_bytes(v77, ", ", 2u);
        goto LABEL_126;
      }
    }
LABEL_120:
    v64 = json_object_key_to_iter((int)v61);
    v65 = json_object_iter_next(a2, v64);
    v61 = (char *)json_object_iter_key(v65);
    if ( !v61 )
      goto LABEL_148;
  }
}
// 31C48: control flows out of bounds to 31C4C
// 31EA8: variable 'v3' is possibly undefined
// E1240: using guessed type char *off_E1240;

//----- (00032764) --------------------------------------------------------
void *__fastcall sub_32764(int a1, int **a2, int a3)
{
  int v6; // lr
  bool v7; // zf
  int v8; // r1
  int v9; // r2
  int v10; // r3
  int v11; // r1
  int v12; // r2
  int v13; // r3
  int *v14; // r3
  int v15; // r5
  unsigned int *v17; // r3
  unsigned int v18; // r2

  sub_317C0((_DWORD *)a1);
  v6 = *(unsigned __int8 *)(a1 + 36);
  v7 = v6 == 63;
  if ( v6 != 63 )
    v7 = v6 == 42;
  if ( !v7 )
  {
    v8 = *(_DWORD *)(a1 + 28);
    v9 = *(_DWORD *)(a1 + 32);
    v10 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 44) = v8;
    *(_DWORD *)(a1 + 48) = v9;
    *(_DWORD *)(a1 + 52) = v10;
    v11 = *(_DWORD *)(a1 + 12);
    v12 = *(_DWORD *)(a1 + 16);
    v13 = *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 28) = v11;
    *(_DWORD *)(a1 + 32) = v12;
    *(_DWORD *)(a1 + 36) = v13;
  }
  v14 = (*a2)++;
  v15 = *v14;
  if ( *v14 )
  {
    if ( !a3 || *(_DWORD *)(v15 + 4) == -1 )
      return (void *)*v14;
    v17 = (unsigned int *)(v15 + 4);
    do
      v18 = __ldrex(v17);
    while ( __strex(v18 + 1, v17) );
    __dmb(0xBu);
    return (void *)v15;
  }
  else
  {
    if ( v6 == 42 )
      return (void *)*v14;
    if ( v6 == 63 )
    {
      return json_null();
    }
    else
    {
      sub_31760((int *)a1, "<args>", 12, "NULL object");
      *(_DWORD *)(a1 + 76) = 1;
      return 0;
    }
  }
}

//----- (00032840) --------------------------------------------------------
double *__fastcall sub_32840(int *a1, int **a2)
{
  double *v4; // r6
  int v6; // r7
  bool v7; // zf
  int v8; // r8
  int v9; // r1
  int v10; // r2
  int v11; // r3
  int v12; // r1
  int v13; // r2
  int v14; // r3
  _BYTE *v15; // r0
  int v16; // r2
  char *v17; // r7
  int v18; // r1
  int v19; // r2
  int v20; // r3
  int v21; // r9
  int v22; // r1
  int v23; // r2
  int v24; // r3
  _DWORD *v25; // r0
  _DWORD *v26; // r2
  unsigned int *v27; // r3
  unsigned int v28; // r1
  unsigned int v29; // r1
  int v30; // r1
  int v31; // r2
  int v32; // r3
  int v33; // r8
  int v34; // r1
  int v35; // r2
  int v36; // r3
  _DWORD *v37; // r0
  _DWORD *v38; // r1
  unsigned int *v39; // r3
  unsigned int v40; // r2
  unsigned int v41; // r2
  __int64 *v42; // r3
  __int64 v43; // r0
  double *v44; // r0
  unsigned int *v45; // r3
  unsigned int v46; // r2
  unsigned int v47; // r2
  int v48; // r0
  unsigned int *v50; // r3
  unsigned int v51; // r2
  unsigned int v52; // r2
  double *v53; // r0
  unsigned int *v54; // r3
  unsigned int v55; // r2
  _DWORD *v56; // [sp+8h] [bp-14h]
  _DWORD *v57; // [sp+Ch] [bp-10h]
  size_t v58; // [sp+10h] [bp-Ch] BYREF
  _DWORD v59[2]; // [sp+14h] [bp-8h] BYREF

  switch ( *((_BYTE *)a1 + 36) )
  {
    case 'I':
      v42 = (__int64 *)(((unsigned int)*a2 + 7) & 0xFFFFFFF8);
      v43 = *v42;
      *a2 = (int *)(v42 + 1);
      v4 = (double *)json_integer(v43);
      if ( v4 )
        return v4;
      goto LABEL_49;
    case 'O':
      return (double *)sub_32764((int)a1, a2, 1);
    case '[':
      v4 = (double *)json_array();
      sub_317C0(a1);
      while ( 2 )
      {
        if ( *((_BYTE *)a1 + 36) == 93 )
        {
          if ( !a1[19] )
            return v4;
        }
        else
        {
          if ( *((_BYTE *)a1 + 36) )
          {
            sub_317C0(a1);
            v30 = a1[7];
            v31 = a1[8];
            v32 = a1[9];
            v33 = *((unsigned __int8 *)a1 + 36);
            a1[10] = a1[6];
            a1[11] = v30;
            a1[12] = v31;
            a1[13] = v32;
            v34 = a1[3];
            v35 = a1[4];
            v36 = a1[5];
            a1[6] = a1[2];
            a1[7] = v34;
            a1[8] = v35;
            a1[9] = v36;
            v37 = (_DWORD *)sub_32840(a1, a2);
            v38 = v37;
            if ( v37 )
            {
              if ( !a1[19] )
                goto LABEL_95;
              if ( v37[1] != -1 )
              {
                v39 = v37 + 1;
                __dmb(0xBu);
                do
                {
                  v40 = __ldrex(v39);
                  v41 = v40 - 1;
                }
                while ( __strex(v41, v39) );
                if ( !v41 )
                {
                  v56 = v37;
                  json_delete(v37);
                  v38 = v56;
                }
                if ( !a1[19] )
                {
LABEL_95:
                  if ( json_array_append_new(v4, v38) )
                  {
                    sub_31760(a1, "<internal>", 1, "Unable to append to array");
                    a1[19] = 1;
                  }
                }
              }
            }
            else if ( v33 != 42 )
            {
              a1[19] = 1;
            }
            sub_317C0(a1);
            continue;
          }
          sub_31760(a1, "<format>", 9, "Unexpected end of format string");
        }
        break;
      }
      if ( !v4 || *((_DWORD *)v4 + 1) == -1 )
        return 0;
      v50 = (unsigned int *)v4 + 1;
      __dmb(0xBu);
      do
      {
        v51 = __ldrex(v50);
        v52 = v51 - 1;
      }
      while ( __strex(v52, v50) );
      goto LABEL_81;
    case 'b':
      if ( *(*a2)++ )
        return (double *)json_true();
      else
        return (double *)json_false();
    case 'f':
      *a2 = (int *)((((unsigned int)*a2 + 7) & 0xFFFFFFF8) + 8);
      v44 = json_real();
      v4 = v44;
      if ( !v44 )
        goto LABEL_49;
      if ( json_real_set((int)v44) )
      {
        if ( *((_DWORD *)v4 + 1) != -1 )
        {
          v45 = (unsigned int *)v4 + 1;
          __dmb(0xBu);
          do
          {
            v46 = __ldrex(v45);
            v47 = v46 - 1;
          }
          while ( __strex(v47, v45) );
          if ( !v47 )
            json_delete(v4);
        }
        sub_31760(a1, "<args>", 15, "Invalid floating point value");
        v4 = 0;
        a1[19] = 1;
      }
      return v4;
    case 'i':
      v48 = *(*a2)++;
      v4 = (double *)json_integer(v48);
      if ( !v4 )
      {
LABEL_49:
        sub_31760(a1, "<internal>", 1, "Out of memory");
        a1[19] = 1;
      }
      return v4;
    case 'n':
      return (double *)json_null();
    case 'o':
      return (double *)sub_32764((int)a1, a2, 0);
    case 's':
      sub_317C0(a1);
      v6 = *((unsigned __int8 *)a1 + 36);
      v7 = v6 == 42;
      if ( v6 != 42 )
        v7 = v6 == 63;
      v8 = v7;
      if ( v7 )
      {
        v15 = (_BYTE *)sub_318F0((int)a1, (size_t **)a2, "string", &v58, v59, v8);
        if ( !v15 )
        {
          if ( v6 == 63 && !a1[19] )
            return (double *)json_null();
          return 0;
        }
      }
      else
      {
        v9 = a1[7];
        v10 = a1[8];
        v11 = a1[9];
        a1[10] = a1[6];
        a1[11] = v9;
        a1[12] = v10;
        a1[13] = v11;
        v12 = a1[3];
        v13 = a1[4];
        v14 = a1[5];
        a1[6] = a1[2];
        a1[7] = v12;
        a1[8] = v13;
        a1[9] = v14;
        v15 = (_BYTE *)sub_318F0((int)a1, (size_t **)a2, "string", &v58, v59, v8);
        if ( !v15 )
          return 0;
      }
      if ( a1[19] )
        return 0;
      if ( v59[0] )
        return (double *)jsonp_stringn_nocheck_own(v15, v58);
      else
        return (double *)json_stringn_nocheck(v15, v58);
    case '{':
      v4 = (double *)json_object();
      sub_317C0(a1);
      break;
    default:
      sub_31760(a1, "<format>", 9, "Unexpected format character '%c'", *((unsigned __int8 *)a1 + 36));
      v4 = 0;
      a1[19] = 1;
      return v4;
  }
  while ( 1 )
  {
    v16 = *((unsigned __int8 *)a1 + 36);
    if ( v16 == 125 )
    {
      if ( a1[19] )
        goto LABEL_85;
      return v4;
    }
    if ( !*((_BYTE *)a1 + 36) )
    {
      sub_31760(a1, "<format>", 9, "Unexpected end of format string");
      goto LABEL_85;
    }
    if ( v16 != 115 )
      break;
    v17 = (char *)sub_318F0((int)a1, (size_t **)a2, "object key", &v58, v59, 0);
    sub_317C0(a1);
    sub_317C0(a1);
    v18 = a1[7];
    v19 = a1[8];
    v20 = a1[9];
    v21 = *((unsigned __int8 *)a1 + 36);
    a1[10] = a1[6];
    a1[11] = v18;
    a1[12] = v19;
    a1[13] = v20;
    v22 = a1[3];
    v23 = a1[4];
    v24 = a1[5];
    a1[6] = a1[2];
    a1[7] = v22;
    a1[8] = v23;
    a1[9] = v24;
    v25 = (_DWORD *)sub_32840(a1, a2);
    v26 = v25;
    if ( v25 )
    {
      if ( !a1[19] )
        goto LABEL_16;
      if ( v25[1] != -1 )
      {
        v27 = v25 + 1;
        __dmb(0xBu);
        do
        {
          v28 = __ldrex(v27);
          v29 = v28 - 1;
        }
        while ( __strex(v29, v27) );
        if ( !v29 )
        {
          v57 = v25;
          json_delete(v25);
          v26 = v57;
        }
        if ( a1[19] )
        {
          if ( !v59[0] )
            goto LABEL_19;
          goto LABEL_32;
        }
LABEL_16:
        if ( json_object_set_new_nocheck(v4, v17, v26) )
        {
          sub_31760(a1, "<internal>", 1, "Unable to add key \"%s\"", v17);
          a1[19] = 1;
        }
      }
      if ( !v59[0] )
        goto LABEL_19;
LABEL_32:
      jsonp_free(v17);
      goto LABEL_19;
    }
    if ( v59[0] )
      jsonp_free(v17);
    if ( v21 != 42 )
    {
      sub_31760(a1, "<args>", 12, "NULL object value");
      a1[19] = 1;
    }
LABEL_19:
    sub_317C0(a1);
  }
  sub_31760(a1, "<format>", 9, "Expected format 's', got '%c'", *((unsigned __int8 *)a1 + 36));
LABEL_85:
  if ( v4 && *((_DWORD *)v4 + 1) != -1 )
  {
    v54 = (unsigned int *)v4 + 1;
    __dmb(0xBu);
    do
    {
      v55 = __ldrex(v54);
      v52 = v55 - 1;
    }
    while ( __strex(v52, v54) );
LABEL_81:
    if ( !v52 )
    {
      v53 = v4;
      v4 = 0;
      json_delete(v53);
      return v4;
    }
  }
  return 0;
}
// 32864: control flows out of bounds to 32868

//----- (00032F98) --------------------------------------------------------
double *__fastcall json_vpack_ex(char *a1, int a2, _BYTE *a3, int *a4)
{
  double *v8; // r4
  unsigned int *v10; // r3
  unsigned int v11; // r2
  unsigned int v12; // r2
  int *v13; // [sp+Ch] [bp-58h] BYREF
  int v14[9]; // [sp+10h] [bp-54h] BYREF
  int v15; // [sp+34h] [bp-30h]
  int v16; // [sp+38h] [bp-2Ch]
  int v17; // [sp+3Ch] [bp-28h]
  int v18; // [sp+40h] [bp-24h]
  int v19; // [sp+44h] [bp-20h]
  char *v20; // [sp+48h] [bp-1Ch]
  int v21; // [sp+4Ch] [bp-18h]
  int v22; // [sp+50h] [bp-14h]
  int v23; // [sp+54h] [bp-10h]
  int v24; // [sp+58h] [bp-Ch]
  int v25; // [sp+5Ch] [bp-8h]

  if ( a3 && *a3 )
  {
    jsonp_error_init(a1, 0);
    v14[0] = (int)a3;
    v14[1] = (int)a3;
    memset(&v14[2], 0, 28);
    v16 = 0;
    v23 = 0;
    v24 = 0;
    v25 = 0;
    v15 = 0;
    v17 = 0;
    v18 = 0;
    v19 = 0;
    v22 = 1;
    v20 = a1;
    v21 = a2;
    sub_317C0(v14);
    v13 = a4;
    v8 = sub_32840(v14, &v13);
    if ( v8 )
    {
      sub_317C0(v14);
      if ( (_BYTE)v15 )
      {
        if ( *((_DWORD *)v8 + 1) != -1 )
        {
          v10 = (unsigned int *)v8 + 1;
          __dmb(0xBu);
          do
          {
            v11 = __ldrex(v10);
            v12 = v11 - 1;
          }
          while ( __strex(v12, v10) );
          if ( !v12 )
            json_delete(v8);
        }
        v8 = 0;
        sub_31760(v14, "<format>", 9, "Garbage after format string");
      }
    }
    return v8;
  }
  else
  {
    jsonp_error_init(a1, "<format>");
    jsonp_error_set((int)a1, -1, -1, 0, 4, "NULL or empty format string");
    return 0;
  }
}

//----- (00033104) --------------------------------------------------------
double *qsnprintf(wchar_t *a1, int a2, wchar_t *a3, ...)
{
  va_list varg_r3; // [sp+14h] [bp+8h] BYREF

  va_start(varg_r3, a3);
  return json_vpack_ex((char *)a1, a2, a3, (int *)varg_r3);
}

//----- (00033134) --------------------------------------------------------
double *json_pack(_BYTE *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+8h] BYREF

  va_start(varg_r1, a1);
  return json_vpack_ex(0, 0, a1, (int *)varg_r1);
}

//----- (0003316C) --------------------------------------------------------
int __fastcall json_vunpack_ex(_DWORD *a1, char *a2, int a3, _BYTE *a4, _QWORD **a5)
{
  int v9; // r4
  _QWORD **v11; // [sp+Ch] [bp-58h] BYREF
  int v12[9]; // [sp+10h] [bp-54h] BYREF
  int v13; // [sp+34h] [bp-30h]
  int v14; // [sp+38h] [bp-2Ch]
  int v15; // [sp+3Ch] [bp-28h]
  int v16; // [sp+40h] [bp-24h]
  int v17; // [sp+44h] [bp-20h]
  char *v18; // [sp+48h] [bp-1Ch]
  int v19; // [sp+4Ch] [bp-18h]
  int v20; // [sp+50h] [bp-14h]
  int v21; // [sp+54h] [bp-10h]
  int v22; // [sp+58h] [bp-Ch]
  int v23; // [sp+5Ch] [bp-8h]

  if ( a1 )
  {
    if ( a4 && *a4 )
    {
      jsonp_error_init(a2, 0);
      v12[0] = (int)a4;
      v12[1] = (int)a4;
      memset(&v12[2], 0, 28);
      v14 = 0;
      v21 = 0;
      v22 = 0;
      v23 = 0;
      v13 = 0;
      v15 = 0;
      v16 = 0;
      v17 = 0;
      v20 = 1;
      v18 = a2;
      v19 = a3;
      sub_317C0(v12);
      v11 = a5;
      v9 = sub_31C24((int)v12, a1, &v11);
      if ( v9 )
      {
        return -1;
      }
      else
      {
        sub_317C0(v12);
        if ( (_BYTE)v13 )
        {
          sub_31760(v12, "<format>", 9, "Garbage after format string");
          return -1;
        }
      }
    }
    else
    {
      v9 = -1;
      jsonp_error_init(a2, "<format>");
      jsonp_error_set((int)a2, -1, -1, 0, 4, "NULL or empty format string");
    }
  }
  else
  {
    v9 = -1;
    jsonp_error_init(a2, "<root>");
    jsonp_error_set((int)a2, -1, -1, 0, 12, "NULL root value");
  }
  return v9;
}

//----- (000332F0) --------------------------------------------------------
int json_unpack_ex(_DWORD *a1, char *a2, int a3, _BYTE *a4, ...)
{
  va_list va; // [sp+18h] [bp+Ch] BYREF

  va_start(va, a4);
  return json_vunpack_ex(a1, a2, a3, a4, (_QWORD **)va);
}

//----- (00033320) --------------------------------------------------------
int json_unpack(_DWORD *a1, _BYTE *a2, ...)
{
  va_list varg_r2; // [sp+18h] [bp+8h] BYREF

  va_start(varg_r2, a2);
  return json_vunpack_ex(a1, 0, 0, a2, (_QWORD **)varg_r2);
}

//----- (00033358) --------------------------------------------------------
int __fastcall strbuffer_init(_DWORD *a1)
{
  _BYTE *v2; // r0

  a1[2] = 16;
  a1[1] = 0;
  v2 = jsonp_malloc((void *)0x10);
  *a1 = v2;
  if ( !v2 )
    return -1;
  *v2 = 0;
  return 0;
}

//----- (0003338C) --------------------------------------------------------
void __fastcall strbuffer_close(int a1)
{
  void *v2; // r0

  v2 = *(void **)a1;
  if ( v2 )
    jsonp_free(v2);
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)a1 = 0;
}

//----- (000333B8) --------------------------------------------------------
int __fastcall strbuffer_clear(int result)
{
  _BYTE *v1; // r2

  v1 = *(_BYTE **)result;
  *(_DWORD *)(result + 4) = 0;
  *v1 = 0;
  return result;
}

//----- (000333CC) --------------------------------------------------------
int __fastcall strbuffer_value(int a1)
{
  return *(_DWORD *)a1;
}

//----- (000333D4) --------------------------------------------------------
int __fastcall strbuffer_steal_value(int *a1)
{
  int result; // r0

  result = *a1;
  *a1 = 0;
  return result;
}

//----- (000333E8) --------------------------------------------------------
int __fastcall strbuffer_append_bytes(const void **a1, void *src, size_t n)
{
  unsigned int v4; // r3
  _BYTE *v7; // r0
  const void *v8; // r8
  unsigned int v9; // r3
  unsigned int v10; // r0
  void *v11; // r6
  void *v12; // r0
  const void *v13; // r2
  char *v15; // r5

  v4 = (unsigned int)a1[2];
  v7 = a1[1];
  if ( v4 - (unsigned int)v7 > n )
  {
    v8 = *a1;
LABEL_10:
    memcpy(&v7[(_DWORD)v8], src, n);
    v13 = *a1;
    v15 = (char *)a1[1] + n;
    a1[1] = v15;
    v15[(_DWORD)v13] = 0;
    return 0;
  }
  if ( !((n == -1) | (v4 >> 31)) && -2 - n >= (unsigned int)v7 )
  {
    v9 = 2 * v4;
    v10 = (unsigned int)&v7[n + 1];
    v11 = (void *)(v10 < v9 ? v9 : v10);
    v12 = jsonp_malloc(v11);
    v8 = v12;
    if ( v12 )
    {
      memcpy(v12, *a1, (size_t)a1[1]);
      jsonp_free((void *)*a1);
      v7 = a1[1];
      *a1 = v8;
      a1[2] = v11;
      goto LABEL_10;
    }
  }
  return -1;
}

//----- (000334B4) --------------------------------------------------------
int __fastcall fh_buffer_putc(const void **a1, char a2)
{
  char v3; // [sp+7h] [bp-5h] BYREF

  v3 = a2;
  return strbuffer_append_bytes(a1, &v3, 1u);
}

//----- (000334D8) --------------------------------------------------------
int __fastcall strbuffer_pop(int *a1, char a2, int a3)
{
  int v3; // r3
  bool v4; // zf
  int result; // r0

  v3 = a1[1];
  v4 = v3 == 0;
  if ( v3 )
  {
    a3 = *a1;
    --v3;
    a2 = 0;
    a1[1] = v3;
    result = *(unsigned __int8 *)(a3 + v3);
  }
  else
  {
    result = 0;
  }
  if ( !v4 )
    *(_BYTE *)(a3 + v3) = a2;
  return result;
}

//----- (00033500) --------------------------------------------------------
int __fastcall jsonp_strtod(const char **a1, double *a2)
{
  double v2; // d0
  struct lconv *v5; // r0
  const char *v6; // r4
  int v7; // r6
  char *v8; // r0
  int *v9; // r5
  int result; // r0
  char *endptr; // [sp+4h] [bp-8h] BYREF

  v5 = localeconv();
  v6 = *a1;
  v7 = *(unsigned __int8 *)v5->decimal_point;
  if ( v7 != 46 )
  {
    v8 = strchr(*a1, 46);
    if ( v8 )
    {
      *v8 = v7;
      v6 = *a1;
    }
  }
  v9 = _errno_location();
  *v9 = 0;
  strtod(v6, &endptr);
  if ( (v2 > 1.79769313e308 || v2 < -1.79769313e308) && *v9 == 34 )
    return -1;
  result = 0;
  *a2 = v2;
  return result;
}
// 33568: variable 'v2' is possibly undefined

//----- (000335B0) --------------------------------------------------------
int __fastcall jsonp_dtostr(char *a1, size_t a2, int a3, int a4)
{
  int v4; // s0
  int v5; // s1
  bool v6; // zf
  const char *v7; // r2
  unsigned int v10; // r0
  unsigned int v11; // r6
  int v12; // r1
  char *v13; // r0
  char *v14; // r5
  char *v15; // r0
  unsigned __int8 *v16; // r4
  int v17; // r3
  _BYTE *v18; // r5
  int v19; // t1
  size_t v20; // r2
  char *v22; // r3

  v6 = a3 == 0;
  if ( a3 )
    a4 = a3;
  LOWORD(v7) = 5680;
  if ( v6 )
    a4 = 17;
  HIWORD(v7) = 14;
  v10 = snprintf(a1, a2, v7, a4, v4, v5);
  if ( a2 > v10 )
  {
    v11 = v10;
    v12 = *(unsigned __int8 *)localeconv()->decimal_point;
    if ( v12 != 46 )
    {
      v13 = strchr(a1, v12);
      if ( v13 )
        *v13 = 46;
    }
    v14 = strchr(a1, 46);
    v15 = strchr(a1, 101);
    if ( v14 )
    {
LABEL_10:
      if ( !v15 )
        return v11;
      goto LABEL_11;
    }
    if ( v15 )
    {
LABEL_11:
      v16 = (unsigned __int8 *)(v15 + 2);
      v17 = (unsigned __int8)v15[2];
      if ( v15[1] != 45 )
      {
        v18 = v15 + 1;
        if ( v17 != 48 )
        {
LABEL_14:
          if ( v16 != v18 )
          {
            v20 = v11 - (v16 - (unsigned __int8 *)a1);
            v11 -= v16 - v18;
            memmove(v18, v16, v20);
          }
          return v11;
        }
        do
LABEL_13:
          v19 = *++v16;
        while ( v19 == 48 );
        goto LABEL_14;
      }
      if ( v17 == 48 )
      {
        v18 = v15 + 2;
        goto LABEL_13;
      }
      return v11;
    }
    if ( v11 + 3 < a2 )
    {
      a1[v11] = 46;
      v22 = &a1[v11];
      v11 += 2;
      v22[1] = 48;
      a1[v11] = 0;
      v15 = strchr(a1, 101);
      goto LABEL_10;
    }
  }
  return -1;
}
// 335D8: variable 'v4' is possibly undefined
// 335D8: variable 'v5' is possibly undefined

//----- (000336F0) --------------------------------------------------------
int __fastcall utf8_encode(int a1, _BYTE *a2, _DWORD *a3)
{
  char v3; // r3
  char v5; // r3
  char v6; // r3
  unsigned int v7; // r12

  if ( a1 < 0 )
    return -1;
  if ( a1 <= 127 )
  {
    *a2 = a1;
    *a3 = 1;
    return 0;
  }
  else if ( a1 < 2048 )
  {
    v5 = (a1 & 0x3F) + 0x80;
    *a2 = (a1 >> 6) - 64;
    a2[1] = v5;
    *a3 = 2;
    return 0;
  }
  else if ( a1 < 0x10000 )
  {
    v6 = (a1 & 0x3F) + 0x80;
    v7 = (((unsigned int)a1 >> 6) & 0x3F) - 128;
    *a2 = (a1 >> 12) - 32;
    a2[1] = v7;
    a2[2] = v6;
    *a3 = 3;
    return 0;
  }
  else if ( a1 >= 1114112 )
  {
    return -1;
  }
  else
  {
    v3 = (a1 & 0x3F) + 0x80;
    *a2 = (a1 >> 18) - 16;
    a2[1] = (((unsigned int)a1 >> 12) & 0x3F) + 0x80;
    a2[2] = (((unsigned int)a1 >> 6) & 0x3F) + 0x80;
    a2[3] = v3;
    *a3 = 4;
    return 0;
  }
}

//----- (000337DC) --------------------------------------------------------
int __fastcall utf8_check_first(int a1)
{
  if ( (a1 & 0x80) == 0 )
    return 1;
  if ( (a1 ^ 0x80u) <= 0x41 )
    return 0;
  if ( (unsigned __int8)(a1 + 62) <= 0x1Du )
    return 2;
  if ( (unsigned __int8)(a1 + 32) <= 0xFu )
    return 3;
  if ( (unsigned __int8)(a1 + 16) <= 4u )
    return 4;
  return 0;
}

//----- (00033848) --------------------------------------------------------
bool __fastcall utf8_check_full(char *a1, unsigned int a2, int *a3)
{
  char v3; // lr
  int v4; // lr
  _BOOL4 result; // r0
  int v6; // r3
  char *v7; // r0
  unsigned int v8; // r12
  int v9; // t1
  bool v10; // zf
  _BOOL4 v11; // r3
  _BOOL4 v12; // r1

  v3 = *a1;
  switch ( a2 )
  {
    case 2u:
      v4 = v3 & 0x1F;
      break;
    case 3u:
      v4 = v3 & 0xF;
      break;
    case 4u:
      v4 = v3 & 7;
      break;
    default:
      return 0;
  }
  v6 = (unsigned __int8)a1[1];
  if ( (v6 ^ 0x80u) > 0x3F )
    return 0;
  v7 = a1 + 1;
  v8 = 1;
  while ( 1 )
  {
    ++v8;
    v4 = (v6 & 0x3F) + (v4 << 6);
    if ( a2 <= v8 )
      break;
    v9 = (unsigned __int8)*++v7;
    LOBYTE(v6) = v9;
    if ( (v9 ^ 0x80u) > 0x3F )
      return 0;
  }
  if ( v4 >= 1114112 || (unsigned int)(v4 - 55296) < 0x800 )
    return 0;
  v10 = v4 == 127;
  if ( v4 <= 127 )
    v10 = a2 == 2;
  result = v10;
  if ( v10 )
    return 0;
  v11 = a2 == 3;
  if ( v4 >= 2048 )
    v11 = 0;
  if ( !v11 )
  {
    v12 = a2 == 4;
    if ( v4 >= 0x10000 )
      v12 = 0;
    if ( !v12 )
    {
      result = 1;
      if ( a3 )
        *a3 = v4;
      return result;
    }
    return 0;
  }
  return result;
}

//----- (00033930) --------------------------------------------------------
char *__fastcall utf8_iterate(char *result, int a2, _DWORD *a3)
{
  char *v4; // r4
  unsigned int v5; // r0
  unsigned int v6; // r1
  int v7; // r2
  unsigned int v8; // r6
  int v9; // [sp+4h] [bp-14h] BYREF

  if ( a2 )
  {
    v4 = result;
    v5 = utf8_check_first((unsigned __int8)*result);
    v8 = v5;
    if ( v5 )
    {
      if ( v5 == 1 )
      {
        v9 = v7;
LABEL_7:
        result = &v4[v8];
        if ( a3 )
          *a3 = v9;
        return result;
      }
      if ( v6 >= v5 && utf8_check_full(v4, v5, &v9) )
        goto LABEL_7;
    }
    return 0;
  }
  return result;
}
// 33960: variable 'v7' is possibly undefined
// 3396C: variable 'v6' is possibly undefined

//----- (000339AC) --------------------------------------------------------
int __fastcall utf8_check_string(int a1, unsigned int a2)
{
  int v4; // r4
  unsigned int v5; // r5
  char *v6; // r0

  if ( !a2 )
    return 1;
  v4 = 0;
  while ( 1 )
  {
    v5 = utf8_check_first(*(unsigned __int8 *)(a1 + v4));
    v6 = (char *)(a1 + v4);
    if ( !v5 )
      break;
    if ( v5 > 1 )
    {
      if ( a2 - v4 < v5 )
        break;
      v4 = v5 + v4 - 1;
      if ( !utf8_check_full(v6, v5, 0) )
        break;
    }
    if ( a2 <= ++v4 )
      return 1;
  }
  return 0;
}

//----- (00033A28) --------------------------------------------------------
_QWORD *__fastcall sub_33A28(int a1)
{
  __int64 v1; // r4
  _QWORD *result; // r0

  if ( a1 && *(_DWORD *)a1 == 3 )
    v1 = *(_QWORD *)(a1 + 8);
  else
    v1 = 0;
  result = jsonp_malloc((void *)0x10);
  if ( result )
  {
    result[1] = v1;
    *(_DWORD *)result = 3;
    *((_DWORD *)result + 1) = 1;
  }
  return result;
}

//----- (00033A78) --------------------------------------------------------
void *__fastcall sub_33A78(_DWORD *a1, int a2, int a3)
{
  unsigned int v3; // r12
  void *v4; // r5
  unsigned int v6; // r3
  unsigned int v7; // r12
  unsigned int v10; // r7
  void *v11; // r0

  v3 = a1[2];
  v4 = (void *)a1[4];
  if ( a2 + a1[3] <= v3 )
    return v4;
  v6 = 2 * v3;
  v7 = v3 + a2;
  if ( v6 < v7 )
    v10 = v7;
  else
    v10 = v6;
  v11 = jsonp_malloc((void *)(4 * v10));
  if ( !v11 )
    return 0;
  a1[2] = v10;
  a1[4] = v11;
  if ( !a3 )
    return v4;
  memcpy(v11, v4, 4 * a1[3]);
  jsonp_free(v4);
  return (void *)a1[4];
}

//----- (00033B04) --------------------------------------------------------
_DWORD *__fastcall sub_33B04(_BYTE *a1, size_t a2, int a3)
{
  _BYTE *v3; // r5
  _DWORD *result; // r0

  v3 = a1;
  if ( !a1 )
    return 0;
  if ( !a3 )
  {
    v3 = jsonp_strndup(a1, a2);
    if ( !v3 )
      return 0;
  }
  result = jsonp_malloc((void *)0x10);
  if ( result )
  {
    result[2] = v3;
    result[3] = a2;
    *result = 2;
    result[1] = 1;
  }
  else
  {
    jsonp_free(v3);
    return 0;
  }
  return result;
}

//----- (00033B70) --------------------------------------------------------
_DWORD *json_object()
{
  _DWORD *v0; // r4
  void *v2; // r0

  v0 = jsonp_malloc((void *)0x24);
  if ( v0 )
  {
    if ( !hashtable_seed )
      json_object_seed(0);
    v0[1] = 1;
    *v0 = 0;
    if ( hashtable_init(v0 + 2) )
    {
      v2 = v0;
      v0 = 0;
      jsonp_free(v2);
    }
  }
  return v0;
}
// 1085DC: using guessed type int hashtable_seed;

//----- (00033BD8) --------------------------------------------------------
_DWORD *__fastcall json_object_size(_DWORD *result)
{
  if ( result )
  {
    if ( *result )
      return 0;
    else
      return (_DWORD *)result[2];
  }
  return result;
}

//----- (00033BF4) --------------------------------------------------------
int __fastcall json_object_get(_DWORD *a1, char *a2)
{
  bool v2; // zf

  v2 = a1 == 0;
  if ( a1 )
    v2 = a2 == 0;
  if ( v2 || *a1 )
    return 0;
  else
    return hashtable_get((int)(a1 + 2), a2);
}

//----- (00033C1C) --------------------------------------------------------
bool __fastcall sub_33C1C(int *a1, int *a2)
{
  int v2; // r3
  int v6; // r7
  int v7; // r2
  unsigned int v8; // r6
  int v9; // r1
  bool v10; // zf
  int v11; // r0
  int v12; // r8
  int v13; // r0
  int v14; // r1
  int v15; // r0
  char *v16; // r6
  int v17; // r7
  int v18; // r0
  char *v19; // r1
  int v20; // r6
  size_t v21; // r2

  v2 = *a1;
  if ( *a1 != *a2 )
    return 0;
  if ( a1 == a2 )
    return 1;
  switch ( v2 )
  {
    case 0:
      if ( a1[2] != a2[2] )
        return 0;
      v12 = (int)(a1 + 2);
      v13 = hashtable_iter((int)(a1 + 2));
      if ( !v13 )
        return 1;
      while ( 1 )
      {
        v15 = hashtable_iter_key(v13);
        v16 = (char *)v15;
        if ( !v15 )
          break;
        v17 = v15 - 16;
        v18 = hashtable_iter_value(v15 - 16);
        v19 = v16;
        v20 = v18;
        if ( !v18 )
          break;
        v14 = json_object_get(a2, v19);
        if ( !v14 || !sub_33C1C(v20, v14) )
          return 0;
        if ( !*a1 )
        {
          v13 = hashtable_iter_next(v12, v17);
          if ( v13 )
            continue;
        }
        return 1;
      }
      return 1;
    case 1:
      v6 = a1[3];
      if ( v6 != a2[3] )
        return 0;
      if ( !v6 )
        return 1;
      v7 = *a1;
      v8 = 0;
      break;
    case 2:
      v21 = a1[3];
      return v21 == a2[3] && !memcmp((const void *)a1[2], (const void *)a2[2], v21);
    case 3:
      return *((_QWORD *)a1 + 1) == *((_QWORD *)a2 + 1);
    case 4:
      return *((double *)a1 + 1) == *((double *)a2 + 1);
    default:
      return 0;
  }
  while ( 1 )
  {
    if ( v2 == 1 && a1[3] > v8 )
      v11 = *(_DWORD *)(a1[4] + 4 * v8);
    else
      v11 = 0;
    if ( v7 != 1 || a2[3] <= v8 )
      return 0;
    v9 = *(_DWORD *)(a2[4] + 4 * v8);
    v10 = v9 == 0;
    if ( v9 )
      v10 = v11 == 0;
    if ( v10 || !sub_33C1C(v11, v9) )
      return 0;
    if ( v6 == ++v8 )
      break;
    v2 = *a1;
    v7 = *a2;
  }
  return 1;
}
// 33C50: control flows out of bounds to 33C54

//----- (00033DFC) --------------------------------------------------------
int __fastcall json_object_del(_DWORD *a1, char *a2)
{
  bool v2; // zf

  v2 = a1 == 0;
  if ( a1 )
    v2 = a2 == 0;
  if ( v2 || *a1 )
    return -1;
  else
    return hashtable_del(a1 + 2, a2);
}

//----- (00033E24) --------------------------------------------------------
int __fastcall json_object_clear(_DWORD *a1)
{
  if ( !a1 )
    return -1;
  if ( *a1 )
    return -1;
  hashtable_clear(a1 + 2);
  return 0;
}

//----- (00033E5C) --------------------------------------------------------
int __fastcall json_object_iter(_DWORD *a1)
{
  if ( !a1 || *a1 )
    return 0;
  else
    return hashtable_iter((int)(a1 + 2));
}

//----- (00033E80) --------------------------------------------------------
int __fastcall json_object_iter_at(_DWORD *a1, char *a2)
{
  bool v2; // zf

  v2 = a1 == 0;
  if ( a1 )
    v2 = a2 == 0;
  if ( v2 || *a1 )
    return 0;
  else
    return hashtable_iter_at((int)(a1 + 2), a2);
}

//----- (00033EA8) --------------------------------------------------------
int __fastcall json_object_iter_next(_DWORD *a1, int a2)
{
  _BOOL4 v2; // r3

  if ( !a1 )
    return 0;
  v2 = a2 == 0;
  if ( *a1 )
    v2 = 1;
  if ( v2 )
    return 0;
  else
    return hashtable_iter_next((int)(a1 + 2), a2);
}

//----- (00033EDC) --------------------------------------------------------
int __fastcall json_object_iter_key(int a1)
{
  if ( a1 )
    return hashtable_iter_key(a1);
  return a1;
}

//----- (00033EE8) --------------------------------------------------------
int __fastcall json_object_iter_value(int a1)
{
  if ( a1 )
    return hashtable_iter_value(a1);
  return a1;
}

//----- (00033EF4) --------------------------------------------------------
int __fastcall json_object_key_to_iter(int result)
{
  if ( result )
    result -= 16;
  return result;
}

//----- (00033F00) --------------------------------------------------------
_DWORD *json_array()
{
  _DWORD *v0; // r0
  _DWORD *v1; // r4
  void *v2; // r0
  void *v4; // r0

  v0 = jsonp_malloc((void *)0x14);
  v1 = v0;
  if ( v0 )
  {
    *v0 = 1;
    v0[1] = 1;
    v0[3] = 0;
    v0[2] = 8;
    v2 = jsonp_malloc((void *)0x20);
    v1[4] = v2;
    if ( !v2 )
    {
      v4 = v1;
      v1 = 0;
      jsonp_free(v4);
    }
  }
  return v1;
}

//----- (00033F60) --------------------------------------------------------
_DWORD *__fastcall json_array_size(_DWORD *result)
{
  if ( result )
  {
    if ( *result == 1 )
      return (_DWORD *)result[3];
    else
      return 0;
  }
  return result;
}

//----- (00033F7C) --------------------------------------------------------
_DWORD *__fastcall json_array_get(_DWORD *result, unsigned int a2)
{
  if ( result )
  {
    if ( *result == 1 && result[3] > a2 )
      return *(_DWORD **)(result[4] + 4 * a2);
    else
      return 0;
  }
  return result;
}

//----- (00033FB0) --------------------------------------------------------
int __fastcall json_array_extend(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 v3; // r4
  __int64 v5; // r0
  size_t v6; // r2
  unsigned int v7; // r3
  int v8; // r2
  int v9; // r12
  unsigned int *v10; // r2
  unsigned int v11; // r1

  if ( !a1 )
    return -1;
  v3 = *a1 != 1 || a2 == 0;
  if ( v3 || *a2 != 1 || !sub_33A78(a1, a2[3], 1) )
    return -1;
  v5 = *(_QWORD *)(a2 + 3);
  v6 = a2[3];
  if ( (_DWORD)v5 )
  {
    v7 = 0;
    do
    {
      v8 = *(_DWORD *)(HIDWORD(v5) + 4 * v7);
      if ( v8 )
      {
        v9 = *(_DWORD *)(v8 + 4);
        v10 = (unsigned int *)(v8 + 4);
        if ( v9 != -1 )
        {
          do
            v11 = __ldrex(v10);
          while ( __strex(v11 + 1, v10) );
          __dmb(0xBu);
          v5 = *(_QWORD *)(a2 + 3);
        }
      }
      ++v7;
    }
    while ( (unsigned int)v5 > v7 );
    v6 = 4 * v5;
  }
  memcpy((void *)(a1[4] + 4 * a1[3]), (const void *)HIDWORD(v5), v6);
  a1[3] += a2[3];
  return 0;
}

//----- (00034088) --------------------------------------------------------
char *__fastcall json_string_nocheck(char *result)
{
  char *v1; // r4
  size_t v2; // r0

  if ( result )
  {
    v1 = result;
    v2 = strlen(result);
    return (char *)sub_33B04(v1, v2, 0);
  }
  return result;
}

//----- (000340B0) --------------------------------------------------------
_DWORD *__fastcall json_stringn_nocheck(_BYTE *a1, size_t a2)
{
  return sub_33B04(a1, a2, 0);
}

//----- (000340B8) --------------------------------------------------------
_DWORD *__fastcall jsonp_stringn_nocheck_own(_BYTE *a1, size_t a2)
{
  return sub_33B04(a1, a2, 1);
}

//----- (000340C0) --------------------------------------------------------
_DWORD *__fastcall json_stringn(_BYTE *a1, size_t a2)
{
  if ( !a1 )
    return 0;
  if ( utf8_check_string((int)a1, a2) )
    return sub_33B04(a1, a2, 0);
  return 0;
}

//----- (00034104) --------------------------------------------------------
char *__fastcall BUFX_strdup(char *result)
{
  char *v1; // r4
  size_t v2; // r0

  if ( result )
  {
    v1 = result;
    v2 = strlen(result);
    return (char *)json_stringn(v1, v2);
  }
  return result;
}

//----- (00034128) --------------------------------------------------------
_DWORD *__fastcall json_string_value(_DWORD *result)
{
  if ( result )
  {
    if ( *result == 2 )
      return (_DWORD *)result[2];
    else
      return 0;
  }
  return result;
}

//----- (00034144) --------------------------------------------------------
_DWORD *__fastcall json_string_length(_DWORD *result)
{
  if ( result )
  {
    if ( *result == 2 )
      return (_DWORD *)result[3];
    else
      return 0;
  }
  return result;
}

//----- (00034160) --------------------------------------------------------
int __fastcall json_string_setn_nocheck(int a1, const void *a2, size_t a3)
{
  _BYTE *v6; // r7

  if ( !a1 )
    return -1;
  if ( *(_DWORD *)a1 != 2 || a2 == 0 )
    return -1;
  v6 = jsonp_strndup(a2, a3);
  if ( !v6 )
    return -1;
  jsonp_free(*(void **)(a1 + 8));
  *(_DWORD *)(a1 + 8) = v6;
  *(_DWORD *)(a1 + 12) = a3;
  return 0;
}

//----- (000341C4) --------------------------------------------------------
int __fastcall json_string_set_nocheck(int a1, const char *a2)
{
  size_t v4; // r0

  if ( !a2 )
    return -1;
  v4 = strlen(a2);
  return json_string_setn_nocheck(a1, a2, v4);
}

//----- (000341F8) --------------------------------------------------------
int __fastcall json_string_setn(int a1, const void *a2, size_t a3)
{
  if ( a2 && utf8_check_string((int)a2, a3) )
    return json_string_setn_nocheck(a1, a2, a3);
  else
    return -1;
}

//----- (0003423C) --------------------------------------------------------
int __fastcall json_string_set(int a1, const char *a2)
{
  size_t v4; // r0

  if ( !a2 )
    return -1;
  v4 = strlen(a2);
  return json_string_setn(a1, a2, v4);
}

//----- (00034270) --------------------------------------------------------
_DWORD *__fastcall json_vsprintf(char *format, __gnuc_va_list arg)
{
  int v3; // r0
  size_t v4; // r4
  char *v5; // r0
  char *v6; // r7

  v3 = vsnprintf(0, 0, format, arg);
  v4 = v3;
  if ( !v3 )
    return json_stringn("", 0);
  v5 = (char *)jsonp_malloc((void *)(v3 + 1));
  v6 = v5;
  if ( !v5 )
    return 0;
  vsnprintf(v5, v4 + 1, format, arg);
  if ( utf8_check_string((int)v6, v4) )
    return sub_33B04(v6, v4, 1);
  jsonp_free(v6);
  return 0;
}

//----- (00034320) --------------------------------------------------------
_DWORD *ipcomx_vprintf(char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+8h] BYREF

  va_start(varg_r1, a1);
  return json_vsprintf(a1, varg_r1);
}

//----- (00034350) --------------------------------------------------------
_QWORD *__fastcall json_integer(__int64 a1)
{
  _QWORD *result; // r0

  result = jsonp_malloc((void *)0x10);
  if ( result )
  {
    result[1] = a1;
    *(_DWORD *)result = 3;
    *((_DWORD *)result + 1) = 1;
  }
  return result;
}

//----- (00034384) --------------------------------------------------------
__int64 __fastcall json_integer_value(int a1)
{
  if ( a1 && *(_DWORD *)a1 == 3 )
    return *(_QWORD *)(a1 + 8);
  else
    return 0;
}

//----- (000343AC) --------------------------------------------------------
int __fastcall json_integer_set(int a1, __int64 a2)
{
  if ( !a1 || *(_DWORD *)a1 != 3 )
    return -1;
  *(_QWORD *)(a1 + 8) = a2;
  return 0;
}

//----- (000343D4) --------------------------------------------------------
double *json_real()
{
  double v0; // d0
  double *result; // r0

  if ( fabs(v0) > 1.79769313e308 )
    return 0;
  result = (double *)jsonp_malloc((void *)0x10);
  if ( result )
  {
    result[1] = v0;
    *(_DWORD *)result = 4;
    *((_DWORD *)result + 1) = 1;
  }
  return result;
}
// 343E4: variable 'v0' is possibly undefined

//----- (00034430) --------------------------------------------------------
void json_real_value()
{
  ;
}

//----- (00034460) --------------------------------------------------------
int __fastcall json_real_set(int a1)
{
  double v1; // d0
  int result; // r0

  if ( !a1 )
    return -1;
  result = *(_DWORD *)a1 != 4;
  if ( result || fabs(v1) > 1.79769313e308 )
    return -1;
  *(double *)(a1 + 8) = v1;
  return result;
}
// 34494: variable 'v1' is possibly undefined

//----- (000344C0) --------------------------------------------------------
int __fastcall json_number_value(int result)
{
  if ( result )
  {
    if ( *(_DWORD *)result == 3 )
      return sub_DD47C(*(_QWORD *)(result + 8));
  }
  return result;
}

//----- (00034508) --------------------------------------------------------
void *json_true()
{
  return &unk_1063DC;
}

//----- (00034514) --------------------------------------------------------
void *json_false()
{
  return &unk_1063E4;
}

//----- (00034520) --------------------------------------------------------
void *json_null()
{
  return &unk_1063EC;
}

//----- (0003452C) --------------------------------------------------------
void __fastcall json_delete(_DWORD *a1)
{
  _DWORD *v2; // r0
  unsigned int v3; // r1
  unsigned int i; // r5
  _DWORD *v5; // r3
  unsigned int *v6; // r2
  unsigned int v7; // r1
  unsigned int v8; // r1

  if ( a1 )
  {
    switch ( *a1 )
    {
      case 0:
        hashtable_close((int)(a1 + 2));
        jsonp_free(a1);
        return;
      case 1:
        v3 = a1[3];
        v2 = (_DWORD *)a1[4];
        if ( v3 )
        {
          for ( i = 0; i < v3; ++i )
          {
            v5 = (_DWORD *)v2[i];
            if ( v5 )
            {
              v6 = v5 + 1;
              if ( v5[1] != -1 )
              {
                __dmb(0xBu);
                do
                {
                  v7 = __ldrex(v6);
                  v8 = v7 - 1;
                }
                while ( __strex(v8, v6) );
                if ( !v8 )
                  json_delete(v5);
                v2 = (_DWORD *)a1[4];
                v3 = a1[3];
              }
            }
          }
        }
        goto LABEL_4;
      case 2:
        v2 = (_DWORD *)a1[2];
LABEL_4:
        jsonp_free(v2);
        goto LABEL_5;
      case 3:
      case 4:
LABEL_5:
        jsonp_free(a1);
        break;
      default:
        return;
    }
  }
}
// 34544: control flows out of bounds to 34548

//----- (000345F8) --------------------------------------------------------
int __fastcall json_array_clear(_DWORD *a1)
{
  unsigned int v2; // r2
  unsigned int i; // r4
  _DWORD *v4; // r0
  unsigned int *v5; // r3
  unsigned int v6; // r2
  unsigned int v7; // r2

  if ( !a1 || *a1 != 1 )
    return -1;
  v2 = a1[3];
  if ( v2 )
  {
    for ( i = 0; i < v2; ++i )
    {
      v4 = *(_DWORD **)(a1[4] + 4 * i);
      if ( v4 )
      {
        v5 = v4 + 1;
        if ( v4[1] != -1 )
        {
          __dmb(0xBu);
          do
          {
            v6 = __ldrex(v5);
            v7 = v6 - 1;
          }
          while ( __strex(v7, v5) );
          if ( !v7 )
            json_delete(v4);
          v2 = a1[3];
        }
      }
    }
  }
  a1[3] = 0;
  return 0;
}

//----- (00034688) --------------------------------------------------------
int __fastcall json_object_iter_set_new(_DWORD *a1, int a2, _DWORD *a3)
{
  unsigned int *v4; // r3
  unsigned int v5; // r1
  unsigned int v6; // r1
  _BOOL4 v7; // r4

  if ( !a1 || *a1 || (a2 ? (v7 = a3 == 0) : (v7 = 1), v7) )
  {
    if ( !a3 )
      return -1;
    if ( a3[1] == -1 )
      return -1;
    v4 = a3 + 1;
    __dmb(0xBu);
    do
    {
      v5 = __ldrex(v4);
      v6 = v5 - 1;
    }
    while ( __strex(v6, v4) );
    if ( v6 )
    {
      return -1;
    }
    else
    {
      json_delete(a3);
      return -1;
    }
  }
  else
  {
    hashtable_iter_set(a2, (int)a3);
    return 0;
  }
}

//----- (00034720) --------------------------------------------------------
int __fastcall json_array_remove(_DWORD *a1, unsigned int a2)
{
  unsigned int v3; // r12
  unsigned int v5; // r6
  _DWORD *v6; // r0
  int v7; // r3
  unsigned int *v9; // r3
  unsigned int v10; // r2
  unsigned int v11; // r2

  if ( a1 )
  {
    if ( *a1 == 1 )
    {
      v3 = a1[3];
      if ( v3 > a2 )
      {
        v5 = 4 * a2;
        v6 = *(_DWORD **)(a1[4] + 4 * a2);
        if ( v6 && v6[1] != -1 )
        {
          v9 = v6 + 1;
          __dmb(0xBu);
          do
          {
            v10 = __ldrex(v9);
            v11 = v10 - 1;
          }
          while ( __strex(v11, v9) );
          if ( !v11 )
            json_delete(v6);
          v3 = a1[3];
          v7 = v3 - 1;
          if ( v3 - 1 <= a2 )
            goto LABEL_7;
        }
        else
        {
          v7 = v3 - 1;
          if ( v3 - 1 <= a2 )
          {
LABEL_7:
            a1[3] = v7;
            return 0;
          }
        }
        memmove((void *)(a1[4] + v5), (const void *)(a1[4] + v5 + 4), 4 * (~a2 + v3));
        v7 = a1[3] - 1;
        goto LABEL_7;
      }
    }
  }
  return -1;
}

//----- (000347EC) --------------------------------------------------------
int __fastcall json_object_set_new_nocheck(_DWORD *a1, char *a2, _DWORD *a3)
{
  bool v4; // zf
  int result; // r0
  _BOOL4 v6; // r3
  unsigned int *v7; // r3
  unsigned int v8; // r2
  unsigned int v9; // r2
  unsigned int *v10; // r3
  unsigned int v11; // r2

  if ( !a3 )
    return -1;
  v4 = a1 == 0;
  if ( a1 )
    v4 = a2 == 0;
  if ( !v4 )
  {
    v6 = a3 == a1;
    if ( *a1 )
      v6 = 1;
    if ( !v6 )
    {
      result = hashtable_set(a1 + 2, a2, (unsigned int)a3);
      if ( !result )
        return result;
      if ( a3[1] != -1 )
      {
        v7 = a3 + 1;
        __dmb(0xBu);
        do
        {
          v8 = __ldrex(v7);
          v9 = v8 - 1;
        }
        while ( __strex(v9, v7) );
        goto LABEL_18;
      }
      return -1;
    }
  }
  if ( a3[1] == -1 )
    return -1;
  v10 = a3 + 1;
  __dmb(0xBu);
  do
  {
    v11 = __ldrex(v10);
    v9 = v11 - 1;
  }
  while ( __strex(v9, v10) );
LABEL_18:
  if ( v9 )
    return -1;
  json_delete(a3);
  return -1;
}

//----- (000348A8) --------------------------------------------------------
int __fastcall json_object_update_missing(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 v3; // r3
  _DWORD *v4; // r9
  int i; // r0
  unsigned int *v8; // r3
  unsigned int v9; // r2
  int v10; // r0
  char *v11; // r4
  _DWORD *v12; // r8

  if ( !a1 )
    return -1;
  v3 = a2 == 0;
  if ( *a1 )
    v3 = 1;
  if ( v3 || *a2 )
    return -1;
  v4 = a2 + 2;
  for ( i = hashtable_iter((int)(a2 + 2)); i; i = hashtable_iter_next((int)v4, (int)(v11 - 16)) )
  {
    v10 = hashtable_iter_key(i);
    v11 = (char *)v10;
    if ( !v10 )
      break;
    v12 = (_DWORD *)hashtable_iter_value(v10 - 16);
    if ( !v12 )
      break;
    if ( !json_object_get(a1, v11) )
    {
      v8 = v12 + 1;
      if ( v12[1] != -1 )
      {
        do
          v9 = __ldrex(v8);
        while ( __strex(v9 + 1, v8) );
        __dmb(0xBu);
      }
      json_object_set_new_nocheck(a1, v11, v12);
    }
    if ( *a2 )
      break;
  }
  return 0;
}

//----- (00034994) --------------------------------------------------------
int __fastcall json_object_set_new(_DWORD *a1, char *a2, _DWORD *a3)
{
  size_t v6; // r0
  unsigned int *v8; // r3
  unsigned int v9; // r2
  unsigned int v10; // r2

  if ( a2 )
  {
    v6 = strlen(a2);
    if ( utf8_check_string((int)a2, v6) )
      return json_object_set_new_nocheck(a1, a2, a3);
  }
  if ( !a3 )
    return -1;
  if ( a3[1] == -1 )
    return -1;
  v8 = a3 + 1;
  __dmb(0xBu);
  do
  {
    v9 = __ldrex(v8);
    v10 = v9 - 1;
  }
  while ( __strex(v10, v8) );
  if ( v10 )
    return -1;
  json_delete(a3);
  return -1;
}

//----- (00034A28) --------------------------------------------------------
int __fastcall json_object_update(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 v3; // r3
  _DWORD *v4; // r8
  int v6; // r0
  unsigned int v8; // r1
  int v9; // r0
  char *v10; // r5
  _DWORD *v11; // r0
  unsigned int *v12; // r3

  if ( !a1 )
    return -1;
  v3 = a2 == 0;
  if ( *a1 )
    v3 = 1;
  if ( v3 || *a2 )
    return -1;
  v4 = a2 + 2;
  v6 = hashtable_iter((int)(a2 + 2));
  if ( v6 )
  {
    while ( 1 )
    {
      v9 = hashtable_iter_key(v6);
      v10 = (char *)v9;
      if ( !v9 )
        break;
      v11 = (_DWORD *)hashtable_iter_value(v9 - 16);
      v12 = v11 + 1;
      if ( !v11 )
        return 0;
      if ( v11[1] != -1 )
      {
        do
          v8 = __ldrex(v12);
        while ( __strex(v8 + 1, v12) );
        __dmb(0xBu);
      }
      if ( json_object_set_new_nocheck(a1, v10, v11) )
        return -1;
      if ( !*a2 )
      {
        v6 = hashtable_iter_next((int)v4, (int)(v10 - 16));
        if ( v6 )
          continue;
      }
      return 0;
    }
  }
  return 0;
}

//----- (00034B08) --------------------------------------------------------
int __fastcall json_object_update_existing(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 v3; // r3
  _DWORD *v4; // r9
  int i; // r0
  unsigned int *v7; // r3
  unsigned int v8; // r2
  int v9; // r0
  char *v10; // r4
  _DWORD *v11; // r6

  if ( !a1 )
    return -1;
  v3 = a2 == 0;
  if ( *a1 )
    v3 = 1;
  if ( v3 || *a2 )
    return -1;
  v4 = a2 + 2;
  for ( i = hashtable_iter((int)(a2 + 2)); i; i = hashtable_iter_next((int)v4, (int)(v10 - 16)) )
  {
    v9 = hashtable_iter_key(i);
    v10 = (char *)v9;
    if ( !v9 )
      break;
    v11 = (_DWORD *)hashtable_iter_value(v9 - 16);
    if ( !v11 )
      break;
    if ( json_object_get(a1, v10) )
    {
      v7 = v11 + 1;
      if ( v11[1] != -1 )
      {
        do
          v8 = __ldrex(v7);
        while ( __strex(v8 + 1, v7) );
        __dmb(0xBu);
      }
      json_object_set_new_nocheck(a1, v10, v11);
    }
    if ( *a2 )
      break;
  }
  return 0;
}

//----- (00034BF8) --------------------------------------------------------
int __fastcall json_array_insert_new(_DWORD *a1, unsigned int a2, _DWORD *a3)
{
  int v6; // r2
  unsigned int *v8; // r3
  unsigned int v9; // r2
  unsigned int v10; // r2
  char *v11; // r8
  char *v12; // r0
  unsigned int v13; // r7
  int v14; // r3
  unsigned int *v15; // r3
  unsigned int v16; // r2

  if ( !a3 )
    return -1;
  if ( !a1 )
    goto LABEL_6;
  v6 = a3 == a1;
  if ( *a1 != 1 )
    v6 |= 1u;
  if ( v6 || a1[3] < a2 )
  {
LABEL_6:
    if ( a3[1] == -1 )
      return -1;
    v8 = a3 + 1;
    __dmb(0xBu);
    do
    {
      v9 = __ldrex(v8);
      v10 = v9 - 1;
    }
    while ( __strex(v10, v8) );
LABEL_10:
    if ( !v10 )
    {
      json_delete(a3);
      return -1;
    }
    return -1;
  }
  v11 = (char *)sub_33A78(a1, 1, 0);
  if ( !v11 )
  {
    if ( a3[1] == -1 )
      return -1;
    v15 = a3 + 1;
    __dmb(0xBu);
    do
    {
      v16 = __ldrex(v15);
      v10 = v16 - 1;
    }
    while ( __strex(v10, v15) );
    goto LABEL_10;
  }
  v12 = (char *)a1[4];
  v13 = 4 * (a2 + 1);
  if ( v12 == v11 )
  {
    memmove(&v12[v13], &v11[v13 - 4], 4 * (a1[3] - a2));
  }
  else
  {
    memcpy(v12, v11, v13 - 4);
    memcpy((void *)(a1[4] + v13), &v11[v13 - 4], 4 * (a1[3] - a2));
    jsonp_free(v11);
  }
  v14 = a1[3] + 1;
  *(_DWORD *)(a1[4] + v13 - 4) = a3;
  a1[3] = v14;
  return 0;
}

//----- (00034D48) --------------------------------------------------------
int __fastcall json_array_set_new(_DWORD *a1, unsigned int a2, _DWORD *a3)
{
  _BOOL4 v4; // r3
  unsigned int *v6; // r3
  unsigned int v7; // r1
  unsigned int v8; // r1
  int v9; // r3
  unsigned int v10; // r5
  _DWORD *v11; // r0
  _DWORD *v12; // r3
  unsigned int *v13; // r3
  unsigned int v14; // r1
  unsigned int v15; // r1
  _DWORD *v16; // [sp+4h] [bp-14h]

  if ( !a3 )
    return -1;
  if ( !a1 )
    goto LABEL_6;
  v4 = a3 == a1;
  if ( *a1 != 1 )
    v4 = 1;
  if ( v4 || a1[3] <= a2 )
  {
LABEL_6:
    if ( a3[1] != -1 )
    {
      v6 = a3 + 1;
      __dmb(0xBu);
      do
      {
        v7 = __ldrex(v6);
        v8 = v7 - 1;
      }
      while ( __strex(v8, v6) );
      if ( !v8 )
        json_delete(a3);
    }
    return -1;
  }
  else
  {
    v9 = a1[4];
    v10 = 4 * a2;
    v11 = *(_DWORD **)(v9 + 4 * a2);
    v12 = (_DWORD *)(v9 + 4 * a2);
    if ( v11 && v11[1] != -1 )
    {
      v13 = v11 + 1;
      __dmb(0xBu);
      do
      {
        v14 = __ldrex(v13);
        v15 = v14 - 1;
      }
      while ( __strex(v15, v13) );
      if ( !v15 )
      {
        v16 = a3;
        json_delete(v11);
        a3 = v16;
      }
      v12 = (_DWORD *)(a1[4] + v10);
    }
    *v12 = a3;
    return 0;
  }
}

//----- (00034E54) --------------------------------------------------------
int __fastcall json_array_append_new(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 v4; // r5
  unsigned int *v6; // r3
  unsigned int v7; // r2
  unsigned int v8; // r2
  int v9; // r3
  unsigned int *v10; // r3
  unsigned int v11; // r2

  if ( !a2 )
    return -1;
  if ( !a1 )
    goto LABEL_6;
  v4 = a2 == a1;
  if ( *a1 != 1 )
    v4 = 1;
  if ( !v4 )
  {
    if ( sub_33A78(a1, 1, 1) )
    {
      v9 = a1[3];
      *(_DWORD *)(a1[4] + 4 * v9) = a2;
      a1[3] = v9 + 1;
      return 0;
    }
    if ( a2[1] == -1 )
      return -1;
    v10 = a2 + 1;
    __dmb(0xBu);
    do
    {
      v11 = __ldrex(v10);
      v8 = v11 - 1;
    }
    while ( __strex(v8, v10) );
  }
  else
  {
LABEL_6:
    if ( a2[1] == -1 )
      return -1;
    v6 = a2 + 1;
    __dmb(0xBu);
    do
    {
      v7 = __ldrex(v6);
      v8 = v7 - 1;
    }
    while ( __strex(v8, v6) );
  }
  if ( v8 )
    return -1;
  json_delete(a2);
  return -1;
}

//----- (00034F30) --------------------------------------------------------
bool __fastcall json_equal(int *a1, int *a2)
{
  bool v2; // zf

  v2 = a2 == 0;
  if ( a2 )
    v2 = a1 == 0;
  return !v2 && sub_33C1C(a1, a2);
}

//----- (00034F48) --------------------------------------------------------
double *__fastcall json_copy(int a1)
{
  _DWORD *v2; // r7
  int i; // r0
  unsigned int v4; // r1
  int v5; // r0
  char *v6; // r5
  _DWORD *v7; // r0
  unsigned int *v8; // r3
  unsigned int v9; // r3
  unsigned int j; // r5
  _DWORD *v11; // r1
  unsigned int *v12; // r2
  unsigned int v13; // r3

  if ( a1 )
  {
    switch ( *(_DWORD *)a1 )
    {
      case 0:
        v2 = json_object();
        if ( !v2 )
          return 0;
        if ( !*(_DWORD *)a1 )
        {
          for ( i = hashtable_iter(a1 + 8); i; i = hashtable_iter_next(a1 + 8, (int)(v6 - 16)) )
          {
            v5 = hashtable_iter_key(i);
            v6 = (char *)v5;
            if ( !v5 )
              break;
            v7 = (_DWORD *)hashtable_iter_value(v5 - 16);
            v8 = v7 + 1;
            if ( !v7 )
              break;
            if ( v7[1] != -1 )
            {
              do
                v4 = __ldrex(v8);
              while ( __strex(v4 + 1, v8) );
              __dmb(0xBu);
            }
            json_object_set_new_nocheck(v2, v6, v7);
            if ( *(_DWORD *)a1 )
              break;
          }
        }
        return (double *)v2;
      case 1:
        v2 = json_array();
        if ( !v2 )
          return 0;
        if ( *(_DWORD *)a1 == 1 )
        {
          v9 = *(_DWORD *)(a1 + 12);
          if ( v9 )
          {
            for ( j = 0; j < v9; ++j )
            {
              v11 = 0;
              if ( v9 > j )
              {
                v11 = *(_DWORD **)(*(_DWORD *)(a1 + 16) + 4 * j);
                v12 = v11 + 1;
                if ( v11 )
                {
                  if ( v11[1] != -1 )
                  {
                    do
                      v13 = __ldrex(v12);
                    while ( __strex(v13 + 1, v12) );
                    __dmb(0xBu);
                  }
                }
              }
              json_array_append_new(v2, v11);
              if ( *(_DWORD *)a1 != 1 )
                break;
              v9 = *(_DWORD *)(a1 + 12);
            }
          }
        }
        return (double *)v2;
      case 2:
        return (double *)sub_33B04(*(_BYTE **)(a1 + 8), *(_DWORD *)(a1 + 12), 0);
      case 3:
        return (double *)sub_33A28(a1);
      case 4:
        return json_real();
      case 5:
      case 6:
      case 7:
        return (double *)a1;
      default:
        return 0;
    }
  }
  return 0;
}
// 34F60: control flows out of bounds to 34F64

//----- (00035104) --------------------------------------------------------
double *__fastcall json_deep_copy(int a1)
{
  _DWORD *v2; // r6
  int i; // r5
  char *v4; // r7
  int v5; // r0
  double *v6; // r0
  unsigned int v7; // r3
  unsigned int j; // r5
  int v9; // r0
  double *v10; // r0

  if ( a1 )
  {
    switch ( *(_DWORD *)a1 )
    {
      case 0:
        v2 = json_object();
        if ( !v2 )
          return 0;
        if ( !*(_DWORD *)a1 )
        {
          for ( i = hashtable_iter(a1 + 8); i; i = hashtable_iter_next(a1 + 8, i) )
          {
            v4 = (char *)hashtable_iter_key(i);
            v5 = hashtable_iter_value(i);
            v6 = json_deep_copy(v5);
            json_object_set_new_nocheck(v2, v4, v6);
            if ( *(_DWORD *)a1 )
              break;
          }
        }
        return (double *)v2;
      case 1:
        v2 = json_array();
        if ( !v2 )
          return 0;
        if ( *(_DWORD *)a1 == 1 )
        {
          v7 = *(_DWORD *)(a1 + 12);
          if ( v7 )
          {
            for ( j = 0; j < v7; ++j )
            {
              v9 = 0;
              if ( v7 > j )
                v9 = *(_DWORD *)(*(_DWORD *)(a1 + 16) + 4 * j);
              v10 = json_deep_copy(v9);
              json_array_append_new(v2, v10);
              if ( *(_DWORD *)a1 != 1 )
                break;
              v7 = *(_DWORD *)(a1 + 12);
            }
          }
        }
        return (double *)v2;
      case 2:
        return (double *)sub_33B04(*(_BYTE **)(a1 + 8), *(_DWORD *)(a1 + 12), 0);
      case 3:
        return (double *)sub_33A28(a1);
      case 4:
        return json_real();
      case 5:
      case 6:
      case 7:
        return (double *)a1;
      default:
        return 0;
    }
  }
  return 0;
}
// 3511C: control flows out of bounds to 35120

//----- (00035268) --------------------------------------------------------
int __fastcall stratum_set_diff_or_target_base(int a1, int a2, _DWORD *a3)
{
  double v3; // d0
  _DWORD *v7; // r0
  void (__fastcall *v8)(int); // r3
  int v10; // r12
  _DWORD *v11; // r0
  const char *v12; // r0
  char *v13; // r5
  size_t v14; // r0
  int v15; // r1
  int v16; // r2
  int v17; // r3
  int v18; // r1
  int v19; // r2
  int v20; // r3
  int v21; // [sp+4h] [bp-1028h]
  _DWORD v22[1025]; // [sp+28h] [bp-1004h] BYREF

  if ( json_array_get(a3, 0) && *json_array_get(a3, 0) == 2 )
  {
    v11 = json_array_get(a3, 0);
    v12 = (const char *)json_string_value(v11);
    v13 = (char *)v12;
    if ( v12 && strlen(v12) == 64 )
    {
      V_LOCK();
      logfmt_raw((char *)v22, 0x1000u, 0, "%s target from pool: %s", "stratum_set_diff_or_target_base", v13);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/frontend/frontend_base.c",
        152,
        "stratum_set_diff_or_target_base",
        31,
        20,
        20,
        v22);
      v14 = strlen(v13);
      hex2bin((int)v22, (unsigned __int8 *)v13, v14 >> 1);
      pthread_mutex_lock((pthread_mutex_t *)(a2 + 1584));
      v15 = v22[1];
      v16 = v22[2];
      v17 = v22[3];
      *(_DWORD *)(a2 + 1480) = v22[0];
      *(_DWORD *)(a2 + 1484) = v15;
      *(_DWORD *)(a2 + 1488) = v16;
      *(_DWORD *)(a2 + 1492) = v17;
      v18 = v22[5];
      v19 = v22[6];
      v20 = v22[7];
      *(_DWORD *)(a2 + 1496) = v22[4];
      *(_DWORD *)(a2 + 1500) = v18;
      *(_DWORD *)(a2 + 1504) = v19;
      *(_DWORD *)(a2 + 1508) = v20;
      (*(void (__fastcall **)(_DWORD *))(a1 + 64))(v22);
      *(double *)(a2 + 1512) = v3;
      *(double *)(a2 + 440) = v3;
      *(double *)(a2 + 1800) = v3;
      pthread_mutex_unlock((pthread_mutex_t *)(a2 + 1584));
      return 1;
    }
    V_LOCK();
    logfmt_raw((char *)v22, 0x1000u, 0, "Stratum set target: invalid parameters");
    V_UNLOCK();
    v10 = 16;
LABEL_7:
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/frontend/frontend_base.c",
      152,
      "stratum_set_diff_or_target_base",
      31,
      v10,
      100,
      v22);
    return 0;
  }
  v7 = json_array_get(a3, 0);
  json_number_value((int)v7);
  if ( v3 == 0.0 )
  {
    V_LOCK();
    logfmt_raw((char *)v22, 0x1000u, 0, "Stratum set target: invalid parameters");
    V_UNLOCK();
    v10 = 32;
    goto LABEL_7;
  }
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 1584));
  v8 = *(void (__fastcall **)(int))(a1 + 60);
  *(double *)(a2 + 1512) = v3;
  *(double *)(a2 + 440) = v3;
  *(double *)(a2 + 1800) = v3;
  v8(a2 + 1480);
  V_LOCK();
  logfmt_raw((char *)v22, 0x1000u, 0, "%s diff from pool: %lf", "stratum_set_diff_or_target_base", v21, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/frontend/frontend_base.c",
    152,
    "stratum_set_diff_or_target_base",
    31,
    39,
    20,
    v22);
  V_LOCK();
  logfmt_raw(
    (char *)v22,
    0x1000u,
    0,
    "%s target:%08x %08x %08x %08x %08x %08x %08x %08x ",
    "stratum_set_diff_or_target_base",
    *(_DWORD *)(a2 + 1480),
    *(_DWORD *)(a2 + 1484),
    *(_DWORD *)(a2 + 1488),
    *(_DWORD *)(a2 + 1492),
    *(_DWORD *)(a2 + 1496),
    *(_DWORD *)(a2 + 1500),
    *(_DWORD *)(a2 + 1504),
    *(_DWORD *)(a2 + 1508));
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/frontend/frontend_base.c",
    152,
    "stratum_set_diff_or_target_base",
    31,
    40,
    20,
    v22);
  pthread_mutex_unlock((pthread_mutex_t *)(a2 + 1584));
  return 1;
}
// 352CC: variable 'v3' is possibly undefined
// 3533C: variable 'v21' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (000355CC) --------------------------------------------------------
const char *__fastcall stratum_handle_method_base(int (__fastcall **a1)(_DWORD, _DWORD, _DWORD), int a2, int a3)
{
  double *v6; // r0
  double *v7; // r4
  _DWORD *v8; // r0
  const char *v9; // r5
  int v10; // r9
  int v11; // r0
  _BYTE *v12; // r1
  unsigned int *v13; // r3
  unsigned int v14; // r2
  unsigned int v15; // r2
  char v17[92]; // [sp+14h] [bp-1100h] BYREF
  _BYTE v18[160]; // [sp+70h] [bp-10A4h] BYREF
  char v19[4100]; // [sp+110h] [bp-1004h] BYREF

  v6 = json_loads(a3, 0, v17);
  v7 = v6;
  if ( !v6 )
  {
    V_LOCK();
    logfmt_raw(v19, 0x1000u, 0, "JSON decode failed(%d): %s", *(_DWORD *)v17, v18);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/frontend/frontend_base.c",
      152,
      "stratum_handle_method_base",
      26,
      62,
      100,
      v19);
    return 0;
  }
  v8 = (_DWORD *)json_object_get(v6, "method");
  v9 = (const char *)json_string_value(v8);
  if ( !v9 )
  {
LABEL_9:
    if ( *((_DWORD *)v7 + 1) != -1 )
      goto LABEL_10;
    return v9;
  }
  v10 = json_object_get(v7, "params");
  if ( !v10 )
    v10 = json_object_get(v7, "result");
  json_object_get(v7, "id");
  if ( !strcasecmp(v9, "mining.notify") )
  {
    v11 = a1[11](a1, a2, v10);
    goto LABEL_7;
  }
  if ( !strcasecmp(v9, "mining.set_difficulty") || !strcasecmp(v9, "mining.set_target") )
  {
    v9 = (const char *)a1[13](a1, a2, v10);
    goto LABEL_9;
  }
  if ( strcasecmp(v9, "mining.set_extranonce") )
  {
    V_LOCK();
    v9 = 0;
    logfmt_raw(v19, 0x1000u, 0, "unknown stratum method %s!", a3);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/frontend/frontend_base.c",
      152,
      "stratum_handle_method_base",
      26,
      102,
      80,
      v19);
    goto LABEL_9;
  }
  v11 = a1[12](a1, a2, v10);
LABEL_7:
  v9 = (const char *)v11;
  v12 = (_BYTE *)(a2 + 1908);
  if ( v11 )
  {
    pool_tset(a2, v12, 1);
    goto LABEL_9;
  }
  pool_tclear(a2, v12, 0);
  if ( *((_DWORD *)v7 + 1) == -1 )
    return v9;
LABEL_10:
  v13 = (unsigned int *)v7 + 1;
  __dmb(0xBu);
  do
  {
    v14 = __ldrex(v13);
    v15 = v14 - 1;
  }
  while ( __strex(v15, v13) );
  if ( v15 )
    return v9;
  json_delete(v7);
  return v9;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0003587C) --------------------------------------------------------
int __fastcall stratum_subscribe_base(int a1, int *a2)
{
  int v2; // r4
  double *v5; // r7
  void *v6; // r11
  const char *v7; // r0
  size_t v8; // r0
  char *v9; // r0
  char *v10; // r6
  const char *v11; // r1
  size_t v12; // r2
  int v13; // r2
  int v14; // r0
  int v15; // r1
  int v17; // r0
  _DWORD *v18; // r10
  int v19; // r0
  int v20; // r9
  _BOOL4 v21; // r2
  int v22; // r9
  unsigned int *v23; // r3
  unsigned int v24; // r2
  unsigned int v25; // r2
  unsigned int *v26; // r3
  unsigned int v27; // r2
  unsigned int v28; // r2
  const char *v29; // r0
  int v30; // r10
  int v31; // [sp+4h] [bp-1158h]
  _DWORD *v32; // [sp+30h] [bp-112Ch]
  _DWORD v33[7]; // [sp+38h] [bp-1124h] BYREF
  int v34; // [sp+54h] [bp-1108h]
  char v35[92]; // [sp+5Ch] [bp-1100h] BYREF
  _BYTE v36[160]; // [sp+B8h] [bp-10A4h] BYREF
  char v37[4100]; // [sp+158h] [bp-1004h] BYREF

  v2 = *((unsigned __int8 *)a2 + 1648);
  if ( !*((_BYTE *)a2 + 1648) )
  {
    v5 = (double *)*((unsigned __int8 *)a2 + 1648);
    v6 = v5;
    while ( 1 )
    {
      v7 = (const char *)a2[17];
      v8 = v7 ? strlen(v7) + 128 : 128;
      v9 = (char *)malloc(v8);
      v10 = v9;
      if ( v2 )
      {
        v11 = "{\"id\": 1, \"method\": \"mining.subscribe\", \"params\": [\"ckbminer-v1.0.0\", null]}";
        v12 = 77;
      }
      else
      {
        v11 = "{\"id\": 1, \"method\": \"mining.subscribe\", \"params\": [\"GodMiner/2.0.0\", null]}";
        v12 = 76;
      }
      memcpy(v9, v11, v12);
      if ( !(*(int (__fastcall **)(int *, char *))(a1 + 12))(a2, v10) )
        break;
      if ( !socket_full(a2[8], 30) )
      {
        V_LOCK();
        V_INT((int)v33, "poolno", *a2);
        logfmt_raw(
          v37,
          0x1000u,
          0,
          v34,
          v33[0],
          v33[1],
          v33[2],
          v33[3],
          v33[4],
          v33[5],
          v33[6],
          v34,
          "stratum_subscribe timed out");
        V_UNLOCK();
        v14 = g_zc;
        v13 = 136;
        LOWORD(v15) = 5900;
        goto LABEL_11;
      }
      v17 = (*(int (__fastcall **)(int *))(a1 + 8))(a2);
      v6 = (void *)v17;
      if ( !v17 )
        goto LABEL_12;
      v5 = json_loads(v17, 0, v35);
      free(v6);
      if ( v5 )
      {
        v18 = (_DWORD *)json_object_get(v5, "result");
        v32 = (_DWORD *)json_object_get(v5, "error");
        v19 = json_object_get(v5, "id");
        v20 = json_integer_value(v19);
        v21 = v18 == 0;
        if ( v20 != 1 )
          v21 = 1;
        if ( v21 || *v18 == 7 )
        {
          if ( !v2 )
            goto LABEL_41;
          if ( v32 )
            goto LABEL_28;
          v10 = (char *)malloc(0x11u);
          if ( v10 )
            strcpy(v10, "(unknown reason)");
LABEL_29:
          V_LOCK();
          v31 = v20;
          v22 = 0;
          logfmt_raw(v37, 0x1000u, 0, "JSON-RPC call failed: %s, req_id=%d", v10, v31);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/frontend/frontend_base.c",
            152,
            "stratum_subscribe_base",
            22,
            162,
            100,
            v37);
        }
        else
        {
          if ( v32 && *v32 != 7 )
          {
            if ( !v2 )
            {
LABEL_41:
              v22 = v2;
              if ( v10 )
                goto LABEL_42;
              goto LABEL_31;
            }
LABEL_28:
            v10 = json_dumps(v32, 3);
            goto LABEL_29;
          }
          v22 = (*(int (__fastcall **)(int, int *, _DWORD *, int))(a1 + 48))(a1, a2, v18, 1);
          if ( v22 )
          {
            v29 = (const char *)a2[7];
            a2[478] = 2;
            if ( v29 )
            {
              if ( strstr(v29, "nicehash") )
              {
                a2[478] = 3;
                sprintf(v10, "{\"id\": %d, \"method\": \"mining.extranonce.subscribe\", \"params\": []}", 2);
                v30 = (*(int (__fastcall **)(int *, char *))(a1 + 12))(a2, v10);
                if ( v30 )
                {
                  v22 = socket_full(a2[8], 30);
                  if ( v22 )
                  {
                    (*(void (__fastcall **)(int *))(a1 + 8))(a2);
                    free(v10);
                    goto LABEL_31;
                  }
                  v22 = v30;
                }
LABEL_42:
                free(v10);
LABEL_31:
                if ( *((_DWORD *)v5 + 1) != -1 )
                {
                  v23 = (unsigned int *)v5 + 1;
                  __dmb(0xBu);
                  do
                  {
                    v24 = __ldrex(v23);
                    v25 = v24 - 1;
                  }
                  while ( __strex(v25, v23) );
                  if ( !v25 )
LABEL_47:
                    json_delete(v5);
                }
                if ( v22 )
                  return 1;
                goto LABEL_15;
              }
            }
          }
        }
        if ( v10 )
          goto LABEL_42;
        goto LABEL_31;
      }
      V_LOCK();
      logfmt_raw(v37, 0x1000u, 0, "JSON decode failed(%d): %s", *(_DWORD *)v35, v36);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/frontend/frontend_base.c",
        152,
        "stratum_subscribe_base",
        22,
        147,
        100,
        v37);
      if ( v10 )
        free(v10);
LABEL_15:
      if ( v6 )
        v2 ^= 1u;
      else
        v2 = 0;
      if ( !v2 )
        return 0;
    }
    V_LOCK();
    logfmt_raw(v37, 0x1000u, 0, "stratum_subscribe send failed");
    V_UNLOCK();
    v13 = 131;
    v14 = g_zc;
    LOWORD(v15) = (unsigned __int16)"/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp"
                                    "/release/build/godminer-origin_godminer-new/frontend/frontend_base.c";
LABEL_11:
    HIWORD(v15) = (unsigned int)"/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/rel"
                                "ease/build/godminer-origin_godminer-new/frontend/frontend_base.c" >> 16;
    zlog(v14, v15, 152, "stratum_subscribe_base", 22, v13, 100, v37);
LABEL_12:
    if ( v10 )
    {
      free(v10);
      if ( v5 )
      {
        v22 = 0;
        goto LABEL_31;
      }
    }
    else if ( v5 )
    {
      if ( *((_DWORD *)v5 + 1) != -1 )
      {
        v26 = (unsigned int *)v5 + 1;
        __dmb(0xBu);
        do
        {
          v27 = __ldrex(v26);
          v28 = v27 - 1;
        }
        while ( __strex(v28, v26) );
        if ( !v28 )
        {
          v22 = 0;
          goto LABEL_47;
        }
      }
    }
    goto LABEL_15;
  }
  return 1;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00035DA8) --------------------------------------------------------
int __fastcall stratum_authorize_base(int a1, _DWORD *a2)
{
  const char *v2; // r8
  const char *v5; // r9
  size_t v6; // r6
  size_t v7; // r0
  char *v8; // r0
  int v9; // r2
  char *v10; // r7
  int v11; // r8
  void *v13; // r6
  double *v14; // r5
  _DWORD *v15; // r9
  _DWORD *v16; // r6
  int v17; // r0
  int v18; // r0
  _BOOL4 v19; // r3
  int v20; // r10
  unsigned int *v21; // r3
  unsigned int v22; // r2
  unsigned int v23; // r2
  char v24[92]; // [sp+14h] [bp-10FCh] BYREF
  _BYTE v25[160]; // [sp+70h] [bp-10A0h] BYREF
  char v26[4096]; // [sp+110h] [bp-1000h] BYREF

  v2 = (const char *)a2[3];
  v5 = (const char *)a2[4];
  v6 = strlen(v2);
  v7 = strlen(v5);
  v8 = (char *)malloc(v6 + v7 + 80);
  v9 = a2[478];
  v10 = v8;
  a2[478] = v9 + 1;
  sprintf(v8, "{\"id\":%d,\"method\":\"mining.authorize\",\"params\":[\"%s\",\"%s\"]}", v9, v2, v5);
  v11 = (*(int (__fastcall **)(_DWORD *, char *))(a1 + 12))(a2, v10);
  if ( !v11 )
  {
LABEL_2:
    free(v10);
    return v11;
  }
  while ( 1 )
  {
    v13 = (void *)(*(int (__fastcall **)(_DWORD *))(a1 + 8))(a2);
    if ( !v13 )
    {
      v11 = 0;
      goto LABEL_2;
    }
    if ( !(*(int (**)(void))(a1 + 20))() )
      break;
    free(v13);
  }
  v14 = json_loads((int)v13, 0, v24);
  free(v13);
  if ( !v14 )
  {
    v11 = 0;
    V_LOCK();
    logfmt_raw(v26, 0x1000u, 0, "JSON decode failed(%d): %s", *(_DWORD *)v24, v25);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/frontend/frontend_base.c",
      152,
      "stratum_authorize_base",
      22,
      224,
      100,
      v26);
    free(v10);
    return v11;
  }
  v15 = (_DWORD *)json_object_get(v14, "result");
  v16 = (_DWORD *)json_object_get(v14, "error");
  v17 = json_object_get(v14, "id");
  v18 = json_integer_value(v17);
  v19 = v15 == 0;
  v20 = v18;
  if ( a2[478] - 1 != v18 )
    v19 = 1;
  if ( v19 || *v15 == 6 || v16 && *v16 != 7 )
  {
    V_LOCK();
    v11 = 0;
    logfmt_raw(v26, 0x1000u, 0, "Stratum authentication failed, req_id=%d", v20);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/frontend/frontend_base.c",
      152,
      "stratum_authorize_base",
      22,
      234,
      100,
      v26);
  }
  free(v10);
  if ( *((_DWORD *)v14 + 1) == -1 )
    return v11;
  v21 = (unsigned int *)v14 + 1;
  __dmb(0xBu);
  do
  {
    v22 = __ldrex(v21);
    v23 = v22 - 1;
  }
  while ( __strex(v23, v21) );
  if ( v23 )
    return v11;
  json_delete(v14);
  return v11;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00036054) --------------------------------------------------------
int __fastcall stratum_login_base(int a1, int a2)
{
  int result; // r0

  result = (*(int (**)(void))(a1 + 36))();
  if ( result )
    return (*(int (__fastcall **)(int, int))(a1 + 40))(a1, a2);
  return result;
}

//----- (00036084) --------------------------------------------------------
int __fastcall stratum_handle_response_base(int a1, int a2, int a3)
{
  double *v4; // r0
  double *v5; // r4
  _DWORD *v6; // r5
  _DWORD *v7; // r8
  _DWORD *v8; // r7
  _BYTE *v9; // r0
  _BOOL4 v10; // r9
  int v11; // r0
  int v12; // r6
  bool v13; // zf
  char *v14; // r2
  unsigned int *v15; // r3
  unsigned int v16; // r2
  unsigned int v17; // r2
  char *v19; // r2
  _DWORD *v20; // r0
  char v21[92]; // [sp+14h] [bp-10FCh] BYREF
  _BYTE v22[160]; // [sp+70h] [bp-10A0h] BYREF
  char v23[4096]; // [sp+110h] [bp-1000h] BYREF

  v4 = json_loads(a2, 0, v21);
  v5 = v4;
  if ( !v4 )
  {
    V_LOCK();
    logfmt_raw(v23, 0x1000u, 0, "JSON decode failed(%d): %s", *(_DWORD *)v21, v22);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/frontend/frontend_base.c",
      152,
      "stratum_handle_response_base",
      28,
      262,
      40,
      v23);
    return 0;
  }
  v6 = (_DWORD *)json_object_get(v4, "result");
  v7 = (_DWORD *)json_object_get(v5, "error");
  v8 = (_DWORD *)json_object_get(v5, "id");
  if ( !v6 || *v6 == 7 || v6 == json_false() )
    goto LABEL_15;
  v9 = json_string_value(v6);
  v10 = (_BOOL4)v9;
  if ( !v9 )
    goto LABEL_16;
  if ( *v9 == 111 && v9[1] == 107 )
  {
    v11 = (unsigned __int8)v9[2];
    v10 = (_BOOL4)v7;
    if ( v7 )
      v10 = 1;
    if ( v11 )
      v10 = 0;
    if ( v10 )
      v10 = *v7 == 7;
  }
  else
  {
LABEL_15:
    v10 = 0;
  }
LABEL_16:
  if ( v6 == json_true() )
  {
    if ( v7 )
    {
      if ( *v7 == 7 )
        v10 = 1;
      if ( !v8 )
        goto LABEL_32;
      goto LABEL_18;
    }
    v10 = 1;
  }
  if ( !v8 )
  {
LABEL_32:
    V_LOCK();
    logfmt_raw(v23, 0x1000u, 0, "%s json id is null!", "stratum_handle_response_base");
    V_UNLOCK();
    v12 = 0;
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/frontend/frontend_base.c",
      152,
      "stratum_handle_response_base",
      28,
      286,
      20,
      v23);
    goto LABEL_33;
  }
LABEL_18:
  if ( *v8 == 7 )
    goto LABEL_32;
  v12 = *(unsigned __int8 *)(a3 + 1648);
  if ( *(_BYTE *)(a3 + 1648) )
  {
    v13 = v6 == 0;
    if ( !v6 )
      v13 = v7 == 0;
    if ( !v13 )
    {
      if ( v7 )
        v14 = (char *)json_string_value(v7);
      else
        v14 = 0;
      share_result(v10, 0, v14, (double *)a3);
      goto LABEL_33;
    }
LABEL_46:
    v12 = 0;
    goto LABEL_33;
  }
  if ( !v6 || json_integer_value((int)v8) < 4 )
    goto LABEL_46;
  if ( v7 )
  {
    v20 = json_array_get(v7, 1u);
    v19 = (char *)json_string_value(v20);
  }
  else
  {
    v19 = 0;
  }
  v12 = 1;
  share_result(v10, 0, v19, (double *)a3);
LABEL_33:
  if ( *((_DWORD *)v5 + 1) != -1 )
  {
    v15 = (unsigned int *)v5 + 1;
    __dmb(0xBu);
    do
    {
      v16 = __ldrex(v15);
      v17 = v16 - 1;
    }
    while ( __strex(v17, v15) );
    if ( !v17 )
      json_delete(v5);
  }
  return v12;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00036370) --------------------------------------------------------
int __fastcall sub_36370(int a1, int a2, _DWORD *a3, unsigned int a4)
{
  _DWORD *v7; // r0
  char *v8; // r4
  _DWORD *v9; // r0
  size_t v10; // r0
  size_t v11; // r5
  size_t v12; // r0
  int v13; // r12
  int v14; // r0
  int v15; // r3
  void *v17; // r0
  size_t v18; // r6
  void *v19; // r0
  void *v20; // r0
  _DWORD *v21; // r0
  char v22[4100]; // [sp+10h] [bp-1004h] BYREF

  v7 = json_array_get(a3, a4);
  v8 = (char *)json_string_value(v7);
  if ( !v8 )
  {
    V_LOCK();
    logfmt_raw(v22, 0x1000u, 0, "Failed to get extranonce1");
    V_UNLOCK();
    v13 = 73;
    v14 = g_zc;
    LOWORD(v15) = 6796;
    goto LABEL_7;
  }
  v9 = json_array_get(a3, a4 + 1);
  v10 = json_integer_value((int)v9);
  v11 = v10;
  if ( !v10 )
  {
    V_LOCK();
    logfmt_raw(v22, 0x1000u, 0, "Failed to get extranonce2_size");
    V_UNLOCK();
    v13 = 78;
    goto LABEL_6;
  }
  if ( v10 - 4 > 0xB )
  {
    V_LOCK();
    logfmt_raw(v22, 0x1000u, 0, "Failed to get valid n2size in parse_extranonce, xn2_size=%d", v11);
    V_UNLOCK();
    v13 = 82;
    goto LABEL_6;
  }
  if ( v10 + (strlen(v8) >> 1) != 16 )
  {
    V_LOCK();
    v12 = strlen(v8);
    logfmt_raw(v22, 0x1000u, 0, "n1size %d, n2size %d, n1size + n2size != %d, in parse_extranonce", v12 >> 1, v11, 16);
    V_UNLOCK();
    v13 = 86;
LABEL_6:
    v14 = g_zc;
    LOWORD(v15) = (unsigned __int16)"stratum_parse_extranonce_ckb";
LABEL_7:
    HIWORD(v15) = (unsigned int)"stratum_parse_extranonce_ckb" >> 16;
    zlog(
      v14,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/frontend/frontend_ckb/frontend_ckb.c",
      164,
      v15,
      28,
      v13,
      100,
      v22);
    return 0;
  }
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 1584));
  v17 = *(void **)(a2 + 76);
  if ( v17 )
  {
    free(v17);
    *(_DWORD *)(a2 + 76) = 0;
  }
  v18 = strlen(v8) >> 1;
  *(_DWORD *)(a2 + 72) = v18;
  v19 = calloc(1u, v18);
  *(_DWORD *)(a2 + 76) = v19;
  if ( v19 )
  {
    hex2bin((int)v19, (unsigned __int8 *)v8, v18);
    memcpy((void *)(a2 + 488), *(const void **)(a2 + 76), *(_DWORD *)(a2 + 72));
    v20 = *(void **)(a2 + 1580);
    *(_DWORD *)(a2 + 80) = v11;
    if ( v20 )
      free(v20);
    v21 = calloc(1u, 0x14u);
    *(_DWORD *)(a2 + 1580) = v21;
    if ( v21 )
    {
      *v21 = v11;
      memset(v21 + 1, 0, v11);
      pthread_mutex_unlock((pthread_mutex_t *)(a2 + 1584));
      V_LOCK();
      logfmt_raw(v22, 0x1000u, 0, "Stratum set nonce1 %s, nonce2 size=%d", v8, v11);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/frontend/frontend_ckb/frontend_ckb.c",
        164,
        "stratum_parse_extranonce_ckb",
        28,
        121,
        20,
        v22);
      return 1;
    }
    else
    {
      printf("invalid pointer(%s)!\n", "work->private");
      return 0;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v22, 0x1000u, 0, "Failed to alloc xnonce1");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/frontend/frontend_ckb/frontend_ckb.c",
      164,
      "stratum_parse_extranonce_ckb",
      28,
      95,
      100,
      v22);
    pthread_mutex_unlock((pthread_mutex_t *)(a2 + 1584));
    return 0;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (000366FC) --------------------------------------------------------
int __fastcall sub_366FC(int a1, pthread_mutex_t *a2, _DWORD *a3)
{
  _DWORD *v5; // r0
  const char *v6; // r7
  _DWORD *v7; // r0
  char *v8; // r5
  _DWORD *v9; // r0
  unsigned int v10; // r9
  unsigned int v11; // r11
  char *v12; // r8
  _DWORD *v13; // r0
  bool v14; // r10
  _BOOL4 v15; // r4
  _DWORD *v17; // r0
  size_t v18; // r0
  const char *kind; // r0
  void *v20; // r4
  int v21; // r0
  unsigned int v22; // r1
  int v23; // r2
  int v24; // r3
  int v25; // r1
  int v26; // r2
  unsigned int v27; // r3
  int v28; // r1
  unsigned int v29; // r2
  int v30; // r3
  unsigned int v31; // r1
  int v32; // r2
  int v33; // r3
  int lock; // r2
  size_t v35; // r0
  _DWORD v36[8]; // [sp+10h] [bp-1044h] BYREF
  _DWORD v37[8]; // [sp+30h] [bp-1024h] BYREF
  char v38[4100]; // [sp+50h] [bp-1004h] BYREF

  v5 = json_array_get(a3, 0);
  v6 = (const char *)json_string_value(v5);
  v7 = json_array_get(a3, 1u);
  v8 = (char *)json_string_value(v7);
  v9 = json_array_get(a3, 2u);
  v10 = json_integer_value((int)v9);
  if ( json_array_get(a3, 3u) && *json_array_get(a3, 3u) == 2 )
  {
    v17 = json_array_get(a3, 3u);
    v11 = 4;
    v12 = (char *)json_string_value(v17);
  }
  else
  {
    v11 = 3;
    v12 = 0;
  }
  v13 = json_array_get(a3, v11);
  v14 = (char)v13;
  if ( v13 )
    v14 = *json_array_get(a3, v11) == 5;
  if ( v6 )
    v15 = v8 == 0;
  else
    v15 = 1;
  if ( v15 || strlen(v8) != 64 )
  {
    V_LOCK();
    logfmt_raw(v38, 0x1000u, 0, "Stratum notify: invalid parameters");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/frontend/frontend_ckb/frontend_ckb.c",
      164,
      "stratum_notify_ckb",
      18,
      30,
      100,
      v38);
    return 0;
  }
  hex2bin((int)v36, (unsigned __int8 *)v8, 32);
  if ( v12 )
  {
    v18 = strlen(v12);
    hex2bin((int)v37, (unsigned __int8 *)v12, v18 >> 1);
  }
  if ( a2 == (pthread_mutex_t *)-448 )
    return 0;
  kind = (const char *)a2[65].__kind;
  if ( kind && !strcmp(kind, v6) )
  {
    V_LOCK();
    logfmt_raw(v38, 0x1000u, 0, "Stratum notify: new job's job_id doesnot change(%s)", a2[65].__kind);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/frontend/frontend_ckb/frontend_ckb.c",
      164,
      "stratum_notify_ckb",
      18,
      41,
      20,
      v38);
  }
  if ( strlen(v6) > 0x1F )
  {
    V_LOCK();
    v35 = strlen(v6);
    logfmt_raw(v38, 0x1000u, 0, "Stratum notify: job_id %s, len %d >= 32", v6, v35);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/frontend/frontend_ckb/frontend_ckb.c",
      164,
      "stratum_notify_ckb",
      18,
      44,
      100,
      v38);
  }
  pthread_mutex_lock(a2 + 66);
  v20 = (void *)a2[65].__kind;
  a2[65].__kind = (int)_strdup(v6);
  if ( v20 )
    free(v20);
  v21 = v36[0];
  v22 = v36[1];
  v23 = v36[2];
  v24 = v36[3];
  a2[63].__nusers = v10;
  a2[68].__count = v10;
  a2[19].__lock = v21;
  a2[19].__count = v22;
  a2[19].__owner = v23;
  a2[19].__kind = v24;
  v25 = v36[5];
  v26 = v36[6];
  v27 = v36[7];
  a2[19].__nusers = v36[4];
  a2[19].__spins = v25;
  a2[20].__lock = v26;
  a2[20].__count = v27;
  if ( v12 )
  {
    v28 = v37[1];
    v29 = v37[2];
    v30 = v37[3];
    a2[3].__spins = v37[0];
    a2[4].__lock = v28;
    a2[4].__count = v29;
    a2[4].__owner = v30;
    v31 = v37[5];
    v32 = v37[6];
    v33 = v37[7];
    a2[4].__kind = v37[4];
    a2[4].__nusers = v31;
    a2[4].__spins = v32;
    a2[5].__lock = v33;
  }
  lock = a2->__lock;
  a2[18].__size[4] = v14;
  *((_QWORD *)&a2[18].__align + 2) = lock;
  pthread_mutex_unlock(a2 + 66);
  return 1;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00036A74) --------------------------------------------------------
int __fastcall sub_36A74(int a1, int a2, char *a3)
{
  int *v4; // r1
  int v7; // r3
  const char *v8; // r12
  const char *v10; // [sp+4h] [bp-30h]
  char s[36]; // [sp+10h] [bp-24h] BYREF

  v4 = *(int **)(a1 + 1132);
  if ( v4 )
  {
    bin2hex((int)s, (int)(v4 + 1), *v4);
    v7 = *(_DWORD *)(a2 + 1912);
    v8 = *(const char **)(a2 + 12);
    v10 = *(const char **)(a1 + 1124);
    *(_DWORD *)(a2 + 1912) = v7 + 1;
    snprintf(a3, 0x400u, "{\"id\":%d,\"method\":\"mining.submit\",\"params\":[\"%s\",\"%s\",\"%s\"]}", v7, v8, v10, s);
    return 0;
  }
  else
  {
    printf("invalid pointer(%s)!\n", "private");
    return 3;
  }
}

//----- (00036B04) --------------------------------------------------------
_DWORD *frontend_runtime_ckb()
{
  _DWORD *result; // r0

  result = calloc(1u, 0x50u);
  *result = stratum_connect;
  result[1] = stratum_disconnect;
  result[2] = stratum_recv_line;
  result[3] = stratum_send_line;
  result[4] = stratum_login_base;
  result[5] = stratum_handle_method_base;
  result[6] = stratum_handle_response_base;
  result[7] = sub_36A74;
  result[8] = sub_366C4;
  result[9] = stratum_subscribe_base;
  result[10] = stratum_authorize_base;
  result[11] = sub_366FC;
  result[12] = sub_36370;
  result[13] = stratum_set_diff_or_target_base;
  result[14] = target_to_diff_ckb;
  result[15] = diff_to_target_ckb;
  result[16] = target_to_double_diff_ckb;
  return result;
}
// 366C4: using guessed type int sub_366C4();
// 3D3D8: using guessed type int __fastcall target_to_diff_ckb(_DWORD);

//----- (00036BE4) --------------------------------------------------------
int __fastcall sub_36BE4(int a1, pthread_mutex_t *a2, _DWORD *a3, unsigned int a4)
{
  _DWORD *v7; // r0
  char *v8; // r4
  _DWORD *v9; // r0
  size_t v10; // r0
  size_t v11; // r6
  void *count; // r0
  size_t v13; // r7
  void *v14; // r0
  struct __pthread_internal_slist *next; // r0
  _DWORD *v16; // r0
  _DWORD *v17; // r7
  int v19; // r12
  int v20; // r0
  int v21; // r3
  char v22[4100]; // [sp+10h] [bp-1004h] BYREF

  v7 = json_array_get(a3, a4);
  v8 = (char *)json_string_value(v7);
  if ( !v8 )
  {
    V_LOCK();
    logfmt_raw(v22, 0x1000u, 0, "Failed to get extranonce1");
    V_UNLOCK();
    v19 = 208;
    v20 = g_zc;
    LOWORD(v21) = 7484;
    goto LABEL_13;
  }
  v9 = json_array_get(a3, a4 + 1);
  v10 = json_integer_value((int)v9);
  v11 = v10;
  if ( !v10 )
  {
    V_LOCK();
    logfmt_raw(v22, 0x1000u, 0, "Failed to get extranonce2_size");
    V_UNLOCK();
    v19 = 213;
    goto LABEL_12;
  }
  if ( v10 - 2 > 0xE )
  {
    V_LOCK();
    logfmt_raw(v22, 0x1000u, 0, "Failed to get valid n2size in parse_extranonce, xn2_size=%d", v11);
    V_UNLOCK();
    v19 = 217;
LABEL_12:
    v20 = g_zc;
    LOWORD(v21) = (unsigned __int16)"stratum_parse_extranonce_dash";
LABEL_13:
    HIWORD(v21) = (unsigned int)"stratum_parse_extranonce_dash" >> 16;
    zlog(
      v20,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/frontend/frontend_dash/frontend_dash.c",
      166,
      v21,
      29,
      v19,
      100,
      v22);
    return 0;
  }
  pthread_mutex_lock(a2 + 66);
  count = (void *)a2[3].__count;
  if ( count )
  {
    free(count);
    a2[3].__count = 0;
  }
  v13 = strlen(v8) >> 1;
  a2[3].__lock = v13;
  v14 = calloc(1u, v13);
  a2[3].__count = (unsigned int)v14;
  if ( v14 )
  {
    hex2bin((int)v14, (unsigned __int8 *)v8, v13);
    next = a2[65].__list.__next;
    if ( next )
      free(next);
    v16 = calloc(1u, 0x18u);
    v17 = v16;
    a2[65].__spins = (int)v16;
    if ( v16 )
    {
      a2[3].__owner = v11;
      *v16 = v11;
      memset(v16 + 4, 0, v11);
      v17[4] = 0;
      pthread_mutex_unlock(a2 + 66);
      V_LOCK();
      logfmt_raw(v22, 0x1000u, 0, "Stratum set nonce1 %s, nonce2 size=%d", v8, v11);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/frontend/frontend_dash/frontend_dash.c",
        166,
        "stratum_parse_extranonce_dash",
        29,
        251,
        20,
        v22);
      return 1;
    }
    else
    {
      printf("invalid pointer(%s)!\n", "work->private");
      return 0;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v22, 0x1000u, 0, "Failed to alloc xnonce1");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/frontend/frontend_dash/frontend_dash.c",
      166,
      "stratum_parse_extranonce_dash",
      29,
      226,
      100,
      v22);
    pthread_mutex_unlock(a2 + 66);
    return 0;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00036F0C) --------------------------------------------------------
bool __fastcall sub_36F0C(int a1, pthread_mutex_t *a2, _DWORD *a3)
{
  _DWORD *v5; // r0
  _DWORD *v6; // r4
  _BOOL4 v7; // r9
  int v9; // r8
  _DWORD *v10; // r0
  const char *v11; // r6
  _DWORD *v12; // r0
  const char *v13; // r7
  _DWORD *v14; // r0
  char *v15; // r11
  _DWORD *v16; // r0
  _DWORD *v17; // r0
  _DWORD *v18; // r0
  _DWORD *v19; // r0
  _DWORD *v20; // r0
  bool v21; // r9
  const char *kind; // r0
  size_t v23; // r0
  void *v24; // r10
  int owner; // r1
  int count; // r2
  size_t v27; // r3
  int v28; // r3
  int i; // r9
  void *v30; // r10
  void *v31; // r0
  void *v32; // r8
  char *v33; // r2
  signed int v34; // r6
  _DWORD *v35; // r0
  unsigned __int8 *v36; // r0
  int v37; // r10
  unsigned __int8 *v38; // r9
  void *v39; // r0
  int v40; // r12
  char *s; // [sp+18h] [bp-113Ch]
  const char *v42; // [sp+1Ch] [bp-1138h]
  const char *v43; // [sp+20h] [bp-1134h]
  const char *v44; // [sp+24h] [bp-1130h]
  _BOOL4 v45; // [sp+28h] [bp-112Ch]
  void *src; // [sp+2Ch] [bp-1128h]
  size_t n; // [sp+30h] [bp-1124h]
  unsigned int v48; // [sp+34h] [bp-1120h]
  size_t nmemb; // [sp+3Ch] [bp-1118h]
  const char *v50; // [sp+40h] [bp-1114h]
  int v51; // [sp+58h] [bp-10FCh]
  char v52[228]; // [sp+6Ch] [bp-10E8h] BYREF
  char v53[4100]; // [sp+150h] [bp-1004h] BYREF

  v5 = json_array_get(a3, 4u);
  v6 = v5;
  if ( !v5 || *v5 != 1 )
    return 0;
  v9 = (int)json_array_size(v5);
  v10 = json_array_get(a3, 0);
  v11 = (const char *)json_string_value(v10);
  v12 = json_array_get(a3, 1u);
  v13 = (const char *)json_string_value(v12);
  v14 = json_array_get(a3, 2u);
  v15 = (char *)json_string_value(v14);
  v16 = json_array_get(a3, 3u);
  s = (char *)json_string_value(v16);
  v17 = json_array_get(a3, 5u);
  v42 = (const char *)json_string_value(v17);
  v18 = json_array_get(a3, 6u);
  v44 = (const char *)json_string_value(v18);
  v19 = json_array_get(a3, 7u);
  v43 = (const char *)json_string_value(v19);
  v20 = json_array_get(a3, 8u);
  v21 = (char)v20;
  if ( v20 )
  {
    v21 = *json_array_get(a3, 8u) == 5;
    v45 = v21;
  }
  else
  {
    v45 = 0;
  }
  if ( valid_ascii(v11)
    && valid_hex(v13)
    && valid_hex(v15)
    && valid_hex(s)
    && valid_hex(v42)
    && valid_hex(v44)
    && valid_hex(v43) )
  {
    if ( a2 != (pthread_mutex_t *)-448 )
    {
      kind = (const char *)a2[65].__kind;
      if ( kind && !strcmp(kind, v11) )
      {
        V_LOCK();
        logfmt_raw(v53, 0x1000u, 0, "Stratum notify: new job's job_id doesnot change, %s, %s", a2[65].__kind, v11);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/frontend/frontend_dash/frontend_dash.c",
          166,
          "stratum_notify_dash",
          19,
          86,
          80,
          v53);
      }
      if ( strlen(v11) > 0x3F )
      {
        V_LOCK();
        v23 = strlen(v11);
        logfmt_raw(v53, 0x1000u, 0, "Stratum notify: job_id len = %s, len %d >= 64", v11, v23);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/frontend/frontend_dash/frontend_dash.c",
          166,
          "stratum_notify_dash",
          19,
          89,
          80,
          v53);
      }
      pthread_mutex_lock(a2 + 66);
      v24 = (void *)a2[65].__kind;
      a2[65].__kind = (int)_strdup(v11);
      if ( v24 )
        free(v24);
      snprintf(&a2[3].__size[20], 0x41u, "%s", v13);
      nmemb = strlen(v15) >> 1;
      n = strlen(s) >> 1;
      snprintf(&a2[13].__size[12], 9u, "%s", v42);
      snprintf((char *)&a2[14], 9u, "%s", v44);
      snprintf(&a2[14].__size[12], 9u, "%s", v43);
      owner = a2[3].__owner;
      count = a2[13].__count;
      v27 = nmemb + a2[3].__lock;
      a2[13].__lock = v27;
      a2[18].__size[4] = v21;
      v48 = n + owner + v27;
      a2[12].__lock = v48;
      if ( count > 0 )
      {
        v28 = a2[13].__owner;
        for ( i = 0; i < count; ++i )
        {
          if ( *(_DWORD *)(v28 + 4 * i) )
          {
            free(*(void **)(v28 + 4 * i));
            v28 = a2[13].__owner;
            count = a2[13].__count;
            *(_DWORD *)(v28 + 4 * i) = 0;
          }
        }
      }
      if ( v9 )
      {
        v50 = v11;
        v34 = 0;
        a2[13].__owner = (int)realloc((void *)a2[13].__owner, 4 * v9);
        while ( 1 )
        {
          v51 = 4 * v34;
          if ( v9 <= v34 )
            break;
          v35 = json_array_get(v6, v34);
          v36 = (unsigned __int8 *)json_string_value(v35);
          v37 = a2[13].__owner;
          v38 = v36;
          v39 = malloc(0x20u);
          *(_DWORD *)(v37 + 4 * v34) = v39;
          if ( !v39 )
          {
            V_LOCK();
            logfmt_raw(v53, 0x1000u, 0, "Failed to malloc pool swork merkle_bin");
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godmine"
              "r-origin_godminer-new/frontend/frontend_dash/frontend_dash.c",
              166,
              "stratum_notify_dash",
              19,
              117,
              100,
              v53);
          }
          if ( opt_protocol )
          {
            V_LOCK();
            logfmt_raw(v53, 0x1000u, 0, "merkle %d: %s", v34, v38);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godmine"
              "r-origin_godminer-new/frontend/frontend_dash/frontend_dash.c",
              166,
              "stratum_notify_dash",
              19,
              119,
              20,
              v53);
          }
          ++v34;
          if ( !hex2bin(*(_DWORD *)(a2[13].__owner + v51), v38, 32) )
          {
            v7 = 0;
            v11 = v50;
            V_LOCK();
            logfmt_raw(v53, 0x1000u, 0, "Failed to convert merkle to merkle_bin in parse_notify");
            V_UNLOCK();
            v40 = 124;
            goto LABEL_58;
          }
        }
        v11 = v50;
      }
      a2[13].__count = v9;
      if ( v45 )
        *((_QWORD *)&a2[12].__align + 2) = 0;
      snprintf(
        v52,
        0xE1u,
        "%s%s%s%s%s%s%s",
        &a2[13].__size[12],
        &a2[3].__size[20],
        "0000000000000000000000000000000000000000000000000000000000000000",
        &a2[14].__size[12],
        (const char *)&a2[14],
        "00000000",
        workpadding);
      v7 = hex2bin((int)&a2[6].__nusers, (unsigned __int8 *)v52, 112);
      if ( v7 )
      {
        src = calloc(nmemb, 1u);
        v7 = hex2bin((int)src, (unsigned __int8 *)v15, nmemb);
        if ( v7 )
        {
          v30 = calloc(n, 1u);
          v7 = hex2bin((int)v30, (unsigned __int8 *)s, n);
          if ( v7 )
          {
            v31 = (void *)a2[12].__count;
            if ( v31 )
              free(v31);
            if ( (v48 & 3) != 0 )
              v48 = (v48 & 0xFFFFFFFC) + 4;
            v32 = calloc(v48, 1u);
            a2[12].__count = (unsigned int)v32;
            if ( !v32 )
            {
              V_LOCK();
              logfmt_raw(v53, 0x1000u, 0, "Failed to calloc pool coinbase in parse_notify");
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godmi"
                "ner-origin_godminer-new/frontend/frontend_dash/frontend_dash.c",
                166,
                "stratum_notify_dash",
                19,
                165,
                100,
                v53);
            }
            memcpy((void *)a2[12].__count, src, nmemb);
            memcpy((void *)(a2[12].__count + nmemb), (const void *)a2[3].__count, a2[3].__lock);
            memcpy((void *)(a2[12].__count + a2[3].__lock + a2[3].__owner + nmemb), v30, n);
            *((_QWORD *)&a2[18].__align + 2) = a2->__lock;
          }
          else
          {
            V_LOCK();
            logfmt_raw(v53, 0x1000u, 0, "Failed to convert cb2 to cb2_bin in parse_notify");
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godmine"
              "r-origin_godminer-new/frontend/frontend_dash/frontend_dash.c",
              166,
              "stratum_notify_dash",
              19,
              158,
              100,
              v53);
          }
        }
        else
        {
          V_LOCK();
          logfmt_raw(v53, 0x1000u, 0, "Failed to convert cb1 to cb1_bin in parse_notify");
          V_UNLOCK();
          v30 = 0;
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/frontend/frontend_dash/frontend_dash.c",
            166,
            "stratum_notify_dash",
            19,
            151,
            100,
            v53);
        }
      }
      else
      {
        V_LOCK();
        logfmt_raw(v53, 0x1000u, 0, "Failed to convert header to header_bin in parse_notify");
        V_UNLOCK();
        v40 = 144;
LABEL_58:
        v30 = 0;
        src = 0;
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/frontend/frontend_dash/frontend_dash.c",
          166,
          "stratum_notify_dash",
          19,
          v40,
          100,
          v53);
      }
      pthread_mutex_unlock(a2 + 66);
      if ( opt_protocol )
      {
        V_LOCK();
        logfmt_raw(v53, 0x1000u, 0, "job_id: %s", v11);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/frontend/frontend_dash/frontend_dash.c",
          166,
          "stratum_notify_dash",
          19,
          183,
          20,
          v53);
        V_LOCK();
        logfmt_raw(v53, 0x1000u, 0, "prev_hash: %s", v13);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/frontend/frontend_dash/frontend_dash.c",
          166,
          "stratum_notify_dash",
          19,
          184,
          20,
          v53);
        V_LOCK();
        logfmt_raw(v53, 0x1000u, 0, "coinbase1: %s", v15);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/frontend/frontend_dash/frontend_dash.c",
          166,
          "stratum_notify_dash",
          19,
          185,
          20,
          v53);
        V_LOCK();
        logfmt_raw(v53, 0x1000u, 0, "coinbase2: %s", s);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/frontend/frontend_dash/frontend_dash.c",
          166,
          "stratum_notify_dash",
          19,
          186,
          20,
          v53);
        V_LOCK();
        logfmt_raw(v53, 0x1000u, 0, "bbversion: %s", v42);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/frontend/frontend_dash/frontend_dash.c",
          166,
          "stratum_notify_dash",
          19,
          187,
          20,
          v53);
        V_LOCK();
        logfmt_raw(v53, 0x1000u, 0, "nbit: %s", v44);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/frontend/frontend_dash/frontend_dash.c",
          166,
          "stratum_notify_dash",
          19,
          188,
          20,
          v53);
        V_LOCK();
        logfmt_raw(v53, 0x1000u, 0, "ntime: %s", v43);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/frontend/frontend_dash/frontend_dash.c",
          166,
          "stratum_notify_dash",
          19,
          189,
          20,
          v53);
        V_LOCK();
        v33 = "yes";
        if ( !v45 )
          v33 = "no";
        logfmt_raw(v53, 0x1000u, 0, "clean: %s", v33);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/frontend/frontend_dash/frontend_dash.c",
          166,
          "stratum_notify_dash",
          19,
          190,
          20,
          v53);
      }
      if ( src )
        free(src);
      if ( v30 )
        free(v30);
      return v7;
    }
    return 0;
  }
  V_LOCK();
  logfmt_raw(v53, 0x1000u, 0, "Stratum notify: invalid parameters");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/frontend/frontend_dash/frontend_dash.c",
    166,
    "stratum_notify_dash",
    19,
    80,
    100,
    v53);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1063F4: using guessed type char *workpadding;
// 107A64: using guessed type char opt_protocol;
// 11A7AC: using guessed type int g_zc;

//----- (00037B18) --------------------------------------------------------
int __fastcall sub_37B18(int a1, int a2, char *a3)
{
  int v3; // r4
  int v7; // r2
  const char *v8; // lr
  const char *v9; // r3
  int v11; // [sp+10h] [bp-74h]
  unsigned int v12; // [sp+1Ch] [bp-68h] BYREF
  _QWORD v13[4]; // [sp+20h] [bp-64h] BYREF
  char s[32]; // [sp+40h] [bp-44h] BYREF
  char v15[32]; // [sp+60h] [bp-24h] BYREF

  v3 = *(_DWORD *)(a1 + 1132);
  if ( v3 )
  {
    v7 = *(_DWORD *)v3;
    v13[0] = *(_QWORD *)(v3 + 8);
    bin2hex((int)s, (int)v13, v7);
    v12 = bswap32(*(_DWORD *)(v3 + 16));
    bin2hex((int)v15, (int)&v12, 4);
    v8 = *(const char **)(a1 + 1124);
    v9 = *(const char **)(a2 + 12);
    v11 = *(_DWORD *)(a2 + 1912);
    *(_DWORD *)(a2 + 1912) = v11 + 1;
    snprintf(
      a3,
      0x400u,
      "{\"params\": [\"%s\", \"%s\", \"%s\", \"%s\", \"%s\"], \"id\": %d, \"method\": \"mining.submit\"}",
      v9,
      v8,
      s,
      (const char *)(a1 + 1100),
      v15,
      v11);
    return 0;
  }
  else
  {
    printf("invalid pointer(%s)!\n", "private");
    return 3;
  }
}

//----- (00037BE4) --------------------------------------------------------
void *frontend_runtime_dash()
{
  __int64 v0; // r2
  void *v1; // r0

  dword_1085E4 = (int)stratum_connect;
  dword_1085E8 = (int)stratum_disconnect;
  dword_1085EC = (int)stratum_recv_line;
  dword_1085F0 = (int)stratum_send_line;
  dword_1085F4 = (int)stratum_login_base;
  dword_1085F8 = (int)stratum_handle_method_base;
  dword_1085FC = (int)stratum_handle_response_base;
  dword_108600 = (int)sub_37B18;
  dword_108604 = (int)sub_36ED4;
  dword_108608 = (int)stratum_subscribe_base;
  dword_10860C = (int)stratum_authorize_base;
  dword_108610 = (int)sub_36F0C;
  LODWORD(v0) = diff_to_target_dash;
  HIDWORD(v0) = le256_target_to_double_diff_base_0;
  dword_108614 = (int)sub_36BE4;
  dword_108618 = (int)stratum_set_diff_or_target_base;
  *(_QWORD *)&dword_108620 = v0;
  dword_10861C = (int)le256_target_to_diff_base_0;
  v1 = calloc(1u, 0x50u);
  return memcpy(v1, &dword_1085E4, 0x50u);
}
// 36ED4: using guessed type int sub_36ED4();
// 1085E4: using guessed type int dword_1085E4;
// 1085E8: using guessed type int dword_1085E8;
// 1085EC: using guessed type int dword_1085EC;
// 1085F0: using guessed type int dword_1085F0;
// 1085F4: using guessed type int dword_1085F4;
// 1085F8: using guessed type int dword_1085F8;
// 1085FC: using guessed type int dword_1085FC;
// 108600: using guessed type int dword_108600;
// 108604: using guessed type int dword_108604;
// 108608: using guessed type int dword_108608;
// 10860C: using guessed type int dword_10860C;
// 108610: using guessed type int dword_108610;
// 108614: using guessed type int dword_108614;
// 108618: using guessed type int dword_108618;
// 10861C: using guessed type int dword_10861C;
// 108620: using guessed type int dword_108620;

//----- (00037CD4) --------------------------------------------------------
int __fastcall sub_37CD4(int a1, pthread_mutex_t *a2, _DWORD *a3, unsigned int a4)
{
  _DWORD *v7; // r0
  char *v8; // r4
  _DWORD *v9; // r0
  int v10; // r0
  int v11; // r6
  void *count; // r0
  size_t v13; // r7
  void *v14; // r0
  struct __pthread_internal_slist *next; // r0
  _DWORD *v16; // r0
  size_t lock; // r2
  int v19; // r12
  int v20; // r0
  int v21; // r3
  char v22[4096]; // [sp+10h] [bp-1000h] BYREF

  v7 = json_array_get(a3, a4);
  v8 = (char *)json_string_value(v7);
  if ( !v8 )
  {
    V_LOCK();
    logfmt_raw(v22, 0x1000u, 0, "Failed to get extranonce1");
    V_UNLOCK();
    v19 = 249;
    v20 = g_zc;
    LOWORD(v21) = 8508;
    goto LABEL_13;
  }
  v9 = json_array_get(a3, a4 + 1);
  v10 = json_integer_value((int)v9);
  v11 = v10;
  if ( !v10 )
  {
    V_LOCK();
    logfmt_raw(v22, 0x1000u, 0, "Failed to get extranonce2_size");
    V_UNLOCK();
    v19 = 254;
    goto LABEL_12;
  }
  if ( (unsigned int)(v10 - 2) > 0xE )
  {
    V_LOCK();
    logfmt_raw(v22, 0x1000u, 0, "Failed to get valid n2size in parse_extranonce, xn2_size=%d", v11);
    V_UNLOCK();
    v19 = 258;
LABEL_12:
    v20 = g_zc;
    LOWORD(v21) = (unsigned __int16)"stratum_parse_extranonce_dcr";
LABEL_13:
    HIWORD(v21) = (unsigned int)"stratum_parse_extranonce_dcr" >> 16;
    zlog(
      v20,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/frontend/frontend_dcr/frontend_dcr.c",
      164,
      v21,
      28,
      v19,
      100,
      v22);
    return 0;
  }
  pthread_mutex_lock(a2 + 66);
  count = (void *)a2[3].__count;
  if ( count )
  {
    free(count);
    a2[3].__count = 0;
  }
  v13 = strlen(v8) >> 1;
  a2[3].__lock = v13;
  v14 = calloc(1u, v13);
  a2[3].__count = (unsigned int)v14;
  if ( v14 )
  {
    hex2bin((int)v14, (unsigned __int8 *)v8, v13);
    V_LOCK();
    logfmt_raw(v22, 0x1000u, 0, "save xnonce1 into work->xnonce2 to submit");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/frontend/frontend_dcr/frontend_dcr.c",
      164,
      "stratum_parse_extranonce_dcr",
      28,
      274,
      20,
      v22);
    next = a2[65].__list.__next;
    if ( next )
      free(next);
    v16 = calloc(1u, 0x10u);
    a2[65].__spins = (int)v16;
    if ( v16 )
    {
      lock = a2[3].__lock;
      *v16 = lock;
      memset(v16 + 1, 0, lock);
      pthread_mutex_unlock(a2 + 66);
      V_LOCK();
      logfmt_raw(v22, 0x1000u, 0, "Stratum set nonce1 %s, nonce2 size=%d", v8, v11);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/frontend/frontend_dcr/frontend_dcr.c",
        164,
        "stratum_parse_extranonce_dcr",
        28,
        283,
        20,
        v22);
      return 1;
    }
    else
    {
      printf("invalid pointer(%s)!\n", "work->private");
      return 0;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v22, 0x1000u, 0, "Failed to alloc xnonce1");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/frontend/frontend_dcr/frontend_dcr.c",
      164,
      "stratum_parse_extranonce_dcr",
      28,
      267,
      100,
      v22);
    pthread_mutex_unlock(a2 + 66);
    return 0;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0003800C) --------------------------------------------------------
bool __fastcall sub_3800C(int a1, pthread_mutex_t *a2, _DWORD *a3)
{
  _DWORD *v5; // r0
  _DWORD *v6; // r5
  _BOOL4 v7; // r4
  _DWORD *v9; // r0
  const char *v10; // r7
  _DWORD *v11; // r0
  char *v12; // r8
  _DWORD *v13; // r0
  char *v14; // r9
  _DWORD *v15; // r0
  _DWORD *v16; // r0
  char *v17; // r11
  _DWORD *v18; // r0
  const char *v19; // r10
  _DWORD *v20; // r0
  bool v21; // r4
  const char *kind; // r0
  size_t v23; // r0
  int owner; // r3
  int count; // r1
  size_t v26; // r2
  int v27; // r2
  int i; // r7
  char *v29; // r5
  void *v30; // r10
  unsigned __int8 *v31; // r7
  unsigned __int8 *v32; // r3
  unsigned __int8 *v33; // r1
  bool v34; // cf
  unsigned int v35; // t1
  bool v36; // cc
  _BOOL4 v37; // r2
  int v38; // t1
  _BOOL4 v39; // r2
  int v40; // r2
  void *v41; // r8
  void *v42; // r0
  void *v43; // r9
  unsigned int *v44; // r2
  int *v45; // r1
  unsigned int v46; // t1
  unsigned int v47; // r10
  _DWORD *v48; // r0
  unsigned __int8 *v49; // r4
  void *v50; // r0
  int v51; // r1
  int v52; // lr
  int v53; // [sp+14h] [bp-1040h]
  const char *v54; // [sp+18h] [bp-103Ch]
  unsigned int v55; // [sp+18h] [bp-103Ch]
  char *s; // [sp+1Ch] [bp-1038h]
  _BOOL4 v57; // [sp+20h] [bp-1034h]
  pthread_mutex_t *mutex; // [sp+28h] [bp-102Ch]
  void *ptr; // [sp+2Ch] [bp-1028h]
  char *ptra; // [sp+2Ch] [bp-1028h]
  size_t n; // [sp+30h] [bp-1024h]
  size_t v62; // [sp+34h] [bp-1020h]
  size_t nmemb; // [sp+38h] [bp-101Ch]
  int v64; // [sp+3Ch] [bp-1018h]
  int v65; // [sp+4Ch] [bp-1008h] BYREF
  char v66[4100]; // [sp+50h] [bp-1004h] BYREF

  v5 = json_array_get(a3, 4u);
  v6 = v5;
  if ( !v5 || *v5 != 1 )
    return 0;
  v53 = (int)json_array_size(v5);
  v9 = json_array_get(a3, 0);
  v10 = (const char *)json_string_value(v9);
  v11 = json_array_get(a3, 1u);
  v12 = (char *)json_string_value(v11);
  v13 = json_array_get(a3, 2u);
  v14 = (char *)json_string_value(v13);
  v15 = json_array_get(a3, 3u);
  s = (char *)json_string_value(v15);
  v16 = json_array_get(a3, 5u);
  v17 = (char *)json_string_value(v16);
  v18 = json_array_get(a3, 6u);
  v19 = (const char *)json_string_value(v18);
  v20 = json_array_get(a3, 7u);
  v54 = (const char *)json_string_value(v20);
  if ( json_array_get(a3, 8u) )
  {
    v21 = *json_array_get(a3, 8u) == 5;
    v57 = v21;
  }
  else
  {
    v21 = 0;
    v57 = 0;
  }
  if ( valid_ascii(v10) && valid_hex(v12) && valid_hex(v14) && valid_hex(v17) && valid_hex(v19) && valid_hex(v54) )
  {
    if ( a2 == (pthread_mutex_t *)-448 )
      return 0;
    kind = (const char *)a2[65].__kind;
    if ( kind && !strcmp(kind, v10) )
    {
      V_LOCK();
      logfmt_raw(v66, 0x1000u, 0, "Stratum notify: new job's job_id doesnot change, %s, %s", a2[65].__kind, v10);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/frontend/frontend_dcr/frontend_dcr.c",
        164,
        "stratum_notify_dcr",
        18,
        110,
        80,
        v66);
    }
    if ( strlen(v10) > 0x1F )
    {
      V_LOCK();
      v23 = strlen(v10);
      logfmt_raw(v66, 0x1000u, 0, "Stratum notify: job_id len = %s, len %d >= 32", v10, v23);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/frontend/frontend_dcr/frontend_dcr.c",
        164,
        "stratum_notify_dcr",
        18,
        113,
        80,
        v66);
    }
    mutex = a2 + 66;
    pthread_mutex_lock(a2 + 66);
    ptr = (void *)a2[65].__kind;
    a2[65].__kind = (int)_strdup(v10);
    if ( ptr )
      free(ptr);
    snprintf(&a2[3].__size[20], 0x41u, "%s", v12);
    ptra = (char *)(strlen(v12) >> 1);
    nmemb = strlen(v17) >> 1;
    n = strlen(v14) >> 1;
    v62 = strlen(s) >> 1;
    snprintf(&a2[13].__size[12], 9u, "%s", v17);
    snprintf((char *)&a2[14], 9u, "%s", v19);
    snprintf(&a2[14].__size[12], 9u, "%s", v54);
    strcpy(&a2[64].__size[12], v54);
    owner = a2[3].__owner;
    count = a2[13].__count;
    v26 = n + a2[3].__lock;
    a2[18].__size[4] = v21;
    a2[13].__lock = v26;
    v55 = v62 + owner + v26;
    a2[12].__lock = v55;
    if ( count > 0 )
    {
      v27 = a2[13].__owner;
      for ( i = 0; i < count; ++i )
      {
        if ( *(_DWORD *)(v27 + 4 * i) )
        {
          free(*(void **)(v27 + 4 * i));
          v27 = a2[13].__owner;
          count = a2[13].__count;
          *(_DWORD *)(v27 + 4 * i) = 0;
        }
      }
    }
    if ( v53 )
    {
      a2[13].__owner = (int)realloc((void *)a2[13].__owner, 4 * v53);
      if ( v53 > 0 )
      {
        v47 = 0;
        while ( 1 )
        {
          v48 = json_array_get(v6, v47);
          v49 = (unsigned __int8 *)json_string_value(v48);
          v65 = a2[13].__owner;
          v64 = 4 * v47;
          v50 = malloc(0x20u);
          *(_DWORD *)(v65 + 4 * v47) = v50;
          if ( !v50 )
          {
            V_LOCK();
            logfmt_raw(v66, 0x1000u, 0, "Failed to malloc pool swork merkle_bin");
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godmine"
              "r-origin_godminer-new/frontend/frontend_dcr/frontend_dcr.c",
              164,
              "stratum_notify_dcr",
              18,
              144,
              100,
              v66);
          }
          if ( opt_protocol )
          {
            V_LOCK();
            logfmt_raw(v66, 0x1000u, 0, "merkle %d: %s", v47, v49);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godmine"
              "r-origin_godminer-new/frontend/frontend_dcr/frontend_dcr.c",
              164,
              "stratum_notify_dcr",
              18,
              146,
              20,
              v66);
          }
          ++v47;
          if ( !hex2bin(*(_DWORD *)(a2[13].__owner + v64), v49, 32) )
            break;
          if ( v53 == v47 )
            goto LABEL_29;
        }
        v7 = 0;
        V_LOCK();
        logfmt_raw(v66, 0x1000u, 0, "Failed to convert merkle to merkle_bin in parse_notify");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/frontend/frontend_dcr/frontend_dcr.c",
          164,
          "stratum_notify_dcr",
          18,
          151,
          100,
          v66);
        pthread_mutex_unlock(mutex);
        return v7;
      }
    }
LABEL_29:
    a2[13].__count = v53;
    if ( v57 )
      *((_QWORD *)&a2[12].__align + 2) = 0;
    v29 = (char *)calloc((size_t)ptra, 1u);
    v7 = hex2bin((int)v29, (unsigned __int8 *)v12, (int)ptra);
    if ( v7 )
    {
      v30 = calloc(nmemb, 1u);
      if ( hex2bin((int)v30, (unsigned __int8 *)v17, nmemb) )
      {
        v31 = (unsigned __int8 *)calloc(n, 1u);
        if ( hex2bin((int)v31, (unsigned __int8 *)v14, n) )
        {
          v32 = v31 + 32;
          v33 = v31 + 160;
          v34 = v31[32] == 255;
          if ( v31[32] != 255 )
            v34 = v32 >= v33;
          if ( !v34 )
          {
            do
            {
              v35 = *++v32;
              v36 = v35 > 0xFF;
              if ( v35 != 255 )
                v36 = v33 > v32;
            }
            while ( v36 );
          }
          v37 = *v32 == 255;
          if ( v32 >= v33 )
            v37 = 0;
          if ( v37 )
          {
            do
            {
              v38 = *++v32;
              v39 = v38 == 255;
              if ( v33 <= v32 )
                v39 = 0;
            }
            while ( v39 );
          }
          if ( *(v32 - 1) == 255 && *(v32 - 2) == 255 )
          {
            v51 = v32[1];
            v40 = (unsigned __int16)(v32[2] + (v32[3] << 8));
            if ( v51 == 3 )
            {
              v40 += v32[4] << 16;
            }
            else if ( v51 == 4 )
            {
              v40 += (v32[4] + (v32[5] << 8)) << 16;
            }
          }
          else
          {
            v40 = 0;
          }
          a2[68].__count = v40;
          v41 = calloc(v62, 1u);
          v7 = hex2bin((int)v41, (unsigned __int8 *)s, v62);
          if ( v7 )
          {
            v42 = (void *)a2[12].__count;
            if ( v42 )
              free(v42);
            if ( (v55 & 3) != 0 )
              v55 = (v55 & 0xFFFFFFFC) + 4;
            v43 = calloc(v55, 1u);
            a2[12].__count = (unsigned int)v43;
            if ( !v43 )
            {
              V_LOCK();
              logfmt_raw(v66, 0x1000u, 0, "Failed to calloc pool coinbase in parse_notify");
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godmi"
                "ner-origin_godminer-new/frontend/frontend_dcr/frontend_dcr.c",
                164,
                "stratum_notify_dcr",
                18,
                195,
                100,
                v66);
            }
            v44 = (unsigned int *)(v29 - 4);
            v45 = &v65;
            do
            {
              v46 = v44[1];
              ++v44;
              v45[1] = bswap32(v46);
              ++v45;
            }
            while ( v29 + 28 != (char *)v44 );
            memcpy((void *)a2[12].__count, v31, n);
            memcpy(&a2[19], v30, nmemb);
            memcpy((char *)&a2[19] + nmemb, v66, (size_t)ptra);
            memcpy(&ptra[nmemb + (_DWORD)(a2 + 19)], v31, n);
            memcpy(&a2[25], (const void *)a2[3].__count, a2[3].__lock);
            memcpy(&a2[26].__align + 2, v41, v62);
            *((_QWORD *)&a2[18].__align + 2) = a2->__lock;
            pthread_mutex_unlock(mutex);
            if ( !v29 )
              goto LABEL_60;
            goto LABEL_58;
          }
          V_LOCK();
          logfmt_raw(v66, 0x1000u, 0, "Failed to convert cb2 to cb2_bin in parse_notify");
          V_UNLOCK();
          v52 = 188;
        }
        else
        {
          V_LOCK();
          v41 = 0;
          logfmt_raw(v66, 0x1000u, 0, "Failed to convert cb1 to cb1_bin in parse_notify");
          V_UNLOCK();
          v52 = 180;
        }
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/frontend/frontend_dcr/frontend_dcr.c",
          164,
          "stratum_notify_dcr",
          18,
          v52,
          100,
          v66);
      }
      else
      {
        V_LOCK();
        v41 = 0;
        logfmt_raw(v66, 0x1000u, 0, "Failed to convert block_version to block_version_bin in parse_notify");
        V_UNLOCK();
        v31 = 0;
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/frontend/frontend_dcr/frontend_dcr.c",
          164,
          "stratum_notify_dcr",
          18,
          172,
          100,
          v66);
      }
      pthread_mutex_unlock(mutex);
      if ( !v29 )
      {
        v7 = 0;
LABEL_59:
        if ( !v30 )
        {
LABEL_61:
          if ( v31 )
            free(v31);
          if ( v41 )
            free(v41);
          return v7;
        }
LABEL_60:
        free(v30);
        goto LABEL_61;
      }
      v7 = 0;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v66, 0x1000u, 0, "Failed to convert prev_bloc_hash to prev_bloc_hash_bin in parse_notify");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/frontend/frontend_dcr/frontend_dcr.c",
        164,
        "stratum_notify_dcr",
        18,
        164,
        100,
        v66);
      pthread_mutex_unlock(mutex);
      if ( !v29 )
        return v7;
      v41 = 0;
      v31 = 0;
      v30 = 0;
    }
LABEL_58:
    free(v29);
    goto LABEL_59;
  }
  V_LOCK();
  logfmt_raw(v66, 0x1000u, 0, "Stratum notify: invalid parameters");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/frontend/frontend_dcr/frontend_dcr.c",
    164,
    "stratum_notify_dcr",
    18,
    104,
    100,
    v66);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 107A64: using guessed type char opt_protocol;
// 11A7AC: using guessed type int g_zc;

//----- (00038B84) --------------------------------------------------------
int __fastcall sub_38B84(int a1, int a2, char *a3)
{
  int *v3; // r9
  int v6; // r5
  const char *v7; // r11
  const char *v8; // r10
  int v9; // r12
  char s[4]; // [sp+18h] [bp-2Ch] BYREF
  int v12; // [sp+1Ch] [bp-28h]
  char v13; // [sp+20h] [bp-24h]
  _DWORD v14[6]; // [sp+24h] [bp-20h] BYREF
  char v15; // [sp+3Ch] [bp-8h]

  v3 = *(int **)(a1 + 1132);
  if ( v3 )
  {
    v12 = 0;
    *(_DWORD *)s = 0;
    v6 = a1 + 1088;
    v13 = 0;
    memset(v14, 0, sizeof(v14));
    v15 = 0;
    bin2hex((int)s, a1 + 1072, 4);
    bin2hex((int)v14, (int)(v3 + 1), *v3);
    v7 = *(const char **)(a2 + 12);
    v8 = *(const char **)(v6 + 36);
    v9 = rand();
    snprintf(
      a3,
      0x400u,
      "{\"params\": [\"%s\", \"%s\", \"%s\", \"%s\", \"%s\"], \"id\": %d, \"method\": \"mining.submit\"}",
      v7,
      v8,
      (const char *)v14,
      (const char *)(v6 + 12),
      s,
      v9 % 3 + 10);
    return 0;
  }
  else
  {
    printf("invalid pointer(%s)!\n", "private");
    return 3;
  }
}

//----- (00038C84) --------------------------------------------------------
void *frontend_runtime_dcr()
{
  __int64 v0; // r2
  void *v1; // r0

  dword_108634 = (int)stratum_connect;
  dword_108638 = (int)stratum_disconnect;
  dword_10863C = (int)stratum_recv_line;
  dword_108640 = (int)stratum_send_line;
  dword_108644 = (int)stratum_login_base;
  dword_108648 = (int)stratum_handle_method_base;
  dword_10864C = (int)stratum_handle_response_base;
  dword_108650 = (int)sub_38B84;
  dword_108654 = (int)sub_38B1C;
  dword_108658 = (int)stratum_subscribe_base;
  dword_10865C = (int)stratum_authorize_base;
  dword_108660 = (int)sub_3800C;
  LODWORD(v0) = diff_to_target_dcr;
  HIDWORD(v0) = target_to_double_diff_dcr;
  dword_108664 = (int)sub_37CD4;
  dword_108668 = (int)stratum_set_diff_or_target_base;
  *(_QWORD *)&dword_108670 = v0;
  dword_10866C = (int)target_to_diff_dcr;
  v1 = calloc(1u, 0x50u);
  return memcpy(v1, &dword_108634, 0x50u);
}
// 38B1C: using guessed type int sub_38B1C();
// 108634: using guessed type int dword_108634;
// 108638: using guessed type int dword_108638;
// 10863C: using guessed type int dword_10863C;
// 108640: using guessed type int dword_108640;
// 108644: using guessed type int dword_108644;
// 108648: using guessed type int dword_108648;
// 10864C: using guessed type int dword_10864C;
// 108650: using guessed type int dword_108650;
// 108654: using guessed type int dword_108654;
// 108658: using guessed type int dword_108658;
// 10865C: using guessed type int dword_10865C;
// 108660: using guessed type int dword_108660;
// 108664: using guessed type int dword_108664;
// 108668: using guessed type int dword_108668;
// 10866C: using guessed type int dword_10866C;
// 108670: using guessed type int dword_108670;

//----- (00038D74) --------------------------------------------------------
int __fastcall sub_38D74(int a1, int a2)
{
  const char *v2; // r0
  const char *v3; // r1

  v2 = *(const char **)(a1 + 1124);
  if ( !v2 )
    return 2;
  v3 = *(const char **)(a2 + 1572);
  if ( !v3 )
    return 2;
  if ( !strcmp(v2, v3) )
    return 0;
  return 2;
}

//----- (00038DAC) --------------------------------------------------------
int __fastcall stratum_handle_response_hns(int a1, int a2, int a3)
{
  double *v4; // r0
  double *v5; // r4
  _DWORD *v6; // r5
  _DWORD *v7; // r7
  int v8; // r6
  _BYTE *v9; // r0
  _BOOL4 v10; // r9
  int v11; // r0
  char *v12; // r2
  _DWORD *v13; // r0
  unsigned int *v14; // r3
  unsigned int v15; // r2
  unsigned int v16; // r2
  bool v18; // zf
  char *v19; // r2
  char v20[92]; // [sp+14h] [bp-1100h] BYREF
  _BYTE v21[160]; // [sp+70h] [bp-10A4h] BYREF
  char v22[4100]; // [sp+110h] [bp-1004h] BYREF

  v4 = json_loads(a2, 0, v20);
  v5 = v4;
  if ( !v4 )
  {
    V_LOCK();
    logfmt_raw(v22, 0x1000u, 0, "JSON decode failed(%d): %s", *(_DWORD *)v20, v21);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/frontend/frontend_hns/frontend_hns.c",
      164,
      "stratum_handle_response_hns",
      27,
      377,
      40,
      v22);
    return 0;
  }
  v6 = (_DWORD *)json_object_get(v4, "result");
  v7 = (_DWORD *)json_object_get(v5, "error");
  v8 = json_object_get(v5, "id");
  if ( !v6 || *v6 == 7 || v6 == json_false() )
    goto LABEL_15;
  v9 = json_string_value(v6);
  v10 = (_BOOL4)v9;
  if ( !v9 )
    goto LABEL_16;
  if ( *v9 == 111 && v9[1] == 107 )
  {
    v11 = (unsigned __int8)v9[2];
    v10 = (_BOOL4)v7;
    if ( v7 )
      v10 = 1;
    if ( v11 )
      v10 = 0;
    if ( v10 )
      v10 = *v7 == 7;
  }
  else
  {
LABEL_15:
    v10 = 0;
  }
LABEL_16:
  if ( v6 == json_true() )
  {
    if ( v7 )
    {
      if ( *v7 == 7 )
        v10 = 1;
      if ( v8 )
        goto LABEL_18;
      goto LABEL_43;
    }
    v10 = 1;
  }
  if ( v8 )
  {
LABEL_18:
    v8 = *(unsigned __int8 *)(a3 + 1648);
    if ( *(_BYTE *)(a3 + 1648) )
    {
      v18 = v6 == 0;
      if ( !v6 )
        v18 = v7 == 0;
      if ( v18 )
      {
        v8 = 0;
      }
      else
      {
        if ( v7 )
          v19 = (char *)json_string_value(v7);
        else
          v19 = 0;
        share_result(v10, 0, v19, (double *)a3);
      }
    }
    else if ( v6 )
    {
      if ( v7 )
      {
        v13 = json_array_get(v7, 1u);
        v12 = (char *)json_string_value(v13);
      }
      else
      {
        v12 = 0;
      }
      v8 = 1;
      share_result(v10, 0, v12, (double *)a3);
    }
    goto LABEL_24;
  }
LABEL_43:
  V_LOCK();
  logfmt_raw(v22, 0x1000u, v8, "%s json id is null!", "stratum_handle_response_hns");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/frontend/frontend_hns/frontend_hns.c",
    164,
    "stratum_handle_response_hns",
    27,
    401,
    20,
    v22);
LABEL_24:
  if ( *((_DWORD *)v5 + 1) != -1 )
  {
    v14 = (unsigned int *)v5 + 1;
    __dmb(0xBu);
    do
    {
      v15 = __ldrex(v14);
      v16 = v15 - 1;
    }
    while ( __strex(v16, v14) );
    if ( !v16 )
      json_delete(v5);
  }
  return v8;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00039074) --------------------------------------------------------
int __fastcall sub_39074(int a1, pthread_mutex_t *a2, _DWORD *a3, unsigned int a4)
{
  _DWORD *v7; // r0
  char *v8; // r4
  _DWORD *v9; // r0
  size_t v10; // r0
  size_t v11; // r6
  void *count; // r0
  size_t v13; // r7
  void *v14; // r0
  struct __pthread_internal_slist *next; // r0
  _DWORD *v16; // r0
  int v18; // r2
  int v19; // r0
  int v20; // r1
  char v21[4100]; // [sp+10h] [bp-1004h] BYREF

  v7 = json_array_get(a3, a4);
  v8 = (char *)json_string_value(v7);
  if ( !v8 )
  {
    V_LOCK();
    logfmt_raw(v21, 0x1000u, 0, "Failed to get extranonce1");
    V_UNLOCK();
    v18 = 327;
    v19 = g_zc;
    LOWORD(v20) = 9068;
    goto LABEL_13;
  }
  v9 = json_array_get(a3, a4 + 1);
  v10 = json_integer_value((int)v9);
  v11 = v10;
  if ( !v10 )
  {
    V_LOCK();
    logfmt_raw(v21, 0x1000u, 0, "Failed to get extranonce2_size");
    V_UNLOCK();
    v18 = 332;
    goto LABEL_12;
  }
  if ( v10 - 2 > 0x16 )
  {
    V_LOCK();
    logfmt_raw(v21, 0x1000u, 0, "Failed to get valid n2size in parse_extranonce, xn2_size=%d", v11);
    V_UNLOCK();
    v18 = 336;
LABEL_12:
    v19 = g_zc;
    LOWORD(v20) = (unsigned __int16)"/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp"
                                    "/release/build/godminer-origin_godminer-new/frontend/frontend_hns/frontend_hns.c";
LABEL_13:
    HIWORD(v20) = (unsigned int)"/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/rel"
                                "ease/build/godminer-origin_godminer-new/frontend/frontend_hns/frontend_hns.c" >> 16;
    zlog(v19, v20, 164, "stratum_parse_extranonce_hns", 28, v18, 100, v21);
    return 0;
  }
  pthread_mutex_lock(a2 + 66);
  count = (void *)a2[3].__count;
  if ( count )
  {
    free(count);
    a2[3].__count = 0;
  }
  v13 = strlen(v8) >> 1;
  a2[3].__lock = v13;
  v14 = calloc(1u, v13);
  a2[3].__count = (unsigned int)v14;
  if ( v14 )
  {
    hex2bin((int)v14, (unsigned __int8 *)v8, v13);
    next = a2[65].__list.__next;
    a2[3].__owner = v11;
    if ( next )
      free(next);
    v16 = calloc(1u, 0x1Cu);
    a2[65].__spins = (int)v16;
    if ( v16 )
    {
      *v16 = v11;
      memset(v16 + 1, 0, v11);
      pthread_mutex_unlock(a2 + 66);
      V_LOCK();
      logfmt_raw(v21, 0x1000u, 0, "Stratum set nonce1 %s, nonce2 size=%d", v8, v11);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/frontend/frontend_hns/frontend_hns.c",
        164,
        "stratum_parse_extranonce_hns",
        28,
        361,
        80,
        v21);
      return 1;
    }
    else
    {
      printf("invalid pointer(%s)!\n", "work->private");
      return 0;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v21, 0x1000u, 0, "Failed to alloc xnonce1");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/frontend/frontend_hns/frontend_hns.c",
      164,
      "stratum_parse_extranonce_hns",
      28,
      345,
      100,
      v21);
    pthread_mutex_unlock(a2 + 66);
    return 0;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00039364) --------------------------------------------------------
int __fastcall sub_39364(int a1, int a2, char *a3)
{
  int v3; // r9
  _DWORD v8[2]; // [sp+1Ch] [bp-80h] BYREF
  char v9; // [sp+24h] [bp-78h]
  _DWORD v10[2]; // [sp+28h] [bp-74h] BYREF
  char v11; // [sp+30h] [bp-6Ch]
  _BYTE v12[32]; // [sp+34h] [bp-68h] BYREF
  char s[72]; // [sp+54h] [bp-48h] BYREF

  v3 = *(_DWORD *)(a1 + 1132);
  if ( v3 )
  {
    v8[0] = 0;
    v10[0] = 0;
    v8[1] = 0;
    v9 = 0;
    v10[1] = 0;
    v11 = 0;
    memset(s, 0, 0x41u);
    memset(v12, 0, sizeof(v12));
    bin2hex((int)v8, a1 + 1072, 4);
    bin2hex((int)v10, v3 + 4, 4);
    bin2hex((int)s, (int)v12, 32);
    snprintf(
      a3,
      0x400u,
      "{\"params\": [\"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\"], \"id\": \"%d\", \"method\": \"mining.submit\"}",
      *(const char **)(a2 + 12),
      *(const char **)(a1 + 1124),
      (const char *)v10,
      (const char *)(a1 + 1100),
      (const char *)v8,
      s,
      3);
    return 0;
  }
  else
  {
    printf("invalid pointer(%s)!\n", "private");
    return 3;
  }
}

//----- (00039468) --------------------------------------------------------
bool __fastcall sub_39468(int a1, pthread_mutex_t *a2, _DWORD *a3)
{
  _BOOL4 v4; // r4
  _DWORD *v7; // r0
  const char *v8; // r5
  _DWORD *v9; // r0
  char *v10; // r6
  _DWORD *v11; // r0
  char *v12; // r8
  _DWORD *v13; // r0
  char *v14; // r7
  _DWORD *v15; // r0
  char *v16; // r9
  _DWORD *v17; // r0
  _DWORD *v18; // r0
  char *v19; // r10
  _DWORD *v20; // r0
  _DWORD *v21; // r0
  const char *kind; // r0
  size_t v23; // r0
  void *v24; // r4
  size_t v25; // r4
  size_t v26; // r0
  size_t v27; // r0
  size_t v28; // r4
  unsigned __int8 *v29; // r2
  char *v30; // r1
  bool v31; // cc
  _BOOL4 v32; // r0
  int v33; // r3
  int v34; // r3
  pthread_mutex_t *v35; // r10
  size_t lock; // r2
  const void *count; // r1
  size_t v38; // r0
  size_t v39; // r7
  unsigned __int8 *v40; // r0
  _BYTE *i; // r2
  char v42; // t1
  size_t v43; // r3
  char *v44; // r0
  _BYTE *j; // r2
  char v46; // t1
  size_t v47; // r3
  char *v48; // r0
  _BYTE *k; // r2
  char v50; // t1
  size_t v51; // r3
  _BYTE *v52; // r1
  unsigned __int64 *v53; // r2
  char v54; // t1
  int *v55; // r1
  char *v56; // r2
  char v57; // t1
  char *v58; // r1
  signed int v59; // r2
  char v60; // t1
  int v61; // r0
  size_t v62; // r7
  char *v63; // r1
  _BYTE *m; // r3
  char v65; // t1
  size_t v66; // r7
  _BYTE *v67; // r2
  unsigned __int64 *v68; // r3
  char v69; // t1
  size_t v70; // r3
  size_t v71; // r7
  size_t v72; // r7
  unsigned __int64 *v73; // r9
  int v74; // r0
  int v75; // r1
  int v76; // [sp+4h] [bp-10A0h]
  char *src; // [sp+10h] [bp-1094h]
  char *v78; // [sp+14h] [bp-1090h]
  char *s; // [sp+18h] [bp-108Ch]
  char *sa; // [sp+18h] [bp-108Ch]
  char *v81; // [sp+24h] [bp-1080h]
  char *v82; // [sp+28h] [bp-107Ch]
  unsigned __int8 *v83; // [sp+2Ch] [bp-1078h]
  void *v84; // [sp+30h] [bp-1074h]
  signed int v85; // [sp+34h] [bp-1070h]
  signed int v86; // [sp+38h] [bp-106Ch]
  signed int v87; // [sp+3Ch] [bp-1068h]
  signed int v88; // [sp+40h] [bp-1064h]
  void *v89; // [sp+44h] [bp-1060h]
  signed int v90; // [sp+48h] [bp-105Ch]
  size_t n; // [sp+4Ch] [bp-1058h]
  size_t nmemb; // [sp+50h] [bp-1054h]
  void *ptr; // [sp+58h] [bp-104Ch]
  _BYTE v94[20]; // [sp+6Ch] [bp-1038h] BYREF
  unsigned __int64 dest[4]; // [sp+80h] [bp-1024h] BYREF
  _DWORD v96[1025]; // [sp+A0h] [bp-1004h] BYREF

  if ( !a3 || *a3 != 1 )
    return 0;
  v7 = json_array_get(a3, 0);
  v8 = (const char *)json_string_value(v7);
  v9 = json_array_get(a3, 1u);
  v10 = (char *)json_string_value(v9);
  v11 = json_array_get(a3, 2u);
  v12 = (char *)json_string_value(v11);
  v13 = json_array_get(a3, 3u);
  v14 = (char *)json_string_value(v13);
  v15 = json_array_get(a3, 4u);
  v16 = (char *)json_string_value(v15);
  v17 = json_array_get(a3, 5u);
  s = (char *)json_string_value(v17);
  v18 = json_array_get(a3, 6u);
  v19 = (char *)json_string_value(v18);
  v20 = json_array_get(a3, 7u);
  v78 = (char *)json_string_value(v20);
  v21 = json_array_get(a3, 8u);
  src = (char *)json_string_value(v21);
  if ( valid_ascii(v8)
    && valid_hex(v10)
    && valid_hex(v14)
    && valid_hex(v12)
    && valid_hex(v16)
    && valid_hex(s)
    && valid_hex(v19)
    && valid_hex(v78)
    && valid_hex(src) )
  {
    if ( a2 == (pthread_mutex_t *)-448 )
      return 0;
    kind = (const char *)a2[65].__kind;
    if ( kind && !strcmp(kind, v8) )
    {
      V_LOCK();
      logfmt_raw((char *)v96, 0x1000u, 0, "Stratum notify: new job's job_id doesnot change, %s, %s", a2[65].__kind, v8);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/frontend/frontend_hns/frontend_hns.c",
        164,
        "stratum_notify_hns",
        18,
        140,
        80,
        v96);
    }
    if ( strlen(v8) > 0x1F )
    {
      V_LOCK();
      v23 = strlen(v8);
      logfmt_raw((char *)v96, 0x1000u, 0, "Stratum notify: job_id len = %s, len %d >= 32", v8, v23);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/frontend/frontend_hns/frontend_hns.c",
        164,
        "stratum_notify_hns",
        18,
        143,
        80,
        v96);
    }
    pthread_mutex_lock(a2 + 66);
    v24 = (void *)a2[65].__kind;
    a2[65].__kind = (int)_strdup(v8);
    if ( v24 )
      free(v24);
    snprintf(&a2[3].__size[20], 0x41u, "%s", v10);
    v85 = strlen(v10) >> 1;
    v86 = strlen(v12) >> 1;
    v87 = strlen(v14) >> 1;
    v90 = strlen(v16) >> 1;
    v88 = strlen(s) >> 1;
    v25 = strlen(v19);
    nmemb = strlen(src) >> 1;
    n = v25 >> 1;
    snprintf(&a2[13].__size[12], v25 + 1, "%s", v19);
    v26 = strlen(v78);
    snprintf((char *)&a2[14], v26 + 1, "%s", v78);
    v27 = strlen(src);
    snprintf(&a2[14].__size[12], v27 + 1, "%s", src);
    strcpy(&a2[64].__size[12], src);
    a2[18].__size[4] = 1;
    v28 = strlen(v78);
    ptr = calloc(v28, 1u);
    v4 = hex2bin((int)ptr, (unsigned __int8 *)v78, v28 >> 1);
    if ( v4 )
    {
      v89 = calloc(nmemb, 1u);
      v4 = hex2bin((int)v89, (unsigned __int8 *)src, nmemb);
      if ( v4 )
      {
        v84 = calloc(n, 1u);
        v4 = hex2bin((int)v84, (unsigned __int8 *)v19, n);
        if ( v4 )
        {
          v83 = (unsigned __int8 *)calloc(v86, 1u);
          v4 = hex2bin((int)v83, (unsigned __int8 *)v12, v86);
          if ( v4 )
          {
            v29 = v83 + 32;
            v30 = (char *)(v83 + 160);
            while ( 1 )
            {
              v31 = 0;
              if ( *v29 != 255 )
                v31 = v30 > (char *)v29;
              if ( !v31 )
                break;
              ++v29;
            }
            while ( 1 )
            {
              v32 = *v29 == 255;
              if ( v30 <= (char *)v29 )
                v32 = 0;
              if ( !v32 )
                break;
              ++v29;
            }
            v33 = 0;
            if ( *(v29 - 1) == 255 && *(v29 - 2) == 255 )
            {
              v75 = v29[1];
              v33 = (unsigned __int16)(v29[2] + (v29[3] << 8));
              if ( v75 == 3 )
              {
                v33 += v29[4] << 16;
              }
              else if ( v75 == 4 )
              {
                v33 += (v29[4] + (v29[5] << 8)) << 16;
              }
            }
            a2[68].__count = v33;
            v82 = (char *)calloc(v87, 1u);
            v4 = hex2bin((int)v82, (unsigned __int8 *)v14, v87);
            if ( v4 )
            {
              v81 = (char *)calloc(v88, 1u);
              v4 = hex2bin((int)v81, (unsigned __int8 *)s, v88);
              if ( v4 )
              {
                sa = (char *)calloc(v90, 1u);
                v4 = hex2bin((int)sa, (unsigned __int8 *)v16, v90);
                if ( v4 )
                {
                  v73 = (unsigned __int64 *)calloc(v85, 1u);
                  v4 = hex2bin((int)v73, (unsigned __int8 *)v10, v85);
                  if ( v4 )
                  {
                    v34 = v73 == 0;
                    if ( !sa )
                      v34 = 1;
                    if ( v34 )
                    {
                      V_LOCK();
                      logfmt_raw((char *)v96, 0x1000u, 0, "%s input value error", "hns_padding");
                      V_UNLOCK();
                      zlog(
                        g_zc,
                        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/bui"
                        "ld/godminer-origin_godminer-new/frontend/frontend_hns/frontend_hns.c",
                        164,
                        "hns_padding",
                        11,
                        82,
                        100,
                        v96);
                    }
                    else
                    {
                      do
                      {
                        v94[v34] = *((_BYTE *)v73 + v34) ^ sa[v34];
                        ++v34;
                      }
                      while ( v34 != 20 );
                    }
                    if ( memcmp(v73, &dword_108684, 0x20u) )
                    {
                      dword_108684 = *(_DWORD *)v73;
                      memset(dest, 0, sizeof(dest));
                      memset(&unk_1086A4, 0, 0x20u);
                      memset(v96, 0, 0xF0u);
                      hs_blake2b_init(v96, 32);
                      hs_blake2b_update((int)v96, v73, 0x20u);
                      hs_blake2b_update((int)v96, dest, 0x20u);
                      hs_blake2b_final((int)v96, &unk_1086A4, 0x20u);
                    }
                    v35 = a2 + 19;
                    lock = a2[3].__lock;
                    count = (const void *)a2[3].__count;
                    memset(dest, 0, 22);
                    memcpy(dest, count, lock);
                    memset(&a2[19], 0, 0x100u);
                    v38 = strlen(v78);
                    memcpy(&a2[19], ptr, v38 >> 1);
                    v39 = strlen(v78) >> 1;
                    memcpy((char *)&a2[19] + v39, v84, n);
                    v40 = &v83[v86];
                    for ( i = (char *)&a2[19] + v39 + n; v86 > i - ((char *)&a2[19] + v39 + n); ++i )
                    {
                      v42 = *--v40;
                      *i = v42;
                    }
                    v43 = v39 + n + v86;
                    v44 = &v82[v87];
                    for ( j = (char *)v35 + v43; j - ((char *)v35 + v43) < v87; ++j )
                    {
                      v46 = *--v44;
                      *j = v46;
                    }
                    v47 = v43 + v87;
                    v48 = &v81[v88];
                    for ( k = (char *)v35 + v47; v88 > k - ((char *)v35 + v47); ++k )
                    {
                      v50 = *--v48;
                      *k = v50;
                    }
                    v51 = v47 + v88;
                    v52 = (char *)v35 + v51;
                    v53 = (unsigned __int64 *)((char *)&dest[2] + 6);
                    do
                    {
                      v54 = *((_BYTE *)v53 - 1);
                      v53 = (unsigned __int64 *)((char *)v53 - 1);
                      *v52++ = v54;
                    }
                    while ( v53 != dest );
                    v55 = &dword_1086C4;
                    v56 = &v35->__size[v51 + 21];
                    do
                    {
                      v57 = *((_BYTE *)v55 - 1);
                      v55 = (int *)((char *)v55 - 1);
                      *++v56 = v57;
                    }
                    while ( v55 != (int *)&unk_1086A4 );
                    v58 = &sa[v90];
                    v59 = 0;
                    while ( 1 )
                    {
                      v31 = v90 <= v59;
                      v61 = (int)v35 + v51 + v59++;
                      if ( v31 )
                        break;
                      v60 = *--v58;
                      *(_BYTE *)(v61 + 54) = v60;
                    }
                    v62 = v51 + v90 + 54;
                    v63 = (char *)v73 + v85;
                    for ( m = (char *)v35 + v62; m - ((char *)v35 + v62) < v85; ++m )
                    {
                      v65 = *--v63;
                      *m = v65;
                    }
                    v66 = v62 + v85;
                    v67 = (char *)v35 + v66;
                    v68 = dest;
                    do
                    {
                      v69 = *((_BYTE *)v68 - 1);
                      v68 = (unsigned __int64 *)((char *)v68 - 1);
                      *v67++ = v69;
                    }
                    while ( v94 != (_BYTE *)v68 );
                    v70 = v66 + 20;
                    v71 = v66 + 24;
                    *(int *)((char *)&v35->__lock + v70) = 0;
                    memcpy((char *)v35 + v71, v89, nmemb);
                    v72 = v71 + nmemb;
                    *(int *)((char *)&v35->__lock + v72) = 0;
                    *(_WORD *)&v35->__size[v72 + 4] = 0;
                    *((_QWORD *)&a2[18].__align + 2) = a2->__lock;
                    goto LABEL_71;
                  }
                  V_LOCK();
                  logfmt_raw((char *)v96, 0x1000u, 0, "parse prev_hash failed!");
                  V_UNLOCK();
                  v74 = 229;
                }
                else
                {
                  V_LOCK();
                  v73 = 0;
                  logfmt_raw((char *)v96, 0x1000u, 0, "parse nameroot failed!");
                  V_UNLOCK();
                  v74 = 221;
                }
                zlog(
                  g_zc,
                  "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/god"
                  "miner-origin_godminer-new/frontend/frontend_hns/frontend_hns.c",
                  164,
                  "stratum_notify_hns",
                  18,
                  v74,
                  100,
                  v96);
              }
              else
              {
                V_LOCK();
                sa = 0;
                v73 = 0;
                logfmt_raw((char *)v96, 0x1000u, 0, "parse reserved_root failed!");
                V_UNLOCK();
                zlog(
                  g_zc,
                  "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/god"
                  "miner-origin_godminer-new/frontend/frontend_hns/frontend_hns.c",
                  164,
                  "stratum_notify_hns",
                  18,
                  213,
                  100,
                  v96);
              }
            }
            else
            {
              V_LOCK();
              v81 = 0;
              v73 = 0;
              logfmt_raw((char *)v96, 0x1000u, 0, "parse witness failed!");
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godmi"
                "ner-origin_godminer-new/frontend/frontend_hns/frontend_hns.c",
                164,
                "stratum_notify_hns",
                18,
                205,
                100,
                v96);
              sa = 0;
            }
          }
          else
          {
            V_LOCK();
            v81 = 0;
            v73 = 0;
            logfmt_raw((char *)v96, 0x1000u, 0, "parse merkle failed!");
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godmine"
              "r-origin_godminer-new/frontend/frontend_hns/frontend_hns.c",
              164,
              "stratum_notify_hns",
              18,
              195,
              100,
              v96);
            sa = 0;
            v82 = 0;
          }
        }
        else
        {
          V_LOCK();
          v81 = 0;
          v73 = 0;
          logfmt_raw((char *)v96, 0x1000u, 0, "parse bloc_version failed!");
          V_UNLOCK();
          sa = 0;
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/frontend/frontend_hns/frontend_hns.c",
            164,
            "stratum_notify_hns",
            18,
            187,
            100,
            v96);
          v82 = 0;
          v83 = 0;
        }
LABEL_71:
        pthread_mutex_unlock(a2 + 66);
        V_LOCK();
        logfmt_raw((char *)v96, 0x1000u, 0, "job_id: %s", v8);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/frontend/frontend_hns/frontend_hns.c",
          164,
          "stratum_notify_hns",
          18,
          299,
          20,
          v96);
        V_LOCK();
        logfmt_raw((char *)v96, 0x1000u, 0, "prev_hash: %s", v10);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/frontend/frontend_hns/frontend_hns.c",
          164,
          "stratum_notify_hns",
          18,
          300,
          20,
          v96);
        V_LOCK();
        logfmt_raw((char *)v96, 0x1000u, 0, "nbit: %s", v78);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/frontend/frontend_hns/frontend_hns.c",
          164,
          "stratum_notify_hns",
          18,
          301,
          20,
          v96);
        V_LOCK();
        logfmt_raw((char *)v96, 0x1000u, 0, "ntime: %s", src);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/frontend/frontend_hns/frontend_hns.c",
          164,
          "stratum_notify_hns",
          18,
          302,
          20,
          v96);
        if ( ptr )
          free(ptr);
        if ( v89 )
          free(v89);
        if ( v84 )
          free(v84);
        if ( v83 )
          free(v83);
        if ( v82 )
          free(v82);
        if ( v81 )
          free(v81);
        if ( sa )
          free(sa);
        if ( v73 )
          free(v73);
        return v4;
      }
      V_LOCK();
      v81 = 0;
      logfmt_raw((char *)v96, 0x1000u, 0, "parse ntime failed!");
      V_UNLOCK();
      v76 = 179;
      sa = 0;
      v82 = 0;
    }
    else
    {
      V_LOCK();
      v89 = 0;
      logfmt_raw((char *)v96, 0x1000u, 0, "parse nbits failed!");
      V_UNLOCK();
      v76 = 171;
      v81 = 0;
      sa = 0;
      v82 = 0;
    }
    v73 = 0;
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/frontend/frontend_hns/frontend_hns.c",
      164,
      "stratum_notify_hns",
      18,
      v76,
      100,
      v96);
    v83 = 0;
    v84 = 0;
    goto LABEL_71;
  }
  V_LOCK();
  logfmt_raw((char *)v96, 0x1000u, 0, "Stratum notify: invalid parameters");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/frontend/frontend_hns/frontend_hns.c",
    164,
    "stratum_notify_hns",
    18,
    134,
    100,
    v96);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 108684: using guessed type int dword_108684;
// 1086C4: using guessed type int dword_1086C4;
// 11A7AC: using guessed type int g_zc;

//----- (0003A380) --------------------------------------------------------
void *frontend_runtime_hns()
{
  __int64 v0; // r2
  void *v1; // r0

  dword_1086C4 = (int)stratum_connect;
  dword_1086C8 = (int)stratum_disconnect;
  dword_1086CC = (int)stratum_recv_line;
  dword_1086D0 = (int)stratum_send_line;
  dword_1086D4 = (int)stratum_login_base;
  dword_1086D8 = (int)stratum_handle_method_base;
  dword_1086DC = (int)stratum_handle_response_hns;
  dword_1086E0 = (int)sub_39364;
  dword_1086E4 = (int)sub_38D74;
  dword_1086E8 = (int)stratum_subscribe_base;
  dword_1086EC = (int)stratum_authorize_base;
  dword_1086F0 = (int)sub_39468;
  LODWORD(v0) = diff_to_target_hns;
  HIDWORD(v0) = target_to_double_diff_hns;
  dword_1086F4 = (int)sub_39074;
  dword_1086F8 = (int)stratum_set_diff_or_target_base;
  *(_QWORD *)&dword_108700 = v0;
  dword_1086FC = (int)target_to_diff_word_hns;
  v1 = calloc(1u, 0x50u);
  return memcpy(v1, &dword_1086C4, 0x50u);
}
// 1086C4: using guessed type int dword_1086C4;
// 1086C8: using guessed type int dword_1086C8;
// 1086CC: using guessed type int dword_1086CC;
// 1086D0: using guessed type int dword_1086D0;
// 1086D4: using guessed type int dword_1086D4;
// 1086D8: using guessed type int dword_1086D8;
// 1086DC: using guessed type int dword_1086DC;
// 1086E0: using guessed type int dword_1086E0;
// 1086E4: using guessed type int dword_1086E4;
// 1086E8: using guessed type int dword_1086E8;
// 1086EC: using guessed type int dword_1086EC;
// 1086F0: using guessed type int dword_1086F0;
// 1086F4: using guessed type int dword_1086F4;
// 1086F8: using guessed type int dword_1086F8;
// 1086FC: using guessed type int dword_1086FC;
// 108700: using guessed type int dword_108700;

//----- (0003A470) --------------------------------------------------------
_DWORD *__fastcall set_frontend_runtime_type(int a1, int a2)
{
  _DWORD *v4; // r4

  switch ( a2 )
  {
    case 0:
    case 1:
      v4 = frontend_runtime_ckb();
      goto LABEL_3;
    case 2:
      v4 = frontend_runtime_kda();
      goto LABEL_3;
    case 3:
      v4 = frontend_runtime_hns();
      goto LABEL_3;
    case 4:
      v4 = frontend_runtime_dcr();
      goto LABEL_3;
    case 5:
      v4 = frontend_runtime_dash();
LABEL_3:
      if ( v4 )
      {
        v4[17] = a1;
        if ( dword_108714 )
          free((void *)dword_108714);
        v4[18] = a2;
        dword_108714 = (int)v4;
      }
      break;
    default:
      v4 = 0;
      break;
  }
  return v4;
}
// 3A484: control flows out of bounds to 3A488
// 108714: using guessed type int dword_108714;

//----- (0003A514) --------------------------------------------------------
int frontend_runtime_instance()
{
  int v0; // r4
  char v2[4100]; // [sp+10h] [bp-1004h] BYREF

  v0 = dword_108714;
  if ( !dword_108714 )
  {
    V_LOCK();
    logfmt_raw(v2, 0x1000u, 0, "frontend runtime type not set");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/frontend/frontend_interface.c",
      157,
      "frontend_runtime_instance",
      25,
      50,
      100,
      v2);
  }
  return v0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 108714: using guessed type int dword_108714;
// 11A7AC: using guessed type int g_zc;

//----- (0003A5A4) --------------------------------------------------------
int __fastcall sub_3A5A4(int a1, int a2)
{
  if ( !*(_DWORD *)(a1 + 1124) || !*(_DWORD *)(a2 + 1572) )
    return 2;
  if ( *(_BYTE *)(a2 + 436) )
    return 2;
  return 0;
}

//----- (0003A5D8) --------------------------------------------------------
int __fastcall sub_3A5D8(int a1, pthread_mutex_t *a2, _DWORD *a3, unsigned int a4)
{
  _DWORD *v7; // r0
  const char *v8; // r0
  char *v9; // r8
  int v10; // r12
  int v11; // r0
  int v12; // r3
  _DWORD *v14; // r0
  int v15; // r0
  size_t v16; // r6
  int v17; // r7
  void *count; // r0
  size_t v19; // r9
  void *v20; // r0
  struct __pthread_internal_slist *next; // r0
  _DWORD *v22; // r0
  char v23[4100]; // [sp+10h] [bp-1004h] BYREF

  v7 = json_array_get(a3, a4);
  v8 = (const char *)json_string_value(v7);
  v9 = (char *)v8;
  if ( !v8 || (strlen(v8) & 1) != 0 )
  {
    V_LOCK();
    logfmt_raw(v23, 0x1000u, 0, "Failed to get extranonce1");
    V_UNLOCK();
    v10 = 65;
    v11 = g_zc;
    LOWORD(v12) = (unsigned __int16)"stratum_parse_extranonce_kda";
LABEL_4:
    HIWORD(v12) = (unsigned int)"stratum_parse_extranonce_kda" >> 16;
    zlog(
      v11,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/frontend/frontend_kda/frontend_kda.c",
      164,
      v12,
      28,
      v10,
      100,
      v23);
    return 0;
  }
  v14 = json_array_get(a3, a4 + 1);
  v15 = json_integer_value((int)v14);
  v16 = v15 - 5;
  v17 = v15;
  if ( (unsigned int)(v15 - 5) > 3 )
  {
    V_LOCK();
    logfmt_raw(v23, 0x1000u, 0, "Get invalid n2size in parse_extranonce, xn2_size=%d", v17);
    V_UNLOCK();
    v10 = 71;
    v11 = g_zc;
    LOWORD(v12) = 9760;
    goto LABEL_4;
  }
  count = (void *)a2[3].__count;
  if ( count )
  {
    free(count);
    a2[3].__count = 0;
  }
  v19 = strlen(v9) >> 1;
  a2[3].__lock = v19;
  v20 = calloc(1u, v19);
  a2[3].__count = (unsigned int)v20;
  if ( !v20 )
  {
    V_LOCK();
    logfmt_raw(v23, 0x1000u, 0, "Failed to alloc xnonce1");
    V_UNLOCK();
    v10 = 79;
    v11 = g_zc;
    LOWORD(v12) = 9760;
    goto LABEL_4;
  }
  hex2bin((int)v20, (unsigned __int8 *)v9, v19);
  pthread_mutex_lock(a2 + 66);
  next = a2[65].__list.__next;
  if ( next )
    free(next);
  v22 = calloc(1u, 0x14u);
  a2[65].__spins = (int)v22;
  if ( v22 )
  {
    a2[3].__owner = v16;
    *v22 = v16;
    memset(v22 + 1, 0, v16);
    pthread_mutex_unlock(a2 + 66);
    V_LOCK();
    logfmt_raw(v23, 0x1000u, 0, "Stratum set nonce1 %s, nonce2 size=%d", v9, v17);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/frontend/frontend_kda/frontend_kda.c",
      164,
      "stratum_parse_extranonce_kda",
      28,
      94,
      20,
      v23);
    return 1;
  }
  else
  {
    printf("invalid pointer(%s)!\n", "work->private");
    return 0;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0003A868) --------------------------------------------------------
int __fastcall sub_3A868(int a1, pthread_mutex_t *a2, _DWORD *a3)
{
  _DWORD *v5; // r0
  const char *v6; // r7
  _DWORD *v7; // r0
  char *v8; // r5
  bool v9; // r4
  int valid; // r6
  size_t v12; // r0
  void *kind; // r5
  int lock; // r2
  size_t v15; // r0
  _BYTE src[288]; // [sp+18h] [bp-1124h] BYREF
  char v17[4100]; // [sp+138h] [bp-1004h] BYREF

  v5 = json_array_get(a3, 0);
  v6 = (const char *)json_string_value(v5);
  v7 = json_array_get(a3, 1u);
  v8 = (char *)json_string_value(v7);
  if ( json_array_get(a3, 2u) )
    v9 = *json_array_get(a3, 2u) == 5;
  else
    v9 = 0;
  if ( !valid_ascii(v6) || (valid = valid_hex(v8)) == 0 )
  {
    V_LOCK();
    logfmt_raw(v17, 0x1000u, 0, "Stratum notify: invalid parameters");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/frontend/frontend_kda/frontend_kda.c",
      164,
      "stratum_notify_kda",
      18,
      28,
      100,
      v17);
    return 0;
  }
  v12 = strlen(v8);
  hex2bin((int)src, (unsigned __int8 *)v8, v12 >> 1);
  if ( a2 == (pthread_mutex_t *)-448 )
    return 0;
  pthread_mutex_lock(a2 + 66);
  kind = (void *)a2[65].__kind;
  if ( !kind )
  {
    if ( strlen(v6) <= 0x3F )
      goto LABEL_13;
    goto LABEL_15;
  }
  if ( !strcmp((const char *)a2[65].__kind, v6) )
  {
    V_LOCK();
    logfmt_raw(v17, 0x1000u, 0, "Stratum notify: new job's job_id doesnot change, %s, %s", a2[65].__kind, v6);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/frontend/frontend_kda/frontend_kda.c",
      164,
      "stratum_notify_kda",
      18,
      36,
      80,
      v17);
    if ( strlen(v6) <= 0x3F )
    {
LABEL_16:
      kind = (void *)a2[65].__kind;
      if ( !kind )
        goto LABEL_13;
      goto LABEL_12;
    }
LABEL_15:
    V_LOCK();
    v15 = strlen(v6);
    logfmt_raw(v17, 0x1000u, 0, "Stratum notify: job_id len = %s, len %d >= %d", v6, v15, 64);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/frontend/frontend_kda/frontend_kda.c",
      164,
      "stratum_notify_kda",
      18,
      39,
      80,
      v17);
    goto LABEL_16;
  }
  if ( strlen(v6) > 0x3F )
    goto LABEL_15;
LABEL_12:
  free(kind);
  a2[65].__kind = 0;
LABEL_13:
  a2[65].__kind = (int)_strdup(v6);
  memcpy(&a2[19], src, 0x11Eu);
  lock = a2->__lock;
  a2[18].__size[4] = v9;
  *((_QWORD *)&a2[18].__align + 2) = lock;
  pthread_mutex_unlock(a2 + 66);
  return valid;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0003AB38) --------------------------------------------------------
int __fastcall sub_3AB38(int a1, int a2, char *a3)
{
  _DWORD *v3; // r3
  int v7; // r3
  const char *v8; // r12
  const char *v10; // [sp+4h] [bp-28h]
  char s[24]; // [sp+14h] [bp-18h] BYREF

  v3 = *(_DWORD **)(a1 + 1132);
  if ( v3 )
  {
    bin2hex((int)s, a1 + 1072, *v3 + 5);
    v7 = *(_DWORD *)(a2 + 1912);
    v8 = *(const char **)(a2 + 12);
    v10 = *(const char **)(a1 + 1124);
    *(_DWORD *)(a2 + 1912) = v7 + 1;
    snprintf(a3, 0x400u, "{\"id\":%d,\"method\":\"mining.submit\",\"params\":[\"%s\",\"%s\",\"%s\"]}", v7, v8, v10, s);
    return 0;
  }
  else
  {
    printf("invalid pointer(%s)!\n", "private");
    return 3;
  }
}

//----- (0003ABD0) --------------------------------------------------------
void *frontend_runtime_kda()
{
  __int64 v0; // r2
  void *v1; // r0

  dword_108718 = (int)stratum_connect;
  dword_10871C = (int)stratum_disconnect;
  dword_108720 = (int)stratum_recv_line;
  dword_108724 = (int)stratum_send_line;
  dword_108728 = (int)stratum_login_base;
  dword_10872C = (int)stratum_handle_method_base;
  dword_108730 = (int)stratum_handle_response_base;
  dword_108734 = (int)sub_3AB38;
  dword_108738 = (int)sub_3A5A4;
  dword_10873C = (int)stratum_subscribe_base;
  dword_108740 = (int)stratum_authorize_base;
  dword_108744 = (int)sub_3A868;
  LODWORD(v0) = diff_to_target_kda;
  HIDWORD(v0) = target_to_double_diff_kda;
  dword_108748 = (int)sub_3A5D8;
  dword_10874C = (int)stratum_set_diff_or_target_base;
  *(_QWORD *)&dword_108754 = v0;
  dword_108750 = (int)target_to_diff_kda;
  v1 = calloc(1u, 0x50u);
  return memcpy(v1, &dword_108718, 0x50u);
}
// 108718: using guessed type int dword_108718;
// 10871C: using guessed type int dword_10871C;
// 108720: using guessed type int dword_108720;
// 108724: using guessed type int dword_108724;
// 108728: using guessed type int dword_108728;
// 10872C: using guessed type int dword_10872C;
// 108730: using guessed type int dword_108730;
// 108734: using guessed type int dword_108734;
// 108738: using guessed type int dword_108738;
// 10873C: using guessed type int dword_10873C;
// 108740: using guessed type int dword_108740;
// 108744: using guessed type int dword_108744;
// 108748: using guessed type int dword_108748;
// 10874C: using guessed type int dword_10874C;
// 108750: using guessed type int dword_108750;
// 108754: using guessed type int dword_108754;

//----- (0003ACC0) --------------------------------------------------------
int __fastcall sub_3ACC0(int a1, int a2)
{
  int v2; // r12
  int v3; // r4
  _DWORD *v4; // r12
  int v5; // lr
  int v6; // t1
  int result; // r0
  _DWORD v8[15]; // [sp+0h] [bp+0h] BYREF

  v2 = *(_DWORD *)(a1 + 64);
  v8[0] = 17;
  v8[1] = 12;
  v8[2] = 7;
  v8[3] = -3;
  v3 = a2 - v2;
  v4 = v8;
  v5 = 0;
  v8[4] = -8;
  v8[5] = -13;
  v8[6] = -18;
  v8[7] = 20;
  v8[8] = 30;
  v8[9] = 40;
  v8[10] = 60;
  v8[11] = 70;
  v8[12] = 80;
  v8[13] = 100;
  while ( 1 )
  {
    v6 = v4[1];
    ++v4;
    if ( v6 < v3 && *(v4 - 1) >= v3 )
      break;
    ++v5;
  }
  result = v8[v5 + 7];
  if ( v3 > 17 )
    return 0;
  if ( v3 < -17 )
    return 100;
  if ( result <= 0 )
    return 0;
  if ( result >= 100 )
    return 100;
  return result;
}

//----- (0003AD84) --------------------------------------------------------
void *machine_runtime_ctrl_ckb_2042()
{
  void *v0; // r0
  void *v1; // r4
  _DWORD v3[22]; // [sp+0h] [bp-5Ch] BYREF

  memset(&v3[3], 0, 0x4Cu);
  v0 = calloc(1u, 0x58u);
  v1 = v0;
  if ( v0 )
  {
    v3[0] = sub_3ACC0;
    v3[1] = get_working_voltage_base;
    v3[2] = start_voltage_monitor_base;
    v3[4] = set_voltage_base;
    v3[5] = set_baud_base;
    v3[6] = set_frequency_with_voltage_base;
    v3[7] = start_mining_base;
    v3[8] = stop_mining_base;
    v3[9] = reset_mining_base;
    v3[10] = check_asic_num_base;
    v3[11] = check_bringup_temperature_base;
    v3[14] = "_nonce_num_hns";
    v3[15] = 3000000;
    v3[18] = 1143930880;
    v3[20] = 1065353216;
    v3[13] = 35;
    v3[16] = 22;
    memcpy(v0, v3, 0x58u);
  }
  else
  {
    printf("invalid pointer(%s)!\n", "new_machine_runtime");
  }
  return v1;
}

//----- (0003AEA0) --------------------------------------------------------
int __fastcall sub_3AEA0(int a1, int a2)
{
  int v2; // r12
  int v3; // r4
  _DWORD *v4; // r12
  int v5; // lr
  int v6; // t1
  int result; // r0
  _DWORD v8[15]; // [sp+0h] [bp+0h] BYREF

  v2 = *(_DWORD *)(a1 + 64);
  v8[0] = 15;
  v8[1] = 8;
  v8[2] = 3;
  v8[3] = -5;
  v3 = a2 - v2;
  v4 = v8;
  v5 = 0;
  v8[4] = -13;
  v8[5] = -17;
  v8[6] = -23;
  v8[7] = 10;
  v8[8] = 20;
  v8[9] = 30;
  v8[10] = 40;
  v8[11] = 60;
  v8[12] = 80;
  v8[13] = 100;
  while ( 1 )
  {
    v6 = v4[1];
    ++v4;
    if ( v6 < v3 && *(v4 - 1) >= v3 )
      break;
    ++v5;
  }
  result = v8[v5 + 7];
  if ( v3 > 15 )
    return 0;
  if ( v3 < -22 )
    return 100;
  if ( result <= 0 )
    return 0;
  if ( result >= 100 )
    return 100;
  return result;
}

//----- (0003AF64) --------------------------------------------------------
void *machine_runtime_ctrl_dash_1766()
{
  void *v0; // r0
  void *v1; // r4
  _DWORD v3[22]; // [sp+0h] [bp-5Ch] BYREF

  memset(&v3[3], 0, 0x4Cu);
  v0 = calloc(1u, 0x58u);
  v1 = v0;
  if ( v0 )
  {
    v3[0] = sub_3AEA0;
    v3[1] = get_working_voltage_base;
    v3[2] = start_voltage_monitor_base;
    v3[4] = set_voltage_base;
    v3[5] = set_baud_base;
    v3[6] = set_frequency_with_voltage_base;
    v3[7] = start_mining_base;
    v3[8] = stop_mining_base;
    v3[9] = reset_mining_base;
    v3[10] = check_asic_num_base;
    v3[11] = check_bringup_temperature_base;
    v3[14] = "_nonce_num_hns";
    v3[15] = 3000000;
    v3[18] = 1142292480;
    v3[20] = 1065353216;
    v3[13] = 51;
    v3[16] = 20;
    memcpy(v0, v3, 0x58u);
  }
  else
  {
    printf("invalid pointer(%s)!\n", "new_machine_runtime");
  }
  return v1;
}

//----- (0003B080) --------------------------------------------------------
int __fastcall sub_3B080(int a1, int a2)
{
  int v2; // r12
  int v3; // r4
  _DWORD *v4; // r12
  int v5; // lr
  int v6; // t1
  int result; // r0
  _DWORD v8[15]; // [sp+0h] [bp+0h] BYREF

  v2 = *(_DWORD *)(a1 + 64);
  v8[0] = 15;
  v8[1] = 8;
  v8[2] = 3;
  v8[3] = -2;
  v3 = a2 - v2;
  v4 = v8;
  v5 = 0;
  v8[4] = -8;
  v8[5] = -13;
  v8[6] = -18;
  v8[7] = 10;
  v8[8] = 20;
  v8[9] = 30;
  v8[10] = 40;
  v8[11] = 60;
  v8[12] = 80;
  v8[13] = 100;
  while ( 1 )
  {
    v6 = v4[1];
    ++v4;
    if ( v6 < v3 && *(v4 - 1) >= v3 )
      break;
    ++v5;
  }
  result = v8[v5 + 7];
  if ( v3 > 15 )
    return 0;
  if ( v3 < -17 )
    return 100;
  if ( result <= 0 )
    return 0;
  if ( result >= 100 )
    return 100;
  return result;
}

//----- (0003B144) --------------------------------------------------------
void *machine_runtime_ctrl_dcr_1727()
{
  void *v0; // r0
  void *v1; // r4
  _DWORD v3[22]; // [sp+0h] [bp-58h] BYREF

  memset(&v3[3], 0, 0x44u);
  v0 = calloc(1u, 0x58u);
  v1 = v0;
  if ( v0 )
  {
    v3[0] = sub_3B080;
    v3[1] = get_working_voltage_base;
    v3[2] = start_voltage_monitor_base;
    v3[4] = set_voltage_base;
    v3[5] = set_baud_base;
    v3[6] = set_frequency_with_voltage_base;
    v3[7] = start_mining_base;
    v3[8] = stop_mining_base;
    v3[9] = reset_mining_base;
    v3[10] = check_asic_num_base;
    v3[11] = check_bringup_temperature_base;
    v3[14] = "_nonce_num_hns";
    v3[15] = 3000000;
    v3[21] = "/config/sn";
    v3[20] = 1065353216;
    v3[18] = 1143930880;
    v3[13] = 35;
    v3[16] = 20;
    memcpy(v0, v3, 0x58u);
  }
  else
  {
    printf("invalid pointer(%s)!\n", "new_machine_runtime");
  }
  return v1;
}

//----- (0003B26C) --------------------------------------------------------
int __fastcall sub_3B26C(int a1, int a2)
{
  int v2; // r12
  int v3; // r4
  _DWORD *v4; // r12
  int v5; // lr
  int v6; // t1
  int result; // r0
  _DWORD v8[15]; // [sp+0h] [bp+0h] BYREF

  v2 = *(_DWORD *)(a1 + 64);
  v8[0] = 15;
  v8[1] = 8;
  v8[2] = 3;
  v8[3] = -2;
  v3 = a2 - v2;
  v4 = v8;
  v5 = 0;
  v8[4] = -8;
  v8[5] = -13;
  v8[6] = -18;
  v8[7] = 10;
  v8[8] = 20;
  v8[9] = 30;
  v8[10] = 40;
  v8[11] = 60;
  v8[12] = 80;
  v8[13] = 100;
  while ( 1 )
  {
    v6 = v4[1];
    ++v4;
    if ( v6 < v3 && *(v4 - 1) >= v3 )
      break;
    ++v5;
  }
  result = v8[v5 + 7];
  if ( v3 > 15 )
    return 0;
  if ( v3 < -17 )
    return 100;
  if ( result <= 0 )
    return 0;
  if ( result >= 100 )
    return 100;
  return result;
}

//----- (0003B330) --------------------------------------------------------
void *machine_runtime_ctrl_hns_2130()
{
  void *v0; // r0
  void *v1; // r4
  _DWORD v3[22]; // [sp+0h] [bp-58h] BYREF

  memset(&v3[3], 0, 0x44u);
  v0 = calloc(1u, 0x58u);
  v1 = v0;
  if ( v0 )
  {
    v3[0] = sub_3B26C;
    v3[1] = get_working_voltage_base;
    v3[2] = start_voltage_monitor_base;
    v3[4] = set_voltage_base;
    v3[5] = set_baud_base;
    v3[6] = set_frequency_with_voltage_base;
    v3[7] = start_mining_base;
    v3[8] = stop_mining_base;
    v3[9] = reset_mining_base;
    v3[10] = check_asic_num_base;
    v3[11] = check_bringup_temperature_base;
    v3[14] = "_nonce_num_hns";
    v3[15] = 3000000;
    v3[21] = "/config/sn";
    v3[20] = 1065353216;
    v3[18] = 1143193600;
    v3[13] = 37;
    v3[16] = 20;
    memcpy(v0, v3, 0x58u);
  }
  else
  {
    printf("invalid pointer(%s)!\n", "new_machine_runtime");
  }
  return v1;
}

//----- (0003B458) --------------------------------------------------------
int __fastcall sub_3B458(int a1, int a2)
{
  int v2; // r12
  int v3; // r4
  _DWORD *v4; // r12
  int v5; // lr
  int v6; // t1
  int result; // r0
  _DWORD v8[15]; // [sp+0h] [bp+0h] BYREF

  v2 = *(_DWORD *)(a1 + 64);
  v8[0] = 15;
  v8[1] = 8;
  v8[2] = 3;
  v8[3] = -2;
  v3 = a2 - v2;
  v4 = v8;
  v5 = 0;
  v8[4] = -8;
  v8[5] = -13;
  v8[6] = -18;
  v8[7] = 10;
  v8[8] = 20;
  v8[9] = 30;
  v8[10] = 40;
  v8[11] = 60;
  v8[12] = 80;
  v8[13] = 100;
  while ( 1 )
  {
    v6 = v4[1];
    ++v4;
    if ( v6 < v3 && *(v4 - 1) >= v3 )
      break;
    ++v5;
  }
  result = v8[v5 + 7];
  if ( v3 > 15 )
    return 0;
  if ( v3 < -17 )
    return 100;
  if ( result <= 0 )
    return 0;
  if ( result >= 100 )
    return 100;
  return result;
}

//----- (0003B51C) --------------------------------------------------------
void *machine_runtime_ctrl_kda_2110()
{
  void *v0; // r0
  void *v1; // r4
  _DWORD v3[22]; // [sp+0h] [bp-58h] BYREF

  memset(&v3[3], 0, 0x44u);
  v0 = calloc(1u, 0x58u);
  v1 = v0;
  if ( v0 )
  {
    v3[0] = sub_3B458;
    v3[1] = get_working_voltage_base;
    v3[2] = start_voltage_monitor_base;
    v3[4] = set_voltage_base;
    v3[5] = set_baud_base;
    v3[6] = set_frequency_with_voltage_base;
    v3[7] = start_mining_base;
    v3[8] = stop_mining_base;
    v3[9] = reset_mining_base;
    v3[10] = check_asic_num_base;
    v3[11] = check_bringup_temperature_base;
    v3[14] = "_nonce_num_hns";
    v3[15] = 3000000;
    v3[21] = "/config/sn";
    v3[20] = 1065353216;
    v3[18] = 1143521280;
    v3[13] = 35;
    v3[16] = 20;
    memcpy(v0, v3, 0x58u);
  }
  else
  {
    printf("invalid pointer(%s)!\n", "new_machine_runtime");
  }
  return v1;
}

//----- (0003B644) --------------------------------------------------------
void __fastcall __noreturn check_working_voltage(int a1)
{
  int current_voltage; // r4
  int v3; // r0
  int v4; // r4
  int v5; // r5
  int v6; // r0

  while ( 1 )
  {
    current_voltage = get_current_voltage();
    v3 = (*(int (__fastcall **)(int))(a1 + 4))(a1);
    v4 = current_voltage - v3;
    v5 = v3;
    if ( v4 < 0 )
      v4 = -v4;
    if ( v4 > 9 )
    {
      v6 = is_power_init();
      set_voltage_by_steps(v5, v6);
    }
    sleep(1u);
  }
}

//----- (0003B698) --------------------------------------------------------
int __fastcall set_baud_base(int a1, int a2)
{
  char *all_created_runtime; // r0
  char *v4; // r8
  char *v5; // r8
  int i; // r4
  int v7; // t1
  int v8; // r0
  int chain_domain_num; // r0
  int domain_asic_num; // r0
  int v12; // r0
  int v13; // r7
  int v14; // r10
  char *v15; // r6
  int v16; // r4
  int v17; // r0
  int v18; // t1
  int v19; // [sp+14h] [bp-1008h] BYREF
  char v20[4100]; // [sp+18h] [bp-1004h] BYREF

  v19 = 0;
  all_created_runtime = (char *)get_all_created_runtime(&v19);
  v4 = all_created_runtime;
  if ( a2 > 3000000 )
  {
    V_LOCK();
    chain_domain_num = platform_get_chain_domain_num();
    logfmt_raw(v20, 0x1000u, 0, 928144, chain_domain_num);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/machine_runtime/machine_runtime_base.c",
      166,
      "set_baud_base",
      13,
      104,
      20,
      v20);
    V_LOCK();
    domain_asic_num = platform_get_domain_asic_num();
    logfmt_raw(v20, 0x1000u, 0, 928332, domain_asic_num);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/machine_runtime/machine_runtime_base.c",
      166,
      "set_baud_base",
      13,
      105,
      20,
      v20);
    v12 = platform_get_chain_domain_num();
    if ( v12 > 2 )
    {
      v13 = 18;
      v14 = v12 + 15;
      do
      {
        platform_get_domain_asic_num();
        if ( v19 > 0 )
        {
          v15 = v4 - 4;
          v16 = 0;
          do
          {
            v17 = v16++;
            platform_get_asic_addr_interval(v17);
            v18 = *((_DWORD *)v15 + 1);
            v15 += 4;
            (*(void (**)(void))(v18 + 92))();
          }
          while ( v19 > v16 );
        }
        v13 += 3;
      }
      while ( v14 - v13 >= 0 );
    }
    all_created_runtime = (char *)usleep((__useconds_t)"rl_kda_2110");
  }
  if ( v19 > 0 )
  {
    v5 = v4 - 4;
    for ( i = 0; i < v19; ++i )
    {
      v7 = *((_DWORD *)v5 + 1);
      v5 += 4;
      (*(void (**)(void))(v7 + 76))();
      all_created_runtime = (char *)usleep(0x2710u);
    }
  }
  v8 = dev_ctrl(all_created_runtime);
  (*(void (__fastcall **)(int))(v8 + 16))(a2);
  usleep(0x2710u);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4AB8C: using guessed type int __fastcall dev_ctrl(_DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0003B884) --------------------------------------------------------
int __fastcall check_bringup_temperature_base(int a1)
{
  int *all_created_runtime; // r11
  int v2; // r8
  int *v3; // r3
  int v4; // t1
  int v5; // r2
  int v6; // r5
  char *v7; // r7
  char *v8; // r10
  int v9; // r4
  int v10; // t1
  int *v11; // r10
  int v12; // r12
  int v13; // r9
  int v14; // r7
  char *v15; // r3
  int *v16; // r2
  int v17; // r0
  int v18; // r1
  int v19; // r4
  char *v20; // r10
  int v21; // r7
  int v22; // r5
  int *v23; // r4
  int v24; // r3
  double v25; // r0
  int v26; // r3
  bool v27; // cc
  int result; // r0
  double v29; // r0
  int v30; // r2
  int v31; // r0
  int *v32; // r3
  int v33; // r2
  int *v34; // r7
  int v35; // r1
  int v36; // t1
  int v37; // [sp+0h] [bp-12A4h] BYREF
  int v38; // [sp+24h] [bp-1280h]
  int v39; // [sp+28h] [bp-127Ch]
  void *ptr; // [sp+2Ch] [bp-1278h]
  int v41; // [sp+30h] [bp-1274h]
  int v42; // [sp+34h] [bp-1270h]
  int v43; // [sp+38h] [bp-126Ch]
  char *s; // [sp+3Ch] [bp-1268h]
  const char *v45; // [sp+40h] [bp-1264h]
  int *v46; // [sp+44h] [bp-1260h]
  int v47; // [sp+48h] [bp-125Ch]
  int v48; // [sp+4Ch] [bp-1258h]
  int v49; // [sp+50h] [bp-1254h]
  int v50; // [sp+54h] [bp-1250h]
  int v51; // [sp+5Ch] [bp-1248h] BYREF
  _DWORD v52[7]; // [sp+60h] [bp-1244h] BYREF
  int v53; // [sp+7Ch] [bp-1228h]
  _DWORD v54[7]; // [sp+80h] [bp-1224h] BYREF
  int v55; // [sp+9Ch] [bp-1208h]
  _DWORD v56[64]; // [sp+A0h] [bp-1204h] BYREF
  _DWORD v57[64]; // [sp+1A0h] [bp-1104h] BYREF
  char v58[4100]; // [sp+2A0h] [bp-1004h] BYREF

  v49 = a1;
  v51 = 0;
  all_created_runtime = (int *)get_all_created_runtime(&v51);
  if ( v51 > 0 )
  {
    v3 = all_created_runtime;
    v2 = 256;
    do
    {
      v4 = *v3++;
      v5 = *(_DWORD *)(v4 + 340);
      if ( v2 >= v5 )
        v2 = v5;
    }
    while ( v3 != &all_created_runtime[v51] );
    if ( v2 == 256 )
      v2 = 2;
  }
  else
  {
    v2 = 2;
  }
  ptr = calloc(v51 * v2, 8u);
  if ( !ptr )
  {
    printf("invalid pointer(%s)!\n", "sensor_status");
    return 3;
  }
  v6 = v51;
  if ( v51 > 0 )
  {
    v7 = (char *)ptr;
    v8 = (char *)(all_created_runtime - 1);
    v9 = 0;
    do
    {
      v10 = *((_DWORD *)v8 + 1);
      v8 += 4;
      ++v9;
      v7 += 8 * v2;
      (*(void (**)(void))(v10 + 184))();
      v6 = v51;
    }
    while ( v51 > v9 );
  }
  if ( v2 <= 0 )
  {
    if ( v6 != 1 )
    {
      v14 = 0;
      v13 = 8 * v2;
      v41 = 0;
LABEL_26:
      if ( v51 > 0 )
      {
        v20 = (char *)ptr;
        v47 = v14;
        v21 = 0;
        s = "chain";
        v43 = 0;
        v42 = 0;
        v45 = "sensor_addr %02x, J0:6";
        v46 = &g_zc;
        v39 = 255;
        v50 = v13;
        while ( v2 <= 0 )
        {
LABEL_37:
          ++v21;
          v20 += v50;
          if ( v51 <= v21 )
            goto LABEL_38;
        }
        v22 = 0;
        v23 = (int *)(*(_DWORD *)(all_created_runtime[v21] + 332) + 20);
        while ( 1 )
        {
          while ( 1 )
          {
            v24 = *(v23 - 2);
            if ( v24 )
              break;
            LODWORD(v25) = v56;
            HIDWORD(v25) = v47;
            if ( !check_value_valid_with_stdd(v25, *(_DWORD *)&v20[8 * v22]) )
            {
              V_LOCK();
              V_INT((int)v52, s, *(int *)(all_created_runtime[v21] + 200));
              v38 = *v23;
              v48 = (int)&v37;
              logfmt_raw(v58, 0x1000u, 0, v53, v52[0], v52[1], v52[2], v52[3], v52[4], v52[5], v52[6], v53, v45, v38);
              V_UNLOCK();
              v30 = 189;
              v31 = *v46;
LABEL_49:
              zlog(
                v31,
                "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godmi"
                "ner-origin_godminer-new/machine_runtime/machine_runtime_base.c",
                166,
                "check_bringup_temperature_base",
                30,
                v30,
                100,
                v58);
              goto LABEL_31;
            }
            v23 += 6;
            v26 = *(_DWORD *)&v20[8 * v22++];
            ++v42;
            if ( v39 < v26 )
              v26 = v39;
            v39 = v26;
            if ( v2 == v22 )
              goto LABEL_37;
          }
          if ( v24 == 1 )
          {
            LODWORD(v29) = v57;
            HIDWORD(v29) = v41;
            v48 = check_value_valid_with_stdd(v29, *(_DWORD *)&v20[8 * v22]);
            if ( !v48 )
            {
              V_LOCK();
              V_INT((int)v54, s, *(int *)(all_created_runtime[v21] + 200));
              logfmt_raw(v58, 0x1000u, v48, v55, v54[0], v54[1], v54[2], v54[3], v54[4], v54[5], v54[6], v55, v45, *v23);
              V_UNLOCK();
              v30 = 197;
              v31 = *v46;
              goto LABEL_49;
            }
            ++v43;
          }
LABEL_31:
          ++v22;
          v23 += 6;
          if ( v2 == v22 )
            goto LABEL_37;
        }
      }
      free(ptr);
LABEL_58:
      V_LOCK();
      logfmt_raw(v58, 0x1000u, 0, "J0:6, temp sensor error, pls check it, and reboot system");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/machine_runtime/machine_runtime_base.c",
        166,
        "check_bringup_temperature_base",
        30,
        209,
        100,
        v58);
      while ( 1 )
        ;
    }
  }
  else
  {
    v11 = (int *)ptr;
    v12 = 0;
    v13 = 8 * v2;
    v41 = 0;
    v14 = 0;
    v39 = (int)ptr + 8 * v2;
    do
    {
      if ( v6 > 0 )
      {
        v15 = (char *)all_created_runtime;
        v16 = v11;
        do
        {
          v17 = *v16;
          if ( *v16 != -64 )
          {
            v18 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v15 + 332) + v12 + 12);
            if ( v18 )
            {
              if ( v18 == 1 )
              {
                v19 = v41;
                v57[v41] = v17;
                v41 = v19 + 1;
              }
            }
            else
            {
              v56[v14++] = v17;
            }
          }
          v15 += 4;
          v16 = (int *)((char *)v16 + v13);
        }
        while ( &all_created_runtime[v6] != (int *)v15 );
      }
      v11 += 2;
      v12 += 24;
    }
    while ( (int *)v39 != v11 );
    if ( v6 != 1 )
      goto LABEL_26;
    if ( v14 )
    {
      v32 = v56;
      v33 = 255;
      v34 = &v56[v14];
      do
      {
        v36 = *v32++;
        v35 = v36;
        if ( v33 >= v36 )
          v33 = v35;
      }
      while ( v34 != v32 );
      v39 = v33;
      goto LABEL_38;
    }
  }
  v39 = 255;
LABEL_38:
  free(ptr);
  v27 = v43 <= 0;
  if ( v43 > 0 )
    v27 = v42 <= 0;
  result = v27;
  if ( v27 )
    goto LABEL_58;
  *(_DWORD *)(v49 + 68) = v39;
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0003BD24) --------------------------------------------------------
int __fastcall get_working_voltage_base(int (__fastcall **a1)(_DWORD, int))
{
  int v1; // r9
  int temp; // r4
  int working_voltage; // r0
  int v5; // r1
  int v6; // r7
  int v7; // r2
  int v8; // r2
  bool v9; // cc
  int v10; // r2
  int v11; // r8
  int v12; // r5
  char v14[4100]; // [sp+10h] [bp-1004h] BYREF

  temp = get_temp(1);
  working_voltage = get_working_voltage();
  v6 = working_voltage;
  if ( temp == -64 )
  {
    v11 = 0;
    v12 = working_voltage;
    v1 = 0;
  }
  else
  {
    v7 = dword_1063F8;
    dword_1063F8 = temp;
    v8 = v7 - temp;
    v9 = v8 <= 5;
    if ( v8 <= 5 )
      v10 = 34664;
    else
      v10 = (unsigned __int16)&dword_108768;
    if ( v9 )
      v5 = 0;
    else
      HIWORD(v10) = (unsigned int)&dword_108768 >> 16;
    if ( v9 )
    {
      HIWORD(v10) = 16;
      v1 = v5;
    }
    else
    {
      v5 = *(_DWORD *)v10;
    }
    if ( !v9 )
    {
      v1 = 10;
      ++v5;
    }
    *(_DWORD *)v10 = v5;
    v11 = (*a1)(a1, temp);
    v12 = v6 + v11 + v1;
  }
  V_LOCK();
  logfmt_raw(v14, 0x1000u, 0, "temp:%d, working_voltage:%d, compensate:%d, bias:%d", temp, v6, v11, v1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/machine_runtime/machine_runtime_base.c",
    166,
    "get_working_voltage_base",
    24,
    245,
    20,
    v14);
  return v12;
}
// 3BD84: variable 'v5' is possibly undefined
// 3BDA8: variable 'v1' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1063F8: using guessed type int dword_1063F8;
// 108768: using guessed type int dword_108768;
// 11A7AC: using guessed type int g_zc;

//----- (0003BE40) --------------------------------------------------------
int __fastcall start_voltage_monitor_base(void *arg)
{
  char v2[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( pthread_create((pthread_t *)&dword_10876C, 0, (void *(*)(void *))check_working_voltage, arg) )
  {
    V_LOCK();
    logfmt_raw(v2, 0x1000u, 0, "voltage monitor create failed");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/machine_runtime/machine_runtime_base.c",
      166,
      "start_voltage_monitor_base",
      26,
      269,
      100,
      v2);
    return 5;
  }
  else
  {
    pthread_detach(dword_10876C);
    V_LOCK();
    logfmt_raw(v2, 0x1000u, 0, "start_voltage_monitor");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/machine_runtime/machine_runtime_base.c",
      166,
      "start_voltage_monitor_base",
      26,
      273,
      60,
      v2);
    return 0;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10876C: using guessed type int dword_10876C;
// 11A7AC: using guessed type int g_zc;

//----- (0003BF60) --------------------------------------------------------
void __noreturn stop_voltage_monitor_base()
{
  pthread_exit(&dword_10876C);
}
// 10876C: using guessed type int dword_10876C;

//----- (0003BF70) --------------------------------------------------------
int __fastcall set_voltage_base(int a1, int a2)
{
  int v3; // r0

  v3 = is_power_init();
  set_voltage(a2, v3);
  return 0;
}

//----- (0003BF90) --------------------------------------------------------
int __fastcall set_frequency_with_voltage_base(int a1)
{
  char *all_created_runtime; // r8
  float v3; // s17
  float v4; // s16
  int working_voltage; // r9
  float v6; // s20
  int v7; // s19
  int v8; // r0
  char *v9; // r5
  int v10; // r4
  int v11; // t1
  int v12; // r3
  char *v15; // r8
  int v16; // r4
  int v17; // t1
  int current_voltage; // [sp+14h] [bp-1018h]
  int v19; // [sp+18h] [bp-1014h]
  int v20; // [sp+1Ch] [bp-1010h]
  int v21; // [sp+24h] [bp-1008h] BYREF
  char v22[4100]; // [sp+28h] [bp-1004h] BYREF

  v21 = 0;
  all_created_runtime = (char *)get_all_created_runtime(&v21);
  v3 = *(float *)(*(_DWORD *)all_created_runtime + 900);
  v4 = *(float *)(*(_DWORD *)all_created_runtime + 896);
  if ( v3 > *(float *)(a1 + 72) )
    v3 = *(float *)(a1 + 72);
  current_voltage = get_current_voltage();
  working_voltage = get_working_voltage();
  if ( *(_DWORD *)(a1 + 68) != -64 )
    working_voltage += (*(int (__fastcall **)(int))a1)(a1);
  v6 = v3 * *(float *)(a1 + 80);
  V_LOCK();
  logfmt_raw(v22, 0x1000u, 0, "Initializing chip cluster, please wait, this may take up to 2 minutes...");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/machine_runtime/machine_runtime_base.c",
    166,
    "set_frequency_with_voltage_base",
    31,
    320,
    60,
    v22);
  v20 = (current_voltage - working_voltage) / 10;
  v7 = (int)(float)((float)(v3 - v4) / 6.25);
  if ( v7 <= 0 )
  {
LABEL_21:
    V_LOCK();
    logfmt_raw(v22, 0x1000u, 0, "set freq to %.2f, current voltage %d", v3, current_voltage);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/machine_runtime/machine_runtime_base.c",
      166,
      "set_frequency_with_voltage_base",
      31,
      345,
      60,
      v22);
    if ( v3 == v4 || v21 <= 0 )
    {
      return 0;
    }
    else
    {
      v15 = all_created_runtime - 4;
      v16 = 0;
      while ( 1 )
      {
        v17 = *((_DWORD *)v15 + 1);
        v15 += 4;
        ++v16;
        v12 = (*(int (**)(void))(v17 + 176))();
        if ( v12 )
          break;
        usleep((__useconds_t)&loc_30D40);
        if ( v21 <= v16 )
          return 0;
      }
    }
  }
  else
  {
    v19 = 0;
    while ( 1 )
    {
      v4 = v4 + 6.25;
      if ( v21 > 0 )
        break;
LABEL_14:
      if ( working_voltage + 20 < current_voltage && v6 < v4 && v7 - v20 <= v19 )
      {
        current_voltage -= 10;
        v12 = (*(int (__fastcall **)(int, int))(a1 + 16))(a1, current_voltage);
        if ( v12 )
          return v12;
        usleep((__useconds_t)"rl_kda_2110");
      }
      if ( v7 == ++v19 )
        goto LABEL_21;
    }
    v8 = *(_DWORD *)all_created_runtime;
    if ( *(_DWORD *)all_created_runtime )
    {
      v9 = all_created_runtime;
      v10 = 0;
      while ( 1 )
      {
        ++v10;
        v12 = (*(int (__fastcall **)(int, _DWORD))(v8 + 176))(v8, 0);
        if ( v12 )
          break;
        usleep((__useconds_t)&loc_30D40);
        if ( v21 <= v10 )
          goto LABEL_14;
        v11 = *((_DWORD *)v9 + 1);
        v9 += 4;
        v8 = v11;
        if ( !v11 )
          goto LABEL_27;
      }
    }
    else
    {
LABEL_27:
      printf("invalid pointer(%s)!\n", "be_runtimes[b]");
      return 3;
    }
  }
  return v12;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0003C298) --------------------------------------------------------
int __fastcall check_asic_num_base(int a1)
{
  int v1; // r4
  int *all_created_runtime; // r0
  int *v4; // r5
  int v5; // t1
  int v6; // r0
  int v7; // r8
  int v8; // r0
  int i; // r4
  int v10; // r0
  int v11; // r5
  int *v12; // r4
  int (**v13)(void); // t1
  int v14; // r7
  int v15; // r0
  int v16; // r0
  int v17; // r7
  int v19; // [sp+0h] [bp-10ACh]
  int *v20; // [sp+14h] [bp-1098h]
  int v21; // [sp+24h] [bp-1088h] BYREF
  _DWORD v22[32]; // [sp+28h] [bp-1084h] BYREF
  char v23[4100]; // [sp+A8h] [bp-1004h] BYREF

  v1 = 0;
  v21 = 0;
  all_created_runtime = (int *)get_all_created_runtime(&v21);
  v20 = all_created_runtime;
  if ( v21 > 0 )
  {
    if ( !*all_created_runtime )
    {
LABEL_25:
      printf("invalid pointer(%s)!\n", "be_runtimes[c]");
      return 3;
    }
    v4 = all_created_runtime;
    while ( 1 )
    {
      v6 = dev_ctrl(all_created_runtime);
      all_created_runtime = (int *)(*(int (__fastcall **)(int))(v6 + 28))(v1++);
      if ( v21 <= v1 )
        break;
      v5 = v4[1];
      ++v4;
      if ( !v5 )
        goto LABEL_25;
    }
  }
  V_LOCK();
  logfmt_raw(v23, 0x1000u, 0, "all backend runtimes have been poweroff.");
  V_UNLOCK();
  v7 = 1;
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/machine_runtime/machine_runtime_base.c",
    166,
    "check_asic_num_base",
    19,
    370,
    60,
    v23);
  memset(v22, 0, sizeof(v22));
  V_LOCK();
  logfmt_raw(v23, 0x1000u, 0, "start to check asic num test loop");
  V_UNLOCK();
  v8 = zlog(
         g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-ori"
         "gin_godminer-new/machine_runtime/machine_runtime_base.c",
         166,
         "check_asic_num_base",
         19,
         375,
         60,
         v23);
  while ( 1 )
  {
    if ( v21 > 0 )
    {
      for ( i = 0; i < v21; ++i )
      {
        v10 = dev_ctrl(v8);
        v8 = (*(int (__fastcall **)(int))(v10 + 40))(i);
      }
    }
    v11 = power_init();
    if ( v11 )
      break;
    v8 = (*(int (__fastcall **)(int, _DWORD))(a1 + 20))(a1, *(_DWORD *)(a1 + 56));
    if ( v21 > 0 )
    {
      v12 = v20 - 1;
      do
      {
        while ( 1 )
        {
          v13 = (int (**)(void))v12[1];
          ++v12;
          v8 = (*v13)();
          if ( !v8 )
            break;
          if ( v21 <= ++v11 )
            goto LABEL_22;
        }
        v14 = 3;
        v15 = redirect_nonce_output(*v20, *v12);
        while ( 1 )
        {
          v16 = dev_ctrl(v15);
          (*(void (__fastcall **)(_DWORD, _DWORD, _DWORD))(v16 + 24))(
            *(_DWORD *)(*v12 + 196),
            *(_DWORD *)(*v12 + 904),
            *(_DWORD *)(*v12 + 928));
          (*(void (**)(void))(*v12 + 188))();
          v15 = (*(int (**)(void))(*v12 + 180))();
          if ( !v15 )
            break;
          if ( !--v14 )
          {
            v17 = v22[2 * v11] + 1;
            v22[2 * v11] = v17;
            goto LABEL_21;
          }
        }
        v17 = v22[2 * v11];
LABEL_21:
        (*(void (**)(void))(*v12 + 20))();
        V_LOCK();
        v19 = v11++;
        logfmt_raw(v23, 0x1000u, 0, "chain[%d] check asic num test, loop:%d done, total failed times:%d", v19, v7, v17);
        V_UNLOCK();
        v8 = zlog(
               g_zc,
               "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godmin"
               "er-origin_godminer-new/machine_runtime/machine_runtime_base.c",
               166,
               "check_asic_num_base",
               19,
               410,
               60,
               v23);
      }
      while ( v21 > v11 );
    }
LABEL_22:
    if ( ++v7 == 1001 )
      return 0;
  }
  V_LOCK();
  logfmt_raw(v23, 0x1000u, 0, "power init error!");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/machine_runtime/machine_runtime_base.c",
    166,
    "check_asic_num_base",
    19,
    382,
    100,
    v23);
  return 30;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4AB8C: using guessed type int __fastcall dev_ctrl(_DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0003C5F4) --------------------------------------------------------
int __fastcall start_mining_base(int a1)
{
  int v1; // r4
  int *all_created_runtime; // r0
  int *v4; // r8
  int *v5; // r5
  int v6; // t1
  int v7; // r0
  int started; // r5
  int *v9; // r4
  int (**v10)(void); // t1
  int v11; // r10
  int v12; // r0
  int v13; // r0
  int *v14; // r7
  int v15; // r8
  int v16; // r3
  int *v17; // r5
  int i; // r4
  int v19; // t1
  int *v20; // r7
  int v21; // r5
  int v22; // t1
  int v24; // [sp+14h] [bp-4h] BYREF
  int v25; // [sp+18h] [bp+0h] BYREF

  v1 = 0;
  v24 = 0;
  all_created_runtime = (int *)get_all_created_runtime(&v24);
  v4 = all_created_runtime;
  if ( v24 > 0 )
  {
    if ( !*all_created_runtime )
    {
LABEL_32:
      v15 = 3;
      printf("invalid pointer(%s)!\n", "be_runtimes[c]");
      return v15;
    }
    v5 = all_created_runtime;
    while ( 1 )
    {
      v7 = dev_ctrl(all_created_runtime);
      all_created_runtime = (int *)(*(int (__fastcall **)(int))(v7 + 28))(v1++);
      if ( v24 <= v1 )
        break;
      v6 = v5[1];
      ++v5;
      if ( !v6 )
        goto LABEL_32;
    }
  }
  V_LOCK();
  logfmt_raw((char *)&v25, 0x1000u, 0, "all backend runtimes have been poweroff.");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/machine_runtime/machine_runtime_base.c",
    166,
    "start_mining_base",
    17,
    428,
    60,
    &v25);
  if ( power_init() )
  {
    V_LOCK();
    logfmt_raw((char *)&v25, 0x1000u, 0, ">> power init error, check PSU please <<");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/machine_runtime/machine_runtime_base.c",
      166,
      "start_mining_base",
      17,
      433,
      100,
      &v25);
    return 30;
  }
  started = start_heartbeat_thread();
  if ( started )
    return start_heartbeat_thread();
  (*(void (__fastcall **)(int, _DWORD))(a1 + 20))(a1, *(_DWORD *)(a1 + 56));
  if ( v24 > 0 )
  {
    v9 = v4 - 1;
    do
    {
LABEL_12:
      v10 = (int (**)(void))v9[1];
      ++v9;
      if ( !(*v10)() )
      {
        v11 = 3;
        v12 = redirect_nonce_output(*v4, *v9);
        while ( 1 )
        {
          v13 = dev_ctrl(v12);
          (*(void (__fastcall **)(_DWORD, _DWORD, _DWORD))(v13 + 24))(
            *(_DWORD *)(*v9 + 196),
            *(_DWORD *)(*v9 + 904),
            *(_DWORD *)(*v9 + 928));
          (*(void (**)(void))(*v9 + 188))();
          v12 = (*(int (**)(void))(*v9 + 180))();
          if ( !v12 )
            break;
          if ( !--v11 )
          {
            if ( v24 > ++started )
              goto LABEL_12;
            goto LABEL_17;
          }
        }
      }
      ++started;
    }
    while ( v24 > started );
  }
LABEL_17:
  check_and_destroy_abnormal_runtime();
  v14 = (int *)get_all_created_runtime(&v24);
  if ( v24 <= 0 )
  {
    V_LOCK();
    v15 = 12;
    logfmt_raw((char *)&v25, 0x1000u, 0, "there is no qualified device remain after check abnormal runtime!");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/machine_runtime/machine_runtime_base.c",
      166,
      "start_mining_base",
      17,
      463,
      100,
      &v25);
    return v15;
  }
  v15 = (*(int (__fastcall **)(int, _DWORD))(a1 + 20))(a1, *(_DWORD *)(a1 + 60));
  if ( v15 )
    return v15;
  (*(void (__fastcall **)(int))(a1 + 44))(a1);
  V_LOCK();
  logfmt_raw((char *)&v25, 0x1000u, 0, "check_bringup temperature %d C", *(_DWORD *)(a1 + 68));
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/machine_runtime/machine_runtime_base.c",
    166,
    "start_mining_base",
    17,
    473,
    60,
    &v25);
  v16 = *(_DWORD *)(a1 + 68);
  if ( v16 != -64 )
  {
    if ( v16 < -10 )
    {
      fan_pwm_set(0x28u);
    }
    else if ( v16 > 30 )
    {
      fan_pwm_set(0x64u);
    }
  }
  if ( v24 > 0 )
  {
    v17 = v14 - 1;
    for ( i = 0; i < v24; ++i )
    {
      v19 = v17[1];
      ++v17;
      redirect_nonce_output(*v14, v19);
      (*(void (**)(void))(*v17 + 192))();
    }
  }
  v15 = (*(int (__fastcall **)(int))(a1 + 24))(a1);
  if ( v15 || v24 <= 0 )
    return v15;
  v20 = v14 - 1;
  v21 = 0;
  do
  {
    v22 = v20[1];
    ++v20;
    ++v21;
    (*(void (**)(void))(v22 + 4))();
    (*(void (**)(void))(*v20 + 112))();
    (*(void (**)(void))(*v20 + 8))();
  }
  while ( v24 > v21 );
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4AB8C: using guessed type int __fastcall dev_ctrl(_DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0003C9FC) --------------------------------------------------------
int stop_mining_base()
{
  int v0; // r4
  _DWORD *all_created_runtime; // r0
  _DWORD *v2; // r5
  int v3; // r0
  int v4; // r0
  int v5; // t1
  int result; // r0
  int v7; // r0
  int v8; // [sp+4h] [bp-4h] BYREF

  v0 = 0;
  v8 = 0;
  all_created_runtime = get_all_created_runtime(&v8);
  if ( v8 <= 0 )
  {
LABEL_8:
    v7 = dev_ctrl(all_created_runtime);
    (*(void (__fastcall **)(char *))(v7 + 16))("_nonce_num_hns");
    usleep(0x2710u);
    return 0;
  }
  else
  {
    v2 = all_created_runtime;
    v3 = *all_created_runtime;
    if ( v3 )
    {
      while ( 1 )
      {
        result = (*(int (**)(void))(v3 + 12))();
        if ( result )
          break;
        v4 = dev_ctrl(0);
        (*(void (__fastcall **)(int))(v4 + 28))(v0++);
        all_created_runtime = (_DWORD *)usleep((__useconds_t)"rl_kda_2110");
        if ( v8 <= v0 )
          goto LABEL_8;
        v5 = v2[1];
        ++v2;
        v3 = v5;
        if ( !v5 )
          goto LABEL_9;
      }
    }
    else
    {
LABEL_9:
      printf("invalid pointer(%s)!\n", 928772);
      return 3;
    }
  }
  return result;
}
// 4AB8C: using guessed type int __fastcall dev_ctrl(_DWORD);

//----- (0003CAD0) --------------------------------------------------------
int reset_mining_base()
{
  return 0;
}

//----- (0003CAD8) --------------------------------------------------------
int machine_info_init()
{
  int result; // r0

  result = platform_topol_init();
  if ( result )
    exit(result);
  return result;
}

//----- (0003CAEC) --------------------------------------------------------
int __fastcall hardware_init(int a1)
{
  int is_pic_mcu_en; // r0
  int v3; // r0
  int v4; // r6
  _DWORD *device_num; // r0
  _DWORD *v6; // r8
  _DWORD *v7; // r4
  int v8; // r0
  int v9; // r0
  int v10; // r0
  int v11; // r0
  int v12; // r0
  int v13; // r0
  __int64 v14; // r0
  int v15; // r6
  int v16; // r9
  int eeprom_chain_load_state; // r0
  int v18; // r7
  int v19; // r0
  int v20; // r0
  int v21; // r0
  const char *v22; // r4
  char *v23; // r9
  char *v24; // r0
  size_t v25; // r2
  _BOOL4 v26; // r0
  char *v27; // r7
  size_t v28; // r4
  int v29; // r4
  char *all_created_runtime; // r0
  char *v31; // r7
  int v32; // t1
  int is_adjustable_power; // r0
  int v34; // r10
  int chain_sensor_num; // r0
  int v36; // r11
  int sensor_max_chip_temp; // r0
  int v38; // r10
  int sensor_max_pcb_temp; // r0
  int v40; // r11
  int sensor_min_pcb_temp; // r0
  int v42; // r10
  int psu_gpio_port; // r0
  char *v44; // r0
  char *v45; // r4
  int v46; // t1
  char pic_device_high; // r0
  int v49; // r0
  int v50; // r0
  int v51; // r0
  int v52; // r12
  int v53; // r2
  int v54; // [sp+0h] [bp-106Ch]
  int dest; // [sp+28h] [bp-1044h]
  char *desta; // [sp+28h] [bp-1044h]
  int v57; // [sp+30h] [bp-103Ch] BYREF
  int v58[13]; // [sp+34h] [bp-1038h] BYREF
  _DWORD v59[1025]; // [sp+68h] [bp-1004h] BYREF

  machine_info_init();
  platform_get_fan_control_info((float *)v58);
  fan_control_info_init(
    v58[0],
    v58[1],
    v58[2],
    v58[3],
    v58[4],
    v58[5],
    *(float *)&v58[6],
    v58[7],
    v58[8],
    v58[9],
    v58[10],
    v58[11],
    v58[12]);
  is_pic_mcu_en = platform_is_pic_mcu_en();
  if ( is_pic_mcu_en )
  {
    pic_device_high = platform_get_pic_device_high(0);
    is_pic_mcu_en = set_pic_device_high(pic_device_high);
  }
  v3 = dev_ctrl(is_pic_mcu_en);
  v4 = (*(int (**)(void))(v3 + 8))();
  if ( v4 )
  {
    V_LOCK();
    logfmt_raw((char *)v59, 0x1000u, 0, "dev init failed!");
    V_UNLOCK();
    v52 = 100;
    v53 = 574;
    goto LABEL_33;
  }
  check_fan_valiad();
  device_num = (_DWORD *)query_device_num();
  v6 = device_num;
  if ( (int)device_num <= 0 )
  {
    V_LOCK();
    logfmt_raw((char *)v59, 0x1000u, 0, "query_device_num error code %d and then exit", v6);
    V_UNLOCK();
    v52 = 100;
    v53 = 585;
LABEL_33:
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/machine_runtime/machine_runtime_base.c",
      166,
      "hardware_init",
      13,
      v53,
      v52,
      v59);
    return 31;
  }
  v7 = 0;
  do
  {
    v8 = dev_ctrl(device_num);
    (*(void (__fastcall **)(_DWORD *))(v8 + 40))(v7);
    v7 = (_DWORD *)((char *)v7 + 1);
    device_num = runtime_ctrl(a1);
    if ( !device_num )
    {
      V_LOCK();
      logfmt_raw((char *)v59, 0x1000u, 0, "runtime ctrl error!");
      V_UNLOCK();
      v52 = 80;
      v53 = 593;
      goto LABEL_33;
    }
  }
  while ( v6 != v7 );
  do
  {
    v9 = V_LOCK();
    v10 = dev_ctrl(v9);
    v11 = (*(int (__fastcall **)(int))(v10 + 48))(v4);
    logfmt_raw((char *)v59, 0x1000u, 0, "eeprom add device :%d", v11);
    V_UNLOCK();
    v12 = zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/machine_runtime/machine_runtime_base.c",
            166,
            "hardware_init",
            13,
            600,
            60,
            v59);
    v13 = dev_ctrl(v12);
    v14 = ((__int64 (__fastcall *)(int))*(_DWORD *)(v13 + 48))(v4++);
    add_eeprom_device(v14, SHIDWORD(v14));
  }
  while ( (_DWORD *)v4 != v7 );
  v15 = eeprom_load();
  if ( v15 )
  {
    V_LOCK();
    logfmt_raw((char *)v59, 0x1000u, 0, "EEPROM load error!, pls check it");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/machine_runtime/machine_runtime_base.c",
      166,
      "hardware_init",
      13,
      605,
      100,
      v59);
    return 32;
  }
  v16 = 0;
  dest = a1;
  while ( 2 )
  {
    while ( 2 )
    {
      eeprom_chain_load_state = api_get_eeprom_chain_load_state(v16);
      v18 = eeprom_chain_load_state;
      if ( eeprom_chain_load_state == -1 )
      {
        v49 = V_LOCK();
        v50 = dev_ctrl(v49);
        v51 = (*(int (__fastcall **)(int))(v50 + 48))(v16);
        logfmt_raw((char *)v59, 0x1000u, 0, "g_eeprom_data is not ready, chain = %d", v51);
        V_UNLOCK();
        ++v15;
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/machine_runtime/machine_runtime_base.c",
          166,
          "hardware_init",
          13,
          621,
          100,
          v59);
LABEL_12:
        if ( (_DWORD *)++v16 == v7 )
          goto LABEL_16;
        continue;
      }
      break;
    }
    if ( eeprom_chain_load_state )
      goto LABEL_12;
    v19 = V_LOCK();
    v20 = dev_ctrl(v19);
    v21 = (*(int (__fastcall **)(int))(v20 + 48))(v16++);
    logfmt_raw((char *)v59, 0x1000u, v18, "Chain%d load EEPROM error.", v21);
    V_UNLOCK();
    ++v15;
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/machine_runtime/machine_runtime_base.c",
      166,
      "hardware_init",
      13,
      624,
      100,
      v59);
    if ( (_DWORD *)v16 != v7 )
      continue;
    break;
  }
LABEL_16:
  if ( v15 )
  {
    V_LOCK();
    logfmt_raw((char *)v59, 0x1000u, 0, "Error! EEPROM data corrupted. pls check it");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/machine_runtime/machine_runtime_base.c",
      166,
      "hardware_init",
      13,
      646,
      100,
      v59);
    return 32;
  }
  else
  {
    opt_custom_freq = eeprom_get_min_freq();
    opt_custom_voltage = eeprom_get_max_voltage();
    V_LOCK();
    logfmt_raw((char *)v59, 0x1000u, 0, "MAX voltage: %d", opt_custom_voltage);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/machine_runtime/machine_runtime_base.c",
      166,
      "hardware_init",
      13,
      670,
      40,
      v59);
    V_LOCK();
    logfmt_raw((char *)v59, 0x1000u, 0, "MIN freq: %d", opt_custom_freq);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/machine_runtime/machine_runtime_base.c",
      166,
      "hardware_init",
      13,
      671,
      40,
      v59);
    v22 = *(const char **)&aSetBaudBase_0[4 * dest + 192];
    v23 = (char *)calloc(1u, 8u);
    v24 = strchr(v22, 95);
    v25 = v24 - v22;
    if ( v24 )
      v26 = v24 - v22 <= 7;
    else
      v26 = 0;
    if ( v26 )
      strncpy(v23, v22, v25);
    desta = (char *)calloc(1u, 8u);
    v27 = strchr(v22, 95);
    if ( v27 )
    {
      v28 = strlen(v22);
      if ( v28 - strlen(v27) <= 7 )
        strcpy(desta, v27 + 1);
    }
    v29 = 0;
    LOWORD(v57) = 0;
    str2hex((int)&v57, (int)desta, 4);
    v59[0] = 0;
    all_created_runtime = (char *)get_all_created_runtime(v59);
    if ( v59[0] > 0 )
    {
      v31 = all_created_runtime - 4;
      do
      {
        v32 = *((_DWORD *)v31 + 1);
        v31 += 4;
        strcpy((char *)(v32 + 264), v23);
        *(_DWORD *)(*(_DWORD *)v31 + 272) = (unsigned __int16)__rev16((unsigned __int16)v57);
        is_adjustable_power = platform_is_adjustable_power();
        v34 = *(_DWORD *)v31;
        *(_DWORD *)(*(_DWORD *)v31 + 928) = is_adjustable_power;
        chain_sensor_num = platform_get_chain_sensor_num(v29);
        v36 = *(_DWORD *)v31;
        *(_DWORD *)(v34 + 340) = chain_sensor_num;
        sensor_max_chip_temp = platform_get_sensor_max_chip_temp(v29);
        v38 = *(_DWORD *)v31;
        *(_DWORD *)(v36 + 344) = sensor_max_chip_temp;
        sensor_max_pcb_temp = platform_get_sensor_max_pcb_temp(v29);
        v40 = *(_DWORD *)v31;
        *(_DWORD *)(v38 + 348) = sensor_max_pcb_temp;
        sensor_min_pcb_temp = platform_get_sensor_min_pcb_temp(v29);
        v42 = *(_DWORD *)v31;
        *(_DWORD *)(v40 + 352) = sensor_min_pcb_temp;
        *(_DWORD *)(v42 + 356) = platform_get_sensor_max_uneffective_count(v29++);
      }
      while ( v29 < v59[0] );
    }
    free(v23);
    free(desta);
    psu_gpio_port = platform_get_psu_gpio_port();
    set_bitmain_power_gpio_port(psu_gpio_port);
    v57 = 0;
    v44 = (char *)get_all_created_runtime(&v57);
    if ( v57 > 0 )
    {
      v45 = v44 - 4;
      do
      {
        V_LOCK();
        v46 = *((_DWORD *)v45 + 1);
        v45 += 4;
        logfmt_raw((char *)v59, 0x1000u, 0, "chain[%d] %s", v15, v46 + 264);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/machine_runtime/machine_runtime_base.c",
          166,
          "show_backend_info",
          17,
          39,
          20,
          v59);
        V_LOCK();
        v54 = v15++;
        logfmt_raw((char *)v59, 0x1000u, 0, "chain[%d] %x", v54, *(_DWORD *)(*(_DWORD *)v45 + 272));
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/machine_runtime/machine_runtime_base.c",
          166,
          "show_backend_info",
          17,
          40,
          20,
          v59);
      }
      while ( v15 < v57 );
    }
    return 0;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4AB8C: using guessed type int __fastcall dev_ctrl(_DWORD);
// 107B2C: using guessed type int opt_custom_freq;
// 107B30: using guessed type int opt_custom_voltage;
// 11A7AC: using guessed type int g_zc;

//----- (0003D264) --------------------------------------------------------
void *__fastcall machine_runtime_init(int a1, int a2)
{
  void *result; // r0
  char v4[4100]; // [sp+10h] [bp-1004h] BYREF

  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "machine_runtime_init");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/machine_runtime/machine_runtime_interface.c",
    171,
    "machine_runtime_init",
    20,
    23,
    60,
    v4);
  switch ( a2 )
  {
    case 1:
      result = machine_runtime_ctrl_ckb_2042();
      break;
    case 2:
      result = machine_runtime_ctrl_kda_2110();
      break;
    case 3:
      result = machine_runtime_ctrl_hns_2130();
      break;
    case 4:
      result = machine_runtime_ctrl_dcr_1727();
      break;
    case 5:
      result = machine_runtime_ctrl_dash_1766();
      break;
    default:
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, "not support miner type: %d", 1);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/machine_runtime/machine_runtime_interface.c",
        171,
        "machine_runtime_init",
        20,
        43,
        100,
        v4);
      result = 0;
      break;
  }
  return result;
}
// 3D2E0: control flows out of bounds to 3D2E4
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0003D3BC) --------------------------------------------------------
void __fastcall machine_runtime_exit(void *ptr)
{
  if ( ptr )
    free(ptr);
}

//----- (0003D3C8) --------------------------------------------------------
int __fastcall diff_to_target_ckb(int a1)
{
  return diff_to_be256_target_base(a1);
}

//----- (0003D3DC) --------------------------------------------------------
int __fastcall target_to_double_diff_ckb(unsigned __int64 *a1)
{
  return be256_target_to_double_diff_base(a1);
}

//----- (0003D3F0) --------------------------------------------------------
int __fastcall le256_target_to_double_diff_base_0(__int64 *a1)
{
  sub_DD46C(a1[3]);
  sub_DD46C(a1[2]);
  sub_DD46C(a1[1]);
  return sub_DD46C(*a1);
}

//----- (0003D488) --------------------------------------------------------
int __fastcall diff_to_target_dash(unsigned __int64 *a1)
{
  double v1; // d0
  __int64 v3; // r6
  double v4; // r0
  double v5; // d8
  __int64 v6; // kr00_8
  double v7; // r0
  double v8; // d8
  __int64 v9; // kr08_8
  double v10; // r0
  unsigned __int64 v11; // r0
  __int64 v12; // r0
  __int64 v13; // r2
  _QWORD v15[2]; // [sp+10h] [bp-1004h] BYREF
  __int64 v16; // [sp+20h] [bp-FF4h]
  __int64 v17; // [sp+28h] [bp-FECh]

  if ( v1 <= 0.0 )
  {
    V_LOCK();
    logfmt_raw((char *)v15, 0x1000u, 0, 929612);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/dhash_content/dash/dash_dhash_common.c",
      166,
      "diff_to_target_dash",
      19,
      58,
      20,
      v15);
    v3 = 4294901760LL;
    v11 = 0;
    v6 = 0;
    v9 = 0;
  }
  else
  {
    v3 = (unsigned __int64)(2.69595353e67 / v1 * 1.59309191e-58);
    LODWORD(v4) = sub_DD46C(v3);
    v5 = 2.69595353e67 / v1 - v4 * 6.27710174e57;
    v6 = (unsigned __int64)(v5 * 2.93873588e-39);
    LODWORD(v7) = sub_DD46C(v6);
    v8 = v5 - v7 * 3.40282367e38;
    v9 = (unsigned __int64)(v8 * 5.42101086e-20);
    LODWORD(v10) = sub_DD46C(v9);
    v11 = (unsigned __int64)(v8 - v10 * 1.84467441e19);
  }
  v17 = v3;
  v16 = v6;
  v15[1] = v9;
  v15[0] = v11;
  *a1 = v11;
  a1[1] = v9;
  v12 = v16;
  v13 = v17;
  a1[2] = v16;
  a1[3] = v13;
  return v12;
}
// 3D4A4: variable 'v1' is possibly undefined
// 3D4DC: variable 'v4' is possibly undefined
// 3D504: variable 'v7' is possibly undefined
// 3D528: variable 'v10' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0003D648) --------------------------------------------------------
int __fastcall le256_target_to_diff_base_0(int a1)
{
  int v1; // r1
  int v2; // r4
  int v3; // r3
  int v4; // lr
  int v5; // t1
  int v6; // r2

  v1 = 0;
  v2 = a1 + 32;
LABEL_2:
  v3 = 7;
  v5 = *(unsigned __int8 *)--v2;
  v4 = v5;
  while ( 1 )
  {
    v6 = v4 >> v3--;
    if ( (v6 & 1) != 0 )
      return v1;
    v1 = (unsigned __int8)(v1 + 1);
    if ( v3 == -1 )
    {
      if ( v2 != a1 )
        goto LABEL_2;
      return v1;
    }
  }
}

//----- (0003D690) --------------------------------------------------------
int __fastcall target_to_double_diff_dcr(unsigned __int64 *a1)
{
  return be256_target_to_double_diff_base(a1);
}

//----- (0003D6A0) --------------------------------------------------------
void *__fastcall diff_to_target_dcr(char *a1)
{
  double v1; // d0
  int v3; // r4
  double v4; // d0
  char *v5; // r8
  int v6; // r4
  unsigned __int64 v7; // r6
  void *result; // r0
  int v9; // r4

  if ( v1 <= 1.0 )
  {
    v7 = (unsigned __int64)(4294901760.0 / v1);
    if ( !v7 )
      return memset(a1, 255, 0x20u);
    v3 = 6;
  }
  else
  {
    v3 = 5;
    v4 = v1 * 2.32830644e-10;
    while ( v4 > 1.0 )
    {
      --v3;
      v4 = v4 * 2.32830644e-10;
      if ( !v3 )
      {
        v5 = a1;
        v6 = 4;
        v7 = (unsigned __int64)(4294901760.0 / v4);
        goto LABEL_6;
      }
    }
    v7 = (unsigned __int64)(4294901760.0 / v4);
  }
  v9 = 4 * v3;
  v5 = &a1[v9];
  v6 = v9 + 4;
LABEL_6:
  result = memset(a1, 0, 0x20u);
  *(_DWORD *)v5 = v7;
  *(_DWORD *)&a1[v6] = HIDWORD(v7);
  return result;
}
// 3D6B4: variable 'v1' is possibly undefined

//----- (0003D790) --------------------------------------------------------
int __fastcall target_to_diff_dcr(int a1)
{
  int v1; // r1
  int v2; // r4
  int v3; // r3
  int v4; // lr
  int v5; // t1
  int v6; // r2

  v1 = 0;
  v2 = a1 + 32;
LABEL_2:
  v3 = 7;
  v5 = *(unsigned __int8 *)--v2;
  v4 = v5;
  while ( 1 )
  {
    v6 = v4 >> v3--;
    if ( (v6 & 1) != 0 )
      return v1;
    v1 = (unsigned __int8)(v1 + 1);
    if ( v3 == -1 )
    {
      if ( v2 != a1 )
        goto LABEL_2;
      return v1;
    }
  }
}

//----- (0003D7D4) --------------------------------------------------------
_DWORD *__fastcall dhash_content_init(int a1)
{
  _DWORD *result; // r0

  switch ( a1 )
  {
    case 1:
      result = dhash_content_ckb_2042();
      break;
    case 2:
      result = dhash_content_kda_2110();
      break;
    case 3:
      result = dhash_content_hns_2130();
      break;
    case 4:
      result = dhash_content_dcr_1727();
      break;
    case 5:
      result = dhash_content_ltc_1489();
      break;
    default:
      result = 0;
      break;
  }
  return result;
}
// 3D7E0: control flows out of bounds to 3D7E4

//----- (0003D814) --------------------------------------------------------
void __fastcall dhash_content_exit(void *ptr)
{
  if ( ptr )
    free(ptr);
}

//----- (0003D820) --------------------------------------------------------
int sub_3D820()
{
  int result; // r0
  int v1; // r2

  result = 0;
  v1 = dword_108770 + 1;
  if ( (unsigned int)(dword_108770 + 1) >= 0x4000 )
    v1 = 0;
  dword_108770 = v1;
  return result;
}
// 108770: using guessed type int dword_108770;

//----- (0003D844) --------------------------------------------------------
int __fastcall sub_3D844(_DWORD *a1, __int64 *a2)
{
  __int64 v2; // r2
  const char *v5; // r1
  int v6; // r12
  int v7; // r0
  int v8; // r1
  int v9; // r2
  int v10; // r3
  int v11; // r1
  int v12; // r2
  int v13; // r3
  __int64 *v14; // r12
  int v15; // r0
  int v16; // r1
  int v17; // r2
  int v18; // r3
  void (__fastcall *v19)(_DWORD *, __int64 *); // r5
  int v20; // r0
  int v21; // r1
  _BYTE v23[256]; // [sp+10h] [bp-1274h] BYREF
  __int64 v24; // [sp+110h] [bp-1174h] BYREF
  char dest[32]; // [sp+118h] [bp-116Ch] BYREF
  _BYTE v26[256]; // [sp+138h] [bp-114Ch] BYREF
  int v27; // [sp+238h] [bp-104Ch]
  int v28; // [sp+23Ch] [bp-1048h]
  int v29; // [sp+240h] [bp-1044h]
  int v30; // [sp+244h] [bp-1040h]
  int v31; // [sp+248h] [bp-103Ch]
  int v32; // [sp+24Ch] [bp-1038h]
  int v33; // [sp+250h] [bp-1034h]
  int v34; // [sp+254h] [bp-1030h]
  int v35; // [sp+258h] [bp-102Ch]
  int v36; // [sp+25Ch] [bp-1028h]
  int v37; // [sp+260h] [bp-1024h]
  int v38; // [sp+264h] [bp-1020h]
  int v39; // [sp+268h] [bp-101Ch]
  int v40; // [sp+26Ch] [bp-1018h]
  int v41; // [sp+270h] [bp-1014h]
  char v42[4100]; // [sp+280h] [bp-1004h] BYREF

  v2 = *a2;
  v5 = (const char *)*((_DWORD *)a2 + 281);
  v24 = v2;
  strcpy(dest, v5);
  memcpy(v23, a2 + 1, sizeof(v23));
  v6 = a1[49];
  v23[120] = dword_108770;
  v23[121] = BYTE1(dword_108770) | ((_BYTE)v6 << 6);
  memcpy(v26, v23, sizeof(v26));
  v7 = be256_target_to_diff_base_0((int)(a2 + 129));
  v8 = *((_DWORD *)a2 + 259);
  v9 = *((_DWORD *)a2 + 260);
  v10 = *((_DWORD *)a2 + 261);
  v27 = v7;
  v28 = *((_DWORD *)a2 + 258);
  v29 = v8;
  v30 = v9;
  v31 = v10;
  v11 = *((_DWORD *)a2 + 263);
  v12 = *((_DWORD *)a2 + 264);
  v13 = *((_DWORD *)a2 + 265);
  v32 = *((_DWORD *)a2 + 262);
  v33 = v11;
  v34 = v12;
  v35 = v13;
  V_LOCK();
  logfmt_raw(v42, 0x1000u, 0, "start nonce: %08x target_diff: %d", dword_108770, v27);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/dhash_content/hns/hns_2130/hns_2130_content.c",
    173,
    "push_work_hns_2130",
    18,
    44,
    20,
    v42);
  v14 = a2 + 136;
  v15 = *((_DWORD *)a2 + 275);
  v16 = *((_DWORD *)a2 + 276);
  v17 = *((_DWORD *)a2 + 277);
  v18 = *((_DWORD *)a2 + 278);
  v19 = (void (__fastcall *)(_DWORD *, __int64 *))a1[6];
  v36 = v15;
  v37 = v16;
  v38 = v17;
  v39 = v18;
  v20 = *((_DWORD *)v14 + 7);
  v21 = *((_DWORD *)v14 + 8);
  a1[109] = 0;
  v40 = v20;
  v41 = v21;
  v19(a1, &v24);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 108770: using guessed type int dword_108770;
// 11A7AC: using guessed type int g_zc;

//----- (0003D9B4) --------------------------------------------------------
int __fastcall sub_3D9B4(_DWORD *a1, int a2, int a3)
{
  size_t *v3; // r3
  int v4; // r1

  v3 = (size_t *)a1[283];
  v4 = *(_DWORD *)(a3 + 48);
  a1[269] = 0;
  a1[268] = v4;
  if ( v3 )
  {
    memcpy(v3 + 1, (const void *)(a3 + 52), *v3);
    return 0;
  }
  else
  {
    printf("invalid pointer(%s)!\n", "private");
    return 3;
  }
}

//----- (0003DA08) --------------------------------------------------------
_DWORD *dhash_content_hns_2130()
{
  _DWORD *result; // r0

  result = calloc(1u, 0x14u);
  *result = sub_3D820;
  result[1] = sub_3D844;
  result[2] = sub_3D9B4;
  result[3] = "H";
  result[4] = 60;
  return result;
}
// 3D844: using guessed type int sub_3D844();

//----- (0003DA40) --------------------------------------------------------
int __fastcall diff_to_target_hns(int a1)
{
  return diff_to_be256_target_base(a1);
}

//----- (0003DA54) --------------------------------------------------------
int __fastcall target_to_double_diff_hns(unsigned __int64 *a1)
{
  return be256_target_to_double_diff_base(a1);
}

//----- (0003DA68) --------------------------------------------------------
int __fastcall be256_target_to_diff_base_0(int a1)
{
  int v1; // r1
  int v2; // r4
  int v3; // r0
  int v4; // r3
  int v5; // lr
  int v6; // t1
  int v7; // r2

  v1 = 0;
  v2 = a1 - 1;
  v3 = a1 + 31;
LABEL_2:
  v4 = 7;
  v6 = *(unsigned __int8 *)++v2;
  v5 = v6;
  while ( 1 )
  {
    v7 = v5 >> v4--;
    if ( (v7 & 1) != 0 )
      return v1;
    v1 = (unsigned __int8)(v1 + 1);
    if ( v4 == -1 )
    {
      if ( v2 != v3 )
        goto LABEL_2;
      return v1;
    }
  }
}

//----- (0003DAB0) --------------------------------------------------------
int __fastcall target_to_diff_word_hns(int a1)
{
  int v1; // r1
  int v2; // r4
  int v3; // r3
  int v4; // lr
  int v5; // t1
  int v6; // r2

  v1 = 0;
  v2 = a1 + 32;
LABEL_2:
  v3 = 7;
  v5 = *(unsigned __int8 *)--v2;
  v4 = v5;
  while ( 1 )
  {
    v6 = v4 >> v3--;
    if ( (v6 & 1) != 0 )
      return v1;
    v1 = (unsigned __int8)(v1 + 1);
    if ( v3 == -1 )
    {
      if ( v2 != a1 )
        goto LABEL_2;
      return v1;
    }
  }
}

//----- (0003DAF4) --------------------------------------------------------
int __fastcall sub_3DAF4(int a1, const char **a2)
{
  size_t *v2; // r6
  __int64 v3; // r2
  int *v4; // r4
  const char **v6; // r5
  const char *v7; // r1
  size_t v8; // r8
  int v9; // r0
  int v10; // r1
  int v11; // r2
  int v12; // r3
  int v13; // r3
  int v14; // r1
  int v15; // r2
  void (__fastcall *v16)(int, __int64 *); // r3
  __int64 v18; // [sp+0h] [bp-194h] BYREF
  char dest[64]; // [sp+8h] [bp-18Ch] BYREF
  _BYTE v20[286]; // [sp+48h] [bp-14Ch] BYREF
  int v21; // [sp+168h] [bp-2Ch]
  int v22; // [sp+16Ch] [bp-28h]
  int v23; // [sp+170h] [bp-24h]
  int v24; // [sp+174h] [bp-20h]
  int v25; // [sp+178h] [bp-1Ch]
  int v26; // [sp+17Ch] [bp-18h]
  int v27; // [sp+180h] [bp-14h]
  int v28; // [sp+184h] [bp-10h]
  int v29; // [sp+188h] [bp-Ch]
  __int16 v30; // [sp+18Ch] [bp-8h] BYREF
  char v31; // [sp+18Eh] [bp-6h]

  v2 = (size_t *)a2[283];
  if ( v2 )
  {
    v3 = *(_QWORD *)a2;
    v4 = (int *)(a2 + 258);
    v6 = a2;
    v7 = a2[281];
    v8 = *v2;
    v18 = v3;
    strcpy(dest, v7);
    v9 = target_to_diff_kda(v4);
    v10 = v4[1];
    v11 = v4[2];
    v6 += 2;
    v12 = v4[3];
    v21 = v9;
    v22 = *v4;
    v23 = v10;
    v24 = v11;
    v25 = v12;
    v13 = v4[7];
    v14 = v4[5];
    v15 = v4[6];
    v26 = v4[4];
    v27 = v14;
    v28 = v15;
    v29 = v13;
    memcpy(&v30, v2 + 1, *v2);
    memcpy((char *)&v30 + *v2, (char *)v6 + v8 + 283, 3 - v8);
    memcpy(v20, v6, sizeof(v20));
    *(_WORD *)&v20[283] = v30;
    v16 = *(void (__fastcall **)(int, __int64 *))(a1 + 24);
    v20[285] = v31;
    v16(a1, &v18);
    return 0;
  }
  else
  {
    printf("invalid pointer(%s)!\n", "private");
    return 3;
  }
}

//----- (0003DC08) --------------------------------------------------------
int __fastcall sub_3DC08(int a1, pthread_mutex_t *a2, int a3)
{
  size_t *v3; // r6
  pthread_mutex_t *v6; // r8
  int owner; // r3
  char *v8; // r0
  int spins; // lr
  int lock; // r12
  int count; // r1
  int kind; // lr
  int nusers; // r12
  int v14; // r1
  char v16[4100]; // [sp+10h] [bp-1004h] BYREF

  v3 = *(size_t **)(a1 + 1132);
  if ( v3 )
  {
    v6 = a2 + 19;
    if ( a3 && memcmp(&unk_108778, &a2[19], 0x116u) )
    {
      qword_108898 = 0;
      memcpy(&unk_108778, v6, 0x11Eu);
    }
    pthread_mutex_lock(a2 + 66);
    owner = a2[3].__owner;
    if ( owner && owner == *v3 )
    {
      V_LOCK();
      logfmt_raw(v16, 0x1000u, 0, "pool->xnonce2_size: %d, private->xnonce2_len:%d", a2[3].__owner, *v3);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/dhash_content/kda/kda_2110/kda_2110_content.c",
        173,
        "pre_push_work_kda_2110",
        22,
        40,
        20,
        v16);
      memcpy(v3 + 1, &qword_108898, *v3);
      if ( (unsigned __int64)qword_108898 > 0xFF )
        qword_108898 = 0;
      else
        ++qword_108898;
    }
    v8 = (char *)memcpy((void *)(a1 + 8), v6, 0x11Eu);
    memcpy(&v8[286 - a2[3].__lock], (const void *)a2[3].__count, a2[3].__lock);
    spins = a2[61].__spins;
    lock = a2[62].__lock;
    count = a2[62].__count;
    *(_DWORD *)(a1 + 1032) = a2[61].__nusers;
    *(_DWORD *)(a1 + 1036) = spins;
    *(_DWORD *)(a1 + 1040) = lock;
    *(_DWORD *)(a1 + 1044) = count;
    kind = a2[62].__kind;
    nusers = a2[62].__nusers;
    v14 = a2[62].__spins;
    *(_DWORD *)(a1 + 1048) = a2[62].__owner;
    *(_DWORD *)(a1 + 1052) = kind;
    *(_DWORD *)(a1 + 1056) = nusers;
    *(_DWORD *)(a1 + 1060) = v14;
    *(_QWORD *)a1 = a2->__lock;
    pthread_mutex_unlock(a2 + 66);
    return 0;
  }
  else
  {
    printf("invalid pointer(%s)!\n", "private");
    return 3;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 108898: using guessed type __int64 qword_108898;
// 11A7AC: using guessed type int g_zc;

//----- (0003DE08) --------------------------------------------------------
int __fastcall sub_3DE08(_DWORD *a1, int a2, int a3)
{
  _DWORD *v3; // r6
  char *v5; // r0

  v3 = (_DWORD *)a1[283];
  if ( v3 )
  {
    v5 = (char *)a1[281];
    if ( v5 )
    {
      if ( a3 != -16 )
        strcpy(v5, (const char *)(a3 + 16));
    }
    memcpy(a1 + 268, (const void *)(a3 + 80), *v3 + 5);
    return 0;
  }
  else
  {
    printf("invalid pointer(%s)!\n", "private");
    return 3;
  }
}

//----- (0003DE70) --------------------------------------------------------
_DWORD *dhash_content_kda_2110()
{
  _DWORD *result; // r0

  result = calloc(1u, 0x14u);
  *result = sub_3DC08;
  result[1] = sub_3DAF4;
  result[2] = sub_3DE08;
  result[3] = "H";
  result[4] = 60;
  return result;
}
// 3DAF4: using guessed type int sub_3DAF4();
// 3DC08: using guessed type int sub_3DC08();

//----- (0003DEA8) --------------------------------------------------------
int __fastcall target_to_double_diff_kda(_DWORD *a1)
{
  int v1; // r1
  __int64 *v2; // lr
  int v3; // r2
  int v4; // r3
  int v5; // r1
  int v6; // r2
  int v7; // r3
  __int64 *v8; // r12
  char v9; // r3
  __int64 v11; // [sp+0h] [bp-20h] BYREF
  int v12; // [sp+8h] [bp-18h]
  int v13; // [sp+Ch] [bp-14h]
  int v14; // [sp+10h] [bp-10h]
  int v15; // [sp+14h] [bp-Ch]
  int v16; // [sp+18h] [bp-8h]
  int v17; // [sp+1Ch] [bp-4h] BYREF

  v1 = a1[1];
  v2 = &v11;
  v3 = a1[2];
  v4 = a1[3];
  LODWORD(v11) = *a1;
  HIDWORD(v11) = v1;
  v12 = v3;
  v13 = v4;
  v5 = a1[5];
  v6 = a1[6];
  v7 = a1[7];
  v8 = (__int64 *)((char *)&v17 + 3);
  v14 = a1[4];
  v15 = v5;
  v16 = v6;
  v17 = v7;
  do
  {
    v9 = *(_BYTE *)v2;
    *(_BYTE *)v2 = *(_BYTE *)v8;
    v2 = (__int64 *)((char *)v2 + 1);
    *(_BYTE *)v8 = v9;
    v8 = (__int64 *)((char *)v8 - 1);
  }
  while ( v2 < v8 );
  return le256_target_to_double_diff_base(&v11);
}

//----- (0003DF20) --------------------------------------------------------
int __fastcall diff_to_target_kda(_DWORD *a1)
{
  unsigned __int64 *v2; // r2
  unsigned __int64 *v3; // r3
  char v4; // r1
  int v5; // r1
  int v6; // r2
  int v7; // r3
  int result; // r0
  int v9; // r1
  int v10; // r2
  int v11; // r3
  unsigned __int64 v12; // [sp+0h] [bp-80h] BYREF
  int v13; // [sp+8h] [bp-78h]
  int v14; // [sp+Ch] [bp-74h]
  int v15; // [sp+10h] [bp-70h]
  int v16; // [sp+14h] [bp-6Ch]
  int v17; // [sp+18h] [bp-68h]
  int v18; // [sp+1Ch] [bp-64h] BYREF

  diff_to_le256_target_base(&v12);
  v2 = &v12;
  v3 = (unsigned __int64 *)((char *)&v18 + 3);
  do
  {
    v4 = *(_BYTE *)v2;
    *(_BYTE *)v2 = *(_BYTE *)v3;
    v2 = (unsigned __int64 *)((char *)v2 + 1);
    *(_BYTE *)v3 = v4;
    v3 = (unsigned __int64 *)((char *)v3 - 1);
  }
  while ( v2 < v3 );
  v5 = HIDWORD(v12);
  v6 = v13;
  v7 = v14;
  *a1 = v12;
  a1[1] = v5;
  a1[2] = v6;
  a1[3] = v7;
  result = v15;
  v9 = v16;
  v10 = v17;
  v11 = v18;
  a1[4] = v15;
  a1[5] = v9;
  a1[6] = v10;
  a1[7] = v11;
  return result;
}

//----- (0003DF98) --------------------------------------------------------
int __fastcall target_to_diff_kda(_DWORD *a1)
{
  int v1; // r1
  int v2; // r2
  char *v3; // lr
  int v4; // r3
  int v5; // r1
  int v6; // r2
  int v7; // r3
  char *v8; // r12
  char v9; // r3
  char *v10; // lr
  int result; // r0
  int v12; // r12
  int v13; // t1
  int v14; // r3
  int v15; // r2
  _DWORD v16[7]; // [sp+0h] [bp-24h] BYREF
  int v17; // [sp+1Ch] [bp-8h] BYREF
  char v18; // [sp+20h] [bp-4h] BYREF

  v1 = a1[1];
  v2 = a1[2];
  v3 = (char *)v16;
  v4 = a1[3];
  v16[0] = *a1;
  v16[1] = v1;
  v16[2] = v2;
  v16[3] = v4;
  v5 = a1[5];
  v6 = a1[6];
  v7 = a1[7];
  v8 = (char *)&v17 + 3;
  v16[4] = a1[4];
  v16[5] = v5;
  v16[6] = v6;
  v17 = v7;
  do
  {
    v9 = *v3;
    *v3++ = *v8;
    *v8-- = v9;
  }
  while ( v3 < v8 );
  v10 = &v18;
  result = 0;
LABEL_4:
  v13 = (unsigned __int8)*--v10;
  v12 = v13;
  v14 = 7;
  while ( 1 )
  {
    v15 = v12 >> v14--;
    if ( (v15 & 1) != 0 )
      return result;
    result = (unsigned __int8)(result + 1);
    if ( v14 == -1 )
    {
      if ( v10 != (char *)v16 )
        goto LABEL_4;
      return result;
    }
  }
}

//----- (0003E038) --------------------------------------------------------
int __fastcall le256todouble(__int64 *a1)
{
  sub_DD46C(a1[3]);
  sub_DD46C(a1[2]);
  sub_DD46C(a1[1]);
  return sub_DD46C(*a1);
}

//----- (0003E0B0) --------------------------------------------------------
int __fastcall le256_target_to_double_diff_base(__int64 *a1)
{
  sub_DD46C(a1[3]);
  sub_DD46C(a1[2]);
  sub_DD46C(a1[1]);
  return sub_DD46C(*a1);
}

//----- (0003E140) --------------------------------------------------------
int __fastcall diff_to_le256_target_base(unsigned __int64 *a1)
{
  double v1; // d0
  double v2; // d1
  double v4; // d8
  double v5; // r0
  double v6; // d8
  double v7; // r0
  double v8; // d8
  double v9; // r0
  __int64 v10; // r2
  __int64 v11; // r0
  __int64 v12; // r2
  unsigned __int64 v14; // [sp+10h] [bp-1004h] BYREF
  __int64 v15; // [sp+18h] [bp-FFCh]
  __int64 v16; // [sp+20h] [bp-FF4h]
  __int64 v17; // [sp+28h] [bp-FECh]

  v4 = v2;
  if ( v1 <= 0.0 )
  {
    V_LOCK();
    logfmt_raw((char *)&v14, 0x1000u, 0, 929612);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/dhash_content/base_common.c",
      155,
      "diff_to_le256_target_base",
      25,
      57,
      20,
      &v14);
  }
  else
  {
    v4 = v2 / v1;
  }
  v17 = (unsigned __int64)(v4 * 1.59309191e-58);
  LODWORD(v5) = sub_DD46C(v17);
  v6 = v4 - v5 * 6.27710174e57;
  v16 = (unsigned __int64)(v6 * 2.93873588e-39);
  LODWORD(v7) = sub_DD46C(v16);
  v8 = v6 - v7 * 3.40282367e38;
  v15 = (unsigned __int64)(v8 * 5.42101086e-20);
  LODWORD(v9) = sub_DD46C(v15);
  v14 = (unsigned __int64)(v8 - v9 * 1.84467441e19);
  v10 = v15;
  *a1 = v14;
  a1[1] = v10;
  v11 = v16;
  v12 = v17;
  a1[2] = v16;
  a1[3] = v12;
  return v11;
}
// 3E15C: variable 'v2' is possibly undefined
// 3E160: variable 'v1' is possibly undefined
// 3E190: variable 'v5' is possibly undefined
// 3E1B4: variable 'v7' is possibly undefined
// 3E1D4: variable 'v9' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0003E2B8) --------------------------------------------------------
int __fastcall le256_target_to_diff_base(int a1)
{
  int v1; // r1
  int v2; // r4
  int v3; // r3
  int v4; // lr
  int v5; // t1
  int v6; // r2

  v1 = 0;
  v2 = a1 + 32;
LABEL_2:
  v3 = 7;
  v5 = *(unsigned __int8 *)--v2;
  v4 = v5;
  while ( 1 )
  {
    v6 = v4 >> v3--;
    if ( (v6 & 1) != 0 )
      return v1;
    v1 = (unsigned __int8)(v1 + 1);
    if ( v3 == -1 )
    {
      if ( v2 != a1 )
        goto LABEL_2;
      return v1;
    }
  }
}

//----- (0003E2FC) --------------------------------------------------------
int __fastcall be256todouble(unsigned __int64 *a1)
{
  sub_DD46C(_byteswap_uint64(*a1));
  sub_DD46C(_byteswap_uint64(a1[1]));
  sub_DD46C(_byteswap_uint64(a1[2]));
  return sub_DD46C(_byteswap_uint64(a1[3]));
}

//----- (0003E398) --------------------------------------------------------
int __fastcall be256_target_to_double_diff_base(unsigned __int64 *a1)
{
  sub_DD46C(_byteswap_uint64(*a1));
  sub_DD46C(_byteswap_uint64(a1[1]));
  sub_DD46C(_byteswap_uint64(a1[2]));
  return sub_DD46C(_byteswap_uint64(a1[3]));
}

//----- (0003E448) --------------------------------------------------------
int __fastcall diff_to_be256_target_base(int a1)
{
  double v1; // d0
  double v2; // d1
  double v4; // d8
  unsigned __int64 v5; // r0
  double v6; // r0
  double v7; // d8
  unsigned __int64 v8; // r0
  double v9; // r0
  double v10; // d8
  unsigned __int64 v11; // r0
  double v12; // r0
  unsigned __int64 v13; // r0
  unsigned int v14; // r2
  unsigned int v15; // r3
  unsigned __int64 v16; // r0
  unsigned int v17; // r2
  unsigned int v18; // r3
  unsigned int v20; // [sp+10h] [bp-1004h] BYREF
  unsigned int v21; // [sp+14h] [bp-1000h]
  unsigned int v22; // [sp+18h] [bp-FFCh]
  unsigned int v23; // [sp+1Ch] [bp-FF8h]
  unsigned __int64 v24; // [sp+20h] [bp-FF4h]
  unsigned int v25; // [sp+28h] [bp-FECh]
  unsigned int v26; // [sp+2Ch] [bp-FE8h]

  v4 = v2;
  if ( v1 <= 0.0 )
  {
    V_LOCK();
    logfmt_raw((char *)&v20, 0x1000u, 0, 929612);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/dhash_content/base_common.c",
      155,
      "diff_to_be256_target_base",
      25,
      169,
      20,
      &v20);
  }
  else
  {
    v4 = v2 / v1;
  }
  v5 = (unsigned __int64)(v4 * 1.59309191e-58);
  v20 = bswap32(HIDWORD(v5));
  v21 = bswap32(v5);
  LODWORD(v6) = sub_DD46C(v5);
  v7 = v4 - v6 * 6.27710174e57;
  v8 = (unsigned __int64)(v7 * 2.93873588e-39);
  v23 = bswap32(v8);
  v22 = bswap32(HIDWORD(v8));
  LODWORD(v9) = sub_DD46C(v8);
  v10 = v7 - v9 * 3.40282367e38;
  v11 = (unsigned __int64)(v10 * 5.42101086e-20);
  v24 = _byteswap_uint64(v11);
  LODWORD(v12) = sub_DD46C(v11);
  v13 = (unsigned __int64)(v10 - v12 * 1.84467441e19);
  v26 = bswap32(v13);
  v25 = bswap32(HIDWORD(v13));
  HIDWORD(v13) = v21;
  v14 = v22;
  v15 = v23;
  *(_DWORD *)a1 = v20;
  *(_DWORD *)(a1 + 4) = HIDWORD(v13);
  *(_DWORD *)(a1 + 8) = v14;
  *(_DWORD *)(a1 + 12) = v15;
  v16 = v24;
  v17 = v25;
  v18 = v26;
  *(_QWORD *)(a1 + 16) = v24;
  *(_DWORD *)(a1 + 24) = v17;
  *(_DWORD *)(a1 + 28) = v18;
  return v16;
}
// 3E464: variable 'v2' is possibly undefined
// 3E468: variable 'v1' is possibly undefined
// 3E4A4: variable 'v6' is possibly undefined
// 3E4D4: variable 'v9' is possibly undefined
// 3E500: variable 'v12' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0003E5F4) --------------------------------------------------------
int __fastcall be256_target_to_diff_base(int a1)
{
  int v1; // r1
  int v2; // r4
  int v3; // r0
  int v4; // r3
  int v5; // lr
  int v6; // t1
  int v7; // r2

  v1 = 0;
  v2 = a1 - 1;
  v3 = a1 + 31;
LABEL_2:
  v4 = 7;
  v6 = *(unsigned __int8 *)++v2;
  v5 = v6;
  while ( 1 )
  {
    v7 = v5 >> v4--;
    if ( (v7 & 1) != 0 )
      return v1;
    v1 = (unsigned __int8)(v1 + 1);
    if ( v4 == -1 )
    {
      if ( v2 != v3 )
        goto LABEL_2;
      return v1;
    }
  }
}

//----- (0003E63C) --------------------------------------------------------
int __fastcall sub_3E63C(int a1, __int64 *a2)
{
  __int64 v2; // r2
  int *v5; // r6
  const char *v6; // r1
  char *v7; // r5
  int *v8; // r12
  int v9; // r0
  int v10; // r1
  char *v11; // lr
  int v12; // r2
  int v13; // r3
  int *v14; // r4
  int v15; // r0
  int v16; // r1
  int v17; // r2
  int v18; // r3
  void (__fastcall *v19)(int, __int64 *); // r5
  int v20; // r1
  int v21; // r2
  int v22; // r3
  __int64 v24; // [sp+0h] [bp-84h] BYREF
  char dest[32]; // [sp+8h] [bp-7Ch] BYREF
  char v26; // [sp+28h] [bp-5Ch] BYREF
  int v27; // [sp+58h] [bp-2Ch]
  int v28; // [sp+5Ch] [bp-28h]
  int v29; // [sp+60h] [bp-24h]
  int v30; // [sp+64h] [bp-20h]
  int v31; // [sp+68h] [bp-1Ch]
  int v32; // [sp+6Ch] [bp-18h]
  int v33; // [sp+70h] [bp-14h]
  int v34; // [sp+74h] [bp-10h]
  int v35; // [sp+78h] [bp-Ch]

  v2 = *a2;
  v5 = (int *)(a2 + 7);
  v6 = (const char *)*((_DWORD *)a2 + 281);
  v7 = &v26;
  v24 = v2;
  strcpy(dest, v6);
  v8 = (int *)(a2 + 1);
  do
  {
    v9 = *v8;
    v8 += 4;
    v10 = *(v8 - 3);
    v11 = v7;
    v12 = *(v8 - 2);
    v7 += 16;
    v13 = *(v8 - 1);
    *(_DWORD *)v11 = v9;
    *((_DWORD *)v11 + 1) = v10;
    *((_DWORD *)v11 + 2) = v12;
    *((_DWORD *)v11 + 3) = v13;
  }
  while ( v8 != v5 );
  v14 = (int *)(a2 + 129);
  v15 = target_to_diff_ckb(v14);
  v16 = v14[1];
  v17 = v14[2];
  v18 = v14[3];
  v27 = v15;
  v19 = *(void (__fastcall **)(int, __int64 *))(a1 + 24);
  v28 = *v14;
  v29 = v16;
  v30 = v17;
  v31 = v18;
  v20 = v14[5];
  v21 = v14[6];
  v22 = v14[7];
  v32 = v14[4];
  v33 = v20;
  v34 = v21;
  v35 = v22;
  v19(a1, &v24);
  return 0;
}
// 3D3D8: using guessed type int __fastcall target_to_diff_ckb(_DWORD);

//----- (0003E6F0) --------------------------------------------------------
int __fastcall sub_3E6F0(int a1, int *a2, int a3)
{
  size_t *v3; // r7
  size_t v4; // r8
  size_t v7; // r6
  size_t v8; // r3
  size_t v9; // r10
  int v11; // lr
  int v12; // r12
  int v13; // r1
  int v14; // lr
  int v15; // r12
  int v16; // r1
  size_t v17; // r2
  int v18; // r0
  struct timeval v19; // [sp+0h] [bp-10h] BYREF
  __int64 seed; // [sp+8h] [bp-8h] BYREF

  v3 = *(size_t **)(a1 + 1132);
  if ( v3 )
  {
    v4 = *v3;
    v7 = *v3 - 6;
    v8 = *v3;
    if ( v7 >= 4 )
      v7 = 4;
    v9 = v4 - v7;
    if ( a3 && *((_BYTE *)a2 + 436) )
    {
      dword_1088A0 = 0;
      gettimeofday(&v19, 0);
      LODWORD(seed) = v19.tv_usec + (_DWORD)&unk_F4240 * v19.tv_sec;
      seed = (int)seed;
      v18 = rand_r((unsigned int *)&seed);
      v8 = *v3;
      dword_1088A4 = v18;
    }
    memset(v3 + 1, 0, v8);
    if ( v4 == 6 )
    {
      if ( v9 == 6 )
      {
LABEL_9:
        memcpy((void *)(a1 + 40), (const void *)a2[19], a2[18]);
        memcpy((void *)(a1 + a2[18] + 40), v3 + 1, *v3);
        v11 = a2[371];
        v12 = a2[372];
        v13 = a2[373];
        *(_DWORD *)(a1 + 1032) = a2[370];
        *(_DWORD *)(a1 + 1036) = v11;
        *(_DWORD *)(a1 + 1040) = v12;
        *(_DWORD *)(a1 + 1044) = v13;
        v14 = a2[375];
        v15 = a2[376];
        v16 = a2[377];
        *(_DWORD *)(a1 + 1048) = a2[374];
        *(_DWORD *)(a1 + 1052) = v14;
        *(_DWORD *)(a1 + 1056) = v15;
        *(_DWORD *)(a1 + 1060) = v16;
        *(_QWORD *)a1 = *a2;
        return 0;
      }
    }
    else
    {
      memcpy(v3 + 1, &dword_1088A0, v7);
      ++dword_1088A0;
      if ( v9 == 6 )
        goto LABEL_9;
    }
    v17 = v9 - 6;
    if ( v9 - 6 >= 4 )
      v17 = 4;
    memcpy((char *)v3 + v7 + 4, &dword_1088A4, v17);
    ++dword_1088A4;
    goto LABEL_9;
  }
  printf("invalid pointer(%s)!\n", "private");
  return 3;
}
// 1088A0: using guessed type int dword_1088A0;
// 1088A4: using guessed type int dword_1088A4;

//----- (0003E8A8) --------------------------------------------------------
int __fastcall sub_3E8A8(int a1, int a2, int a3)
{
  const char *v4; // r1
  size_t *v7; // r0

  v4 = *(const char **)(a2 + 1572);
  if ( v4 && strcmp((const char *)(a3 + 16), v4) )
    return 1;
  v7 = *(size_t **)(a1 + 1132);
  if ( v7 )
  {
    memcpy(v7 + 1, (const void *)(a3 + 48 + *(_DWORD *)(a2 + 72)), *v7);
    return 0;
  }
  else
  {
    printf("invalid pointer(%s)!\n", "private");
    return 3;
  }
}

//----- (0003E924) --------------------------------------------------------
_DWORD *dhash_content_ckb_2042()
{
  _DWORD *result; // r0

  result = calloc(1u, 0x14u);
  *result = sub_3E6F0;
  result[1] = sub_3E63C;
  result[2] = sub_3E8A8;
  result[3] = "H";
  result[4] = 60;
  return result;
}

//----- (0003E95C) --------------------------------------------------------
int __fastcall sub_3E95C(int a1, __int64 *a2)
{
  int v2; // r6
  __int64 v3; // r2
  const char *v6; // r1
  int v7; // r0
  int v8; // r1
  int v9; // r2
  int v10; // r3
  void (__fastcall *v11)(int, __int64 *); // r6
  int v12; // r1
  int v13; // r2
  int v14; // r3
  int v15; // r1
  __int64 v17; // [sp+0h] [bp-B4h] BYREF
  char dest[32]; // [sp+8h] [bp-ACh] BYREF
  _BYTE v19[80]; // [sp+28h] [bp-8Ch] BYREF
  int v20; // [sp+78h] [bp-3Ch]
  int v21; // [sp+7Ch] [bp-38h]
  int v22; // [sp+80h] [bp-34h]
  int v23; // [sp+84h] [bp-30h]
  int v24; // [sp+88h] [bp-2Ch]
  int v25; // [sp+8Ch] [bp-28h]
  int v26; // [sp+90h] [bp-24h]
  int v27; // [sp+94h] [bp-20h]
  int v28; // [sp+98h] [bp-1Ch]
  int v29; // [sp+9Ch] [bp-18h]
  int v30; // [sp+A0h] [bp-14h]
  __int64 v31; // [sp+A8h] [bp-Ch]

  v2 = *((_DWORD *)a2 + 283);
  if ( v2 )
  {
    v3 = *a2;
    v6 = (const char *)*((_DWORD *)a2 + 281);
    v17 = v3;
    strcpy(dest, v6);
    v31 = *(_QWORD *)(v2 + 8);
    memcpy(v19, a2 + 1, sizeof(v19));
    v7 = le256_target_to_diff_base_0((int)(a2 + 129));
    v8 = *((_DWORD *)a2 + 259);
    v9 = *((_DWORD *)a2 + 260);
    v10 = *((_DWORD *)a2 + 261);
    v20 = v7;
    v11 = *(void (__fastcall **)(int, __int64 *))(a1 + 24);
    v21 = *((_DWORD *)a2 + 258);
    v22 = v8;
    v23 = v9;
    v24 = v10;
    v12 = *((_DWORD *)a2 + 263);
    v13 = *((_DWORD *)a2 + 264);
    v14 = *((_DWORD *)a2 + 265);
    v25 = *((_DWORD *)a2 + 262);
    v26 = v12;
    v27 = v13;
    v28 = v14;
    v15 = *((_DWORD *)a2 + 276);
    v29 = *((_DWORD *)a2 + 275);
    v30 = v15;
    v11(a1, &v17);
    return 0;
  }
  else
  {
    printf("invalid pointer(%s)!\n", "private");
    return 3;
  }
}

//----- (0003EA34) --------------------------------------------------------
int __fastcall sub_3EA34(int a1, pthread_mutex_t *a2)
{
  int *v2; // r10
  pthread_mutex_t *v3; // r6
  const void *v6; // r7
  size_t owner; // r2
  void *v8; // r0
  int nusers; // r3
  int spins; // r0
  int v11; // r12
  size_t lock; // r1
  int count; // r7
  int v14; // r7
  _DWORD *v15; // lr
  int v16; // r1
  int v17; // r2
  int v18; // r3
  int v19; // r1
  int v20; // r2
  int v21; // r3
  int v22; // r8
  char *v23; // r2
  unsigned int *v24; // r1
  unsigned int v25; // t1
  int v26; // r1
  int v27; // r2
  int v28; // r3
  int v29; // r1
  int v30; // r2
  int v31; // r3
  void *v32; // r0
  int v33; // r3
  unsigned int v35; // [sp+4h] [bp-84h] BYREF
  int v36; // [sp+8h] [bp-80h] BYREF
  int v37; // [sp+Ch] [bp-7Ch]
  int v38; // [sp+10h] [bp-78h]
  int v39; // [sp+14h] [bp-74h]
  int v40; // [sp+18h] [bp-70h]
  int v41; // [sp+1Ch] [bp-6Ch]
  int v42; // [sp+20h] [bp-68h]
  int v43; // [sp+24h] [bp-64h]
  char v44[28]; // [sp+28h] [bp-60h] BYREF
  char v45; // [sp+44h] [bp-44h] BYREF
  int v46; // [sp+48h] [bp-40h] BYREF
  int v47; // [sp+4Ch] [bp-3Ch]
  int v48; // [sp+50h] [bp-38h]
  int v49; // [sp+54h] [bp-34h]
  int v50; // [sp+58h] [bp-30h]
  int v51; // [sp+5Ch] [bp-2Ch]
  int v52; // [sp+60h] [bp-28h]
  _DWORD v53[9]; // [sp+64h] [bp-24h] BYREF

  v2 = *(int **)(a1 + 1132);
  if ( v2 )
  {
    v3 = a2 + 66;
    v6 = &a2[12].__align + 4;
    pthread_mutex_lock(a2 + 66);
    owner = a2[3].__owner;
    v8 = (void *)(a2[12].__count + a2[13].__lock);
    v35 = bswap32(a2[12].__nusers);
    memcpy(v8, v6, owner);
    nusers = a2[12].__nusers;
    spins = a2[12].__spins;
    v11 = a2[3].__owner;
    a2[12].__nusers = nusers + 1;
    a2[12].__spins = __CFADD__(nusers, 1) + spins;
    lock = a2[12].__lock;
    v2[2] = nusers;
    *v2 = v11;
    v2[3] = spins;
    sha256((char *)a2[12].__count, lock, &v46);
    sha256((char *)&v46, 0x20u, &v36);
    count = a2[13].__count;
    v46 = v36;
    v47 = v37;
    v48 = v38;
    v49 = v39;
    v50 = v40;
    v51 = v41;
    v52 = v42;
    v53[0] = v43;
    if ( count > 0 )
    {
      v14 = 0;
      do
      {
        v15 = *(_DWORD **)(a2[13].__owner + 4 * v14++);
        v16 = v15[1];
        v17 = v15[2];
        v18 = v15[3];
        v53[1] = *v15;
        v53[2] = v16;
        v53[3] = v17;
        v53[4] = v18;
        v19 = v15[5];
        v20 = v15[6];
        v21 = v15[7];
        v53[5] = v15[4];
        v53[6] = v19;
        v53[7] = v20;
        v53[8] = v21;
        sha256((char *)&v46, 0x40u, v44);
        sha256(v44, 0x20u, &v36);
        v22 = a2[13].__count;
        v46 = v36;
        v47 = v37;
        v48 = v38;
        v49 = v39;
        v50 = v40;
        v51 = v41;
        v52 = v42;
        v53[0] = v43;
      }
      while ( v22 > v14 );
    }
    v23 = &v45;
    v24 = &v35;
    do
    {
      v25 = *((_DWORD *)v23 + 1);
      v23 += 4;
      v24[1] = bswap32(v25);
      ++v24;
    }
    while ( v23 != (char *)v53 );
    memcpy((void *)(a1 + 8), &a2[6].__align + 4, 0x80u);
    v26 = v37;
    v27 = v38;
    v28 = v39;
    *(_DWORD *)(a1 + 44) = v36;
    *(_DWORD *)(a1 + 48) = v26;
    *(_DWORD *)(a1 + 52) = v27;
    *(_DWORD *)(a1 + 56) = v28;
    v29 = v41;
    v30 = v42;
    v31 = v43;
    *(_DWORD *)(a1 + 60) = v40;
    v32 = *(void **)(a1 + 1124);
    *(_DWORD *)(a1 + 64) = v29;
    *(_DWORD *)(a1 + 68) = v30;
    *(_DWORD *)(a1 + 72) = v31;
    *(_QWORD *)(a1 + 1088) = *((_QWORD *)&a2[18].__align + 1);
    if ( v32 )
    {
      free(v32);
      *(_DWORD *)(a1 + 1124) = 0;
    }
    *(_DWORD *)(a1 + 1124) = _strdup((const char *)a2[65].__kind);
    v33 = a2[14].__nusers;
    *(_DWORD *)(a1 + 1100) = a2[14].__kind;
    *(_DWORD *)(a1 + 1104) = v33;
    *(_QWORD *)a1 = a2->__lock;
    pthread_mutex_unlock(v3);
    return 0;
  }
  else
  {
    printf("invalid pointer(%s)!\n", "private");
    return 3;
  }
}

//----- (0003EC5C) --------------------------------------------------------
int __fastcall sub_3EC5C(_DWORD *a1, int a2, int a3)
{
  int v3; // r5
  const char *v4; // r1
  int v8; // r3

  v3 = a1[283];
  if ( v3 )
  {
    v4 = *(const char **)(a2 + 1572);
    if ( v4 && strcmp((const char *)(a3 + 16), v4) )
    {
      return 1;
    }
    else
    {
      *(_DWORD *)(v3 + 16) = *(_DWORD *)(a3 + 48);
      v8 = *(_DWORD *)(a3 + 58);
      a1[275] = *(_DWORD *)(a3 + 54);
      a1[276] = v8;
      *(_QWORD *)(v3 + 8) = *(_QWORD *)(a3 + 72);
      return 0;
    }
  }
  else
  {
    printf("invalid pointer(%s)!\n", "private");
    return 3;
  }
}

//----- (0003ECE0) --------------------------------------------------------
_DWORD *dhash_content_ltc_1489()
{
  _DWORD *result; // r0

  result = calloc(1u, 0x14u);
  *result = sub_3EA34;
  result[1] = sub_3E95C;
  result[2] = sub_3EC5C;
  result[3] = "H";
  result[4] = 60;
  return result;
}
// 3E95C: using guessed type int sub_3E95C();
// 3EA34: using guessed type int sub_3EA34();

//----- (0003ED38) --------------------------------------------------------
int sub_3ED38()
{
  int result; // r0
  int v1; // r2

  result = 0;
  v1 = dword_1088A8 + 1;
  if ( (unsigned int)(dword_1088A8 + 1) >= 0x400000 )
    v1 = 0;
  dword_1088A8 = v1;
  return result;
}
// 1088A8: using guessed type int dword_1088A8;

//----- (0003ED5C) --------------------------------------------------------
int __fastcall sub_3ED5C(int a1, __int64 *a2)
{
  __int64 v2; // r2
  const char *v4; // r1
  int *v6; // r3
  _BYTE *v7; // r2
  int v8; // r0
  int v9; // lr
  int v10; // r12
  int v11; // r0
  char v12; // r12
  int v13; // r3
  int v14; // r0
  int v15; // r1
  int v16; // r2
  int v17; // r3
  void (__fastcall *v18)(int, __int64 *); // r5
  int v19; // r1
  int v20; // r2
  int v21; // r3
  int v22; // r1
  _WORD v24[90]; // [sp+14h] [bp-11CCh] BYREF
  __int64 v25; // [sp+C8h] [bp-1118h] BYREF
  char dest[16]; // [sp+D0h] [bp-1110h] BYREF
  _BYTE v27[180]; // [sp+F0h] [bp-10F0h] BYREF
  int v28; // [sp+1A4h] [bp-103Ch]
  int v29; // [sp+1A8h] [bp-1038h]
  int v30; // [sp+1ACh] [bp-1034h]
  int v31; // [sp+1B0h] [bp-1030h]
  int v32; // [sp+1B4h] [bp-102Ch]
  int v33; // [sp+1B8h] [bp-1028h]
  int v34; // [sp+1BCh] [bp-1024h]
  int v35; // [sp+1C0h] [bp-1020h]
  int v36; // [sp+1C4h] [bp-101Ch]
  int v37; // [sp+1C8h] [bp-1018h]
  int v38; // [sp+1CCh] [bp-1014h]
  _DWORD v39[1024]; // [sp+1E0h] [bp-1000h] BYREF

  v2 = *a2;
  v4 = (const char *)*((_DWORD *)a2 + 281);
  v25 = v2;
  strcpy(dest, v4);
  v24[89] = 0;
  *(_DWORD *)&v24[87] = 0;
  V_LOCK();
  logfmt_raw((char *)v39, 0x1000u, 0, "start nonce: %08x", dword_1088A8);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/dhash_content/dcr/dcr_1727/dcr_1727_content.c",
    173,
    "push_work_dcr_1727",
    18,
    40,
    20,
    v39);
  memcpy(v24, a2 + 1, 0x8Cu);
  v6 = (int *)((char *)a2 + 155);
  v7 = &v24[71];
  do
  {
    v8 = *v6;
    v6 += 4;
    v9 = *(v6 - 3);
    v7 += 16;
    v10 = *(v6 - 2);
    *((_DWORD *)v7 - 4) = v8;
    v11 = *(v6 - 1);
    *((_DWORD *)v7 - 3) = v9;
    *((_DWORD *)v7 - 2) = v10;
    *((_DWORD *)v7 - 1) = v11;
  }
  while ( v6 != (int *)((char *)a2 + 187) );
  v12 = *(_BYTE *)v6;
  v13 = dword_1088A8 | (*(_DWORD *)(a1 + 196) << 22);
  *v7 = v12;
  v39[0] = v13;
  v24[70] = v13;
  LOBYTE(v24[71]) = BYTE2(v13);
  memcpy(v27, v24, sizeof(v27));
  v14 = target_to_diff_dcr((int)(a2 + 129));
  v15 = *((_DWORD *)a2 + 259);
  v16 = *((_DWORD *)a2 + 260);
  v28 = v14;
  v17 = *((_DWORD *)a2 + 261);
  v18 = *(void (__fastcall **)(int, __int64 *))(a1 + 24);
  v29 = *((_DWORD *)a2 + 258);
  v30 = v15;
  v31 = v16;
  v32 = v17;
  v19 = *((_DWORD *)a2 + 263);
  v20 = *((_DWORD *)a2 + 264);
  v21 = *((_DWORD *)a2 + 265);
  v33 = *((_DWORD *)a2 + 262);
  v34 = v19;
  v35 = v20;
  v36 = v21;
  v22 = *((_DWORD *)a2 + 276);
  v37 = *((_DWORD *)a2 + 275);
  v38 = v22;
  v18(a1, &v25);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1088A8: using guessed type int dword_1088A8;
// 11A7AC: using guessed type int g_zc;

//----- (0003EEFC) --------------------------------------------------------
int __fastcall sub_3EEFC(_DWORD *a1, int a2, int a3)
{
  size_t *v3; // r12
  unsigned int v4; // r3

  v3 = (size_t *)a1[283];
  v4 = *(_DWORD *)(a3 + 48);
  a1[269] = 0;
  a1[268] = bswap32(v4);
  if ( v3 )
  {
    memcpy(v3 + 1, (const void *)(a3 + 52), *v3);
    return 0;
  }
  else
  {
    printf("invalid pointer(%s)!\n", "private");
    return 3;
  }
}

//----- (0003EF54) --------------------------------------------------------
_DWORD *dhash_content_dcr_1727()
{
  _DWORD *result; // r0

  result = calloc(1u, 0x14u);
  *result = sub_3ED38;
  result[1] = sub_3ED5C;
  result[2] = sub_3EEFC;
  result[3] = "H";
  result[4] = 60;
  return result;
}
// 3ED5C: using guessed type int sub_3ED5C();

//----- (0003EF8C) --------------------------------------------------------
int check_fan_valiad()
{
  unsigned int v0; // r6
  int fan_num; // r4
  unsigned int v2; // r5
  int v3; // r7
  int i; // r10
  int realtime_speed; // r11
  int v6; // r0
  int fan_max_speed; // r0
  char v9[4100]; // [sp+18h] [bp-1004h] BYREF

  if ( !fan_inited )
  {
    fan_init();
    fan_inited = 1;
  }
  green_led_off();
  red_led_off();
  fan_pwm_set_max();
  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "Begain check_fan_valiad");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/miner_util/check_fan.c",
    150,
    "check_fan_valiad",
    16,
    32,
    60,
    v9);
  v0 = 0;
  fan_num = platform_get_fan_num();
  while ( 1 )
  {
    v2 = ++v0 % 0x14;
    if ( fan_num <= 0 )
      break;
    v3 = 0;
    for ( i = 0; i != fan_num; ++i )
    {
      realtime_speed = fan_get_realtime_speed(i);
      v6 = i;
      if ( realtime_speed != -1 )
      {
        fan_max_speed = platform_get_fan_max_speed(v6);
        if ( fan_get_check_fan_speed(fan_max_speed) <= realtime_speed )
          ++v3;
      }
    }
    usleep((__useconds_t)&loc_7A120);
    if ( v2 )
    {
      if ( fan_num <= v3 )
        goto LABEL_16;
      goto LABEL_12;
    }
LABEL_15:
    fan_pwm_set_max();
    if ( fan_num <= v3 )
      goto LABEL_16;
LABEL_12:
    if ( v0 == 120 * (v0 / 0x78) )
    {
      red_led_on();
      V_LOCK();
      logfmt_raw(v9, 0x1000u, v0 % 0x78, "Sweep error string = %s.", "F:1");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/miner_util/check_fan.c",
        150,
        "check_fan_valiad",
        16,
        50,
        100,
        v9);
    }
  }
  usleep((__useconds_t)&loc_7A120);
  if ( !v2 )
  {
    v3 = 0;
    goto LABEL_15;
  }
  v3 = 0;
LABEL_16:
  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "check_fan_speed ok, fan_num = %d", v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/miner_util/check_fan.c",
    150,
    "check_fan_valiad",
    16,
    54,
    60,
    v9);
  return fan_pwm_set(0x50u);
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10DC20: using guessed type char fan_inited;
// 11A7AC: using guessed type int g_zc;

//----- (0003F200) --------------------------------------------------------
void __noreturn heartbeat_on_device()
{
  char *all_created_runtime; // r0
  char *v1; // r5
  int i; // r6
  int v3; // r3
  int v4; // t1
  int v5; // r0
  int v6; // r0
  int v7; // [sp+3Ch] [bp-1028h] BYREF
  _DWORD v8[7]; // [sp+40h] [bp-1024h] BYREF
  int v9; // [sp+5Ch] [bp-1008h]
  char v10[4100]; // [sp+60h] [bp-1004h] BYREF

  v7 = 0;
  while ( 1 )
  {
    do
      all_created_runtime = (char *)get_all_created_runtime(&v7);
    while ( v7 <= 0 );
    v1 = all_created_runtime - 4;
    for ( i = 0; i < v7; ++i )
    {
      v4 = *((_DWORD *)v1 + 1);
      v1 += 4;
      v3 = v4;
      if ( *(_BYTE *)(v4 + 206) || *(_BYTE *)(v3 + 205) )
      {
        V_LOCK();
        logfmt_raw(v10, 0x1000u, 0, "heartbeat_on_device");
        V_UNLOCK();
        v5 = zlog(
               g_zc,
               "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godmin"
               "er-origin_godminer-new/miner_util/check_heartbeat.c",
               156,
               "heartbeat_on_device",
               19,
               59,
               60,
               v10);
        v6 = dev_ctrl(v5);
        if ( !(*(int (__fastcall **)(_DWORD))(v6 + 80))(*(_DWORD *)(*(_DWORD *)v1 + 196)) )
        {
          V_LOCK();
          V_STR(v8, "error", "pic lost");
          logfmt_raw(v10, 0x1000u, 0, v9, v8[0], v8[1], v8[2], v8[3], v8[4], v8[5], v8[6], v9, "heartbeat failed!");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/miner_util/check_heartbeat.c",
            156,
            "heartbeat_on_device",
            19,
            61,
            100,
            v10);
        }
        sleep(5u);
      }
    }
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4AB8C: using guessed type int __fastcall dev_ctrl(_DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0003F398) --------------------------------------------------------
int psu_watchdog()
{
  double v0; // d0
  int v1; // r5
  int v2; // r7
  int v3; // r5
  int current_voltage; // r6
  double v5; // d12
  double v6; // d13
  const char *v7; // r1
  int v8; // r0
  int v9; // r12
  int v10; // r2
  int power_status; // r6
  int v12; // r5
  int result; // r0
  bool v14; // zf
  int v15; // [sp+4h] [bp-1010h]
  char v16[4100]; // [sp+10h] [bp-1004h] BYREF

  v1 = bitmain_set_watchdog(1);
  V_LOCK();
  logfmt_raw(v16, 0x1000u, 0, "enable power watchdog: 0x%04x", v1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/miner_util/check_heartbeat.c",
    156,
    "psu_watchdog",
    12,
    76,
    60,
    v16);
  if ( v1 != 1 )
  {
    V_LOCK();
    logfmt_raw(v16, 0x1000u, 0, "%s enable power watchdog failed!", "psu_watchdog");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/miner_util/check_heartbeat.c",
      156,
      "psu_watchdog",
      12,
      78,
      100,
      v16);
    return 0;
  }
  v2 = 0;
  v3 = 0;
  while ( 1 )
  {
    pthread_setcancelstate(1, 0);
    read_feedback_voltage(0);
    current_voltage = get_current_voltage();
    if ( !is_power_on() )
      goto LABEL_15;
    if ( v0 < 0.0 )
    {
      V_LOCK();
      ++v2;
      logfmt_raw(v16, 0x1000u, 0, ">> read_feedback_voltage failed!, pls check <<");
      V_UNLOCK();
      v8 = g_zc;
      v9 = 100;
      v10 = 88;
LABEL_13:
      zlog(
        v8,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/miner_util/check_heartbeat.c",
        156,
        "psu_watchdog",
        12,
        v10,
        v9,
        v16);
      goto LABEL_14;
    }
    v5 = (double)current_voltage;
    v6 = v0 * 100.0;
    if ( v0 * 100.0 > (double)current_voltage * 1.1 || v6 < v5 * 0.9 )
    {
      V_LOCK();
      v7 = "rise";
      ++v2;
      if ( v6 - v5 <= 0.0 )
        v7 = "drop";
      logfmt_raw(v16, 0x1000u, 0, ">> chain avg vol %s from %d to %.2f, pls check <<", v7, current_voltage, v0 * 100.0);
      V_UNLOCK();
      v8 = g_zc;
      v9 = 80;
      v10 = 92;
      goto LABEL_13;
    }
    v2 = 0;
LABEL_14:
    V_LOCK();
    logfmt_raw(v16, 0x1000u, 0, "cur_voltage = %d, avg_voltage = %.2f", current_voltage, v15, v0 * 100.0);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/miner_util/check_heartbeat.c",
      156,
      "psu_watchdog",
      12,
      98,
      20,
      v16);
LABEL_15:
    power_status = bitmain_get_power_status();
    if ( !power_status )
      break;
    V_LOCK();
    v12 = v3 + 1;
    logfmt_raw(v16, 0x1000u, 0, ">> power status error, ret %d, err_times %d <<", power_status, v12);
    V_UNLOCK();
    result = zlog(
               g_zc,
               "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godmin"
               "er-origin_godminer-new/miner_util/check_heartbeat.c",
               156,
               "psu_watchdog",
               12,
               105,
               80,
               v16);
    v14 = v12 == 3;
    if ( v12 <= 3 )
      v14 = v2 == 0;
    if ( !v14 )
      return result;
    power_status = v12;
LABEL_4:
    v3 = power_status;
    pthread_setcancelstate(0, 0);
    pthread_testcancel();
    sleep(0xAu);
  }
  if ( v2 <= 3 )
    goto LABEL_4;
  V_LOCK();
  logfmt_raw(v16, 0x1000u, 0, ">> feedback voltage: too many times error, pls check <<");
  V_UNLOCK();
  return zlog(
           g_zc,
           "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-o"
           "rigin_godminer-new/miner_util/check_heartbeat.c",
           156,
           "psu_watchdog",
           12,
           112,
           100,
           v16);
}
// 3F498: variable 'v0' is possibly undefined
// 3F568: variable 'v15' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0003F740) --------------------------------------------------------
int start_heartbeat_thread()
{
  pthread_t *v0; // r4
  pthread_attr_t *v1; // r6
  bool v2; // zf
  pthread_attr_t *v3; // r0
  void *(*v4)(void *); // r2
  int v5; // r5
  char v7[4096]; // [sp+10h] [bp-1000h] BYREF

  v0 = (pthread_t *)calloc(1u, 0x30u);
  *v0 = 5;
  v1 = (pthread_attr_t *)(v0 + 2);
  v2 = platform_is_pic_mcu_en() == 0;
  v3 = (pthread_attr_t *)(v0 + 2);
  if ( v2 )
  {
    pthread_attr_init(v3);
    v4 = (void *(*)(void *))psu_watchdog;
  }
  else
  {
    pthread_attr_init(v3);
    v4 = (void *(*)(void *))heartbeat_on_device;
  }
  v5 = pthread_create(v0 + 1, v1, v4, v0);
  pthread_attr_destroy(v1);
  if ( v5 )
  {
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, "heartbeat thread create failed");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/miner_util/check_heartbeat.c",
      156,
      "start_heartbeat_thread",
      22,
      131,
      100,
      v7);
    return 5;
  }
  else
  {
    pthread_detach(v0[1]);
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, "start_heartbeat_thread");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/miner_util/check_heartbeat.c",
      156,
      "start_heartbeat_thread",
      22,
      135,
      60,
      v7);
    return 0;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0003F8AC) --------------------------------------------------------
void __fastcall __noreturn stop_heartbeat_thread(int a1)
{
  pthread_exit((void *)(a1 + 4));
}

//----- (0003F8B8) --------------------------------------------------------
int sub_3F8B8()
{
  char v1[4096]; // [sp+10h] [bp-1000h] BYREF

  V_LOCK();
  logfmt_raw(v1, 0x1000u, 0, "Unable to set thread to low priority");
  V_UNLOCK();
  return zlog(
           g_zc,
           "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-o"
           "rigin_godminer-new/miner_util/check_pool.c",
           151,
           "set_lowprio",
           11,
           18,
           20,
           v1);
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0003F92C) --------------------------------------------------------
int sub_3F92C()
{
  int result; // r0

  result = nice(10);
  if ( !result )
    return sub_3F8B8();
  return result;
}

//----- (0003F948) --------------------------------------------------------
void __noreturn watchpool_thread()
{
  pthread_t v0; // r0
  char *v1; // r4
  int v2; // r0
  int v3; // r4
  unsigned __int8 *v4; // r5
  int v5; // r11
  int v6; // r1
  int v7; // r2
  int v8; // r3
  char *v9; // r11
  int v10; // r1
  int v11; // r2
  int v12; // r3
  int current_pool; // r0
  char v14; // [sp+20h] [bp-1084h] BYREF
  char *v15; // [sp+40h] [bp-1064h]
  int v16; // [sp+44h] [bp-1060h]
  char *v17; // [sp+48h] [bp-105Ch]
  char *v18; // [sp+4Ch] [bp-1058h]
  char *v19; // [sp+50h] [bp-1054h]
  char *s; // [sp+54h] [bp-1050h]
  struct timeval v21; // [sp+58h] [bp-104Ch] BYREF
  _DWORD v22[7]; // [sp+60h] [bp-1044h] BYREF
  int v23; // [sp+7Ch] [bp-1028h]
  _DWORD v24[8]; // [sp+80h] [bp-1024h] BYREF
  char v25[4100]; // [sp+A0h] [bp-1004h] BYREF

  v0 = pthread_self();
  pthread_detach(v0);
  pthread_setcanceltype(1, 0);
  sub_3F92C();
  v1 = (char *)calloc(1u, 0x40u);
  snprintf(v1, 0x40u, "%.10s_%d", "watchpool_thread", 0);
  V_LOCK();
  v2 = syscall(224);
  logfmt_raw(v25, 0x1000u, 0, 914180, v1, v2);
  V_UNLOCK();
  v19 = "poolno";
  v18 = "stable for >%d seconds";
  s = "current_pool" + 8;
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/miner_util/check_pool.c",
    151,
    "watchpool_thread",
    16,
    31,
    40,
    v25);
  v17 = &v14;
  prctl(15, v1);
  while ( 1 )
  {
    cgtime(&v21);
    if ( total_pools > 0 )
    {
      v3 = 0;
      do
      {
        while ( 1 )
        {
          v4 = *(unsigned __int8 **)(pools + 4 * v3++);
          if ( !pool_tget((int)v4, v4 + 1896) )
          {
            v5 = *((_DWORD *)v4 + 1);
            if ( v5 < *(_DWORD *)(get_current_pool() + 4) && v21.tv_sec - *((_DWORD *)v4 + 475) > 120 )
              break;
          }
          if ( total_pools <= v3 )
            goto LABEL_9;
        }
        V_LOCK();
        V_INT((int)v22, v19, *(int *)v4);
        V_STR(v24, s, *((const char **)v4 + 2));
        v6 = v24[1];
        v7 = v24[2];
        v8 = v24[3];
        v9 = v17;
        v15 = v18;
        v16 = 120;
        *(_DWORD *)v17 = v24[0];
        *((_DWORD *)v9 + 1) = v6;
        *((_DWORD *)v9 + 2) = v7;
        *((_DWORD *)v9 + 3) = v8;
        v9 += 16;
        v10 = v24[5];
        v11 = v24[6];
        v12 = v24[7];
        *(_DWORD *)v9 = v24[4];
        *((_DWORD *)v9 + 1) = v10;
        *((_DWORD *)v9 + 2) = v11;
        *((_DWORD *)v9 + 3) = v12;
        logfmt_raw(v25, 0x1000u, 0, v23, v22[0], v22[1], v22[2], v22[3], v22[4], v22[5], v22[6], v23);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/miner_util/check_pool.c",
          151,
          "watchpool_thread",
          16,
          50,
          80,
          v25);
        switch_pools();
      }
      while ( total_pools > v3 );
    }
LABEL_9:
    current_pool = get_current_pool();
    if ( pool_tget(current_pool, (unsigned __int8 *)(current_pool + 1896)) )
      switch_pools();
    sleep(0x1Eu);
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 107BA0: using guessed type int total_pools;
// 107BA4: using guessed type int pools;
// 11A7AC: using guessed type int g_zc;

//----- (0003FBBC) --------------------------------------------------------
int __fastcall sub_3FBBC(int a1)
{
  pthread_t v2; // r0

  v2 = pthread_self();
  pthread_detach(v2);
  pthread_setcanceltype(1, 0);
  sub_3F92C();
  api();
  *(_DWORD *)(a1 + 4) = 0;
  return 0;
}

//----- (0003FBEC) --------------------------------------------------------
int start_watchpool_thread()
{
  int v0; // r5
  char v2[4100]; // [sp+10h] [bp-1004h] BYREF

  dword_11AEA8 = 2;
  pthread_attr_init(&attr);
  v0 = pthread_create((pthread_t *)&dword_11AEAC, &attr, (void *(*)(void *))watchpool_thread, &dword_11AEA8);
  pthread_attr_destroy(&attr);
  if ( !v0 )
    return 0;
  V_LOCK();
  logfmt_raw(v2, 0x1000u, 0, "watchpool thread create failed");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/miner_util/check_pool.c",
    151,
    "start_watchpool_thread",
    22,
    126,
    100,
    v2);
  return 5;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;
// 11AEA8: using guessed type int dword_11AEA8;
// 11AEAC: using guessed type int dword_11AEAC;

//----- (0003FCC0) --------------------------------------------------------
int start_api_thread()
{
  int v0; // r5
  char v2[4100]; // [sp+10h] [bp-1004h] BYREF

  dword_11AED8 = 3;
  pthread_attr_init((pthread_attr_t *)&dword_11AEDC[1]);
  v0 = pthread_create(
         dword_11AEDC,
         (const pthread_attr_t *)&dword_11AEDC[1],
         (void *(*)(void *))sub_3FBBC,
         &dword_11AED8);
  pthread_attr_destroy((pthread_attr_t *)&dword_11AEDC[1]);
  if ( !v0 )
    return 0;
  V_LOCK();
  logfmt_raw(v2, 0x1000u, 0, "api thread create failed");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/miner_util/check_pool.c",
    151,
    "start_api_thread",
    16,
    138,
    100,
    v2);
  return 5;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;
// 11AED8: using guessed type int dword_11AED8;
// 11AEDC: using guessed type pthread_t[35];

//----- (0003FD94) --------------------------------------------------------
int check_pool_connect()
{
  int pool_stratum_threads; // r8
  int v1; // r4
  int v3; // r5
  const char *v4; // r6
  bool v5; // zf
  bool v6; // r0
  char *all_created_runtime; // r0
  int v8; // r3
  char *v9; // r4
  int v10; // t1
  _DWORD v11[1025]; // [sp+20h] [bp-1004h] BYREF

  pool_stratum_threads = create_pool_stratum_threads();
  if ( pool_stratum_threads )
  {
    V_LOCK();
    logfmt_raw((char *)v11, 0x1000u, 0, "stratum thread create failed");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/miner_util/check_pool.c",
      151,
      "check_pool_connect",
      18,
      152,
      100,
      v11);
    return 1;
  }
  else
  {
    v1 = 60;
    do
    {
      sleep(1u);
      if ( pools_active )
        return 0;
      --v1;
    }
    while ( v1 );
    V_LOCK();
    logfmt_raw((char *)v11, 0x1000u, 0, "No servers were found that could be used to get work from.");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/miner_util/check_pool.c",
      151,
      "check_pool_connect",
      18,
      164,
      100,
      v11);
    V_LOCK();
    logfmt_raw((char *)v11, 0x1000u, 0, "Please check the details from the list below of the servers you have input.");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/miner_util/check_pool.c",
      151,
      "check_pool_connect",
      18,
      165,
      100,
      v11);
    V_LOCK();
    logfmt_raw(
      (char *)v11,
      0x1000u,
      0,
      "Most likely you have input the wrong URL, forgotten to add a port, have not set up workers, or the network was disconnected.");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/miner_util/check_pool.c",
      151,
      "check_pool_connect",
      18,
      166,
      100,
      v11);
    if ( total_pools > 0 )
    {
      do
      {
        v3 = *(_DWORD *)(pools + 4 * v1);
        V_LOCK();
        logfmt_raw(
          (char *)v11,
          0x1000u,
          0,
          "Pool: %d  URL: %s\tUser: %s  Password: %s",
          *(_DWORD *)v3,
          *(_DWORD *)(v3 + 8),
          *(_DWORD *)(v3 + 12),
          *(_DWORD *)(v3 + 16));
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/miner_util/check_pool.c",
          151,
          "check_pool_connect",
          18,
          172,
          80,
          v11);
        if ( *(_DWORD *)(v3 + 16) )
        {
          v4 = *(const char **)(v3 + 12);
          if ( v4 )
          {
            v5 = strstr(*(const char **)(v3 + 16), "stats") == 0;
            v6 = 1;
            if ( v5 )
              v6 = strcmp(v4, "benchmark") == 0;
            *(_BYTE *)(v3 + 1640) = v6;
          }
        }
        ++v1;
      }
      while ( total_pools > v1 );
    }
    V_LOCK();
    logfmt_raw((char *)v11, 0x1000u, 0, "No servers could be used!");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/miner_util/check_pool.c",
      151,
      "check_pool_connect",
      18,
      178,
      100,
      v11);
    v11[0] = 0;
    all_created_runtime = (char *)get_all_created_runtime(v11);
    v8 = v11[0];
    if ( v11[0] > 0 )
    {
      v9 = all_created_runtime - 4;
      do
      {
        v10 = *((_DWORD *)v9 + 1);
        v9 += 4;
        ++pool_stratum_threads;
        (*(void (**)(void))(v10 + 12))();
        (*(void (**)(void))(*(_DWORD *)v9 + 20))();
        v8 = v11[0];
      }
      while ( pool_stratum_threads < v11[0] );
    }
    if ( v8 )
      fan_pwm_set(0x14u);
    green_led_on();
    red_led_on();
    while ( !pools_active )
      sleep(1u);
    V_LOCK();
    logfmt_raw((char *)v11, 0x1000u, 0, "Pool is activing, exiting and restart.");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/miner_util/check_pool.c",
      151,
      "check_pool_connect",
      18,
      180,
      80,
      v11);
    return 0;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 107BA0: using guessed type int total_pools;
// 107BA4: using guessed type int pools;
// 1085D4: using guessed type char pools_active;
// 11A7AC: using guessed type int g_zc;

//----- (0004019C) --------------------------------------------------------
int __fastcall fan_get_check_fan_speed(int a1)
{
  return 90 * a1 / 110;
}

//----- (000401BC) --------------------------------------------------------
int fan_pwm_get()
{
  int v0; // r0
  int v2; // [sp+4h] [bp-4h] BYREF

  if ( byte_1088AC )
  {
    v0 = dword_1088B0;
  }
  else
  {
    v0 = pwm_init(0, 1);
    dword_1088B0 = v0;
    byte_1088AC = 1;
  }
  pwm_get(v0, (int)&v2);
  return v2;
}
// 1088AC: using guessed type char byte_1088AC;
// 1088B0: using guessed type int dword_1088B0;

//----- (00040208) --------------------------------------------------------
int __fastcall fan_pwm_set(unsigned int a1)
{
  int result; // r0
  unsigned int v3; // r1

  if ( !byte_1088AC )
  {
    dword_1088B0 = pwm_init(0, 100);
    byte_1088AC = 1;
  }
  if ( a1 >= 0x64 )
    a1 = 100;
  result = fan_pwm_get();
  if ( result != a1 )
  {
    if ( fan_pwm_fixed )
      v3 = fan_pwm;
    else
      v3 = a1;
    return pwm_set(dword_1088B0, v3);
  }
  return result;
}
// 1063FC: using guessed type int fan_pwm;
// 1088AC: using guessed type char byte_1088AC;
// 1088B0: using guessed type int dword_1088B0;
// 1088B4: using guessed type char fan_pwm_fixed;

//----- (00040280) --------------------------------------------------------
int fan_pwm_set_max()
{
  int result; // r0

  if ( !byte_1088AC )
  {
    dword_1088B0 = pwm_init(0, 100);
    byte_1088AC = 1;
  }
  result = fan_pwm_get();
  if ( result != 100 )
    return pwm_set(dword_1088B0, 0x64u);
  return result;
}
// 1088AC: using guessed type char byte_1088AC;
// 1088B0: using guessed type int dword_1088B0;

//----- (000402D0) --------------------------------------------------------
int sub_402D0()
{
  char v1[4096]; // [sp+10h] [bp-1000h] BYREF

  V_LOCK();
  logfmt_raw(v1, 0x1000u, 0, "bitmain_set_voltage failed");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/miner_util/power_api.c",
    150,
    "set_voltage_without_feedback",
    28,
    197,
    100,
    v1);
  return -1;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00040348) --------------------------------------------------------
int sub_40348()
{
  char v1[4096]; // [sp+10h] [bp-1000h] BYREF

  V_LOCK();
  logfmt_raw(v1, 0x1000u, 0, "set_working_voltage error!");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/miner_util/power_api.c",
    150,
    "set_working_voltage",
    19,
    461,
    100,
    v1);
  return -1;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (000403C8) --------------------------------------------------------
int __fastcall sub_403C8(int a1)
{
  if ( bitmain_set_voltage() < 0 )
    return sub_402D0();
  usleep(0x7A120u);
  dword_1088D4 = a1;
  dword_1088D8 = a1;
  return 0;
}
// 1088D4: using guessed type int dword_1088D4;
// 1088D8: using guessed type int dword_1088D8;

//----- (00040420) --------------------------------------------------------
int __fastcall read_feedback_voltage(int a1)
{
  int v1; // s0
  int v2; // s1
  int v5; // [sp+4h] [bp-1010h]
  char v6[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( platform_is_pic_mcu_en() )
    pic1704_get_an_voltage1(a1);
  else
    bitmain_get_sample_voltage();
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "read_feedback_voltage chain = %d, voltage = %f", a1, v5, v1, v2);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-o"
           "rigin_godminer-new/miner_util/power_api.c",
           150,
           "read_feedback_voltage",
           21,
           55,
           20,
           v6);
}
// 4046C: variable 'v5' is possibly undefined
// 4046C: variable 'v1' is possibly undefined
// 4046C: variable 'v2' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (000404D8) --------------------------------------------------------
unsigned int power_on()
{
  bitmain_power_on();
  byte_1088D0 = 1;
  return sleep(1u);
}
// 1088D0: using guessed type char byte_1088D0;

//----- (000404FC) --------------------------------------------------------
unsigned int power_off()
{
  bitmain_power_off_0();
  byte_1088D0 = 0;
  return sleep(1u);
}
// 1088D0: using guessed type char byte_1088D0;

//----- (00040520) --------------------------------------------------------
int __fastcall power_info_init(int a1, int a2, int a3, int a4, int a5)
{
  *(_DWORD *)&byte_1088BC = a1;
  unk_1088C0 = a2;
  dword_1088C4 = a3;
  *(_DWORD *)&byte_1088C8 = a4;
  dword_1088CC = a5;
  return 0;
}
// 1088BC: using guessed type char byte_1088BC;
// 1088C4: using guessed type int dword_1088C4;
// 1088C8: using guessed type char byte_1088C8;
// 1088CC: using guessed type int dword_1088CC;

//----- (0004055C) --------------------------------------------------------
int __fastcall set_power_init_status(char a1)
{
  byte_1088B8 = a1;
  return 0;
}
// 1088B8: using guessed type char byte_1088B8;

//----- (00040570) --------------------------------------------------------
int is_power_init()
{
  return (unsigned __int8)byte_1088B8;
}
// 1088B8: using guessed type char byte_1088B8;

//----- (00040580) --------------------------------------------------------
int is_power_on()
{
  return (unsigned __int8)byte_1088D0;
}
// 1088D0: using guessed type char byte_1088D0;

//----- (00040590) --------------------------------------------------------
int __fastcall set_voltage(int a1, int a2)
{
  char v4[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( a2 )
  {
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, "set_voltage to %d", a1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/miner_util/power_api.c",
      150,
      "set_voltage",
      11,
      382,
      40,
      v4);
    return sub_403C8(a1);
  }
  else
  {
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, "set_voltage power is not inited");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/miner_util/power_api.c",
      150,
      "set_voltage",
      11,
      379,
      100,
      v4);
    return -1;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0004068C) --------------------------------------------------------
int __fastcall set_voltage_by_steps(int a1, int a2)
{
  int v3; // r5
  int v4; // r4
  int v5; // r6
  char v7[4120]; // [sp+10h] [bp-1018h] BYREF

  if ( a2 )
  {
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, "set_voltage_by_steps to %d", a1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/miner_util/power_api.c",
      150,
      "set_voltage_by_steps",
      20,
      392,
      40,
      v7);
    if ( byte_1088B8 )
      v3 = dword_1088D4;
    else
      v3 = -1;
    v4 = a1 - v3;
    if ( a1 == v3 )
      return 0;
    if ( a1 - v3 < 0 )
    {
      v5 = -10;
      if ( (int)abs32(v4) <= 10 )
      {
LABEL_11:
        if ( a1 != v3 )
          sub_403C8(a1);
        return 0;
      }
    }
    else
    {
      v5 = 10;
      if ( (int)abs32(v4) <= 10 )
        goto LABEL_11;
    }
    do
    {
      v3 += v5;
      v4 -= v5;
      sub_403C8(v3);
    }
    while ( (int)abs32(v4) > 10 );
    goto LABEL_11;
  }
  return -1;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1088B8: using guessed type char byte_1088B8;
// 1088D4: using guessed type int dword_1088D4;
// 11A7AC: using guessed type int g_zc;

//----- (000407A8) --------------------------------------------------------
int get_current_voltage()
{
  if ( byte_1088B8 )
    return dword_1088D4;
  else
    return -1;
}
// 1088B8: using guessed type char byte_1088B8;
// 1088D4: using guessed type int dword_1088D4;

//----- (000407C4) --------------------------------------------------------
int get_working_voltage()
{
  if ( byte_1088B8 )
    return dword_1088C4;
  else
    return -1;
}
// 1088B8: using guessed type char byte_1088B8;
// 1088C4: using guessed type int dword_1088C4;

//----- (000407E0) --------------------------------------------------------
int get_max_voltage()
{
  double v0; // d0

  if ( !byte_1088B8 )
    return -1;
  bitmain_convert_N_to_V();
  return (int)(v0 * 100.0);
}
// 40804: variable 'v0' is possibly undefined
// 1088B8: using guessed type char byte_1088B8;

//----- (0004082C) --------------------------------------------------------
int __fastcall set_working_voltage(int a1)
{
  int result; // r0

  if ( a1 )
  {
    result = (unsigned __int16)set_voltage_by_steps(dword_1088C4, (unsigned __int8)byte_1088B8);
    if ( !(_WORD)result )
      return result;
    return sub_40348();
  }
  result = (unsigned __int16)set_voltage(dword_1088C4, (unsigned __int8)byte_1088B8);
  if ( (_WORD)result )
    return sub_40348();
  return result;
}
// 1088B8: using guessed type char byte_1088B8;
// 1088C4: using guessed type int dword_1088C4;

//----- (00040874) --------------------------------------------------------
int is_check_asic_voltage_enable()
{
  int result; // r0

  result = (unsigned __int8)byte_1088BC;
  if ( byte_1088BC )
    return (unsigned __int8)byte_1088C8;
  return result;
}
// 1088BC: using guessed type char byte_1088BC;
// 1088C8: using guessed type char byte_1088C8;

//----- (0004088C) --------------------------------------------------------
int __fastcall set_check_asic_voltage(int a1)
{
  int result; // r0
  char v3[4100]; // [sp+10h] [bp-1004h] BYREF

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "set_check_asic_voltage");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/miner_util/power_api.c",
    150,
    "set_check_asic_voltage",
    22,
    477,
    40,
    v3);
  if ( a1 )
    result = set_voltage_by_steps(dword_1088CC, (unsigned __int8)byte_1088B8);
  else
    result = set_voltage(dword_1088CC, (unsigned __int8)byte_1088B8);
  if ( result )
  {
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, "set_check_asic_voltage error!");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/miner_util/power_api.c",
      150,
      "set_check_asic_voltage",
      22,
      485,
      100,
      v3);
    return -1;
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1088B8: using guessed type char byte_1088B8;
// 1088CC: using guessed type int dword_1088CC;
// 11A7AC: using guessed type int g_zc;

//----- (00040988) --------------------------------------------------------
int power_init()
{
  double v0; // d0
  unsigned __int16 v1; // r4
  unsigned __int16 v2; // r0
  int v3; // r4
  unsigned int v4; // r4
  double v5; // d11
  double v6; // d10
  int v7; // r8
  double v8; // d8
  char *all_created_runtime; // r0
  char *v10; // r11
  int j; // r9
  int v12; // t1
  int power_status; // r7
  double v15; // d8
  int v16; // r9
  int v17; // r11
  int chain_num; // r8
  int v19; // r10
  int i; // r4
  int v21; // r0
  double v22; // d8
  int v23; // r0
  int v24; // r12
  int v25; // r2
  int v26; // r0
  int v27; // r2
  unsigned __int16 v28; // r4
  int v29; // r2
  int v30; // r0
  int v31; // r1
  int v32; // [sp+4h] [bp-1028h]
  int v33; // [sp+4h] [bp-1028h]
  int v34; // [sp+1Ch] [bp-1010h]
  int v35; // [sp+24h] [bp-1008h] BYREF
  char v36[4100]; // [sp+28h] [bp-1004h] BYREF

  if ( !platform_is_adjustable_power() )
  {
    V_LOCK();
    logfmt_raw(v36, 0x1000u, 0, "%s, current algo donot use adjustable power!", "power_init");
    V_UNLOCK();
    power_status = -1;
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/miner_util/power_api.c",
      150,
      "power_init",
      10,
      289,
      100,
      v36);
    return power_status;
  }
  v1 = bitmain_power_version();
  if ( !platform_is_psu_supported(v1) )
  {
    power_status = -1;
    V_LOCK();
    logfmt_raw(v36, 0x1000u, 0, "Not support power version, %04x", v1);
    V_UNLOCK();
    v29 = 295;
    v30 = g_zc;
    LOWORD(v31) = 15284;
    goto LABEL_65;
  }
  if ( !platform_is_pic_mcu_en() )
  {
    v2 = bitmain_set_watchdog(0);
    if ( !v2 )
    {
      sleep(1u);
      goto LABEL_6;
    }
    v28 = v2;
    power_status = 0;
    V_LOCK();
    logfmt_raw(v36, 0x1000u, 0, "disable power watchdog: %04x", v28);
    V_UNLOCK();
    v29 = 302;
    v30 = g_zc;
    LOWORD(v31) = (unsigned __int16)"/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp"
                                    "/release/build/godminer-origin_godminer-new/miner_util/power_api.c";
LABEL_65:
    HIWORD(v31) = (unsigned int)"/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/rel"
                                "ease/build/godminer-origin_godminer-new/miner_util/power_api.c" >> 16;
    zlog(v30, v31, 150, "power_init", 10, v29, 100, v36);
    return power_status;
  }
LABEL_6:
  V_LOCK();
  logfmt_raw(v36, 0x1000u, 0, "Enter sleep to make sure power release finish.");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/miner_util/power_api.c",
    150,
    "power_init",
    10,
    308,
    60,
    v36);
  bitmain_power_off_0();
  byte_1088D0 = 0;
  sleep(1u);
  sleep(0x1Eu);
  if ( platform_is_pic_mcu_en() )
    goto LABEL_7;
  v15 = 0.0;
  v16 = 21;
  v17 = 1;
  chain_num = platform_get_chain_num();
  v19 = 100;
  while ( 1 )
  {
    while ( 1 )
    {
      if ( chain_num > 0 )
      {
        for ( i = 0; i != chain_num; ++i )
        {
          v21 = i;
          read_feedback_voltage(v21);
          if ( v15 < v0 )
            v15 = v0;
        }
      }
      if ( v15 <= 10.0 )
        break;
      if ( v19 > 20 )
      {
        v19 = 20;
        goto LABEL_47;
      }
      sleep(1u);
      if ( !--v16 )
        goto LABEL_63;
      if ( ++v17 > 19 )
        goto LABEL_7;
      v19 = 20;
    }
    if ( v15 <= 4.0 )
      goto LABEL_7;
    if ( v19 == 2 )
      break;
    v19 = 2;
LABEL_47:
    sleep(1u);
    if ( !--v16 )
      goto LABEL_63;
    v17 = 1;
  }
  sleep(1u);
  if ( v16 != 1 )
    goto LABEL_7;
LABEL_63:
  V_LOCK();
  logfmt_raw(v36, 0x1000u, 0, "APW discharge too slow OR pic adc wrong");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/miner_util/power_api.c",
    150,
    "wait_for_psu_discharge",
    22,
    185,
    100,
    v36);
LABEL_7:
  v3 = (unsigned __int16)bitmain_power_fw_version();
  V_LOCK();
  logfmt_raw(v36, 0x1000u, 0, "bitmain power fw version: %04x", v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/miner_util/power_api.c",
    150,
    "power_init",
    10,
    318,
    60,
    v36);
  byte_1088D1 = 0;
  dword_1088D4 = 0;
  dword_1088D8 = 0;
  byte_1088B8 = 1;
  if ( opt_custom_voltage_swith || is_eeprom_loaded() )
    dword_1088C4 = opt_custom_voltage;
  byte_1088BC = platform_is_adjustable_power();
  byte_1088C8 = platform_is_check_asic_voltage_enable();
  dword_1088CC = platfrom_get_check_asic_voltage();
  V_LOCK();
  logfmt_raw(v36, 0x1000u, 0, "Power init:");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/miner_util/power_api.c",
    150,
    "power_init",
    10,
    337,
    40,
    v36);
  V_LOCK();
  logfmt_raw(v36, 0x1000u, 0, "current_voltage_raw\t\t= %d", dword_1088D4);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/miner_util/power_api.c",
    150,
    "power_init",
    10,
    338,
    40,
    v36);
  V_LOCK();
  logfmt_raw(v36, 0x1000u, 0, "working_voltage_raw\t\t= %d", dword_1088C4);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/miner_util/power_api.c",
    150,
    "power_init",
    10,
    339,
    40,
    v36);
  V_LOCK();
  logfmt_raw(v36, 0x1000u, 0, "check_asic_voltage_enable\t= %d", (unsigned __int8)byte_1088C8);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/miner_util/power_api.c",
    150,
    "power_init",
    10,
    340,
    40,
    v36);
  V_LOCK();
  logfmt_raw(v36, 0x1000u, 0, "check_asic_voltage_raw\t= %d", dword_1088CC);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/miner_util/power_api.c",
    150,
    "power_init",
    10,
    341,
    40,
    v36);
  if ( byte_1088BC && byte_1088C8 )
    v4 = set_check_asic_voltage(0);
  else
    v4 = set_working_voltage(0);
  if ( !v4 )
  {
    bitmain_power_on();
    byte_1088D0 = 1;
    sleep(1u);
    if ( byte_1088B8 )
    {
      v34 = dword_1088D4;
      v6 = (double)dword_1088D4;
      v5 = (double)dword_1088D4 * 0.75 / 100.0;
    }
    else
    {
      v5 = -0.0075;
      v6 = -1.0;
      v34 = -1;
    }
    v7 = 3;
    while ( 1 )
    {
      sleep(1u);
      if ( platform_is_pic_mcu_en() )
      {
        v8 = 0.0;
        all_created_runtime = (char *)get_all_created_runtime(&v35);
        if ( v35 > 0 )
        {
          v10 = all_created_runtime - 4;
          for ( j = 0; j < v35; ++j )
          {
            v12 = *((_DWORD *)v10 + 1);
            v10 += 4;
            read_feedback_voltage(*(_DWORD *)(v12 + 200));
            if ( v0 > 0.1 )
            {
              if ( v0 >= v8 )
              {
                if ( v8 < 0.1 )
                  v8 = v0;
              }
              else
              {
                v8 = v0;
              }
            }
          }
        }
        V_LOCK();
        logfmt_raw(v36, 0x1000u, 0, "the minimal voltage = %.2f", v8);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/miner_util/power_api.c",
          150,
          "get_minimal_feedback_voltage",
          28,
          72,
          20,
          v36);
        if ( v8 >= v5 )
        {
          V_LOCK();
          logfmt_raw(
            v36,
            0x1000u,
            0,
            "power voltage qualified! centi_voltage %d feedback_voltage %f qualified_vol %f",
            v34,
            v32,
            v8,
            v5);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/miner_util/power_api.c",
            150,
            "check_feedback_voltage",
            22,
            93,
            80,
            v36);
          goto LABEL_28;
        }
        V_LOCK();
        logfmt_raw(
          v36,
          0x1000u,
          0,
          "power voltage can not meet the target! centi_voltage %d feedback_voltage %f qualified_vol %f",
          v34,
          v32,
          v8,
          v5);
        V_UNLOCK();
        v23 = g_zc;
        v24 = 80;
        v25 = 89;
      }
      else
      {
        read_feedback_voltage(0);
        V_LOCK();
        logfmt_raw(v36, 0x1000u, 0, "read fb voltage %.2f", v0);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/miner_util/power_api.c",
          150,
          "check_feedback_voltage",
          22,
          98,
          20,
          v36);
        if ( v0 < 0.0 )
        {
          V_LOCK();
          logfmt_raw(v36, 0x1000u, 0, "read_feedback_voltage_from_psu failed!");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/miner_util/power_api.c",
            150,
            "check_feedback_voltage",
            22,
            100,
            80,
            v36);
          goto LABEL_28;
        }
        v22 = v0 * 100.0;
        if ( v0 * 100.0 <= v6 * 1.1 && v22 >= v6 * 0.9 )
        {
LABEL_28:
          while ( 1 )
          {
            power_status = bitmain_get_power_status();
            ++v4;
            if ( !power_status )
              break;
            if ( v4 == 5 * (v4 / 5) )
            {
              V_LOCK();
              logfmt_raw(v36, 0x1000u, v4 % 5, ">> bitmain_get_power_status failed(%d) <<", power_status);
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godmi"
                "ner-origin_godminer-new/miner_util/power_api.c",
                150,
                "power_init",
                10,
                365,
                100,
                v36);
              sleep(3u);
              if ( v4 == 20 )
                return power_status;
            }
            else
            {
              sleep(3u);
              if ( v4 == 20 )
                return power_status;
            }
          }
          return power_status;
        }
        V_LOCK();
        logfmt_raw(v36, 0x1000u, 0, "power voltage qualified! centi_voltage %d fb_vol %f", v34, v33, v22);
        V_UNLOCK();
        v23 = g_zc;
        v24 = 100;
        v25 = 105;
      }
      zlog(
        v23,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/miner_util/power_api.c",
        150,
        "check_feedback_voltage",
        22,
        v25,
        v24,
        v36);
      if ( !--v7 )
      {
        V_LOCK();
        power_status = -1;
        logfmt_raw(v36, 0x1000u, 0, "check_feedback_voltage error!");
        V_UNLOCK();
        v26 = g_zc;
        v27 = 356;
        goto LABEL_61;
      }
    }
  }
  V_LOCK();
  power_status = -1;
  logfmt_raw(v36, 0x1000u, 0, "set_voltage_by_steps error!");
  V_UNLOCK();
  v26 = g_zc;
  v27 = 349;
LABEL_61:
  zlog(
    v26,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/miner_util/power_api.c",
    150,
    "power_init",
    10,
    v27,
    100,
    v36);
  return power_status;
}
// 40D80: variable 'v0' is possibly undefined
// 40E38: variable 'v32' is possibly undefined
// 41134: variable 'v33' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 107B30: using guessed type int opt_custom_voltage;
// 107B34: using guessed type char opt_custom_voltage_swith;
// 1088B8: using guessed type char byte_1088B8;
// 1088BC: using guessed type char byte_1088BC;
// 1088C4: using guessed type int dword_1088C4;
// 1088C8: using guessed type char byte_1088C8;
// 1088CC: using guessed type int dword_1088CC;
// 1088D0: using guessed type char byte_1088D0;
// 1088D1: using guessed type char byte_1088D1;
// 1088D4: using guessed type int dword_1088D4;
// 1088D8: using guessed type int dword_1088D8;
// 11A7AC: using guessed type int g_zc;

//----- (00041428) --------------------------------------------------------
int sub_41428()
{
  int v0; // r5
  char *all_created_runtime; // r0
  char *v2; // r9
  char *v3; // r7
  int v4; // r6
  int v5; // t1
  size_t v6; // r0
  int *v7; // r8
  int v8; // r5
  char *v9; // r9
  int i; // r7
  int v11; // t1
  int *v12; // r0
  _DWORD *v13; // r10
  int *v14; // r9
  int *v15; // r5
  int v16; // r7
  int v17; // t1
  int v19; // [sp+24h] [bp-10E0h] BYREF
  const void *v20[6]; // [sp+28h] [bp-10DCh] BYREF
  int v21; // [sp+40h] [bp-10C4h]
  char v22[4100]; // [sp+100h] [bp-1004h] BYREF

  v0 = 0;
  v19 = 0;
  all_created_runtime = (char *)get_all_created_runtime(&v19);
  v2 = all_created_runtime;
  if ( v19 <= 0 )
  {
    v6 = 0;
    v4 = 0;
  }
  else
  {
    v3 = all_created_runtime - 4;
    v4 = 0;
    do
    {
      v5 = *((_DWORD *)v3 + 1);
      v3 += 4;
      read_status_from_monitor(v20, v5);
      ++v0;
      v4 += v21;
    }
    while ( v19 > v0 );
    v6 = v4;
  }
  v7 = (int *)calloc(v6, 4u);
  if ( v7 )
  {
    if ( v19 > 0 )
    {
      v8 = 0;
      v9 = v2 - 4;
      for ( i = 0; i < v19; ++i )
      {
        v11 = *((_DWORD *)v9 + 1);
        v9 += 4;
        read_status_from_monitor(v20, v11);
        v12 = &v7[v8];
        v8 += v21;
        memcpy(v12, v20[0], 4 * v21);
      }
    }
    LOWORD(v13) = (unsigned __int16)&g_zc;
    if ( v4 <= 0 )
    {
      v16 = 0x7FFFFFFF;
      HIWORD(v13) = (unsigned int)&g_zc >> 16;
    }
    else
    {
      v14 = &v7[v4];
      HIWORD(v13) = (unsigned int)&g_zc >> 16;
      v15 = v7;
      v16 = 0x7FFFFFFF;
      do
      {
        while ( 1 )
        {
          v17 = *v15++;
          if ( check_value_valid_with_stdd(COERCE_DOUBLE(__PAIR64__(v4, (unsigned int)v7)), v17) )
            break;
          V_LOCK();
          logfmt_raw(v22, 0x1000u, 0, "%d C, most likely a bad sensor", *(v15 - 1));
          V_UNLOCK();
          zlog(
            *v13,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/miner_util/set_pwm_by_temp.c",
            156,
            "get_min_pcb_temp",
            16,
            133,
            20,
            v22);
          if ( v14 == v15 )
            goto LABEL_16;
        }
        if ( v16 >= *(v15 - 1) )
          v16 = *(v15 - 1);
      }
      while ( v14 != v15 );
    }
LABEL_16:
    free(v7);
    dword_106400 = v16;
    V_LOCK();
    logfmt_raw(v22, 0x1000u, 0, "min temp pcb: %d", v16);
    V_UNLOCK();
    zlog(
      *v13,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/miner_util/set_pwm_by_temp.c",
      156,
      "get_min_pcb_temp",
      16,
      138,
      20,
      v22);
    return v16;
  }
  else
  {
    printf("invalid pointer(%s)!\n", "temp_in_pcb");
    return dword_106400;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 106400: using guessed type int dword_106400;
// 11A7AC: using guessed type int g_zc;

//----- (0004167C) --------------------------------------------------------
int sub_4167C()
{
  int v0; // r5
  char *all_created_runtime; // r0
  char *v2; // r9
  char *v3; // r7
  int v4; // r6
  int v5; // t1
  size_t v6; // r0
  int *v7; // r8
  int v8; // r5
  char *v9; // r9
  int i; // r7
  int v11; // t1
  int *v12; // r0
  _DWORD *v13; // r10
  int *v14; // r9
  int *v15; // r5
  signed int v16; // r7
  int v17; // t1
  int v19; // [sp+1Ch] [bp-10E0h] BYREF
  const void *v20[7]; // [sp+20h] [bp-10DCh] BYREF
  int v21; // [sp+3Ch] [bp-10C0h]
  char v22[4100]; // [sp+F8h] [bp-1004h] BYREF

  v0 = 0;
  v19 = 0;
  all_created_runtime = (char *)get_all_created_runtime(&v19);
  v2 = all_created_runtime;
  if ( v19 <= 0 )
  {
    v6 = 0;
    v4 = 0;
  }
  else
  {
    v3 = all_created_runtime - 4;
    v4 = 0;
    do
    {
      v5 = *((_DWORD *)v3 + 1);
      v3 += 4;
      read_status_from_monitor(v20, v5);
      ++v0;
      v4 += v21;
    }
    while ( v19 > v0 );
    v6 = v4;
  }
  v7 = (int *)calloc(v6, 4u);
  if ( v7 )
  {
    if ( v19 > 0 )
    {
      v8 = 0;
      v9 = v2 - 4;
      for ( i = 0; i < v19; ++i )
      {
        v11 = *((_DWORD *)v9 + 1);
        v9 += 4;
        read_status_from_monitor(v20, v11);
        v12 = &v7[v8];
        v8 += v21;
        memcpy(v12, v20[3], 4 * v21);
      }
    }
    LOWORD(v13) = (unsigned __int16)&g_zc;
    if ( v4 <= 0 )
    {
      v16 = 0x80000000;
      HIWORD(v13) = (unsigned int)&g_zc >> 16;
    }
    else
    {
      v14 = &v7[v4];
      HIWORD(v13) = (unsigned int)&g_zc >> 16;
      v15 = v7;
      v16 = 0x80000000;
      do
      {
        while ( 1 )
        {
          v17 = *v15++;
          if ( check_value_valid_with_stdd(COERCE_DOUBLE(__PAIR64__(v4, (unsigned int)v7)), v17) )
            break;
          V_LOCK();
          logfmt_raw(v22, 0x1000u, 0, "%d C, most likely a bad sensor", *(v15 - 1));
          V_UNLOCK();
          zlog(
            *v13,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/miner_util/set_pwm_by_temp.c",
            156,
            "get_max_chip_temp",
            17,
            56,
            20,
            v22);
          if ( v14 == v15 )
            goto LABEL_16;
        }
        if ( v16 < *(v15 - 1) )
          v16 = *(v15 - 1);
      }
      while ( v14 != v15 );
    }
LABEL_16:
    free(v7);
    dword_106404 = v16;
    V_LOCK();
    logfmt_raw(v22, 0x1000u, 0, "max temp chip: %d", v16);
    V_UNLOCK();
    zlog(
      *v13,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/miner_util/set_pwm_by_temp.c",
      156,
      "get_max_chip_temp",
      17,
      61,
      20,
      v22);
    return v16;
  }
  else
  {
    printf("invalid pointer(%s)!\n", "temp_out_chip");
    return dword_106404;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 106404: using guessed type int dword_106404;
// 11A7AC: using guessed type int g_zc;

//----- (000418C0) --------------------------------------------------------
int __fastcall sub_418C0(int a1)
{
  char v3[4100]; // [sp+10h] [bp-1004h] BYREF

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "%s unknow temp type %d", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/miner_util/set_pwm_by_temp.c",
    156,
    "get_temp",
    8,
    161,
    100,
    v3);
  return 0x7FFFFFFF;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00041948) --------------------------------------------------------
int __fastcall get_temp(int a1)
{
  int v1; // r6
  int *v2; // r0
  int *v3; // r7
  int *v4; // r7
  int v5; // r4
  int v6; // t1
  int *v7; // r3
  int v8; // r2
  int v9; // t1
  int *v10; // r3
  int v11; // r2
  int v12; // t1
  int result; // r0
  int v14; // r4
  int v15; // r6
  int *all_created_runtime; // r0
  int *v17; // r7
  int *v18; // r7
  signed int v19; // r4
  int v20; // t1
  signed int *v21; // r3
  signed int v22; // r2
  signed int v23; // t1
  signed int *v24; // r3
  signed int v25; // r2
  signed int v26; // t1
  int v27; // [sp+4h] [bp-E0h] BYREF
  signed int *v28; // [sp+8h] [bp-DCh] BYREF
  int *v29; // [sp+Ch] [bp-D8h]
  signed int *v30; // [sp+10h] [bp-D4h]
  int *v31; // [sp+14h] [bp-D0h]
  int v32; // [sp+20h] [bp-C4h]
  int v33; // [sp+24h] [bp-C0h]

  switch ( a1 )
  {
    case 0:
      v15 = 0;
      v27 = 0;
      all_created_runtime = (int *)get_all_created_runtime(&v27);
      v17 = all_created_runtime;
      if ( v27 <= 0 || (read_status_from_monitor(&v28, *all_created_runtime), v27 <= 0) )
      {
        v14 = 0x80000000;
        goto LABEL_18;
      }
      v18 = v17 - 1;
      v19 = 0x80000000;
      do
      {
        v20 = v18[1];
        ++v18;
        read_status_from_monitor(&v28, v20);
        if ( v32 > 0 )
        {
          v21 = v28;
          do
          {
            v23 = *v21++;
            v22 = v23;
            if ( v19 < v23 )
              v19 = v22;
          }
          while ( &v28[v32] != v21 );
        }
        if ( v33 > 0 )
        {
          v24 = v30;
          do
          {
            v26 = *v24++;
            v25 = v26;
            if ( v19 < v26 )
              v19 = v25;
          }
          while ( &v30[v33] != v24 );
        }
        ++v15;
      }
      while ( v15 < v27 );
      result = v19;
      break;
    case 1:
      result = sub_41428();
      break;
    case 2:
      v14 = sub_4167C();
      goto LABEL_18;
    case 3:
      v1 = 0;
      v27 = 0;
      v2 = (int *)get_all_created_runtime(&v27);
      v3 = v2;
      if ( v27 <= 0 || (read_status_from_monitor(&v28, *v2), v27 <= 0) )
      {
        v14 = 0x7FFFFFFF;
LABEL_18:
        result = v14;
      }
      else
      {
        v4 = v3 - 1;
        v5 = 0x7FFFFFFF;
        do
        {
          v6 = v4[1];
          ++v4;
          read_status_from_monitor(&v28, v6);
          if ( v32 > 0 )
          {
            v7 = v29;
            do
            {
              v9 = *v7++;
              v8 = v9;
              if ( v5 >= v9 )
                v5 = v8;
            }
            while ( &v29[v32] != v7 );
          }
          if ( v33 > 0 )
          {
            v10 = v31;
            do
            {
              v12 = *v10++;
              v11 = v12;
              if ( v5 >= v12 )
                v5 = v11;
            }
            while ( &v31[v33] != v10 );
          }
          ++v1;
        }
        while ( v1 < v27 );
        result = v5;
      }
      break;
    default:
      result = sub_418C0(a1);
      break;
  }
  return result;
}
// 41958: control flows out of bounds to 4195C

//----- (00041B28) --------------------------------------------------------
int set_pwm_by_temp()
{
  float v0; // s10
  double v1; // d7
  int v2; // r3
  bool v3; // cf
  __int64 v4; // r6
  int v5; // r0
  float v6; // s13
  int v7; // r8
  float v8; // s15
  float v9; // s14
  float v10; // s16
  float v11; // s14
  signed int v12; // r0
  __int64 v13; // r6
  __int64 v14; // r2
  int result; // r0
  int v16; // r0
  int v17; // r4
  bool v18; // cc
  double v19; // d5
  int v20; // r0
  int v21; // r0

  if ( !byte_1088E0 )
  {
    clock_gettime(1, &stru_1088E4);
    byte_1088E0 = 1;
    v2 = dword_106408;
    *(_QWORD *)&dword_1088F8 = 0;
    v3 = dword_106408 != 0;
    if ( dword_106408 != 1 )
      goto LABEL_3;
    goto LABEL_19;
  }
  clock_gettime(1, (struct timespec *)&dword_1088EC);
  v13 = *(_QWORD *)&dword_1088F8;
  v14 = 1000LL * (dword_1088EC - stru_1088E4.tv_sec) + (dword_1088F0 - stru_1088E4.tv_nsec) / 1000000;
  if ( *(__int64 *)&dword_1088F8 >= 20 )
  {
    result = dword_106428;
    if ( v14 >= dword_106428 )
    {
LABEL_18:
      clock_gettime(1, &stru_1088E4);
      *(_QWORD *)&dword_1088F8 = v13 + 1;
      v2 = dword_106408;
      v3 = dword_106408 != 0;
      if ( dword_106408 != 1 )
      {
LABEL_3:
        if ( !v3 )
        {
          v21 = sub_41428();
          if ( v21 <= 18 )
          {
            v17 = 40;
            goto LABEL_27;
          }
          if ( (unsigned int)(v21 - 19) <= 0xE )
          {
            v20 = v21 - 18;
            v19 = 0.666666667;
            v1 = 40.0;
          }
          else
          {
            if ( (unsigned int)(v21 - 34) <= 4 )
            {
              v17 = 50;
              goto LABEL_27;
            }
            if ( (unsigned int)(v21 - 39) <= 9 )
            {
              v17 = (int)((double)(v21 - 38) + 50.0);
              goto LABEL_27;
            }
            if ( (unsigned int)(v21 - 49) > 6 )
            {
              v17 = 100;
              goto LABEL_27;
            }
            v20 = v21 - 48;
            v19 = 5.71428571;
            v1 = 60.0;
          }
          goto LABEL_26;
        }
        if ( v2 == 2 )
        {
          v4 = *(_QWORD *)&dword_1088F8;
          flt_10890C = (float)get_temp(dword_10641C);
          v5 = fan_pwm_get();
          v6 = flt_108924;
          v7 = v5;
          if ( v4 < 21 )
            v0 = flt_108910;
          v8 = flt_108908 - flt_10890C;
          if ( v4 >= 21 )
            v0 = flt_108914;
          flt_108920 = flt_108908 - flt_10890C;
          v9 = (float)(v8 - (float)(flt_108924 + flt_108924)) + flt_108928;
          flt_108928 = flt_108924;
          flt_108924 = flt_108908 - flt_10890C;
          v10 = (float)((float)(v8 * flt_108918) + (float)((float)(v8 - v6) * v0)) + (float)(v9 * flt_10891C);
          if ( get_temp(dword_106414) < dword_106418 )
            v11 = (float)((int)v10 + v7);
          else
            v11 = 100.0;
          if ( v11 < flt_108904 )
          {
            if ( flt_108904 <= flt_108900 )
            {
              v12 = (int)flt_108904;
              return fan_pwm_set(v12);
            }
          }
          else if ( v11 <= flt_108900 )
          {
            v12 = (int)v11;
            return fan_pwm_set(v12);
          }
          v12 = (int)flt_108900;
          return fan_pwm_set(v12);
        }
        v12 = 100;
        return fan_pwm_set(v12);
      }
LABEL_19:
      v16 = sub_41428();
      if ( v16 <= 13 )
      {
        v17 = 20;
LABEL_27:
        if ( get_temp(dword_106414) >= dword_106418 )
          v17 = 100;
        if ( v17 < dword_10640C )
          v12 = dword_10640C;
        else
          v12 = v17;
        if ( v12 >= dword_106410 )
          v12 = dword_106410;
        return fan_pwm_set(v12);
      }
      v18 = (unsigned int)(v16 - 14) > 0x12;
      if ( (unsigned int)(v16 - 14) > 0x12 )
      {
        v19 = 1.42857143;
        v20 = v16 - 32;
        v1 = 60.0;
      }
      else
      {
        v19 = 2.10526316;
        v20 = v16 - 13;
      }
      if ( !v18 )
        v1 = 20.0;
LABEL_26:
      v17 = (int)(v1 + (double)v20 * v19);
      goto LABEL_27;
    }
  }
  else
  {
    result = dword_106424;
    if ( v14 >= dword_106424 )
      goto LABEL_18;
  }
  return result;
}
// 41BE4: variable 'v0' is possibly undefined
// 41D18: variable 'v1' is possibly undefined
// 106408: using guessed type int dword_106408;
// 10640C: using guessed type int dword_10640C;
// 106410: using guessed type int dword_106410;
// 106414: using guessed type int dword_106414;
// 106418: using guessed type int dword_106418;
// 10641C: using guessed type int dword_10641C;
// 106424: using guessed type int dword_106424;
// 106428: using guessed type int dword_106428;
// 1088E0: using guessed type char byte_1088E0;
// 1088EC: using guessed type int dword_1088EC;
// 1088F0: using guessed type int dword_1088F0;
// 1088F8: using guessed type int dword_1088F8;
// 108900: using guessed type float flt_108900;
// 108904: using guessed type float flt_108904;
// 108908: using guessed type float flt_108908;
// 10890C: using guessed type float flt_10890C;
// 108910: using guessed type float flt_108910;
// 108914: using guessed type float flt_108914;
// 108918: using guessed type float flt_108918;
// 10891C: using guessed type float flt_10891C;
// 108920: using guessed type float flt_108920;
// 108924: using guessed type float flt_108924;
// 108928: using guessed type float flt_108928;

//----- (00041E78) --------------------------------------------------------
int __fastcall fan_control_info_init(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        float a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13)
{
  char var1004[4104]; // [sp+38h] [bp-1004h] BYREF
  int varg_r0; // [sp+1048h] [bp+Ch]
  int varg_r1; // [sp+104Ch] [bp+10h]
  int varg_r2; // [sp+1050h] [bp+14h]
  int varg_r3; // [sp+1054h] [bp+18h]

  varg_r0 = a1;
  varg_r1 = a2;
  varg_r2 = a3;
  varg_r3 = a4;
  dword_106408 = a1;
  dword_10640C = a2;
  dword_106410 = a3;
  dword_106414 = a4;
  dword_106418 = a5;
  dword_10641C = a6;
  flt_106420 = a7;
  dword_106424 = a8;
  dword_106428 = a9;
  dword_10642C = a10;
  dword_106430 = a11;
  dword_106434 = a12;
  dword_106438 = a13;
  memset(&flt_108900, 0, 0x2Cu);
  if ( dword_106408 == 2 )
  {
    LODWORD(flt_108910) = dword_10642C;
    flt_108908 = (float)SLODWORD(flt_106420);
    LODWORD(flt_108914) = dword_106430;
    LODWORD(flt_108918) = dword_106434;
    flt_108904 = (float)dword_10640C;
    LODWORD(flt_10891C) = dword_106438;
    flt_108900 = (float)dword_106410;
  }
  V_LOCK();
  logfmt_raw(
    var1004,
    0x1000u,
    0,
    "startup P: %f, p: %f, i: %f, d: %f   target: %f, min %f, max %f",
    flt_108910,
    flt_108914,
    flt_108918,
    flt_10891C,
    flt_108908,
    flt_108904,
    flt_108900);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/miner_util/set_pwm_by_temp.c",
    156,
    "fan_control_info_init",
    21,
    331,
    40,
    var1004);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 106408: using guessed type int dword_106408;
// 10640C: using guessed type int dword_10640C;
// 106410: using guessed type int dword_106410;
// 106414: using guessed type int dword_106414;
// 106418: using guessed type int dword_106418;
// 10641C: using guessed type int dword_10641C;
// 106420: using guessed type float flt_106420;
// 106424: using guessed type int dword_106424;
// 106428: using guessed type int dword_106428;
// 10642C: using guessed type int dword_10642C;
// 106430: using guessed type int dword_106430;
// 106434: using guessed type int dword_106434;
// 106438: using guessed type int dword_106438;
// 108900: using guessed type float flt_108900;
// 108904: using guessed type float flt_108904;
// 108908: using guessed type float flt_108908;
// 108910: using guessed type float flt_108910;
// 108914: using guessed type float flt_108914;
// 108918: using guessed type float flt_108918;
// 10891C: using guessed type float flt_10891C;
// 11A7AC: using guessed type int g_zc;

//----- (00041FFC) --------------------------------------------------------
int __fastcall show_sn(int a1)
{
  bool v1; // zf
  FILE *v2; // r0
  FILE *v3; // r4
  int v4; // lr
  int v5; // r12
  _DWORD ptr[4]; // [sp+14h] [bp-1018h] BYREF
  __int16 v8; // [sp+24h] [bp-1008h]
  char v9[4100]; // [sp+28h] [bp-1004h] BYREF

  v1 = a1 == 0;
  if ( !a1 )
    a1 = 10268;
  memset(&ptr[1], 0, 12);
  if ( v1 )
    HIWORD(a1) = 14;
  v8 = 0;
  ptr[0] = 0;
  g_miner_sn_file_path = a1;
  v2 = (FILE *)fopen64(a1, "r");
  v3 = v2;
  if ( v2 )
  {
    if ( fread(ptr, 0x11u, 1u, v2) )
    {
      V_LOCK();
      logfmt_raw(v9, 0x1000u, 0, "miner sn: %s", ptr);
      V_UNLOCK();
      v4 = 60;
      v5 = 28;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v9, 0x1000u, 0, "miner sn: is NULL");
      V_UNLOCK();
      v4 = 100;
      v5 = 30;
    }
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/miner_util/show_sn.c",
      148,
      "show_sn",
      7,
      v5,
      v4,
      v9);
    return fclose(v3);
  }
  else
  {
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, "miner has no sn!");
    V_UNLOCK();
    return zlog(
             g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer"
             "-origin_godminer-new/miner_util/show_sn.c",
             148,
             "show_sn",
             7,
             22,
             100,
             v9);
  }
}
// 1EA0C: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10892C: using guessed type int g_miner_sn_file_path;
// 11A7AC: using guessed type int g_zc;

//----- (00042188) --------------------------------------------------------
int __fastcall get_miner_working_status(int result)
{
  int v1; // r1
  char v2; // r3

  if ( !byte_108930 )
  {
    byte_108934 = 0;
    byte_108935 = 0;
    byte_108936 = 0;
    byte_108937 = 0;
    byte_108938 = 0;
    byte_108939 = 0;
    byte_10893B = 0;
    byte_10893C = 0;
    byte_108930 = 1;
    byte_10893A = pools_active == 0;
  }
  v1 = *(_DWORD *)&byte_108938;
  v2 = byte_10893C;
  *(_DWORD *)result = *(_DWORD *)&byte_108934;
  *(_DWORD *)(result + 4) = v1;
  *(_BYTE *)(result + 8) = v2;
  return result;
}
// 1085D4: using guessed type char pools_active;
// 108930: using guessed type char byte_108930;
// 108934: using guessed type char byte_108934;
// 108935: using guessed type char byte_108935;
// 108936: using guessed type char byte_108936;
// 108937: using guessed type char byte_108937;
// 108938: using guessed type char byte_108938;
// 108939: using guessed type char byte_108939;
// 10893A: using guessed type char byte_10893A;
// 10893B: using guessed type char byte_10893B;
// 10893C: using guessed type char byte_10893C;

//----- (00042204) --------------------------------------------------------
int task_check_miner_status()
{
  char *all_created_runtime; // r0
  int v1; // r7
  int v2; // r2
  bool v3; // zf
  __int64 v4; // r0
  int v5; // r0
  char *flag_from_monitor; // r0
  int v7; // r3
  char *v8; // r4
  int *v9; // r0
  char *v10; // r0
  int v11; // r7
  char *v12; // r0
  int *v13; // r5
  int v14; // r4
  int v15; // t1
  char *v16; // r0
  int v17; // r4
  __int64 v18; // r10
  int v19; // r9
  int v20; // r1
  int v21; // r4
  int v22; // r6
  int v23; // r6
  int v24; // r2
  int v25; // r1
  int v26; // r2
  int v27; // r3
  int *v28; // r10
  int v29; // r1
  int v30; // r2
  int v31; // r3
  int v32; // r3
  int v33; // r4
  char *v34; // r0
  char *v35; // r10
  int v36; // t1
  int v37; // r0
  int v38; // r0
  char *v39; // r3
  char *v40; // r3
  char v41; // r2
  char v42; // r2
  int v43; // r2
  int v45; // r1
  int v46; // r2
  int v47; // r3
  int *v48; // r10
  int v49; // r1
  int v50; // r2
  int v51; // r3
  unsigned int v52; // r10
  int v53; // r9
  int v54; // r1
  int v55; // r2
  int v56; // r3
  int *v57; // r11
  int v58; // r1
  int v59; // r2
  int v60; // r3
  int v61; // r9
  int v62; // r1
  int v63; // r2
  int v64; // r3
  int *v65; // r12
  int v66; // r1
  int v67; // r2
  int v68; // r3
  int v69; // r1
  int v70; // r2
  int v71; // r3
  int *v72; // r12
  int v73; // r1
  int v74; // r2
  int v75; // r3
  unsigned int v76; // r9
  unsigned int v77; // r11
  int v78; // [sp+20h] [bp-1384h] BYREF
  int v79; // [sp+40h] [bp-1364h]
  const char *v80; // [sp+44h] [bp-1360h]
  int v81; // [sp+4Ch] [bp-1358h]
  __int64 v82; // [sp+50h] [bp-1354h]
  char *v83; // [sp+58h] [bp-134Ch]
  int v84; // [sp+5Ch] [bp-1348h]
  unsigned int v85; // [sp+60h] [bp-1344h]
  char *v86; // [sp+64h] [bp-1340h]
  __int64 v87; // [sp+68h] [bp-133Ch]
  unsigned int v88; // [sp+70h] [bp-1334h]
  int v89; // [sp+74h] [bp-1330h]
  __int64 v90; // [sp+78h] [bp-132Ch]
  int v91; // [sp+80h] [bp-1324h]
  int v92; // [sp+84h] [bp-1320h]
  int *v93; // [sp+88h] [bp-131Ch]
  const char *v94; // [sp+8Ch] [bp-1318h]
  int v95; // [sp+90h] [bp-1314h]
  int v96; // [sp+94h] [bp-1310h]
  int v97; // [sp+98h] [bp-130Ch]
  int v98; // [sp+9Ch] [bp-1308h]
  int *v99; // [sp+A0h] [bp-1304h]
  char *v100; // [sp+A4h] [bp-1300h]
  int v101; // [sp+A8h] [bp-12FCh]
  int v102; // [sp+ACh] [bp-12F8h]
  int v103; // [sp+B0h] [bp-12F4h]
  int v104; // [sp+B4h] [bp-12F0h]
  int v105; // [sp+B8h] [bp-12ECh]
  int v106; // [sp+BCh] [bp-12E8h]
  int v107; // [sp+C0h] [bp-12E4h]
  int v108; // [sp+C4h] [bp-12E0h]
  int v109; // [sp+C8h] [bp-12DCh]
  int v110; // [sp+CCh] [bp-12D8h]
  int v111; // [sp+D0h] [bp-12D4h]
  int v112; // [sp+D4h] [bp-12D0h]
  char *s; // [sp+D8h] [bp-12CCh]
  const char *v114; // [sp+DCh] [bp-12C8h]
  int v115; // [sp+E0h] [bp-12C4h]
  int v116; // [sp+E4h] [bp-12C0h]
  int v117; // [sp+E8h] [bp-12BCh]
  int v118; // [sp+ECh] [bp-12B8h]
  int v119; // [sp+F8h] [bp-12ACh]
  int v120; // [sp+FCh] [bp-12A8h]
  int v121; // [sp+100h] [bp-12A4h]
  int v122; // [sp+104h] [bp-12A0h]
  _DWORD v123[7]; // [sp+108h] [bp-129Ch] BYREF
  int v124; // [sp+124h] [bp-1280h]
  _DWORD v125[7]; // [sp+128h] [bp-127Ch] BYREF
  int v126; // [sp+144h] [bp-1260h]
  _DWORD v127[7]; // [sp+148h] [bp-125Ch] BYREF
  int v128; // [sp+164h] [bp-1240h]
  _DWORD v129[7]; // [sp+168h] [bp-123Ch] BYREF
  int v130; // [sp+184h] [bp-1220h]
  _DWORD v131[8]; // [sp+188h] [bp-121Ch] BYREF
  _DWORD v132[7]; // [sp+1A8h] [bp-11FCh] BYREF
  int v133; // [sp+1C4h] [bp-11E0h]
  _DWORD v134[8]; // [sp+1C8h] [bp-11DCh] BYREF
  _DWORD v135[7]; // [sp+1E8h] [bp-11BCh] BYREF
  int v136; // [sp+204h] [bp-11A0h]
  _DWORD v137[8]; // [sp+208h] [bp-119Ch] BYREF
  _DWORD v138[7]; // [sp+228h] [bp-117Ch] BYREF
  int v139; // [sp+244h] [bp-1160h]
  _DWORD v140[8]; // [sp+248h] [bp-115Ch] BYREF
  _DWORD v141[7]; // [sp+268h] [bp-113Ch] BYREF
  int v142; // [sp+284h] [bp-1120h]
  _DWORD v143[8]; // [sp+288h] [bp-111Ch] BYREF
  _DWORD v144[7]; // [sp+2A8h] [bp-10FCh] BYREF
  int v145; // [sp+2C4h] [bp-10E0h]
  __int64 v146; // [sp+2C8h] [bp-10DCh] BYREF
  int v147; // [sp+2D0h] [bp-10D4h]
  int v148; // [sp+2D4h] [bp-10D0h]
  int v149; // [sp+2D8h] [bp-10CCh]
  int v150; // [sp+2DCh] [bp-10C8h]
  int v151; // [sp+2E0h] [bp-10C4h]
  int v152; // [sp+2E4h] [bp-10C0h]
  float v153; // [sp+2E8h] [bp-10BCh]
  float v154; // [sp+2ECh] [bp-10B8h]
  float v155; // [sp+2F0h] [bp-10B4h]
  _DWORD v156[1025]; // [sp+3A0h] [bp-1004h] BYREF

  v86 = &byte_108930;
  if ( !byte_108930 )
  {
    byte_108934 = 0;
    byte_108935 = 0;
    byte_108936 = 0;
    byte_108937 = 0;
    byte_108938 = 0;
    byte_108939 = 0;
    byte_10893A = 0;
    byte_10893B = 0;
    byte_10893C = 0;
    byte_108930 = 1;
  }
  pthread_mutex_lock(&stru_108940);
  v129[0] = 0;
  v81 = (unsigned __int8)v86[12] ^ 1;
  all_created_runtime = (char *)get_all_created_runtime(v129);
  v146 = 0;
  v147 = 0;
  v148 = 0;
  if ( v129[0] <= 0 )
  {
    v93 = 0;
    v82 = 0;
    v88 = 0;
    goto LABEL_27;
  }
  v1 = 0;
  v100 = "chain";
  v114 = "uneffective temp exceed limit";
  s = "error";
  v85 = (unsigned int)(all_created_runtime - 4);
  do
  {
    while ( 1 )
    {
      v5 = *(_DWORD *)(v85 + 4);
      v85 += 4;
      flag_from_monitor = get_flag_from_monitor(v5);
      v7 = *((_DWORD *)flag_from_monitor + 4);
      v8 = flag_from_monitor;
      v82 = v7 & 1;
      if ( (v7 & 1) == 0 )
      {
        v89 = 0;
        v88 = v7 & 2;
        if ( (v7 & 2) == 0 )
        {
          v102 = 0;
          v101 = v7 & 4;
          if ( (v7 & 4) != 0 )
          {
            v3 = v81 == 0;
            *((_DWORD *)flag_from_monitor + 6) |= 4u;
            if ( v3 )
              goto LABEL_10;
            v94 = "check_temp";
            v77 = HIDWORD(v146);
            v76 = v146;
            LODWORD(v90) = "%s";
            v99 = &g_zc;
            v93 = &v78;
            goto LABEL_98;
          }
          goto LABEL_21;
        }
        v3 = v81 == 0;
        *((_DWORD *)flag_from_monitor + 6) |= 2u;
        if ( v3 )
        {
          LODWORD(v87) = v7 & 4;
          HIDWORD(v87) = v81;
          if ( (unsigned int)v87 | v81 )
          {
LABEL_9:
            *((_DWORD *)v8 + 6) |= 4u;
LABEL_10:
            v97 = v7 & 8;
            v98 = 0;
            if ( (v7 & 8) != 0 )
              *((_DWORD *)v8 + 6) |= 8u;
LABEL_12:
            v83 = (char *)(v7 & 0x10);
            v84 = 0;
            if ( (v7 & 0x10) == 0 )
              goto LABEL_15;
            v3 = v81 == 0;
            *((_DWORD *)v8 + 6) |= 0x10u;
            if ( v3 )
              goto LABEL_15;
            v94 = "check_temp";
            LODWORD(v90) = "%s";
            v99 = &g_zc;
            v93 = &v78;
            goto LABEL_106;
          }
          goto LABEL_21;
        }
        v94 = "check_temp";
        v77 = HIDWORD(v146);
        v76 = v146;
        LODWORD(v90) = "%s";
        v99 = &g_zc;
        v93 = &v78;
        goto LABEL_96;
      }
      v2 = *((_DWORD *)flag_from_monitor + 6);
      v3 = v81 == 0;
      *((_DWORD *)flag_from_monitor + 6) = v2 | 1;
      if ( v3 )
        break;
      V_LOCK();
      v93 = &v78;
      v24 = *(_DWORD *)(*(_DWORD *)v85 + 200);
      LODWORD(v90) = "%s";
      v99 = &g_zc;
      v94 = "check_temp";
      V_INT((int)v144, v100, v24);
      V_STR(v143, s, "temp lost");
      v25 = v143[1];
      v26 = v143[2];
      v27 = v143[3];
      v28 = v93;
      v80 = "check_temp";
      v79 = v90;
      *v93 = v143[0];
      v28[1] = v25;
      v28[2] = v26;
      v28[3] = v27;
      v28 += 4;
      v29 = v143[5];
      v30 = v143[6];
      v31 = v143[7];
      *v28 = v143[4];
      v28[1] = v29;
      v28[2] = v30;
      v28[3] = v31;
      logfmt_raw((char *)v156, 0x1000u, 0, v145, v144[0], v144[1], v144[2], v144[3], v144[4], v144[5], v144[6], v145);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/miner_util/miner_monitor/check_miner_status.c",
        173,
        "check_temp",
        10,
        35,
        100,
        v156);
      v106 = 0;
      v77 = HIDWORD(v146);
      v76 = v146 | 1;
      LODWORD(v146) = v146 | 1;
      v32 = *((_DWORD *)v8 + 4);
      v105 = v32 & 2;
      if ( (v32 & 2) != 0 )
      {
        *((_DWORD *)v8 + 6) |= 2u;
LABEL_96:
        V_LOCK();
        v76 |= 2u;
        V_INT((int)v141, v100, *(int *)(*(_DWORD *)v85 + 200));
        V_STR(v140, s, "temp too high");
        v45 = v140[1];
        v46 = v140[2];
        v47 = v140[3];
        v80 = v94;
        v48 = v93;
        v79 = v90;
        *v93 = v140[0];
        v48[1] = v45;
        v48[2] = v46;
        v48[3] = v47;
        v48 += 4;
        v49 = v140[5];
        v50 = v140[6];
        v51 = v140[7];
        *v48 = v140[4];
        v48[1] = v49;
        v48[2] = v50;
        v48[3] = v51;
        logfmt_raw((char *)v156, 0x1000u, 0, v142, v141[0], v141[1], v141[2], v141[3], v141[4], v141[5], v141[6], v142);
        V_UNLOCK();
        zlog(
          *v99,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/miner_util/miner_monitor/check_miner_status.c",
          173,
          "check_temp",
          10,
          43,
          100,
          v156);
        v146 = __PAIR64__(v77, v76);
        v7 = *((_DWORD *)v8 + 4);
        v107 = v7 & 4;
        v108 = 0;
        if ( (v7 & 4) != 0 )
          goto LABEL_97;
        goto LABEL_21;
      }
      v118 = 0;
      v117 = v32 & 4;
      if ( (v32 & 4) == 0 )
      {
        v120 = 0;
        v119 = v32 & 8;
        if ( (v32 & 8) == 0 )
        {
          v122 = 0;
          v121 = v32 & 0x10;
          if ( (v32 & 0x10) == 0 )
            goto LABEL_15;
          *((_DWORD *)v8 + 6) |= 0x10u;
LABEL_106:
          v52 = HIDWORD(v146);
          v61 = v146;
          goto LABEL_102;
        }
        *((_DWORD *)v8 + 6) |= 8u;
        goto LABEL_107;
      }
LABEL_97:
      *((_DWORD *)v8 + 6) |= 4u;
LABEL_98:
      V_LOCK();
      v52 = v77;
      v53 = v76 | 4;
      V_INT((int)v138, v100, *(int *)(*(_DWORD *)v85 + 200));
      V_STR(v137, s, "temp too low");
      v54 = v137[1];
      v55 = v137[2];
      v56 = v137[3];
      v80 = v94;
      v57 = v93;
      v79 = v90;
      *v93 = v137[0];
      v57[1] = v54;
      v57[2] = v55;
      v57[3] = v56;
      v57 += 4;
      v58 = v137[5];
      v59 = v137[6];
      v60 = v137[7];
      *v57 = v137[4];
      v57[1] = v58;
      v57[2] = v59;
      v57[3] = v60;
      logfmt_raw((char *)v156, 0x1000u, 0, v139, v138[0], v138[1], v138[2], v138[3], v138[4], v138[5], v138[6], v139);
      V_UNLOCK();
      zlog(
        *v99,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/miner_util/miner_monitor/check_miner_status.c",
        173,
        "check_temp",
        10,
        51,
        100,
        v156);
      v146 = __PAIR64__(v52, v53);
      v7 = *((_DWORD *)v8 + 4);
      v109 = v7 & 8;
      v110 = 0;
      if ( (v7 & 8) == 0 )
        goto LABEL_12;
      *((_DWORD *)v8 + 6) |= 8u;
LABEL_100:
      V_LOCK();
      v61 = v53 | 8;
      V_INT((int)v135, v100, *(int *)(*(_DWORD *)v85 + 200));
      V_STR(v134, s, "read no temp");
      v62 = v134[1];
      v63 = v134[2];
      v64 = v134[3];
      v65 = v93;
      v80 = v94;
      v79 = v90;
      *v93 = v134[0];
      v65[1] = v62;
      v65[2] = v63;
      v65[3] = v64;
      v65 += 4;
      v66 = v134[5];
      v67 = v134[6];
      v68 = v134[7];
      *v65 = v134[4];
      v65[1] = v66;
      v65[2] = v67;
      v65[3] = v68;
      logfmt_raw((char *)v156, 0x1000u, 0, v136, v135[0], v135[1], v135[2], v135[3], v135[4], v135[5], v135[6], v136);
      V_UNLOCK();
      zlog(
        *v99,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/miner_util/miner_monitor/check_miner_status.c",
        173,
        "check_temp",
        10,
        59,
        100,
        v156);
      v146 = __PAIR64__(v52, v61);
      v111 = *((_DWORD *)v8 + 4) & 0x10;
      v112 = 0;
      if ( v111 )
      {
        *((_DWORD *)v8 + 6) |= 0x10u;
LABEL_102:
        V_LOCK();
        V_INT((int)v132, v100, *(int *)(*(_DWORD *)v85 + 200));
        V_STR(v131, s, v114);
        v69 = v131[1];
        v70 = v131[2];
        v71 = v131[3];
        v72 = v93;
        v80 = v94;
        v79 = v90;
        *v93 = v131[0];
        v72[1] = v69;
        v72[2] = v70;
        v72[3] = v71;
        v72 += 4;
        v73 = v131[5];
        v74 = v131[6];
        v75 = v131[7];
        *v72 = v131[4];
        v72[1] = v73;
        v72[2] = v74;
        v72[3] = v75;
        logfmt_raw((char *)v156, 0x1000u, 0, v133, v132[0], v132[1], v132[2], v132[3], v132[4], v132[5], v132[6], v133);
        V_UNLOCK();
        zlog(
          *v99,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/miner_util/miner_monitor/check_miner_status.c",
          173,
          "check_temp",
          10,
          67,
          100,
          v156);
        HIDWORD(v146) = v52;
        LODWORD(v146) = v61 | 0x10;
      }
LABEL_15:
      if ( ++v1 >= v129[0] )
        goto LABEL_26;
    }
    v95 = v7 & 2;
    LODWORD(v87) = v7 & 4;
    v96 = v81;
    HIDWORD(v87) = v81;
    if ( !(v95 | v81) )
    {
      if ( v87 )
      {
        *((_DWORD *)flag_from_monitor + 6) = v2 | 5;
        goto LABEL_10;
      }
      v115 = v7 & 8;
      v116 = v81;
      if ( !(v115 | v81) )
        goto LABEL_12;
      *((_DWORD *)flag_from_monitor + 6) = v2 | 9;
      goto LABEL_24;
    }
    v4 = v87;
    *((_DWORD *)v8 + 6) = v2 | 3;
    if ( v4 )
      goto LABEL_9;
LABEL_21:
    v91 = v7 & 8;
    v92 = 0;
    if ( (v7 & 8) == 0 )
      goto LABEL_12;
    v3 = v81 == 0;
    *((_DWORD *)v8 + 6) |= 8u;
    if ( !v3 )
    {
      v94 = "check_temp";
      LODWORD(v90) = "%s";
      v99 = &g_zc;
      v93 = &v78;
LABEL_107:
      v52 = HIDWORD(v146);
      v53 = v146;
      goto LABEL_100;
    }
LABEL_24:
    v103 = v7 & 0x10;
    v104 = 0;
    if ( (v7 & 0x10) == 0 )
      goto LABEL_15;
    ++v1;
    *((_DWORD *)v8 + 6) |= 0x10u;
  }
  while ( v1 < v129[0] );
LABEL_26:
  v82 = v146;
  v88 = ((unsigned int)v146 >> 2) & 1;
  v93 = (int *)((v146 >> 1) & 1);
LABEL_27:
  LODWORD(v146) = 0;
  v9 = (int *)get_all_created_runtime(&v146);
  v10 = get_flag_from_monitor(*v9);
  if ( (*((_DWORD *)v10 + 8) & 4) == 0 || (v3 = v81 == 0, *((_DWORD *)v10 + 10) |= 4u, v3) )
  {
    v85 = 0;
  }
  else
  {
    V_LOCK();
    V_STR(v129, "error", "fan error exceed limit");
    v85 = v81;
    logfmt_raw(
      (char *)v156,
      0x1000u,
      0,
      v130,
      v129[0],
      v129[1],
      v129[2],
      v129[3],
      v129[4],
      v129[5],
      v129[6],
      v130,
      "%s",
      "check_fan_err");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/miner_util/miner_monitor/check_miner_status.c",
      173,
      "check_fan_err",
      13,
      84,
      100,
      v156);
  }
  v11 = 0;
  v125[0] = 0;
  v12 = (char *)get_all_created_runtime(v125);
  if ( v125[0] > 0 )
  {
    v13 = (int *)(v12 - 4);
    v14 = 0;
    v83 = "chain";
    do
    {
      while ( 1 )
      {
        v15 = v13[1];
        ++v13;
        v16 = get_flag_from_monitor(v15);
        if ( (*(_DWORD *)v16 & 1) != 0 )
        {
          v3 = v81 == 0;
          *((_DWORD *)v16 + 2) |= 1u;
          if ( !v3 )
            break;
        }
        if ( ++v14 >= v125[0] )
          goto LABEL_37;
      }
      V_LOCK();
      ++v14;
      V_INT((int)v127, v83, *(int *)(*v13 + 200));
      v11 = v81;
      logfmt_raw(
        (char *)v156,
        0x1000u,
        0,
        v128,
        v127[0],
        v127[1],
        v127[2],
        v127[3],
        v127[4],
        v127[5],
        v127[6],
        v128,
        "%s low hashrate happened!",
        "check_low_hashrate");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/miner_util/miner_monitor/check_miner_status.c",
        173,
        "check_low_hashrate",
        18,
        103,
        80,
        v156);
      read_status_from_monitor(&v146, *v13);
      V_LOCK();
      logfmt_raw((char *)v156, 0x1000u, 0, "no ratio hashrate last_5s: %f", v153 / 1000000000.0);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/miner_util/miner_monitor/check_miner_status.c",
        173,
        "check_low_hashrate",
        18,
        106,
        80,
        v156);
      V_LOCK();
      logfmt_raw((char *)v156, 0x1000u, 0, "no ratio hashrate last_30min: %f", v154 / 1000000000.0);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/miner_util/miner_monitor/check_miner_status.c",
        173,
        "check_low_hashrate",
        18,
        107,
        80,
        v156);
      V_LOCK();
      logfmt_raw((char *)v156, 0x1000u, 0, "no ratio hashrate lifetime: %f", v155 / 1000000000.0);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/miner_util/miner_monitor/check_miner_status.c",
        173,
        "check_low_hashrate",
        18,
        108,
        80,
        v156);
    }
    while ( v14 < v125[0] );
  }
LABEL_37:
  if ( !v86[40] )
  {
    clock_gettime(1, &stru_10895C);
    v86[40] = 1;
  }
  if ( total_pools > 0 )
  {
    v17 = 0;
    do
    {
      while ( pool_tget(*(_DWORD *)(pools + 4 * v17), (unsigned __int8 *)(*(_DWORD *)(pools + 4 * v17) + 1896))
           || !pools_active )
      {
        if ( ++v17 >= total_pools )
          goto LABEL_45;
      }
      clock_gettime(1, &stru_10895C);
      ++v17;
    }
    while ( v17 < total_pools );
  }
LABEL_45:
  clock_gettime(1, &stru_108964);
  v18 = 1000LL * (*((_DWORD *)v86 + 13) - *((_DWORD *)v86 + 11))
      + (*((_DWORD *)v86 + 14) - *((_DWORD *)v86 + 12)) / 1000000;
  if ( v18 <= 59999 )
    v19 = v86[60] & 1;
  else
    v19 = 0;
  if ( v19 )
  {
    V_LOCK();
    logfmt_raw(
      (char *)v156,
      0x1000u,
      0,
      "The pool connection recovered after the system poweroff. Exit and restart mining!");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/miner_util/miner_monitor/check_miner_status.c",
      173,
      "check_lost_connection_to_pool",
      29,
      139,
      80,
      v156);
    exit(1);
  }
  v83 = (char *)(((unsigned int)v82 >> 4) & 1);
  v20 = v85;
  LODWORD(v87) = ((unsigned int)v82 >> 3) & 1;
  if ( (v82 & 0x1E) != 0 )
    v20 = v85 | 1;
  v21 = v20;
  LODWORD(v90) = v11 | v20;
  if ( !v81 )
    goto LABEL_70;
  if ( v18 <= 60000 )
  {
    *((_DWORD *)v86 + 16) = 0;
LABEL_70:
    LOBYTE(v23) = v86[12];
    if ( (_BYTE)v23 )
      goto LABEL_80;
    if ( !v20 )
    {
      if ( v11 )
      {
        LOBYTE(v19) = 0;
        goto LABEL_80;
      }
      goto LABEL_78;
    }
    v19 = (unsigned __int8)v86[12];
LABEL_73:
    v33 = 0;
    v156[0] = 0;
    v86[12] = 1;
    v34 = (char *)get_all_created_runtime(v156);
    if ( v156[0] > 0 )
    {
      v35 = v34 - 4;
      do
      {
        v36 = *((_DWORD *)v35 + 1);
        v35 += 4;
        ++v33;
        v37 = (*(int (**)(void))(v36 + 12))();
        v38 = dev_ctrl(v37);
        (*(void (__fastcall **)(_DWORD))(v38 + 28))(*(_DWORD *)(*(_DWORD *)v35 + 196));
      }
      while ( v33 < v156[0] );
    }
    power_off();
    V_LOCK();
    V_BOOL((int)v123, "poweroff", 1);
    logfmt_raw(
      (char *)v156,
      0x1000u,
      0,
      v124,
      v123[0],
      v123[1],
      v123[2],
      v123[3],
      v123[4],
      v123[5],
      v123[6],
      v124,
      "high temp %d low temp %d fan err %d read no temp %d, uneffective temp %d, lost connection too long %d",
      v93,
      v88,
      v85,
      (_DWORD)v87,
      v83,
      v19);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/miner_util/miner_monitor/check_miner_status.c",
      173,
      "task_check_miner_status",
      23,
      292,
      120,
      v156);
    if ( (_DWORD)v90 || v86[12] )
      goto LABEL_79;
LABEL_78:
    LOBYTE(v19) = v23;
    v86[11] = 0;
    goto LABEL_81;
  }
  v22 = *((_DWORD *)v86 + 16);
  *((_DWORD *)v86 + 16) = v22 + 1;
  if ( !(v22 % 60) )
  {
    V_LOCK();
    V_STR(&v146, "error", "net lost");
    v90 = 274877907LL * (int)v18;
    logfmt_raw(
      (char *)v156,
      0x1000u,
      0,
      v152,
      v146,
      v147,
      v148,
      v149,
      v150,
      v151,
      v152,
      "lost internet for %d seconds",
      (int)v18 / 1000);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/miner_util/miner_monitor/check_miner_status.c",
      173,
      "check_lost_connection_to_pool",
      29,
      146,
      100,
      v156);
  }
  if ( v18 <= 1200000 )
  {
    v19 = (unsigned __int8)v86[12];
    if ( v86[12] )
      goto LABEL_80;
    if ( !v21 )
    {
      LOBYTE(v19) = v81;
      goto LABEL_80;
    }
LABEL_59:
    LODWORD(v90) = v21;
    LOBYTE(v23) = v21;
    goto LABEL_73;
  }
  v23 = (unsigned __int8)v86[60];
  if ( !v86[60] )
  {
    V_LOCK();
    V_STR(v125, "error", "net lost");
    logfmt_raw(
      (char *)v156,
      0x1000u,
      v23,
      v126,
      v125[0],
      v125[1],
      v125[2],
      v125[3],
      v125[4],
      v125[5],
      v125[6],
      v126,
      "lost internet %d seconds > 20 minutes, poweroff.",
      (int)v18 / 1000);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/miner_util/miner_monitor/check_miner_status.c",
      173,
      "check_lost_connection_to_pool",
      29,
      156,
      120,
      v156);
    v19 = (unsigned __int8)v86[12];
    v86[60] = 1;
    if ( v19 )
      goto LABEL_80;
    LOBYTE(v23) = v81;
    v19 = 1;
    LODWORD(v90) = v81;
    goto LABEL_73;
  }
  v19 = (unsigned __int8)v86[12];
  if ( !v86[12] )
  {
    if ( v21 )
      goto LABEL_59;
LABEL_79:
    LOBYTE(v19) = v23;
  }
LABEL_80:
  v86[11] = 1;
LABEL_81:
  if ( v81 )
  {
    v39 = v86;
    if ( !v11 )
      LOBYTE(v11) = v86[12];
    v86[4] = (char)v93;
    v39[5] = v88;
    v39[8] = v85;
    v40 = v86;
    v41 = v87;
    v86[9] = v11;
    v40[6] = v41;
    v42 = (char)v83;
    v40[10] = v19;
    v40[7] = v42;
  }
  pthread_mutex_unlock(&stru_108940);
  v43 = (unsigned __int8)v86[11];
  byte_10643C ^= 1u;
  if ( v43 )
  {
    green_led_off();
    if ( byte_10643C )
      red_led_on();
    else
      red_led_off();
  }
  else
  {
    red_led_off();
    if ( byte_10643C )
      green_led_on();
    else
      green_led_off();
  }
  if ( (v82 & 0x1A) != 0 )
    return fan_pwm_set_max();
  else
    return set_pwm_by_temp();
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4AB8C: using guessed type int __fastcall dev_ctrl(_DWORD);
// 10643C: using guessed type char byte_10643C;
// 107BA0: using guessed type int total_pools;
// 107BA4: using guessed type int pools;
// 1085D4: using guessed type char pools_active;
// 108930: using guessed type char byte_108930;
// 108934: using guessed type char byte_108934;
// 108935: using guessed type char byte_108935;
// 108936: using guessed type char byte_108936;
// 108937: using guessed type char byte_108937;
// 108938: using guessed type char byte_108938;
// 108939: using guessed type char byte_108939;
// 10893A: using guessed type char byte_10893A;
// 10893B: using guessed type char byte_10893B;
// 10893C: using guessed type char byte_10893C;
// 11A7AC: using guessed type int g_zc;

//----- (00043588) --------------------------------------------------------
int sub_43588()
{
  int v0; // r8
  __int64 v1; // r0
  int *v2; // r5
  int v3; // t1
  int updated; // r4
  int v5; // lr
  int v6; // r12
  int v7; // r2
  int v9; // [sp+4h] [bp-4h] BYREF

  v0 = 0;
  v9 = 0;
  LODWORD(v1) = get_all_created_runtime(&v9);
  if ( v9 > 0 )
  {
    v2 = (int *)(v1 - 4);
    do
    {
      while ( 1 )
      {
        v3 = v2[1];
        ++v2;
        ++v0;
        updated = update_fanspeed(
                    v3,
                    (_DWORD *)&unk_108E78 + 54 * *(_DWORD *)(v3 + 196),
                    (int)&unk_108978 + 80 * *(_DWORD *)(v3 + 196));
        v1 = *(_QWORD *)updated;
        if ( *(_QWORD *)updated )
          break;
        if ( v9 <= v0 )
          return v1;
      }
      subject_notify_all(dword_109BF8, *v2);
      LODWORD(v1) = *(_DWORD *)(updated + 12);
      v5 = *(_DWORD *)(updated + 4);
      v6 = *(_DWORD *)(updated + 8);
      *(_QWORD *)(updated + 8) = 0;
      HIDWORD(v1) = *(_DWORD *)updated;
      *(_DWORD *)(updated + 4) = v5 & ~(_DWORD)v1;
      v7 = v9;
      *(_DWORD *)updated = HIDWORD(v1) & ~v6;
    }
    while ( v7 > v0 );
  }
  return v1;
}
// 109BF8: using guessed type int dword_109BF8;

//----- (00043650) --------------------------------------------------------
int sub_43650()
{
  int v0; // r8
  __int64 v1; // r0
  int *v2; // r5
  int v3; // t1
  _DWORD *updated; // r4
  int v5; // lr
  int v6; // r12
  int v7; // r2
  int v9; // [sp+4h] [bp-4h] BYREF

  v0 = 0;
  v9 = 0;
  LODWORD(v1) = get_all_created_runtime(&v9);
  if ( v9 > 0 )
  {
    v2 = (int *)(v1 - 4);
    do
    {
      while ( 1 )
      {
        v3 = v2[1];
        ++v2;
        ++v0;
        updated = update_hashrate(
                    v3,
                    (int)&unk_108E78 + 216 * *(_DWORD *)(v3 + 196),
                    &dword_108978[20 * *(_DWORD *)(v3 + 196)]);
        v1 = *(_QWORD *)updated;
        if ( *(_QWORD *)updated )
          break;
        if ( v9 <= v0 )
          return v1;
      }
      subject_notify_all(dword_109BFC, *v2);
      LODWORD(v1) = updated[3];
      v5 = updated[1];
      v6 = updated[2];
      *((_QWORD *)updated + 1) = 0;
      HIDWORD(v1) = *updated;
      updated[1] = v5 & ~(_DWORD)v1;
      v7 = v9;
      *updated = HIDWORD(v1) & ~v6;
    }
    while ( v7 > v0 );
  }
  return v1;
}
// 108978: using guessed type _DWORD dword_108978[320];
// 109BFC: using guessed type int dword_109BFC;

//----- (00043718) --------------------------------------------------------
int sub_43718()
{
  int v0; // r8
  __int64 v1; // r0
  int *v2; // r5
  int v3; // t1
  _DWORD *updated; // r4
  int v5; // lr
  int v6; // r12
  int v7; // r2
  int v9; // [sp+4h] [bp-4h] BYREF

  v0 = 0;
  v9 = 0;
  LODWORD(v1) = get_all_created_runtime(&v9);
  if ( v9 > 0 )
  {
    v2 = (int *)(v1 - 4);
    do
    {
      while ( 1 )
      {
        v3 = v2[1];
        ++v2;
        ++v0;
        updated = update_chip_status(
                    v3,
                    (int)&unk_108E78 + 216 * *(_DWORD *)(v3 + 196),
                    (int)&dword_108978[20 * *(_DWORD *)(v3 + 196)]);
        v1 = *(_QWORD *)updated;
        if ( *(_QWORD *)updated )
          break;
        if ( v9 <= v0 )
          return v1;
      }
      subject_notify_all(dword_109C00, *v2);
      LODWORD(v1) = updated[3];
      v5 = updated[1];
      v6 = updated[2];
      *((_QWORD *)updated + 1) = 0;
      HIDWORD(v1) = *updated;
      updated[1] = v5 & ~(_DWORD)v1;
      v7 = v9;
      *updated = HIDWORD(v1) & ~v6;
    }
    while ( v7 > v0 );
  }
  return v1;
}
// 108978: using guessed type _DWORD dword_108978[320];
// 109C00: using guessed type int dword_109C00;

//----- (000437E0) --------------------------------------------------------
int sub_437E0()
{
  int v0; // r8
  __int64 v1; // r0
  int *v2; // r5
  int v3; // t1
  int updated; // r4
  int v5; // lr
  int v6; // r12
  int v7; // r2
  int v9; // [sp+4h] [bp-4h] BYREF

  v0 = 0;
  v9 = 0;
  LODWORD(v1) = get_all_created_runtime(&v9);
  if ( v9 > 0 )
  {
    v2 = (int *)(v1 - 4);
    do
    {
      while ( 1 )
      {
        v3 = v2[1];
        ++v2;
        ++v0;
        updated = update_temperature(
                    v3,
                    (_DWORD *)&unk_108E78 + 54 * *(_DWORD *)(v3 + 196),
                    (int)&dword_108978[20 * *(_DWORD *)(v3 + 196)]);
        v1 = *(_QWORD *)updated;
        if ( *(_QWORD *)updated )
          break;
        if ( v9 <= v0 )
          return v1;
      }
      subject_notify_all(dword_109C04, *v2);
      LODWORD(v1) = *(_DWORD *)(updated + 12);
      v5 = *(_DWORD *)(updated + 4);
      v6 = *(_DWORD *)(updated + 8);
      *(_QWORD *)(updated + 8) = 0;
      HIDWORD(v1) = *(_DWORD *)updated;
      *(_DWORD *)(updated + 4) = v5 & ~(_DWORD)v1;
      v7 = v9;
      *(_DWORD *)updated = HIDWORD(v1) & ~v6;
    }
    while ( v7 > v0 );
  }
  return v1;
}
// 108978: using guessed type _DWORD dword_108978[320];
// 109C04: using guessed type int dword_109C04;

//----- (000438A8) --------------------------------------------------------
int do_miner_monitor_start()
{
  int v0; // r5
  char *all_created_runtime; // r0
  int v2; // r3
  char *v3; // r4
  int v4; // t1
  int v6; // [sp+4h] [bp-8h] BYREF

  v0 = 0;
  v6 = 0;
  all_created_runtime = (char *)get_all_created_runtime(&v6);
  v2 = v6;
  if ( v6 > 0 )
  {
    v3 = all_created_runtime - 4;
    do
    {
      v4 = *((_DWORD *)v3 + 1);
      v3 += 4;
      if ( !*(_BYTE *)(v4 + 206) )
      {
        do
          sleep(1u);
        while ( !*(_BYTE *)(*(_DWORD *)v3 + 206) );
        v2 = v6;
      }
      ++v0;
    }
    while ( v2 > v0 );
  }
  force_exec_all_task(dword_109C08);
  force_exec_all_task(dword_109C0C);
  start_task_timer((_DWORD *)dword_109C08);
  return start_task_timer((_DWORD *)dword_109C0C);
}
// 109C08: using guessed type int dword_109C08;
// 109C0C: using guessed type int dword_109C0C;

//----- (00043938) --------------------------------------------------------
int __fastcall miner_monitor_init(int a1)
{
  int (**v1)(void); // r0
  int v2; // r0
  char *v3; // r4
  char *v4; // r5
  _BYTE *v5; // r0
  int v6; // r0

  v1 = (int (**)(void))dev_ctrl(a1);
  v2 = (*v1)();
  if ( v2 > 0 )
  {
    v3 = (char *)&unk_108E78;
    v4 = (char *)&unk_108E78 + 216 * v2;
    do
    {
      v5 = calloc(0x100u, 1u);
      *((_DWORD *)v3 + 17) = v5;
      *v5 = 63;
      *((_DWORD *)v3 + 24) = calloc(0x10u, 4u);
      *((_DWORD *)v3 + 25) = calloc(0x10u, 4u);
      *((_DWORD *)v3 + 1) = calloc(0x10u, 4u);
      *(_DWORD *)v3 = calloc(0x10u, 4u);
      *((_DWORD *)v3 + 3) = calloc(0x10u, 4u);
      *((_DWORD *)v3 + 2) = calloc(0x10u, 4u);
      *((_QWORD *)v3 + 26) = 0;
      v6 = (int)v3;
      *((_DWORD *)v3 + 50) = 0;
      v3 += 216;
      init_temp_senor_info(v6);
    }
    while ( v3 != v4 );
  }
  dword_109C04 = (int)new_observable_subject();
  dword_109BFC = (int)new_observable_subject();
  dword_109C00 = (int)new_observable_subject();
  dword_109BF8 = (int)new_observable_subject();
  dword_109C08 = (int)new_task_timer();
  add_new_task(dword_109C08, (int)sub_437E0, 1000);
  add_new_task(dword_109C08, (int)sub_43718, (int)"evice");
  add_new_task(dword_109C08, (int)sub_43D30, 60000);
  dword_109C0C = (int)new_task_timer();
  add_new_task(dword_109C0C, (int)sub_43650, 5000);
  add_new_task(dword_109C0C, (int)sub_43588, 1000);
  return add_new_task(dword_109C0C, (int)task_check_miner_status, 1000);
}
// 4AB8C: using guessed type int __fastcall dev_ctrl(_DWORD);
// 109BF8: using guessed type int dword_109BF8;
// 109BFC: using guessed type int dword_109BFC;
// 109C00: using guessed type int dword_109C00;
// 109C04: using guessed type int dword_109C04;
// 109C08: using guessed type int dword_109C08;
// 109C0C: using guessed type int dword_109C0C;

//----- (00043AB4) --------------------------------------------------------
void miner_monitor_deinit()
{
  int v0; // r0
  int (**v1)(void); // r0
  int v2; // r0
  char *v3; // r4
  char *v4; // r5
  void *v5; // r0

  destroy_task_timer((_DWORD *)dword_109C0C);
  destroy_task_timer((_DWORD *)dword_109C08);
  destroy_observable_subject((void *)dword_109C04);
  destroy_observable_subject((void *)dword_109BFC);
  destroy_observable_subject((void *)dword_109C00);
  destroy_observable_subject((void *)dword_109BF8);
  v1 = (int (**)(void))dev_ctrl(v0);
  v2 = (*v1)();
  if ( v2 > 0 )
  {
    v3 = (char *)&unk_108E78;
    v4 = (char *)&unk_108E78 + 216 * v2;
    do
    {
      v5 = (void *)*((_DWORD *)v3 + 17);
      v3 += 216;
      free(v5);
      free(*((void **)v3 - 30));
      free(*((void **)v3 - 53));
      free(*((void **)v3 - 54));
      free(*((void **)v3 - 51));
      free(*((void **)v3 - 52));
    }
    while ( v3 != v4 );
  }
}
// 43AF0: variable 'v0' is possibly undefined
// 4AB8C: using guessed type int __fastcall dev_ctrl(_DWORD);
// 109BF8: using guessed type int dword_109BF8;
// 109BFC: using guessed type int dword_109BFC;
// 109C00: using guessed type int dword_109C00;
// 109C04: using guessed type int dword_109C04;
// 109C08: using guessed type int dword_109C08;
// 109C0C: using guessed type int dword_109C0C;

//----- (00043B54) --------------------------------------------------------
int miner_monitor_start()
{
  void *(*v0)(void *); // r2
  pthread_t newthread[2]; // [sp+4h] [bp-8h] BYREF

  LOWORD(v0) = 14504;
  HIWORD(v0) = (unsigned int)&loc_4DEA0 >> 16;
  pthread_create(newthread, 0, v0, 0);
  return pthread_detach(newthread[0]);
}

//----- (00043B84) --------------------------------------------------------
int miner_monitor_stop()
{
  stop_task_timer(dword_109C0C);
  return stop_task_timer(dword_109C08);
}
// 109C08: using guessed type int dword_109C08;
// 109C0C: using guessed type int dword_109C0C;

//----- (00043BA4) --------------------------------------------------------
void *__fastcall read_status_from_monitor(void *a1, int a2)
{
  memcpy(a1, (char *)&unk_108978 + 216 * *(_DWORD *)(a2 + 196) + 1280, 0xD8u);
  return a1;
}

//----- (00043BD4) --------------------------------------------------------
int __fastcall add_temperature_observer(int a1)
{
  return subject_observe(dword_109C04, a1);
}
// 109C04: using guessed type int dword_109C04;

//----- (00043BE8) --------------------------------------------------------
int __fastcall add_hashrate_observer(int a1)
{
  return subject_observe(dword_109BFC, a1);
}
// 109BFC: using guessed type int dword_109BFC;

//----- (00043BFC) --------------------------------------------------------
int __fastcall add_chip_status_observer(int a1)
{
  return subject_observe(dword_109C00, a1);
}
// 109C00: using guessed type int dword_109C00;

//----- (00043C10) --------------------------------------------------------
int __fastcall add_fanspeed_observer(int a1)
{
  return subject_observe(dword_109BF8, a1);
}
// 109BF8: using guessed type int dword_109BF8;

//----- (00043C24) --------------------------------------------------------
int __fastcall read_system_status_from_monitor(int a1)
{
  int *all_created_runtime; // r0
  double v3; // d6
  float v4; // s15
  int *v5; // r7
  double v6; // d5
  float v7; // s14
  float v8; // s9
  __int64 v9; // kr00_8
  int v10; // t1
  char *v11; // r3
  int v13; // r1
  int v14; // r3
  int v15; // [sp+4h] [bp-4h] BYREF

  v15 = 0;
  all_created_runtime = (int *)get_all_created_runtime(&v15);
  v3 = 0.0;
  if ( v15 <= 0 )
  {
    v4 = 0.0;
    v6 = 0.0;
    v7 = 0.0;
    v8 = 0.0;
    v9 = 0;
  }
  else
  {
    v4 = 0.0;
    v5 = &all_created_runtime[v15];
    v6 = 0.0;
    v7 = 0.0;
    v8 = 0.0;
    v9 = 0;
    do
    {
      v10 = *all_created_runtime++;
      v11 = (char *)&unk_108E78 + 216 * *(_DWORD *)(v10 + 196);
      v9 += *((_QWORD *)v11 + 10);
      v8 = v8 + *((float *)v11 + 8);
      v7 = v7 + *((float *)v11 + 9);
      v4 = v4 + *((float *)v11 + 10);
      v6 = v6 + *((double *)v11 + 6);
      v3 = v3 + *((double *)v11 + 7);
    }
    while ( v5 != all_created_runtime );
  }
  *(_DWORD *)a1 = v15;
  v13 = dword_108ED4;
  v14 = dword_108ED8;
  *(float *)(a1 + 12) = v8;
  *(float *)(a1 + 16) = v7;
  *(float *)(a1 + 20) = v4;
  *(double *)(a1 + 24) = v6;
  *(double *)(a1 + 32) = v3;
  *(_QWORD *)(a1 + 40) = v9;
  *(_DWORD *)(a1 + 4) = v13;
  *(_DWORD *)(a1 + 8) = v14;
  return a1;
}
// 108ED4: using guessed type int dword_108ED4;
// 108ED8: using guessed type int dword_108ED8;

//----- (00043D30) --------------------------------------------------------
int sub_43D30()
{
  char *all_created_runtime; // r5
  int result; // r0
  int v2; // r3
  char *v3; // r3
  __int64 v4; // r6
  __int64 v5; // r4
  int v6; // r0
  int v7; // r0
  int v8; // r0
  int v9; // r0
  int v10; // r3
  int v11; // r6
  int v12; // r9
  int v13; // r5
  __int64 *v14; // r4
  __int64 *v15; // r5
  int v16; // r10
  __int64 v17; // t1
  int v19; // [sp+1Ch] [bp-A4h]
  char *v20; // [sp+20h] [bp-A0h]
  int v21; // [sp+24h] [bp-9Ch]
  int v22; // [sp+30h] [bp-90h]
  int v23; // [sp+34h] [bp-8Ch]
  int v24; // [sp+4Ch] [bp-74h] BYREF
  char v25[32]; // [sp+50h] [bp-70h] BYREF
  char v26[32]; // [sp+70h] [bp-50h] BYREF
  char v27[16]; // [sp+90h] [bp-30h] BYREF
  int v28; // [sp+B8h] [bp-8h]
  int v29; // [sp+BCh] [bp-4h]
  char v30[4096]; // [sp+C0h] [bp+0h] BYREF
  char v31[4100]; // [sp+10C0h] [bp+1000h] BYREF

  v24 = 0;
  v23 = frontend_runtime_instance();
  all_created_runtime = (char *)get_all_created_runtime(&v24);
  read_system_status_from_monitor((int)v27);
  format_hashrate_string(*(_DWORD *)(*(_DWORD *)(v23 + 68) + 12), v25);
  format_hashrate_string(*(_DWORD *)(*(_DWORD *)(v23 + 68) + 12), v26);
  V_LOCK();
  logfmt_raw(v31, 0x1000u, 0, "total avg hashrate %s 2min avg hashrate %s hw %llu", v25, v26, v28, v29);
  V_UNLOCK();
  result = zlog(
             g_hash_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer"
             "-origin_godminer-new/miner_util/miner_monitor/miner_monitor.c",
             168,
             "task_applog_printer",
             19,
             115,
             40,
             v31);
  if ( v24 > 0 )
  {
    v20 = all_created_runtime - 4;
    v22 = 0;
    do
    {
      v2 = *(_DWORD *)(*((_DWORD *)v20 + 1) + 196);
      v20 += 4;
      v3 = (char *)&unk_108E78 + 216 * v2;
      v4 = *((_QWORD *)v3 + 8);
      v5 = *((_QWORD *)v3 + 10);
      format_hashrate_string(*(_DWORD *)(*(_DWORD *)(v23 + 68) + 12), v25);
      v6 = format_hashrate_string(*(_DWORD *)(*(_DWORD *)(v23 + 68) + 12), v26);
      v7 = dev_ctrl(v6);
      v8 = (*(int (__fastcall **)(_DWORD))(v7 + 48))(*(_DWORD *)(*(_DWORD *)v20 + 196));
      LODWORD(v4) = snprintf(
                      v30,
                      0x1000u,
                      "chain %d device %d alive chip count %d avg hashrate %s 30min avg hashrate %s hw %llu\n",
                      v8,
                      *(_DWORD *)(*(_DWORD *)v20 + 196),
                      (_DWORD)v4,
                      v25,
                      v26,
                      v5);
      v9 = snprintf(
             &v30[v4],
             4096 - v4,
             "wc %llu nc %llu chip status str %s detail:\n",
             *(_DWORD *)v20 + 384,
             *(_DWORD *)(*(_DWORD *)v20 + 384),
             *(_DWORD *)(*(_DWORD *)v20 + 388),
             *(_DWORD *)(*(_DWORD *)v20 + 392),
             *(_DWORD *)(*(_DWORD *)v20 + 396),
             HIDWORD(v4));
      v10 = *(_DWORD *)v20;
      v11 = v4 + v9;
      v21 = *(_DWORD *)(*(_DWORD *)v20 + 280);
      if ( v21 > 0 )
      {
        v12 = 0;
        v19 = 0;
        while ( 1 )
        {
          v13 = *(_DWORD *)(v10 + 400);
          v14 = (__int64 *)(v13 + v12);
          v12 += 48;
          v15 = (__int64 *)(v13 + v12);
          ++v19;
          v16 = v11 + snprintf(&v30[v11], 4096 - v11, "%d:");
          do
          {
            v17 = *v14++;
            v16 += snprintf(&v30[v16], 4096 - v16, " %llu", v17);
          }
          while ( v15 != v14 );
          v11 = v16 + 2;
          snprintf(&v30[v16], 4096 - v16, " /");
          if ( v19 == v21 )
            break;
          v10 = *(_DWORD *)v20;
        }
      }
      V_LOCK();
      logfmt_raw(v31, 0x1000u, 0, "%s", v30);
      V_UNLOCK();
      result = zlog(
                 g_hash_zc,
                 "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godm"
                 "iner-origin_godminer-new/miner_util/miner_monitor/miner_monitor.c",
                 168,
                 "task_applog_printer",
                 19,
                 137,
                 40,
                 v31);
    }
    while ( v24 > ++v22 );
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4AB8C: using guessed type int __fastcall dev_ctrl(_DWORD);
// 11A7B8: using guessed type int g_hash_zc;

//----- (00044070) --------------------------------------------------------
char *__fastcall get_flag_from_monitor(int a1)
{
  return (char *)&unk_108978 + 80 * *(_DWORD *)(a1 + 196);
}

//----- (00044088) --------------------------------------------------------
int __fastcall chip_speed_test(_DWORD *a1, int a2)
{
  void (__fastcall *v3)(_DWORD *, float *); // r2
  int result; // r0
  int v6; // r12
  unsigned int *v7; // r2
  int v8; // r3
  float v9; // s14
  float v10; // [sp+14h] [bp-1008h] BYREF
  char v11[4100]; // [sp+18h] [bp-1004h] BYREF

  v3 = (void (__fastcall *)(_DWORD *, float *))a1[33];
  v10 = 0.0;
  v3(a1, &v10);
  v10 = v10 * 120.0;
  V_LOCK();
  logfmt_raw(v11, 0x1000u, 0, "qualify nonce count %f\n", v10);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/miner_util/miner_monitor/update_miner_status/update_chip_status.c",
    193,
    "chip_speed_test",
    15,
    31,
    20,
    v11);
  get_miner_working_status((int)v11);
  if ( (int)a1[70] <= 0 )
    return 0;
  v6 = (unsigned __int8)v11[6];
  result = 0;
  v7 = (unsigned int *)a1[106];
  v8 = 0;
  v9 = v10;
  do
  {
    if ( v6 )
    {
      *(_DWORD *)(a2 + 4 * v8) = 2;
      result = 12;
    }
    else if ( (float)*v7 < v9 )
    {
      result = 12;
      if ( *v7 )
        *(_DWORD *)(a2 + 4 * v8) = 3;
      else
        *(_DWORD *)(a2 + 4 * v8) = 2;
    }
    else
    {
      *(_DWORD *)(a2 + 4 * v8) = 0;
    }
    *v7++ = 0;
    ++v8;
  }
  while ( a1[70] > v8 );
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (000441C8) --------------------------------------------------------
int __fastcall update_str_and_flag(int result, int a2, _DWORD *a3)
{
  int v3; // r12
  int v4; // r3
  _BYTE *v5; // lr

  v3 = *(_DWORD *)(result + 280);
  v4 = 0;
  *(_DWORD *)(a2 + 64) = 0;
  v5 = *(_BYTE **)(a2 + 68);
  if ( v3 > 0 )
  {
    do
    {
      switch ( dword_109C20[256 * *(_DWORD *)(result + 196) + v4] )
      {
        case 0:
          ++*(_DWORD *)(a2 + 64);
          *v5 = 111;
          break;
        case 1:
          *v5 = 35;
          *a3 |= 1u;
          break;
        case 2:
          *v5 = 88;
          *a3 |= 2u;
          break;
        case 3:
          *v5 = 120;
          *a3 |= 4u;
          break;
        default:
          *v5 = 42;
          break;
      }
      if ( !v4 || (v4 & 7) != 0 )
      {
        ++v5;
      }
      else
      {
        v5[1] = 32;
        v5 += 2;
      }
      ++v4;
    }
    while ( *(_DWORD *)(result + 280) > v4 );
  }
  *v5 = 0;
  return result;
}
// 4421C: control flows out of bounds to 44220
// 109C20: using guessed type _DWORD dword_109C20[852];

//----- (000442BC) --------------------------------------------------------
_DWORD *__fastcall update_chip_status(int a1, int a2, int a3)
{
  int v3; // r12
  int v6; // r1
  _DWORD *v7; // r7
  int v8; // r12
  _DWORD *v9; // r3
  int v10; // r1

  v3 = *(_DWORD *)(a1 + 196);
  v6 = byte_109C10[v3];
  v7 = (_DWORD *)(a3 + 48);
  if ( !byte_109C10[v3] )
  {
    v8 = v3 << 10;
    v9 = (_DWORD *)((char *)&dword_109C20[-1] + v8);
    do
    {
      v9[1] = v6;
      ++v9;
    }
    while ( v9 != (_DWORD *)((char *)&dword_109C20[255] + v8) );
    *(_DWORD *)(a2 + 72) = *(_DWORD *)(a1 + 408);
    update_str_and_flag(a1, a2, v7);
    v10 = *(_DWORD *)(a1 + 368);
    byte_109C10[*(_DWORD *)(a1 + 196)] = 1;
    *(_DWORD *)(a2 + 64) = v10;
    return v7;
  }
  if ( !*(_BYTE *)(a1 + 206) )
    return v7;
  *(_DWORD *)(a2 + 72) = *(_DWORD *)(a1 + 408);
  chip_speed_test((_DWORD *)a1, (int)&dword_109C20[256 * v3]);
  if ( (*(int (__fastcall **)(int, _DWORD *))(a1 + 116))(a1, &dword_109C20[256 * *(_DWORD *)(a1 + 196)]) )
    *(_DWORD *)(a3 + 48) |= 8u;
  update_str_and_flag(a1, a2, v7);
  return v7;
}
// 109C10: using guessed type unsigned __int8 byte_109C10[16];
// 109C20: using guessed type _DWORD dword_109C20[852];

//----- (000443B8) --------------------------------------------------------
int __fastcall update_fanspeed(int a1, _DWORD *a2, int a3)
{
  int v3; // r5
  __int64 v5; // kr00_8
  int realtime_speed; // r5
  char *v7; // r11
  int v8; // r1
  int v9; // r2
  int v10; // r3
  char *v11; // r9
  int v12; // r1
  int v13; // r2
  int v14; // r3
  int v15; // r1
  int v16; // r2
  int v17; // r3
  _DWORD *v18; // r11
  int v19; // r1
  int v20; // r2
  int v21; // r3
  int v22; // r0
  int v23; // r3
  int v24; // r2
  int v25; // r2
  int v26; // r5
  bool v27; // cc
  int v28; // r3
  int v29; // r7
  int v30; // r9
  int fan_max_speed; // r6
  int v32; // r3
  bool v33; // nf
  int result; // r0
  char v35; // [sp+20h] [bp-10ECh] BYREF
  char *v36; // [sp+40h] [bp-10CCh]
  const char *v37; // [sp+44h] [bp-10C8h]
  const char *v38; // [sp+48h] [bp-10C4h]
  char *v39; // [sp+4Ch] [bp-10C0h]
  char *s; // [sp+50h] [bp-10BCh]
  char *v41; // [sp+54h] [bp-10B8h]
  int fan_num; // [sp+58h] [bp-10B4h]
  int v43; // [sp+5Ch] [bp-10B0h]
  char *v44; // [sp+60h] [bp-10ACh]
  int *v45; // [sp+64h] [bp-10A8h]
  int v46; // [sp+68h] [bp-10A4h]
  int v47; // [sp+6Ch] [bp-10A0h]
  _DWORD *v48; // [sp+70h] [bp-109Ch]
  int v49; // [sp+74h] [bp-1098h]
  int v50; // [sp+78h] [bp-1094h]
  char *v51; // [sp+7Ch] [bp-1090h]
  int v52; // [sp+80h] [bp-108Ch]
  int v53; // [sp+84h] [bp-1088h]
  _DWORD v54[7]; // [sp+88h] [bp-1084h] BYREF
  int v55; // [sp+A4h] [bp-1068h]
  _DWORD v56[8]; // [sp+A8h] [bp-1064h] BYREF
  _DWORD v57[7]; // [sp+C8h] [bp-1044h] BYREF
  int v58; // [sp+E4h] [bp-1028h]
  _DWORD v59[8]; // [sp+E8h] [bp-1024h] BYREF
  char v60[4100]; // [sp+108h] [bp-1004h] BYREF

  v3 = *(_DWORD *)(a1 + 196);
  v49 = a3 + 32;
  if ( v3 )
    return v49;
  v50 = a3;
  v51 = &fan_inited;
  v53 = a1;
  if ( !fan_inited )
  {
    fan_init();
    *v51 = 1;
    fan_num = platform_get_fan_num();
    if ( fan_num > 0 )
      goto LABEL_4;
LABEL_26:
    v28 = *(_DWORD *)(v50 + 32);
    a2[23] = 0;
    goto LABEL_17;
  }
  fan_num = platform_get_fan_num();
  if ( fan_num <= 0 )
    goto LABEL_26;
LABEL_4:
  v38 = "update_fanspeed";
  v39 = "%s";
  v43 = 0;
  s = "fanid";
  v41 = "fanspeed";
  v44 = &v35;
  v52 = 0;
  v48 = a2;
  v45 = &g_fan_zc;
  v5 = 0;
  do
  {
    realtime_speed = fan_get_realtime_speed(v5);
    v46 = realtime_speed;
    v47 = realtime_speed >> 31;
    V_LOCK();
    V_INT((int)v54, s, v5);
    V_INT((int)v56, v41, realtime_speed);
    v7 = v44;
    v8 = v56[1];
    v9 = v56[2];
    v10 = v56[3];
    v11 = v44;
    v37 = v38;
    v36 = v39;
    *(_DWORD *)v44 = v56[0];
    *((_DWORD *)v11 + 1) = v8;
    *((_DWORD *)v11 + 2) = v9;
    *((_DWORD *)v11 + 3) = v10;
    v11 += 16;
    v12 = v56[5];
    v13 = v56[6];
    v14 = v56[7];
    *(_DWORD *)v11 = v56[4];
    *((_DWORD *)v11 + 1) = v12;
    *((_DWORD *)v11 + 2) = v13;
    *((_DWORD *)v11 + 3) = v14;
    logfmt_raw(v60, 0x1000u, 0, v55, v54[0], v54[1], v54[2], v54[3], v54[4], v54[5], v54[6], v55);
    V_UNLOCK();
    zlog(
      *v45,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/miner_util/miner_monitor/update_miner_status/update_fanspeed.c",
      190,
      "update_fanspeed",
      15,
      35,
      40,
      v60);
    if ( realtime_speed != -1 )
    {
      V_LOCK();
      V_INT((int)v57, s, v5);
      V_INT((int)v59, v41, realtime_speed);
      v15 = v59[1];
      v16 = v59[2];
      v17 = v59[3];
      v37 = v38;
      v36 = v39;
      *(_DWORD *)v7 = v59[0];
      *((_DWORD *)v7 + 1) = v15;
      *((_DWORD *)v7 + 2) = v16;
      *((_DWORD *)v7 + 3) = v17;
      v18 = v7 + 16;
      v19 = v59[5];
      v20 = v59[6];
      v21 = v59[7];
      *v18 = v59[4];
      v18[1] = v19;
      v18[2] = v20;
      v18[3] = v21;
      logfmt_raw(v60, 0x1000u, 0, v58, v57[0], v57[1], v57[2], v57[3], v57[4], v57[5], v57[6], v58);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/miner_util/miner_monitor/update_miner_status/update_fanspeed.c",
        190,
        "update_fanspeed",
        15,
        37,
        20,
        v60);
      v22 = v43;
      v23 = 4 * v43;
      v24 = v48[24];
      *(_DWORD *)(v48[25] + 4 * v43) = v5;
      *(_DWORD *)(v24 + v23) = realtime_speed;
      v43 = v22 + 1;
    }
    ++v5;
  }
  while ( fan_num > (int)v5 );
  v25 = v43;
  a2 = v48;
  v26 = v52;
  v27 = v43 < fan_num;
  v48[23] = v43;
  if ( !v27 || (v28 = *(_DWORD *)(v50 + 32) | 2, *(_DWORD *)(v50 + 32) = v28, v25) )
  {
    v29 = v50;
    do
    {
      while ( 1 )
      {
        v30 = *(_DWORD *)(a2[24] + 4 * v26);
        if ( v30 )
        {
          fan_max_speed = platform_get_fan_max_speed(v26);
          if ( v30 >= fan_pwm_get() * fan_max_speed / 150 )
            break;
        }
        ++v26;
        *(_DWORD *)(v29 + 32) |= 1u;
        if ( a2[23] <= v26 )
          goto LABEL_16;
      }
      ++v26;
    }
    while ( a2[23] > v26 );
LABEL_16:
    v28 = *(_DWORD *)(v50 + 32);
  }
LABEL_17:
  if ( (v28 & 3) == 0 )
  {
    result = v49;
    *((_DWORD *)v51 + 1) = 0;
    return result;
  }
  v32 = *((_DWORD *)v51 + 1) + 1;
  v33 = *((_DWORD *)v51 + 1) - 14 < 0;
  *((_DWORD *)v51 + 1) = v32;
  if ( v33 ^ __OFSUB__(v32, 15) | (v32 == 15) )
    return v49;
  V_LOCK();
  logfmt_raw(v60, 0x1000u, 0, "fan_error_num: %d fan_num %d", *((_DWORD *)v51 + 1), a2[23]);
  V_UNLOCK();
  if ( !*(_BYTE *)(v53 + 206) )
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/miner_util/miner_monitor/update_miner_status/update_fanspeed.c",
      190,
      "update_fanspeed",
      15,
      56,
      20,
      v60);
  result = v49;
  *(_DWORD *)(v50 + 32) |= 4u;
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10DC20: using guessed type char fan_inited;
// 11A7AC: using guessed type int g_zc;
// 11A7B4: using guessed type int g_fan_zc;

//----- (00044828) --------------------------------------------------------
_DWORD *__fastcall update_hashrate(int a1, int a2, _DWORD *a3)
{
  int v5; // r9
  __int64 v6; // r2
  double v7; // d6
  float v8; // s16
  int v9; // r4
  bool v10; // cc
  int v11; // r2
  int v12; // r7
  float v13; // s14
  int v14; // r3
  float v15; // s15
  int v16; // r2
  float v17; // s15
  int v18; // r1
  int v19; // r6
  int v20; // lr
  int v21; // r6
  __int64 v22; // kr00_8
  __int64 *v23; // r0
  __int64 v24; // t1
  float v25; // s13
  int v26; // r5
  float v27; // s15
  int i; // r2
  float v29; // s16
  int v30; // r4
  int v31; // r3
  int v32; // r2
  double v33; // d6
  unsigned int v35; // r6
  __int64 v36; // kr08_8
  int v37; // r0
  char v38; // r1
  int v39; // r3
  __int64 v40; // r0
  float v41; // s17
  float v42; // s17
  _DWORD *v43; // r4
  unsigned int v44; // r12
  int v45; // lr
  int v46; // r8
  __int64 v47; // r0
  float v48; // s17
  float v49; // r0
  unsigned int v50; // [sp+20h] [bp-1054h]
  unsigned __int64 v52; // [sp+30h] [bp-1044h]
  int v53; // [sp+3Ch] [bp-1038h]
  __int64 v54; // [sp+48h] [bp-102Ch] BYREF
  __int64 v55; // [sp+50h] [bp-1024h] BYREF
  double v56; // [sp+58h] [bp-101Ch] BYREF
  _BYTE v57[12]; // [sp+64h] [bp-1010h] BYREF
  char v58[4100]; // [sp+70h] [bp-1004h] BYREF

  (*(void (__fastcall **)(int, __int64 *))(a1 + 120))(a1, &v54);
  (*(void (__fastcall **)(int, __int64 *))(a1 + 128))(a1, &v55);
  (*(void (__fastcall **)(int, double *))(a1 + 128))(a1, &v56);
  v5 = *(_DWORD *)(a1 + 196);
  v6 = v55;
  *(_QWORD *)(a2 + 48) = v54;
  *(_QWORD *)(a2 + 56) = v6;
  if ( v5 <= 16 )
  {
    v53 = 16 * v5;
    if ( !*((_BYTE *)&unk_10DC28 + v5) )
    {
      clock_gettime(1, (struct timespec *)&unk_10DC38 + 2 * v5);
      clock_gettime(1, (struct timespec *)&unk_10DD38 + 2 * v5);
      clock_gettime(1, (struct timespec *)&unk_10DE38 + 2 * v5);
      *((_QWORD *)&unk_10DF38 + v5) = 0;
      *((_BYTE *)&unk_10DC28 + v5) = 1;
    }
    clock_gettime(1, (struct timespec *)&unk_10DC38 + 2 * v5 + 1);
    *((float *)&v7 + 1) = (float)(1000LL
                                * (*((_DWORD *)&unk_10DC28 + 4 * v5 + 6) - *((_DWORD *)&unk_10DC28 + 4 * v5 + 4))
                                + (*((_DWORD *)&unk_10DC28 + 4 * v5 + 7) - *((_DWORD *)&unk_10DC28 + 4 * v5 + 5))
                                / 1000000);
    v8 = *((float *)&v7 + 1) / 1000.0;
    if ( (float)(*((float *)&v7 + 1) / 1000.0) >= 5.0 )
    {
      v35 = *(_DWORD *)(a1 + 392);
      v50 = *(_DWORD *)(a1 + 396);
      v36 = __PAIR64__(v50, v35) - *((_QWORD *)&unk_10DF38 + v5);
      get_miner_working_status((int)v57);
      if ( v57[6] )
      {
        v42 = 0.0;
      }
      else
      {
        v37 = *(_DWORD *)(a1 + 376);
        v38 = 32 - v37;
        v39 = 1 << (v37 - 32);
        LODWORD(v40) = 1 << v37;
        HIDWORD(v40) = v39 | (1u >> v38);
        v41 = COERCE_FLOAT(sub_DD668(v40));
        v42 = v41 * (float)(COERCE_FLOAT(sub_DD668(v36)) / v8);
      }
      V_LOCK();
      v7 = v42;
      logfmt_raw(
        v58,
        0x1000u,
        0,
        "[HashRate] time_passed_sec: %.2f, nc %llu, new %llu, %.2f H/s",
        v8,
        v35,
        v50,
        v36,
        v42);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/miner_util/miner_monitor/update_miner_status/update_hashrate.c",
        190,
        "update_hashrate",
        15,
        107,
        20,
        v58);
      clock_gettime(1, (struct timespec *)&unk_10DC38 + 2 * v5);
      v43 = (_DWORD *)((char *)&unk_10DFB8 + 2896 * v5);
      *((_DWORD *)&unk_10DF38 + 2 * v5) = v35;
      v44 = v43[723];
      v45 = v43[720] + 1;
      v46 = v43[720];
      *((_DWORD *)&unk_10DF38 + 2 * v5 + 1) = v50;
      LODWORD(v47) = v43[722];
      HIDWORD(v47) = v44;
      v52 = __PAIR64__(v44, v47) + 1;
      *((float *)&unk_10DFB8 + 724 * v5 + v46) = v42;
      v43[720] = v45 % 720;
      v48 = v42 + (float)(COERCE_FLOAT(sub_DD668(v47)) * *(float *)(a2 + 40));
      v49 = COERCE_FLOAT(sub_DD668(v52));
      *((_QWORD *)v43 + 361) = v52;
      *(float *)(a2 + 40) = v48 / v49;
    }
    else
    {
      v52 = *((_QWORD *)&unk_10DFB8 + 362 * v5 + 361);
    }
    v9 = *((_DWORD *)&unk_10DFB8 + 724 * v5 + 720);
    if ( v52 )
    {
      v10 = HIDWORD(v52) != 0;
      v11 = 359;
      if ( !HIDWORD(v52) )
        v10 = (unsigned int)v52 > 0x167;
      if ( v10 )
      {
        HIDWORD(v7) = 1135869952;
        v12 = 360;
      }
      else
      {
        v11 = v52;
        v12 = v52;
      }
      v13 = *((float *)&unk_10DFB8 + 724 * v5 + (v9 + 719) % 720);
      v14 = v9 + 719;
      v15 = v13 + 0.0;
      *(float *)(a2 + 32) = v13 + 0.0;
      if ( !v10 )
        v15 = *(float *)&v11;
      v16 = 0;
      if ( !v10 )
        *((float *)&v7 + 1) = (float)SLODWORD(v15);
      v17 = 0.0;
      while ( 1 )
      {
        ++v16;
        v17 = v17 + v13;
        v18 = v14 % 720;
        if ( v16 >= v12 )
          break;
        v14 = v18 + 719;
        v13 = *((float *)&unk_10DFB8 + 724 * v5 + (v18 + 719) % 0x2D0u);
      }
    }
    else
    {
      HIDWORD(v7) = 0;
      v17 = 0.0;
      *(float *)(a2 + 32) = 0.0 / 0.0;
    }
    v19 = *(_DWORD *)(a1 + 280);
    *(float *)(a2 + 36) = v17 / *((float *)&v7 + 1);
    if ( v19 <= 0 )
    {
      v22 = 0;
    }
    else
    {
      v20 = *(_DWORD *)(a1 + 400) + 16;
      v21 = v20 + 48 * v19;
      v22 = 0;
      do
      {
        v23 = (__int64 *)v20;
        do
        {
          v24 = *v23++;
          v22 += v24;
        }
        while ( (__int64 *)(v20 + 32) != v23 );
        v20 += 48;
      }
      while ( v21 != v20 );
    }
    *(_QWORD *)(a2 + 80) = v22;
    clock_gettime(1, (struct timespec *)&unk_10DD38 + 2 * v5 + 1);
    if ( (float)((float)(1000LL
                       * (*(_DWORD *)((char *)&unk_10DC28 + v53 + 280) - *(_DWORD *)((char *)&unk_10DC28 + v53 + 272))
                       + (*(_DWORD *)((char *)&unk_10DC28 + v53 + 284) - *(_DWORD *)((char *)&unk_10DC28 + v53 + 276))
                       / 1000000)
               / 1000.0) >= 900.0 )
    {
      if ( v52 <= 0xB3 )
      {
        v26 = v52;
        v25 = (float)(int)v52;
        if ( !(_DWORD)v52 )
        {
          v27 = 0.0;
          goto LABEL_29;
        }
      }
      else
      {
        v25 = 180.0;
        v26 = 180;
      }
      v27 = 0.0;
      for ( i = 0; i < v26; ++i )
      {
        v9 = (v9 + 719) % 720;
        v27 = v27 + *((float *)&unk_10DFB8 + 724 * v5 + v9);
      }
LABEL_29:
      v29 = v27 / v25;
      v30 = *(_DWORD *)(a2 + 200);
      if ( v30 > 23 )
      {
        memcpy((void *)(a2 + 104), (const void *)(a2 + 108), 0x5Cu);
        *(float *)(a2 + 196) = v29;
      }
      else
      {
        *(float *)(a2 + 4 * v30 + 104) = v29;
      }
      v31 = *(_DWORD *)(a2 + 208);
      v32 = *(_DWORD *)(a2 + 212);
      v33 = v56 * 0.97;
      *(_DWORD *)(a2 + 200) = v30 + 1;
      *(_DWORD *)(a2 + 208) = v31 + 1;
      *(_DWORD *)(a2 + 212) = __CFADD__(v31, 1) + v32;
      if ( v29 <= v33 )
        *a3 |= 1u;
      clock_gettime(1, (struct timespec *)((char *)&unk_10DD38 + v53));
    }
  }
  return a3;
}
// 44828: too many cbuild loops
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00044EBC) --------------------------------------------------------
void *__fastcall init_temp_senor_info(int a1)
{
  void *result; // r0
  int v3; // r2
  int v4; // r1
  int v5; // r3
  int v6; // r1
  int v7; // r2
  int v8; // [sp+4h] [bp-4h] BYREF

  result = get_all_created_runtime(&v8);
  v3 = v8;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  if ( v3 > 0 )
  {
    v4 = *(_DWORD *)(*(_DWORD *)result + 340);
    v5 = *(_DWORD *)(*(_DWORD *)result + 332);
    if ( v4 > 0 )
    {
      v6 = v5 + 24 * v4;
      do
      {
        while ( 1 )
        {
          v7 = *(_DWORD *)(v5 + 12);
          if ( v7 )
            break;
          v5 += 24;
          ++*(_DWORD *)(a1 + 24);
          if ( v5 == v6 )
            return result;
        }
        v5 += 24;
        if ( v7 == 1 )
          ++*(_DWORD *)(a1 + 28);
      }
      while ( v5 != v6 );
    }
  }
  return result;
}

//----- (00044F50) --------------------------------------------------------
int __fastcall update_temperature(int a1, _DWORD *a2, int a3)
{
  int v3; // r3
  signed int v4; // r5
  int v6; // r4
  void *v7; // r0
  void (__fastcall *v8)(int, void *); // r3
  int *v9; // r6
  int v10; // r10
  int v11; // r1
  int v12; // r2
  int v13; // r3
  char *v14; // lr
  char *v15; // r11
  int v16; // r1
  int v17; // r2
  int v18; // r3
  int *v19; // r5
  int v20; // r1
  int v21; // r2
  int v22; // r3
  int v23; // r1
  int v24; // r2
  int v25; // r3
  int v26; // r1
  int v27; // r2
  int v28; // r3
  int v29; // r1
  int v30; // r2
  int v31; // r3
  int v32; // r1
  int v33; // r2
  int v34; // r3
  char *v35; // lr
  char *v36; // r9
  int v37; // r1
  int v38; // r2
  int v39; // r3
  int *v40; // r5
  int v41; // r1
  int v42; // r2
  int v43; // r3
  int v44; // r1
  int v45; // r2
  int v46; // r3
  int v47; // r1
  int v48; // r2
  int v49; // r3
  int v50; // r1
  int v51; // r2
  int v52; // r3
  int v53; // r3
  int v54; // r2
  int v55; // r8
  int v56; // r2
  int v57; // r2
  int v58; // r2
  int v59; // r2
  int v60; // r3
  int v61; // r12
  _DWORD *v62; // r12
  int v63; // lr
  int v64; // r1
  bool v65; // nf
  char *v66; // r3
  int v67; // r2
  int result; // r0
  char *v69; // r0
  int v70; // r1
  int v71; // r2
  int v72; // r2
  int v73; // r1
  int v74; // [sp+20h] [bp-1334h] BYREF
  char v75; // [sp+40h] [bp-1314h] BYREF
  char v76; // [sp+60h] [bp-12F4h] BYREF
  char *v77; // [sp+80h] [bp-12D4h]
  const char *v78; // [sp+84h] [bp-12D0h]
  int v79; // [sp+88h] [bp-12CCh]
  char *s; // [sp+8Ch] [bp-12C8h]
  const char *v81; // [sp+90h] [bp-12C4h]
  int *v82; // [sp+94h] [bp-12C0h]
  const char *v83; // [sp+98h] [bp-12BCh]
  char *v84; // [sp+9Ch] [bp-12B8h]
  int *v85; // [sp+A0h] [bp-12B4h]
  char *v86; // [sp+A4h] [bp-12B0h]
  char *v87; // [sp+A8h] [bp-12ACh]
  char *v88; // [sp+ACh] [bp-12A8h]
  _DWORD *v89; // [sp+B0h] [bp-12A4h]
  int v90; // [sp+B4h] [bp-12A0h]
  int v91; // [sp+B8h] [bp-129Ch]
  unsigned int v92; // [sp+BCh] [bp-1298h]
  int v93; // [sp+C0h] [bp-1294h]
  int v94; // [sp+C4h] [bp-1290h]
  int v95; // [sp+C8h] [bp-128Ch]
  int v96; // [sp+CCh] [bp-1288h]
  int *v97; // [sp+D0h] [bp-1284h]
  const char *v98; // [sp+D4h] [bp-1280h]
  int *v99; // [sp+D8h] [bp-127Ch]
  int v100; // [sp+DCh] [bp-1278h]
  signed int v101; // [sp+E0h] [bp-1274h]
  void *ptr; // [sp+E4h] [bp-1270h]
  int v103; // [sp+E8h] [bp-126Ch]
  int v104; // [sp+ECh] [bp-1268h]
  _DWORD v105[7]; // [sp+F0h] [bp-1264h] BYREF
  int v106; // [sp+10Ch] [bp-1248h]
  _DWORD v107[7]; // [sp+110h] [bp-1244h] BYREF
  int v108; // [sp+12Ch] [bp-1228h]
  _DWORD v109[7]; // [sp+130h] [bp-1224h] BYREF
  int v110; // [sp+14Ch] [bp-1208h]
  _DWORD v111[7]; // [sp+150h] [bp-1204h] BYREF
  int v112; // [sp+16Ch] [bp-11E8h]
  _DWORD v113[7]; // [sp+170h] [bp-11E4h] BYREF
  int v114; // [sp+18Ch] [bp-11C8h]
  _DWORD v115[7]; // [sp+190h] [bp-11C4h] BYREF
  int v116; // [sp+1ACh] [bp-11A8h]
  _DWORD v117[8]; // [sp+1B0h] [bp-11A4h] BYREF
  _DWORD v118[8]; // [sp+1D0h] [bp-1184h] BYREF
  _DWORD v119[8]; // [sp+1F0h] [bp-1164h] BYREF
  _DWORD v120[8]; // [sp+210h] [bp-1144h] BYREF
  int v121; // [sp+230h] [bp-1124h] BYREF
  int v122; // [sp+234h] [bp-1120h]
  int v123; // [sp+238h] [bp-111Ch]
  int v124; // [sp+23Ch] [bp-1118h]
  int v125; // [sp+240h] [bp-1114h]
  int v126; // [sp+244h] [bp-1110h]
  int v127; // [sp+248h] [bp-110Ch]
  int v128; // [sp+24Ch] [bp-1108h]
  int v129; // [sp+250h] [bp-1104h] BYREF
  int v130; // [sp+254h] [bp-1100h]
  int v131; // [sp+258h] [bp-10FCh]
  int v132; // [sp+25Ch] [bp-10F8h]
  int v133; // [sp+260h] [bp-10F4h]
  int v134; // [sp+264h] [bp-10F0h]
  int v135; // [sp+268h] [bp-10ECh]
  int v136; // [sp+26Ch] [bp-10E8h]
  _DWORD v137[8]; // [sp+270h] [bp-10E4h] BYREF
  _DWORD v138[7]; // [sp+290h] [bp-10C4h] BYREF
  int v139; // [sp+2ACh] [bp-10A8h]
  int v140; // [sp+2B0h] [bp-10A4h] BYREF
  int v141; // [sp+2B4h] [bp-10A0h]
  int v142; // [sp+2B8h] [bp-109Ch]
  int v143; // [sp+2BCh] [bp-1098h]
  int v144; // [sp+2C0h] [bp-1094h]
  int v145; // [sp+2C4h] [bp-1090h]
  int v146; // [sp+2C8h] [bp-108Ch]
  int v147; // [sp+2CCh] [bp-1088h]
  int v148; // [sp+2D0h] [bp-1084h] BYREF
  int v149; // [sp+2D4h] [bp-1080h]
  int v150; // [sp+2D8h] [bp-107Ch]
  int v151; // [sp+2DCh] [bp-1078h]
  int v152; // [sp+2E0h] [bp-1074h]
  int v153; // [sp+2E4h] [bp-1070h]
  int v154; // [sp+2E8h] [bp-106Ch]
  int v155; // [sp+2ECh] [bp-1068h]
  _DWORD v156[8]; // [sp+2F0h] [bp-1064h] BYREF
  _DWORD v157[7]; // [sp+310h] [bp-1044h] BYREF
  int v158; // [sp+32Ch] [bp-1028h]
  _DWORD v159[7]; // [sp+330h] [bp-1024h] BYREF
  int v160; // [sp+34Ch] [bp-1008h]
  char v161[4100]; // [sp+350h] [bp-1004h] BYREF

  v3 = *(unsigned __int8 *)(a1 + 206);
  v100 = a3 + 16;
  if ( !v3 )
    return v100;
  v4 = *(_DWORD *)(a1 + 340);
  v89 = a2;
  v6 = *(_DWORD *)(a1 + 332);
  v104 = a3;
  v101 = v4;
  v7 = calloc(v4, 8u);
  v8 = *(void (__fastcall **)(int, void *))(a1 + 184);
  ptr = v7;
  v8(a1, v7);
  if ( v4 <= 0 )
  {
    free(ptr);
    if ( !v101 )
    {
      v59 = *(_DWORD *)(a1 + 196);
      v92 = 0;
      v90 = 0;
      v93 = -150;
      goto LABEL_59;
    }
    v91 = 0;
    v90 = 0;
    v92 = 0;
    v93 = -150;
    v95 = -150;
    v82 = &g_zc;
    v94 = 150;
LABEL_68:
    V_LOCK();
    V_INT((int)v105, "chain", *(int *)(a1 + 200));
    logfmt_raw(
      v161,
      0x1000u,
      0,
      v106,
      v105[0],
      v105[1],
      v105[2],
      v105[3],
      v105[4],
      v105[5],
      v105[6],
      v106,
      "read temp error! pcb temp count %d chip temp count %d uneffective value count %d",
      v91,
      v90,
      v92);
    V_UNLOCK();
    zlog(
      *v82,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/miner_util/miner_monitor/update_miner_status/update_temperature.c",
      193,
      "update_temperature",
      18,
      266,
      120,
      v161);
    *(_DWORD *)(v104 + 16) |= 1u;
    goto LABEL_33;
  }
  v9 = (int *)ptr;
  v83 = "check_temperature";
  v92 = 0;
  v90 = 0;
  v91 = 0;
  v103 = 0;
  v95 = -150;
  v96 = 0;
  v94 = 150;
  v87 = &v76;
  v86 = &v75;
  v97 = (int *)((char *)ptr + 8 * v101);
  v10 = v6;
  v93 = -150;
  v98 = "check_temperature, local:%d, remote:%d";
  v82 = &g_zc;
  v84 = "%s";
  v99 = &g_temp_zc;
  s = "chain";
  v81 = "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/miner_util/miner_monitor/update_miner_status/update_temperature.c";
  v88 = "sensor";
  v85 = &v74;
  do
  {
    V_LOCK();
    V_INT((int)v159, s, *(int *)(a1 + 200));
    logfmt_raw(
      v161,
      0x1000u,
      0,
      v160,
      v159[0],
      v159[1],
      v159[2],
      v159[3],
      v159[4],
      v159[5],
      v159[6],
      v160,
      v98,
      *v9,
      v9[1]);
    V_UNLOCK();
    zlog(*v82, v81, 193, "check_temperature", 17, 34, 20, v161);
    v53 = *v9;
    if ( *v9 == -64 )
    {
      v55 = 0;
      ++v92;
    }
    else
    {
      v54 = v95;
      v55 = 1;
      if ( v95 < v53 )
        v54 = *v9;
      v95 = v54;
      v56 = v94;
      ++v91;
      if ( v94 >= v53 )
        v56 = v53;
      v94 = v56;
    }
    v57 = v9[1];
    if ( v57 == -64 )
    {
      ++v92;
      v79 = 0;
    }
    else
    {
      if ( v93 >= v57 )
        v57 = v93;
      v93 = v57;
      ++v90;
      v79 = 1;
    }
    if ( v89 )
    {
      v58 = *(_DWORD *)(v10 + 12);
      if ( v58 )
      {
        if ( v58 == 1 )
        {
          if ( v55 )
            *(_DWORD *)(v89[2] + 4 * v103) = v53;
          if ( v79 )
            *(_DWORD *)(v89[3] + 4 * v103) = v9[1];
          ++v103;
        }
      }
      else
      {
        if ( v55 )
          *(_DWORD *)(*v89 + 4 * v96) = v53;
        if ( v79 )
          *(_DWORD *)(v89[1] + 4 * v96) = v9[1];
        ++v96;
      }
    }
    V_LOCK();
    V_INT((int)v157, s, *(int *)(a1 + 200));
    V_INT((int)v156, v88, *(int *)(v10 + 20));
    if ( v55 )
    {
      V_INT((int)&v148, "pcbtemp", *v9);
      if ( v79 )
        goto LABEL_5;
    }
    else
    {
      V_INT((int)v120, "pcbtemp", -256);
      v148 = v120[0];
      v149 = v120[1];
      v150 = v120[2];
      v151 = v120[3];
      v152 = v120[4];
      v153 = v120[5];
      v154 = v120[6];
      v155 = v120[7];
      if ( v79 )
      {
LABEL_5:
        V_INT((int)&v140, "chiptemp", v9[1]);
        goto LABEL_6;
      }
    }
    V_INT((int)v119, "chiptemp", -256);
    v140 = v119[0];
    v141 = v119[1];
    v142 = v119[2];
    v143 = v119[3];
    v144 = v119[4];
    v145 = v119[5];
    v146 = v119[6];
    v147 = v119[7];
LABEL_6:
    v11 = v141;
    v12 = v142;
    v13 = v143;
    v78 = v83;
    v14 = v87;
    v77 = v84;
    *(_DWORD *)v87 = v140;
    *((_DWORD *)v14 + 1) = v11;
    *((_DWORD *)v14 + 2) = v12;
    *((_DWORD *)v14 + 3) = v13;
    v14 += 16;
    v15 = v86;
    v16 = v145;
    v17 = v146;
    v18 = v147;
    v19 = v85;
    *(_DWORD *)v14 = v144;
    *((_DWORD *)v14 + 1) = v16;
    *((_DWORD *)v14 + 2) = v17;
    *((_DWORD *)v14 + 3) = v18;
    v20 = v149;
    v21 = v150;
    v22 = v151;
    *(_DWORD *)v15 = v148;
    *((_DWORD *)v15 + 1) = v20;
    *((_DWORD *)v15 + 2) = v21;
    *((_DWORD *)v15 + 3) = v22;
    v15 += 16;
    v23 = v153;
    v24 = v154;
    v25 = v155;
    *(_DWORD *)v15 = v152;
    *((_DWORD *)v15 + 1) = v23;
    *((_DWORD *)v15 + 2) = v24;
    *((_DWORD *)v15 + 3) = v25;
    v26 = v156[1];
    v27 = v156[2];
    v28 = v156[3];
    *v19 = v156[0];
    v19[1] = v26;
    v19[2] = v27;
    v19[3] = v28;
    v19 += 4;
    v29 = v156[5];
    v30 = v156[6];
    v31 = v156[7];
    *v19 = v156[4];
    v19[1] = v29;
    v19[2] = v30;
    v19[3] = v31;
    logfmt_raw(v161, 0x1000u, 0, v158, v157[0], v157[1], v157[2], v157[3], v157[4], v157[5], v157[6], v158);
    V_UNLOCK();
    zlog(*v82, v81, 193, "check_temperature", 17, 76, 20, v161);
    V_LOCK();
    V_INT((int)v138, s, *(int *)(a1 + 200));
    V_INT((int)v137, v88, *(int *)(v10 + 20));
    if ( v55 )
    {
      V_INT((int)&v129, "pcbtemp", *v9);
    }
    else
    {
      V_INT((int)v118, "pcbtemp", -256);
      v129 = v118[0];
      v130 = v118[1];
      v131 = v118[2];
      v132 = v118[3];
      v133 = v118[4];
      v134 = v118[5];
      v135 = v118[6];
      v136 = v118[7];
    }
    if ( v79 )
    {
      V_INT((int)&v121, "chiptemp", v9[1]);
    }
    else
    {
      V_INT((int)v117, "chiptemp", -256);
      v121 = v117[0];
      v122 = v117[1];
      v123 = v117[2];
      v124 = v117[3];
      v125 = v117[4];
      v126 = v117[5];
      v127 = v117[6];
      v128 = v117[7];
    }
    v32 = v122;
    v33 = v123;
    v34 = v124;
    v9 += 2;
    v10 += 24;
    v78 = v83;
    v35 = v87;
    v77 = v84;
    *(_DWORD *)v87 = v121;
    *((_DWORD *)v35 + 1) = v32;
    *((_DWORD *)v35 + 2) = v33;
    *((_DWORD *)v35 + 3) = v34;
    v35 += 16;
    v36 = v86;
    v37 = v126;
    v38 = v127;
    v39 = v128;
    v40 = v85;
    *(_DWORD *)v35 = v125;
    *((_DWORD *)v35 + 1) = v37;
    *((_DWORD *)v35 + 2) = v38;
    *((_DWORD *)v35 + 3) = v39;
    v41 = v130;
    v42 = v131;
    v43 = v132;
    *(_DWORD *)v36 = v129;
    *((_DWORD *)v36 + 1) = v41;
    *((_DWORD *)v36 + 2) = v42;
    *((_DWORD *)v36 + 3) = v43;
    v36 += 16;
    v44 = v134;
    v45 = v135;
    v46 = v136;
    *(_DWORD *)v36 = v133;
    *((_DWORD *)v36 + 1) = v44;
    *((_DWORD *)v36 + 2) = v45;
    *((_DWORD *)v36 + 3) = v46;
    v47 = v137[1];
    v48 = v137[2];
    v49 = v137[3];
    *v40 = v137[0];
    v40[1] = v47;
    v40[2] = v48;
    v40[3] = v49;
    v40 += 4;
    v50 = v137[5];
    v51 = v137[6];
    v52 = v137[7];
    *v40 = v137[4];
    v40[1] = v50;
    v40[2] = v51;
    v40[3] = v52;
    logfmt_raw(v161, 0x1000u, 0, v139, v138[0], v138[1], v138[2], v138[3], v138[4], v138[5], v138[6], v139);
    V_UNLOCK();
    zlog(*v99, v81, 193, "check_temperature", 17, 78, 40, v161);
  }
  while ( v97 != v9 );
  free(ptr);
  if ( v91 != v101 || v91 != v90 )
    goto LABEL_68;
LABEL_33:
  v59 = *(_DWORD *)(a1 + 196);
  if ( v91 )
  {
    v60 = v59;
    v61 = v95;
    v89[5] = v94;
    dword_1194B8[v59] = v61;
    dword_1194B8[v59 + 16] = 0;
    goto LABEL_35;
  }
LABEL_59:
  v60 = v59;
  v69 = (char *)&dword_1194B8[v59];
  v70 = *((_DWORD *)v69 + 16) + 1;
  v65 = *((_DWORD *)v69 + 16) - 1 < 0;
  *((_DWORD *)v69 + 16) = v70;
  if ( !(v65 ^ __OFSUB__(v70, 2) | (v70 == 2)) )
  {
    V_LOCK();
    V_INT((int)v107, "chain", *(int *)(a1 + 200));
    logfmt_raw(
      v161,
      0x1000u,
      0,
      v108,
      v107[0],
      v107[1],
      v107[2],
      v107[3],
      v107[4],
      v107[5],
      v107[6],
      v108,
      "read no sensor pcb temp exceed limit! (%d)",
      dword_1194B8[*(_DWORD *)(a1 + 196) + 16]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/miner_util/miner_monitor/update_miner_status/update_temperature.c",
      193,
      "update_temperature",
      18,
      278,
      120,
      v161);
    v59 = *(_DWORD *)(a1 + 196);
    v60 = v59;
    *(_DWORD *)(v104 + 16) |= 8u;
  }
LABEL_35:
  if ( v90 )
  {
    v62 = v89;
    v63 = v93;
    dword_1194B8[v60 + 32] = 0;
    v62[4] = v63;
  }
  else
  {
    v73 = dword_1194B8[v60 + 32] + 1;
    v65 = dword_1194B8[v60 + 32] - 1 < 0;
    dword_1194B8[v60 + 32] = v73;
    if ( !(v65 ^ __OFSUB__(v73, 2) | (v73 == 2)) )
    {
      V_LOCK();
      V_INT((int)v109, "chain", *(int *)(a1 + 200));
      logfmt_raw(
        v161,
        0x1000u,
        v90,
        v110,
        v109[0],
        v109[1],
        v109[2],
        v109[3],
        v109[4],
        v109[5],
        v109[6],
        v110,
        "read no sensor chip temp exceed limit! (%d)",
        dword_1194B8[*(_DWORD *)(a1 + 196) + 32]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/miner_util/miner_monitor/update_miner_status/update_temperature.c",
        193,
        "update_temperature",
        18,
        291,
        120,
        v161);
      v59 = *(_DWORD *)(a1 + 196);
      v60 = v59;
      *(_DWORD *)(v104 + 16) |= 8u;
    }
  }
  if ( *(_DWORD *)(a1 + 356) >= v92 )
  {
    dword_1194B8[v60 + 48] = 0;
  }
  else
  {
    v64 = dword_1194B8[v60 + 48] + 1;
    v65 = dword_1194B8[v60 + 48] - 1 < 0;
    dword_1194B8[v60 + 48] = v64;
    if ( !(v65 ^ __OFSUB__(v64, 2) | (v64 == 2)) )
    {
      V_LOCK();
      V_INT((int)v111, "chain", *(int *)(a1 + 200));
      logfmt_raw(
        v161,
        0x1000u,
        0,
        v112,
        v111[0],
        v111[1],
        v111[2],
        v111[3],
        v111[4],
        v111[5],
        v111[6],
        v112,
        "uneffective temp exceed limit (%d), uneffective_value_count = %d!",
        dword_1194B8[*(_DWORD *)(a1 + 196) + 48],
        v92);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/miner_util/miner_monitor/update_miner_status/update_temperature.c",
        193,
        "update_temperature",
        18,
        300,
        120,
        v161);
      v59 = *(_DWORD *)(a1 + 196);
      *(_DWORD *)(v104 + 16) |= 0x10u;
      v60 = v59;
    }
  }
  if ( v89[4] > *(_DWORD *)(a1 + 344) || dword_1194B8[v59] > *(_DWORD *)(a1 + 348) )
  {
    v71 = dword_1194B8[v60 + 64] + 1;
    v65 = dword_1194B8[v60 + 64] - 1 < 0;
    dword_1194B8[v60 + 64] = v71;
    if ( !(v65 ^ __OFSUB__(v71, 2) | (v71 == 2)) )
    {
      V_LOCK();
      V_INT((int)v113, "chain", *(int *)(a1 + 200));
      logfmt_raw(
        v161,
        0x1000u,
        0,
        v114,
        v113[0],
        v113[1],
        v113[2],
        v113[3],
        v113[4],
        v113[5],
        v113[6],
        v114,
        "high temp exceed limit (%d), max_chip_temp = %d, max_pcb_temp = %d!",
        dword_1194B8[*(_DWORD *)(a1 + 196) + 64],
        v89[4],
        dword_1194B8[*(_DWORD *)(a1 + 196)]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/miner_util/miner_monitor/update_miner_status/update_temperature.c",
        193,
        "update_temperature",
        18,
        311,
        120,
        v161);
      v72 = *(_DWORD *)(a1 + 196);
      *(_DWORD *)(v104 + 16) |= 2u;
      v60 = v72;
    }
  }
  else
  {
    dword_1194B8[v60 + 64] = 0;
  }
  if ( v89[5] <= *(_DWORD *)(a1 + 352) )
  {
    v66 = (char *)&dword_1194B8[v60];
    v67 = *((_DWORD *)v66 + 80) + 1;
    v65 = *((_DWORD *)v66 + 80) - 1 < 0;
    *((_DWORD *)v66 + 80) = v67;
    if ( !(v65 ^ __OFSUB__(v67, 2) | (v67 == 2)) )
    {
      V_LOCK();
      V_INT((int)v115, "chain", *(int *)(a1 + 200));
      logfmt_raw(
        v161,
        0x1000u,
        0,
        v116,
        v115[0],
        v115[1],
        v115[2],
        v115[3],
        v115[4],
        v115[5],
        v115[6],
        v116,
        "low temp exceed limit (%d), min_pcb_temp = %d!",
        dword_1194B8[*(_DWORD *)(a1 + 196) + 80],
        v89[5]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/miner_util/miner_monitor/update_miner_status/update_temperature.c",
        193,
        "update_temperature",
        18,
        322,
        120,
        v161);
      *(_DWORD *)(v104 + 16) |= 4u;
    }
    return v100;
  }
  result = v100;
  dword_1194B8[v60 + 80] = 0;
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1194B8: using guessed type _DWORD dword_1194B8[96];
// 11A7AC: using guessed type int g_zc;
// 11A7B0: using guessed type int g_temp_zc;

//----- (00045BF4) --------------------------------------------------------
_DWORD *__fastcall runtime_ctrl(int a1)
{
  _DWORD *v1; // r5
  int v2; // r3
  char *v3; // r2

  switch ( a1 )
  {
    case 2:
      v1 = runtime_ctrl_kda_2110();
      break;
    case 3:
      v1 = runtime_ctrl_hns_2130();
      break;
    case 4:
      v1 = runtime_ctrl_dcr_1727();
      break;
    case 5:
      v1 = runtime_ctrl_dash_1766();
      break;
    default:
      v1 = runtime_ctrl_ckb_2042();
      break;
  }
  if ( v1 )
  {
    pthread_mutex_lock(&stru_119638);
    v2 = dword_119650;
    v3 = &stru_119638.__size[4 * dword_119650++];
    *((_DWORD *)v3 + 7) = v1;
    v1[49] = v2;
    pthread_mutex_unlock(&stru_119638);
  }
  return v1;
}
// 45C04: control flows out of bounds to 45C08
// 119638: using guessed type pthread_mutex_t stru_119638;
// 119650: using guessed type int dword_119650;

//----- (00045C90) --------------------------------------------------------
int query_device_num()
{
  int (**v0)(void); // r0

  v0 = (int (**)(void))dev_ctrl();
  return (*v0)();
}
// 4AB8C: using guessed type int dev_ctrl(void);

//----- (00045CA4) --------------------------------------------------------
int __fastcall redirect_nonce_output(int result, int a2)
{
  int v2; // r3
  bool v3; // zf

  v2 = *(_DWORD *)(result + 804);
  v3 = v2 == 0;
  if ( v2 )
    v3 = result == v2;
  if ( !v3 )
    *(_DWORD *)(result + 804) = result;
  *(_DWORD *)(a2 + 804) = result;
  return result;
}

//----- (00045CBC) --------------------------------------------------------
void *__fastcall get_all_created_runtime(_DWORD *a1)
{
  pthread_mutex_lock(&stru_119638);
  *a1 = dword_119650;
  pthread_mutex_unlock(&stru_119638);
  return &unk_119654;
}
// 119638: using guessed type pthread_mutex_t stru_119638;
// 119650: using guessed type int dword_119650;

//----- (00045CEC) --------------------------------------------------------
int check_and_destroy_abnormal_runtime()
{
  int v0; // r6
  int v1; // r5
  void **v2; // r4
  _DWORD *v3; // r3
  _DWORD *v4; // t1
  int *v5; // r3
  _DWORD *v6; // r2
  int v7; // t1
  _DWORD s[256]; // [sp+10h] [bp-1404h] BYREF
  char v10[4100]; // [sp+410h] [bp-1004h] BYREF

  memset(s, 0, sizeof(s));
  pthread_mutex_lock(&stru_119638);
  if ( dword_119650 > 0 )
  {
    v1 = 0;
    v0 = 0;
    v2 = (void **)&dword_119650;
    do
    {
      v4 = v2[1];
      ++v2;
      v3 = v4;
      if ( v4[92] == v4[70] )
      {
        s[v0++] = v3;
      }
      else
      {
        V_LOCK();
        logfmt_raw(v10, 0x1000u, 0, "chain %d runtime check asic number error, destroy it!", *((_DWORD *)*v2 + 50));
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/backend_interface.c",
          155,
          "check_and_destroy_abnormal_runtime",
          34,
          85,
          80,
          v10);
        (*((void (**)(void))*v2 + 3))();
        (*((void (**)(void))*v2 + 5))();
        free(*v2);
        *v2 = 0;
      }
      ++v1;
    }
    while ( dword_119650 > v1 );
    if ( v0 )
    {
      v5 = s;
      v6 = &unk_119654;
      do
      {
        v7 = *v5++;
        *v6++ = v7;
      }
      while ( v5 != &s[v0] );
    }
  }
  else
  {
    v0 = 0;
  }
  dword_119650 = v0;
  return pthread_mutex_unlock(&stru_119638);
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119638: using guessed type pthread_mutex_t stru_119638;
// 119650: using guessed type int dword_119650;
// 11A7AC: using guessed type int g_zc;

//----- (00045E48) --------------------------------------------------------
int __fastcall sub_45E48(_DWORD *a1)
{
  signed int *v1; // r0
  signed int v2; // r4
  _DWORD *v3; // r0
  _DWORD *v4; // r10
  _DWORD *v5; // r0
  _DWORD *v6; // r0
  _DWORD *v7; // r11
  _DWORD *v8; // r9
  _DWORD *v9; // r0
  int v10; // r7
  _DWORD *v11; // r0
  _DWORD *v12; // r4
  const char *v13; // r9
  const char *v14; // r2
  _DWORD *v15; // r0
  _DWORD *v16; // r10
  _DWORD *v17; // r0
  int v18; // r9
  int v19; // r0
  _DWORD *v20; // r0
  int v21; // r9
  int v22; // r0
  _DWORD *v23; // r0
  int v24; // r9
  int v25; // r0
  int v26; // r0
  int v27; // r3
  int v29; // r0
  int v30; // r12
  signed int *v31; // [sp+10h] [bp-100Ch]
  char v32[4100]; // [sp+18h] [bp-1004h] BYREF

  v1 = (signed int *)json_object_get(a1, "power");
  v31 = v1;
  if ( !v1 || (v2 = *v1) != 0 )
  {
    V_LOCK();
    logfmt_raw(v32, 0x1000u, 0, "get power failed\n");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/topol/topol.c",
      149,
      "_parse_power",
      12,
      203,
      100,
      v32);
    return -1;
  }
  V_LOCK();
  logfmt_raw(v32, 0x1000u, 0, "power:\n");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/topol/topol.c",
    149,
    "_parse_power",
    12,
    206,
    20,
    v32);
  v3 = (_DWORD *)json_object_get(v31, "type");
  v4 = v3;
  if ( v3 && *v3 == 2 )
  {
    V_LOCK();
    v5 = json_string_value(v4);
    logfmt_raw(v32, 0x1000u, 0, "type: %s\n", v5);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/topol/topol.c",
      149,
      "_parse_power",
      12,
      214,
      20,
      v32);
    v6 = (_DWORD *)json_object_get(v31, "version");
    v7 = v6;
    if ( v6 && *v6 == 1 )
    {
      v8 = json_array_size(v6);
      dword_1197B4 = (int)v8;
      dword_1197CC = (int)calloc((size_t)v8, 2u);
      if ( (int)v8 > 0 )
      {
        do
        {
          v9 = json_array_get(v7, v2);
          v10 = 2 * v2++;
          *(_WORD *)(dword_1197CC + v10) = json_integer_value((int)v9);
          V_LOCK();
          logfmt_raw(v32, 0x1000u, 0, "psu version = 0x%x\n", *(unsigned __int16 *)(dword_1197CC + v10));
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/backend/topol/topol.c",
            149,
            "_parse_power",
            12,
            226,
            20,
            v32);
        }
        while ( dword_1197B4 > v2 );
      }
      v11 = (_DWORD *)json_object_get(v31, "is_adjustable_power");
      v12 = v11;
      if ( v11 && (unsigned int)(*v11 - 5) <= 1 )
      {
        V_LOCK();
        v13 = "true";
        if ( *v12 == 5 )
          v14 = "true";
        else
          v14 = "false";
        logfmt_raw(v32, 0x1000u, 0, "is_adjustable_power: %s\n", v14);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/topol/topol.c",
          149,
          "_parse_power",
          12,
          235,
          20,
          v32);
        byte_1197B8 = *v12 == 5;
        v15 = (_DWORD *)json_object_get(v31, "check_asic_voltage_enable");
        v16 = v15;
        if ( v15 && (unsigned int)(*v15 - 5) <= 1 )
        {
          V_LOCK();
          if ( *v16 != 5 )
            v13 = "false";
          logfmt_raw(v32, 0x1000u, 0, "check_asic_voltage_enable: %s\n", v13);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/backend/topol/topol.c",
            149,
            "_parse_power",
            12,
            244,
            20,
            v32);
          byte_1197B9 = *v16 == 5;
          v17 = (_DWORD *)json_object_get(v31, "check_asic_voltage");
          v18 = (int)v17;
          if ( v17 && *v17 == 3 )
          {
            V_LOCK();
            v19 = json_integer_value(v18);
            logfmt_raw(v32, 0x1000u, 0, "check_asic_voltage: %d\n", v19);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godmine"
              "r-origin_godminer-new/backend/topol/topol.c",
              149,
              "_parse_power",
              12,
              253,
              20,
              v32);
            dword_1197BC = json_integer_value(v18);
            v20 = (_DWORD *)json_object_get(v31, "i2c_addr");
            v21 = (int)v20;
            if ( v20 && *v20 == 3 )
            {
              V_LOCK();
              v22 = json_integer_value(v21);
              logfmt_raw(v32, 0x1000u, 0, "i2c_addr: %d\n", v22);
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godmi"
                "ner-origin_godminer-new/backend/topol/topol.c",
                149,
                "_parse_power",
                12,
                262,
                20,
                v32);
              dword_1197C0 = json_integer_value(v21);
              v23 = (_DWORD *)json_object_get(v31, "gpio");
              v24 = (int)v23;
              if ( v23 && *v23 == 3 )
              {
                V_LOCK();
                v25 = json_integer_value(v24);
                logfmt_raw(v32, 0x1000u, 0, "gpio: %d\n", v25);
                V_UNLOCK();
                zlog(
                  g_zc,
                  "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/god"
                  "miner-origin_godminer-new/backend/topol/topol.c",
                  149,
                  "_parse_power",
                  12,
                  271,
                  20,
                  v32);
                v26 = json_integer_value(v24);
                v27 = 0;
                dword_1197C4 = v26;
                return v27;
              }
              V_LOCK();
              logfmt_raw(v32, 0x1000u, 0, "get gpio failed\n");
              V_UNLOCK();
              v29 = g_zc;
              v30 = 268;
            }
            else
            {
              V_LOCK();
              logfmt_raw(v32, 0x1000u, 0, "get i2c_addr failed\n");
              V_UNLOCK();
              v29 = g_zc;
              v30 = 259;
            }
          }
          else
          {
            V_LOCK();
            logfmt_raw(v32, 0x1000u, 0, "get check_asic_voltage failed!\n");
            V_UNLOCK();
            v29 = g_zc;
            v30 = 250;
          }
        }
        else
        {
          V_LOCK();
          logfmt_raw(v32, 0x1000u, 0, "get check_asic_voltage_enable failed!\n");
          V_UNLOCK();
          v29 = g_zc;
          v30 = 241;
        }
      }
      else
      {
        V_LOCK();
        logfmt_raw(v32, 0x1000u, 0, "get is_adjustable_power failed!\n");
        V_UNLOCK();
        v29 = g_zc;
        v30 = 232;
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(v32, 0x1000u, 0, "get version array failed\n");
      V_UNLOCK();
      v29 = g_zc;
      v30 = 219;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v32, 0x1000u, 0, "get type failed\n");
    V_UNLOCK();
    v29 = g_zc;
    v30 = 211;
  }
  zlog(
    v29,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/topol/topol.c",
    149,
    "_parse_power",
    12,
    v30,
    100,
    v32);
  return -1;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1197B4: using guessed type int dword_1197B4;
// 1197B8: using guessed type char byte_1197B8;
// 1197B9: using guessed type char byte_1197B9;
// 1197BC: using guessed type int dword_1197BC;
// 1197C0: using guessed type int dword_1197C0;
// 1197C4: using guessed type int dword_1197C4;
// 1197CC: using guessed type int dword_1197CC;
// 11A7AC: using guessed type int g_zc;

//----- (00046544) --------------------------------------------------------
int __fastcall sub_46544(_DWORD *a1)
{
  _DWORD *v1; // r0
  _DWORD *v2; // r7
  _DWORD *v3; // r0
  int v4; // r9
  int v5; // r0
  _DWORD *v6; // r0
  int v7; // r9
  int v8; // r0
  _DWORD *v9; // r0
  int v10; // r9
  int v11; // r0
  _DWORD *v12; // r0
  int v13; // r10
  int v14; // r0
  _DWORD *v15; // r0
  int v16; // r10
  int v17; // r0
  _DWORD *v18; // r0
  int v19; // r10
  int v20; // r0
  _DWORD *v21; // r0
  int v22; // r10
  int v23; // r0
  _DWORD *v24; // r0
  int v25; // r10
  int v26; // r0
  _DWORD *v27; // r0
  int v28; // r10
  int v29; // r0
  _DWORD *v30; // r0
  int v31; // r10
  int v32; // r0
  __int64 v33; // r0
  double v34; // r0
  float v35; // s14
  _DWORD *v36; // r0
  int v37; // r10
  int v38; // r0
  __int64 v39; // r0
  double v40; // r0
  float v41; // s14
  _DWORD *v42; // r0
  int v43; // r10
  int v44; // r0
  __int64 v45; // r0
  double v46; // r0
  float v47; // s14
  _DWORD *v48; // r0
  int v49; // r10
  int v50; // r0
  __int64 v51; // r0
  double v52; // r0
  float v53; // s14
  _DWORD *v54; // r0
  _DWORD *v55; // r0
  int v56; // r11
  unsigned int v57; // r10
  _DWORD *v58; // r0
  _DWORD *v59; // r8
  _DWORD *v60; // r0
  int v61; // r9
  int v62; // r0
  _DWORD *v63; // r0
  int v64; // r9
  int v65; // r0
  _DWORD *v66; // r0
  int v67; // r8
  int v68; // r0
  int v69; // r0
  int v70; // r2
  int v71; // r3
  int v73; // r2
  int v74; // r0
  int v75; // r2
  _DWORD *v76; // [sp+14h] [bp-1010h]
  char v77[4100]; // [sp+20h] [bp-1004h] BYREF

  v1 = (_DWORD *)json_object_get(a1, "fan");
  v2 = v1;
  if ( !v1 || *v1 )
  {
    V_LOCK();
    logfmt_raw(v77, 0x1000u, 0, "get fan failed\n");
    V_UNLOCK();
    v73 = 286;
    goto LABEL_45;
  }
  v3 = (_DWORD *)json_object_get(v1, "fan_control_mode");
  v4 = (int)v3;
  if ( !v3 || *v3 != 3 )
  {
    V_LOCK();
    logfmt_raw(v77, 0x1000u, 0, "get fan_control_mode failed!\n");
    V_UNLOCK();
    v73 = 293;
LABEL_45:
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/topol/topol.c",
      149,
      "_parse_fan",
      10,
      v73,
      100,
      v77);
    return -1;
  }
  V_LOCK();
  v5 = json_integer_value(v4);
  logfmt_raw(v77, 0x1000u, 0, "fan_control_mode: %d\n", v5);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/topol/topol.c",
    149,
    "_parse_fan",
    10,
    296,
    20,
    v77);
  dword_11977C = json_integer_value(v4);
  v6 = (_DWORD *)json_object_get(v2, "pwm_percent_min");
  v7 = (int)v6;
  if ( v6 && *v6 == 3 )
  {
    V_LOCK();
    v8 = json_integer_value(v7);
    logfmt_raw(v77, 0x1000u, 0, "pwm_percent_min: %d\n", v8);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/topol/topol.c",
      149,
      "_parse_fan",
      10,
      305,
      20,
      v77);
    dword_119780 = json_integer_value(v7);
    v9 = (_DWORD *)json_object_get(v2, "pwm_percent_max");
    v10 = (int)v9;
    if ( v9 && *v9 == 3 )
    {
      V_LOCK();
      v11 = json_integer_value(v10);
      logfmt_raw(v77, 0x1000u, 0, "pwm_percent_max: %d\n", v11);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/topol/topol.c",
        149,
        "_parse_fan",
        10,
        314,
        20,
        v77);
      dword_119784 = json_integer_value(v10);
      v12 = (_DWORD *)json_object_get(v2, "full_speed_temp_type");
      v13 = (int)v12;
      if ( v12 && *v12 == 3 )
      {
        V_LOCK();
        v14 = json_integer_value(v13);
        logfmt_raw(v77, 0x1000u, 0, "full_speed_temp_type: %d\n", v14);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/topol/topol.c",
          149,
          "_parse_fan",
          10,
          323,
          20,
          v77);
        dword_119788 = json_integer_value(v13);
        v15 = (_DWORD *)json_object_get(v2, "full_speed_temp");
        v16 = (int)v15;
        if ( v15 && *v15 == 3 )
        {
          V_LOCK();
          v17 = json_integer_value(v16);
          logfmt_raw(v77, 0x1000u, 0, "full_speed_temp: %d\n", v17);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/backend/topol/topol.c",
            149,
            "_parse_fan",
            10,
            332,
            20,
            v77);
          dword_11978C = json_integer_value(v16);
          v18 = (_DWORD *)json_object_get(v2, "target_temp_type");
          v19 = (int)v18;
          if ( v18 && *v18 == 3 )
          {
            V_LOCK();
            v20 = json_integer_value(v19);
            logfmt_raw(v77, 0x1000u, 0, "target_temp_type: %d\n", v20);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godmine"
              "r-origin_godminer-new/backend/topol/topol.c",
              149,
              "_parse_fan",
              10,
              341,
              20,
              v77);
            dword_119790 = json_integer_value(v19);
            v21 = (_DWORD *)json_object_get(v2, "target_temp");
            v22 = (int)v21;
            if ( v21 && *v21 == 3 )
            {
              V_LOCK();
              v23 = json_integer_value(v22);
              logfmt_raw(v77, 0x1000u, 0, "target_temp: %d\n", v23);
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godmi"
                "ner-origin_godminer-new/backend/topol/topol.c",
                149,
                "_parse_fan",
                10,
                350,
                20,
                v77);
              dword_119794 = json_integer_value(v22);
              v24 = (_DWORD *)json_object_get(v2, "initial_interval");
              v25 = (int)v24;
              if ( v24 && *v24 == 3 )
              {
                V_LOCK();
                v26 = json_integer_value(v25);
                logfmt_raw(v77, 0x1000u, 0, "initial_interval: %d\n", v26);
                V_UNLOCK();
                zlog(
                  g_zc,
                  "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/god"
                  "miner-origin_godminer-new/backend/topol/topol.c",
                  149,
                  "_parse_fan",
                  10,
                  359,
                  20,
                  v77);
                dword_119798 = json_integer_value(v25);
                v27 = (_DWORD *)json_object_get(v2, "interval");
                v28 = (int)v27;
                if ( v27 && *v27 == 3 )
                {
                  V_LOCK();
                  v29 = json_integer_value(v28);
                  logfmt_raw(v77, 0x1000u, 0, "interval: %d\n", v29);
                  V_UNLOCK();
                  zlog(
                    g_zc,
                    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/g"
                    "odminer-origin_godminer-new/backend/topol/topol.c",
                    149,
                    "_parse_fan",
                    10,
                    368,
                    20,
                    v77);
                  dword_11979C = json_integer_value(v28);
                  v30 = (_DWORD *)json_object_get(v2, "startup_Kp");
                  v31 = (int)v30;
                  if ( v30 && *v30 == 3 )
                  {
                    V_LOCK();
                    v32 = json_integer_value(v31);
                    logfmt_raw(v77, 0x1000u, 0, "startup_Kp: %d\n", v32);
                    V_UNLOCK();
                    zlog(
                      g_zc,
                      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build"
                      "/godminer-origin_godminer-new/backend/topol/topol.c",
                      149,
                      "_parse_fan",
                      10,
                      377,
                      20,
                      v77);
                    v33 = json_integer_value(v31);
                    LODWORD(v34) = sub_DD47C(v33);
                    v35 = v34 / 100.0;
                    flt_1197A0 = v35;
                    v36 = (_DWORD *)json_object_get(v2, "Kp");
                    v37 = (int)v36;
                    if ( v36 && *v36 == 3 )
                    {
                      V_LOCK();
                      v38 = json_integer_value(v37);
                      logfmt_raw(v77, 0x1000u, 0, "Kp: %d\n", v38);
                      V_UNLOCK();
                      zlog(
                        g_zc,
                        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/bui"
                        "ld/godminer-origin_godminer-new/backend/topol/topol.c",
                        149,
                        "_parse_fan",
                        10,
                        386,
                        20,
                        v77);
                      v39 = json_integer_value(v37);
                      LODWORD(v40) = sub_DD47C(v39);
                      v41 = v40 / 100.0;
                      flt_1197A4 = v41;
                      v42 = (_DWORD *)json_object_get(v2, "Ki");
                      v43 = (int)v42;
                      if ( v42 && *v42 == 3 )
                      {
                        V_LOCK();
                        v44 = json_integer_value(v43);
                        logfmt_raw(v77, 0x1000u, 0, "Ki: %d\n", v44);
                        V_UNLOCK();
                        zlog(
                          g_zc,
                          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/b"
                          "uild/godminer-origin_godminer-new/backend/topol/topol.c",
                          149,
                          "_parse_fan",
                          10,
                          395,
                          20,
                          v77);
                        v45 = json_integer_value(v43);
                        LODWORD(v46) = sub_DD47C(v45);
                        v47 = v46 / 100.0;
                        flt_1197A8 = v47;
                        v48 = (_DWORD *)json_object_get(v2, "Kd");
                        v49 = (int)v48;
                        if ( v48 && *v48 == 3 )
                        {
                          V_LOCK();
                          v50 = json_integer_value(v49);
                          logfmt_raw(v77, 0x1000u, 0, "Kd: %d\n", v50);
                          V_UNLOCK();
                          zlog(
                            g_zc,
                            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release"
                            "/build/godminer-origin_godminer-new/backend/topol/topol.c",
                            149,
                            "_parse_fan",
                            10,
                            404,
                            20,
                            v77);
                          v51 = json_integer_value(v49);
                          LODWORD(v52) = sub_DD47C(v51);
                          v53 = v52 / 100.0;
                          flt_1197AC = v53;
                          v54 = (_DWORD *)json_object_get(v2, "speed_info");
                          v76 = v54;
                          if ( v54 && *v54 == 1 )
                          {
                            V_LOCK();
                            logfmt_raw(v77, 0x1000u, 0, "fan speed_info info:\n");
                            V_UNLOCK();
                            zlog(
                              g_zc,
                              "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/relea"
                              "se/build/godminer-origin_godminer-new/backend/topol/topol.c",
                              149,
                              "_parse_fan",
                              10,
                              413,
                              20,
                              v77);
                            v55 = json_array_size(v76);
                            dword_1197B0 = (int)calloc((size_t)v55, 0xCu);
                            if ( !dword_1197B0 )
                            {
                              V_LOCK();
                              logfmt_raw(v77, 0x1000u, 0, "calloc topol_machine.fan_info.speeds failed!\n");
                              V_UNLOCK();
                              zlog(
                                g_zc,
                                "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/rel"
                                "ease/build/godminer-origin_godminer-new/backend/topol/topol.c",
                                149,
                                "_parse_fan",
                                10,
                                418,
                                100,
                                v77);
                              return -1;
                            }
                            v56 = 0;
                            v57 = 0;
                            while ( 1 )
                            {
                              if ( (unsigned int)json_array_size(v76) <= v57 )
                                return 0;
                              v58 = json_array_get(v76, v57);
                              v59 = v58;
                              if ( !v58 || *v58 )
                              {
                                V_LOCK();
                                logfmt_raw(v77, 0x1000u, 0, "get array %d failed\n", v57);
                                V_UNLOCK();
                                v74 = g_zc;
                                v75 = 427;
                                goto LABEL_49;
                              }
                              v60 = (_DWORD *)json_object_get(v58, "id");
                              v61 = (int)v60;
                              if ( !v60 || *v60 != 3 )
                              {
                                V_LOCK();
                                logfmt_raw(v77, 0x1000u, 0, "get array %d id failed\n", v57);
                                V_UNLOCK();
                                v74 = g_zc;
                                v75 = 434;
                                goto LABEL_49;
                              }
                              V_LOCK();
                              v62 = json_integer_value(v61);
                              logfmt_raw(v77, 0x1000u, 0, "id: %d\n", v62);
                              V_UNLOCK();
                              zlog(
                                g_zc,
                                "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/rel"
                                "ease/build/godminer-origin_godminer-new/backend/topol/topol.c",
                                149,
                                "_parse_fan",
                                10,
                                437,
                                20,
                                v77);
                              *(_DWORD *)(dword_1197B0 + v56) = json_integer_value(v61);
                              v63 = (_DWORD *)json_object_get(v59, "max_speed");
                              v64 = (int)v63;
                              if ( !v63 || *v63 != 3 )
                              {
                                V_LOCK();
                                logfmt_raw(v77, 0x1000u, 0, "get array %d max_speed failed\n", v57);
                                V_UNLOCK();
                                v74 = g_zc;
                                v75 = 443;
                                goto LABEL_49;
                              }
                              V_LOCK();
                              v65 = json_integer_value(v64);
                              logfmt_raw(v77, 0x1000u, 0, "max_speed: %d\n", v65);
                              V_UNLOCK();
                              zlog(
                                g_zc,
                                "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/rel"
                                "ease/build/godminer-origin_godminer-new/backend/topol/topol.c",
                                149,
                                "_parse_fan",
                                10,
                                446,
                                20,
                                v77);
                              *(_DWORD *)(dword_1197B0 + v56 + 8) = json_integer_value(v64);
                              v66 = (_DWORD *)json_object_get(v59, "min_speed");
                              v67 = (int)v66;
                              if ( !v66 || *v66 != 3 )
                                break;
                              V_LOCK();
                              ++v57;
                              v68 = json_integer_value(v67);
                              logfmt_raw(v77, 0x1000u, 0, "min_speed: %d\n", v68);
                              V_UNLOCK();
                              zlog(
                                g_zc,
                                "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/rel"
                                "ease/build/godminer-origin_godminer-new/backend/topol/topol.c",
                                149,
                                "_parse_fan",
                                10,
                                455,
                                20,
                                v77);
                              v69 = json_integer_value(v67);
                              v70 = dword_1197B0 + v56;
                              v56 += 12;
                              v71 = dword_119774 + 1;
                              *(_DWORD *)(v70 + 4) = v69;
                              dword_119774 = v71;
                            }
                            V_LOCK();
                            logfmt_raw(v77, 0x1000u, 0, "get array %d min_speed failed\n", v57);
                            V_UNLOCK();
                            v74 = g_zc;
                            v75 = 452;
                          }
                          else
                          {
                            V_LOCK();
                            logfmt_raw(v77, 0x1000u, 0, "get fan speed_info failed\n");
                            V_UNLOCK();
                            v74 = g_zc;
                            v75 = 410;
                          }
                        }
                        else
                        {
                          V_LOCK();
                          logfmt_raw(v77, 0x1000u, 0, "get Kd failed!\n");
                          V_UNLOCK();
                          v74 = g_zc;
                          v75 = 401;
                        }
                      }
                      else
                      {
                        V_LOCK();
                        logfmt_raw(v77, 0x1000u, 0, "get Ki failed!\n");
                        V_UNLOCK();
                        v74 = g_zc;
                        v75 = 392;
                      }
                    }
                    else
                    {
                      V_LOCK();
                      logfmt_raw(v77, 0x1000u, 0, "get Kp failed!\n");
                      V_UNLOCK();
                      v74 = g_zc;
                      v75 = 383;
                    }
                  }
                  else
                  {
                    V_LOCK();
                    logfmt_raw(v77, 0x1000u, 0, "get startup_Kp failed!\n");
                    V_UNLOCK();
                    v74 = g_zc;
                    v75 = 374;
                  }
                }
                else
                {
                  V_LOCK();
                  logfmt_raw(v77, 0x1000u, 0, "get interval failed!\n");
                  V_UNLOCK();
                  v74 = g_zc;
                  v75 = 365;
                }
              }
              else
              {
                V_LOCK();
                logfmt_raw(v77, 0x1000u, 0, "get initial_interval failed!\n");
                V_UNLOCK();
                v74 = g_zc;
                v75 = 356;
              }
            }
            else
            {
              V_LOCK();
              logfmt_raw(v77, 0x1000u, 0, "get target_temp failed!\n");
              V_UNLOCK();
              v74 = g_zc;
              v75 = 347;
            }
          }
          else
          {
            V_LOCK();
            logfmt_raw(v77, 0x1000u, 0, "get target_temp_type failed!\n");
            V_UNLOCK();
            v74 = g_zc;
            v75 = 338;
          }
        }
        else
        {
          V_LOCK();
          logfmt_raw(v77, 0x1000u, 0, "get full_speed_temp failed!\n");
          V_UNLOCK();
          v74 = g_zc;
          v75 = 329;
        }
      }
      else
      {
        V_LOCK();
        logfmt_raw(v77, 0x1000u, 0, "get full_speed_temp_type failed!\n");
        V_UNLOCK();
        v74 = g_zc;
        v75 = 320;
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(v77, 0x1000u, 0, "get pwm_percent_max failed!\n");
      V_UNLOCK();
      v74 = g_zc;
      v75 = 311;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v77, 0x1000u, 0, "get pwm_percent_min failed!\n");
    V_UNLOCK();
    v74 = g_zc;
    v75 = 302;
  }
LABEL_49:
  zlog(
    v74,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/topol/topol.c",
    149,
    "_parse_fan",
    10,
    v75,
    100,
    v77);
  return -1;
}
// 46AF4: variable 'v34' is possibly undefined
// 46B8C: variable 'v40' is possibly undefined
// 46C24: variable 'v46' is possibly undefined
// 46CBC: variable 'v52' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119774: using guessed type int dword_119774;
// 11977C: using guessed type int dword_11977C;
// 119780: using guessed type int dword_119780;
// 119784: using guessed type int dword_119784;
// 119788: using guessed type int dword_119788;
// 11978C: using guessed type int dword_11978C;
// 119790: using guessed type int dword_119790;
// 119794: using guessed type int dword_119794;
// 119798: using guessed type int dword_119798;
// 11979C: using guessed type int dword_11979C;
// 1197A0: using guessed type float flt_1197A0;
// 1197A4: using guessed type float flt_1197A4;
// 1197A8: using guessed type float flt_1197A8;
// 1197AC: using guessed type float flt_1197AC;
// 1197B0: using guessed type int dword_1197B0;
// 11A7AC: using guessed type int g_zc;

//----- (000473E4) --------------------------------------------------------
int __fastcall sub_473E4(_DWORD *a1)
{
  _DWORD *v1; // r0
  _DWORD *v2; // r7
  _DWORD *v3; // r0
  _DWORD *v4; // r8
  _DWORD *v5; // r0
  _DWORD *v6; // r0
  _DWORD *v7; // r11
  _DWORD *v8; // r0
  const char *v9; // r0
  int v10; // r11
  int v11; // r0
  _DWORD *v12; // r0
  int v13; // r11
  int v14; // r0
  _DWORD *v15; // r0
  int v16; // r10
  int v17; // r0
  _DWORD *v18; // r0
  int v19; // r10
  int v20; // r0
  _DWORD *v21; // r0
  int v22; // r10
  int v23; // r0
  _DWORD *v24; // r0
  int v25; // r10
  int v26; // r0
  _DWORD *v27; // r0
  int v28; // r7
  int v29; // r0
  int v30; // r0
  int v31; // r3
  int v33; // r0
  int v34; // r2
  char v35[4100]; // [sp+18h] [bp-1004h] BYREF

  v1 = (_DWORD *)json_object_get(a1, "asic");
  v2 = v1;
  if ( !v1 || *v1 )
  {
    V_LOCK();
    logfmt_raw(v35, 0x1000u, 0, "get asic failed\n");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/topol/topol.c",
      149,
      "_parse_asic",
      11,
      471,
      100,
      v35);
  }
  else
  {
    V_LOCK();
    logfmt_raw(v35, 0x1000u, 0, "asic:\n");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/topol/topol.c",
      149,
      "_parse_asic",
      11,
      474,
      20,
      v35);
    v3 = (_DWORD *)json_object_get(v2, "asic_id");
    v4 = v3;
    if ( v3 && *v3 == 2 )
    {
      V_LOCK();
      v5 = json_string_value(v4);
      logfmt_raw(v35, 0x1000u, 0, "asic_id: %s\n", v5);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/topol/topol.c",
        149,
        "_parse_asic",
        11,
        482,
        20,
        v35);
      v6 = (_DWORD *)json_object_get(v2, "chip_type");
      v7 = v6;
      if ( v6 && *v6 == 2 )
      {
        V_LOCK();
        v8 = json_string_value(v7);
        logfmt_raw(v35, 0x1000u, 0, "chip_type : %s\n", v8);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/topol/topol.c",
          149,
          "_parse_asic",
          11,
          490,
          20,
          v35);
        v9 = (const char *)json_string_value(v7);
        v10 = dword_119778;
        v11 = strtol(v9, 0, 0);
        *(_DWORD *)(v10 + 24) = v11;
        if ( !v11 )
        {
          V_LOCK();
          logfmt_raw(v35, 0x1000u, 0, "convert chip_type failed\n");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/backend/topol/topol.c",
            149,
            "_parse_asic",
            11,
            495,
            100,
            v35);
          return -1;
        }
        V_LOCK();
        logfmt_raw(v35, 0x1000u, 0, "chip_type 0x%x\n", *(_DWORD *)(dword_119778 + 24));
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/topol/topol.c",
          149,
          "_parse_asic",
          11,
          498,
          20,
          v35);
        v12 = (_DWORD *)json_object_get(v2, "cycle_cnt");
        v13 = (int)v12;
        if ( v12 && *v12 == 3 )
        {
          V_LOCK();
          v14 = json_integer_value(v13);
          logfmt_raw(v35, 0x1000u, 0, "cycle_cnt : %d\n", v14);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/backend/topol/topol.c",
            149,
            "_parse_asic",
            11,
            506,
            20,
            v35);
          *(_DWORD *)(dword_119778 + 28) = json_integer_value(v13);
          v15 = (_DWORD *)json_object_get(v2, "asic_big_core_num");
          v16 = (int)v15;
          if ( v15 && *v15 == 3 )
          {
            V_LOCK();
            v17 = json_integer_value(v16);
            logfmt_raw(v35, 0x1000u, 0, "asic_big_core_num: %d\n", v17);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godmine"
              "r-origin_godminer-new/backend/topol/topol.c",
              149,
              "_parse_asic",
              11,
              515,
              20,
              v35);
            *(_DWORD *)(dword_119778 + 36) = json_integer_value(v16);
            v18 = (_DWORD *)json_object_get(v2, "asic_little_core_num");
            v19 = (int)v18;
            if ( v18 && *v18 == 3 )
            {
              V_LOCK();
              v20 = json_integer_value(v19);
              logfmt_raw(v35, 0x1000u, 0, "asic_little_core_num %d\n", v20);
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godmi"
                "ner-origin_godminer-new/backend/topol/topol.c",
                149,
                "_parse_asic",
                11,
                524,
                20,
                v35);
              *(_DWORD *)(dword_119778 + 40) = json_integer_value(v19);
              v21 = (_DWORD *)json_object_get(v2, "core_little_core_num");
              v22 = (int)v21;
              if ( v21 && *v21 == 3 )
              {
                V_LOCK();
                v23 = json_integer_value(v22);
                logfmt_raw(v35, 0x1000u, 0, "core_little_core_num: %d\n", v23);
                V_UNLOCK();
                zlog(
                  g_zc,
                  "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/god"
                  "miner-origin_godminer-new/backend/topol/topol.c",
                  149,
                  "_parse_asic",
                  11,
                  533,
                  20,
                  v35);
                *(_DWORD *)(dword_119778 + 44) = json_integer_value(v22);
                v24 = (_DWORD *)json_object_get(v2, "asic_domain_num");
                v25 = (int)v24;
                if ( v24 && *v24 == 3 )
                {
                  V_LOCK();
                  v26 = json_integer_value(v25);
                  logfmt_raw(v35, 0x1000u, 0, "asic_domain_num : %d\n", v26);
                  V_UNLOCK();
                  zlog(
                    g_zc,
                    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/g"
                    "odminer-origin_godminer-new/backend/topol/topol.c",
                    149,
                    "_parse_asic",
                    11,
                    542,
                    20,
                    v35);
                  *(_DWORD *)(dword_119778 + 48) = json_integer_value(v25);
                  v27 = (_DWORD *)json_object_get(v2, "asic_addr_interval");
                  v28 = (int)v27;
                  if ( v27 && *v27 == 3 )
                  {
                    V_LOCK();
                    v29 = json_integer_value(v28);
                    logfmt_raw(v35, 0x1000u, 0, "asic_addr_interval : %d\n", v29);
                    V_UNLOCK();
                    zlog(
                      g_zc,
                      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build"
                      "/godminer-origin_godminer-new/backend/topol/topol.c",
                      149,
                      "_parse_asic",
                      11,
                      551,
                      20,
                      v35);
                    v30 = json_integer_value(v28);
                    v31 = 0;
                    *(_DWORD *)(dword_119778 + 52) = v30;
                    return v31;
                  }
                  V_LOCK();
                  logfmt_raw(v35, 0x1000u, 0, "get asic_addr_interval failed\n");
                  V_UNLOCK();
                  v33 = g_zc;
                  v34 = 548;
                }
                else
                {
                  V_LOCK();
                  logfmt_raw(v35, 0x1000u, 0, "get asic_domain_num failed\n");
                  V_UNLOCK();
                  v33 = g_zc;
                  v34 = 539;
                }
              }
              else
              {
                V_LOCK();
                logfmt_raw(v35, 0x1000u, 0, "get core_little_core_num failed\n");
                V_UNLOCK();
                v33 = g_zc;
                v34 = 530;
              }
            }
            else
            {
              V_LOCK();
              logfmt_raw(v35, 0x1000u, 0, "get asic_little_core_num failed\n");
              V_UNLOCK();
              v33 = g_zc;
              v34 = 521;
            }
          }
          else
          {
            V_LOCK();
            logfmt_raw(v35, 0x1000u, 0, "get asic_big_core_num failed\n");
            V_UNLOCK();
            v33 = g_zc;
            v34 = 512;
          }
        }
        else
        {
          V_LOCK();
          logfmt_raw(v35, 0x1000u, 0, "get cycle_cnt failed\n");
          V_UNLOCK();
          v33 = g_zc;
          v34 = 503;
        }
      }
      else
      {
        V_LOCK();
        logfmt_raw(v35, 0x1000u, 0, "get chip_type failed\n");
        V_UNLOCK();
        v33 = g_zc;
        v34 = 487;
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(v35, 0x1000u, 0, "get asic_id failed\n");
      V_UNLOCK();
      v33 = g_zc;
      v34 = 479;
    }
    zlog(
      v33,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/topol/topol.c",
      149,
      "_parse_asic",
      11,
      v34,
      100,
      v35);
  }
  return -1;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119778: using guessed type int dword_119778;
// 11A7AC: using guessed type int g_zc;

//----- (00047BB4) --------------------------------------------------------
int __fastcall sub_47BB4(_DWORD *a1)
{
  _DWORD *v1; // r0
  _DWORD *v2; // r7
  _DWORD *v3; // r0
  _DWORD *v4; // r10
  _DWORD *v5; // r0
  _DWORD *v6; // r0
  int v7; // r10
  int v8; // r0
  _DWORD *v9; // r0
  int v10; // r10
  int v11; // r0
  int v12; // r0
  int v13; // r3
  _DWORD *v15; // r0
  _DWORD *v16; // r0
  _DWORD *v17; // r7
  _DWORD *v18; // r0
  int v19; // r6
  int v20; // r0
  int v21; // r0
  int v22; // r6
  _DWORD *v23; // r6
  _DWORD *v24; // r0
  _DWORD *v25; // r9
  _DWORD *v26; // r0
  const char *v27; // r8
  int v28; // r0
  _DWORD *v29; // r0
  int v30; // r8
  int v31; // r0
  _DWORD *v32; // r0
  _DWORD *v33; // r8
  int v34; // r11
  _DWORD *v35; // r0
  char **v36; // r9
  const char *v37; // r0
  const char *v38; // r1
  const char *v39; // r10
  const char *v40; // t1
  int v41; // r8
  _DWORD *v42; // r0
  _DWORD *v43; // r9
  _DWORD *v44; // r0
  const char **v45; // r7
  const char *v46; // r0
  const char *v47; // r1
  const char *v48; // r9
  const char *v49; // t1
  int v50; // r0
  int v51; // r2
  int v52; // r0
  int v53; // r2
  unsigned int i; // [sp+14h] [bp-1018h]
  _DWORD *v55; // [sp+18h] [bp-1014h]
  char v56[4100]; // [sp+28h] [bp-1004h] BYREF

  v1 = (_DWORD *)json_object_get(a1, "pic");
  v2 = v1;
  if ( !v1 || *v1 )
  {
    V_LOCK();
    logfmt_raw(v56, 0x1000u, 0, "get pic failed\n");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/topol/topol.c",
      149,
      "_parse_chain_pic",
      16,
      713,
      100,
      v56);
    return -1;
  }
  V_LOCK();
  logfmt_raw(v56, 0x1000u, 0, "pic:\n");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/topol/topol.c",
    149,
    "_parse_chain_pic",
    16,
    716,
    20,
    v56);
  v3 = (_DWORD *)json_object_get(v2, "type");
  v4 = v3;
  if ( !v3 || *v3 != 2 )
  {
    V_LOCK();
    logfmt_raw(v56, 0x1000u, 0, "get type failed\n");
    V_UNLOCK();
    v50 = g_zc;
    v51 = 721;
LABEL_39:
    zlog(
      v50,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/topol/topol.c",
      149,
      "_parse_chain_pic",
      16,
      v51,
      100,
      v56);
    return -1;
  }
  V_LOCK();
  v5 = json_string_value(v4);
  logfmt_raw(v56, 0x1000u, 0, "type: %s\n", v5);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/topol/topol.c",
    149,
    "_parse_chain_pic",
    16,
    724,
    20,
    v56);
  v6 = (_DWORD *)json_object_get(v2, "i2c_addr");
  v7 = (int)v6;
  if ( !v6 || *v6 != 3 )
  {
    V_LOCK();
    logfmt_raw(v56, 0x1000u, 0, "get i2c_addr failed\n");
    V_UNLOCK();
    v50 = g_zc;
    v51 = 729;
    goto LABEL_39;
  }
  V_LOCK();
  v8 = json_integer_value(v7);
  logfmt_raw(v56, 0x1000u, 0, "i2c_addr: %d\n", v8);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/topol/topol.c",
    149,
    "_parse_chain_pic",
    16,
    732,
    20,
    v56);
  v9 = (_DWORD *)json_object_get(v2, "device_high");
  v10 = (int)v9;
  if ( !v9 || *v9 != 3 )
  {
    V_LOCK();
    logfmt_raw(v56, 0x1000u, 0, "get device_high failed\n");
    V_UNLOCK();
    v50 = g_zc;
    v51 = 737;
    goto LABEL_39;
  }
  V_LOCK();
  v11 = json_integer_value(v10);
  logfmt_raw(v56, 0x1000u, 0, "device_high: %d\n", v11);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/topol/topol.c",
    149,
    "_parse_chain_pic",
    16,
    740,
    20,
    v56);
  v12 = json_integer_value(v10);
  v13 = *(_DWORD *)(dword_119778 + 88);
  *(_DWORD *)(dword_119778 + 64) = v12;
  if ( (unsigned int)(v13 - 1) > 1 )
    return 0;
  v15 = (_DWORD *)json_object_get(v2, "pic_sensor");
  v55 = v15;
  if ( v15 && *v15 == 1 )
  {
    V_LOCK();
    logfmt_raw(v56, 0x1000u, 0, "pic sensor:\n");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/topol/topol.c",
      149,
      "_parse_chain_pic_sensor",
      23,
      568,
      20,
      v56);
    for ( i = 0; i < (unsigned int)json_array_size(v55); ++i )
    {
      v16 = json_array_get(v55, i);
      v17 = v16;
      if ( !v16 || *v16 )
      {
        V_LOCK();
        logfmt_raw(v56, 0x1000u, 0, "get array %d failed\n", i);
        V_UNLOCK();
        v52 = g_zc;
        v53 = 575;
        goto LABEL_45;
      }
      v18 = (_DWORD *)json_object_get(v16, "index");
      v19 = (int)v18;
      if ( !v18 || *v18 != 3 )
      {
        V_LOCK();
        logfmt_raw(v56, 0x1000u, 0, "get array %d index failed\n", i);
        V_UNLOCK();
        v52 = g_zc;
        v53 = 582;
        goto LABEL_45;
      }
      V_LOCK();
      v20 = json_integer_value(v19);
      logfmt_raw(v56, 0x1000u, 0, "index: %d\n", v20);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/topol/topol.c",
        149,
        "_parse_chain_pic_sensor",
        23,
        585,
        20,
        v56);
      v21 = json_integer_value(v19);
      v22 = *(_DWORD *)(dword_119778 + 84);
      *(_DWORD *)(v22 + 24 * v21) = v21;
      v23 = (_DWORD *)(v22 + 24 * v21);
      v23[2] = 0;
      v24 = (_DWORD *)json_object_get(v17, "type");
      v25 = v24;
      if ( !v24 || *v24 != 2 )
      {
        V_LOCK();
        logfmt_raw(v56, 0x1000u, 0, "get array %d type failed\n", i);
        V_UNLOCK();
        v52 = g_zc;
        v53 = 594;
        goto LABEL_45;
      }
      V_LOCK();
      v26 = json_string_value(v25);
      logfmt_raw(v56, 0x1000u, 0, "type: %s\n", v26);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/topol/topol.c",
        149,
        "_parse_chain_pic_sensor",
        23,
        597,
        20,
        v56);
      v27 = (const char *)json_string_value(v25);
      v28 = strcmp(v27, "TMP451");
      if ( v28 )
      {
        if ( !strcmp(v27, "LM75A") )
          v28 = 1;
        else
          v28 = 2;
      }
      v23[1] = v28;
      v29 = (_DWORD *)json_object_get(v17, "iic");
      v30 = (int)v29;
      if ( !v29 || *v29 != 3 )
      {
        V_LOCK();
        logfmt_raw(v56, 0x1000u, 0, "get array %d bind_asic failed\n", i);
        V_UNLOCK();
        v52 = g_zc;
        v53 = 603;
        goto LABEL_45;
      }
      V_LOCK();
      v31 = json_integer_value(v30);
      logfmt_raw(v56, 0x1000u, 0, "iic: %d\n", v31);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/topol/topol.c",
        149,
        "_parse_chain_pic_sensor",
        23,
        606,
        20,
        v56);
      v23[5] = json_integer_value(v30);
      v32 = (_DWORD *)json_object_get(v17, "x");
      v33 = v32;
      if ( !v32 || *v32 != 2 )
      {
        V_LOCK();
        logfmt_raw(v56, 0x1000u, 0, "get array %d x failed\n", i);
        V_UNLOCK();
        v52 = g_zc;
        v53 = 612;
        goto LABEL_45;
      }
      V_LOCK();
      v34 = 0;
      v35 = json_string_value(v33);
      logfmt_raw(v56, 0x1000u, 0, "x: %s\n", v35);
      V_UNLOCK();
      v36 = off_E4E38;
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/topol/topol.c",
        149,
        "_parse_chain_pic_sensor",
        23,
        615,
        20,
        v56);
      v37 = (const char *)json_string_value(v33);
      v38 = "air_in";
      v39 = v37;
      while ( strcmp(v39, v38) )
      {
        v40 = *v36++;
        v38 = v40;
        ++v34;
      }
      v41 = 0;
      v23[3] = v34;
      v42 = (_DWORD *)json_object_get(v17, "y");
      v43 = v42;
      if ( !v42 || *v42 != 2 )
      {
        V_LOCK();
        logfmt_raw(v56, 0x1000u, 0, "get array %d y failed\n", i);
        V_UNLOCK();
        v52 = g_zc;
        v53 = 621;
        goto LABEL_45;
      }
      V_LOCK();
      v44 = json_string_value(v43);
      logfmt_raw(v56, 0x1000u, 0, "y: %s\n", v44);
      V_UNLOCK();
      v45 = (const char **)&unk_E4E58;
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/topol/topol.c",
        149,
        "_parse_chain_pic_sensor",
        23,
        624,
        20,
        v56);
      v46 = (const char *)json_string_value(v43);
      v47 = "top";
      v48 = v46;
      while ( strcmp(v48, v47) )
      {
        v49 = *v45++;
        v47 = v49;
        ++v41;
      }
      v23[4] = v41;
    }
    return 0;
  }
  V_LOCK();
  logfmt_raw(v56, 0x1000u, 0, "get pic sensor failed\n");
  V_UNLOCK();
  v52 = g_zc;
  v53 = 565;
LABEL_45:
  zlog(
    v52,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/topol/topol.c",
    149,
    "_parse_chain_pic_sensor",
    23,
    v53,
    100,
    v56);
  return -1;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// E4E38: using guessed type char *[2];
// 119778: using guessed type int dword_119778;
// 11A7AC: using guessed type int g_zc;

//----- (00048504) --------------------------------------------------------
int platform_is_adjustable_power()
{
  return (unsigned __int8)byte_1197B8;
}
// 1197B8: using guessed type char byte_1197B8;

//----- (00048514) --------------------------------------------------------
int platform_is_check_asic_voltage_enable()
{
  return (unsigned __int8)byte_1197B9;
}
// 1197B9: using guessed type char byte_1197B9;

//----- (00048524) --------------------------------------------------------
int platfrom_get_check_asic_voltage()
{
  return dword_1197BC;
}
// 1197BC: using guessed type int dword_1197BC;

//----- (00048534) --------------------------------------------------------
int platform_get_machine_name()
{
  return dword_119754;
}
// 119754: using guessed type int dword_119754;

//----- (00048544) --------------------------------------------------------
int platform_get_chain_num()
{
  return dword_119758;
}
// 119758: using guessed type int dword_119758;

//----- (00048554) --------------------------------------------------------
int platform_get_chain_domain_num()
{
  return dword_119764;
}
// 119764: using guessed type int dword_119764;

//----- (00048564) --------------------------------------------------------
int platform_get_chain_asic_num()
{
  return dword_119768;
}
// 119768: using guessed type int dword_119768;

//----- (00048574) --------------------------------------------------------
int platform_get_domain_asic_num()
{
  return dword_11976C;
}
// 11976C: using guessed type int dword_11976C;

//----- (00048584) --------------------------------------------------------
int __fastcall platform_get_chip_type(int a1)
{
  return *(_DWORD *)(dword_119778 + 120 * a1 + 24);
}
// 119778: using guessed type int dword_119778;

//----- (000485A0) --------------------------------------------------------
int __fastcall platform_get_asic_big_core_num(int a1)
{
  return *(_DWORD *)(dword_119778 + 120 * a1 + 36);
}
// 119778: using guessed type int dword_119778;

//----- (000485BC) --------------------------------------------------------
int __fastcall platform_get_asic_little_core_num(int a1)
{
  return *(_DWORD *)(dword_119778 + 120 * a1 + 40);
}
// 119778: using guessed type int dword_119778;

//----- (000485D8) --------------------------------------------------------
int __fastcall platform_get_core_little_core_num(int a1)
{
  return *(_DWORD *)(dword_119778 + 120 * a1 + 44);
}
// 119778: using guessed type int dword_119778;

//----- (000485F4) --------------------------------------------------------
int __fastcall platform_get_asic_domain_num(int a1)
{
  return *(_DWORD *)(dword_119778 + 120 * a1 + 48);
}
// 119778: using guessed type int dword_119778;

//----- (00048610) --------------------------------------------------------
int platform_is_pic_mcu_en()
{
  return (unsigned __int8)byte_119770;
}
// 119770: using guessed type char byte_119770;

//----- (00048620) --------------------------------------------------------
int __fastcall platform_get_asic_addr_interval(int a1)
{
  return *(_DWORD *)(dword_119778 + 120 * a1 + 52);
}
// 119778: using guessed type int dword_119778;

//----- (0004863C) --------------------------------------------------------
int __fastcall platform_get_chain_sensor_mode(int a1)
{
  return *(_DWORD *)(dword_119778 + 120 * a1 + 88);
}
// 119778: using guessed type int dword_119778;

//----- (00048658) --------------------------------------------------------
int __fastcall platform_get_chain_sensor_num(int a1)
{
  return *(_DWORD *)(dword_119778 + 120 * a1 + 92);
}
// 119778: using guessed type int dword_119778;

//----- (00048674) --------------------------------------------------------
int __fastcall platform_get_sensor_addr(int a1, int a2)
{
  return *(_DWORD *)(*(_DWORD *)(dword_119778 + 120 * a1 + 84) + 24 * a2 + 20);
}
// 119778: using guessed type int dword_119778;

//----- (0004869C) --------------------------------------------------------
int platform_is_asic_sensor_air_in()
{
  return 0;
}

//----- (000486A4) --------------------------------------------------------
int __fastcall platform_get_sensor_max_chip_temp(int a1)
{
  return *(_DWORD *)(dword_119778 + 120 * a1 + 96);
}
// 119778: using guessed type int dword_119778;

//----- (000486C0) --------------------------------------------------------
int __fastcall platform_get_sensor_max_pcb_temp(int a1)
{
  return *(_DWORD *)(dword_119778 + 120 * a1 + 100);
}
// 119778: using guessed type int dword_119778;

//----- (000486DC) --------------------------------------------------------
int __fastcall platform_get_sensor_min_pcb_temp(int a1)
{
  return *(_DWORD *)(dword_119778 + 120 * a1 + 104);
}
// 119778: using guessed type int dword_119778;

//----- (000486F8) --------------------------------------------------------
int __fastcall platform_get_sensor_max_uneffective_count(int a1)
{
  return *(_DWORD *)(dword_119778 + 120 * a1 + 108);
}
// 119778: using guessed type int dword_119778;

//----- (00048714) --------------------------------------------------------
int platform_get_fan_num()
{
  return dword_119774;
}
// 119774: using guessed type int dword_119774;

//----- (00048724) --------------------------------------------------------
int __fastcall platform_get_fan_max_speed(int a1)
{
  return *(_DWORD *)(dword_1197B0 + 12 * a1 + 8);
}
// 1197B0: using guessed type int dword_1197B0;

//----- (00048740) --------------------------------------------------------
int __fastcall platform_get_fan_min_speed(int a1)
{
  return *(_DWORD *)(dword_1197B0 + 12 * a1 + 4);
}
// 1197B0: using guessed type int dword_1197B0;

//----- (0004875C) --------------------------------------------------------
float *__fastcall platform_get_fan_control_info(float *result)
{
  int v1; // r1
  int v2; // r2
  int v3; // r3
  int v4; // r1
  int v5; // r2
  int v6; // r3
  float v7; // r1
  float v8; // r2
  float v9; // r3
  float v10; // lr

  v1 = dword_119780;
  v2 = dword_119784;
  v3 = dword_119788;
  *(_DWORD *)result = dword_11977C;
  *((_DWORD *)result + 1) = v1;
  *((_DWORD *)result + 2) = v2;
  *((_DWORD *)result + 3) = v3;
  v4 = dword_119790;
  v5 = dword_119794;
  v6 = dword_119798;
  *((_DWORD *)result + 4) = dword_11978C;
  *((_DWORD *)result + 5) = v4;
  *((_DWORD *)result + 6) = v5;
  *((_DWORD *)result + 7) = v6;
  v7 = flt_1197A0;
  v8 = flt_1197A4;
  v9 = flt_1197A8;
  v10 = flt_1197AC;
  *((_DWORD *)result + 8) = dword_11979C;
  result[9] = v7;
  result[10] = v8;
  result[11] = v9;
  result[12] = v10;
  return result;
}
// 11977C: using guessed type int dword_11977C;
// 119780: using guessed type int dword_119780;
// 119784: using guessed type int dword_119784;
// 119788: using guessed type int dword_119788;
// 11978C: using guessed type int dword_11978C;
// 119790: using guessed type int dword_119790;
// 119794: using guessed type int dword_119794;
// 119798: using guessed type int dword_119798;
// 11979C: using guessed type int dword_11979C;
// 1197A0: using guessed type float flt_1197A0;
// 1197A4: using guessed type float flt_1197A4;
// 1197A8: using guessed type float flt_1197A8;
// 1197AC: using guessed type float flt_1197AC;

//----- (00048798) --------------------------------------------------------
int __fastcall platform_get_pic_device_high(int a1)
{
  return *(_DWORD *)(dword_119778 + 120 * a1 + 64);
}
// 119778: using guessed type int dword_119778;

//----- (000487B4) --------------------------------------------------------
int platform_get_psu_gpio_port()
{
  return dword_1197C4;
}
// 1197C4: using guessed type int dword_1197C4;

//----- (000487C4) --------------------------------------------------------
int __fastcall platform_is_psu_supported(int a1)
{
  unsigned __int16 *i; // r3
  int v2; // t1

  if ( dword_1197B4 <= 0 )
    return 0;
  if ( *(unsigned __int16 *)dword_1197CC != a1 )
  {
    for ( i = (unsigned __int16 *)(dword_1197CC + 2); i != (unsigned __int16 *)(dword_1197CC + 2 * dword_1197B4); ++i )
    {
      v2 = *i;
      if ( v2 == a1 )
        return 1;
    }
    return 0;
  }
  return 1;
}
// 1197B4: using guessed type int dword_1197B4;
// 1197CC: using guessed type int dword_1197CC;

//----- (00048818) --------------------------------------------------------
int platform_topol_init()
{
  double *file; // r0
  double *v1; // r10
  _DWORD *v2; // r0
  _DWORD *v3; // r9
  _DWORD *v4; // r0
  const char *v5; // r9
  void *v6; // r0
  _DWORD *v7; // r0
  _DWORD *v8; // r9
  _DWORD *v9; // r0
  _DWORD *v10; // r0
  _DWORD *v11; // r9
  _DWORD *v12; // r0
  _DWORD *v13; // r0
  _DWORD *v14; // r8
  _DWORD *v15; // r0
  _DWORD *v16; // r8
  _DWORD *v17; // r0
  int v18; // r0
  int v19; // r2
  unsigned int *v20; // r3
  unsigned int v21; // r2
  unsigned int v22; // r2
  int v24; // r0
  int v25; // r2
  _DWORD *v26; // r0
  _DWORD *v27; // r0
  int v28; // r9
  int v29; // r0
  size_t v30; // r9
  _DWORD *v31; // r0
  int v32; // r6
  int v33; // r0
  _DWORD *v34; // r0
  int v35; // r6
  int v36; // r0
  _DWORD *v37; // r0
  int v38; // r6
  int v39; // r0
  _DWORD *v40; // r0
  int v41; // r6
  int v42; // r0
  _DWORD *v43; // r0
  int v44; // r8
  int v45; // r0
  _DWORD *v46; // r0
  _DWORD *v47; // r8
  const char *v48; // r2
  _DWORD *v49; // r0
  int v50; // r8
  int v51; // r0
  _DWORD *v52; // r0
  int v53; // r8
  int v54; // r0
  size_t v55; // r0
  int v56; // r6
  void *v57; // r0
  _DWORD *v58; // r0
  int v59; // r6
  int v60; // r0
  _DWORD *v61; // r0
  int v62; // r6
  int v63; // r0
  _DWORD *v64; // r0
  int v65; // r6
  int v66; // r0
  _DWORD *v67; // r0
  int v68; // r6
  int v69; // r0
  int v70; // r3
  _DWORD *v71; // r0
  _DWORD *v72; // r0
  _DWORD *v73; // r11
  _DWORD *v74; // r0
  int v75; // r7
  int v76; // r0
  int v77; // r0
  int v78; // r9
  _DWORD *v79; // r9
  _DWORD *v80; // r0
  _DWORD *v81; // r7
  _DWORD *v82; // r0
  const char *v83; // r6
  int v84; // r3
  _DWORD *v85; // r0
  int v86; // r6
  int v87; // r0
  _DWORD *v88; // r0
  _DWORD *v89; // r6
  _DWORD *v90; // r0
  int v91; // r7
  char **v92; // r8
  const char *v93; // r0
  const char *v94; // r1
  const char *v95; // r10
  const char *v96; // t1
  int v97; // r6
  _DWORD *v98; // r0
  _DWORD *v99; // r8
  _DWORD *v100; // r0
  const char **v101; // r7
  const char *v102; // r0
  const char *v103; // r1
  const char *v104; // r8
  const char *v105; // t1
  int v106; // r0
  int v107; // r2
  int v108; // r0
  int v109; // r2
  _DWORD *v110; // r0
  _DWORD *v111; // r0
  int v112; // r8
  _DWORD *v113; // r0
  _DWORD *v114; // r0
  int v115; // r9
  char **v116; // r6
  int v117; // r4
  const char *v118; // r7
  const char *v119; // r1
  const char *v120; // t1
  int v121; // r2
  _DWORD *v122; // r0
  int v123; // r6
  int v124; // r0
  int v125; // r4
  int v126; // r5
  int v127; // r0
  int v128; // r3
  const void *v129; // r6
  int v130; // r4
  int v131; // r5
  void *v132; // r0
  unsigned int *v133; // r3
  unsigned int v134; // r2
  unsigned int v135; // r2
  int v136; // r0
  int v137; // r3
  _DWORD *v138; // r0
  _DWORD *v139; // r0
  _DWORD *v140; // r11
  _DWORD *v141; // r0
  int v142; // r7
  int v143; // r0
  int v144; // r0
  int v145; // r10
  _DWORD *v146; // r10
  _DWORD *v147; // r0
  _DWORD *v148; // r7
  _DWORD *v149; // r0
  const char *v150; // r6
  int v151; // r3
  _DWORD *v152; // r0
  int v153; // r6
  int v154; // r0
  _DWORD *v155; // r0
  _DWORD *v156; // r6
  _DWORD *v157; // r0
  int v158; // r7
  char **v159; // r8
  const char *v160; // r0
  const char *v161; // r1
  const char *v162; // r9
  const char *v163; // t1
  int v164; // r6
  _DWORD *v165; // r0
  _DWORD *v166; // r8
  _DWORD *v167; // r0
  const char **v168; // r7
  const char *v169; // r0
  const char *v170; // r1
  const char *v171; // r8
  const char *v172; // t1
  int v173; // r0
  int v174; // r0
  int v175; // r0
  size_t n; // [sp+10h] [bp-1124h]
  size_t na; // [sp+10h] [bp-1124h]
  _DWORD *v178; // [sp+14h] [bp-1120h]
  int v179; // [sp+14h] [bp-1120h]
  unsigned int v180; // [sp+18h] [bp-111Ch]
  _DWORD *v181; // [sp+18h] [bp-111Ch]
  unsigned int i; // [sp+18h] [bp-111Ch]
  _DWORD *v183; // [sp+1Ch] [bp-1118h]
  _DWORD *v184; // [sp+1Ch] [bp-1118h]
  double *v185; // [sp+1Ch] [bp-1118h]
  double *v186; // [sp+20h] [bp-1114h]
  _DWORD *v187; // [sp+20h] [bp-1114h]
  char v188[252]; // [sp+34h] [bp-1100h] BYREF
  char v189[4100]; // [sp+130h] [bp-1004h] BYREF

  file = json_load_file("/etc/topol.conf", 0, v188);
  v1 = file;
  if ( !file || *(_DWORD *)file )
  {
    V_LOCK();
    na = -1;
    logfmt_raw(v189, 0x1000u, 0, "load topol config file %s failed\n", "/etc/topol.conf");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/topol/topol.c",
      149,
      "platform_topol_init",
      19,
      1487,
      20,
      v189);
    return na;
  }
  v2 = (_DWORD *)json_object_get(file, "machine");
  v3 = v2;
  if ( !v2 || *v2 != 2 )
  {
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "get machine failed\n");
    V_UNLOCK();
    v24 = g_zc;
    v25 = 138;
LABEL_26:
    zlog(
      v24,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/topol/topol.c",
      149,
      "_parse_machine",
      14,
      v25,
      100,
      v189);
LABEL_27:
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "parse machine failed\n");
    V_UNLOCK();
    v18 = g_zc;
    v19 = 1494;
    goto LABEL_16;
  }
  V_LOCK();
  v4 = json_string_value(v3);
  logfmt_raw(v189, 0x1000u, 0, "load machine %s conf\n", v4);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/topol/topol.c",
    149,
    "_parse_machine",
    14,
    141,
    20,
    v189);
  v5 = (const char *)json_string_value(v3);
  n = strlen(v5) + 1;
  v6 = calloc(n, 1u);
  dword_119754 = (int)v6;
  if ( !v6 )
  {
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "get machine failed, Cannot allocate space\n");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/topol/topol.c",
      149,
      "_parse_machine",
      14,
      147,
      100,
      v189);
    goto LABEL_27;
  }
  memcpy(v6, v5, n);
  V_LOCK();
  logfmt_raw(v189, 0x1000u, 0, "machine : %s \n", dword_119754);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/topol/topol.c",
    149,
    "_parse_machine",
    14,
    152,
    20,
    v189);
  v7 = (_DWORD *)json_object_get(v1, "hw_version");
  v8 = v7;
  if ( !v7 || *v7 != 2 )
  {
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "get hw_version failed\n");
    V_UNLOCK();
    v24 = g_zc;
    v25 = 157;
    goto LABEL_26;
  }
  V_LOCK();
  v9 = json_string_value(v8);
  logfmt_raw(v189, 0x1000u, 0, "hw_version: %s\n", v9);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/topol/topol.c",
    149,
    "_parse_machine",
    14,
    160,
    20,
    v189);
  v10 = (_DWORD *)json_object_get(v1, "sw_version");
  v11 = v10;
  if ( !v10 || *v10 != 2 )
  {
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "get sw_version failed\n");
    V_UNLOCK();
    v24 = g_zc;
    v25 = 165;
    goto LABEL_26;
  }
  V_LOCK();
  v12 = json_string_value(v11);
  logfmt_raw(v189, 0x1000u, 0, "sw_version: %s\n", v12);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/topol/topol.c",
    149,
    "_parse_machine",
    14,
    168,
    20,
    v189);
  v13 = (_DWORD *)json_object_get(v1, "processor");
  v14 = v13;
  if ( !v13 || *v13 )
  {
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "get processor failed\n");
    V_UNLOCK();
    v106 = g_zc;
    v107 = 180;
LABEL_94:
    zlog(
      v106,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/topol/topol.c",
      149,
      "_parse_processor",
      16,
      v107,
      100,
      v189);
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "parse processor failed\n");
    V_UNLOCK();
    v18 = g_zc;
    v19 = 1501;
    goto LABEL_16;
  }
  V_LOCK();
  logfmt_raw(v189, 0x1000u, 0, "processor:\n");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/topol/topol.c",
    149,
    "_parse_processor",
    16,
    183,
    20,
    v189);
  v15 = (_DWORD *)json_object_get(v14, "type");
  v16 = v15;
  if ( !v15 || *v15 != 2 )
  {
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "get type failed\n");
    V_UNLOCK();
    v106 = g_zc;
    v107 = 188;
    goto LABEL_94;
  }
  V_LOCK();
  v17 = json_string_value(v16);
  logfmt_raw(v189, 0x1000u, 0, "type: %s\n", v17);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/topol/topol.c",
    149,
    "_parse_processor",
    16,
    191,
    20,
    v189);
  if ( sub_45E48(v1) )
  {
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "parse power failed\n");
    V_UNLOCK();
    v18 = g_zc;
    v19 = 1508;
    goto LABEL_16;
  }
  if ( sub_46544(v1) )
  {
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "parse fan failed\n");
    V_UNLOCK();
    v18 = g_zc;
    v19 = 1515;
    goto LABEL_16;
  }
  v26 = (_DWORD *)json_object_get(v1, "chain");
  v178 = v26;
  if ( !v26 || *v26 )
  {
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "get chain failed\n");
    V_UNLOCK();
    v108 = g_zc;
    v109 = 907;
    goto LABEL_96;
  }
  V_LOCK();
  logfmt_raw(v189, 0x1000u, 0, "chain:\n");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/topol/topol.c",
    149,
    "_parse_chain",
    12,
    910,
    20,
    v189);
  v27 = (_DWORD *)json_object_get(v178, "chain_num");
  v28 = (int)v27;
  if ( !v27 || *v27 != 3 )
  {
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "get chain_num failed\n");
    V_UNLOCK();
    v108 = g_zc;
    v109 = 915;
    goto LABEL_96;
  }
  V_LOCK();
  v29 = json_integer_value(v28);
  logfmt_raw(v189, 0x1000u, 0, "chain_num : %d\n", v29);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/topol/topol.c",
    149,
    "_parse_chain",
    12,
    918,
    20,
    v189);
  v30 = json_integer_value(v28);
  dword_119758 = v30;
  V_LOCK();
  logfmt_raw(v189, 0x1000u, 0, "chain_num %d\n", v30);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/topol/topol.c",
    149,
    "_alloc_chain",
    12,
    80,
    20,
    v189);
  dword_119778 = (int)calloc(v30, 0x78u);
  if ( !dword_119778 )
  {
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "malloc %d chain_t failed\n", v30);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/topol/topol.c",
      149,
      "_alloc_chain",
      12,
      85,
      100,
      v189);
    goto LABEL_97;
  }
  v31 = (_DWORD *)json_object_get(v178, "chain_row");
  v32 = (int)v31;
  if ( !v31 || *v31 != 3 )
  {
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "get chain_row failed\n");
    V_UNLOCK();
    v108 = g_zc;
    v109 = 926;
LABEL_96:
    zlog(
      v108,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/topol/topol.c",
      149,
      "_parse_chain",
      12,
      v109,
      100,
      v189);
LABEL_97:
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "parse chain failed\n");
    V_UNLOCK();
    v18 = g_zc;
    v19 = 1523;
LABEL_16:
    zlog(
      v18,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/topol/topol.c",
      149,
      "platform_topol_init",
      19,
      v19,
      20,
      v189);
    if ( *((_DWORD *)v1 + 1) != -1 )
    {
      v20 = (unsigned int *)v1 + 1;
      __dmb(0xBu);
      do
      {
        v21 = __ldrex(v20);
        v22 = v21 - 1;
      }
      while ( __strex(v22, v20) );
      if ( !v22 )
        json_delete(v1);
    }
    return 34;
  }
  V_LOCK();
  v33 = json_integer_value(v32);
  logfmt_raw(v189, 0x1000u, 0, "chain_row: %d\n", v33);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/topol/topol.c",
    149,
    "_parse_chain",
    12,
    929,
    20,
    v189);
  dword_11975C = json_integer_value(v32);
  v34 = (_DWORD *)json_object_get(v178, "chain_column");
  v35 = (int)v34;
  if ( !v34 || *v34 != 3 )
  {
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "get chain_column failed\n");
    V_UNLOCK();
    v108 = g_zc;
    v109 = 935;
    goto LABEL_96;
  }
  V_LOCK();
  v36 = json_integer_value(v35);
  logfmt_raw(v189, 0x1000u, 0, "chain_column: %d\n", v36);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/topol/topol.c",
    149,
    "_parse_chain",
    12,
    938,
    20,
    v189);
  dword_119760 = json_integer_value(v35);
  v37 = (_DWORD *)json_object_get(v178, "chain_domain_num");
  v38 = (int)v37;
  if ( !v37 || *v37 != 3 )
  {
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "get chain_domain_num failed\n");
    V_UNLOCK();
    v108 = g_zc;
    v109 = 944;
    goto LABEL_96;
  }
  V_LOCK();
  v39 = json_integer_value(v38);
  logfmt_raw(v189, 0x1000u, 0, "chain_domain_num : %d\n", v39);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/topol/topol.c",
    149,
    "_parse_chain",
    12,
    947,
    20,
    v189);
  dword_119764 = json_integer_value(v38);
  v40 = (_DWORD *)json_object_get(v178, "chain_asic_num");
  v41 = (int)v40;
  if ( !v40 || *v40 != 3 )
  {
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "get chain_asic_num failed\n");
    V_UNLOCK();
    v108 = g_zc;
    v109 = 953;
    goto LABEL_96;
  }
  V_LOCK();
  v42 = json_integer_value(v41);
  logfmt_raw(v189, 0x1000u, 0, "chain_asic_num : %d\n", v42);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/topol/topol.c",
    149,
    "_parse_chain",
    12,
    956,
    20,
    v189);
  dword_119768 = json_integer_value(v41);
  v43 = (_DWORD *)json_object_get(v178, "domain_asic_num");
  v44 = (int)v43;
  if ( !v43 || *v43 != 3 )
  {
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "get domain_asic_num failed\n");
    V_UNLOCK();
    v108 = g_zc;
    v109 = 962;
    goto LABEL_96;
  }
  V_LOCK();
  v45 = json_integer_value(v44);
  logfmt_raw(v189, 0x1000u, 0, "domain_asic_num : %d\n", v45);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/topol/topol.c",
    149,
    "_parse_chain",
    12,
    965,
    20,
    v189);
  dword_11976C = json_integer_value(v44);
  v46 = (_DWORD *)json_object_get(v178, "pic_mcu_en");
  v47 = v46;
  if ( !v46 || (unsigned int)(*v46 - 5) > 1 )
  {
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "get pic_mcu_en failed!\n");
    V_UNLOCK();
    v136 = 971;
LABEL_132:
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/topol/topol.c",
      149,
      "_parse_chain",
      12,
      v136,
      100,
      v189);
    goto LABEL_97;
  }
  V_LOCK();
  v48 = "false";
  if ( *v47 == 5 )
    v48 = "true";
  logfmt_raw(v189, 0x1000u, 0, "pic_mcu_en: %s\n", v48);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/topol/topol.c",
    149,
    "_parse_chain",
    12,
    974,
    20,
    v189);
  byte_119770 = *v47 == 5;
  v49 = (_DWORD *)json_object_get(v178, "sensor_mode");
  v50 = (int)v49;
  if ( !v49 || *v49 != 3 )
  {
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "get sensor_mode failed\n");
    V_UNLOCK();
    v136 = 980;
    goto LABEL_132;
  }
  V_LOCK();
  v51 = json_integer_value(v50);
  logfmt_raw(v189, 0x1000u, 0, "sensor mode : %d\n", v51);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/topol/topol.c",
    149,
    "_parse_chain",
    12,
    983,
    20,
    v189);
  *(_DWORD *)(dword_119778 + 88) = json_integer_value(v50);
  v52 = (_DWORD *)json_object_get(v178, "sensor_num");
  v53 = (int)v52;
  if ( !v52 || *v52 != 3 )
  {
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "get sensor num failed\n");
    V_UNLOCK();
    v136 = 989;
    goto LABEL_132;
  }
  V_LOCK();
  v54 = json_integer_value(v53);
  logfmt_raw(v189, 0x1000u, 0, "sensor num : %d\n", v54);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/topol/topol.c",
    149,
    "_parse_chain",
    12,
    992,
    20,
    v189);
  v55 = json_integer_value(v53);
  v56 = dword_119778;
  *(_DWORD *)(dword_119778 + 92) = v55;
  v57 = calloc(v55, 0x18u);
  *(_DWORD *)(v56 + 84) = v57;
  if ( !v57 )
  {
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "calloc sensor failed!\n");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/topol/topol.c",
      149,
      "_alloc_sensor",
      13,
      96,
      100,
      v189);
    goto LABEL_97;
  }
  v58 = (_DWORD *)json_object_get(v178, "max_chip_temp");
  v59 = (int)v58;
  if ( !v58 || *v58 != 3 )
  {
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "get max_chip_temp failed\n");
    V_UNLOCK();
    v136 = 1000;
    goto LABEL_132;
  }
  V_LOCK();
  v60 = json_integer_value(v59);
  logfmt_raw(v189, 0x1000u, 0, "max_chip_temp : %d\n", v60);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/topol/topol.c",
    149,
    "_parse_chain",
    12,
    1003,
    20,
    v189);
  *(_DWORD *)(dword_119778 + 96) = json_integer_value(v59);
  v61 = (_DWORD *)json_object_get(v178, "max_pcb_temp");
  v62 = (int)v61;
  if ( !v61 || *v61 != 3 )
  {
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "get max_pcb_temp failed\n");
    V_UNLOCK();
    v136 = 1009;
    goto LABEL_132;
  }
  V_LOCK();
  v63 = json_integer_value(v62);
  logfmt_raw(v189, 0x1000u, 0, "max_pcb_temp : %d\n", v63);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/topol/topol.c",
    149,
    "_parse_chain",
    12,
    1012,
    20,
    v189);
  *(_DWORD *)(dword_119778 + 100) = json_integer_value(v62);
  v64 = (_DWORD *)json_object_get(v178, "min_pcb_temp");
  v65 = (int)v64;
  if ( !v64 || *v64 != 3 )
  {
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "get min_pcb_temp failed\n");
    V_UNLOCK();
    v136 = 1018;
    goto LABEL_132;
  }
  V_LOCK();
  v66 = json_integer_value(v65);
  logfmt_raw(v189, 0x1000u, 0, "min_pcb_temp : %d\n", v66);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/topol/topol.c",
    149,
    "_parse_chain",
    12,
    1021,
    20,
    v189);
  *(_DWORD *)(dword_119778 + 104) = json_integer_value(v65);
  v67 = (_DWORD *)json_object_get(v178, "max_uneffective_count");
  v68 = (int)v67;
  if ( !v67 || *v67 != 3 )
  {
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "get max_uneffective_count failed\n");
    V_UNLOCK();
    v136 = 1027;
    goto LABEL_132;
  }
  V_LOCK();
  v69 = json_integer_value(v68);
  logfmt_raw(v189, 0x1000u, 0, "max_uneffective_count : %d\n", v69);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/topol/topol.c",
    149,
    "_parse_chain",
    12,
    1030,
    20,
    v189);
  *(_DWORD *)(dword_119778 + 108) = json_integer_value(v68);
  na = sub_473E4(v178);
  if ( na )
  {
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "parse asic failed\n");
    V_UNLOCK();
    v137 = 1036;
    goto LABEL_137;
  }
  if ( byte_119770 && sub_47BB4(v178) )
  {
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "parse chain pic failed\n");
    V_UNLOCK();
    v137 = 1044;
LABEL_137:
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/topol/topol.c",
      149,
      "_parse_chain",
      12,
      v137,
      100,
      v189);
    goto LABEL_97;
  }
  v70 = *(_DWORD *)(dword_119778 + 88);
  if ( v70 == 3 )
  {
    v138 = (_DWORD *)json_object_get(v178, "ctrlboard_sensor");
    v187 = v138;
    if ( !v138 || *v138 != 1 )
    {
      V_LOCK();
      logfmt_raw(v189, 0x1000u, 0, "get ctrlboard_sensor sensor failed\n");
      V_UNLOCK();
      v175 = 639;
LABEL_181:
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/topol/topol.c",
        149,
        "_parse_chain_ctrlboard_sensor",
        29,
        v175,
        100,
        v189);
      V_LOCK();
      logfmt_raw(v189, 0x1000u, 0, "parse chain ctrlboard failed\n");
      V_UNLOCK();
      v136 = 1053;
      goto LABEL_132;
    }
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "ctrlboard_sensor:\n");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/topol/topol.c",
      149,
      "_parse_chain_ctrlboard_sensor",
      29,
      642,
      20,
      v189);
    v185 = v1;
    for ( i = 0; i < (unsigned int)json_array_size(v187); ++i )
    {
      v139 = json_array_get(v187, i);
      v140 = v139;
      if ( !v139 || *v139 )
      {
        v1 = v185;
        V_LOCK();
        logfmt_raw(v189, 0x1000u, 0, "get array %d failed\n", i);
        V_UNLOCK();
        v175 = 649;
        goto LABEL_181;
      }
      v141 = (_DWORD *)json_object_get(v139, "index");
      v142 = (int)v141;
      if ( !v141 || *v141 != 3 )
      {
        v1 = v185;
        V_LOCK();
        logfmt_raw(v189, 0x1000u, 0, "get array %d index failed\n", i);
        V_UNLOCK();
        v175 = 656;
        goto LABEL_181;
      }
      V_LOCK();
      v143 = json_integer_value(v142);
      logfmt_raw(v189, 0x1000u, 0, "index: %d\n", v143);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/topol/topol.c",
        149,
        "_parse_chain_ctrlboard_sensor",
        29,
        659,
        20,
        v189);
      v144 = json_integer_value(v142);
      v145 = *(_DWORD *)(dword_119778 + 84);
      *(_DWORD *)(v145 + 24 * v144) = v144;
      v146 = (_DWORD *)(v145 + 24 * v144);
      v146[2] = 2;
      v147 = (_DWORD *)json_object_get(v140, "type");
      v148 = v147;
      if ( !v147 || *v147 != 2 )
      {
        v1 = v185;
        V_LOCK();
        logfmt_raw(v189, 0x1000u, 0, "get array %d type failed\n", i);
        V_UNLOCK();
        v175 = 668;
        goto LABEL_181;
      }
      V_LOCK();
      v149 = json_string_value(v148);
      logfmt_raw(v189, 0x1000u, 0, "type: %s\n", v149);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/topol/topol.c",
        149,
        "_parse_chain_ctrlboard_sensor",
        29,
        671,
        20,
        v189);
      v150 = (const char *)json_string_value(v148);
      v151 = strcmp(v150, "TMP451");
      if ( v151 )
      {
        if ( !strcmp(v150, "LM75A") )
          v151 = 1;
        else
          v151 = 2;
      }
      v146[1] = v151;
      v152 = (_DWORD *)json_object_get(v140, "iic");
      v153 = (int)v152;
      if ( !v152 || *v152 != 3 )
      {
        v1 = v185;
        V_LOCK();
        logfmt_raw(v189, 0x1000u, 0, "get array %d bind_asic failed\n", i);
        V_UNLOCK();
        v175 = 677;
        goto LABEL_181;
      }
      V_LOCK();
      v154 = json_integer_value(v153);
      logfmt_raw(v189, 0x1000u, 0, "iic: %d\n", v154);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/topol/topol.c",
        149,
        "_parse_chain_ctrlboard_sensor",
        29,
        680,
        20,
        v189);
      v146[5] = json_integer_value(v153);
      v155 = (_DWORD *)json_object_get(v140, "x");
      v156 = v155;
      if ( !v155 || *v155 != 2 )
      {
        v1 = v185;
        V_LOCK();
        logfmt_raw(v189, 0x1000u, 0, "get array %d x failed\n", i);
        V_UNLOCK();
        v175 = 686;
        goto LABEL_181;
      }
      V_LOCK();
      v157 = json_string_value(v156);
      logfmt_raw(v189, 0x1000u, 0, "x: %s\n", v157);
      V_UNLOCK();
      v158 = 0;
      v159 = off_E4E38;
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/topol/topol.c",
        149,
        "_parse_chain_ctrlboard_sensor",
        29,
        689,
        20,
        v189);
      v160 = (const char *)json_string_value(v156);
      v161 = "air_in";
      v162 = v160;
      while ( strcmp(v162, v161) )
      {
        v163 = *v159++;
        v161 = v163;
        ++v158;
      }
      v164 = 0;
      v146[3] = v158;
      v165 = (_DWORD *)json_object_get(v140, "y");
      v166 = v165;
      if ( !v165 || *v165 != 2 )
      {
        v1 = v185;
        V_LOCK();
        logfmt_raw(v189, 0x1000u, 0, "get array %d y failed\n", i);
        V_UNLOCK();
        v175 = 695;
        goto LABEL_181;
      }
      V_LOCK();
      v167 = json_string_value(v166);
      logfmt_raw(v189, 0x1000u, 0, "y: %s\n", v167);
      V_UNLOCK();
      v168 = (const char **)&unk_E4E58;
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/topol/topol.c",
        149,
        "_parse_chain_ctrlboard_sensor",
        29,
        698,
        20,
        v189);
      v169 = (const char *)json_string_value(v166);
      v170 = "top";
      v171 = v169;
      while ( strcmp(v171, v170) )
      {
        v172 = *v168++;
        v170 = v172;
        ++v164;
      }
      v146[4] = v164;
    }
    v1 = v185;
    v70 = *(_DWORD *)(dword_119778 + 88);
  }
  if ( (v70 & 0xFFFFFFFD) == 0 )
  {
    v71 = (_DWORD *)json_object_get(v178, "asic_sensor");
    v183 = v71;
    if ( v71 && *v71 == 1 )
    {
      V_LOCK();
      v180 = 0;
      logfmt_raw(v189, 0x1000u, 0, "asic_sensor:\n");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/topol/topol.c",
        149,
        "_parse_chain_sensor",
        19,
        801,
        20,
        v189);
      v186 = v1;
      while ( 1 )
      {
        if ( v180 >= (unsigned int)json_array_size(v183) )
        {
          v1 = v186;
          goto LABEL_103;
        }
        v72 = json_array_get(v183, v180);
        v73 = v72;
        if ( !v72 || *v72 )
          break;
        v74 = (_DWORD *)json_object_get(v72, "index");
        v75 = (int)v74;
        if ( !v74 || *v74 != 3 )
        {
          v1 = v186;
          V_LOCK();
          logfmt_raw(v189, 0x1000u, 0, "get array %d index failed\n", v180);
          V_UNLOCK();
          v173 = 816;
          goto LABEL_168;
        }
        V_LOCK();
        v76 = json_integer_value(v75);
        logfmt_raw(v189, 0x1000u, 0, "index: %d\n", v76);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/topol/topol.c",
          149,
          "_parse_chain_sensor",
          19,
          819,
          20,
          v189);
        v77 = json_integer_value(v75);
        v78 = *(_DWORD *)(dword_119778 + 84);
        *(_DWORD *)(v78 + 24 * v77) = v77;
        v79 = (_DWORD *)(v78 + 24 * v77);
        v79[2] = 1;
        v80 = (_DWORD *)json_object_get(v73, "type");
        v81 = v80;
        if ( !v80 || *v80 != 2 )
        {
          v1 = v186;
          V_LOCK();
          logfmt_raw(v189, 0x1000u, 0, "get array %d type failed\n", v180);
          V_UNLOCK();
          v173 = 828;
          goto LABEL_168;
        }
        V_LOCK();
        v82 = json_string_value(v81);
        logfmt_raw(v189, 0x1000u, 0, "type: %s\n", v82);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/topol/topol.c",
          149,
          "_parse_chain_sensor",
          19,
          831,
          20,
          v189);
        v83 = (const char *)json_string_value(v81);
        v84 = strcmp(v83, "TMP451");
        if ( v84 )
        {
          if ( !strcmp(v83, "LM75A") )
            v84 = 1;
          else
            v84 = 2;
        }
        v79[1] = v84;
        v85 = (_DWORD *)json_object_get(v73, "bind_asic");
        v86 = (int)v85;
        if ( !v85 || *v85 != 3 )
        {
          v1 = v186;
          V_LOCK();
          logfmt_raw(v189, 0x1000u, 0, "get array %d bind_asic failed\n", v180);
          V_UNLOCK();
          v173 = 837;
          goto LABEL_168;
        }
        V_LOCK();
        v87 = json_integer_value(v86);
        logfmt_raw(v189, 0x1000u, 0, "bind_asic: %d\n", v87);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/topol/topol.c",
          149,
          "_parse_chain_sensor",
          19,
          840,
          20,
          v189);
        v79[5] = json_integer_value(v86);
        v88 = (_DWORD *)json_object_get(v73, "x");
        v89 = v88;
        if ( !v88 || *v88 != 2 )
        {
          v1 = v186;
          V_LOCK();
          logfmt_raw(v189, 0x1000u, 0, "get array %d x failed\n", v180);
          V_UNLOCK();
          v173 = 846;
          goto LABEL_168;
        }
        V_LOCK();
        v90 = json_string_value(v89);
        logfmt_raw(v189, 0x1000u, 0, "x: %s\n", v90);
        V_UNLOCK();
        v91 = 0;
        v92 = off_E4E38;
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/topol/topol.c",
          149,
          "_parse_chain_sensor",
          19,
          849,
          20,
          v189);
        v93 = (const char *)json_string_value(v89);
        v94 = "air_in";
        v95 = v93;
        while ( strcmp(v95, v94) )
        {
          v96 = *v92++;
          v94 = v96;
          ++v91;
        }
        v97 = 0;
        v79[3] = v91;
        v98 = (_DWORD *)json_object_get(v73, "y");
        v99 = v98;
        if ( !v98 || *v98 != 2 )
        {
          v1 = v186;
          V_LOCK();
          logfmt_raw(v189, 0x1000u, 0, "get array %d y failed\n", v180);
          V_UNLOCK();
          v173 = 855;
          goto LABEL_168;
        }
        V_LOCK();
        v100 = json_string_value(v99);
        logfmt_raw(v189, 0x1000u, 0, "y: %s\n", v100);
        V_UNLOCK();
        v101 = (const char **)&unk_E4E58;
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/topol/topol.c",
          149,
          "_parse_chain_sensor",
          19,
          858,
          20,
          v189);
        v102 = (const char *)json_string_value(v99);
        v103 = "top";
        v104 = v102;
        while ( strcmp(v104, v103) )
        {
          v105 = *v101++;
          v103 = v105;
          ++v97;
        }
        v79[4] = v97;
        ++v180;
      }
      v1 = v186;
      V_LOCK();
      logfmt_raw(v189, 0x1000u, 0, "get array %d failed\n", v180);
      V_UNLOCK();
      v173 = 809;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v189, 0x1000u, 0, "get sensor failed\n");
      V_UNLOCK();
      v173 = 798;
    }
LABEL_168:
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/topol/topol.c",
      149,
      "_parse_chain_sensor",
      19,
      v173,
      100,
      v189);
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "parse chain sensor failed\n");
    V_UNLOCK();
    v136 = 1063;
    goto LABEL_132;
  }
LABEL_103:
  v110 = v178;
  v179 = dword_119758;
  v111 = (_DWORD *)json_object_get(v110, "eeprom");
  v181 = v111;
  if ( !v111 || (v112 = *v111) != 0 )
  {
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "get eeprom failed\n");
    V_UNLOCK();
    v174 = 759;
    goto LABEL_175;
  }
  V_LOCK();
  logfmt_raw(v189, 0x1000u, 0, "eeprom:\n");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/topol/topol.c",
    149,
    "_parse_chain_eeprom",
    19,
    762,
    20,
    v189);
  v113 = (_DWORD *)json_object_get(v181, "type");
  v184 = v113;
  if ( !v113 || *v113 != 2 )
  {
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "get type failed\n");
    V_UNLOCK();
    v174 = 767;
    goto LABEL_175;
  }
  V_LOCK();
  v114 = json_string_value(v184);
  logfmt_raw(v189, 0x1000u, 0, "type: %s\n", v114);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/topol/topol.c",
    149,
    "_parse_chain_eeprom",
    19,
    770,
    20,
    v189);
  if ( v179 > 0 )
  {
    v115 = 0;
    do
    {
      v116 = off_E4F24;
      v117 = 0;
      v118 = (const char *)json_string_value(v184);
      v119 = "AT24C02D";
      while ( strcmp(v118, v119) )
      {
        v120 = v116[1];
        ++v116;
        v119 = v120;
        ++v117;
      }
      ++v112;
      v121 = dword_119778 + v115;
      v115 += 120;
      *(_DWORD *)(v121 + 112) = v117;
    }
    while ( v179 != v112 );
  }
  v122 = (_DWORD *)json_object_get(v181, "i2c_addr");
  v123 = (int)v122;
  if ( !v122 || *v122 != 3 )
  {
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "get i2c_addr failed\n");
    V_UNLOCK();
    v174 = 779;
LABEL_175:
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/topol/topol.c",
      149,
      "_parse_chain_eeprom",
      19,
      v174,
      100,
      v189);
    V_LOCK();
    logfmt_raw(v189, 0x1000u, 0, "parse chain eeprom failed\n");
    V_UNLOCK();
    v136 = 1071;
    goto LABEL_132;
  }
  V_LOCK();
  v124 = json_integer_value(v123);
  logfmt_raw(v189, 0x1000u, 0, "i2c_addr: %d\n", v124);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/topol/topol.c",
    149,
    "_parse_chain_eeprom",
    19,
    782,
    20,
    v189);
  if ( v179 > 0 )
  {
    v125 = 0;
    v126 = 0;
    do
    {
      ++v125;
      v127 = json_integer_value(v123);
      v128 = dword_119778 + v126;
      v126 += 120;
      *(_DWORD *)(v128 + 116) = v127;
    }
    while ( v179 != v125 );
  }
  if ( dword_119758 > 1 )
  {
    v129 = (const void *)dword_119778;
    v130 = dword_119778 + 120;
    v131 = dword_119778 + 120 * dword_119758;
    do
    {
      v132 = (void *)v130;
      v130 += 120;
      memcpy(v132, v129, 0x78u);
    }
    while ( v130 != v131 );
  }
  if ( *((_DWORD *)v1 + 1) != -1 )
  {
    v133 = (unsigned int *)v1 + 1;
    __dmb(0xBu);
    do
    {
      v134 = __ldrex(v133);
      v135 = v134 - 1;
    }
    while ( __strex(v135, v133) );
    if ( !v135 )
      json_delete(v1);
  }
  return na;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// E4E38: using guessed type char *off_E4E38[2];
// E4F24: using guessed type char *off_E4F24[2];
// 119754: using guessed type int dword_119754;
// 119758: using guessed type int dword_119758;
// 11975C: using guessed type int dword_11975C;
// 119760: using guessed type int dword_119760;
// 119764: using guessed type int dword_119764;
// 119768: using guessed type int dword_119768;
// 11976C: using guessed type int dword_11976C;
// 119770: using guessed type char byte_119770;
// 119778: using guessed type int dword_119778;
// 11A7AC: using guessed type int g_zc;

//----- (0004AB90) --------------------------------------------------------
int sub_4AB90()
{
  return 0;
}

//----- (0004AB98) --------------------------------------------------------
int get_chip_status_ckb()
{
  return 0;
}

//----- (0004ABA0) --------------------------------------------------------
int __fastcall get_theory_hashrate_ckb(int a1, double *a2)
{
  float v2; // s14

  v2 = *(float *)(a1 + 900);
  *a2 = v2 * 32384.0 * 1000.0 * 1000.0;
  return 0;
}

//----- (0004ABD8) --------------------------------------------------------
int __fastcall get_qualify_nonce_num_ckb(int a1, float *a2)
{
  int v4; // r0
  char v5; // r1
  int v6; // r3
  __int64 v7; // r0
  double v8; // r0
  double v9; // d4
  float v11; // s14
  double v12; // [sp+0h] [bp-Ch] BYREF

  v12 = 0.0;
  (*(void (__fastcall **)(int, double *))(a1 + 120))(a1, &v12);
  v4 = *(_DWORD *)(a1 + 376);
  v5 = 32 - v4;
  v6 = 1 << (v4 - 32);
  LODWORD(v7) = 1 << v4;
  HIDWORD(v7) = v6 | (1u >> v5);
  LODWORD(v8) = sub_DD46C(v7);
  v9 = v8;
  v11 = v12 / v9 / 92.0 * 0.3;
  *a2 = v11;
  return 0;
}
// 4AC28: variable 'v8' is possibly undefined

//----- (0004AC68) --------------------------------------------------------
int overclock_update_ckb()
{
  return 0;
}

//----- (0004AC70) --------------------------------------------------------
unsigned int __fastcall get_packet_remain_len_ckb(int a1)
{
  unsigned int result; // r0

  result = a1 - 1;
  if ( result >= 0xA )
    return 9;
  return result;
}

//----- (0004AC80) --------------------------------------------------------
int __fastcall global_idx_init_ckb(int a1)
{
  void *v2; // r0

  v2 = calloc(0x3E08u, 1u);
  *(_DWORD *)(a1 + 760) = v2;
  printf("__custom_data init %p\n", v2);
  return 0;
}

//----- (0004ACB0) --------------------------------------------------------
int __fastcall global_idx_free_ckb(int a1)
{
  free(*(void **)(a1 + 760));
  return 0;
}

//----- (0004ACC4) --------------------------------------------------------
int __fastcall sub_4ACC4(int a1)
{
  _DWORD v3[1025]; // [sp+10h] [bp-1004h] BYREF

  V_LOCK();
  logfmt_raw((char *)v3, 0x1000u, 0, "software_reset %s %02x", "ChipSetting_software_reset_CKB_2042", 68);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_software_reset_CKB_2042",
    35,
    95,
    20,
    v3);
  v3[2] = 4456449;
  v3[3] = 0;
  v3[1] = 0;
  v3[0] = 3;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v3);
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0004AD84) --------------------------------------------------------
int __fastcall set_sensor_extern_mode_ckb(int a1)
{
  int (__fastcall *v2)(int, _DWORD *); // r3
  int v3; // r6
  int result; // r0
  _DWORD v5[2]; // [sp+0h] [bp-10h] BYREF
  int v6; // [sp+8h] [bp-8h]
  int v7; // [sp+Ch] [bp-4h]

  v5[0] = 26806532;
  v6 = 16711680;
  v5[1] = 0;
  v7 = 0;
  v2 = *(int (__fastcall **)(int, _DWORD *))(a1 + 216);
  LOBYTE(v6) = 1;
  v3 = v2(a1, v5);
  usleep((__useconds_t)"rl_kda_2110");
  result = 0;
  if ( !v3 )
    *(_DWORD *)(a1 + 456) = 1;
  return result;
}

//----- (0004ADEC) --------------------------------------------------------
int __fastcall sub_4ADEC(int *a1, int a2)
{
  int v4; // r2
  int (__fastcall *v5)(int *, _DWORD *); // r3
  int v6; // r4
  int v8; // [sp+2Ch] [bp-1038h]
  _DWORD v9[2]; // [sp+30h] [bp-1034h] BYREF
  int v10; // [sp+38h] [bp-102Ch]
  int v11; // [sp+3Ch] [bp-1028h]
  _DWORD v12[7]; // [sp+40h] [bp-1024h] BYREF
  int v13; // [sp+5Ch] [bp-1008h]
  char v14[4100]; // [sp+60h] [bp-1004h] BYREF

  v9[1] = 0;
  v10 = 0;
  v11 = 0;
  v9[0] = 0;
  V_LOCK();
  V_INT((int)v12, "chain", a1[50]);
  logfmt_raw(
    v14,
    0x1000u,
    0,
    v13,
    v12[0],
    v12[1],
    v12[2],
    v12[3],
    v12[4],
    v12[5],
    v12[6],
    v13,
    "set core ticket mask reg %02x tm %02x",
    3,
    a2,
    v8,
    0,
    0,
    0,
    0);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_core_ticket_mask_CKB_2042",
    37,
    141,
    40,
    v14);
  v4 = a1[71];
  LOBYTE(v11) = -1;
  BYTE1(v11) = v4;
  v10 = 196609;
  BYTE2(v11) = 1;
  v5 = (int (__fastcall *)(int *, _DWORD *))a1[55];
  v9[0] = a2;
  v6 = v5(a1, v9);
  usleep(0x3E8u);
  a1[94] = a2;
  return v6;
}
// 4AE74: variable 'v8' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0004AF14) --------------------------------------------------------
int __fastcall work_2_packet_ckb(int a1, int a2, _BYTE *a3, _DWORD *a4)
{
  int v6; // r4
  int v7; // r5
  int v9; // r0
  int v10; // r12
  _DWORD *v11; // r2
  int v12; // r7
  int v13; // lr
  int v14; // r12
  int v15; // r7
  int v16; // lr
  int v17; // r12
  int *v18; // r2
  int v19; // r4
  int v20; // lr
  int v21; // r12
  int v22; // r1
  int v23; // r3
  char v24; // r2
  _BYTE *v25; // r1
  char *v26; // r3
  int v27; // r12
  int v28; // r0
  int v29; // r2
  int v30; // r4
  char *v31; // r3
  _DWORD *v32; // r2
  int v33; // r12
  int v34; // r0
  int v35; // r1
  __int16 v36; // r0
  int v37; // r3
  int v39; // r5
  int v40; // r6
  int v41; // t1
  char *s2; // [sp+10h] [bp-201Ch]
  char *v43; // [sp+18h] [bp-2014h]
  int v45; // [sp+20h] [bp-200Ch]
  int v46; // [sp+24h] [bp-2008h]
  char v47[4056]; // [sp+28h] [bp-2004h] BYREF
  _DWORD v48[1025]; // [sp+1028h] [bp-1004h] BYREF

  v6 = *(_DWORD *)(a1 + 760);
  *a3 = 85;
  a3[2] = 32;
  a3[1] = -86;
  v7 = v6 + 12288;
  v45 = a2 + 8;
  if ( *(_DWORD *)(a1 + 436) == 1 )
    a3[2] = 48;
  v9 = *(unsigned __int8 *)(v6 + 15872);
  v10 = *(_DWORD *)(a2 + 88);
  *(_QWORD *)(v6 + 8 * v9) = *(_QWORD *)a2;
  *(_DWORD *)(v6 + 4 * (v9 + 2816)) = v10;
  v11 = (_DWORD *)(v6 + 32 * (v9 + 368));
  v12 = *(_DWORD *)(a2 + 96);
  v13 = *(_DWORD *)(a2 + 100);
  v14 = *(_DWORD *)(a2 + 104);
  *v11 = *(_DWORD *)(a2 + 92);
  v11[1] = v12;
  v11[2] = v13;
  v11[3] = v14;
  v15 = *(_DWORD *)(a2 + 112);
  v16 = *(_DWORD *)(a2 + 116);
  v17 = *(_DWORD *)(a2 + 120);
  v11[4] = *(_DWORD *)(a2 + 108);
  v11[5] = v15;
  v11[6] = v16;
  v11[7] = v17;
  s2 = (char *)(a2 + 40);
  strcpy((char *)(v6 + 32 * (*(unsigned __int8 *)(v6 + 15872) + 32)), (const char *)(a2 + 8));
  v18 = (int *)(a2 + 40);
  v19 = v6 + 48 * *(unsigned __int8 *)(v6 + 15872) + 5120;
  do
  {
    v20 = *v18;
    v18 += 4;
    v21 = *(v18 - 3);
    v19 += 16;
    v22 = *(v18 - 2);
    v23 = *(v18 - 1);
    *(_DWORD *)(v19 - 16) = v20;
    *(_DWORD *)(v19 - 12) = v21;
    *(_DWORD *)(v19 - 8) = v22;
    *(_DWORD *)(v19 - 4) = v23;
  }
  while ( v18 != (int *)(a2 + 88) );
  v24 = *(_BYTE *)(v7 + 3584);
  v25 = a3 + 4;
  a3[3] = v24;
  v26 = s2;
  *(_BYTE *)(v7 + 3584) = (v24 + 1) & 0x7F;
  v43 = s2 + 48;
  do
  {
    v26 += 16;
    v25 += 16;
    v27 = *((_DWORD *)v26 - 3);
    v28 = *((_DWORD *)v26 - 2);
    v29 = *((_DWORD *)v26 - 1);
    *((_DWORD *)v25 - 4) = *((_DWORD *)v26 - 4);
    *((_DWORD *)v25 - 3) = v27;
    *((_DWORD *)v25 - 2) = v28;
    *((_DWORD *)v25 - 1) = v29;
  }
  while ( v26 != v43 );
  v30 = memcmp(&last_header_ckb, s2, 0x30u);
  if ( !v30 )
  {
    V_LOCK();
    logfmt_raw((char *)v48, 0x1000u, 0, "found repeat work");
    V_UNLOCK();
    v39 = a2 + 39;
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/backend_ckb_2042/backend_ckb_2042.c",
      171,
      "work_2_packet_ckb",
      17,
      118,
      80,
      v48);
    v40 = a2 + 87;
    v46 = (unsigned __int8)a3[3];
    do
    {
      v41 = *(unsigned __int8 *)++v39;
      snprintf(&v47[v30], 4096 - v30, "%02x ", v41);
      v30 += 3;
    }
    while ( v39 != v40 );
    V_LOCK();
    logfmt_raw((char *)v48, 0x1000u, 0, "ckb dump work jobid %s, work count %d", v45, v46);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/backend_ckb_2042/backend_ckb_2042.c",
      171,
      "dump_work_ckb",
      13,
      85,
      20,
      v48);
    V_LOCK();
    logfmt_raw((char *)v48, 0x1000u, 0, "dump work: %s", v47);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/backend_ckb_2042/backend_ckb_2042.c",
      171,
      "dump_work_ckb",
      13,
      86,
      20,
      v48);
  }
  v31 = s2;
  v32 = &last_header_ckb;
  do
  {
    v31 += 16;
    v32 += 4;
    v33 = *((_DWORD *)v31 - 3);
    v34 = *((_DWORD *)v31 - 2);
    v35 = *((_DWORD *)v31 - 1);
    *(v32 - 4) = *((_DWORD *)v31 - 4);
    *(v32 - 3) = v33;
    *(v32 - 2) = v34;
    *(v32 - 1) = v35;
  }
  while ( v31 != v43 );
  v36 = BM_CRC16(a3 + 2, 50);
  a3[53] = v36;
  a3[52] = HIBYTE(v36);
  v37 = *(unsigned __int8 *)(a1 + 205);
  *a4 = 54;
  if ( v37 && *(_BYTE *)(a1 + 206) )
  {
    memset(*(void **)(a1 + 400), 0, 48 * *(_DWORD *)(a1 + 280));
    sub_4ADEC((int *)a1, 39);
    *(_BYTE *)(a1 + 205) = 0;
  }
  V_LOCK();
  logfmt_raw((char *)v48, 0x1000u, 0, "bridge reset %s %02x", "ChipSetting_bridge_reset_CKB_2042", 68);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_bridge_reset_CKB_2042",
    33,
    82,
    20,
    v48);
  v48[1] = 0;
  v48[2] = 4456449;
  v48[3] = 0;
  v48[0] = 2;
  (*(void (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v48);
  usleep(0x64u);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0004B398) --------------------------------------------------------
int __fastcall sub_4B398(int a1, int a2)
{
  float v2; // s0
  __int16 v3; // r3
  int v4; // r12
  signed int v5; // r6
  float v6; // s19
  int v7; // r10
  int v8; // r11
  int v9; // r8
  int v10; // r5
  int v11; // r2
  int v12; // r4
  float v13; // s17
  int v14; // r0
  int v15; // r0
  float v16; // s16
  int v17; // r2
  signed int v19; // r7
  int v20; // r6
  unsigned int v22; // [sp+38h] [bp-104Ch]
  int v25; // [sp+4Ch] [bp-1038h]
  _DWORD v26[2]; // [sp+50h] [bp-1034h] BYREF
  int v27; // [sp+58h] [bp-102Ch]
  int v28; // [sp+5Ch] [bp-1028h]
  int v29; // [sp+60h] [bp-1024h] BYREF
  int v30; // [sp+64h] [bp-1020h]
  int v31; // [sp+68h] [bp-101Ch]
  int v32; // [sp+6Ch] [bp-1018h]
  __int64 v33; // [sp+70h] [bp-1014h]
  int v34; // [sp+78h] [bp-100Ch]
  int v35; // [sp+7Ch] [bp-1008h]
  char v36[4100]; // [sp+80h] [bp-1004h] BYREF

  v3 = 0;
  v27 = 0;
  v26[1] = 0;
  v28 = 0;
  v26[0] = 0;
  if ( !a2 )
    v3 = 8;
  LOBYTE(v27) = 1;
  if ( a2 )
  {
    if ( a2 == 1 )
      HIWORD(v27) = 12;
  }
  else
  {
    HIWORD(v27) = v3;
  }
  v4 = -1068236443;
  v5 = 2;
  v25 = 2;
LABEL_8:
  v6 = (float)v5;
  v7 = 0;
  v8 = 0;
LABEL_9:
  v9 = v8 + 1;
  v10 = v8;
  v22 = (v5 << 8) | 0xC0000000 | v7;
  while ( 1 )
  {
    v11 = (int)(float)((float)((float)((float)((float)(v10 + 1) * (float)((float)(v8 + 1) * v2)) * v6) / 25.0) * 100.0);
    v12 = v11 / 100;
    if ( v11 % 100 > 50 )
      ++v12;
    if ( (unsigned int)(v12 - 16) <= 0xEA )
    {
      v13 = (float)((float)v12 * 25.0) / v6;
      if ( (v5 != 1 || v13 <= 3125.0) && v13 <= 3200.0 && v13 >= 2000.0 )
      {
        v14 = sub_DCEB0(25 * v12, v5);
        v15 = sub_DCEB0(v14, v8 + 1);
        v16 = (float)sub_DCEB0(v15, v10 + 1);
        v17 = v13 > 2400.0;
        v4 = v10 & 7 | v22 | (v12 << 16) | (v17 << 28);
        if ( fabsf(v16 - v2) < 3.0 )
          break;
      }
    }
    if ( v10-- == 0 )
    {
      v7 += 16;
      ++v8;
      if ( v9 != 8 )
        goto LABEL_9;
      v5 = 1;
      if ( v25 == 1 )
      {
        v26[0] = v4;
        V_LOCK();
        V_INT((int)&v29, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v36,
          0x1000u,
          0,
          v35,
          v29,
          v30,
          v31,
          v32,
          v33,
          v34,
          v35,
          "set pll_no %d freq: %.2f, expected freq: %.2f",
          a2,
          0,
          0,
          v2);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_freq_CKB_2042",
          25,
          500,
          40,
          v36);
        goto LABEL_24;
      }
      v25 = 1;
      goto LABEL_8;
    }
  }
  v19 = v5;
  v20 = v10 & 7 | v22 | (v12 << 16) | (v17 << 28);
  V_LOCK();
  logfmt_raw(
    v36,
    0x1000u,
    0,
    "target_freq:%.2f actual_freq:%.2f,vco:%.2f fbdiv:%d refdiv:%d postdiv1:%d, postdiv2:%d",
    v2,
    v16,
    v13,
    v12,
    v19,
    v8,
    v10);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "inferred_plldivider",
    19,
    473,
    20,
    v36);
  v26[0] = v20;
  V_LOCK();
  V_INT((int)&v29, "chain", *(int *)(a1 + 200));
  logfmt_raw(
    v36,
    0x1000u,
    0,
    v35,
    v29,
    v30,
    v31,
    v32,
    v33,
    v34,
    v35,
    "set pll_no %d freq: %.2f, expected freq: %.2f",
    a2,
    v16,
    v2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_freq_CKB_2042",
    25,
    500,
    40,
    v36);
  if ( v16 > 0.0 )
    v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v26);
  else
    v10 = -1;
LABEL_24:
  usleep(0x2710u);
  return v10;
}
// 4B468: variable 'v2' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0004B7D0) --------------------------------------------------------
int __fastcall set_frequency_ckb(int a1, int a2)
{
  sub_4B398(a1, a2);
  return 0;
}

//----- (0004B7E0) --------------------------------------------------------
int __fastcall sub_4B7E0(int a1, int a2)
{
  _DWORD v4[4]; // [sp+28h] [bp-1034h] BYREF
  _DWORD v5[7]; // [sp+38h] [bp-1024h] BYREF
  int v6; // [sp+54h] [bp-1008h]
  char v7[4100]; // [sp+58h] [bp-1004h] BYREF

  v4[0] = a2;
  v4[2] = 4194305;
  v4[3] = 0;
  v4[1] = 0;
  V_LOCK();
  V_INT((int)v5, "chain", *(int *)(a1 + 200));
  logfmt_raw(v7, 0x1000u, 0, v6, v5[0], v5[1], v5[2], v5[3], v5[4], v5[5], v5[6], v6, "set analog value %08x", v4[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_analog_mux_CKB_2042",
    31,
    745,
    40,
    v7);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v4);
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0004B8D4) --------------------------------------------------------
int __fastcall sub_4B8D4(int a1, int a2)
{
  if ( sub_4B7E0(a1, a2) )
    return 19;
  else
    return 0;
}

//----- (0004B8EC) --------------------------------------------------------
int __fastcall sub_4B8EC(int a1, int *a2)
{
  int v2; // r2
  _DWORD *v3; // r6
  int *v5; // r8
  int v6; // r3
  int v7; // r0
  int v8; // r1
  int v9; // r2
  int v10; // r3
  void (__fastcall *v11)(int, int *, int *, _DWORD, int, int, int, int, _DWORD); // r9
  int v12; // r3
  int v13; // r2
  int v14; // r2
  int *v16; // [sp+38h] [bp-109Ch]
  int v17; // [sp+40h] [bp-1094h] BYREF
  int v18; // [sp+44h] [bp-1090h] BYREF
  int v19; // [sp+48h] [bp-108Ch] BYREF
  int v20; // [sp+4Ch] [bp-1088h] BYREF
  _DWORD v21[7]; // [sp+50h] [bp-1084h] BYREF
  int v22; // [sp+6Ch] [bp-1068h]
  _DWORD v23[7]; // [sp+70h] [bp-1064h] BYREF
  int v24; // [sp+8Ch] [bp-1048h]
  _DWORD v25[7]; // [sp+90h] [bp-1044h] BYREF
  int v26; // [sp+ACh] [bp-1028h]
  _DWORD v27[7]; // [sp+B0h] [bp-1024h] BYREF
  int v28; // [sp+CCh] [bp-1008h]
  char v29[4100]; // [sp+D0h] [bp-1004h] BYREF

  v2 = *(_DWORD *)(a1 + 340);
  v3 = *(_DWORD **)(a1 + 332);
  v17 = -64;
  v18 = -64;
  if ( v2 > 0 )
  {
    v16 = &a2[2 * v2];
    v5 = a2;
    do
    {
      v19 = 0;
      (*(void (__fastcall **)(int, int *, int *, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(a1 + 140))(
        a1,
        &v17,
        &v19,
        *v3,
        v3[1],
        v3[2],
        v3[3],
        v3[4],
        v3[5]);
      if ( v19 )
      {
        v6 = v17;
        if ( v17 >= -63 )
          goto LABEL_4;
        v17 = -64;
        V_LOCK();
        V_INT((int)v21, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v29,
          0x1000u,
          0,
          v22,
          v21[0],
          v21[1],
          v21[2],
          v21[3],
          v21[4],
          v21[5],
          v21[6],
          v22,
          "got uneffective temp, sensor[%d], addr:%02x",
          *v3,
          v3[5]);
        V_UNLOCK();
        v13 = 255;
      }
      else
      {
        v17 = -64;
        V_LOCK();
        V_INT((int)v23, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v29,
          0x1000u,
          0,
          v24,
          v23[0],
          v23[1],
          v23[2],
          v23[3],
          v23[4],
          v23[5],
          v23[6],
          v24,
          "read sensor failed, sensor[%d], addr:%02x",
          *v3,
          v3[5]);
        V_UNLOCK();
        v13 = 260;
      }
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/backend_ckb_2042/backend_ckb_2042.c",
        171,
        "read_temperature_ckb",
        20,
        v13,
        100,
        v29);
      v6 = v17;
LABEL_4:
      *v5 = v6;
      v7 = v3[1];
      v8 = v3[2];
      v9 = v3[3];
      v10 = v3[4];
      v11 = *(void (__fastcall **)(int, int *, int *, _DWORD, int, int, int, int, _DWORD))(a1 + 144);
      v20 = 0;
      v11(a1, &v18, &v20, *v3, v7, v8, v9, v10, v3[5]);
      if ( !v20 )
      {
        v18 = -64;
        V_LOCK();
        V_INT((int)v27, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v29,
          0x1000u,
          0,
          v28,
          v27[0],
          v27[1],
          v27[2],
          v27[3],
          v27[4],
          v27[5],
          v27[6],
          v28,
          "read sensor failed, sensor[%d], addr:%02x",
          *v3,
          v3[5]);
        V_UNLOCK();
        v14 = 275;
LABEL_11:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/backend_ckb_2042/backend_ckb_2042.c",
          171,
          "read_temperature_ckb",
          20,
          v14,
          100,
          v29);
        v12 = v18;
        goto LABEL_6;
      }
      v12 = v18;
      if ( v18 < -63 )
      {
        v18 = -64;
        V_LOCK();
        V_INT((int)v25, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v29,
          0x1000u,
          0,
          v26,
          v25[0],
          v25[1],
          v25[2],
          v25[3],
          v25[4],
          v25[5],
          v25[6],
          v26,
          "got uneffective temp, sensor[%d], addr:%02x",
          *v3,
          v3[5]);
        V_UNLOCK();
        v14 = 270;
        goto LABEL_11;
      }
LABEL_6:
      v5[1] = v12;
      v5 += 2;
      usleep((__useconds_t)&loc_7A120);
      v3 += 6;
    }
    while ( v16 != v5 );
  }
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0004BC64) --------------------------------------------------------
int __fastcall sub_4BC64(int a1, int a2)
{
  int v4; // r2
  int v5; // r7
  int v6; // r7
  int v7; // r7
  int *v8; // r6
  int v9; // r0
  int v10; // r12
  int v11; // r2
  int v12; // r3
  int v13; // r8
  int v15; // [sp+4h] [bp-10E8h]
  int v16; // [sp+38h] [bp-10B4h]
  int *ptr; // [sp+4Ch] [bp-10A0h]
  int v18; // [sp+54h] [bp-1098h] BYREF
  _DWORD v19[2]; // [sp+58h] [bp-1094h] BYREF
  int v20; // [sp+60h] [bp-108Ch]
  int v21; // [sp+64h] [bp-1088h]
  _DWORD v22[7]; // [sp+68h] [bp-1084h] BYREF
  int v23; // [sp+84h] [bp-1068h]
  _DWORD v24[7]; // [sp+88h] [bp-1064h] BYREF
  int v25; // [sp+A4h] [bp-1048h]
  _DWORD v26[7]; // [sp+A8h] [bp-1044h] BYREF
  int v27; // [sp+C4h] [bp-1028h]
  _DWORD v28[7]; // [sp+C8h] [bp-1024h] BYREF
  int v29; // [sp+E4h] [bp-1008h]
  char v30[4100]; // [sp+E8h] [bp-1004h] BYREF

  V_LOCK();
  V_INT((int)v22, "chain", *(int *)(a1 + 200));
  logfmt_raw(
    v30,
    0x1000u,
    0,
    v23,
    v22[0],
    v22[1],
    v22[2],
    v22[3],
    v22[4],
    v22[5],
    v22[6],
    v23,
    "set clock delay chip_no %d, value %08x",
    *(_DWORD *)(a1 + 280),
    a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_clock_delay_CKB_2042",
    32,
    597,
    40,
    v30);
  v19[1] = 0;
  v21 = 255;
  v19[0] = a2;
  v20 = 1;
  if ( (*(int (__fastcall **)(int, _DWORD *))(a1 + 220))(a1, v19) < 0 )
  {
    V_LOCK();
    v16 = -1;
    V_INT((int)v24, "chain", *(int *)(a1 + 200));
    logfmt_raw(
      v30,
      0x1000u,
      0,
      v25,
      v24[0],
      v24[1],
      v24[2],
      v24[3],
      v24[4],
      v24[5],
      v24[6],
      v25,
      "%s failed, set reg:%02x",
      "ChipSetting_clock_delay_CKB_2042",
      HIWORD(v20));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_clock_delay_CKB_2042",
      32,
      606,
      100,
      v30);
  }
  else
  {
    usleep((__useconds_t)"rl_kda_2110");
    v4 = *(_DWORD *)(a1 + 280);
    v5 = *(_DWORD *)(a1 + 284);
    LOBYTE(v21) = 0;
    v6 = v5 * v4;
    ptr = (int *)calloc(12 * v6, 1u);
    (*(void (__fastcall **)(int, _DWORD *, int, int *, int *, int, int, _DWORD))(a1 + 244))(
      a1,
      v19,
      v6,
      ptr,
      &v18,
      v15,
      2000,
      0);
    if ( v18 > 0 )
    {
      v7 = 0;
      v16 = 0;
      v8 = ptr;
      do
      {
        v12 = *v8;
        v13 = *((unsigned __int16 *)v8 + 3);
        HIBYTE(v24[0]) = *v8;
        BYTE2(v24[0]) = BYTE1(v12);
        BYTE1(v24[0]) = BYTE2(v12);
        LOBYTE(v24[0]) = HIBYTE(v12);
        V_LOCK();
        if ( v13 )
        {
          V_INT((int)v28, "chain", *(int *)(a1 + 200));
          logfmt_raw(
            v30,
            0x1000u,
            0,
            v29,
            v28[0],
            v28[1],
            v28[2],
            v28[3],
            v28[4],
            v28[5],
            v28[6],
            v29,
            "[DP] chip %02x, expected reg %02x, but %02x, data %08x",
            *((unsigned __int8 *)v8 + 4),
            0,
            *((unsigned __int16 *)v8 + 3),
            v24[0]);
          V_UNLOCK();
          v9 = g_zc;
          v10 = 100;
          v11 = 625;
        }
        else
        {
          ++v16;
          V_INT((int)v26, "chain", *(int *)(a1 + 200));
          logfmt_raw(
            v30,
            0x1000u,
            0,
            v27,
            v26[0],
            v26[1],
            v26[2],
            v26[3],
            v26[4],
            v26[5],
            v26[6],
            v27,
            "[DP] chip %02x, core %02x, reg %02x, clk_delay %08x",
            *((unsigned __int8 *)v8 + 4),
            *((unsigned __int8 *)v8 + 8),
            *((unsigned __int16 *)v8 + 3),
            v24[0]);
          V_UNLOCK();
          v9 = g_zc;
          v10 = 20;
          v11 = 622;
        }
        ++v7;
        v8 += 3;
        zlog(
          v9,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_clock_delay_CKB_2042",
          32,
          v11,
          v10,
          v30);
      }
      while ( v18 > v7 );
    }
    else
    {
      v16 = 0;
    }
    free(ptr);
  }
  return v16;
}
// 4BDB4: variable 'v15' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0004C024) --------------------------------------------------------
int __fastcall sub_4C024(int a1, int a2)
{
  if ( *(_DWORD *)(a1 + 284) * *(_DWORD *)(a1 + 280) == sub_4BC64(a1, a2) )
    return 19;
  else
    return 0;
}

//----- (0004C04C) --------------------------------------------------------
int __fastcall sub_4C04C(int a1, int a2, char a3)
{
  int v4; // r6
  _DWORD *v5; // r10
  _DWORD *v6; // r4
  int (__fastcall *v7)(int, _DWORD *); // r3
  int result; // r0
  int v9; // [sp+40h] [bp-1094h]
  int v10; // [sp+44h] [bp-1090h]
  char v11; // [sp+48h] [bp-108Ch]
  char v12; // [sp+50h] [bp-1084h]
  int v14; // [sp+5Ch] [bp-1078h] BYREF
  _DWORD v15[2]; // [sp+60h] [bp-1074h] BYREF
  int v16; // [sp+68h] [bp-106Ch]
  int v17; // [sp+6Ch] [bp-1068h]
  _DWORD v18[7]; // [sp+70h] [bp-1064h] BYREF
  int v19; // [sp+8Ch] [bp-1048h]
  _DWORD v20[7]; // [sp+90h] [bp-1044h] BYREF
  int v21; // [sp+ACh] [bp-1028h]
  _DWORD v22[7]; // [sp+B0h] [bp-1024h] BYREF
  int v23; // [sp+CCh] [bp-1008h]
  char v24[4100]; // [sp+D0h] [bp-1004h] BYREF

  v9 = a3 & 1;
  v14 = 0;
  if ( a2 == -1 || *(_DWORD *)(a1 + 280) < a2 )
  {
    v11 = 0;
    v12 = 1;
  }
  else
  {
    v12 = 0;
    v11 = *(_BYTE *)(*(_DWORD *)(a1 + 432) + a2);
  }
  v4 = 0;
  v16 = 0x10000;
  v15[1] = 0;
  v15[0] = 0;
  BYTE1(v16) = v11;
  v17 = 0;
  v5 = calloc(0xCu, 1u);
  (*(void (__fastcall **)(int, _DWORD *, int, _DWORD *, int *))(a1 + 244))(a1, v15, 1, v5, &v14);
  if ( v14 <= 0 )
  {
    v10 = v9;
  }
  else
  {
    v6 = v5;
    v10 = v9;
    do
    {
      if ( *((_WORD *)v6 + 3) == 1 )
      {
        V_LOCK();
        V_INT((int)v18, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v24,
          0x1000u,
          0,
          v19,
          v18[0],
          v18[1],
          v18[2],
          v18[3],
          v18[4],
          v18[5],
          v18[6],
          v19,
          "%s chip %02x, core %02x, reg %02x, core_mode %08x",
          "ChipSetting_same_nonce_CKB_2042",
          *((unsigned __int8 *)v6 + 4),
          *((unsigned __int8 *)v6 + 8),
          *((unsigned __int16 *)v6 + 3),
          *v6);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_same_nonce_CKB_2042",
          31,
          268,
          20,
          v24);
        v10 = v9 | *v6;
      }
      else
      {
        V_LOCK();
        V_INT((int)v20, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v24,
          0x1000u,
          0,
          v21,
          v20[0],
          v20[1],
          v20[2],
          v20[3],
          v20[4],
          v20[5],
          v20[6],
          v21,
          "%s chip %02x, expected reg %02x, but %02x, core_mode %08x",
          "ChipSetting_same_nonce_CKB_2042",
          *((unsigned __int8 *)v6 + 4),
          5,
          *((unsigned __int16 *)v6 + 3),
          *v6);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_same_nonce_CKB_2042",
          31,
          272,
          100,
          v24);
      }
      ++v4;
      v6 += 3;
    }
    while ( v14 > v4 );
  }
  free(v5);
  HIWORD(v16) = 1;
  LOBYTE(v17) = -1;
  LOBYTE(v16) = v12;
  v7 = *(int (__fastcall **)(int, _DWORD *))(a1 + 220);
  BYTE1(v16) = v11;
  v15[0] = v10;
  result = v7(a1, v15);
  if ( result < 0 )
  {
    V_LOCK();
    V_INT((int)v22, "chain", *(int *)(a1 + 200));
    logfmt_raw(
      v24,
      0x1000u,
      0,
      v23,
      v22[0],
      v22[1],
      v22[2],
      v22[3],
      v22[4],
      v22[5],
      v22[6],
      v23,
      "set same nonce failed! chip_id:%d",
      a2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_same_nonce_CKB_2042",
      31,
      285,
      100,
      v24);
    return -1;
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0004C3C8) --------------------------------------------------------
int __fastcall sub_4C3C8(int a1, int a2, char a3)
{
  sub_4C04C(a1, a2, a3);
  usleep(0x2710u);
  return 0;
}

//----- (0004C3E0) --------------------------------------------------------
bool __fastcall sub_4C3E0(int a1, int a2, char **a3)
{
  char v3; // r3
  _DWORD *v5; // r8
  int v6; // r6
  _DWORD *v7; // r5
  int v8; // r3
  int v9; // r10
  void *v10; // r0
  char *v11; // r8
  int v12; // r5
  int v13; // r6
  _DWORD *v14; // r5
  const char *v15; // r5
  int v17; // [sp+4h] [bp-10E8h]
  char *s; // [sp+40h] [bp-10ACh]
  char *v20; // [sp+44h] [bp-10A8h]
  _DWORD *ptr; // [sp+4Ch] [bp-10A0h]
  int v22; // [sp+54h] [bp-1098h] BYREF
  int v23; // [sp+58h] [bp-1094h] BYREF
  int v24; // [sp+5Ch] [bp-1090h]
  int v25; // [sp+60h] [bp-108Ch]
  int v26; // [sp+64h] [bp-1088h]
  _DWORD v27[7]; // [sp+68h] [bp-1084h] BYREF
  int v28; // [sp+84h] [bp-1068h]
  _DWORD v29[7]; // [sp+88h] [bp-1064h] BYREF
  int v30; // [sp+A4h] [bp-1048h]
  _DWORD v31[7]; // [sp+A8h] [bp-1044h] BYREF
  int v32; // [sp+C4h] [bp-1028h]
  _DWORD v33[7]; // [sp+C8h] [bp-1024h] BYREF
  int v34; // [sp+E4h] [bp-1008h]
  char v35[4100]; // [sp+E8h] [bp-1004h] BYREF

  v3 = 0;
  v22 = 0;
  if ( a2 != -1 && *(_DWORD *)(a1 + 280) >= a2 )
    v3 = *(_BYTE *)(*(_DWORD *)(a1 + 432) + a2);
  v25 = 3932160;
  v24 = 0;
  v23 = 0;
  v26 = 0;
  BYTE1(v25) = v3;
  v5 = calloc(0xCu, 1u);
  (*(void (__fastcall **)(int, int *, int, _DWORD *, int *))(a1 + 236))(a1, &v23, 1, v5, &v22);
  if ( v22 <= 0 )
  {
    v20 = 0;
  }
  else
  {
    v20 = 0;
    v6 = 0;
    v7 = v5;
    do
    {
      while ( 1 )
      {
        ++v6;
        if ( *((_WORD *)v7 + 3) == 60 )
          break;
        v7 += 3;
        if ( v22 <= v6 )
          goto LABEL_9;
      }
      v8 = *v5;
      v7 += 3;
      HIBYTE(v33[0]) = *v5;
      BYTE2(v33[0]) = BYTE1(v8);
      BYTE1(v33[0]) = BYTE2(v8);
      LOBYTE(v33[0]) = HIBYTE(v8);
      v9 = v33[0];
      V_LOCK();
      v20 += v9;
      V_INT((int)v27, "chain", *(int *)(a1 + 200));
      logfmt_raw(
        v35,
        0x1000u,
        0,
        v28,
        v27[0],
        v27[1],
        v27[2],
        v27[3],
        v27[4],
        v27[5],
        v27[6],
        v28,
        "[Top Nonce Cnt] asic %02x, reg %02x cnt %08x",
        *((unsigned __int8 *)v7 - 8),
        *((unsigned __int16 *)v7 - 3),
        v9);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/chip_setting.c",
        150,
        "ChipSetting_nonce_counter_CKB_2042",
        34,
        321,
        20,
        v35);
    }
    while ( v22 > v6 );
  }
LABEL_9:
  v10 = v5;
  v11 = 0;
  free(v10);
  *a3 = v20;
  v12 = *(_DWORD *)(a1 + 284);
  v25 = 655360;
  v26 = 255;
  v23 = 1;
  v24 = 0;
  ptr = calloc(12 * v12, 1u);
  (*(void (__fastcall **)(int, int *, int, _DWORD *, int *, int, int, _DWORD))(a1 + 244))(
    a1,
    &v23,
    v12,
    ptr,
    &v22,
    v17,
    2000,
    0);
  if ( v22 > 0 )
  {
    v13 = 0;
    v14 = ptr;
    s = 0;
    do
    {
      if ( *((_WORD *)v14 + 3) == 10 )
      {
        s += *v14;
        V_LOCK();
        V_INT((int)v29, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v35,
          0x1000u,
          0,
          v30,
          v29[0],
          v29[1],
          v29[2],
          v29[3],
          v29[4],
          v29[5],
          v29[6],
          v30,
          "%s chip %02x, core %02x, reg %02x, core_nonce_cnt %08x",
          "ChipSetting_nonce_counter_CKB_2042",
          *((unsigned __int8 *)v14 + 4),
          *((unsigned __int8 *)v14 + 8),
          *((unsigned __int16 *)v14 + 3),
          *v14);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_nonce_counter_CKB_2042",
          34,
          344,
          20,
          v35);
      }
      else
      {
        V_LOCK();
        V_INT((int)v31, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v35,
          0x1000u,
          0,
          v32,
          v31[0],
          v31[1],
          v31[2],
          v31[3],
          v31[4],
          v31[5],
          v31[6],
          v32,
          "%s chip %02x, expected reg %02x, but %02x, core_nonce_cnt %08x",
          "ChipSetting_nonce_counter_CKB_2042",
          *((unsigned __int8 *)v14 + 4),
          5,
          *((unsigned __int16 *)v14 + 3),
          *v14);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_nonce_counter_CKB_2042",
          34,
          347,
          100,
          v35);
      }
      ++v13;
      v14 += 3;
    }
    while ( v22 > v13 );
    v11 = s;
  }
  free(ptr);
  V_LOCK();
  V_INT((int)v33, "chain", *(int *)(a1 + 200));
  v15 = "Failed";
  if ( v20 == v11 )
    v15 = "Pass";
  logfmt_raw(
    v35,
    0x1000u,
    0,
    v34,
    v33[0],
    v33[1],
    v33[2],
    v33[3],
    v33[4],
    v33[5],
    v33[6],
    v34,
    "check nonce counter, top_nonce_cnt %d, core_nocne_cnt %d (%s)",
    v20,
    v11,
    v15);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_nonce_counter_CKB_2042",
    34,
    353,
    40,
    v35);
  return v20 != v11;
}
// 4C620: variable 'v17' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0004C8BC) --------------------------------------------------------
int __fastcall sub_4C8BC(int a1, int a2, char **a3)
{
  if ( sub_4C3E0(a1, a2, a3) )
    return 19;
  else
    return 0;
}

//----- (0004C8D4) --------------------------------------------------------
int __fastcall sub_4C8D4(int a1)
{
  int v2; // r6
  int v3; // r2
  int v4; // r0
  int v5; // r9
  int *v6; // r5
  int v7; // r0
  int v8; // r12
  int v9; // r2
  int v10; // r3
  int v11; // r2
  int v13; // [sp+4h] [bp-10E0h]
  int v14; // [sp+3Ch] [bp-10A8h]
  int *ptr; // [sp+44h] [bp-10A0h]
  int v16; // [sp+4Ch] [bp-1098h] BYREF
  _DWORD v17[2]; // [sp+50h] [bp-1094h] BYREF
  int v18; // [sp+58h] [bp-108Ch]
  int v19; // [sp+5Ch] [bp-1088h]
  _DWORD v20[7]; // [sp+60h] [bp-1084h] BYREF
  int v21; // [sp+7Ch] [bp-1068h]
  _DWORD v22[7]; // [sp+80h] [bp-1064h] BYREF
  int v23; // [sp+9Ch] [bp-1048h]
  _DWORD v24[7]; // [sp+A0h] [bp-1044h] BYREF
  int v25; // [sp+BCh] [bp-1028h]
  _DWORD v26[7]; // [sp+C0h] [bp-1024h] BYREF
  int v27; // [sp+DCh] [bp-1008h]
  char v28[4100]; // [sp+E0h] [bp-1004h] BYREF

  V_LOCK();
  V_INT((int)v20, "chain", *(int *)(a1 + 200));
  v2 = 0;
  logfmt_raw(
    v28,
    0x1000u,
    0,
    v21,
    v20[0],
    v20[1],
    v20[2],
    v20[3],
    v20[4],
    v20[5],
    v20[6],
    v21,
    "get hash clock count chip_no %d",
    *(_DWORD *)(a1 + 280));
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_hash_clock_count_CKB_2042",
    37,
    692,
    20,
    v28);
  v18 = 393217;
  v17[1] = 0;
  v17[0] = 1;
  v19 = 255;
  if ( (*(int (__fastcall **)(int, _DWORD *))(a1 + 220))(a1, v17) < 0 )
  {
    V_LOCK();
    v14 = -1;
    V_INT((int)v22, "chain", *(int *)(a1 + 200));
    logfmt_raw(
      v28,
      0x1000u,
      0,
      v23,
      v22[0],
      v22[1],
      v22[2],
      v22[3],
      v22[4],
      v22[5],
      v22[6],
      v23,
      "%s failed, set reg:%02x",
      "ChipSetting_hash_clock_count_CKB_2042",
      HIWORD(v18));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_hash_clock_count_CKB_2042",
      37,
      701,
      100,
      v28);
  }
  else
  {
    usleep(0x4E20u);
    v3 = *(_DWORD *)(a1 + 280);
    v4 = *(_DWORD *)(a1 + 284);
    v18 = 458753;
    v5 = v4 * v3;
    LOBYTE(v19) = 0;
    ptr = (int *)calloc(12 * v4 * v3, 1u);
    (*(void (__fastcall **)(int, _DWORD *, int, int *, int *, int, int, _DWORD))(a1 + 244))(
      a1,
      v17,
      v5,
      ptr,
      &v16,
      v13,
      2000,
      0);
    v14 = 0;
    if ( v16 > 0 )
    {
      v6 = ptr;
      do
      {
        v10 = *v6;
        v11 = *((unsigned __int16 *)v6 + 3);
        HIBYTE(v22[0]) = *v6;
        BYTE2(v22[0]) = BYTE1(v10);
        BYTE1(v22[0]) = BYTE2(v10);
        LOBYTE(v22[0]) = HIBYTE(v10);
        if ( v11 == 7 )
        {
          V_LOCK();
          ++v14;
          V_INT((int)v24, "chain", *(int *)(a1 + 200));
          logfmt_raw(
            v28,
            0x1000u,
            0,
            v25,
            v24[0],
            v24[1],
            v24[2],
            v24[3],
            v24[4],
            v24[5],
            v24[6],
            v25,
            "[Hash clk cnt] chip %02x, core %02x, reg %02x, clk_cnt %08x",
            *((unsigned __int8 *)v6 + 4),
            *((unsigned __int8 *)v6 + 8),
            *((unsigned __int16 *)v6 + 3),
            v22[0]);
          V_UNLOCK();
          v7 = g_zc;
          v8 = 40;
          v9 = 720;
        }
        else
        {
          V_LOCK();
          V_INT((int)v26, "chain", *(int *)(a1 + 200));
          logfmt_raw(
            v28,
            0x1000u,
            0,
            v27,
            v26[0],
            v26[1],
            v26[2],
            v26[3],
            v26[4],
            v26[5],
            v26[6],
            v27,
            "[Hash clk cnt] chip %02x, expected reg %02x, but %02x, clk_cnt %08x",
            *((unsigned __int8 *)v6 + 4),
            7,
            *((unsigned __int16 *)v6 + 3),
            v22[0]);
          V_UNLOCK();
          v7 = g_zc;
          v8 = 100;
          v9 = 723;
        }
        ++v2;
        v6 += 3;
        zlog(
          v7,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_hash_clock_count_CKB_2042",
          37,
          v9,
          v8,
          v28);
      }
      while ( v16 > v2 );
    }
    free(ptr);
  }
  return v14;
}
// 4CA30: variable 'v13' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0004CC84) --------------------------------------------------------
int __fastcall sub_4CC84(int a1)
{
  if ( *(_DWORD *)(a1 + 284) * *(_DWORD *)(a1 + 280) == sub_4C8D4(a1) )
    return 19;
  else
    return 0;
}

//----- (0004CCAC) --------------------------------------------------------
int __fastcall sub_4CCAC(int a1)
{
  int v2; // r6
  int (__fastcall *v3)(int, _DWORD *); // r3
  int v4; // r8
  int v5; // r2
  int v6; // r5
  int v7; // r5
  _WORD *v8; // r5
  int v9; // r0
  int v10; // r12
  int v11; // r2
  int v13; // [sp+3Ch] [bp-1088h]
  _WORD *ptr; // [sp+44h] [bp-1080h]
  int v15; // [sp+48h] [bp-107Ch]
  int v16; // [sp+4Ch] [bp-1078h]
  _DWORD v17[2]; // [sp+50h] [bp-1074h] BYREF
  int v18; // [sp+58h] [bp-106Ch]
  int v19; // [sp+5Ch] [bp-1068h]
  _DWORD v20[7]; // [sp+60h] [bp-1064h] BYREF
  int v21; // [sp+7Ch] [bp-1048h]
  _DWORD v22[7]; // [sp+80h] [bp-1044h] BYREF
  int v23; // [sp+9Ch] [bp-1028h]
  _DWORD v24[7]; // [sp+A0h] [bp-1024h] BYREF
  int v25; // [sp+BCh] [bp-1008h]
  char v26[4100]; // [sp+C0h] [bp-1004h] BYREF

  V_LOCK();
  V_INT((int)v20, "chain", *(int *)(a1 + 200));
  logfmt_raw(
    v26,
    0x1000u,
    0,
    v21,
    v20[0],
    v20[1],
    v20[2],
    v20[3],
    v20[4],
    v20[5],
    v20[6],
    v21,
    "get pmdata chip_no %d",
    *(_DWORD *)(a1 + 280));
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_pmdata_CKB_2042",
    27,
    640,
    20,
    v26);
  v2 = 0;
  v18 = 0;
  v19 = 0;
  v13 = 0;
  v17[1] = 0;
  v3 = *(int (__fastcall **)(int, _DWORD *))(a1 + 220);
  while ( 1 )
  {
    if ( v2 == 3 )
      goto LABEL_12;
    LOBYTE(v18) = 1;
    HIWORD(v18) = 255;
    v17[0] = (16 * v2) | 1;
    LOBYTE(v19) = -1;
    if ( v3(a1, v17) < 0 )
      break;
    v4 = 0;
    usleep(0x4E20u);
    v5 = *(_DWORD *)(a1 + 280);
    v6 = *(_DWORD *)(a1 + 284);
    v18 = 327681;
    v7 = v6 * v5;
    LOBYTE(v19) = 0;
    ptr = calloc(12 * v7, 1u);
    (*(void (__fastcall **)(int, _DWORD *, int))(a1 + 244))(a1, v17, v7);
    if ( v15 > 0 )
    {
      v8 = ptr;
      do
      {
        HIBYTE(v16) = *(_DWORD *)v8;
        BYTE2(v16) = BYTE1(*(_DWORD *)v8);
        BYTE1(v16) = BYTE2(*(_DWORD *)v8);
        LOBYTE(v16) = HIBYTE(*(_DWORD *)v8);
        if ( v8[3] == 5 )
        {
          V_LOCK();
          ++v13;
          V_INT((int)v22, "chain", *(int *)(a1 + 200));
          logfmt_raw(
            v26,
            0x1000u,
            0,
            v23,
            v22[0],
            v22[1],
            v22[2],
            v22[3],
            v22[4],
            v22[5],
            v22[6],
            v23,
            "[PM data] chip %02x, reg %02x mode %d PMDATA %08x",
            *((unsigned __int8 *)v8 + 4),
            (unsigned __int16)v8[3],
            v2,
            v16);
          V_UNLOCK();
          v9 = g_zc;
          v10 = 40;
          v11 = 672;
        }
        else
        {
          V_LOCK();
          V_INT((int)v24, "chain", *(int *)(a1 + 200));
          logfmt_raw(
            v26,
            0x1000u,
            0,
            v25,
            v24[0],
            v24[1],
            v24[2],
            v24[3],
            v24[4],
            v24[5],
            v24[6],
            v25,
            "[PM data] chip %02x, expected reg %02x, but %02x mode %d PMDATA %08x",
            *((unsigned __int8 *)v8 + 4),
            5,
            (unsigned __int16)v8[3],
            v2,
            v16);
          V_UNLOCK();
          v9 = g_zc;
          v10 = 100;
          v11 = 675;
        }
        ++v4;
        v8 += 6;
        zlog(
          v9,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_pmdata_CKB_2042",
          27,
          v11,
          v10,
          v26);
      }
      while ( v15 > v4 );
    }
    if ( v2 == 6 )
    {
      free(ptr);
      return v13;
    }
    v3 = *(int (__fastcall **)(int, _DWORD *))(a1 + 220);
LABEL_12:
    ++v2;
  }
  V_LOCK();
  logfmt_raw(v26, 0x1000u, 0, "%s failed, set reg:%02x", "ChipSetting_pmdata_CKB_2042", HIWORD(v18));
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_pmdata_CKB_2042",
    27,
    653,
    100,
    v26);
  return -1;
}
// 4CE38: variable 'v15' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0004D060) --------------------------------------------------------
int __fastcall sub_4D060(int a1)
{
  if ( *(_DWORD *)(a1 + 284) * *(_DWORD *)(a1 + 280) == sub_4CCAC(a1) )
    return 19;
  else
    return 0;
}

//----- (0004D088) --------------------------------------------------------
int __fastcall sub_4D088(int a1, int a2)
{
  int v3; // r5
  _DWORD *v4; // r11
  _DWORD *v5; // r9
  _DWORD *v6; // r6
  int v7; // r3
  int v8; // r4
  int v11; // [sp+48h] [bp-105Ch] BYREF
  int v12; // [sp+4Ch] [bp-1058h]
  _DWORD v13[2]; // [sp+50h] [bp-1054h] BYREF
  int v14; // [sp+58h] [bp-104Ch]
  int v15; // [sp+5Ch] [bp-1048h]
  _DWORD v16[7]; // [sp+60h] [bp-1044h] BYREF
  int v17; // [sp+7Ch] [bp-1028h]
  _DWORD v18[7]; // [sp+80h] [bp-1024h] BYREF
  int v19; // [sp+9Ch] [bp-1008h]
  char v20[4100]; // [sp+A0h] [bp-1004h] BYREF

  v5 = *(_DWORD **)(a1 + 280);
  v3 = 0;
  v14 = 1835009;
  v13[1] = 0;
  v13[0] = 0;
  v15 = 0;
  v11 = 0;
  v4 = calloc(12 * (_DWORD)v5, 1u);
  (*(void (__fastcall **)(int, _DWORD *, _DWORD *, _DWORD *, int *))(a1 + 236))(a1, v13, v5, v4, &v11);
  LOWORD(v5) = (unsigned __int16)&g_zc;
  if ( v11 > 0 )
  {
    HIWORD(v5) = (unsigned int)&g_zc >> 16;
    v6 = v4;
    do
    {
      while ( 1 )
      {
        ++v3;
        if ( *((_WORD *)v6 + 3) == 28 )
          break;
        v6 += 3;
        if ( v11 <= v3 )
          goto LABEL_7;
      }
      V_LOCK();
      v6 += 3;
      V_INT((int)v16, "chain", *(int *)(a1 + 200));
      logfmt_raw(
        v20,
        0x1000u,
        0,
        v17,
        v16[0],
        v16[1],
        v16[2],
        v16[3],
        v16[4],
        v16[5],
        v16[6],
        v17,
        "[MISC CTRL] asic %02x, reg %02x state %08x",
        *((unsigned __int8 *)v6 - 8),
        *((unsigned __int16 *)v6 - 3),
        *(v6 - 3));
      V_UNLOCK();
      zlog(
        *v5,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/chip_setting.c",
        150,
        "ChipSetting_pll_sel_CKB_2042",
        28,
        189,
        20,
        v20);
    }
    while ( v11 > v3 );
  }
  else
  {
    HIWORD(v5) = (unsigned int)&g_zc >> 16;
  }
LABEL_7:
  v7 = *v4;
  HIBYTE(v12) = *v4;
  BYTE2(v12) = BYTE1(v7);
  BYTE1(v12) = BYTE2(v7);
  LOBYTE(v12) = HIBYTE(v7);
  free(v4);
  v14 = 1835009;
  v13[0] = v12 & 0xFFFFFFFB | (4 * (_BYTE)a2) & 4;
  V_LOCK();
  V_INT((int)v18, "chain", *(int *)(a1 + 200));
  logfmt_raw(
    v20,
    0x1000u,
    0,
    v19,
    v18[0],
    v18[1],
    v18[2],
    v18[3],
    v18[4],
    v18[5],
    v18[6],
    v19,
    "set pll sel %u %08x",
    a2,
    v13[0]);
  V_UNLOCK();
  zlog(
    *v5,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_pll_sel_CKB_2042",
    28,
    201,
    40,
    v20);
  v8 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v13);
  usleep(0x2710u);
  return v8;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0004D330) --------------------------------------------------------
int __fastcall sub_4D330(int a1, int a2)
{
  if ( sub_4D088(a1, a2) )
    return 19;
  else
    return 0;
}

//----- (0004D348) --------------------------------------------------------
int __fastcall sub_4D348(int a1, int a2)
{
  int v3; // r4
  _DWORD v5[4]; // [sp+28h] [bp-1034h] BYREF
  _DWORD v6[7]; // [sp+38h] [bp-1024h] BYREF
  int v7; // [sp+54h] [bp-1008h]
  char v8[4100]; // [sp+58h] [bp-1004h] BYREF

  v5[0] = a2;
  v5[2] = 2883585;
  v5[3] = 0;
  v5[1] = 0;
  V_LOCK();
  V_INT((int)v6, "chain", *(int *)(a1 + 200));
  logfmt_raw(v8, 0x1000u, 0, v7, v6[0], v6[1], v6[2], v6[3], v6[4], v6[5], v6[6], v7, "set io cfg value %08x", v5[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_io_cfg_CKB_2042",
    27,
    233,
    40,
    v8);
  v3 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v5);
  usleep(0x2710u);
  return v3;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0004D44C) --------------------------------------------------------
int __fastcall sub_4D44C(int a1, int a2)
{
  if ( sub_4D348(a1, a2) )
    return 19;
  else
    return 0;
}

//----- (0004D464) --------------------------------------------------------
int __fastcall check_nonce_ckb(int a1, int a2)
{
  _DWORD *v2; // r8
  int v3; // r12
  int v6; // r4
  unsigned int v7; // r7
  int *v8; // r12
  int v9; // r0
  int v10; // r1
  int v11; // r2
  int v12; // r3
  int v13; // r0
  int v14; // r1
  int v15; // r2
  int v16; // r3
  int v17; // r1
  int v18; // r2
  int v19; // r3
  int v20; // t1
  int v21; // r3
  int v22; // r1
  int v23; // r2
  unsigned int v24; // r0
  unsigned int v25; // r8
  unsigned int v26; // r3
  unsigned __int8 *v27; // r3
  int v28; // r4
  int v29; // r2
  int v30; // r4
  unsigned int v31; // r0
  unsigned int v32; // t1
  unsigned int v33; // t1
  bool v34; // cc
  _DWORD v36[7]; // [sp+30h] [bp-10B4h] BYREF
  int v37; // [sp+4Ch] [bp-1098h]
  _DWORD v38[7]; // [sp+50h] [bp-1094h] BYREF
  int v39; // [sp+6Ch] [bp-1078h]
  _DWORD v40[7]; // [sp+70h] [bp-1074h] BYREF
  int v41; // [sp+8Ch] [bp-1058h]
  _BYTE v42[32]; // [sp+90h] [bp-1054h] BYREF
  _DWORD v43[8]; // [sp+B0h] [bp-1034h] BYREF
  int v44; // [sp+D0h] [bp-1014h]
  int v45; // [sp+D4h] [bp-1010h]
  int v46; // [sp+D8h] [bp-100Ch]
  int v47; // [sp+DCh] [bp-1008h]
  char v48[4100]; // [sp+E0h] [bp-1004h] BYREF

  v2 = (_DWORD *)a2;
  v3 = *(unsigned __int8 *)(a2 + 65);
  v6 = *(_DWORD *)(a1 + 760);
  v7 = *(_DWORD *)(v6 + 4 * (v3 + 2816));
  v8 = (int *)(v6 + 48 * v3 + 5120);
  v9 = *v8;
  v10 = v8[1];
  v11 = v8[2];
  v12 = v8[3];
  v8 += 4;
  v43[0] = v9;
  v43[1] = v10;
  v43[2] = v11;
  v43[3] = v12;
  v13 = *v8;
  v14 = v8[1];
  v15 = v8[2];
  v16 = v8[3];
  v8 += 4;
  v43[4] = v13;
  v43[5] = v14;
  v43[6] = v15;
  v43[7] = v16;
  v17 = v8[1];
  v18 = v8[2];
  v19 = v8[3];
  v44 = *v8;
  v45 = v17;
  v46 = v18;
  v47 = v19;
  v20 = v2[12];
  v2 += 12;
  v21 = v2[3];
  v22 = v2[1];
  v23 = v2[2];
  v44 = v20;
  v45 = v22;
  v46 = v23;
  v47 = v21;
  EaglesongHash((int)v42, (int)v43, 0x30u);
  v24 = target_to_diff_ckb(v42);
  v25 = v24;
  if ( v24 <= 0x26 )
  {
    V_LOCK();
    V_INT((int)v36, "chain", *(int *)(a1 + 200));
    logfmt_raw(
      v48,
      0x1000u,
      0,
      v37,
      v36[0],
      v36[1],
      v36[2],
      v36[3],
      v36[4],
      v36[5],
      v36[6],
      v37,
      "hw error calculate diff %d ans diff %d TICKET_MASK_CKB_2042 %d",
      v25,
      *(unsigned __int8 *)(a2 + 64),
      39);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/backend_ckb_2042/backend_ckb_2042.c",
      171,
      "check_nonce_ckb",
      15,
      505,
      20,
      v48);
    return 2;
  }
  else
  {
    v26 = *(unsigned __int8 *)(a2 + 64);
    if ( v26 == v24 )
    {
      if ( v7 > v26 )
      {
LABEL_9:
        V_LOCK();
        V_INT((int)v40, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v48,
          0x1000u,
          0,
          v41,
          v40[0],
          v40[1],
          v40[2],
          v40[3],
          v40[4],
          v40[5],
          v40[6],
          v41,
          "hw diff (%d<%d) not reach pool",
          *(unsigned __int8 *)(a2 + 64),
          v7);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/backend_ckb_2042/backend_ckb_2042.c",
          171,
          "check_nonce_ckb",
          15,
          535,
          20,
          v48);
        return 1;
      }
      else
      {
        v27 = v42;
        v28 = v6 + 32 * (*(unsigned __int8 *)(a2 + 65) + 368);
        v29 = v28 - 1;
        v30 = v28 + 31;
        do
        {
          v32 = *v27++;
          v31 = v32;
          v33 = *(unsigned __int8 *)++v29;
          v34 = v31 > v33;
          if ( v31 < v33 )
            break;
          if ( v34 )
            goto LABEL_9;
        }
        while ( v29 != v30 );
        return 0;
      }
    }
    else
    {
      V_LOCK();
      V_INT((int)v38, "chain", *(int *)(a1 + 200));
      logfmt_raw(
        v48,
        0x1000u,
        0,
        v39,
        v38[0],
        v38[1],
        v38[2],
        v38[3],
        v38[4],
        v38[5],
        v38[6],
        v39,
        "diff not match (%d!=%d) expected diff %d",
        v25,
        *(unsigned __int8 *)(a2 + 64),
        v7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/backend_ckb_2042/backend_ckb_2042.c",
        171,
        "check_nonce_ckb",
        15,
        510,
        20,
        v48);
      return 3;
    }
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 3D3D8: using guessed type int __fastcall target_to_diff_ckb(_DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0004D778) --------------------------------------------------------
int __fastcall sub_4D778(int *a1, int a2)
{
  const char *v2; // r4
  void *v5; // r0
  void (__fastcall *v6)(int *, _DWORD *, int, void *, int *, int, int, _DWORD); // lr
  unsigned __int16 *v7; // r6
  unsigned int v8; // r9
  int v9; // r1
  int v10; // r0
  unsigned int v11; // r1
  unsigned int v12; // r0
  int v13; // r9
  int v14; // r2
  int **v15; // r12
  int result; // r0
  unsigned __int8 *v17; // r8
  char *v18; // r4
  int v19; // r6
  int v20; // r9
  int v22; // r2
  int *v23; // [sp+0h] [bp-160Ch] BYREF
  int v24; // [sp+4h] [bp-1608h]
  const char *v25; // [sp+8h] [bp-1604h]
  const char *v26; // [sp+54h] [bp-15B8h]
  const char *v27; // [sp+58h] [bp-15B4h]
  const char *v28; // [sp+5Ch] [bp-15B0h]
  int v29; // [sp+60h] [bp-15ACh]
  void *ptr; // [sp+64h] [bp-15A8h]
  int v31; // [sp+68h] [bp-15A4h]
  int **v32; // [sp+6Ch] [bp-15A0h]
  int v33; // [sp+74h] [bp-1598h] BYREF
  _DWORD v34[4]; // [sp+78h] [bp-1594h] BYREF
  _DWORD v35[7]; // [sp+88h] [bp-1584h] BYREF
  int v36; // [sp+A4h] [bp-1568h]
  _BYTE v37[32]; // [sp+A8h] [bp-1564h] BYREF
  _DWORD v38[7]; // [sp+C8h] [bp-1544h] BYREF
  int v39; // [sp+E4h] [bp-1528h]
  _DWORD v40[8]; // [sp+E8h] [bp-1524h] BYREF
  _BYTE s[256]; // [sp+108h] [bp-1504h] BYREF
  char v42[1024]; // [sp+208h] [bp-1404h] BYREF
  char v43[4100]; // [sp+608h] [bp-1004h] BYREF

  v2 = 0;
  v33 = 0;
  memset(s, 0, sizeof(s));
  V_LOCK();
  logfmt_raw(v43, 0x1000u, 0, "%s chip_no %d", "ChipSetting_get_addr_CKB_2042", a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_get_addr_CKB_2042",
    29,
    32,
    20,
    v43);
  v31 = a2;
  v34[0] = 0;
  v34[2] = 1;
  v34[1] = 0;
  v34[3] = 0;
  v5 = calloc(12 * a2, 1u);
  v23 = &v33;
  v6 = (void (__fastcall *)(int *, _DWORD *, int, void *, int *, int, int, _DWORD))a1[59];
  ptr = v5;
  v6(a1, v34, a2, v5, &v33, v24, 3000, 0);
  V_LOCK();
  V_INT((int)v35, "chain", a1[50]);
  logfmt_raw(
    v43,
    0x1000u,
    0,
    v36,
    v35[0],
    v35[1],
    v35[2],
    v35[3],
    v35[4],
    v35[5],
    v35[6],
    v36,
    "%s detect %d chips",
    "ChipSetting_get_addr_CKB_2042",
    v33,
    a1[68]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_get_addr_CKB_2042",
    29,
    43,
    60,
    v43);
  if ( v33 > 0 )
  {
    v26 = "ChipSetting_get_addr_CKB_2042";
    v29 = 0;
    v28 = "[GET ADDR] chip_type %04x/%04x chip %d reg %d addr %02x";
    v27 = "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c";
    v7 = (unsigned __int16 *)ptr;
    do
    {
      while ( 1 )
      {
        v8 = *v7;
        V_LOCK();
        v9 = *((unsigned __int8 *)v7 + 4);
        LOWORD(v8) = __rev16(v8);
        v10 = v7[3];
        v24 = a1[68];
        v25 = v2++;
        logfmt_raw(v43, 0x1000u, 0, v28, (unsigned __int16)v8, v24, v25, v10, v9);
        V_UNLOCK();
        zlog(g_zc, v27, 150, v26, 29, 47, 20, v43);
        if ( a1[68] == (unsigned __int16)v8 )
          break;
        v7 += 6;
        if ( v33 <= (int)v2 )
          goto LABEL_7;
      }
      v7 += 6;
      v11 = a1[93];
      v12 = *((unsigned __int8 *)v7 - 8);
      ++v29;
      v13 = v12 / v11;
      s[v13] = 1;
      V_LOCK();
      v14 = a1[50];
      v32 = (int **)v37;
      V_INT((int)v37, "chain", v14);
      v15 = v32;
      v32 = &v23;
      logfmt_raw(
        v43,
        0x1000u,
        0,
        v15[7],
        *v15,
        v15[1],
        v15[2],
        v15[3],
        v15[4],
        v15[5],
        v15[6],
        v15[7],
        "chip_id:%d, %03d",
        v13,
        *((unsigned __int8 *)v7 - 8));
      V_UNLOCK();
      zlog(g_zc, v27, 150, v26, 29, 53, 20, v43);
    }
    while ( v33 > (int)v2 );
LABEL_7:
    v2 = (const char *)v29;
  }
  else
  {
    v29 = 0;
  }
  if ( a1[70] > v29 )
  {
    V_LOCK();
    V_INT((int)v38, "chain", a1[50]);
    V_STR(v40, "error", "asic num error");
    logfmt_raw(
      v43,
      0x1000u,
      0,
      v39,
      v38[0],
      v38[1],
      v38[2],
      v38[3],
      v38[4],
      v38[5],
      v38[6],
      v39,
      v40[0],
      v40[1],
      v40[2],
      v40[3],
      v40[4],
      v40[5],
      v40[6],
      v40[7],
      "detected asic num less than design(%d<%d)",
      v29,
      a1[70]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_get_addr_CKB_2042",
      29,
      59,
      100,
      v43);
    memset(v42, 0, sizeof(v42));
    v42[0] = 10;
    if ( v31 )
    {
      v26 = v2;
      v17 = s;
      v18 = v42;
      v19 = 0;
      v20 = v31;
      do
      {
        while ( *v17++ )
        {
          if ( v20 == ++v19 )
            goto LABEL_15;
        }
        v22 = v19++;
        sprintf(v18, "%02d ", v22);
        v18 += 3;
      }
      while ( v20 != v19 );
LABEL_15:
      v2 = v26;
    }
    V_LOCK();
    logfmt_raw(v43, 0x1000u, 0, "bad asic:\n%s\n", v42);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_get_addr_CKB_2042",
      29,
      69,
      40,
      v43);
  }
  free(ptr);
  result = v33;
  a1[92] = (int)v2;
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0004DC98) --------------------------------------------------------
int __fastcall sub_4DC98(int *a1)
{
  int v2; // r6
  int v3; // r4

  v2 = a1[70];
  v3 = 3;
  while ( 1 )
  {
    sub_4D778(a1, v2);
    if ( a1[92] == v2 )
      break;
    if ( !--v3 )
      return 12;
  }
  return 0;
}

//----- (0004DCD8) --------------------------------------------------------
int __fastcall parameter_update_ckb(int a1, char a2, int a3, char a4, int a5)
{
  int v8; // r1
  int result; // r0
  int v10; // r3
  int v11; // r7
  double v12; // r0

  if ( *(_BYTE *)(a1 + 204) )
    return 0;
  if ( (unsigned int)(a3 - 50) <= 0x2EE )
    v8 = a2 & 1;
  else
    v8 = 0;
  if ( v8 )
  {
    v11 = a1 + 928;
    LODWORD(v12) = sub_DD46C(*(_QWORD *)(a1 + 920));
    *(_QWORD *)(v11 - 8) = (unsigned __int64)(v12 / (double)a3 * *(float *)(a1 + 900));
    *(float *)(a1 + 900) = (float)a3;
  }
  result = 0;
  if ( (unsigned int)(a5 - 1400) <= 0x12C )
    v10 = a4 & 1;
  else
    v10 = 0;
  if ( v10 )
    *(_DWORD *)(a1 + 904) = a5;
  return result;
}
// 4DD60: variable 'v12' is possibly undefined

//----- (0004DD88) --------------------------------------------------------
int __fastcall sub_4DD88(unsigned int *a1, int a2, int a3, _BYTE *a4, _DWORD *a5, signed int *a6, _DWORD *a7)
{
  unsigned int v8; // r4
  int v12; // r9
  int v13; // r3
  int v14; // lr
  _DWORD *v15; // r6
  int v16; // r12
  int v17; // r0
  int v18; // r3
  signed int v19; // r0
  int v20; // r7
  int v21; // r4
  int v22; // r12
  int v24; // r1
  int v25; // r2
  int v26; // r0
  signed int v27; // r1
  char v28[4080]; // [sp+10h] [bp-1004h] BYREF

  v8 = a1[190];
  v12 = *(_BYTE *)(a2 + 10) & 0x7F;
  v13 = *(_DWORD *)(v8 + 8 * v12);
  v14 = *(_DWORD *)(v8 + 8 * v12 + 4);
  v15 = (_DWORD *)(a3 + 48);
  *(_DWORD *)a3 = v13;
  *(_DWORD *)(a3 + 4) = v14;
  *a7 = v13;
  strcpy((char *)(a3 + 16), (const char *)(v8 + 32 * (v12 + 32)));
  v16 = *(_DWORD *)(v8 + 48 * v12 + 5156);
  v17 = *(_DWORD *)(v8 + 48 * v12 + 5160);
  v18 = *(_DWORD *)(v8 + 48 * v12 + 5164);
  *(_DWORD *)(a3 + 48) = *(_DWORD *)(v8 + 48 * v12 + 5152);
  *(_DWORD *)(a3 + 52) = v16;
  *(_DWORD *)(a3 + 56) = v17;
  *(_DWORD *)(a3 + 60) = v18;
  *(_DWORD *)(a3 + 58) = *(_DWORD *)(a2 + 3);
  *(_WORD *)(a3 + 62) = *(_WORD *)(a2 + 7);
  LOBYTE(v18) = *(_BYTE *)(a2 + 9);
  *(_BYTE *)(a3 + 65) = v12;
  *(_BYTE *)(a3 + 64) = v18;
  v19 = *(unsigned __int8 *)(a2 + 3) / a1[93];
  if ( v19 >= (int)a1[70] )
  {
    v26 = rand();
    sub_DD144(v26, a1[70]);
    v19 = v27;
  }
  *a6 = v19;
  *(_DWORD *)(a3 + 8) = v19;
  *(_DWORD *)(a3 + 12) = (*(_BYTE *)(a2 + 8) & 3)
                       + 4 * ((*(_BYTE *)(a2 + 7) << 6) & 0x40 | (*(unsigned __int8 *)(a2 + 8) >> 2));
  v20 = BM_CRC5((_BYTE *)(a2 + 2), 75);
  v21 = *(_BYTE *)(a2 + 11) & 0x1F;
  if ( v20 == v21 )
  {
    v22 = *(_DWORD *)(a3 + 52);
    v24 = *(_DWORD *)(a3 + 56);
    v25 = *(_DWORD *)(a3 + 60);
    *a5 = *v15;
    a5[1] = v22;
    a5[2] = v24;
    a5[3] = v25;
    *a4 = 1;
    return 0;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v28, 0x1000u, 0, "get nonce crc error calc value %04x expected value %04x", v20, v21);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/backend_ckb_2042/backend_ckb_2042.c",
      171,
      "packet_2_nonce_ckb",
      18,
      204,
      100,
      v28);
    return 11;
  }
}
// 4DF68: variable 'v27' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0004DF74) --------------------------------------------------------
int __fastcall packet_2_nonce_ckb(unsigned int *a1, int a2, int a3, _BYTE *a4, _DWORD *a5, signed int *a6, _DWORD *a7)
{
  if ( *(char *)(a2 + 11) < 0 )
    return sub_4DD88(a1, a2, a3, a4, a5, a6, a7);
  else
    return 10;
}

//----- (0004DF8C) --------------------------------------------------------
int __fastcall get_sale_hashrate_ckb(int a1, double *a2, _DWORD *a3)
{
  double v5; // d8
  void (__fastcall *v7)(int, double *); // r5
  const char *v8; // r4
  double v10; // [sp+0h] [bp-Ch] BYREF

  v5 = 0.0;
  v7 = *(void (__fastcall **)(int, double *))(a1 + 120);
  v10 = 0.0;
  v7(a1, &v10);
  if ( *(_BYTE *)(a1 + 248) != 75 || *(_BYTE *)(a1 + 249) != 55 || *(_BYTE *)(a1 + 250) )
    return 24;
  api_get_eeprom_chip_bin(*(_DWORD *)(a1 + 196));
  v8 = (const char *)(api_get_eeprom_chip_ft(*(_DWORD *)(a1 + 196)) + 5);
  if ( !strncmp(v8, "B1C1", 4u) )
  {
    v5 = 0.982900023;
  }
  else if ( !strncmp(v8, "B2C1", 4u) )
  {
    v5 = 0.970799983;
  }
  *a2 = v10 * v5;
  *a3 = 50;
  return 0;
}

//----- (0004E088) --------------------------------------------------------
int __fastcall get_qualify_hashrate_ckb(int a1, double *a2)
{
  double v4; // d8
  void (__fastcall *v5)(int, double *); // r2
  const char *v6; // r4
  double v8; // [sp+0h] [bp-Ch] BYREF

  v4 = 0.0;
  v5 = *(void (__fastcall **)(int, double *))(a1 + 120);
  v8 = 0.0;
  v5(a1, &v8);
  if ( *(_BYTE *)(a1 + 248) != 75 || *(_BYTE *)(a1 + 249) != 55 || *(_BYTE *)(a1 + 250) )
    return 24;
  api_get_eeprom_chip_bin(*(_DWORD *)(a1 + 196));
  v6 = (const char *)(api_get_eeprom_chip_ft(*(_DWORD *)(a1 + 196)) + 5);
  if ( !strncmp(v6, "B1C1", 4u) )
  {
    v4 = 0.987500012;
  }
  else if ( !strncmp(v6, "B2C1", 4u) )
  {
    v4 = 0.975000024;
  }
  *a2 = v8 * v4;
  return 0;
}

//----- (0004E178) --------------------------------------------------------
int __fastcall sub_4E178(char *a1, _DWORD *a2, _DWORD *a3, int a4)
{
  char v4; // r7
  int result; // r0
  int v10; // r3
  int v11; // r2
  char v12; // [sp+17h] [bp-1005h] BYREF
  char v13[4100]; // [sp+18h] [bp-1004h] BYREF

  v4 = a4;
  *a3 = 0;
  *a2 = -64;
  if ( pic1704_write_iic(*a1, a4) )
  {
    usleep(0x2710u);
    result = pic1704_read_iic(*a1, v4, &v12);
    if ( result )
    {
      v10 = v12;
      *a3 = 1;
      *a2 = v10;
      return result;
    }
    V_LOCK();
    logfmt_raw(v13, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)a1, a4);
    V_UNLOCK();
    v11 = 930;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v13, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)a1, a4);
    V_UNLOCK();
    v11 = 919;
  }
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_read_sensor_temp_local_on_pic_CKB_2042",
    50,
    v11,
    20,
    v13);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0004E2C0) --------------------------------------------------------
int __fastcall sub_4E2C0(char *a1, _DWORD *a2, _DWORD *a3, int a4)
{
  char v4; // r7
  int result; // r0
  int v10; // r3
  int v11; // r2
  char v12; // [sp+17h] [bp-1005h] BYREF
  char v13[4100]; // [sp+18h] [bp-1004h] BYREF

  v4 = a4;
  *a3 = 0;
  *a2 = -64;
  if ( pic1704_write_iic(*a1, a4) )
  {
    usleep(0x2710u);
    result = pic1704_read_iic(*a1, v4, &v12);
    if ( result )
    {
      v10 = v12;
      *a3 = 1;
      *a2 = v10 + 15;
      return result;
    }
    V_LOCK();
    logfmt_raw(v13, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)a1, a4);
    V_UNLOCK();
    v11 = 956;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v13, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)a1, a4);
    V_UNLOCK();
    v11 = 945;
  }
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_read_sensor_temp_remote_on_pic_CKB_2042",
    51,
    v11,
    20,
    v13);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0004E40C) --------------------------------------------------------
int __fastcall sub_4E40C(unsigned int *a1, _DWORD *a2, _DWORD *a3, int a4)
{
  int v8; // r3
  int v10; // [sp+34h] [bp-1030h]
  _BYTE v11[4]; // [sp+3Ch] [bp-1028h] BYREF
  _DWORD v12[7]; // [sp+40h] [bp-1024h] BYREF
  int v13; // [sp+5Ch] [bp-1008h]
  char v14[4100]; // [sp+60h] [bp-1004h] BYREF

  V_LOCK();
  logfmt_raw(
    v14,
    0x1000u,
    0,
    "%s chain[%d] iic_addr:%d",
    "ChipSetting_read_sensor_temp_local_on_ctrlboard_CKB_2042",
    *a1,
    a4);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_read_sensor_temp_local_on_ctrlboard_CKB_2042",
    56,
    970,
    20,
    v14);
  *a3 = 0;
  v10 = tsensor_read(*a1, a4, 0, (int)v11, 2u);
  if ( v10 == 2 )
  {
    v8 = v11[0];
    *a3 = 1;
    *a2 = v8;
    V_LOCK();
    V_INT((int)v12, "chain", (int)*a1);
    logfmt_raw(
      v14,
      0x1000u,
      0,
      v13,
      v12[0],
      v12[1],
      v12[2],
      v12[3],
      v12[4],
      v12[5],
      v12[6],
      v13,
      "read ctrlboard temp, local[%02x] %d",
      a4,
      *a2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_read_sensor_temp_local_on_ctrlboard_CKB_2042",
      56,
      982,
      20,
      v14);
  }
  else
  {
    *a2 = -64;
    v10 = -1;
    V_LOCK();
    logfmt_raw(v14, 0x1000u, 0, "failed to read ctrlboard-temp for chain %d", *a1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_read_sensor_temp_local_on_ctrlboard_CKB_2042",
      56,
      977,
      80,
      v14);
  }
  return v10;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0004E5F0) --------------------------------------------------------
int __fastcall sub_4E5F0(unsigned int *a1, unsigned __int8 *a2, _DWORD *a3, _DWORD *a4, unsigned __int8 a5)
{
  int result; // r0
  int v10; // r3
  _BYTE v11[4]; // [sp+14h] [bp-1004h] BYREF
  char v12[4072]; // [sp+18h] [bp-1000h] BYREF

  *a4 = 0;
  result = tsensor_read(*a1, a5, 0, (int)v11, 2u);
  if ( result == 2 )
  {
    v10 = v11[0];
    *a4 = 1;
    *a3 = v10 + *a2;
  }
  else
  {
    *a3 = -64;
    V_LOCK();
    logfmt_raw(v12, 0x1000u, 0, "failed to read ctrlboard-temp for chain %d", *a1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_read_sensor_temp_remote_on_ctrlboard_CKB_2042",
      57,
      996,
      80,
      v12);
    return -1;
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0004E6E4) --------------------------------------------------------
int __fastcall softreset_all_chip_ckb(int *a1)
{
  void (__fastcall *v2)(int *, _DWORD *); // r3
  _DWORD v4[2]; // [sp+0h] [bp-14h] BYREF
  int v5; // [sp+8h] [bp-Ch]
  int v6; // [sp+Ch] [bp-8h]

  sub_4ACC4((int)a1);
  usleep((__useconds_t)"rl_kda_2110");
  v5 = 0;
  v6 = 0;
  v2 = (void (__fastcall *)(int *, _DWORD *))a1[55];
  LOBYTE(v5) = 1;
  HIWORD(v5) = 8;
  LOBYTE(v6) = -1;
  v4[1] = 0;
  v4[0] = 0;
  v2(a1, v4);
  sub_4ADEC(a1, 255);
  return 0;
}

//----- (0004E754) --------------------------------------------------------
int __fastcall sub_4E754(_DWORD *a1, int a2, int a3, _DWORD *a4, _DWORD *a5)
{
  char v5; // r8
  int (__fastcall *v9)(_DWORD *, int *); // r3
  signed int v11; // r2
  unsigned __int8 *v12; // r0
  unsigned __int8 *v13; // r4
  void (__fastcall *v14)(_DWORD *, int *, signed int, unsigned __int8 *, int *); // r5
  int v15; // r5
  signed int v16; // [sp+14h] [bp-20h]
  int v17; // [sp+1Ch] [bp-18h] BYREF
  int v18; // [sp+20h] [bp-14h] BYREF
  int v19; // [sp+24h] [bp-10h]
  int v20; // [sp+28h] [bp-Ch]
  int v21; // [sp+2Ch] [bp-8h]

  v5 = a2;
  v20 = 0;
  v19 = 0;
  v21 = 0;
  v18 = a3 | 0x1980000;
  BYTE1(v20) = a2;
  v9 = (int (__fastcall *)(_DWORD *, int *))a1[54];
  HIWORD(v20) = 255;
  if ( v9(a1, &v18) )
    return 0;
  usleep(0xC350u);
  *a4 = 0;
  v19 = 0;
  *a5 = 0;
  v11 = a1[70];
  v20 = 0;
  v21 = 0;
  v18 = 0;
  if ( v11 >= 1 )
    v11 = 1;
  v16 = v11;
  v12 = (unsigned __int8 *)calloc(v11, 0xCu);
  BYTE1(v20) = v5;
  v13 = v12;
  v14 = (void (__fastcall *)(_DWORD *, int *, signed int, unsigned __int8 *, int *))a1[59];
  HIWORD(v20) = 255;
  v14(a1, &v18, v16, v12, &v17);
  v15 = v17;
  if ( v17 == 1 && a2 == v13[4] )
  {
    *a4 = *(_DWORD *)v13;
    *a5 = 1;
  }
  free(v13);
  return v15;
}

//----- (0004E868) --------------------------------------------------------
int __fastcall read_sensor_temp_remote_ckb(int a1, int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int v13; // r0
  int v14; // r1
  int v15; // r3
  int v16; // r2
  int v17; // [sp+8h] [bp-8h] BYREF
  int v18; // [sp+Ch] [bp-4h] BYREF

  if ( a6 )
  {
    if ( a6 == 1 )
    {
      v14 = *(unsigned __int8 *)(*(_DWORD *)(a1 + 432) + a9);
      *a3 = 0;
      *a2 = -64;
      v13 = sub_4E754((_DWORD *)a1, v14, 256, &v17, &v18);
      if ( v13 == 1 )
      {
        v15 = HIBYTE(v17);
        v16 = v18;
        if ( *(_DWORD *)(a1 + 456) == 1 )
          v15 = HIBYTE(v17) - 64;
        *a2 = v15;
        *a3 = v16;
        return 0;
      }
    }
    else
    {
      if ( a6 != 2 )
        return 4;
      v13 = sub_4E5F0((unsigned int *)(a1 + 200), (unsigned __int8 *)(a1 + 912), a2, a3, a9);
    }
  }
  else
  {
    v13 = sub_4E2C0((char *)(a1 + 200), a2, a3, a9);
  }
  if ( v13 == -1 )
    return 4;
  return 0;
}

//----- (0004E94C) --------------------------------------------------------
int __fastcall read_sensor_temp_local_ckb(
        _DWORD *a1,
        int *a2,
        _DWORD *a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9)
{
  int v11; // r0
  int v14; // r1
  int v15; // r3
  int v16; // r2
  int v17; // [sp+8h] [bp-8h] BYREF
  int v18; // [sp+Ch] [bp-4h] BYREF

  if ( a6 )
  {
    if ( a6 == 1 )
    {
      v14 = *(unsigned __int8 *)(a1[108] + a9);
      *a3 = 0;
      *a2 = -64;
      v11 = sub_4E754(a1, v14, 0, &v17, &v18);
      if ( v11 == 1 )
      {
        v15 = HIBYTE(v17);
        v16 = v18;
        if ( a1[114] == 1 )
          v15 = HIBYTE(v17) - 64;
        *a2 = v15;
        *a3 = v16;
        return 0;
      }
    }
    else
    {
      if ( a6 != 2 )
        return 4;
      v11 = sub_4E40C(a1 + 50, a2, a3, a9);
    }
  }
  else
  {
    v11 = sub_4E178((char *)a1 + 200, a2, a3, a9);
  }
  if ( v11 == -1 )
    return 4;
  return 0;
}

//----- (0004EA1C) --------------------------------------------------------
int __fastcall set_baud_ckb_0(int a1, int a2)
{
  int v4; // r4
  int v5; // r4
  _DWORD v7[4]; // [sp+30h] [bp-1034h] BYREF
  _DWORD v8[7]; // [sp+40h] [bp-1024h] BYREF
  int v9; // [sp+5Ch] [bp-1008h]
  char v10[4100]; // [sp+60h] [bp-1004h] BYREF

  v7[2] = 6291457;
  v7[1] = 0;
  v7[3] = 0;
  v7[0] = 0;
  if ( a2 == 1500000 )
    goto LABEL_24;
  if ( a2 <= 1500000 )
  {
    if ( a2 == 460800 )
    {
      v4 = 1568;
      goto LABEL_10;
    }
    if ( a2 > 460800 )
    {
      if ( a2 == 921600 || a2 == 1041666 )
      {
        v4 = 544;
        goto LABEL_10;
      }
    }
    else if ( a2 == 38400 )
    {
      v4 = 20512;
      goto LABEL_10;
    }
    goto LABEL_16;
  }
  if ( a2 == 3125000 )
  {
LABEL_23:
    v4 = 32;
    goto LABEL_10;
  }
  if ( a2 <= 3125000 )
  {
    if ( a2 != 1562500 )
    {
      if ( a2 != 3000000 )
        goto LABEL_16;
      goto LABEL_23;
    }
LABEL_24:
    v4 = 288;
    goto LABEL_10;
  }
  if ( a2 == 6250000 )
  {
    v4 = 289;
    goto LABEL_9;
  }
  if ( a2 != 12500000 )
  {
LABEL_16:
    v4 = 6688;
    goto LABEL_10;
  }
  v4 = 33;
LABEL_9:
  (*(void (__fastcall **)(int, int))(a1 + 176))(a1, 1);
LABEL_10:
  v7[0] = v4;
  V_LOCK();
  V_INT((int)v8, "chain", *(int *)(a1 + 200));
  logfmt_raw(
    v10,
    0x1000u,
    0,
    v9,
    v8[0],
    v8[1],
    v8[2],
    v8[3],
    v8[4],
    v8[5],
    v8[6],
    v9,
    "set fuart cfg value %08x/%d",
    v4,
    a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_fuart_cfg_CKB_2042",
    30,
    421,
    40,
    v10);
  v5 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v7);
  usleep(0x2710u);
  return v5;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0004EC18) --------------------------------------------------------
int __fastcall sub_4EC18(int a1)
{
  int v2; // r4
  _DWORD v4[4]; // [sp+28h] [bp-1034h] BYREF
  _DWORD v5[7]; // [sp+38h] [bp-1024h] BYREF
  int v6; // [sp+54h] [bp-1008h]
  char v7[4100]; // [sp+58h] [bp-1004h] BYREF

  v4[0] = 5381904;
  v4[2] = 1835009;
  v4[3] = 0;
  v4[1] = 0;
  V_LOCK();
  V_INT((int)v5, "chain", *(int *)(a1 + 200));
  logfmt_raw(v7, 0x1000u, 0, v6, v5[0], v5[1], v5[2], v5[3], v5[4], v5[5], v5[6], v6, "set misc ctrl %08x", 5381904);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_misc_ctrl_CKB_2042",
    30,
    167,
    40,
    v7);
  v2 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v4);
  usleep(0x2710u);
  return v2;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0004ED24) --------------------------------------------------------
int __fastcall top_init_ckb(int *a1)
{
  int v2; // r7
  int v3; // r4
  int v4; // r0
  int v5; // r1
  char v6; // r3
  void (__fastcall *v7)(int *, int, int); // r3
  _DWORD v9[7]; // [sp+28h] [bp-1024h] BYREF
  int v10; // [sp+44h] [bp-1008h]
  char v11[4100]; // [sp+48h] [bp-1004h] BYREF

  V_LOCK();
  V_INT((int)v9, "chain", a1[50]);
  logfmt_raw(v11, 0x1000u, 0, v10, v9[0], v9[1], v9[2], v9[3], v9[4], v9[5], v9[6], v10, "top_init_ckb");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/backend_ckb_2042/backend_ckb_2042.c",
    171,
    "top_init_ckb",
    12,
    399,
    40,
    v11);
  v2 = a1[70];
  v3 = a1[108];
  v4 = sub_DCEB0(256, (unsigned __int8)v2);
  if ( (_BYTE)v2 )
  {
    v5 = v3 - 1;
    v6 = 0;
    do
    {
      *(_BYTE *)++v5 = v6;
      v6 += v4;
    }
    while ( v5 != v3 - 1 + (unsigned __int8)v2 );
    v3 = a1[108];
  }
  v7 = (void (__fastcall *)(int *, int, int))a1[52];
  a1[93] = v4;
  v7(a1, v3, v2);
  sub_4B7E0((int)a1, 0);
  sub_4EC18((int)a1);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0004EE54) --------------------------------------------------------
int __fastcall dhash_start_ckb(int a1)
{
  int v2; // r3
  int result; // r0
  _DWORD v4[7]; // [sp+28h] [bp-1020h] BYREF
  int v5; // [sp+44h] [bp-1004h]
  char v6[4096]; // [sp+48h] [bp-1000h] BYREF

  V_LOCK();
  V_INT((int)v4, "chain", *(int *)(a1 + 200));
  logfmt_raw(v6, 0x1000u, 0, v5, v4[0], v4[1], v4[2], v4[3], v4[4], v4[5], v4[6], v5, "dhash_start_ckb");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/backend_ckb_2042/backend_ckb_2042.c",
    171,
    "dhash_start_ckb",
    15,
    419,
    40,
    v6);
  sub_4EC18(a1);
  v2 = *(unsigned __int8 *)(a1 + 404);
  result = 0;
  *(_BYTE *)(a1 + 205) = 1;
  if ( !v2 )
    *(_DWORD *)(a1 + 408) = (int)*(float *)(a1 + 900);
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0004EF34) --------------------------------------------------------
int get_pcba_test_level_ckb()
{
  return 0;
}

//----- (0004EF3C) --------------------------------------------------------
int __fastcall makeup_chip_addr_ae(_BYTE *a1, unsigned int a2)
{
  int result; // r0
  _BYTE *v5; // r2
  char v6; // r3

  result = sub_DCEB0(256, a2);
  if ( a2 )
  {
    v5 = a1;
    v6 = 0;
    do
    {
      *v5++ = v6;
      v6 += result;
    }
    while ( &a1[a2] != v5 );
  }
  return result;
}

//----- (0004EF80) --------------------------------------------------------
void __fastcall get_core_regdata_ckb_2042(int a1, __int16 a2)
{
  int v2; // r5
  void *v4; // r6
  int v5; // [sp+14h] [bp-14h] BYREF
  _BYTE v6[10]; // [sp+18h] [bp-10h] BYREF
  __int16 v7; // [sp+22h] [bp-6h]
  char v8; // [sp+24h] [bp-4h]

  v2 = *(_DWORD *)(a1 + 280);
  v7 = a2;
  v6[8] = 1;
  v5 = 0;
  v6[9] = 0;
  v8 = 0;
  v4 = calloc(12 * v2, 1u);
  (*(void (__fastcall **)(int, _BYTE *, int, void *, int *))(a1 + 244))(a1, v6, v2, v4, &v5);
  free(v4);
}

//----- (0004EFFC) --------------------------------------------------------
int get_algo_type_ckb()
{
  return 0;
}

//----- (0004F004) --------------------------------------------------------
int update_chip_info_ckb()
{
  return 0;
}

//----- (0004F00C) --------------------------------------------------------
void *runtime_ctrl_ckb_2042()
{
  void *v0; // r0
  void *v1; // r6
  _QWORD v3[117]; // [sp+0h] [bp-3A8h] BYREF

  memset(v3, 0, sizeof(v3));
  LODWORD(v3[33]) = 6450019;
  LODWORD(v3[31]) = 14155;
  HIDWORD(v3[39]) = 210;
  LODWORD(v3[40]) = 500;
  HIDWORD(v3[41]) = sensor_info_ckb_2042;
  v3[42] = qword_106444;
  v3[43] = qword_10644C;
  v3[44] = qword_106454;
  v0 = calloc(1u, 0x3A8u);
  LODWORD(v3[0]) = backend_init_base;
  HIDWORD(v3[0]) = reset_base;
  HIDWORD(v3[1]) = dhash_mining_stop_base;
  HIDWORD(v3[2]) = backend_exit_base;
  LODWORD(v3[1]) = dhash_mining_start_base;
  LODWORD(v3[2]) = dhash_mining_reset_base;
  LODWORD(v3[3]) = push_work_base;
  LODWORD(v3[4]) = pop_ans_base;
  LODWORD(v3[6]) = softreset_all_chip_ckb;
  HIDWORD(v3[3]) = async_push_work_base;
  HIDWORD(v3[4]) = try_pop_ans_base;
  LODWORD(v3[7]) = work_2_packet_ckb;
  LODWORD(v3[8]) = check_nonce_ckb;
  LODWORD(v3[9]) = global_idx_free_ckb;
  HIDWORD(v3[7]) = packet_2_nonce_ckb;
  HIDWORD(v3[8]) = global_idx_init_ckb;
  HIDWORD(v3[9]) = set_baud_ckb;
  HIDWORD(v3[10]) = sub_4D330;
  HIDWORD(v3[11]) = sub_4AB90;
  LODWORD(v3[10]) = sub_4D44C;
  LODWORD(v3[11]) = sub_4B8D4;
  LODWORD(v3[12]) = sub_4D060;
  LODWORD(v3[13]) = sub_4C8BC;
  LODWORD(v3[14]) = sub_4C024;
  HIDWORD(v3[12]) = sub_4CC84;
  HIDWORD(v3[13]) = sub_4C3C8;
  HIDWORD(v3[14]) = get_chip_status_ckb;
  HIDWORD(v3[15]) = get_sale_hashrate_ckb;
  HIDWORD(v3[16]) = get_qualify_nonce_num_ckb;
  LODWORD(v3[15]) = get_theory_hashrate_ckb;
  LODWORD(v3[16]) = get_qualify_hashrate_ckb;
  LODWORD(v3[17]) = set_sensor_extern_mode_ckb;
  HIDWORD(v3[17]) = read_sensor_temp_local_ckb;
  LODWORD(v3[18]) = read_sensor_temp_remote_ckb;
  HIDWORD(v3[18]) = parameter_update_ckb;
  LODWORD(v3[19]) = overclock_update_ckb;
  LODWORD(v3[20]) = get_packet_remain_len_ckb;
  HIDWORD(v3[22]) = sub_4DC98;
  HIDWORD(v3[19]) = get_pcba_test_level_ckb;
  HIDWORD(v3[23]) = top_init_ckb;
  LODWORD(v3[26]) = set_chipaddr_base;
  LODWORD(v3[27]) = set_chip_reg_base;
  LODWORD(v3[22]) = set_frequency_ckb;
  HIDWORD(v3[27]) = set_core_reg_base_9;
  LODWORD(v3[28]) = set_core_reg_base_9;
  LODWORD(v3[29]) = sync_get_status_base;
  LODWORD(v3[23]) = sub_4B8EC;
  HIDWORD(v3[30]) = sync_get_core_reg_base3;
  v3[34] = 0x100002042LL;
  v3[35] = 0x580000005CLL;
  v3[36] = 0x400000160LL;
  LODWORD(v3[24]) = dhash_start_ckb;
  HIDWORD(v3[37]) = 2;
  LODWORD(v3[47]) = 39;
  HIDWORD(v3[26]) = set_inactive_base;
  HIDWORD(v3[95]) = 128;
  v3[96] = 0x1000000048LL;
  HIDWORD(v3[28]) = set_core_enable_base;
  v3[97] = 0xC00000036LL;
  HIDWORD(v3[29]) = sync_get_chip_reg_base;
  v1 = v0;
  v3[112] = 0x4426400042480000LL;
  LOBYTE(v3[114]) = 12;
  v3[115] = 5166878;
  LODWORD(v3[113]) = 1520;
  memcpy(v0, v3, 0x3A8u);
  return v1;
}
// 4EC14: using guessed type int set_baud_ckb();
// 106440: using guessed type _UNKNOWN *sensor_info_ckb_2042;
// 106444: using guessed type __int64;
// 10644C: using guessed type __int64;
// 106454: using guessed type __int64;

//----- (0004F3A8) --------------------------------------------------------
int get_chip_status_dash()
{
  return 0;
}

//----- (0004F3B0) --------------------------------------------------------
int __fastcall get_theory_hashrate_dash(int a1, double *a2)
{
  float v2; // s14

  v2 = *(float *)(a1 + 900);
  *a2 = v2 * 1104.0 * 1000.0 * 1000.0 * 0.98;
  return 0;
}

//----- (0004F3F8) --------------------------------------------------------
int __fastcall get_sale_hashrate_dash(int a1, double *a2, _DWORD *a3)
{
  int result; // r0
  double v7; // [sp+0h] [bp-8h] BYREF

  v7 = 0.0;
  (*(void (__fastcall **)(int, double *))(a1 + 120))(a1, &v7);
  if ( *(_BYTE *)(a1 + 248) != 68 )
    return 24;
  if ( *(_BYTE *)(a1 + 249) != 57 )
    return 24;
  result = *(unsigned __int8 *)(a1 + 250);
  if ( *(_BYTE *)(a1 + 250) )
    return 24;
  *a2 = v7 * 0.97;
  *a3 = 50;
  return result;
}

//----- (0004F480) --------------------------------------------------------
int __fastcall get_qualify_hashrate_dash(int a1, double *a2)
{
  int result; // r0
  double v5; // [sp+0h] [bp-Ch] BYREF

  v5 = 0.0;
  (*(void (__fastcall **)(int, double *))(a1 + 120))(a1, &v5);
  if ( *(_BYTE *)(a1 + 248) != 68 )
    return 24;
  if ( *(_BYTE *)(a1 + 249) != 57 )
    return 24;
  result = *(unsigned __int8 *)(a1 + 250);
  if ( *(_BYTE *)(a1 + 250) )
    return 24;
  *a2 = v5 * 0.98;
  return result;
}

//----- (0004F500) --------------------------------------------------------
int __fastcall get_qualify_nonce_num_dash(int a1, float *a2)
{
  int v4; // r0
  char v5; // r1
  int v6; // r3
  __int64 v7; // r0
  double v8; // r0
  double v9; // d4
  float v11; // s14
  double v12; // [sp+0h] [bp-Ch] BYREF

  v12 = 0.0;
  (*(void (__fastcall **)(int, double *))(a1 + 120))(a1, &v12);
  v4 = *(_DWORD *)(a1 + 376);
  v5 = 32 - v4;
  v6 = 1 << (v4 - 32);
  LODWORD(v7) = 1 << v4;
  HIDWORD(v7) = v6 | (1u >> v5);
  LODWORD(v8) = sub_DD46C(v7);
  v9 = v8;
  v11 = v12 / v9 / 92.0 * 0.1;
  *a2 = v11;
  return 0;
}
// 4F550: variable 'v8' is possibly undefined

//----- (0004F590) --------------------------------------------------------
int get_packet_remain_len_dash()
{
  return 7;
}

//----- (0004F598) --------------------------------------------------------
int __fastcall sub_4F598(int a1, __int16 a2, int a3)
{
  _DWORD v4[2]; // [sp+0h] [bp-14h] BYREF
  __int16 v5; // [sp+8h] [bp-Ch]
  __int16 v6; // [sp+Ah] [bp-Ah]
  int v7; // [sp+Ch] [bp-8h]

  v4[0] = a3;
  v7 = 255;
  v4[1] = 0;
  v6 = a2;
  v5 = 1;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 220))(a1, v4);
}

//----- (0004F5DC) --------------------------------------------------------
int __fastcall global_idx_init_dash(int a1)
{
  void *v2; // r0
  void *v3; // r5
  char v5[4096]; // [sp+10h] [bp-1000h] BYREF

  v2 = calloc(0x5808u, 1u);
  *(_DWORD *)(a1 + 760) = v2;
  v3 = v2;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "__custom_data init %p\n", v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/backend_dash_1766/backend_dash_1766.c",
    173,
    "global_idx_init_dash",
    20,
    56,
    20,
    v5);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0004F670) --------------------------------------------------------
int __fastcall sub_4F670(int a1)
{
  _DWORD v3[1025]; // [sp+10h] [bp-1004h] BYREF

  V_LOCK();
  logfmt_raw((char *)v3, 0x1000u, 0, "software_reset %s %02x", "ChipSetting_software_reset_DASH_1766", 68);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_software_reset_DASH_1766",
    36,
    95,
    20,
    v3);
  v3[2] = 4456449;
  v3[3] = 0;
  v3[1] = 0;
  v3[0] = 3;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v3);
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0004F734) --------------------------------------------------------
int __fastcall global_idx_free_dash(int a1)
{
  free(*(void **)(a1 + 760));
  return 0;
}

//----- (0004F748) --------------------------------------------------------
int __fastcall set_sensor_extern_mode_dash(int a1)
{
  int (__fastcall *v2)(int, _DWORD *); // r3
  int v3; // r6
  int result; // r0
  _DWORD v5[2]; // [sp+0h] [bp-10h] BYREF
  int v6; // [sp+8h] [bp-8h]
  int v7; // [sp+Ch] [bp-4h]

  v5[0] = 26806532;
  v6 = 16711680;
  v5[1] = 0;
  v7 = 0;
  v2 = *(int (__fastcall **)(int, _DWORD *))(a1 + 216);
  LOBYTE(v6) = 1;
  v3 = v2(a1, v5);
  usleep((__useconds_t)"rl_kda_2110");
  result = 0;
  if ( !v3 )
    *(_DWORD *)(a1 + 456) = 1;
  return result;
}

//----- (0004F7B0) --------------------------------------------------------
int __fastcall sub_4F7B0(int *a1, int a2)
{
  int v4; // r2
  int (__fastcall *v5)(int *, _DWORD *); // r3
  int v6; // r4
  int v8; // [sp+2Ch] [bp-1038h]
  _DWORD v9[2]; // [sp+30h] [bp-1034h] BYREF
  int v10; // [sp+38h] [bp-102Ch]
  int v11; // [sp+3Ch] [bp-1028h]
  _DWORD v12[7]; // [sp+40h] [bp-1024h] BYREF
  int v13; // [sp+5Ch] [bp-1008h]
  char v14[4100]; // [sp+60h] [bp-1004h] BYREF

  v9[1] = 0;
  v10 = 0;
  v11 = 0;
  v9[0] = 0;
  V_LOCK();
  V_INT((int)v12, "chain", a1[50]);
  logfmt_raw(
    v14,
    0x1000u,
    0,
    v13,
    v12[0],
    v12[1],
    v12[2],
    v12[3],
    v12[4],
    v12[5],
    v12[6],
    v13,
    "set core ticket mask reg %02x tm %02x",
    3,
    a2,
    v8,
    0,
    0,
    0,
    0);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_core_ticket_mask_DASH_1766",
    38,
    141,
    40,
    v14);
  v4 = a1[71];
  LOBYTE(v11) = -1;
  BYTE1(v11) = v4;
  v10 = 196609;
  BYTE2(v11) = 1;
  v5 = (int (__fastcall *)(int *, _DWORD *))a1[55];
  v9[0] = a2;
  v6 = v5(a1, v9);
  usleep(0x3E8u);
  a1[94] = a2;
  return v6;
}
// 4F838: variable 'v8' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0004F8D8) --------------------------------------------------------
int __fastcall work_2_packet_dash(int a1, int a2, _BYTE *a3, _DWORD *a4)
{
  int v5; // r4
  int v7; // r9
  int v8; // lr
  int v9; // r2
  int v10; // r0
  int v11; // r8
  int v12; // lr
  int v13; // r12
  _DWORD *v14; // r2
  int v15; // r8
  int v16; // lr
  int v17; // r12
  const void *v18; // r11
  int v19; // r12
  _BYTE *v20; // r2
  _BYTE *v21; // r3
  char v22; // r1
  int v23; // r4
  __int16 v24; // r0
  int v25; // r3
  __int64 v26; // r0
  int v27; // r4
  int v29; // r5
  int v30; // r6
  int v31; // t1
  int v34; // [sp+1Ch] [bp-2010h]
  int v35; // [sp+20h] [bp-200Ch]
  char v36[4056]; // [sp+28h] [bp-2004h] BYREF
  _DWORD v37[2]; // [sp+1028h] [bp-1004h] BYREF
  char v38; // [sp+1030h] [bp-FFCh]
  char v39; // [sp+1031h] [bp-FFBh]
  __int16 v40; // [sp+1032h] [bp-FFAh]
  int v41; // [sp+1034h] [bp-FF8h]

  v5 = *(_DWORD *)(a1 + 760);
  *a3 = 85;
  a3[2] = 32;
  a3[1] = -86;
  if ( *(_DWORD *)(a1 + 436) == 1 )
    a3[2] = 48;
  v7 = *(unsigned __int8 *)(v5 + 21504);
  v8 = *(_DWORD *)(a2 + 120);
  *(_QWORD *)(v5 + 8 * v7) = *(_QWORD *)a2;
  v9 = 12 * (__int16)v7 + 19968;
  *(_DWORD *)(v5 + 4 * (v7 + 3840)) = v8;
  v34 = a2 + 8;
  v10 = *(_DWORD *)(a2 + 160);
  *(_DWORD *)(v5 + v9) = *(_DWORD *)(a2 + 156);
  *(_DWORD *)(v5 + v9 + 4) = v10;
  v11 = *(_DWORD *)(a2 + 128);
  v12 = *(_DWORD *)(a2 + 132);
  v13 = *(_DWORD *)(a2 + 136);
  v14 = (_DWORD *)(v5 + 32 * (*(unsigned __int8 *)(v5 + 21504) + 496));
  *v14 = *(_DWORD *)(a2 + 124);
  v14[1] = v11;
  v14[2] = v12;
  v14[3] = v13;
  v15 = *(_DWORD *)(a2 + 144);
  v16 = *(_DWORD *)(a2 + 148);
  v17 = *(_DWORD *)(a2 + 152);
  v14[4] = *(_DWORD *)(a2 + 140);
  v18 = (const void *)(a2 + 40);
  v14[6] = v16;
  v14[7] = v17;
  v14[5] = v15;
  strcpy((char *)(v5 + 32 * (*(unsigned __int8 *)(v5 + 21504) + 32)), (const char *)(a2 + 8));
  memcpy((void *)(v5 + 80 * *(unsigned __int8 *)(v5 + 21504) + 5120), (const void *)(a2 + 40), 0x50u);
  v19 = *(unsigned __int8 *)(v5 + 21504);
  *(_QWORD *)(v5 + 8 * (v19 + 2689)) = *(_QWORD *)(a2 + 168);
  a3[3] = v19;
  *(_BYTE *)(v5 + 21504) = (v19 + 1) & 0x7F;
  memcpy(a3 + 4, (const void *)(a2 + 40), 0x50u);
  v20 = a3;
  v21 = (_BYTE *)a2;
  do
  {
    v22 = v21[40];
    v21 += 4;
    v20[7] = v22;
    v20[6] = v21[37];
    v20[5] = v21[38];
    v20[4] = v21[39];
    v20 += 4;
  }
  while ( v21 != (_BYTE *)(a2 + 80) );
  v23 = memcmp(&last_header_dash, (const void *)(a2 + 40), 0x50u);
  if ( !v23 )
  {
    V_LOCK();
    logfmt_raw((char *)v37, 0x1000u, 0, "found repeat work");
    V_UNLOCK();
    v29 = a2 + 39;
    v30 = a2 + 119;
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/backend_dash_1766/backend_dash_1766.c",
      173,
      "work_2_packet_dash",
      18,
      125,
      80,
      v37);
    v35 = (unsigned __int8)a3[3];
    do
    {
      v31 = *(unsigned __int8 *)++v29;
      snprintf(&v36[v23], 4096 - v23, "%02x ", v31);
      v23 += 3;
    }
    while ( v29 != v30 );
    V_LOCK();
    logfmt_raw((char *)v37, 0x1000u, 0, "dash dump work jobid %s, work count %d", v34, v35);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/backend_dash_1766/backend_dash_1766.c",
      173,
      "dump_work_dash",
      14,
      75,
      20,
      v37);
    V_LOCK();
    logfmt_raw((char *)v37, 0x1000u, 0, "dump work: %s", v36);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/backend_dash_1766/backend_dash_1766.c",
      173,
      "dump_work_dash",
      14,
      76,
      20,
      v37);
  }
  memcpy(&last_header_dash, v18, 0x50u);
  v24 = BM_CRC16(a3 + 2, 82);
  a3[85] = v24;
  a3[84] = HIBYTE(v24);
  v25 = *(unsigned __int8 *)(a1 + 205);
  *a4 = 86;
  if ( v25 && *(_BYTE *)(a1 + 206) )
  {
    sub_4F7B0((int *)a1, 35);
    *(_BYTE *)(a1 + 205) = 0;
  }
  v26 = 3435973837LL * (unsigned int)++dword_1197D4;
  v27 = dword_1197D4 - 20 * (HIDWORD(v26) >> 4);
  if ( dword_1197D4 == 20 * (HIDWORD(v26) >> 4) )
  {
    sub_4F598(a1, 20, 65280);
    V_LOCK();
    logfmt_raw((char *)v37, 0x1000u, v27, "bridge reset %s %02x", "ChipSetting_bridge_reset_DASH_1766", 68);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_bridge_reset_DASH_1766",
      34,
      82,
      20,
      v37);
    v37[1] = v27;
    v39 = BYTE1(v27);
    v41 = v27;
    v40 = 68;
    v38 = 1;
    v37[0] = 2;
    (*(void (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v37);
    usleep(0x64u);
  }
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1197D4: using guessed type int dword_1197D4;
// 11A7AC: using guessed type int g_zc;

//----- (0004FD88) --------------------------------------------------------
int __fastcall softreset_all_chip_dash(int *a1)
{
  sub_4F670((int)a1);
  usleep((__useconds_t)"rl_kda_2110");
  sub_4F598((int)a1, 8, 0);
  sub_4F598((int)a1, 1, 4);
  sub_4F7B0(a1, 255);
  return 0;
}

//----- (0004FDD4) --------------------------------------------------------
int __fastcall sub_4FDD4(int a1, int a2)
{
  float v2; // s0
  __int16 v3; // r3
  int v4; // r12
  signed int v5; // r6
  float v6; // s19
  int v7; // r10
  int v8; // r11
  int v9; // r8
  int v10; // r5
  int v11; // r2
  int v12; // r4
  float v13; // s17
  int v14; // r0
  int v15; // r0
  float v16; // s16
  int v17; // r2
  signed int v19; // r7
  int v20; // r6
  unsigned int v22; // [sp+38h] [bp-104Ch]
  int v25; // [sp+4Ch] [bp-1038h]
  _DWORD v26[2]; // [sp+50h] [bp-1034h] BYREF
  int v27; // [sp+58h] [bp-102Ch]
  int v28; // [sp+5Ch] [bp-1028h]
  int v29; // [sp+60h] [bp-1024h] BYREF
  int v30; // [sp+64h] [bp-1020h]
  int v31; // [sp+68h] [bp-101Ch]
  int v32; // [sp+6Ch] [bp-1018h]
  __int64 v33; // [sp+70h] [bp-1014h]
  int v34; // [sp+78h] [bp-100Ch]
  int v35; // [sp+7Ch] [bp-1008h]
  char v36[4100]; // [sp+80h] [bp-1004h] BYREF

  v3 = 0;
  v27 = 0;
  v26[1] = 0;
  v28 = 0;
  v26[0] = 0;
  if ( !a2 )
    v3 = 8;
  LOBYTE(v27) = 1;
  if ( a2 )
  {
    if ( a2 == 1 )
      HIWORD(v27) = 12;
  }
  else
  {
    HIWORD(v27) = v3;
  }
  v4 = -1068236443;
  v5 = 2;
  v25 = 2;
LABEL_8:
  v6 = (float)v5;
  v7 = 0;
  v8 = 0;
LABEL_9:
  v9 = v8 + 1;
  v10 = v8;
  v22 = (v5 << 8) | 0xC0000000 | v7;
  while ( 1 )
  {
    v11 = (int)(float)((float)((float)((float)((float)(v10 + 1) * (float)((float)(v8 + 1) * v2)) * v6) / 25.0) * 100.0);
    v12 = v11 / 100;
    if ( v11 % 100 > 50 )
      ++v12;
    if ( (unsigned int)(v12 - 16) <= 0xEA )
    {
      v13 = (float)((float)v12 * 25.0) / v6;
      if ( (v5 != 1 || v13 <= 3125.0) && v13 <= 3200.0 && v13 >= 2000.0 )
      {
        v14 = sub_DCEB0(25 * v12, v5);
        v15 = sub_DCEB0(v14, v8 + 1);
        v16 = (float)sub_DCEB0(v15, v10 + 1);
        v17 = v13 > 2400.0;
        v4 = v10 & 7 | v22 | (v12 << 16) | (v17 << 28);
        if ( fabsf(v16 - v2) < 3.0 )
          break;
      }
    }
    if ( v10-- == 0 )
    {
      v7 += 16;
      ++v8;
      if ( v9 != 8 )
        goto LABEL_9;
      v5 = 1;
      if ( v25 == 1 )
      {
        v26[0] = v4;
        V_LOCK();
        V_INT((int)&v29, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v36,
          0x1000u,
          0,
          v35,
          v29,
          v30,
          v31,
          v32,
          v33,
          v34,
          v35,
          "set pll_no %d freq: %.2f, expected freq: %.2f",
          a2,
          0,
          0,
          v2);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_freq_DASH_1766",
          26,
          500,
          40,
          v36);
        goto LABEL_24;
      }
      v25 = 1;
      goto LABEL_8;
    }
  }
  v19 = v5;
  v20 = v10 & 7 | v22 | (v12 << 16) | (v17 << 28);
  V_LOCK();
  logfmt_raw(
    v36,
    0x1000u,
    0,
    "target_freq:%.2f actual_freq:%.2f,vco:%.2f fbdiv:%d refdiv:%d postdiv1:%d, postdiv2:%d",
    v2,
    v16,
    v13,
    v12,
    v19,
    v8,
    v10);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "inferred_plldivider",
    19,
    473,
    20,
    v36);
  v26[0] = v20;
  V_LOCK();
  V_INT((int)&v29, "chain", *(int *)(a1 + 200));
  logfmt_raw(
    v36,
    0x1000u,
    0,
    v35,
    v29,
    v30,
    v31,
    v32,
    v33,
    v34,
    v35,
    "set pll_no %d freq: %.2f, expected freq: %.2f",
    a2,
    v16,
    v2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_freq_DASH_1766",
    26,
    500,
    40,
    v36);
  if ( v16 > 0.0 )
    v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v26);
  else
    v10 = -1;
LABEL_24:
  usleep(0x2710u);
  return v10;
}
// 4FEA4: variable 'v2' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005020C) --------------------------------------------------------
int __fastcall set_frequency_dash(int a1, int a2)
{
  sub_4FDD4(a1, a2);
  return 0;
}

//----- (0005021C) --------------------------------------------------------
int __fastcall sub_5021C(int a1, int a2)
{
  _DWORD v4[4]; // [sp+28h] [bp-1034h] BYREF
  _DWORD v5[7]; // [sp+38h] [bp-1024h] BYREF
  int v6; // [sp+54h] [bp-1008h]
  char v7[4100]; // [sp+58h] [bp-1004h] BYREF

  v4[0] = a2;
  v4[2] = 4194305;
  v4[3] = 0;
  v4[1] = 0;
  V_LOCK();
  V_INT((int)v5, "chain", *(int *)(a1 + 200));
  logfmt_raw(v7, 0x1000u, 0, v6, v5[0], v5[1], v5[2], v5[3], v5[4], v5[5], v5[6], v6, "set analog value %08x", v4[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_analog_mux_DASH_1766",
    32,
    745,
    40,
    v7);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v4);
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00050310) --------------------------------------------------------
int __fastcall sub_50310(int a1, int a2)
{
  if ( sub_5021C(a1, a2) )
    return 19;
  else
    return 0;
}

//----- (00050328) --------------------------------------------------------
int __fastcall sub_50328(int a1, int *a2)
{
  int v2; // r2
  _DWORD *v3; // r6
  int *v5; // r8
  int v6; // r3
  int v7; // r0
  int v8; // r1
  int v9; // r2
  int v10; // r3
  void (__fastcall *v11)(int, int *, int *, _DWORD, int, int, int, int, _DWORD); // r9
  int v12; // r3
  int v13; // r2
  int v14; // r2
  int *v16; // [sp+38h] [bp-109Ch]
  int v17; // [sp+40h] [bp-1094h] BYREF
  int v18; // [sp+44h] [bp-1090h] BYREF
  int v19; // [sp+48h] [bp-108Ch] BYREF
  int v20; // [sp+4Ch] [bp-1088h] BYREF
  _DWORD v21[7]; // [sp+50h] [bp-1084h] BYREF
  int v22; // [sp+6Ch] [bp-1068h]
  _DWORD v23[7]; // [sp+70h] [bp-1064h] BYREF
  int v24; // [sp+8Ch] [bp-1048h]
  _DWORD v25[7]; // [sp+90h] [bp-1044h] BYREF
  int v26; // [sp+ACh] [bp-1028h]
  _DWORD v27[7]; // [sp+B0h] [bp-1024h] BYREF
  int v28; // [sp+CCh] [bp-1008h]
  char v29[4100]; // [sp+D0h] [bp-1004h] BYREF

  v2 = *(_DWORD *)(a1 + 340);
  v3 = *(_DWORD **)(a1 + 332);
  v17 = -64;
  v18 = -64;
  if ( v2 > 0 )
  {
    v16 = &a2[2 * v2];
    v5 = a2;
    do
    {
      v19 = 0;
      (*(void (__fastcall **)(int, int *, int *, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(a1 + 140))(
        a1,
        &v17,
        &v19,
        *v3,
        v3[1],
        v3[2],
        v3[3],
        v3[4],
        v3[5]);
      if ( v19 )
      {
        v6 = v17;
        if ( v17 >= -63 )
          goto LABEL_4;
        v17 = -64;
        V_LOCK();
        V_INT((int)v21, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v29,
          0x1000u,
          0,
          v22,
          v21[0],
          v21[1],
          v21[2],
          v21[3],
          v21[4],
          v21[5],
          v21[6],
          v22,
          "got uneffective temp, sensor[%d], addr:%02x",
          *v3,
          v3[5]);
        V_UNLOCK();
        v13 = 503;
      }
      else
      {
        v17 = -64;
        V_LOCK();
        V_INT((int)v23, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v29,
          0x1000u,
          0,
          v24,
          v23[0],
          v23[1],
          v23[2],
          v23[3],
          v23[4],
          v23[5],
          v23[6],
          v24,
          "read sensor failed, sensor[%d], addr:%02x",
          *v3,
          v3[5]);
        V_UNLOCK();
        v13 = 508;
      }
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/backend_dash_1766/backend_dash_1766.c",
        173,
        "read_temperature_dash",
        21,
        v13,
        100,
        v29);
      v6 = v17;
LABEL_4:
      *v5 = v6;
      v7 = v3[1];
      v8 = v3[2];
      v9 = v3[3];
      v10 = v3[4];
      v11 = *(void (__fastcall **)(int, int *, int *, _DWORD, int, int, int, int, _DWORD))(a1 + 144);
      v20 = 0;
      v11(a1, &v18, &v20, *v3, v7, v8, v9, v10, v3[5]);
      if ( !v20 )
      {
        v18 = -64;
        V_LOCK();
        V_INT((int)v27, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v29,
          0x1000u,
          0,
          v28,
          v27[0],
          v27[1],
          v27[2],
          v27[3],
          v27[4],
          v27[5],
          v27[6],
          v28,
          "read sensor failed, sensor[%d], addr:%02x",
          *v3,
          v3[5]);
        V_UNLOCK();
        v14 = 523;
LABEL_11:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/backend_dash_1766/backend_dash_1766.c",
          173,
          "read_temperature_dash",
          21,
          v14,
          100,
          v29);
        v12 = v18;
        goto LABEL_6;
      }
      v12 = v18;
      if ( v18 < -63 )
      {
        v18 = -64;
        V_LOCK();
        V_INT((int)v25, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v29,
          0x1000u,
          0,
          v26,
          v25[0],
          v25[1],
          v25[2],
          v25[3],
          v25[4],
          v25[5],
          v25[6],
          v26,
          "got uneffective temp, sensor[%d], addr:%02x",
          *v3,
          v3[5]);
        V_UNLOCK();
        v14 = 518;
        goto LABEL_11;
      }
LABEL_6:
      v5[1] = v12;
      v5 += 2;
      usleep((__useconds_t)&loc_7A120);
      v3 += 6;
    }
    while ( v16 != v5 );
  }
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (000506A0) --------------------------------------------------------
int __fastcall sub_506A0(int a1, int a2)
{
  int v4; // r2
  int v5; // r7
  int v6; // r7
  int v7; // r7
  int *v8; // r6
  int v9; // r0
  int v10; // r12
  int v11; // r2
  int v12; // r3
  int v13; // r8
  int v15; // [sp+4h] [bp-10E8h]
  int v16; // [sp+38h] [bp-10B4h]
  int *ptr; // [sp+4Ch] [bp-10A0h]
  int v18; // [sp+54h] [bp-1098h] BYREF
  _DWORD v19[2]; // [sp+58h] [bp-1094h] BYREF
  int v20; // [sp+60h] [bp-108Ch]
  int v21; // [sp+64h] [bp-1088h]
  _DWORD v22[7]; // [sp+68h] [bp-1084h] BYREF
  int v23; // [sp+84h] [bp-1068h]
  _DWORD v24[7]; // [sp+88h] [bp-1064h] BYREF
  int v25; // [sp+A4h] [bp-1048h]
  _DWORD v26[7]; // [sp+A8h] [bp-1044h] BYREF
  int v27; // [sp+C4h] [bp-1028h]
  _DWORD v28[7]; // [sp+C8h] [bp-1024h] BYREF
  int v29; // [sp+E4h] [bp-1008h]
  char v30[4100]; // [sp+E8h] [bp-1004h] BYREF

  V_LOCK();
  V_INT((int)v22, "chain", *(int *)(a1 + 200));
  logfmt_raw(
    v30,
    0x1000u,
    0,
    v23,
    v22[0],
    v22[1],
    v22[2],
    v22[3],
    v22[4],
    v22[5],
    v22[6],
    v23,
    "set clock delay chip_no %d, value %08x",
    *(_DWORD *)(a1 + 280),
    a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_clock_delay_DASH_1766",
    33,
    597,
    40,
    v30);
  v19[1] = 0;
  v21 = 255;
  v19[0] = a2;
  v20 = 1;
  if ( (*(int (__fastcall **)(int, _DWORD *))(a1 + 220))(a1, v19) < 0 )
  {
    V_LOCK();
    v16 = -1;
    V_INT((int)v24, "chain", *(int *)(a1 + 200));
    logfmt_raw(
      v30,
      0x1000u,
      0,
      v25,
      v24[0],
      v24[1],
      v24[2],
      v24[3],
      v24[4],
      v24[5],
      v24[6],
      v25,
      "%s failed, set reg:%02x",
      "ChipSetting_clock_delay_DASH_1766",
      HIWORD(v20));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_clock_delay_DASH_1766",
      33,
      606,
      100,
      v30);
  }
  else
  {
    usleep((__useconds_t)"rl_kda_2110");
    v4 = *(_DWORD *)(a1 + 280);
    v5 = *(_DWORD *)(a1 + 284);
    LOBYTE(v21) = 0;
    v6 = v5 * v4;
    ptr = (int *)calloc(12 * v6, 1u);
    (*(void (__fastcall **)(int, _DWORD *, int, int *, int *, int, int, _DWORD))(a1 + 244))(
      a1,
      v19,
      v6,
      ptr,
      &v18,
      v15,
      2000,
      0);
    if ( v18 > 0 )
    {
      v7 = 0;
      v16 = 0;
      v8 = ptr;
      do
      {
        v12 = *v8;
        v13 = *((unsigned __int16 *)v8 + 3);
        HIBYTE(v24[0]) = *v8;
        BYTE2(v24[0]) = BYTE1(v12);
        BYTE1(v24[0]) = BYTE2(v12);
        LOBYTE(v24[0]) = HIBYTE(v12);
        V_LOCK();
        if ( v13 )
        {
          V_INT((int)v28, "chain", *(int *)(a1 + 200));
          logfmt_raw(
            v30,
            0x1000u,
            0,
            v29,
            v28[0],
            v28[1],
            v28[2],
            v28[3],
            v28[4],
            v28[5],
            v28[6],
            v29,
            "[DP] chip %02x, expected reg %02x, but %02x, data %08x",
            *((unsigned __int8 *)v8 + 4),
            0,
            *((unsigned __int16 *)v8 + 3),
            v24[0]);
          V_UNLOCK();
          v9 = g_zc;
          v10 = 100;
          v11 = 625;
        }
        else
        {
          ++v16;
          V_INT((int)v26, "chain", *(int *)(a1 + 200));
          logfmt_raw(
            v30,
            0x1000u,
            0,
            v27,
            v26[0],
            v26[1],
            v26[2],
            v26[3],
            v26[4],
            v26[5],
            v26[6],
            v27,
            "[DP] chip %02x, core %02x, reg %02x, clk_delay %08x",
            *((unsigned __int8 *)v8 + 4),
            *((unsigned __int8 *)v8 + 8),
            *((unsigned __int16 *)v8 + 3),
            v24[0]);
          V_UNLOCK();
          v9 = g_zc;
          v10 = 20;
          v11 = 622;
        }
        ++v7;
        v8 += 3;
        zlog(
          v9,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_clock_delay_DASH_1766",
          33,
          v11,
          v10,
          v30);
      }
      while ( v18 > v7 );
    }
    else
    {
      v16 = 0;
    }
    free(ptr);
  }
  return v16;
}
// 507F0: variable 'v15' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00050A60) --------------------------------------------------------
int __fastcall sub_50A60(int a1, int a2)
{
  if ( *(_DWORD *)(a1 + 284) * *(_DWORD *)(a1 + 280) == sub_506A0(a1, a2) )
    return 19;
  else
    return 0;
}

//----- (00050A88) --------------------------------------------------------
int __fastcall sub_50A88(int a1, int a2, char a3)
{
  int v4; // r6
  _DWORD *v5; // r10
  _DWORD *v6; // r4
  int (__fastcall *v7)(int, _DWORD *); // r3
  int result; // r0
  int v9; // [sp+40h] [bp-1094h]
  int v10; // [sp+44h] [bp-1090h]
  char v11; // [sp+48h] [bp-108Ch]
  char v12; // [sp+50h] [bp-1084h]
  int v14; // [sp+5Ch] [bp-1078h] BYREF
  _DWORD v15[2]; // [sp+60h] [bp-1074h] BYREF
  int v16; // [sp+68h] [bp-106Ch]
  int v17; // [sp+6Ch] [bp-1068h]
  _DWORD v18[7]; // [sp+70h] [bp-1064h] BYREF
  int v19; // [sp+8Ch] [bp-1048h]
  _DWORD v20[7]; // [sp+90h] [bp-1044h] BYREF
  int v21; // [sp+ACh] [bp-1028h]
  _DWORD v22[7]; // [sp+B0h] [bp-1024h] BYREF
  int v23; // [sp+CCh] [bp-1008h]
  char v24[4100]; // [sp+D0h] [bp-1004h] BYREF

  v9 = a3 & 1;
  v14 = 0;
  if ( a2 == -1 || *(_DWORD *)(a1 + 280) < a2 )
  {
    v11 = 0;
    v12 = 1;
  }
  else
  {
    v12 = 0;
    v11 = *(_BYTE *)(*(_DWORD *)(a1 + 432) + a2);
  }
  v4 = 0;
  v16 = 0x10000;
  v15[1] = 0;
  v15[0] = 0;
  BYTE1(v16) = v11;
  v17 = 0;
  v5 = calloc(0xCu, 1u);
  (*(void (__fastcall **)(int, _DWORD *, int, _DWORD *, int *))(a1 + 244))(a1, v15, 1, v5, &v14);
  if ( v14 <= 0 )
  {
    v10 = v9;
  }
  else
  {
    v6 = v5;
    v10 = v9;
    do
    {
      if ( *((_WORD *)v6 + 3) == 1 )
      {
        V_LOCK();
        V_INT((int)v18, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v24,
          0x1000u,
          0,
          v19,
          v18[0],
          v18[1],
          v18[2],
          v18[3],
          v18[4],
          v18[5],
          v18[6],
          v19,
          "%s chip %02x, core %02x, reg %02x, core_mode %08x",
          "ChipSetting_same_nonce_DASH_1766",
          *((unsigned __int8 *)v6 + 4),
          *((unsigned __int8 *)v6 + 8),
          *((unsigned __int16 *)v6 + 3),
          *v6);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_same_nonce_DASH_1766",
          32,
          268,
          20,
          v24);
        v10 = v9 | *v6;
      }
      else
      {
        V_LOCK();
        V_INT((int)v20, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v24,
          0x1000u,
          0,
          v21,
          v20[0],
          v20[1],
          v20[2],
          v20[3],
          v20[4],
          v20[5],
          v20[6],
          v21,
          "%s chip %02x, expected reg %02x, but %02x, core_mode %08x",
          "ChipSetting_same_nonce_DASH_1766",
          *((unsigned __int8 *)v6 + 4),
          5,
          *((unsigned __int16 *)v6 + 3),
          *v6);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_same_nonce_DASH_1766",
          32,
          272,
          100,
          v24);
      }
      ++v4;
      v6 += 3;
    }
    while ( v14 > v4 );
  }
  free(v5);
  HIWORD(v16) = 1;
  LOBYTE(v17) = -1;
  LOBYTE(v16) = v12;
  v7 = *(int (__fastcall **)(int, _DWORD *))(a1 + 220);
  BYTE1(v16) = v11;
  v15[0] = v10;
  result = v7(a1, v15);
  if ( result < 0 )
  {
    V_LOCK();
    V_INT((int)v22, "chain", *(int *)(a1 + 200));
    logfmt_raw(
      v24,
      0x1000u,
      0,
      v23,
      v22[0],
      v22[1],
      v22[2],
      v22[3],
      v22[4],
      v22[5],
      v22[6],
      v23,
      "set same nonce failed! chip_id:%d",
      a2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_same_nonce_DASH_1766",
      32,
      285,
      100,
      v24);
    return -1;
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00050E04) --------------------------------------------------------
int __fastcall sub_50E04(int a1, int a2, char a3)
{
  sub_50A88(a1, a2, a3);
  usleep(0x2710u);
  return 0;
}

//----- (00050E1C) --------------------------------------------------------
bool __fastcall sub_50E1C(int a1, int a2, char **a3)
{
  char v3; // r3
  _DWORD *v5; // r8
  int v6; // r6
  _DWORD *v7; // r5
  int v8; // r3
  int v9; // r10
  void *v10; // r0
  char *v11; // r8
  int v12; // r5
  int v13; // r6
  _DWORD *v14; // r5
  const char *v15; // r5
  int v17; // [sp+4h] [bp-10E8h]
  char *s; // [sp+40h] [bp-10ACh]
  char *v20; // [sp+44h] [bp-10A8h]
  _DWORD *ptr; // [sp+4Ch] [bp-10A0h]
  int v22; // [sp+54h] [bp-1098h] BYREF
  int v23; // [sp+58h] [bp-1094h] BYREF
  int v24; // [sp+5Ch] [bp-1090h]
  int v25; // [sp+60h] [bp-108Ch]
  int v26; // [sp+64h] [bp-1088h]
  _DWORD v27[7]; // [sp+68h] [bp-1084h] BYREF
  int v28; // [sp+84h] [bp-1068h]
  _DWORD v29[7]; // [sp+88h] [bp-1064h] BYREF
  int v30; // [sp+A4h] [bp-1048h]
  _DWORD v31[7]; // [sp+A8h] [bp-1044h] BYREF
  int v32; // [sp+C4h] [bp-1028h]
  _DWORD v33[7]; // [sp+C8h] [bp-1024h] BYREF
  int v34; // [sp+E4h] [bp-1008h]
  char v35[4100]; // [sp+E8h] [bp-1004h] BYREF

  v3 = 0;
  v22 = 0;
  if ( a2 != -1 && *(_DWORD *)(a1 + 280) >= a2 )
    v3 = *(_BYTE *)(*(_DWORD *)(a1 + 432) + a2);
  v25 = 3932160;
  v24 = 0;
  v23 = 0;
  v26 = 0;
  BYTE1(v25) = v3;
  v5 = calloc(0xCu, 1u);
  (*(void (__fastcall **)(int, int *, int, _DWORD *, int *))(a1 + 236))(a1, &v23, 1, v5, &v22);
  if ( v22 <= 0 )
  {
    v20 = 0;
  }
  else
  {
    v20 = 0;
    v6 = 0;
    v7 = v5;
    do
    {
      while ( 1 )
      {
        ++v6;
        if ( *((_WORD *)v7 + 3) == 60 )
          break;
        v7 += 3;
        if ( v22 <= v6 )
          goto LABEL_9;
      }
      v8 = *v5;
      v7 += 3;
      HIBYTE(v33[0]) = *v5;
      BYTE2(v33[0]) = BYTE1(v8);
      BYTE1(v33[0]) = BYTE2(v8);
      LOBYTE(v33[0]) = HIBYTE(v8);
      v9 = v33[0];
      V_LOCK();
      v20 += v9;
      V_INT((int)v27, "chain", *(int *)(a1 + 200));
      logfmt_raw(
        v35,
        0x1000u,
        0,
        v28,
        v27[0],
        v27[1],
        v27[2],
        v27[3],
        v27[4],
        v27[5],
        v27[6],
        v28,
        "[Top Nonce Cnt] asic %02x, reg %02x cnt %08x",
        *((unsigned __int8 *)v7 - 8),
        *((unsigned __int16 *)v7 - 3),
        v9);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/chip_setting.c",
        150,
        "ChipSetting_nonce_counter_DASH_1766",
        35,
        321,
        20,
        v35);
    }
    while ( v22 > v6 );
  }
LABEL_9:
  v10 = v5;
  v11 = 0;
  free(v10);
  *a3 = v20;
  v12 = *(_DWORD *)(a1 + 284);
  v25 = 655360;
  v26 = 255;
  v23 = 1;
  v24 = 0;
  ptr = calloc(12 * v12, 1u);
  (*(void (__fastcall **)(int, int *, int, _DWORD *, int *, int, int, _DWORD))(a1 + 244))(
    a1,
    &v23,
    v12,
    ptr,
    &v22,
    v17,
    2000,
    0);
  if ( v22 > 0 )
  {
    v13 = 0;
    v14 = ptr;
    s = 0;
    do
    {
      if ( *((_WORD *)v14 + 3) == 10 )
      {
        s += *v14;
        V_LOCK();
        V_INT((int)v29, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v35,
          0x1000u,
          0,
          v30,
          v29[0],
          v29[1],
          v29[2],
          v29[3],
          v29[4],
          v29[5],
          v29[6],
          v30,
          "%s chip %02x, core %02x, reg %02x, core_nonce_cnt %08x",
          "ChipSetting_nonce_counter_DASH_1766",
          *((unsigned __int8 *)v14 + 4),
          *((unsigned __int8 *)v14 + 8),
          *((unsigned __int16 *)v14 + 3),
          *v14);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_nonce_counter_DASH_1766",
          35,
          344,
          20,
          v35);
      }
      else
      {
        V_LOCK();
        V_INT((int)v31, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v35,
          0x1000u,
          0,
          v32,
          v31[0],
          v31[1],
          v31[2],
          v31[3],
          v31[4],
          v31[5],
          v31[6],
          v32,
          "%s chip %02x, expected reg %02x, but %02x, core_nonce_cnt %08x",
          "ChipSetting_nonce_counter_DASH_1766",
          *((unsigned __int8 *)v14 + 4),
          5,
          *((unsigned __int16 *)v14 + 3),
          *v14);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_nonce_counter_DASH_1766",
          35,
          347,
          100,
          v35);
      }
      ++v13;
      v14 += 3;
    }
    while ( v22 > v13 );
    v11 = s;
  }
  free(ptr);
  V_LOCK();
  V_INT((int)v33, "chain", *(int *)(a1 + 200));
  v15 = "Failed";
  if ( v20 == v11 )
    v15 = "Pass";
  logfmt_raw(
    v35,
    0x1000u,
    0,
    v34,
    v33[0],
    v33[1],
    v33[2],
    v33[3],
    v33[4],
    v33[5],
    v33[6],
    v34,
    "check nonce counter, top_nonce_cnt %d, core_nocne_cnt %d (%s)",
    v20,
    v11,
    v15);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_nonce_counter_DASH_1766",
    35,
    353,
    40,
    v35);
  return v20 != v11;
}
// 5105C: variable 'v17' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (000512F8) --------------------------------------------------------
int __fastcall sub_512F8(int a1, int a2, char **a3)
{
  if ( sub_50E1C(a1, a2, a3) )
    return 19;
  else
    return 0;
}

//----- (00051310) --------------------------------------------------------
int __fastcall sub_51310(int a1)
{
  int v2; // r6
  int v3; // r2
  int v4; // r0
  int v5; // r9
  int *v6; // r5
  int v7; // r0
  int v8; // r12
  int v9; // r2
  int v10; // r3
  int v11; // r2
  int v13; // [sp+4h] [bp-10E0h]
  int v14; // [sp+3Ch] [bp-10A8h]
  int *ptr; // [sp+44h] [bp-10A0h]
  int v16; // [sp+4Ch] [bp-1098h] BYREF
  _DWORD v17[2]; // [sp+50h] [bp-1094h] BYREF
  int v18; // [sp+58h] [bp-108Ch]
  int v19; // [sp+5Ch] [bp-1088h]
  _DWORD v20[7]; // [sp+60h] [bp-1084h] BYREF
  int v21; // [sp+7Ch] [bp-1068h]
  _DWORD v22[7]; // [sp+80h] [bp-1064h] BYREF
  int v23; // [sp+9Ch] [bp-1048h]
  _DWORD v24[7]; // [sp+A0h] [bp-1044h] BYREF
  int v25; // [sp+BCh] [bp-1028h]
  _DWORD v26[7]; // [sp+C0h] [bp-1024h] BYREF
  int v27; // [sp+DCh] [bp-1008h]
  char v28[4100]; // [sp+E0h] [bp-1004h] BYREF

  V_LOCK();
  V_INT((int)v20, "chain", *(int *)(a1 + 200));
  v2 = 0;
  logfmt_raw(
    v28,
    0x1000u,
    0,
    v21,
    v20[0],
    v20[1],
    v20[2],
    v20[3],
    v20[4],
    v20[5],
    v20[6],
    v21,
    "get hash clock count chip_no %d",
    *(_DWORD *)(a1 + 280));
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_hash_clock_count_DASH_1766",
    38,
    692,
    20,
    v28);
  v18 = 393217;
  v17[1] = 0;
  v17[0] = 1;
  v19 = 255;
  if ( (*(int (__fastcall **)(int, _DWORD *))(a1 + 220))(a1, v17) < 0 )
  {
    V_LOCK();
    v14 = -1;
    V_INT((int)v22, "chain", *(int *)(a1 + 200));
    logfmt_raw(
      v28,
      0x1000u,
      0,
      v23,
      v22[0],
      v22[1],
      v22[2],
      v22[3],
      v22[4],
      v22[5],
      v22[6],
      v23,
      "%s failed, set reg:%02x",
      "ChipSetting_hash_clock_count_DASH_1766",
      HIWORD(v18));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_hash_clock_count_DASH_1766",
      38,
      701,
      100,
      v28);
  }
  else
  {
    usleep(0x4E20u);
    v3 = *(_DWORD *)(a1 + 280);
    v4 = *(_DWORD *)(a1 + 284);
    v18 = 458753;
    v5 = v4 * v3;
    LOBYTE(v19) = 0;
    ptr = (int *)calloc(12 * v4 * v3, 1u);
    (*(void (__fastcall **)(int, _DWORD *, int, int *, int *, int, int, _DWORD))(a1 + 244))(
      a1,
      v17,
      v5,
      ptr,
      &v16,
      v13,
      2000,
      0);
    v14 = 0;
    if ( v16 > 0 )
    {
      v6 = ptr;
      do
      {
        v10 = *v6;
        v11 = *((unsigned __int16 *)v6 + 3);
        HIBYTE(v22[0]) = *v6;
        BYTE2(v22[0]) = BYTE1(v10);
        BYTE1(v22[0]) = BYTE2(v10);
        LOBYTE(v22[0]) = HIBYTE(v10);
        if ( v11 == 7 )
        {
          V_LOCK();
          ++v14;
          V_INT((int)v24, "chain", *(int *)(a1 + 200));
          logfmt_raw(
            v28,
            0x1000u,
            0,
            v25,
            v24[0],
            v24[1],
            v24[2],
            v24[3],
            v24[4],
            v24[5],
            v24[6],
            v25,
            "[Hash clk cnt] chip %02x, core %02x, reg %02x, clk_cnt %08x",
            *((unsigned __int8 *)v6 + 4),
            *((unsigned __int8 *)v6 + 8),
            *((unsigned __int16 *)v6 + 3),
            v22[0]);
          V_UNLOCK();
          v7 = g_zc;
          v8 = 40;
          v9 = 720;
        }
        else
        {
          V_LOCK();
          V_INT((int)v26, "chain", *(int *)(a1 + 200));
          logfmt_raw(
            v28,
            0x1000u,
            0,
            v27,
            v26[0],
            v26[1],
            v26[2],
            v26[3],
            v26[4],
            v26[5],
            v26[6],
            v27,
            "[Hash clk cnt] chip %02x, expected reg %02x, but %02x, clk_cnt %08x",
            *((unsigned __int8 *)v6 + 4),
            7,
            *((unsigned __int16 *)v6 + 3),
            v22[0]);
          V_UNLOCK();
          v7 = g_zc;
          v8 = 100;
          v9 = 723;
        }
        ++v2;
        v6 += 3;
        zlog(
          v7,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_hash_clock_count_DASH_1766",
          38,
          v9,
          v8,
          v28);
      }
      while ( v16 > v2 );
    }
    free(ptr);
  }
  return v14;
}
// 5146C: variable 'v13' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (000516C0) --------------------------------------------------------
int __fastcall sub_516C0(int a1)
{
  if ( *(_DWORD *)(a1 + 284) * *(_DWORD *)(a1 + 280) == sub_51310(a1) )
    return 19;
  else
    return 0;
}

//----- (000516E8) --------------------------------------------------------
int __fastcall sub_516E8(int a1)
{
  int v2; // r6
  int (__fastcall *v3)(int, _DWORD *); // r3
  int v4; // r8
  int v5; // r2
  int v6; // r5
  int v7; // r5
  _WORD *v8; // r5
  int v9; // r0
  int v10; // r12
  int v11; // r2
  int v13; // [sp+3Ch] [bp-1088h]
  _WORD *ptr; // [sp+44h] [bp-1080h]
  int v15; // [sp+48h] [bp-107Ch]
  int v16; // [sp+4Ch] [bp-1078h]
  _DWORD v17[2]; // [sp+50h] [bp-1074h] BYREF
  int v18; // [sp+58h] [bp-106Ch]
  int v19; // [sp+5Ch] [bp-1068h]
  _DWORD v20[7]; // [sp+60h] [bp-1064h] BYREF
  int v21; // [sp+7Ch] [bp-1048h]
  _DWORD v22[7]; // [sp+80h] [bp-1044h] BYREF
  int v23; // [sp+9Ch] [bp-1028h]
  _DWORD v24[7]; // [sp+A0h] [bp-1024h] BYREF
  int v25; // [sp+BCh] [bp-1008h]
  char v26[4100]; // [sp+C0h] [bp-1004h] BYREF

  V_LOCK();
  V_INT((int)v20, "chain", *(int *)(a1 + 200));
  logfmt_raw(
    v26,
    0x1000u,
    0,
    v21,
    v20[0],
    v20[1],
    v20[2],
    v20[3],
    v20[4],
    v20[5],
    v20[6],
    v21,
    "get pmdata chip_no %d",
    *(_DWORD *)(a1 + 280));
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_pmdata_DASH_1766",
    28,
    640,
    20,
    v26);
  v2 = 0;
  v18 = 0;
  v19 = 0;
  v13 = 0;
  v17[1] = 0;
  v3 = *(int (__fastcall **)(int, _DWORD *))(a1 + 220);
  while ( 1 )
  {
    if ( v2 == 3 )
      goto LABEL_12;
    LOBYTE(v18) = 1;
    HIWORD(v18) = 255;
    v17[0] = (16 * v2) | 1;
    LOBYTE(v19) = -1;
    if ( v3(a1, v17) < 0 )
      break;
    v4 = 0;
    usleep(0x4E20u);
    v5 = *(_DWORD *)(a1 + 280);
    v6 = *(_DWORD *)(a1 + 284);
    v18 = 327681;
    v7 = v6 * v5;
    LOBYTE(v19) = 0;
    ptr = calloc(12 * v7, 1u);
    (*(void (__fastcall **)(int, _DWORD *, int))(a1 + 244))(a1, v17, v7);
    if ( v15 > 0 )
    {
      v8 = ptr;
      do
      {
        HIBYTE(v16) = *(_DWORD *)v8;
        BYTE2(v16) = BYTE1(*(_DWORD *)v8);
        BYTE1(v16) = BYTE2(*(_DWORD *)v8);
        LOBYTE(v16) = HIBYTE(*(_DWORD *)v8);
        if ( v8[3] == 5 )
        {
          V_LOCK();
          ++v13;
          V_INT((int)v22, "chain", *(int *)(a1 + 200));
          logfmt_raw(
            v26,
            0x1000u,
            0,
            v23,
            v22[0],
            v22[1],
            v22[2],
            v22[3],
            v22[4],
            v22[5],
            v22[6],
            v23,
            "[PM data] chip %02x, reg %02x mode %d PMDATA %08x",
            *((unsigned __int8 *)v8 + 4),
            (unsigned __int16)v8[3],
            v2,
            v16);
          V_UNLOCK();
          v9 = g_zc;
          v10 = 40;
          v11 = 672;
        }
        else
        {
          V_LOCK();
          V_INT((int)v24, "chain", *(int *)(a1 + 200));
          logfmt_raw(
            v26,
            0x1000u,
            0,
            v25,
            v24[0],
            v24[1],
            v24[2],
            v24[3],
            v24[4],
            v24[5],
            v24[6],
            v25,
            "[PM data] chip %02x, expected reg %02x, but %02x mode %d PMDATA %08x",
            *((unsigned __int8 *)v8 + 4),
            5,
            (unsigned __int16)v8[3],
            v2,
            v16);
          V_UNLOCK();
          v9 = g_zc;
          v10 = 100;
          v11 = 675;
        }
        ++v4;
        v8 += 6;
        zlog(
          v9,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_pmdata_DASH_1766",
          28,
          v11,
          v10,
          v26);
      }
      while ( v15 > v4 );
    }
    if ( v2 == 6 )
    {
      free(ptr);
      return v13;
    }
    v3 = *(int (__fastcall **)(int, _DWORD *))(a1 + 220);
LABEL_12:
    ++v2;
  }
  V_LOCK();
  logfmt_raw(v26, 0x1000u, 0, "%s failed, set reg:%02x", "ChipSetting_pmdata_DASH_1766", HIWORD(v18));
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_pmdata_DASH_1766",
    28,
    653,
    100,
    v26);
  return -1;
}
// 51874: variable 'v15' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00051A9C) --------------------------------------------------------
int __fastcall sub_51A9C(int a1)
{
  if ( *(_DWORD *)(a1 + 284) * *(_DWORD *)(a1 + 280) == sub_516E8(a1) )
    return 19;
  else
    return 0;
}

//----- (00051AC4) --------------------------------------------------------
int __fastcall sub_51AC4(int a1, int a2)
{
  int v2; // r6
  int v4; // r5
  _DWORD *v5; // r8
  _DWORD *v6; // r9
  _DWORD *v7; // r6
  int v8; // r3
  int v9; // r4
  int v12; // [sp+40h] [bp-105Ch] BYREF
  int v13; // [sp+44h] [bp-1058h]
  _DWORD v14[2]; // [sp+48h] [bp-1054h] BYREF
  int v15; // [sp+50h] [bp-104Ch]
  int v16; // [sp+54h] [bp-1048h]
  _DWORD v17[7]; // [sp+58h] [bp-1044h] BYREF
  int v18; // [sp+74h] [bp-1028h]
  _DWORD v19[7]; // [sp+78h] [bp-1024h] BYREF
  int v20; // [sp+94h] [bp-1008h]
  char v21[4100]; // [sp+98h] [bp-1004h] BYREF

  v2 = *(_DWORD *)(a1 + 280);
  v4 = 0;
  v15 = 1835009;
  v14[1] = 0;
  v14[0] = 0;
  LOWORD(v5) = (unsigned __int16)&g_zc;
  v16 = 0;
  v12 = 0;
  v6 = calloc(12 * v2, 1u);
  (*(void (__fastcall **)(int, _DWORD *, int, _DWORD *, int *))(a1 + 236))(a1, v14, v2, v6, &v12);
  if ( v12 > 0 )
  {
    v7 = v6;
    HIWORD(v5) = (unsigned int)&g_zc >> 16;
    do
    {
      while ( 1 )
      {
        ++v4;
        if ( *((_WORD *)v7 + 3) == 28 )
          break;
        v7 += 3;
        if ( v12 <= v4 )
          goto LABEL_7;
      }
      V_LOCK();
      v7 += 3;
      V_INT((int)v17, "chain", *(int *)(a1 + 200));
      logfmt_raw(
        v21,
        0x1000u,
        0,
        v18,
        v17[0],
        v17[1],
        v17[2],
        v17[3],
        v17[4],
        v17[5],
        v17[6],
        v18,
        "[MISC CTRL] asic %02x, reg %02x state %08x",
        *((unsigned __int8 *)v7 - 8),
        *((unsigned __int16 *)v7 - 3),
        *(v7 - 3),
        *(v7 - 3));
      V_UNLOCK();
      zlog(
        *v5,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/chip_setting.c",
        150,
        "ChipSetting_pll_sel_DASH_1766",
        29,
        189,
        20,
        v21);
    }
    while ( v12 > v4 );
  }
  else
  {
    HIWORD(v5) = (unsigned int)&g_zc >> 16;
  }
LABEL_7:
  v8 = *v6;
  HIBYTE(v13) = *v6;
  BYTE2(v13) = BYTE1(v8);
  BYTE1(v13) = BYTE2(v8);
  LOBYTE(v13) = HIBYTE(v8);
  free(v6);
  v15 = 1835009;
  v14[0] = v13 & 0xFFFFFFFB | (4 * (_BYTE)a2) & 4;
  V_LOCK();
  V_INT((int)v19, "chain", *(int *)(a1 + 200));
  logfmt_raw(
    v21,
    0x1000u,
    0,
    v20,
    v19[0],
    v19[1],
    v19[2],
    v19[3],
    v19[4],
    v19[5],
    v19[6],
    v20,
    "set pll sel %u %08x",
    a2,
    v14[0]);
  V_UNLOCK();
  zlog(
    *v5,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_pll_sel_DASH_1766",
    29,
    201,
    40,
    v21);
  v9 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v14);
  usleep(0x2710u);
  return v9;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00051D70) --------------------------------------------------------
int __fastcall sub_51D70(int a1, int a2)
{
  if ( sub_51AC4(a1, a2) )
    return 19;
  else
    return 0;
}

//----- (00051D88) --------------------------------------------------------
int __fastcall sub_51D88(int a1, int a2)
{
  int v3; // r4
  _DWORD v5[4]; // [sp+28h] [bp-1034h] BYREF
  _DWORD v6[7]; // [sp+38h] [bp-1024h] BYREF
  int v7; // [sp+54h] [bp-1008h]
  char v8[4100]; // [sp+58h] [bp-1004h] BYREF

  v5[0] = a2;
  v5[2] = 2883585;
  v5[3] = 0;
  v5[1] = 0;
  V_LOCK();
  V_INT((int)v6, "chain", *(int *)(a1 + 200));
  logfmt_raw(v8, 0x1000u, 0, v7, v6[0], v6[1], v6[2], v6[3], v6[4], v6[5], v6[6], v7, "set io cfg value %08x", v5[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_io_cfg_DASH_1766",
    28,
    233,
    40,
    v8);
  v3 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v5);
  usleep(0x2710u);
  return v3;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00051E8C) --------------------------------------------------------
int __fastcall sub_51E8C(int a1, int a2)
{
  if ( sub_51D88(a1, a2) )
    return 19;
  else
    return 0;
}

//----- (00051EA4) --------------------------------------------------------
int __fastcall check_nonce_dash(int a1, int a2)
{
  int v2; // r9
  int v4; // r4
  unsigned int v5; // r7
  int v6; // r12
  char *v7; // r2
  char *v8; // r3
  char v9; // r1
  unsigned int v10; // r0
  unsigned int v11; // r4
  unsigned int v13; // r3
  _BYTE v14[32]; // [sp+18h] [bp-1070h] BYREF
  _DWORD v15[20]; // [sp+38h] [bp-1050h] BYREF
  char v16[4096]; // [sp+88h] [bp-1000h] BYREF

  v2 = *(_DWORD *)(a1 + 760);
  v4 = *(unsigned __int8 *)(a2 + 53);
  v5 = *(_DWORD *)(v2 + 4 * (v4 + 3840));
  ++dword_1197D8;
  v6 = *(_DWORD *)(v2 + 12 * v4 + 19968);
  *(_DWORD *)(a2 + 58) = *(_DWORD *)(v2 + 12 * v4 + 19972);
  *(_DWORD *)(a2 + 54) = v6;
  memcpy(v15, (const void *)(v2 + 80 * v4 + 5120), sizeof(v15));
  v7 = (char *)v15;
  v8 = (char *)(v2 + 80 * v4 + 5120);
  do
  {
    v9 = *v8;
    v8 += 4;
    v7[3] = v9;
    v7[2] = *(v8 - 3);
    v7[1] = *(v8 - 2);
    *v7 = *(v8 - 1);
    v7 += 4;
  }
  while ( v7 != v16 );
  v15[19] = *(_DWORD *)(a2 + 48);
  Xhash(v14, v15);
  v10 = le256_target_to_diff_base_0((int)v14);
  v11 = v10;
  if ( v10 > 0x22 )
  {
    v13 = *(unsigned __int8 *)(a2 + 52);
    if ( v13 == v10 )
    {
      if ( v5 > v13 )
      {
        V_LOCK();
        logfmt_raw(v16, 0x1000u, 0, "hw diff (%d<%d) not reach pool", *(unsigned __int8 *)(a2 + 52), v5);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/backend_dash_1766/backend_dash_1766.c",
          173,
          "check_nonce_dash",
          16,
          756,
          20,
          v16);
        return 1;
      }
      else
      {
        return 0;
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(v16, 0x1000u, 0, "diff not match (%d!=%d) expected diff %d", v11, *(unsigned __int8 *)(a2 + 52), v5);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/backend_dash_1766/backend_dash_1766.c",
        173,
        "check_nonce_dash",
        16,
        737,
        20,
        v16);
      return 3;
    }
  }
  else
  {
    ++dword_1197DC;
    V_LOCK();
    logfmt_raw(
      v16,
      0x1000u,
      0,
      "hw error calculate diff %d ans diff %d TICKET_MASK_DASH_1766 %d",
      v11,
      *(unsigned __int8 *)(a2 + 52),
      35);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/backend_dash_1766/backend_dash_1766.c",
      173,
      "check_nonce_dash",
      16,
      727,
      20,
      v16);
    return 2;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1197D8: using guessed type int dword_1197D8;
// 1197DC: using guessed type int dword_1197DC;
// 11A7AC: using guessed type int g_zc;

//----- (0005211C) --------------------------------------------------------
int __fastcall get_pcba_test_level_dash(_DWORD *a1, _DWORD *a2)
{
  int v2; // r5
  int v6; // r0
  int v7; // r0
  unsigned __int16 *v8; // r1
  int v9; // r2
  int v10; // r12
  int v11; // lr
  unsigned __int16 *i; // r3
  int v13; // r3
  int j; // r2
  int v15; // r3
  char *v16; // r5
  int v17; // [sp+48h] [bp-1068h] BYREF
  __int16 v18; // [sp+4Ch] [bp-1064h]
  _DWORD v19[7]; // [sp+50h] [bp-1060h] BYREF
  int v20; // [sp+6Ch] [bp-1044h]
  _DWORD v21[8]; // [sp+70h] [bp-1040h] BYREF
  _DWORD v22[7]; // [sp+90h] [bp-1020h] BYREF
  int v23; // [sp+ACh] [bp-1004h]
  char v24[4096]; // [sp+B0h] [bp-1000h] BYREF

  v2 = a1[227];
  v18 = 0;
  v17 = 0;
  if ( v2 )
  {
LABEL_2:
    *a2 = v2;
    return 0;
  }
  v6 = dev_ctrl(a1);
  v7 = (*(int (__fastcall **)(_DWORD, int, int, int *))(v6 + 84))(a1[49], 52, 393216, &v17);
  if ( !v7 )
  {
    v8 = (unsigned __int16 *)&unk_E7048;
    v9 = 700;
    v10 = (unsigned __int16)v17;
    v11 = HIWORD(v17);
    for ( i = (unsigned __int16 *)&unk_E7048; ; v9 = i[2] )
    {
      if ( (unsigned __int16)v17 == v9
        && i[3] == HIWORD(v17)
        && *((unsigned __int8 *)i + 8) == (unsigned __int8)v18
        && *((unsigned __int8 *)i + 9) == HIBYTE(v18) )
      {
        v13 = *(_DWORD *)&aGlobalIdxInitD_1[10 * v7 + 652];
        a1[227] = v13;
        goto LABEL_13;
      }
      ++v7;
      i += 5;
      if ( v7 == 5 )
        break;
    }
    v13 = a1[227];
LABEL_13:
    if ( !v13 )
    {
      for ( j = 700; v10 != j || v8[3] != v11; j = v8[2] )
      {
        ++v13;
        v8 += 5;
        if ( v13 == 5 )
          goto LABEL_20;
      }
      v15 = *(_DWORD *)&aGlobalIdxInitD_1[10 * v13 + 652];
      a1[227] = v15;
      if ( v15 )
        goto LABEL_21;
LABEL_20:
      a1[227] = 5;
    }
LABEL_21:
    V_LOCK();
    V_INT((int)v22, "chain", (int)a1[50]);
    v16 = &aGlobalIdxInitD_1[10 * a1[227] - 10];
    logfmt_raw(
      v24,
      0x1000u,
      0,
      v23,
      v22[0],
      v22[1],
      v22[2],
      v22[3],
      v22[4],
      v22[5],
      v22[6],
      v23,
      "pic freq %d voltage %d rate%d.%d",
      (unsigned __int16)v17,
      HIWORD(v17),
      (unsigned __int8)v16[660],
      (unsigned __int8)v16[661]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/backend_dash_1766/backend_dash_1766.c",
      173,
      "get_pcba_test_level_dash",
      24,
      973,
      40,
      v24);
    v2 = a1[227];
    goto LABEL_2;
  }
  *a2 = -1;
  V_LOCK();
  V_INT((int)v19, "chain", (int)a1[50]);
  V_STR(v21, "error", "pic info error");
  logfmt_raw(
    v24,
    0x1000u,
    0,
    v20,
    v19[0],
    v19[1],
    v19[2],
    v19[3],
    v19[4],
    v19[5],
    v19[6],
    v20,
    v21[0],
    v21[1],
    v21[2],
    v21[3],
    v21[4],
    v21[5],
    v21[6],
    v21[7],
    "pic info lost");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/backend_dash_1766/backend_dash_1766.c",
    173,
    "get_pcba_test_level_dash",
    24,
    951,
    120,
    v24);
  return 15;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4AB8C: using guessed type int __fastcall dev_ctrl(_DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00052414) --------------------------------------------------------
int __fastcall sub_52414(int *a1, int a2)
{
  const char *v2; // r4
  void *v5; // r0
  void (__fastcall *v6)(int *, _DWORD *, int, void *, int *, int, int, _DWORD); // lr
  unsigned __int16 *v7; // r6
  unsigned int v8; // r9
  int v9; // r1
  int v10; // r0
  unsigned int v11; // r1
  unsigned int v12; // r0
  int v13; // r9
  int v14; // r2
  int **v15; // r12
  int result; // r0
  unsigned __int8 *v17; // r8
  char *v18; // r4
  int v19; // r6
  int v20; // r9
  int v22; // r2
  int *v23; // [sp+0h] [bp-160Ch] BYREF
  int v24; // [sp+4h] [bp-1608h]
  const char *v25; // [sp+8h] [bp-1604h]
  const char *v26; // [sp+54h] [bp-15B8h]
  const char *v27; // [sp+58h] [bp-15B4h]
  const char *v28; // [sp+5Ch] [bp-15B0h]
  int v29; // [sp+60h] [bp-15ACh]
  void *ptr; // [sp+64h] [bp-15A8h]
  int v31; // [sp+68h] [bp-15A4h]
  int **v32; // [sp+6Ch] [bp-15A0h]
  int v33; // [sp+74h] [bp-1598h] BYREF
  _DWORD v34[4]; // [sp+78h] [bp-1594h] BYREF
  _DWORD v35[7]; // [sp+88h] [bp-1584h] BYREF
  int v36; // [sp+A4h] [bp-1568h]
  _BYTE v37[32]; // [sp+A8h] [bp-1564h] BYREF
  _DWORD v38[7]; // [sp+C8h] [bp-1544h] BYREF
  int v39; // [sp+E4h] [bp-1528h]
  _DWORD v40[8]; // [sp+E8h] [bp-1524h] BYREF
  _BYTE s[256]; // [sp+108h] [bp-1504h] BYREF
  char v42[1024]; // [sp+208h] [bp-1404h] BYREF
  char v43[4100]; // [sp+608h] [bp-1004h] BYREF

  v2 = 0;
  v33 = 0;
  memset(s, 0, sizeof(s));
  V_LOCK();
  logfmt_raw(v43, 0x1000u, 0, "%s chip_no %d", "ChipSetting_get_addr_DASH_1766", a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_get_addr_DASH_1766",
    30,
    32,
    20,
    v43);
  v31 = a2;
  v34[0] = 0;
  v34[2] = 1;
  v34[1] = 0;
  v34[3] = 0;
  v5 = calloc(12 * a2, 1u);
  v23 = &v33;
  v6 = (void (__fastcall *)(int *, _DWORD *, int, void *, int *, int, int, _DWORD))a1[59];
  ptr = v5;
  v6(a1, v34, a2, v5, &v33, v24, 3000, 0);
  V_LOCK();
  V_INT((int)v35, "chain", a1[50]);
  logfmt_raw(
    v43,
    0x1000u,
    0,
    v36,
    v35[0],
    v35[1],
    v35[2],
    v35[3],
    v35[4],
    v35[5],
    v35[6],
    v36,
    "%s detect %d chips",
    "ChipSetting_get_addr_DASH_1766",
    v33,
    a1[68]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_get_addr_DASH_1766",
    30,
    43,
    60,
    v43);
  if ( v33 > 0 )
  {
    v26 = "ChipSetting_get_addr_DASH_1766";
    v29 = 0;
    v28 = "[GET ADDR] chip_type %04x/%04x chip %d reg %d addr %02x";
    v27 = "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c";
    v7 = (unsigned __int16 *)ptr;
    do
    {
      while ( 1 )
      {
        v8 = *v7;
        V_LOCK();
        v9 = *((unsigned __int8 *)v7 + 4);
        LOWORD(v8) = __rev16(v8);
        v10 = v7[3];
        v24 = a1[68];
        v25 = v2++;
        logfmt_raw(v43, 0x1000u, 0, v28, (unsigned __int16)v8, v24, v25, v10, v9);
        V_UNLOCK();
        zlog(g_zc, v27, 150, v26, 30, 47, 20, v43);
        if ( a1[68] == (unsigned __int16)v8 )
          break;
        v7 += 6;
        if ( v33 <= (int)v2 )
          goto LABEL_7;
      }
      v7 += 6;
      v11 = a1[93];
      v12 = *((unsigned __int8 *)v7 - 8);
      ++v29;
      v13 = v12 / v11;
      s[v13] = 1;
      V_LOCK();
      v14 = a1[50];
      v32 = (int **)v37;
      V_INT((int)v37, "chain", v14);
      v15 = v32;
      v32 = &v23;
      logfmt_raw(
        v43,
        0x1000u,
        0,
        v15[7],
        *v15,
        v15[1],
        v15[2],
        v15[3],
        v15[4],
        v15[5],
        v15[6],
        v15[7],
        "chip_id:%d, %03d",
        v13,
        *((unsigned __int8 *)v7 - 8));
      V_UNLOCK();
      zlog(g_zc, v27, 150, v26, 30, 53, 20, v43);
    }
    while ( v33 > (int)v2 );
LABEL_7:
    v2 = (const char *)v29;
  }
  else
  {
    v29 = 0;
  }
  if ( a1[70] > v29 )
  {
    V_LOCK();
    V_INT((int)v38, "chain", a1[50]);
    V_STR(v40, "error", "asic num error");
    logfmt_raw(
      v43,
      0x1000u,
      0,
      v39,
      v38[0],
      v38[1],
      v38[2],
      v38[3],
      v38[4],
      v38[5],
      v38[6],
      v39,
      v40[0],
      v40[1],
      v40[2],
      v40[3],
      v40[4],
      v40[5],
      v40[6],
      v40[7],
      "detected asic num less than design(%d<%d)",
      v29,
      a1[70]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_get_addr_DASH_1766",
      30,
      59,
      100,
      v43);
    memset(v42, 0, sizeof(v42));
    v42[0] = 10;
    if ( v31 )
    {
      v26 = v2;
      v17 = s;
      v18 = v42;
      v19 = 0;
      v20 = v31;
      do
      {
        while ( *v17++ )
        {
          if ( v20 == ++v19 )
            goto LABEL_15;
        }
        v22 = v19++;
        sprintf(v18, "%02d ", v22);
        v18 += 3;
      }
      while ( v20 != v19 );
LABEL_15:
      v2 = v26;
    }
    V_LOCK();
    logfmt_raw(v43, 0x1000u, 0, "bad asic:\n%s\n", v42);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_get_addr_DASH_1766",
      30,
      69,
      40,
      v43);
  }
  free(ptr);
  result = v33;
  a1[92] = (int)v2;
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00052934) --------------------------------------------------------
int __fastcall sub_52934(int *a1)
{
  int v2; // r6
  int v3; // r4

  v2 = a1[70];
  v3 = 3;
  while ( 1 )
  {
    sub_52414(a1, v2);
    if ( a1[92] == v2 )
      break;
    if ( !--v3 )
      return 12;
  }
  return 0;
}

//----- (00052974) --------------------------------------------------------
int __fastcall sub_52974(int a1, char a2, int a3, char a4, int a5)
{
  int v5; // r6
  int v8; // r6
  double v9; // r0
  unsigned __int64 v10; // r0
  int v11; // r4
  char v14[4072]; // [sp+18h] [bp-1000h] BYREF

  if ( a3 <= 700 )
    v5 = a2 & 1;
  else
    v5 = 0;
  if ( v5 )
  {
    v8 = a1 + 928;
    LODWORD(v9) = sub_DD46C(*(_QWORD *)(a1 + 920));
    v10 = (unsigned __int64)(v9 / (double)a3 * *(float *)(a1 + 900));
    *(_QWORD *)(v8 - 8) = v10;
    *(float *)(a1 + 900) = (float)a3;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v14, 0x1000u, 0, "Update parameter failed, freq:%f", *(float *)(a1 + 900));
    V_UNLOCK();
    LODWORD(v10) = zlog(
                     g_zc,
                     "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/"
                     "godminer-origin_godminer-new/backend/backend_dash_1766/backend_dash_1766.c",
                     173,
                     "parameter_update_dash",
                     21,
                     879,
                     40,
                     v14);
  }
  if ( (unsigned int)(a5 - 1400) <= 0x12C )
    v11 = a4 & 1;
  else
    v11 = 0;
  if ( v11 )
    *(_DWORD *)(a1 + 904) = a5;
  return v10;
}
// 529D0: variable 'v9' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00052A90) --------------------------------------------------------
int __fastcall parameter_update_dash(int a1, char a2, int a3, char a4, int a5)
{
  if ( !*(_BYTE *)(a1 + 204) )
    sub_52974(a1, a2, a3, a4, a5);
  return 0;
}

//----- (00052AC4) --------------------------------------------------------
int __fastcall sub_52AC4(int a1, int a2)
{
  int v4; // r2
  int v6; // r8
  __int64 v7; // r0
  _DWORD v8[7]; // [sp+30h] [bp-1040h] BYREF
  int v9; // [sp+4Ch] [bp-1024h]
  _DWORD v10[7]; // [sp+50h] [bp-1020h] BYREF
  int v11; // [sp+6Ch] [bp-1004h]
  char v12[4096]; // [sp+70h] [bp-1000h] BYREF

  if ( a2 == 700 )
  {
    v6 = 820;
LABEL_6:
    LODWORD(v7) = sub_DD794(*(_QWORD *)(a1 + 920), a2);
    *(_QWORD *)(a1 + 920) = v7 * (int)*(float *)(a1 + 900);
    *(float *)(a1 + 900) = (float)a2;
    *(_DWORD *)(a1 + 904) = v6;
    V_LOCK();
    V_INT((int)v10, "chain", *(int *)(a1 + 200));
    logfmt_raw(
      v12,
      0x1000u,
      0,
      v11,
      v10[0],
      v10[1],
      v10[2],
      v10[3],
      v10[4],
      v10[5],
      v10[6],
      v11,
      "overclock freq %d voltage %d",
      (int)*(float *)(a1 + 900),
      *(_DWORD *)(a1 + 904));
    V_UNLOCK();
    v4 = 913;
    return zlog(
             g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer"
             "-origin_godminer-new/backend/backend_dash_1766/backend_dash_1766.c",
             173,
             "overclock_update_dash",
             21,
             v4,
             40,
             v12);
  }
  if ( a2 == 750 )
  {
    v6 = 830;
    goto LABEL_6;
  }
  V_LOCK();
  V_INT((int)v8, "chain", *(int *)(a1 + 200));
  logfmt_raw(
    v12,
    0x1000u,
    0,
    v9,
    v8[0],
    v8[1],
    v8[2],
    v8[3],
    v8[4],
    v8[5],
    v8[6],
    v9,
    "cannot overclock with freq %d",
    a2);
  V_UNLOCK();
  v4 = 915;
  return zlog(
           g_zc,
           "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-o"
           "rigin_godminer-new/backend/backend_dash_1766/backend_dash_1766.c",
           173,
           "overclock_update_dash",
           21,
           v4,
           40,
           v12);
}
// 52BCC: variable 'v7' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00052C6C) --------------------------------------------------------
int __fastcall overclock_update_dash(int a1, int a2)
{
  if ( !*(_BYTE *)(a1 + 204) )
    sub_52AC4(a1, a2);
  return 0;
}

//----- (00052C90) --------------------------------------------------------
int __fastcall sub_52C90(_DWORD *a1, int a2, int a3, _BYTE *a4, _DWORD *a5, signed int *a6, _DWORD *a7)
{
  int v9; // r2
  int v11; // r7
  int *v12; // r6
  int v13; // r3
  int v15; // lr
  char v16; // r2
  unsigned int v17; // r1
  signed int v18; // r0
  int v19; // r1
  int v20; // r2
  char v22[4096]; // [sp+20h] [bp-1000h] BYREF

  v9 = a1[190];
  v11 = *(_BYTE *)(a2 + 8) & 0x7F;
  v12 = (int *)(v9 + 8 * v11);
  v13 = *v12;
  v15 = v12[1];
  *(_DWORD *)a3 = *v12;
  *(_DWORD *)(a3 + 4) = v15;
  *a7 = v13;
  strcpy((char *)(a3 + 16), (const char *)(v9 + 32 * (v11 + 32)));
  *(_DWORD *)(a3 + 48) = *(_DWORD *)(a2 + 3);
  v16 = *(_BYTE *)(a2 + 7);
  *(_BYTE *)(a3 + 53) = v11;
  *(_BYTE *)(a3 + 52) = v16 & 0x7F;
  v17 = a1[93];
  *(_QWORD *)(a3 + 72) = *((_QWORD *)v12 + 2689);
  v18 = *(unsigned __int8 *)(a2 + 3) / v17;
  if ( v18 >= a1[70] )
  {
    V_LOCK();
    logfmt_raw(v22, 0x1000u, 0, "Nonce error, wrong source chip number");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/backend_dash_1766/backend_dash_1766.c",
      173,
      "packet_2_nonce_dash",
      19,
      202,
      100,
      v22);
    v18 = 0;
    *a6 = 0;
  }
  else
  {
    *a6 = v18;
  }
  *(_DWORD *)(a3 + 8) = v18;
  *(_DWORD *)(a3 + 12) = (*(_BYTE *)(a2 + 6) & 0xFu) % 0xC;
  V_LOCK();
  logfmt_raw(
    v22,
    0x1000u,
    0,
    "%s Nonce: %02x%02x%02x%02x chipid:%d coreid:%d",
    "packet_2_nonce_dash",
    *(unsigned __int8 *)(a2 + 3),
    *(unsigned __int8 *)(a2 + 4),
    *(unsigned __int8 *)(a2 + 5),
    *(unsigned __int8 *)(a2 + 6),
    *(_DWORD *)(a3 + 8),
    *(_DWORD *)(a3 + 12));
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/backend_dash_1766/backend_dash_1766.c",
    173,
    "packet_2_nonce_dash",
    19,
    214,
    20,
    v22);
  v19 = BM_CRC5((_BYTE *)(a2 + 2), 59);
  v20 = *(_BYTE *)(a2 + 9) & 0x1F;
  if ( v19 == v20 )
  {
    *a5 = *(_DWORD *)(a3 + 48);
    *a4 = 1;
    return 0;
  }
  else
  {
    printf("get nonce crc error calc value %04x expected value %04x\n", v19, v20);
    return 11;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00052ED4) --------------------------------------------------------
int __fastcall packet_2_nonce_dash(_DWORD *a1, int a2, int a3, _BYTE *a4, _DWORD *a5, signed int *a6, _DWORD *a7)
{
  if ( *(char *)(a2 + 9) < 0 )
    return sub_52C90(a1, a2, a3, a4, a5, a6, a7);
  else
    return 10;
}

//----- (00052EEC) --------------------------------------------------------
int __fastcall sub_52EEC(char *a1, _DWORD *a2, _DWORD *a3, int a4)
{
  char v4; // r7
  int result; // r0
  int v10; // r3
  int v11; // r2
  char v12; // [sp+17h] [bp-1005h] BYREF
  char v13[4100]; // [sp+18h] [bp-1004h] BYREF

  v4 = a4;
  *a3 = 0;
  *a2 = -64;
  if ( pic1704_write_iic(*a1, a4) )
  {
    usleep(0x2710u);
    result = pic1704_read_iic(*a1, v4, &v12);
    if ( result )
    {
      v10 = v12;
      *a3 = 1;
      *a2 = v10;
      return result;
    }
    V_LOCK();
    logfmt_raw(v13, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)a1, a4);
    V_UNLOCK();
    v11 = 930;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v13, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)a1, a4);
    V_UNLOCK();
    v11 = 919;
  }
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_read_sensor_temp_local_on_pic_DASH_1766",
    51,
    v11,
    20,
    v13);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00053034) --------------------------------------------------------
int __fastcall sub_53034(char *a1, _DWORD *a2, _DWORD *a3, int a4)
{
  char v4; // r7
  int result; // r0
  int v10; // r3
  int v11; // r2
  char v12; // [sp+17h] [bp-1005h] BYREF
  char v13[4100]; // [sp+18h] [bp-1004h] BYREF

  v4 = a4;
  *a3 = 0;
  *a2 = -64;
  if ( pic1704_write_iic(*a1, a4) )
  {
    usleep(0x2710u);
    result = pic1704_read_iic(*a1, v4, &v12);
    if ( result )
    {
      v10 = v12;
      *a3 = 1;
      *a2 = v10 + 15;
      return result;
    }
    V_LOCK();
    logfmt_raw(v13, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)a1, a4);
    V_UNLOCK();
    v11 = 956;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v13, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)a1, a4);
    V_UNLOCK();
    v11 = 945;
  }
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_read_sensor_temp_remote_on_pic_DASH_1766",
    52,
    v11,
    20,
    v13);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00053180) --------------------------------------------------------
int __fastcall sub_53180(unsigned int *a1, _DWORD *a2, _DWORD *a3, int a4)
{
  int v8; // r3
  int v10; // [sp+34h] [bp-1030h]
  _BYTE v11[4]; // [sp+3Ch] [bp-1028h] BYREF
  _DWORD v12[7]; // [sp+40h] [bp-1024h] BYREF
  int v13; // [sp+5Ch] [bp-1008h]
  char v14[4100]; // [sp+60h] [bp-1004h] BYREF

  V_LOCK();
  logfmt_raw(
    v14,
    0x1000u,
    0,
    "%s chain[%d] iic_addr:%d",
    "ChipSetting_read_sensor_temp_local_on_ctrlboard_DASH_1766",
    *a1,
    a4);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_read_sensor_temp_local_on_ctrlboard_DASH_1766",
    57,
    970,
    20,
    v14);
  *a3 = 0;
  v10 = tsensor_read(*a1, a4, 0, (int)v11, 2u);
  if ( v10 == 2 )
  {
    v8 = v11[0];
    *a3 = 1;
    *a2 = v8;
    V_LOCK();
    V_INT((int)v12, "chain", (int)*a1);
    logfmt_raw(
      v14,
      0x1000u,
      0,
      v13,
      v12[0],
      v12[1],
      v12[2],
      v12[3],
      v12[4],
      v12[5],
      v12[6],
      v13,
      "read ctrlboard temp, local[%02x] %d",
      a4,
      *a2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_read_sensor_temp_local_on_ctrlboard_DASH_1766",
      57,
      982,
      20,
      v14);
  }
  else
  {
    *a2 = -64;
    v10 = -1;
    V_LOCK();
    logfmt_raw(v14, 0x1000u, 0, "failed to read ctrlboard-temp for chain %d", *a1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_read_sensor_temp_local_on_ctrlboard_DASH_1766",
      57,
      977,
      80,
      v14);
  }
  return v10;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00053364) --------------------------------------------------------
int __fastcall sub_53364(unsigned int *a1, unsigned __int8 *a2, _DWORD *a3, _DWORD *a4, unsigned __int8 a5)
{
  int result; // r0
  int v10; // r3
  _BYTE v11[4]; // [sp+14h] [bp-1004h] BYREF
  char v12[4072]; // [sp+18h] [bp-1000h] BYREF

  *a4 = 0;
  result = tsensor_read(*a1, a5, 0, (int)v11, 2u);
  if ( result == 2 )
  {
    v10 = v11[0];
    *a4 = 1;
    *a3 = v10 + *a2;
  }
  else
  {
    *a3 = -64;
    V_LOCK();
    logfmt_raw(v12, 0x1000u, 0, "failed to read ctrlboard-temp for chain %d", *a1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_read_sensor_temp_remote_on_ctrlboard_DASH_1766",
      58,
      996,
      80,
      v12);
    return -1;
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00053458) --------------------------------------------------------
int __fastcall sub_53458(_DWORD *a1, int a2, int a3, _DWORD *a4, _DWORD *a5)
{
  char v5; // r8
  int (__fastcall *v9)(_DWORD *, int *); // r3
  signed int v11; // r2
  unsigned __int8 *v12; // r0
  unsigned __int8 *v13; // r4
  void (__fastcall *v14)(_DWORD *, int *, signed int, unsigned __int8 *, int *); // r5
  int v15; // r5
  signed int v16; // [sp+14h] [bp-20h]
  int v17; // [sp+1Ch] [bp-18h] BYREF
  int v18; // [sp+20h] [bp-14h] BYREF
  int v19; // [sp+24h] [bp-10h]
  int v20; // [sp+28h] [bp-Ch]
  int v21; // [sp+2Ch] [bp-8h]

  v5 = a2;
  v20 = 0;
  v19 = 0;
  v21 = 0;
  v18 = a3 | 0x1980000;
  BYTE1(v20) = a2;
  v9 = (int (__fastcall *)(_DWORD *, int *))a1[54];
  HIWORD(v20) = 255;
  if ( v9(a1, &v18) )
    return 0;
  usleep(0xC350u);
  *a4 = 0;
  v19 = 0;
  *a5 = 0;
  v11 = a1[70];
  v20 = 0;
  v21 = 0;
  v18 = 0;
  if ( v11 >= 1 )
    v11 = 1;
  v16 = v11;
  v12 = (unsigned __int8 *)calloc(v11, 0xCu);
  BYTE1(v20) = v5;
  v13 = v12;
  v14 = (void (__fastcall *)(_DWORD *, int *, signed int, unsigned __int8 *, int *))a1[59];
  HIWORD(v20) = 255;
  v14(a1, &v18, v16, v12, &v17);
  v15 = v17;
  if ( v17 == 1 && a2 == v13[4] )
  {
    *a4 = *(_DWORD *)v13;
    *a5 = 1;
  }
  free(v13);
  return v15;
}

//----- (0005356C) --------------------------------------------------------
int __fastcall read_sensor_temp_remote_dash(
        int a1,
        int *a2,
        _DWORD *a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9)
{
  int v13; // r0
  int v14; // r1
  int v15; // r2
  int v16; // r3
  int v17; // [sp+8h] [bp-8h] BYREF
  int v18; // [sp+Ch] [bp-4h] BYREF

  if ( !a6 )
  {
    v13 = sub_53034((char *)(a1 + 200), a2, a3, a9);
    goto LABEL_6;
  }
  if ( a6 != 1 )
  {
    if ( a6 != 2 )
      return 4;
    v13 = sub_53364((unsigned int *)(a1 + 200), (unsigned __int8 *)(a1 + 912), a2, a3, a9);
    goto LABEL_6;
  }
  v14 = *(unsigned __int8 *)(*(_DWORD *)(a1 + 432) + a9);
  *a3 = 0;
  *a2 = -64;
  v13 = sub_53458((_DWORD *)a1, v14, 256, &v17, &v18);
  if ( v13 == 1 )
  {
    v15 = HIBYTE(v17);
    v16 = v18;
    if ( *(_DWORD *)(a1 + 456) == 1 )
      v15 = HIBYTE(v17) - 64;
    *a2 = v15;
    *a3 = v16;
    if ( !v16 )
      return 0;
  }
  else if ( !*a3 )
  {
    goto LABEL_6;
  }
  *a2 -= 15;
LABEL_6:
  if ( v13 == -1 )
    return 4;
  return 0;
}

//----- (00053674) --------------------------------------------------------
int __fastcall read_sensor_temp_local_dash(
        _DWORD *a1,
        int *a2,
        _DWORD *a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9)
{
  int v11; // r0
  int v14; // r1
  int v15; // r3
  int v16; // r2
  int v17; // [sp+8h] [bp-8h] BYREF
  int v18; // [sp+Ch] [bp-4h] BYREF

  if ( a6 )
  {
    if ( a6 == 1 )
    {
      v14 = *(unsigned __int8 *)(a1[108] + a9);
      *a3 = 0;
      *a2 = -64;
      v11 = sub_53458(a1, v14, 0, &v17, &v18);
      if ( v11 == 1 )
      {
        v15 = HIBYTE(v17);
        v16 = v18;
        if ( a1[114] == 1 )
          v15 = HIBYTE(v17) - 64;
        *a2 = v15;
        *a3 = v16;
        return 0;
      }
    }
    else
    {
      if ( a6 != 2 )
        return 4;
      v11 = sub_53180(a1 + 50, a2, a3, a9);
    }
  }
  else
  {
    v11 = sub_52EEC((char *)a1 + 200, a2, a3, a9);
  }
  if ( v11 == -1 )
    return 4;
  return 0;
}

//----- (00053744) --------------------------------------------------------
int __fastcall set_baud_dash_0(int a1, int a2)
{
  int v4; // r4
  int v5; // r4
  _DWORD v7[4]; // [sp+30h] [bp-1034h] BYREF
  _DWORD v8[7]; // [sp+40h] [bp-1024h] BYREF
  int v9; // [sp+5Ch] [bp-1008h]
  char v10[4100]; // [sp+60h] [bp-1004h] BYREF

  v7[2] = 6291457;
  v7[1] = 0;
  v7[3] = 0;
  v7[0] = 0;
  if ( a2 == 1500000 )
    goto LABEL_24;
  if ( a2 <= 1500000 )
  {
    if ( a2 == 460800 )
    {
      v4 = 1568;
      goto LABEL_10;
    }
    if ( a2 > 460800 )
    {
      if ( a2 == 921600 || a2 == 1041666 )
      {
        v4 = 544;
        goto LABEL_10;
      }
    }
    else if ( a2 == 38400 )
    {
      v4 = 20512;
      goto LABEL_10;
    }
    goto LABEL_16;
  }
  if ( a2 == 3125000 )
  {
LABEL_23:
    v4 = 32;
    goto LABEL_10;
  }
  if ( a2 <= 3125000 )
  {
    if ( a2 != 1562500 )
    {
      if ( a2 != 3000000 )
        goto LABEL_16;
      goto LABEL_23;
    }
LABEL_24:
    v4 = 288;
    goto LABEL_10;
  }
  if ( a2 == 6250000 )
  {
    v4 = 289;
    goto LABEL_9;
  }
  if ( a2 != 12500000 )
  {
LABEL_16:
    v4 = 6688;
    goto LABEL_10;
  }
  v4 = 33;
LABEL_9:
  (*(void (__fastcall **)(int, int))(a1 + 176))(a1, 1);
LABEL_10:
  v7[0] = v4;
  V_LOCK();
  V_INT((int)v8, "chain", *(int *)(a1 + 200));
  logfmt_raw(
    v10,
    0x1000u,
    0,
    v9,
    v8[0],
    v8[1],
    v8[2],
    v8[3],
    v8[4],
    v8[5],
    v8[6],
    v9,
    "set fuart cfg value %08x/%d",
    v4,
    a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_fuart_cfg_DASH_1766",
    31,
    421,
    40,
    v10);
  v5 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v7);
  usleep(0x2710u);
  return v5;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00053940) --------------------------------------------------------
int __fastcall sub_53940(int a1)
{
  int v2; // r4
  _DWORD v4[4]; // [sp+28h] [bp-1034h] BYREF
  _DWORD v5[7]; // [sp+38h] [bp-1024h] BYREF
  int v6; // [sp+54h] [bp-1008h]
  char v7[4100]; // [sp+58h] [bp-1004h] BYREF

  v4[0] = 5381904;
  v4[2] = 1835009;
  v4[3] = 0;
  v4[1] = 0;
  V_LOCK();
  V_INT((int)v5, "chain", *(int *)(a1 + 200));
  logfmt_raw(v7, 0x1000u, 0, v6, v5[0], v5[1], v5[2], v5[3], v5[4], v5[5], v5[6], v6, "set misc ctrl %08x", 5381904);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_misc_ctrl_DASH_1766",
    31,
    167,
    40,
    v7);
  v2 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v4);
  usleep(0x2710u);
  return v2;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00053A4C) --------------------------------------------------------
int __fastcall top_init_dash(int *a1)
{
  int v2; // r7
  int v3; // r4
  int v4; // r0
  int v5; // r1
  char v6; // r3
  void (__fastcall *v7)(int *, int, int); // r3
  _DWORD v9[7]; // [sp+28h] [bp-1024h] BYREF
  int v10; // [sp+44h] [bp-1008h]
  char v11[4100]; // [sp+48h] [bp-1004h] BYREF

  V_LOCK();
  V_INT((int)v9, "chain", a1[50]);
  logfmt_raw(v11, 0x1000u, 0, v10, v9[0], v9[1], v9[2], v9[3], v9[4], v9[5], v9[6], v10, "top_init_dash");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/backend_dash_1766/backend_dash_1766.c",
    173,
    "top_init_dash",
    13,
    583,
    40,
    v11);
  v2 = a1[70];
  v3 = a1[108];
  v4 = sub_DCEB0(256, (unsigned __int8)v2);
  if ( (_BYTE)v2 )
  {
    v5 = v3 - 1;
    v6 = 0;
    do
    {
      *(_BYTE *)++v5 = v6;
      v6 += v4;
    }
    while ( v5 != v3 - 1 + (unsigned __int8)v2 );
    v3 = a1[108];
  }
  v7 = (void (__fastcall *)(int *, int, int))a1[52];
  a1[93] = v4;
  v7(a1, v3, v2);
  sub_5021C((int)a1, 0);
  sub_53940((int)a1);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00053B7C) --------------------------------------------------------
int __fastcall dhash_start_dash(int a1)
{
  int v2; // r3
  int result; // r0
  _DWORD v4[7]; // [sp+28h] [bp-1020h] BYREF
  int v5; // [sp+44h] [bp-1004h]
  char v6[4096]; // [sp+48h] [bp-1000h] BYREF

  V_LOCK();
  V_INT((int)v4, "chain", *(int *)(a1 + 200));
  logfmt_raw(v6, 0x1000u, 0, v5, v4[0], v4[1], v4[2], v4[3], v4[4], v4[5], v4[6], v5, "dhash_start_dash");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/backend_dash_1766/backend_dash_1766.c",
    173,
    "dhash_start_dash",
    16,
    603,
    40,
    v6);
  sub_53940(a1);
  v2 = *(unsigned __int8 *)(a1 + 404);
  result = 0;
  *(_BYTE *)(a1 + 205) = 1;
  if ( !v2 )
    *(_DWORD *)(a1 + 408) = (int)*(float *)(a1 + 900);
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00053C5C) --------------------------------------------------------
int __fastcall makeup_chip_addr_dash(_BYTE *a1, unsigned int a2)
{
  int result; // r0
  _BYTE *v5; // r2
  char v6; // r3

  result = sub_DCEB0(256, a2);
  if ( a2 )
  {
    v5 = a1;
    v6 = 0;
    do
    {
      *v5++ = v6;
      v6 += result;
    }
    while ( &a1[a2] != v5 );
  }
  return result;
}

//----- (00053CA0) --------------------------------------------------------
void __fastcall get_chip_regdata(int a1, __int16 a2)
{
  int v2; // r5
  void *v4; // r6
  int v5; // [sp+14h] [bp-14h] BYREF
  _BYTE v6[10]; // [sp+18h] [bp-10h] BYREF
  __int16 v7; // [sp+22h] [bp-6h]

  v2 = *(_DWORD *)(a1 + 280);
  v7 = a2;
  v6[8] = 1;
  v5 = 0;
  v6[9] = 0;
  v4 = calloc(12 * v2, 1u);
  (*(void (__fastcall **)(int, _BYTE *, int, void *, int *))(a1 + 236))(a1, v6, v2, v4, &v5);
  free(v4);
}

//----- (00053D18) --------------------------------------------------------
int __fastcall set_chip_reg(int a1, char a2, char a3, int a4, int a5)
{
  _DWORD v8[2]; // [sp+10h] [bp-1010h] BYREF
  char v9; // [sp+18h] [bp-1008h]
  char v10; // [sp+19h] [bp-1007h]
  __int16 v11; // [sp+1Ah] [bp-1006h]
  int v12; // [sp+1Ch] [bp-1004h]
  char v13[4064]; // [sp+20h] [bp-1000h] BYREF

  v9 = a2;
  v10 = a3;
  v11 = a4;
  v12 = 0;
  v8[1] = 0;
  v8[0] = a5;
  V_LOCK();
  logfmt_raw(v13, 0x1000u, 0, "set_chip_reg set reg %x data %x", a4, a5);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/backend_dash_1766/backend_dash_1766.c",
    173,
    "set_chip_reg",
    12,
    308,
    40,
    v13);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v8);
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00053DDC) --------------------------------------------------------
void __fastcall get_core_regdata(int a1, __int16 a2)
{
  int v3; // r2
  int v4; // r4
  int v5; // r4
  void *v6; // r6
  int v7; // [sp+14h] [bp-14h] BYREF
  _BYTE v8[10]; // [sp+18h] [bp-10h] BYREF
  __int16 v9; // [sp+22h] [bp-6h]
  char v10; // [sp+24h] [bp-4h]

  v3 = *(_DWORD *)(a1 + 280);
  v4 = *(_DWORD *)(a1 + 288);
  v9 = a2;
  v8[8] = 1;
  v7 = 0;
  v5 = v4 * v3;
  v8[9] = 0;
  v10 = -1;
  v6 = calloc(12 * v5, 1u);
  (*(void (__fastcall **)(int, _BYTE *, int, void *, int *))(a1 + 244))(a1, v8, v5, v6, &v7);
  free(v6);
}

//----- (00053E64) --------------------------------------------------------
int __fastcall set_core_reg(int a1, char a2, int a3, int a4)
{
  int v9; // [sp+Ch] [bp-1018h]
  int v10; // [sp+10h] [bp-1014h] BYREF
  __int16 v11; // [sp+18h] [bp-100Ch]
  __int16 v12; // [sp+1Ah] [bp-100Ah]
  char v13; // [sp+1Ch] [bp-1008h]
  char v14; // [sp+1Dh] [bp-1007h]
  char v15[4100]; // [sp+20h] [bp-1004h] BYREF

  V_LOCK();
  logfmt_raw(v15, 0x1000u, 0, "%s: regaddr %02x data %d", "set_core_reg", a3, a4, v9, 0, 0, 0, 0);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/backend_dash_1766/backend_dash_1766.c",
    173,
    "set_core_reg",
    0xCu,
    338,
    20,
    v15);
  v13 = a2;
  v11 = 1;
  v12 = a3;
  v10 = a4;
  v14 = 0xCu;
  return (*(int (__fastcall **)(int, int *))(a1 + 220))(a1, &v10);
}
// 53ED0: variable 'v9' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00053F48) --------------------------------------------------------
int __fastcall set_ticket_mask_dash(int a1, int a2)
{
  int result; // r0
  int v5; // [sp+Ch] [bp-1018h]
  _DWORD v6[3]; // [sp+10h] [bp-1014h] BYREF
  int v7; // [sp+1Ch] [bp-1008h]
  char v8[4100]; // [sp+20h] [bp-1004h] BYREF

  V_LOCK();
  logfmt_raw(v8, 0x1000u, 0, "ticket_mask %s core reg %02x tm %d", "set_ticket_mask_dash", 3, a2, v5, 0, 0, 0, 0);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/backend_dash_1766/backend_dash_1766.c",
    173,
    "set_ticket_mask_dash",
    20,
    354,
    20,
    v8);
  LOWORD(v7) = 3327;
  v6[0] = a2;
  v6[2] = 196609;
  result = (*(int (__fastcall **)(int, _DWORD *))(a1 + 220))(a1, v6);
  *(_DWORD *)(a1 + 376) = a2;
  return result;
}
// 53FAC: variable 'v5' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00054034) --------------------------------------------------------
int __fastcall set_core_mode_dash(int a1, int a2)
{
  int v5; // [sp+Ch] [bp-1018h]
  _DWORD v6[3]; // [sp+10h] [bp-1014h] BYREF
  int v7; // [sp+1Ch] [bp-1008h]
  char v8[4100]; // [sp+20h] [bp-1004h] BYREF

  V_LOCK();
  logfmt_raw(v8, 0x1000u, 0, "%s core reg %02x data %d", "set_core_mode_dash", 1, a2, v5, 0, 0, 0, 0);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/backend_dash_1766/backend_dash_1766.c",
    173,
    "set_core_mode_dash",
    18,
    371,
    20,
    v8);
  LOWORD(v7) = 3327;
  v6[2] = 65537;
  v6[0] = a2;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 220))(a1, v6);
}
// 54098: variable 'v5' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00054114) --------------------------------------------------------
int __fastcall set_misc_ctrl_dash(int a1, int a2)
{
  _DWORD v3[5]; // [sp+0h] [bp-14h] BYREF

  v3[0] = a2;
  v3[1] = 0;
  v3[3] = 0;
  v3[2] = 1835009;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v3);
}

//----- (00054154) --------------------------------------------------------
int get_algo_type_dash()
{
  return 0;
}

//----- (0005415C) --------------------------------------------------------
int set_boot_config_dash()
{
  return 0;
}

//----- (00054164) --------------------------------------------------------
void *runtime_ctrl_dash_1766()
{
  void *v0; // r0
  void *v1; // r5
  _QWORD v3[117]; // [sp+0h] [bp-3A8h] BYREF

  memset(v3, 0, sizeof(v3));
  strcpy((char *)&v3[33], "dash");
  HIDWORD(v3[39]) = 210;
  LODWORD(v3[40]) = 500;
  *(_WORD *)((char *)&v3[33] + 5) = 0;
  HIBYTE(v3[33]) = 0;
  HIDWORD(v3[41]) = sensor_info_dash_1766;
  v3[42] = qword_106490;
  v3[43] = qword_106498;
  LODWORD(v3[31]) = 14660;
  v3[44] = qword_1064A0;
  v0 = calloc(1u, 0x3A8u);
  LODWORD(v3[0]) = backend_init_base;
  HIDWORD(v3[0]) = reset_base;
  HIDWORD(v3[1]) = dhash_mining_stop_base;
  HIDWORD(v3[2]) = backend_exit_base;
  LODWORD(v3[3]) = push_work_base;
  LODWORD(v3[4]) = pop_ans_base;
  LODWORD(v3[6]) = softreset_all_chip_dash;
  LODWORD(v3[7]) = work_2_packet_dash;
  LODWORD(v3[8]) = check_nonce_dash;
  LODWORD(v3[9]) = global_idx_free_dash;
  HIDWORD(v3[9]) = set_baud_dash;
  HIDWORD(v3[10]) = sub_51D70;
  LODWORD(v3[12]) = sub_51A9C;
  HIDWORD(v3[12]) = sub_516C0;
  LODWORD(v3[2]) = dhash_mining_reset_base;
  LODWORD(v3[13]) = sub_512F8;
  HIDWORD(v3[13]) = sub_50E04;
  LODWORD(v3[14]) = sub_50A60;
  HIDWORD(v3[3]) = async_push_work_base;
  HIDWORD(v3[4]) = try_pop_ans_base;
  HIDWORD(v3[14]) = get_chip_status_dash;
  LODWORD(v3[15]) = get_theory_hashrate_dash;
  HIDWORD(v3[15]) = get_sale_hashrate_dash;
  HIDWORD(v3[7]) = packet_2_nonce_dash;
  HIDWORD(v3[8]) = global_idx_init_dash;
  LODWORD(v3[16]) = get_qualify_hashrate_dash;
  HIDWORD(v3[16]) = get_qualify_nonce_num_dash;
  LODWORD(v3[17]) = set_sensor_extern_mode_dash;
  LODWORD(v3[1]) = dhash_mining_start_base;
  LODWORD(v3[10]) = sub_51E8C;
  LODWORD(v3[11]) = sub_50310;
  HIDWORD(v3[17]) = read_sensor_temp_local_dash;
  LODWORD(v3[18]) = read_sensor_temp_remote_dash;
  HIDWORD(v3[18]) = parameter_update_dash;
  LODWORD(v3[19]) = overclock_update_dash;
  HIDWORD(v3[19]) = get_pcba_test_level_dash;
  LODWORD(v3[20]) = get_packet_remain_len_dash;
  LODWORD(v3[22]) = set_frequency_dash;
  HIDWORD(v3[22]) = sub_52934;
  LODWORD(v3[23]) = sub_50328;
  HIDWORD(v3[23]) = top_init_dash;
  LODWORD(v3[24]) = dhash_start_dash;
  LODWORD(v3[26]) = set_chipaddr_base;
  HIDWORD(v3[26]) = set_inactive_base;
  LODWORD(v3[27]) = set_chip_reg_base;
  HIDWORD(v3[27]) = set_core_reg_base_9;
  LODWORD(v3[28]) = set_core_reg_base_9;
  HIDWORD(v3[28]) = set_core_enable_base;
  LODWORD(v3[29]) = sync_get_status_base;
  HIDWORD(v3[29]) = sync_get_chip_reg_base;
  HIDWORD(v3[30]) = sync_get_core_reg_base3;
  v3[112] = 0x43FA000042480000LL;
  v3[34] = 0x100001766LL;
  v3[35] = 0xC0000005CLL;
  LODWORD(v3[47]) = 35;
  v1 = v0;
  v3[36] = 0x10000000CLL;
  v3[96] = 0x400000050LL;
  HIDWORD(v3[95]) = 176;
  v3[97] = 0xA00000056LL;
  LODWORD(v3[113]) = 1560;
  LOBYTE(v3[114]) = 12;
  v3[115] = 1750;
  memcpy(v0, v3, 0x3A8u);
  return v1;
}
// 5393C: using guessed type int set_baud_dash();
// 10648C: using guessed type _UNKNOWN *sensor_info_dash_1766;
// 106490: using guessed type __int64;
// 106498: using guessed type __int64;
// 1064A0: using guessed type __int64;

//----- (000544F8) --------------------------------------------------------
int get_chip_status_dcr()
{
  return 0;
}

//----- (00054500) --------------------------------------------------------
int __fastcall get_theory_hashrate_dcr(int a1, double *a2)
{
  float v2; // s14

  v2 = *(float *)(a1 + 900);
  *a2 = v2 * 69920.0 * 1000.0 * 1000.0;
  return 0;
}

//----- (00054538) --------------------------------------------------------
int __fastcall get_sale_hashrate_dcr(int a1, double *a2, _DWORD *a3)
{
  int result; // r0
  double v7; // [sp+0h] [bp-8h] BYREF

  v7 = 0.0;
  (*(void (__fastcall **)(int, double *))(a1 + 120))(a1, &v7);
  if ( *(_BYTE *)(a1 + 248) != 68 )
    return 24;
  if ( *(_BYTE *)(a1 + 249) != 82 )
    return 24;
  if ( *(_BYTE *)(a1 + 250) != 55 )
    return 24;
  result = *(unsigned __int8 *)(a1 + 251);
  if ( *(_BYTE *)(a1 + 251) )
    return 24;
  *a2 = v7 * 0.985;
  *a3 = 100;
  return result;
}

//----- (000545D0) --------------------------------------------------------
int __fastcall get_qualify_hashrate_dcr(int a1, double *a2)
{
  int result; // r0
  double v5; // [sp+0h] [bp-Ch] BYREF

  v5 = 0.0;
  (*(void (__fastcall **)(int, double *))(a1 + 120))(a1, &v5);
  if ( *(_BYTE *)(a1 + 248) != 68 )
    return 24;
  if ( *(_BYTE *)(a1 + 249) != 82 )
    return 24;
  if ( *(_BYTE *)(a1 + 250) != 55 )
    return 24;
  result = *(unsigned __int8 *)(a1 + 251);
  if ( *(_BYTE *)(a1 + 251) )
    return 24;
  *a2 = v5 * 0.994;
  return result;
}

//----- (00054658) --------------------------------------------------------
int __fastcall get_qualify_nonce_num_dcr(int a1, float *a2)
{
  int v4; // r0
  char v5; // r1
  int v6; // r3
  __int64 v7; // r0
  double v8; // r0
  double v9; // d4
  float v11; // s14
  double v12; // [sp+0h] [bp-Ch] BYREF

  v12 = 0.0;
  (*(void (__fastcall **)(int, double *))(a1 + 120))(a1, &v12);
  v4 = *(_DWORD *)(a1 + 376);
  v5 = 32 - v4;
  v6 = 1 << (v4 - 32);
  LODWORD(v7) = 1 << v4;
  HIDWORD(v7) = v6 | (1u >> v5);
  LODWORD(v8) = sub_DD46C(v7);
  v9 = v8;
  v11 = v12 / v9 / 92.0 * 0.5;
  *a2 = v11;
  return 0;
}
// 546A8: variable 'v8' is possibly undefined

//----- (000546E0) --------------------------------------------------------
int overclock_update_dcr()
{
  return 0;
}

//----- (000546E8) --------------------------------------------------------
unsigned int __fastcall get_packet_remain_len_dcr(int a1)
{
  unsigned int result; // r0

  result = a1 - 1;
  if ( result >= 9 )
    return 8;
  return result;
}

//----- (000546F8) --------------------------------------------------------
int __fastcall global_idx_init_dcr(int a1)
{
  void *v2; // r0

  v2 = calloc(0x8008u, 1u);
  *(_DWORD *)(a1 + 760) = v2;
  printf("__custom_data init %p\n", v2);
  return 0;
}

//----- (00054728) --------------------------------------------------------
int __fastcall global_idx_free_dcr(int a1)
{
  free(*(void **)(a1 + 760));
  return 0;
}

//----- (0005473C) --------------------------------------------------------
int __fastcall sub_5473C(int a1)
{
  _DWORD v3[1025]; // [sp+10h] [bp-1004h] BYREF

  V_LOCK();
  logfmt_raw((char *)v3, 0x1000u, 0, "software_reset %s %02x", "ChipSetting_software_reset_DCR_1727", 68);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_software_reset_DCR_1727",
    35,
    95,
    20,
    v3);
  v3[2] = 4456449;
  v3[3] = 0;
  v3[1] = 0;
  v3[0] = 3;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v3);
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (000547FC) --------------------------------------------------------
int __fastcall set_sensor_extern_mode_dcr(int a1)
{
  int (__fastcall *v2)(int, _DWORD *); // r3
  int v3; // r6
  int result; // r0
  _DWORD v5[2]; // [sp+0h] [bp-10h] BYREF
  int v6; // [sp+8h] [bp-8h]
  int v7; // [sp+Ch] [bp-4h]

  v5[0] = 26806532;
  v6 = 16711680;
  v5[1] = 0;
  v7 = 0;
  v2 = *(int (__fastcall **)(int, _DWORD *))(a1 + 216);
  LOBYTE(v6) = 1;
  v3 = v2(a1, v5);
  usleep((__useconds_t)"rl_kda_2110");
  result = 0;
  if ( !v3 )
    *(_DWORD *)(a1 + 456) = 1;
  return result;
}

//----- (00054864) --------------------------------------------------------
int __fastcall sub_54864(int *a1, int a2)
{
  int v4; // r2
  int (__fastcall *v5)(int *, _DWORD *); // r3
  int v6; // r4
  int v8; // [sp+2Ch] [bp-1038h]
  _DWORD v9[2]; // [sp+30h] [bp-1034h] BYREF
  int v10; // [sp+38h] [bp-102Ch]
  int v11; // [sp+3Ch] [bp-1028h]
  _DWORD v12[7]; // [sp+40h] [bp-1024h] BYREF
  int v13; // [sp+5Ch] [bp-1008h]
  char v14[4100]; // [sp+60h] [bp-1004h] BYREF

  v9[1] = 0;
  v10 = 0;
  v11 = 0;
  v9[0] = 0;
  V_LOCK();
  V_INT((int)v12, "chain", a1[50]);
  logfmt_raw(
    v14,
    0x1000u,
    0,
    v13,
    v12[0],
    v12[1],
    v12[2],
    v12[3],
    v12[4],
    v12[5],
    v12[6],
    v13,
    "set core ticket mask reg %02x tm %02x",
    3,
    a2,
    v8,
    0,
    0,
    0,
    0);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_core_ticket_mask_DCR_1727",
    37,
    141,
    40,
    v14);
  v4 = a1[71];
  LOBYTE(v11) = -1;
  BYTE1(v11) = v4;
  v10 = 196609;
  BYTE2(v11) = 1;
  v5 = (int (__fastcall *)(int *, _DWORD *))a1[55];
  v9[0] = a2;
  v6 = v5(a1, v9);
  usleep(0x3E8u);
  a1[94] = a2;
  return v6;
}
// 548EC: variable 'v8' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005498C) --------------------------------------------------------
int __fastcall work_2_packet_dcr(int a1, _DWORD *a2, _BYTE *a3, _DWORD *a4)
{
  int v6; // r5
  char *v8; // r7
  const char *v9; // r1
  const void *v10; // r8
  int v11; // r12
  int v12; // r1
  _DWORD *v13; // r0
  _DWORD *v14; // r3
  int v15; // r11
  int v16; // r10
  int v17; // lr
  int v18; // r12
  int v19; // r12
  int v20; // r11
  int v21; // r10
  char v22; // r12
  __int16 v23; // r0
  int v24; // r3
  void (__fastcall *v25)(int, _DWORD *); // r3
  _DWORD v28[2]; // [sp+18h] [bp-1004h] BYREF
  int v29; // [sp+20h] [bp-FFCh]
  int v30; // [sp+24h] [bp-FF8h]

  v6 = *(_DWORD *)(a1 + 760);
  *a3 = 85;
  a3[1] = -86;
  a3[2] = 32;
  v8 = (char *)(v6 + 0x8000);
  v9 = (const char *)(a2 + 2);
  v10 = a2 + 10;
  if ( *(_DWORD *)(a1 + 436) == 1 )
    a3[2] = 48;
  v11 = (unsigned __int8)*v8;
  *(_QWORD *)(v6 + 8 * v11) = *((_QWORD *)v9 - 1);
  strcpy((char *)(v6 + 32 * (v11 + 32)), v9);
  v12 = (unsigned __int8)*v8;
  *(_DWORD *)(v6 + 4 * (v12 + 7040)) = a2[55];
  v13 = (_DWORD *)(v6 + 32 * (v12 + 896));
  v14 = a2 + 56;
  v15 = a2[56];
  v16 = a2[57];
  v17 = v14[2];
  v18 = v14[3];
  *v13 = v15;
  v13[1] = v16;
  v13[2] = v17;
  v13[3] = v18;
  v19 = v14[7];
  v20 = v14[4];
  v21 = v14[5];
  v13[6] = v14[6];
  v13[7] = v19;
  v13[4] = v20;
  v13[5] = v21;
  memcpy((void *)(v6 + 180 * (unsigned __int8)*v8 + 5120), v10, 0xB4u);
  v22 = *v8;
  a3[3] = *v8;
  *v8 = (v22 + 1) & 0x7F;
  memcpy(a3 + 4, v10, 0xB4u);
  if ( !memcmp(&last_header_dcr, v10, 0xB4u) )
  {
    V_LOCK();
    logfmt_raw((char *)v28, 0x1000u, 0, "found repeat work");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/backend_dcr_1727/backend_dcr_1727.c",
      171,
      "work_2_packet_dcr",
      17,
      119,
      80,
      v28);
  }
  memcpy(&last_header_dcr, v10, 0xB4u);
  v23 = BM_CRC16(a3 + 2, 182);
  a3[185] = v23;
  a3[184] = HIBYTE(v23);
  v24 = *(unsigned __int8 *)(a1 + 205);
  *a4 = 186;
  if ( v24 && *(_BYTE *)(a1 + 206) )
  {
    memset(*(void **)(a1 + 400), 0, 48 * *(_DWORD *)(a1 + 280));
    sub_54864((int *)a1, 39);
    *(_BYTE *)(a1 + 205) = 0;
  }
  V_LOCK();
  logfmt_raw((char *)v28, 0x1000u, 0, "bridge reset %s %02x", "ChipSetting_bridge_reset_DCR_1727", 68);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_bridge_reset_DCR_1727",
    33,
    82,
    20,
    v28);
  v28[1] = 0;
  v29 = 0;
  v30 = 0;
  v25 = *(void (__fastcall **)(int, _DWORD *))(a1 + 216);
  LOBYTE(v29) = 1;
  v28[0] = 2;
  HIWORD(v29) = 68;
  v25(a1, v28);
  usleep(0x14u);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00054C54) --------------------------------------------------------
int __fastcall sub_54C54(int a1, int a2)
{
  float v2; // s0
  __int16 v3; // r3
  int v4; // r12
  signed int v5; // r6
  float v6; // s19
  int v7; // r10
  int v8; // r11
  int v9; // r8
  int v10; // r5
  int v11; // r2
  int v12; // r4
  float v13; // s17
  int v14; // r0
  int v15; // r0
  float v16; // s16
  int v17; // r2
  signed int v19; // r7
  int v20; // r6
  unsigned int v22; // [sp+38h] [bp-104Ch]
  int v25; // [sp+4Ch] [bp-1038h]
  _DWORD v26[2]; // [sp+50h] [bp-1034h] BYREF
  int v27; // [sp+58h] [bp-102Ch]
  int v28; // [sp+5Ch] [bp-1028h]
  int v29; // [sp+60h] [bp-1024h] BYREF
  int v30; // [sp+64h] [bp-1020h]
  int v31; // [sp+68h] [bp-101Ch]
  int v32; // [sp+6Ch] [bp-1018h]
  __int64 v33; // [sp+70h] [bp-1014h]
  int v34; // [sp+78h] [bp-100Ch]
  int v35; // [sp+7Ch] [bp-1008h]
  char v36[4100]; // [sp+80h] [bp-1004h] BYREF

  v3 = 0;
  v27 = 0;
  v26[1] = 0;
  v28 = 0;
  v26[0] = 0;
  if ( !a2 )
    v3 = 8;
  LOBYTE(v27) = 1;
  if ( a2 )
  {
    if ( a2 == 1 )
      HIWORD(v27) = 12;
  }
  else
  {
    HIWORD(v27) = v3;
  }
  v4 = -1068236443;
  v5 = 2;
  v25 = 2;
LABEL_8:
  v6 = (float)v5;
  v7 = 0;
  v8 = 0;
LABEL_9:
  v9 = v8 + 1;
  v10 = v8;
  v22 = (v5 << 8) | 0xC0000000 | v7;
  while ( 1 )
  {
    v11 = (int)(float)((float)((float)((float)((float)(v10 + 1) * (float)((float)(v8 + 1) * v2)) * v6) / 25.0) * 100.0);
    v12 = v11 / 100;
    if ( v11 % 100 > 50 )
      ++v12;
    if ( (unsigned int)(v12 - 16) <= 0xEA )
    {
      v13 = (float)((float)v12 * 25.0) / v6;
      if ( (v5 != 1 || v13 <= 3125.0) && v13 <= 3200.0 && v13 >= 2000.0 )
      {
        v14 = sub_DCEB0(25 * v12, v5);
        v15 = sub_DCEB0(v14, v8 + 1);
        v16 = (float)sub_DCEB0(v15, v10 + 1);
        v17 = v13 > 2400.0;
        v4 = v10 & 7 | v22 | (v12 << 16) | (v17 << 28);
        if ( fabsf(v16 - v2) < 3.0 )
          break;
      }
    }
    if ( v10-- == 0 )
    {
      v7 += 16;
      ++v8;
      if ( v9 != 8 )
        goto LABEL_9;
      v5 = 1;
      if ( v25 == 1 )
      {
        v26[0] = v4;
        V_LOCK();
        V_INT((int)&v29, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v36,
          0x1000u,
          0,
          v35,
          v29,
          v30,
          v31,
          v32,
          v33,
          v34,
          v35,
          "set pll_no %d freq: %.2f, expected freq: %.2f",
          a2,
          0,
          0,
          v2);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_freq_DCR_1727",
          25,
          500,
          40,
          v36);
        goto LABEL_24;
      }
      v25 = 1;
      goto LABEL_8;
    }
  }
  v19 = v5;
  v20 = v10 & 7 | v22 | (v12 << 16) | (v17 << 28);
  V_LOCK();
  logfmt_raw(
    v36,
    0x1000u,
    0,
    "target_freq:%.2f actual_freq:%.2f,vco:%.2f fbdiv:%d refdiv:%d postdiv1:%d, postdiv2:%d",
    v2,
    v16,
    v13,
    v12,
    v19,
    v8,
    v10);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "inferred_plldivider",
    19,
    473,
    20,
    v36);
  v26[0] = v20;
  V_LOCK();
  V_INT((int)&v29, "chain", *(int *)(a1 + 200));
  logfmt_raw(
    v36,
    0x1000u,
    0,
    v35,
    v29,
    v30,
    v31,
    v32,
    v33,
    v34,
    v35,
    "set pll_no %d freq: %.2f, expected freq: %.2f",
    a2,
    v16,
    v2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_freq_DCR_1727",
    25,
    500,
    40,
    v36);
  if ( v16 > 0.0 )
    v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v26);
  else
    v10 = -1;
LABEL_24:
  usleep(0x2710u);
  return v10;
}
// 54D24: variable 'v2' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005508C) --------------------------------------------------------
int __fastcall set_frequency_dcr(int a1, int a2)
{
  sub_54C54(a1, a2);
  return 0;
}

//----- (0005509C) --------------------------------------------------------
int __fastcall sub_5509C(int a1, int a2)
{
  _DWORD v4[4]; // [sp+28h] [bp-1034h] BYREF
  _DWORD v5[7]; // [sp+38h] [bp-1024h] BYREF
  int v6; // [sp+54h] [bp-1008h]
  char v7[4100]; // [sp+58h] [bp-1004h] BYREF

  v4[0] = a2;
  v4[2] = 4194305;
  v4[3] = 0;
  v4[1] = 0;
  V_LOCK();
  V_INT((int)v5, "chain", *(int *)(a1 + 200));
  logfmt_raw(v7, 0x1000u, 0, v6, v5[0], v5[1], v5[2], v5[3], v5[4], v5[5], v5[6], v6, "set analog value %08x", v4[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_analog_mux_DCR_1727",
    31,
    745,
    40,
    v7);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v4);
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00055190) --------------------------------------------------------
int __fastcall sub_55190(int a1, int a2)
{
  if ( sub_5509C(a1, a2) )
    return 19;
  else
    return 0;
}

//----- (000551A8) --------------------------------------------------------
int __fastcall sub_551A8(int a1, int *a2)
{
  int v2; // r2
  _DWORD *v3; // r6
  int *v5; // r8
  int v6; // r3
  int v7; // r0
  int v8; // r1
  int v9; // r2
  int v10; // r3
  void (__fastcall *v11)(int, int *, int *, _DWORD, int, int, int, int, _DWORD); // r9
  int v12; // r3
  int v13; // r2
  int v14; // r2
  int *v16; // [sp+38h] [bp-109Ch]
  int v17; // [sp+40h] [bp-1094h] BYREF
  int v18; // [sp+44h] [bp-1090h] BYREF
  int v19; // [sp+48h] [bp-108Ch] BYREF
  int v20; // [sp+4Ch] [bp-1088h] BYREF
  _DWORD v21[7]; // [sp+50h] [bp-1084h] BYREF
  int v22; // [sp+6Ch] [bp-1068h]
  _DWORD v23[7]; // [sp+70h] [bp-1064h] BYREF
  int v24; // [sp+8Ch] [bp-1048h]
  _DWORD v25[7]; // [sp+90h] [bp-1044h] BYREF
  int v26; // [sp+ACh] [bp-1028h]
  _DWORD v27[7]; // [sp+B0h] [bp-1024h] BYREF
  int v28; // [sp+CCh] [bp-1008h]
  char v29[4100]; // [sp+D0h] [bp-1004h] BYREF

  v2 = *(_DWORD *)(a1 + 340);
  v3 = *(_DWORD **)(a1 + 332);
  v17 = -64;
  v18 = -64;
  if ( v2 > 0 )
  {
    v16 = &a2[2 * v2];
    v5 = a2;
    do
    {
      v19 = 0;
      (*(void (__fastcall **)(int, int *, int *, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(a1 + 140))(
        a1,
        &v17,
        &v19,
        *v3,
        v3[1],
        v3[2],
        v3[3],
        v3[4],
        v3[5]);
      if ( v19 )
      {
        v6 = v17;
        if ( v17 >= -63 )
          goto LABEL_4;
        v17 = -64;
        V_LOCK();
        V_INT((int)v21, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v29,
          0x1000u,
          0,
          v22,
          v21[0],
          v21[1],
          v21[2],
          v21[3],
          v21[4],
          v21[5],
          v21[6],
          v22,
          "got uneffective temp, sensor[%d], addr:%02x",
          *v3,
          v3[5]);
        V_UNLOCK();
        v13 = 263;
      }
      else
      {
        v17 = -64;
        V_LOCK();
        V_INT((int)v23, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v29,
          0x1000u,
          0,
          v24,
          v23[0],
          v23[1],
          v23[2],
          v23[3],
          v23[4],
          v23[5],
          v23[6],
          v24,
          "read sensor failed, sensor[%d], addr:%02x",
          *v3,
          v3[5]);
        V_UNLOCK();
        v13 = 268;
      }
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/backend_dcr_1727/backend_dcr_1727.c",
        171,
        "read_temperature_dcr",
        20,
        v13,
        100,
        v29);
      v6 = v17;
LABEL_4:
      *v5 = v6;
      v7 = v3[1];
      v8 = v3[2];
      v9 = v3[3];
      v10 = v3[4];
      v11 = *(void (__fastcall **)(int, int *, int *, _DWORD, int, int, int, int, _DWORD))(a1 + 144);
      v20 = 0;
      v11(a1, &v18, &v20, *v3, v7, v8, v9, v10, v3[5]);
      if ( !v20 )
      {
        v18 = -64;
        V_LOCK();
        V_INT((int)v27, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v29,
          0x1000u,
          0,
          v28,
          v27[0],
          v27[1],
          v27[2],
          v27[3],
          v27[4],
          v27[5],
          v27[6],
          v28,
          "read sensor failed, sensor[%d], addr:%02x",
          *v3,
          v3[5]);
        V_UNLOCK();
        v14 = 283;
LABEL_11:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/backend_dcr_1727/backend_dcr_1727.c",
          171,
          "read_temperature_dcr",
          20,
          v14,
          100,
          v29);
        v12 = v18;
        goto LABEL_6;
      }
      v12 = v18;
      if ( v18 < -63 )
      {
        v18 = -64;
        V_LOCK();
        V_INT((int)v25, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v29,
          0x1000u,
          0,
          v26,
          v25[0],
          v25[1],
          v25[2],
          v25[3],
          v25[4],
          v25[5],
          v25[6],
          v26,
          "got uneffective temp, sensor[%d], addr:%02x",
          *v3,
          v3[5]);
        V_UNLOCK();
        v14 = 278;
        goto LABEL_11;
      }
LABEL_6:
      v5[1] = v12;
      v5 += 2;
      usleep((__useconds_t)&loc_7A120);
      v3 += 6;
    }
    while ( v16 != v5 );
  }
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00055520) --------------------------------------------------------
int __fastcall sub_55520(int a1, int a2)
{
  int v4; // r2
  int v5; // r7
  int v6; // r7
  int v7; // r7
  int *v8; // r6
  int v9; // r0
  int v10; // r12
  int v11; // r2
  int v12; // r3
  int v13; // r8
  int v15; // [sp+4h] [bp-10E8h]
  int v16; // [sp+38h] [bp-10B4h]
  int *ptr; // [sp+4Ch] [bp-10A0h]
  int v18; // [sp+54h] [bp-1098h] BYREF
  _DWORD v19[2]; // [sp+58h] [bp-1094h] BYREF
  int v20; // [sp+60h] [bp-108Ch]
  int v21; // [sp+64h] [bp-1088h]
  _DWORD v22[7]; // [sp+68h] [bp-1084h] BYREF
  int v23; // [sp+84h] [bp-1068h]
  _DWORD v24[7]; // [sp+88h] [bp-1064h] BYREF
  int v25; // [sp+A4h] [bp-1048h]
  _DWORD v26[7]; // [sp+A8h] [bp-1044h] BYREF
  int v27; // [sp+C4h] [bp-1028h]
  _DWORD v28[7]; // [sp+C8h] [bp-1024h] BYREF
  int v29; // [sp+E4h] [bp-1008h]
  char v30[4100]; // [sp+E8h] [bp-1004h] BYREF

  V_LOCK();
  V_INT((int)v22, "chain", *(int *)(a1 + 200));
  logfmt_raw(
    v30,
    0x1000u,
    0,
    v23,
    v22[0],
    v22[1],
    v22[2],
    v22[3],
    v22[4],
    v22[5],
    v22[6],
    v23,
    "set clock delay chip_no %d, value %08x",
    *(_DWORD *)(a1 + 280),
    a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_clock_delay_DCR_1727",
    32,
    597,
    40,
    v30);
  v19[1] = 0;
  v21 = 255;
  v19[0] = a2;
  v20 = 1;
  if ( (*(int (__fastcall **)(int, _DWORD *))(a1 + 220))(a1, v19) < 0 )
  {
    V_LOCK();
    v16 = -1;
    V_INT((int)v24, "chain", *(int *)(a1 + 200));
    logfmt_raw(
      v30,
      0x1000u,
      0,
      v25,
      v24[0],
      v24[1],
      v24[2],
      v24[3],
      v24[4],
      v24[5],
      v24[6],
      v25,
      "%s failed, set reg:%02x",
      "ChipSetting_clock_delay_DCR_1727",
      HIWORD(v20));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_clock_delay_DCR_1727",
      32,
      606,
      100,
      v30);
  }
  else
  {
    usleep((__useconds_t)"rl_kda_2110");
    v4 = *(_DWORD *)(a1 + 280);
    v5 = *(_DWORD *)(a1 + 284);
    LOBYTE(v21) = 0;
    v6 = v5 * v4;
    ptr = (int *)calloc(12 * v6, 1u);
    (*(void (__fastcall **)(int, _DWORD *, int, int *, int *, int, int, _DWORD))(a1 + 244))(
      a1,
      v19,
      v6,
      ptr,
      &v18,
      v15,
      2000,
      0);
    if ( v18 > 0 )
    {
      v7 = 0;
      v16 = 0;
      v8 = ptr;
      do
      {
        v12 = *v8;
        v13 = *((unsigned __int16 *)v8 + 3);
        HIBYTE(v24[0]) = *v8;
        BYTE2(v24[0]) = BYTE1(v12);
        BYTE1(v24[0]) = BYTE2(v12);
        LOBYTE(v24[0]) = HIBYTE(v12);
        V_LOCK();
        if ( v13 )
        {
          V_INT((int)v28, "chain", *(int *)(a1 + 200));
          logfmt_raw(
            v30,
            0x1000u,
            0,
            v29,
            v28[0],
            v28[1],
            v28[2],
            v28[3],
            v28[4],
            v28[5],
            v28[6],
            v29,
            "[DP] chip %02x, expected reg %02x, but %02x, data %08x",
            *((unsigned __int8 *)v8 + 4),
            0,
            *((unsigned __int16 *)v8 + 3),
            v24[0]);
          V_UNLOCK();
          v9 = g_zc;
          v10 = 100;
          v11 = 625;
        }
        else
        {
          ++v16;
          V_INT((int)v26, "chain", *(int *)(a1 + 200));
          logfmt_raw(
            v30,
            0x1000u,
            0,
            v27,
            v26[0],
            v26[1],
            v26[2],
            v26[3],
            v26[4],
            v26[5],
            v26[6],
            v27,
            "[DP] chip %02x, core %02x, reg %02x, clk_delay %08x",
            *((unsigned __int8 *)v8 + 4),
            *((unsigned __int8 *)v8 + 8),
            *((unsigned __int16 *)v8 + 3),
            v24[0]);
          V_UNLOCK();
          v9 = g_zc;
          v10 = 20;
          v11 = 622;
        }
        ++v7;
        v8 += 3;
        zlog(
          v9,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_clock_delay_DCR_1727",
          32,
          v11,
          v10,
          v30);
      }
      while ( v18 > v7 );
    }
    else
    {
      v16 = 0;
    }
    free(ptr);
  }
  return v16;
}
// 55670: variable 'v15' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (000558E0) --------------------------------------------------------
int __fastcall sub_558E0(int a1, int a2)
{
  if ( *(_DWORD *)(a1 + 284) * *(_DWORD *)(a1 + 280) == sub_55520(a1, a2) )
    return 19;
  else
    return 0;
}

//----- (00055908) --------------------------------------------------------
int __fastcall sub_55908(int a1, int a2, char a3)
{
  int v4; // r6
  _DWORD *v5; // r10
  _DWORD *v6; // r4
  int (__fastcall *v7)(int, _DWORD *); // r3
  int result; // r0
  int v9; // [sp+40h] [bp-1094h]
  int v10; // [sp+44h] [bp-1090h]
  char v11; // [sp+48h] [bp-108Ch]
  char v12; // [sp+50h] [bp-1084h]
  int v14; // [sp+5Ch] [bp-1078h] BYREF
  _DWORD v15[2]; // [sp+60h] [bp-1074h] BYREF
  int v16; // [sp+68h] [bp-106Ch]
  int v17; // [sp+6Ch] [bp-1068h]
  _DWORD v18[7]; // [sp+70h] [bp-1064h] BYREF
  int v19; // [sp+8Ch] [bp-1048h]
  _DWORD v20[7]; // [sp+90h] [bp-1044h] BYREF
  int v21; // [sp+ACh] [bp-1028h]
  _DWORD v22[7]; // [sp+B0h] [bp-1024h] BYREF
  int v23; // [sp+CCh] [bp-1008h]
  char v24[4100]; // [sp+D0h] [bp-1004h] BYREF

  v9 = a3 & 1;
  v14 = 0;
  if ( a2 == -1 || *(_DWORD *)(a1 + 280) < a2 )
  {
    v11 = 0;
    v12 = 1;
  }
  else
  {
    v12 = 0;
    v11 = *(_BYTE *)(*(_DWORD *)(a1 + 432) + a2);
  }
  v4 = 0;
  v16 = 0x10000;
  v15[1] = 0;
  v15[0] = 0;
  BYTE1(v16) = v11;
  v17 = 0;
  v5 = calloc(0xCu, 1u);
  (*(void (__fastcall **)(int, _DWORD *, int, _DWORD *, int *))(a1 + 244))(a1, v15, 1, v5, &v14);
  if ( v14 <= 0 )
  {
    v10 = v9;
  }
  else
  {
    v6 = v5;
    v10 = v9;
    do
    {
      if ( *((_WORD *)v6 + 3) == 1 )
      {
        V_LOCK();
        V_INT((int)v18, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v24,
          0x1000u,
          0,
          v19,
          v18[0],
          v18[1],
          v18[2],
          v18[3],
          v18[4],
          v18[5],
          v18[6],
          v19,
          "%s chip %02x, core %02x, reg %02x, core_mode %08x",
          "ChipSetting_same_nonce_DCR_1727",
          *((unsigned __int8 *)v6 + 4),
          *((unsigned __int8 *)v6 + 8),
          *((unsigned __int16 *)v6 + 3),
          *v6);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_same_nonce_DCR_1727",
          31,
          268,
          20,
          v24);
        v10 = v9 | *v6;
      }
      else
      {
        V_LOCK();
        V_INT((int)v20, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v24,
          0x1000u,
          0,
          v21,
          v20[0],
          v20[1],
          v20[2],
          v20[3],
          v20[4],
          v20[5],
          v20[6],
          v21,
          "%s chip %02x, expected reg %02x, but %02x, core_mode %08x",
          "ChipSetting_same_nonce_DCR_1727",
          *((unsigned __int8 *)v6 + 4),
          5,
          *((unsigned __int16 *)v6 + 3),
          *v6);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_same_nonce_DCR_1727",
          31,
          272,
          100,
          v24);
      }
      ++v4;
      v6 += 3;
    }
    while ( v14 > v4 );
  }
  free(v5);
  HIWORD(v16) = 1;
  LOBYTE(v17) = -1;
  LOBYTE(v16) = v12;
  v7 = *(int (__fastcall **)(int, _DWORD *))(a1 + 220);
  BYTE1(v16) = v11;
  v15[0] = v10;
  result = v7(a1, v15);
  if ( result < 0 )
  {
    V_LOCK();
    V_INT((int)v22, "chain", *(int *)(a1 + 200));
    logfmt_raw(
      v24,
      0x1000u,
      0,
      v23,
      v22[0],
      v22[1],
      v22[2],
      v22[3],
      v22[4],
      v22[5],
      v22[6],
      v23,
      "set same nonce failed! chip_id:%d",
      a2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_same_nonce_DCR_1727",
      31,
      285,
      100,
      v24);
    return -1;
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00055C84) --------------------------------------------------------
int __fastcall sub_55C84(int a1, int a2, char a3)
{
  sub_55908(a1, a2, a3);
  usleep(0x2710u);
  return 0;
}

//----- (00055C9C) --------------------------------------------------------
bool __fastcall sub_55C9C(int a1, int a2, char **a3)
{
  char v3; // r3
  _DWORD *v5; // r8
  int v6; // r6
  _DWORD *v7; // r5
  int v8; // r3
  int v9; // r10
  void *v10; // r0
  char *v11; // r8
  int v12; // r5
  int v13; // r6
  _DWORD *v14; // r5
  const char *v15; // r5
  int v17; // [sp+4h] [bp-10E8h]
  char *s; // [sp+40h] [bp-10ACh]
  char *v20; // [sp+44h] [bp-10A8h]
  _DWORD *ptr; // [sp+4Ch] [bp-10A0h]
  int v22; // [sp+54h] [bp-1098h] BYREF
  int v23; // [sp+58h] [bp-1094h] BYREF
  int v24; // [sp+5Ch] [bp-1090h]
  int v25; // [sp+60h] [bp-108Ch]
  int v26; // [sp+64h] [bp-1088h]
  _DWORD v27[7]; // [sp+68h] [bp-1084h] BYREF
  int v28; // [sp+84h] [bp-1068h]
  _DWORD v29[7]; // [sp+88h] [bp-1064h] BYREF
  int v30; // [sp+A4h] [bp-1048h]
  _DWORD v31[7]; // [sp+A8h] [bp-1044h] BYREF
  int v32; // [sp+C4h] [bp-1028h]
  _DWORD v33[7]; // [sp+C8h] [bp-1024h] BYREF
  int v34; // [sp+E4h] [bp-1008h]
  char v35[4100]; // [sp+E8h] [bp-1004h] BYREF

  v3 = 0;
  v22 = 0;
  if ( a2 != -1 && *(_DWORD *)(a1 + 280) >= a2 )
    v3 = *(_BYTE *)(*(_DWORD *)(a1 + 432) + a2);
  v25 = 3932160;
  v24 = 0;
  v23 = 0;
  v26 = 0;
  BYTE1(v25) = v3;
  v5 = calloc(0xCu, 1u);
  (*(void (__fastcall **)(int, int *, int, _DWORD *, int *))(a1 + 236))(a1, &v23, 1, v5, &v22);
  if ( v22 <= 0 )
  {
    v20 = 0;
  }
  else
  {
    v20 = 0;
    v6 = 0;
    v7 = v5;
    do
    {
      while ( 1 )
      {
        ++v6;
        if ( *((_WORD *)v7 + 3) == 60 )
          break;
        v7 += 3;
        if ( v22 <= v6 )
          goto LABEL_9;
      }
      v8 = *v5;
      v7 += 3;
      HIBYTE(v33[0]) = *v5;
      BYTE2(v33[0]) = BYTE1(v8);
      BYTE1(v33[0]) = BYTE2(v8);
      LOBYTE(v33[0]) = HIBYTE(v8);
      v9 = v33[0];
      V_LOCK();
      v20 += v9;
      V_INT((int)v27, "chain", *(int *)(a1 + 200));
      logfmt_raw(
        v35,
        0x1000u,
        0,
        v28,
        v27[0],
        v27[1],
        v27[2],
        v27[3],
        v27[4],
        v27[5],
        v27[6],
        v28,
        "[Top Nonce Cnt] asic %02x, reg %02x cnt %08x",
        *((unsigned __int8 *)v7 - 8),
        *((unsigned __int16 *)v7 - 3),
        v9);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/chip_setting.c",
        150,
        "ChipSetting_nonce_counter_DCR_1727",
        34,
        321,
        20,
        v35);
    }
    while ( v22 > v6 );
  }
LABEL_9:
  v10 = v5;
  v11 = 0;
  free(v10);
  *a3 = v20;
  v12 = *(_DWORD *)(a1 + 284);
  v25 = 655360;
  v26 = 255;
  v23 = 1;
  v24 = 0;
  ptr = calloc(12 * v12, 1u);
  (*(void (__fastcall **)(int, int *, int, _DWORD *, int *, int, int, _DWORD))(a1 + 244))(
    a1,
    &v23,
    v12,
    ptr,
    &v22,
    v17,
    2000,
    0);
  if ( v22 > 0 )
  {
    v13 = 0;
    v14 = ptr;
    s = 0;
    do
    {
      if ( *((_WORD *)v14 + 3) == 10 )
      {
        s += *v14;
        V_LOCK();
        V_INT((int)v29, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v35,
          0x1000u,
          0,
          v30,
          v29[0],
          v29[1],
          v29[2],
          v29[3],
          v29[4],
          v29[5],
          v29[6],
          v30,
          "%s chip %02x, core %02x, reg %02x, core_nonce_cnt %08x",
          "ChipSetting_nonce_counter_DCR_1727",
          *((unsigned __int8 *)v14 + 4),
          *((unsigned __int8 *)v14 + 8),
          *((unsigned __int16 *)v14 + 3),
          *v14);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_nonce_counter_DCR_1727",
          34,
          344,
          20,
          v35);
      }
      else
      {
        V_LOCK();
        V_INT((int)v31, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v35,
          0x1000u,
          0,
          v32,
          v31[0],
          v31[1],
          v31[2],
          v31[3],
          v31[4],
          v31[5],
          v31[6],
          v32,
          "%s chip %02x, expected reg %02x, but %02x, core_nonce_cnt %08x",
          "ChipSetting_nonce_counter_DCR_1727",
          *((unsigned __int8 *)v14 + 4),
          5,
          *((unsigned __int16 *)v14 + 3),
          *v14);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_nonce_counter_DCR_1727",
          34,
          347,
          100,
          v35);
      }
      ++v13;
      v14 += 3;
    }
    while ( v22 > v13 );
    v11 = s;
  }
  free(ptr);
  V_LOCK();
  V_INT((int)v33, "chain", *(int *)(a1 + 200));
  v15 = "Failed";
  if ( v20 == v11 )
    v15 = "Pass";
  logfmt_raw(
    v35,
    0x1000u,
    0,
    v34,
    v33[0],
    v33[1],
    v33[2],
    v33[3],
    v33[4],
    v33[5],
    v33[6],
    v34,
    "check nonce counter, top_nonce_cnt %d, core_nocne_cnt %d (%s)",
    v20,
    v11,
    v15);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_nonce_counter_DCR_1727",
    34,
    353,
    40,
    v35);
  return v20 != v11;
}
// 55EDC: variable 'v17' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00056178) --------------------------------------------------------
int __fastcall sub_56178(int a1, int a2, char **a3)
{
  if ( sub_55C9C(a1, a2, a3) )
    return 19;
  else
    return 0;
}

//----- (00056190) --------------------------------------------------------
int __fastcall sub_56190(int a1)
{
  int v2; // r6
  int v3; // r2
  int v4; // r0
  int v5; // r9
  int *v6; // r5
  int v7; // r0
  int v8; // r12
  int v9; // r2
  int v10; // r3
  int v11; // r2
  int v13; // [sp+4h] [bp-10E0h]
  int v14; // [sp+3Ch] [bp-10A8h]
  int *ptr; // [sp+44h] [bp-10A0h]
  int v16; // [sp+4Ch] [bp-1098h] BYREF
  _DWORD v17[2]; // [sp+50h] [bp-1094h] BYREF
  int v18; // [sp+58h] [bp-108Ch]
  int v19; // [sp+5Ch] [bp-1088h]
  _DWORD v20[7]; // [sp+60h] [bp-1084h] BYREF
  int v21; // [sp+7Ch] [bp-1068h]
  _DWORD v22[7]; // [sp+80h] [bp-1064h] BYREF
  int v23; // [sp+9Ch] [bp-1048h]
  _DWORD v24[7]; // [sp+A0h] [bp-1044h] BYREF
  int v25; // [sp+BCh] [bp-1028h]
  _DWORD v26[7]; // [sp+C0h] [bp-1024h] BYREF
  int v27; // [sp+DCh] [bp-1008h]
  char v28[4100]; // [sp+E0h] [bp-1004h] BYREF

  V_LOCK();
  V_INT((int)v20, "chain", *(int *)(a1 + 200));
  v2 = 0;
  logfmt_raw(
    v28,
    0x1000u,
    0,
    v21,
    v20[0],
    v20[1],
    v20[2],
    v20[3],
    v20[4],
    v20[5],
    v20[6],
    v21,
    "get hash clock count chip_no %d",
    *(_DWORD *)(a1 + 280));
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_hash_clock_count_DCR_1727",
    37,
    692,
    20,
    v28);
  v18 = 393217;
  v17[1] = 0;
  v17[0] = 1;
  v19 = 255;
  if ( (*(int (__fastcall **)(int, _DWORD *))(a1 + 220))(a1, v17) < 0 )
  {
    V_LOCK();
    v14 = -1;
    V_INT((int)v22, "chain", *(int *)(a1 + 200));
    logfmt_raw(
      v28,
      0x1000u,
      0,
      v23,
      v22[0],
      v22[1],
      v22[2],
      v22[3],
      v22[4],
      v22[5],
      v22[6],
      v23,
      "%s failed, set reg:%02x",
      "ChipSetting_hash_clock_count_DCR_1727",
      HIWORD(v18));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_hash_clock_count_DCR_1727",
      37,
      701,
      100,
      v28);
  }
  else
  {
    usleep(0x4E20u);
    v3 = *(_DWORD *)(a1 + 280);
    v4 = *(_DWORD *)(a1 + 284);
    v18 = 458753;
    v5 = v4 * v3;
    LOBYTE(v19) = 0;
    ptr = (int *)calloc(12 * v4 * v3, 1u);
    (*(void (__fastcall **)(int, _DWORD *, int, int *, int *, int, int, _DWORD))(a1 + 244))(
      a1,
      v17,
      v5,
      ptr,
      &v16,
      v13,
      2000,
      0);
    v14 = 0;
    if ( v16 > 0 )
    {
      v6 = ptr;
      do
      {
        v10 = *v6;
        v11 = *((unsigned __int16 *)v6 + 3);
        HIBYTE(v22[0]) = *v6;
        BYTE2(v22[0]) = BYTE1(v10);
        BYTE1(v22[0]) = BYTE2(v10);
        LOBYTE(v22[0]) = HIBYTE(v10);
        if ( v11 == 7 )
        {
          V_LOCK();
          ++v14;
          V_INT((int)v24, "chain", *(int *)(a1 + 200));
          logfmt_raw(
            v28,
            0x1000u,
            0,
            v25,
            v24[0],
            v24[1],
            v24[2],
            v24[3],
            v24[4],
            v24[5],
            v24[6],
            v25,
            "[Hash clk cnt] chip %02x, core %02x, reg %02x, clk_cnt %08x",
            *((unsigned __int8 *)v6 + 4),
            *((unsigned __int8 *)v6 + 8),
            *((unsigned __int16 *)v6 + 3),
            v22[0]);
          V_UNLOCK();
          v7 = g_zc;
          v8 = 40;
          v9 = 720;
        }
        else
        {
          V_LOCK();
          V_INT((int)v26, "chain", *(int *)(a1 + 200));
          logfmt_raw(
            v28,
            0x1000u,
            0,
            v27,
            v26[0],
            v26[1],
            v26[2],
            v26[3],
            v26[4],
            v26[5],
            v26[6],
            v27,
            "[Hash clk cnt] chip %02x, expected reg %02x, but %02x, clk_cnt %08x",
            *((unsigned __int8 *)v6 + 4),
            7,
            *((unsigned __int16 *)v6 + 3),
            v22[0]);
          V_UNLOCK();
          v7 = g_zc;
          v8 = 100;
          v9 = 723;
        }
        ++v2;
        v6 += 3;
        zlog(
          v7,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_hash_clock_count_DCR_1727",
          37,
          v9,
          v8,
          v28);
      }
      while ( v16 > v2 );
    }
    free(ptr);
  }
  return v14;
}
// 562EC: variable 'v13' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00056540) --------------------------------------------------------
int __fastcall sub_56540(int a1)
{
  if ( *(_DWORD *)(a1 + 284) * *(_DWORD *)(a1 + 280) == sub_56190(a1) )
    return 19;
  else
    return 0;
}

//----- (00056568) --------------------------------------------------------
int __fastcall sub_56568(int a1)
{
  int v2; // r6
  int (__fastcall *v3)(int, _DWORD *); // r3
  int v4; // r8
  int v5; // r2
  int v6; // r5
  int v7; // r5
  _WORD *v8; // r5
  int v9; // r0
  int v10; // r12
  int v11; // r2
  int v13; // [sp+3Ch] [bp-1088h]
  _WORD *ptr; // [sp+44h] [bp-1080h]
  int v15; // [sp+48h] [bp-107Ch]
  int v16; // [sp+4Ch] [bp-1078h]
  _DWORD v17[2]; // [sp+50h] [bp-1074h] BYREF
  int v18; // [sp+58h] [bp-106Ch]
  int v19; // [sp+5Ch] [bp-1068h]
  _DWORD v20[7]; // [sp+60h] [bp-1064h] BYREF
  int v21; // [sp+7Ch] [bp-1048h]
  _DWORD v22[7]; // [sp+80h] [bp-1044h] BYREF
  int v23; // [sp+9Ch] [bp-1028h]
  _DWORD v24[7]; // [sp+A0h] [bp-1024h] BYREF
  int v25; // [sp+BCh] [bp-1008h]
  char v26[4100]; // [sp+C0h] [bp-1004h] BYREF

  V_LOCK();
  V_INT((int)v20, "chain", *(int *)(a1 + 200));
  logfmt_raw(
    v26,
    0x1000u,
    0,
    v21,
    v20[0],
    v20[1],
    v20[2],
    v20[3],
    v20[4],
    v20[5],
    v20[6],
    v21,
    "get pmdata chip_no %d",
    *(_DWORD *)(a1 + 280));
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_pmdata_DCR_1727",
    27,
    640,
    20,
    v26);
  v2 = 0;
  v18 = 0;
  v19 = 0;
  v13 = 0;
  v17[1] = 0;
  v3 = *(int (__fastcall **)(int, _DWORD *))(a1 + 220);
  while ( 1 )
  {
    if ( v2 == 3 )
      goto LABEL_12;
    LOBYTE(v18) = 1;
    HIWORD(v18) = 255;
    v17[0] = (16 * v2) | 1;
    LOBYTE(v19) = -1;
    if ( v3(a1, v17) < 0 )
      break;
    v4 = 0;
    usleep(0x4E20u);
    v5 = *(_DWORD *)(a1 + 280);
    v6 = *(_DWORD *)(a1 + 284);
    v18 = 327681;
    v7 = v6 * v5;
    LOBYTE(v19) = 0;
    ptr = calloc(12 * v7, 1u);
    (*(void (__fastcall **)(int, _DWORD *, int))(a1 + 244))(a1, v17, v7);
    if ( v15 > 0 )
    {
      v8 = ptr;
      do
      {
        HIBYTE(v16) = *(_DWORD *)v8;
        BYTE2(v16) = BYTE1(*(_DWORD *)v8);
        BYTE1(v16) = BYTE2(*(_DWORD *)v8);
        LOBYTE(v16) = HIBYTE(*(_DWORD *)v8);
        if ( v8[3] == 5 )
        {
          V_LOCK();
          ++v13;
          V_INT((int)v22, "chain", *(int *)(a1 + 200));
          logfmt_raw(
            v26,
            0x1000u,
            0,
            v23,
            v22[0],
            v22[1],
            v22[2],
            v22[3],
            v22[4],
            v22[5],
            v22[6],
            v23,
            "[PM data] chip %02x, reg %02x mode %d PMDATA %08x",
            *((unsigned __int8 *)v8 + 4),
            (unsigned __int16)v8[3],
            v2,
            v16);
          V_UNLOCK();
          v9 = g_zc;
          v10 = 40;
          v11 = 672;
        }
        else
        {
          V_LOCK();
          V_INT((int)v24, "chain", *(int *)(a1 + 200));
          logfmt_raw(
            v26,
            0x1000u,
            0,
            v25,
            v24[0],
            v24[1],
            v24[2],
            v24[3],
            v24[4],
            v24[5],
            v24[6],
            v25,
            "[PM data] chip %02x, expected reg %02x, but %02x mode %d PMDATA %08x",
            *((unsigned __int8 *)v8 + 4),
            5,
            (unsigned __int16)v8[3],
            v2,
            v16);
          V_UNLOCK();
          v9 = g_zc;
          v10 = 100;
          v11 = 675;
        }
        ++v4;
        v8 += 6;
        zlog(
          v9,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_pmdata_DCR_1727",
          27,
          v11,
          v10,
          v26);
      }
      while ( v15 > v4 );
    }
    if ( v2 == 6 )
    {
      free(ptr);
      return v13;
    }
    v3 = *(int (__fastcall **)(int, _DWORD *))(a1 + 220);
LABEL_12:
    ++v2;
  }
  V_LOCK();
  logfmt_raw(v26, 0x1000u, 0, "%s failed, set reg:%02x", "ChipSetting_pmdata_DCR_1727", HIWORD(v18));
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_pmdata_DCR_1727",
    27,
    653,
    100,
    v26);
  return -1;
}
// 566F4: variable 'v15' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005691C) --------------------------------------------------------
int __fastcall sub_5691C(int a1)
{
  if ( *(_DWORD *)(a1 + 284) * *(_DWORD *)(a1 + 280) == sub_56568(a1) )
    return 19;
  else
    return 0;
}

//----- (00056944) --------------------------------------------------------
int __fastcall sub_56944(int a1, int a2)
{
  int v3; // r5
  _DWORD *v4; // r11
  _DWORD *v5; // r9
  _DWORD *v6; // r6
  int v7; // r3
  int v8; // r4
  int v11; // [sp+48h] [bp-105Ch] BYREF
  int v12; // [sp+4Ch] [bp-1058h]
  _DWORD v13[2]; // [sp+50h] [bp-1054h] BYREF
  int v14; // [sp+58h] [bp-104Ch]
  int v15; // [sp+5Ch] [bp-1048h]
  _DWORD v16[7]; // [sp+60h] [bp-1044h] BYREF
  int v17; // [sp+7Ch] [bp-1028h]
  _DWORD v18[7]; // [sp+80h] [bp-1024h] BYREF
  int v19; // [sp+9Ch] [bp-1008h]
  char v20[4100]; // [sp+A0h] [bp-1004h] BYREF

  v5 = *(_DWORD **)(a1 + 280);
  v3 = 0;
  v14 = 1835009;
  v13[1] = 0;
  v13[0] = 0;
  v15 = 0;
  v11 = 0;
  v4 = calloc(12 * (_DWORD)v5, 1u);
  (*(void (__fastcall **)(int, _DWORD *, _DWORD *, _DWORD *, int *))(a1 + 236))(a1, v13, v5, v4, &v11);
  LOWORD(v5) = (unsigned __int16)&g_zc;
  if ( v11 > 0 )
  {
    HIWORD(v5) = (unsigned int)&g_zc >> 16;
    v6 = v4;
    do
    {
      while ( 1 )
      {
        ++v3;
        if ( *((_WORD *)v6 + 3) == 28 )
          break;
        v6 += 3;
        if ( v11 <= v3 )
          goto LABEL_7;
      }
      V_LOCK();
      v6 += 3;
      V_INT((int)v16, "chain", *(int *)(a1 + 200));
      logfmt_raw(
        v20,
        0x1000u,
        0,
        v17,
        v16[0],
        v16[1],
        v16[2],
        v16[3],
        v16[4],
        v16[5],
        v16[6],
        v17,
        "[MISC CTRL] asic %02x, reg %02x state %08x",
        *((unsigned __int8 *)v6 - 8),
        *((unsigned __int16 *)v6 - 3),
        *(v6 - 3));
      V_UNLOCK();
      zlog(
        *v5,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/chip_setting.c",
        150,
        "ChipSetting_pll_sel_DCR_1727",
        28,
        189,
        20,
        v20);
    }
    while ( v11 > v3 );
  }
  else
  {
    HIWORD(v5) = (unsigned int)&g_zc >> 16;
  }
LABEL_7:
  v7 = *v4;
  HIBYTE(v12) = *v4;
  BYTE2(v12) = BYTE1(v7);
  BYTE1(v12) = BYTE2(v7);
  LOBYTE(v12) = HIBYTE(v7);
  free(v4);
  v14 = 1835009;
  v13[0] = v12 & 0xFFFFFFFB | (4 * (_BYTE)a2) & 4;
  V_LOCK();
  V_INT((int)v18, "chain", *(int *)(a1 + 200));
  logfmt_raw(
    v20,
    0x1000u,
    0,
    v19,
    v18[0],
    v18[1],
    v18[2],
    v18[3],
    v18[4],
    v18[5],
    v18[6],
    v19,
    "set pll sel %u %08x",
    a2,
    v13[0]);
  V_UNLOCK();
  zlog(
    *v5,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_pll_sel_DCR_1727",
    28,
    201,
    40,
    v20);
  v8 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v13);
  usleep(0x2710u);
  return v8;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00056BEC) --------------------------------------------------------
int __fastcall sub_56BEC(int a1, int a2)
{
  if ( sub_56944(a1, a2) )
    return 19;
  else
    return 0;
}

//----- (00056C04) --------------------------------------------------------
int __fastcall sub_56C04(int a1, int a2)
{
  int v3; // r4
  _DWORD v5[4]; // [sp+28h] [bp-1034h] BYREF
  _DWORD v6[7]; // [sp+38h] [bp-1024h] BYREF
  int v7; // [sp+54h] [bp-1008h]
  char v8[4100]; // [sp+58h] [bp-1004h] BYREF

  v5[0] = a2;
  v5[2] = 2883585;
  v5[3] = 0;
  v5[1] = 0;
  V_LOCK();
  V_INT((int)v6, "chain", *(int *)(a1 + 200));
  logfmt_raw(v8, 0x1000u, 0, v7, v6[0], v6[1], v6[2], v6[3], v6[4], v6[5], v6[6], v7, "set io cfg value %08x", v5[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_io_cfg_DCR_1727",
    27,
    233,
    40,
    v8);
  v3 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v5);
  usleep(0x2710u);
  return v3;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00056D08) --------------------------------------------------------
int __fastcall sub_56D08(int a1, int a2)
{
  if ( sub_56C04(a1, a2) )
    return 19;
  else
    return 0;
}

//----- (00056D20) --------------------------------------------------------
int __fastcall check_nonce_dcr(int a1, int a2)
{
  int v2; // r5
  int v4; // r4
  unsigned int v5; // r3
  int v6; // r0
  _DWORD *v7; // r12
  int v8; // r1
  int v9; // r2
  int v10; // r1
  int v11; // r2
  int v12; // r3
  int v13; // r1
  unsigned int v14; // r0
  unsigned int v15; // r5
  unsigned int v16; // r3
  _BYTE *v17; // r5
  unsigned __int8 *v18; // r4
  int v19; // r12
  int v20; // t1
  int v21; // t1
  unsigned int v22; // r2
  unsigned int v23; // r3
  unsigned int v25; // [sp+14h] [bp-10E0h]
  _BYTE v26[32]; // [sp+1Ch] [bp-10D8h] BYREF
  _DWORD s[45]; // [sp+3Ch] [bp-10B8h] BYREF
  char v28[4100]; // [sp+F0h] [bp-1004h] BYREF

  v2 = *(unsigned __int8 *)(a2 + 65);
  v4 = *(_DWORD *)(a1 + 760);
  v5 = *(_DWORD *)(v4 + 4 * (v2 + 7040));
  v2 *= 180;
  v25 = v5;
  memset(s, 0, sizeof(s));
  memcpy(s, (const void *)(v4 + v2 + 5120), 0x8Cu);
  v6 = *(_DWORD *)(a2 + 52);
  v7 = (_DWORD *)(v4 + v2 + 5271);
  v8 = *(_DWORD *)(a2 + 56);
  v9 = *(_DWORD *)(a2 + 60);
  s[35] = *(_DWORD *)(a2 + 48);
  s[36] = v6;
  s[37] = v8;
  s[38] = v9;
  v10 = v7[1];
  v11 = v7[2];
  v12 = v7[3];
  s[39] = *v7;
  s[40] = v10;
  s[41] = v11;
  s[42] = v12;
  v13 = v7[5];
  s[43] = v7[4];
  s[44] = v13;
  decred_hash((int)v26, (char *)s);
  v14 = target_to_diff_dcr((int)v26);
  v15 = v14;
  if ( v14 <= 0x26 )
  {
    V_LOCK();
    logfmt_raw(
      v28,
      0x1000u,
      0,
      "hw error calculate diff %d ans diff %d TICKET_MASK_DCR_1727 %d",
      v15,
      *(unsigned __int8 *)(a2 + 64),
      39);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/backend_dcr_1727/backend_dcr_1727.c",
      171,
      "check_nonce_dcr",
      15,
      532,
      20,
      v28);
    return 2;
  }
  else
  {
    v16 = *(unsigned __int8 *)(a2 + 64);
    if ( v16 == v14 )
    {
      if ( v25 > v16 )
      {
LABEL_9:
        V_LOCK();
        logfmt_raw(v28, 0x1000u, 0, "hw diff (%d<%d) not reach pool", *(unsigned __int8 *)(a2 + 64), v25);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/backend_dcr_1727/backend_dcr_1727.c",
          171,
          "check_nonce_dcr",
          15,
          549,
          20,
          v28);
        return 1;
      }
      else
      {
        v17 = s;
        v18 = (unsigned __int8 *)(v4 + 32 * *(unsigned __int8 *)(a2 + 65) + 28704);
        do
        {
          V_LOCK();
          v20 = (unsigned __int8)*--v17;
          v19 = v20;
          v21 = *--v18;
          logfmt_raw(v28, 0x1000u, 0, "%02x Vs %02x", v19, v21);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/backend/backend_dcr_1727/backend_dcr_1727.c",
            171,
            "fulltest_dcr",
            12,
            449,
            20,
            v28);
          v22 = (unsigned __int8)*v17;
          v23 = *v18;
          if ( v22 < v23 )
            break;
          if ( v22 > v23 )
            goto LABEL_9;
        }
        while ( v26 != v17 );
        return 0;
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(v28, 0x1000u, 0, "diff not match (%d!=%d) expected diff %d", v15, *(unsigned __int8 *)(a2 + 64), v25);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/backend_dcr_1727/backend_dcr_1727.c",
        171,
        "check_nonce_dcr",
        15,
        537,
        20,
        v28);
      return 3;
    }
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00057038) --------------------------------------------------------
int __fastcall sub_57038(int *a1, int a2)
{
  const char *v2; // r4
  void *v5; // r0
  void (__fastcall *v6)(int *, _DWORD *, int, void *, int *, int, int, _DWORD); // lr
  unsigned __int16 *v7; // r6
  unsigned int v8; // r9
  int v9; // r1
  int v10; // r0
  unsigned int v11; // r1
  unsigned int v12; // r0
  int v13; // r9
  int v14; // r2
  int **v15; // r12
  int result; // r0
  unsigned __int8 *v17; // r8
  char *v18; // r4
  int v19; // r6
  int v20; // r9
  int v22; // r2
  int *v23; // [sp+0h] [bp-160Ch] BYREF
  int v24; // [sp+4h] [bp-1608h]
  const char *v25; // [sp+8h] [bp-1604h]
  const char *v26; // [sp+54h] [bp-15B8h]
  const char *v27; // [sp+58h] [bp-15B4h]
  const char *v28; // [sp+5Ch] [bp-15B0h]
  int v29; // [sp+60h] [bp-15ACh]
  void *ptr; // [sp+64h] [bp-15A8h]
  int v31; // [sp+68h] [bp-15A4h]
  int **v32; // [sp+6Ch] [bp-15A0h]
  int v33; // [sp+74h] [bp-1598h] BYREF
  _DWORD v34[4]; // [sp+78h] [bp-1594h] BYREF
  _DWORD v35[7]; // [sp+88h] [bp-1584h] BYREF
  int v36; // [sp+A4h] [bp-1568h]
  _BYTE v37[32]; // [sp+A8h] [bp-1564h] BYREF
  _DWORD v38[7]; // [sp+C8h] [bp-1544h] BYREF
  int v39; // [sp+E4h] [bp-1528h]
  _DWORD v40[8]; // [sp+E8h] [bp-1524h] BYREF
  _BYTE s[256]; // [sp+108h] [bp-1504h] BYREF
  char v42[1024]; // [sp+208h] [bp-1404h] BYREF
  char v43[4100]; // [sp+608h] [bp-1004h] BYREF

  v2 = 0;
  v33 = 0;
  memset(s, 0, sizeof(s));
  V_LOCK();
  logfmt_raw(v43, 0x1000u, 0, "%s chip_no %d", "ChipSetting_get_addr_DCR_1727", a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_get_addr_DCR_1727",
    29,
    32,
    20,
    v43);
  v31 = a2;
  v34[0] = 0;
  v34[2] = 1;
  v34[1] = 0;
  v34[3] = 0;
  v5 = calloc(12 * a2, 1u);
  v23 = &v33;
  v6 = (void (__fastcall *)(int *, _DWORD *, int, void *, int *, int, int, _DWORD))a1[59];
  ptr = v5;
  v6(a1, v34, a2, v5, &v33, v24, 3000, 0);
  V_LOCK();
  V_INT((int)v35, "chain", a1[50]);
  logfmt_raw(
    v43,
    0x1000u,
    0,
    v36,
    v35[0],
    v35[1],
    v35[2],
    v35[3],
    v35[4],
    v35[5],
    v35[6],
    v36,
    "%s detect %d chips",
    "ChipSetting_get_addr_DCR_1727",
    v33,
    a1[68]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_get_addr_DCR_1727",
    29,
    43,
    60,
    v43);
  if ( v33 > 0 )
  {
    v26 = "ChipSetting_get_addr_DCR_1727";
    v29 = 0;
    v28 = "[GET ADDR] chip_type %04x/%04x chip %d reg %d addr %02x";
    v27 = "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c";
    v7 = (unsigned __int16 *)ptr;
    do
    {
      while ( 1 )
      {
        v8 = *v7;
        V_LOCK();
        v9 = *((unsigned __int8 *)v7 + 4);
        LOWORD(v8) = __rev16(v8);
        v10 = v7[3];
        v24 = a1[68];
        v25 = v2++;
        logfmt_raw(v43, 0x1000u, 0, v28, (unsigned __int16)v8, v24, v25, v10, v9);
        V_UNLOCK();
        zlog(g_zc, v27, 150, v26, 29, 47, 20, v43);
        if ( a1[68] == (unsigned __int16)v8 )
          break;
        v7 += 6;
        if ( v33 <= (int)v2 )
          goto LABEL_7;
      }
      v7 += 6;
      v11 = a1[93];
      v12 = *((unsigned __int8 *)v7 - 8);
      ++v29;
      v13 = v12 / v11;
      s[v13] = 1;
      V_LOCK();
      v14 = a1[50];
      v32 = (int **)v37;
      V_INT((int)v37, "chain", v14);
      v15 = v32;
      v32 = &v23;
      logfmt_raw(
        v43,
        0x1000u,
        0,
        v15[7],
        *v15,
        v15[1],
        v15[2],
        v15[3],
        v15[4],
        v15[5],
        v15[6],
        v15[7],
        "chip_id:%d, %03d",
        v13,
        *((unsigned __int8 *)v7 - 8));
      V_UNLOCK();
      zlog(g_zc, v27, 150, v26, 29, 53, 20, v43);
    }
    while ( v33 > (int)v2 );
LABEL_7:
    v2 = (const char *)v29;
  }
  else
  {
    v29 = 0;
  }
  if ( a1[70] > v29 )
  {
    V_LOCK();
    V_INT((int)v38, "chain", a1[50]);
    V_STR(v40, "error", "asic num error");
    logfmt_raw(
      v43,
      0x1000u,
      0,
      v39,
      v38[0],
      v38[1],
      v38[2],
      v38[3],
      v38[4],
      v38[5],
      v38[6],
      v39,
      v40[0],
      v40[1],
      v40[2],
      v40[3],
      v40[4],
      v40[5],
      v40[6],
      v40[7],
      "detected asic num less than design(%d<%d)",
      v29,
      a1[70]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_get_addr_DCR_1727",
      29,
      59,
      100,
      v43);
    memset(v42, 0, sizeof(v42));
    v42[0] = 10;
    if ( v31 )
    {
      v26 = v2;
      v17 = s;
      v18 = v42;
      v19 = 0;
      v20 = v31;
      do
      {
        while ( *v17++ )
        {
          if ( v20 == ++v19 )
            goto LABEL_15;
        }
        v22 = v19++;
        sprintf(v18, "%02d ", v22);
        v18 += 3;
      }
      while ( v20 != v19 );
LABEL_15:
      v2 = v26;
    }
    V_LOCK();
    logfmt_raw(v43, 0x1000u, 0, "bad asic:\n%s\n", v42);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_get_addr_DCR_1727",
      29,
      69,
      40,
      v43);
  }
  free(ptr);
  result = v33;
  a1[92] = (int)v2;
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00057558) --------------------------------------------------------
int __fastcall sub_57558(int *a1)
{
  int v2; // r6
  int v3; // r4

  v2 = a1[70];
  v3 = 3;
  while ( 1 )
  {
    sub_57038(a1, v2);
    if ( a1[92] == v2 )
      break;
    if ( !--v3 )
      return 12;
  }
  return 0;
}

//----- (00057598) --------------------------------------------------------
int __fastcall parameter_update_dcr(int a1, char a2, int a3, char a4, int a5)
{
  int v8; // r1
  int result; // r0
  int v10; // r3
  int v11; // r7
  double v12; // r0

  if ( *(_BYTE *)(a1 + 204) )
    return 0;
  if ( (unsigned int)(a3 - 50) <= 0x2EE )
    v8 = a2 & 1;
  else
    v8 = 0;
  if ( v8 )
  {
    v11 = a1 + 928;
    LODWORD(v12) = sub_DD46C(*(_QWORD *)(a1 + 920));
    *(_QWORD *)(v11 - 8) = (unsigned __int64)(v12 / (double)a3 * *(float *)(a1 + 900));
    *(float *)(a1 + 900) = (float)a3;
  }
  result = 0;
  if ( (unsigned int)(a5 - 1400) <= 0x12C )
    v10 = a4 & 1;
  else
    v10 = 0;
  if ( v10 )
    *(_DWORD *)(a1 + 904) = a5;
  return result;
}
// 57620: variable 'v12' is possibly undefined

//----- (00057648) --------------------------------------------------------
int __fastcall sub_57648(unsigned int *a1, int a2, int a3, _BYTE *a4, _DWORD *a5, signed int *a6, _DWORD *a7)
{
  unsigned int v7; // r6
  int v11; // r7
  int v13; // r3
  int v14; // r12
  unsigned int v15; // r6
  int v16; // r2
  char v17; // r3
  signed int v18; // r0
  int v19; // r6
  int v20; // r5
  int v22; // r0
  signed int v23; // r1
  char v24[4080]; // [sp+10h] [bp-1000h] BYREF

  v7 = a1[190];
  v11 = *(_BYTE *)(a2 + 9) & 0x7F;
  v13 = *(_DWORD *)(v7 + 8 * v11);
  v14 = *(_DWORD *)(v7 + 8 * v11 + 4);
  *(_DWORD *)a3 = v13;
  *(_DWORD *)(a3 + 4) = v14;
  *a7 = v13;
  strcpy((char *)(a3 + 16), (const char *)(v7 + 32 * (v11 + 32)));
  v15 = v7 + 180 * (__int16)v11 + 5260;
  *(_BYTE *)(a3 + 52) = *(_BYTE *)(a2 + 3);
  v16 = *(_DWORD *)(v15 + 4);
  *(_DWORD *)(a3 + 53) = *(_DWORD *)v15;
  *(_DWORD *)(a3 + 57) = v16;
  LOBYTE(v16) = *(_BYTE *)(v15 + 10);
  *(_WORD *)(a3 + 61) = *(_WORD *)(v15 + 8);
  *(_BYTE *)(a3 + 63) = v16;
  *(_DWORD *)(a3 + 48) = *(_DWORD *)(a2 + 4);
  v17 = *(_BYTE *)(a2 + 8);
  *(_BYTE *)(a3 + 65) = v11;
  *(_BYTE *)(a3 + 64) = v17;
  v18 = *(unsigned __int8 *)(a2 + 3) / a1[93];
  if ( v18 >= (int)a1[70] )
  {
    v22 = rand();
    sub_DD144(v22, a1[70]);
    v18 = v23;
  }
  *a6 = v18;
  *(_DWORD *)(a3 + 8) = v18;
  *(_DWORD *)(a3 + 12) = (*(unsigned __int8 *)(a2 + 5) >> 6) + 4 * *(unsigned __int8 *)(a2 + 4);
  v19 = BM_CRC5((_BYTE *)(a2 + 2), 67);
  v20 = *(_BYTE *)(a2 + 10) & 0x1F;
  if ( v19 == v20 )
  {
    *a5 = *(_DWORD *)(a3 + 48);
    *a4 = 1;
    return 0;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v24, 0x1000u, 0, "get nonce crc error calc value %04x expected value %04x", v19, v20);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/backend_dcr_1727/backend_dcr_1727.c",
      171,
      "packet_2_nonce_dcr",
      18,
      211,
      80,
      v24);
    return 11;
  }
}
// 57784: variable 'v23' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00057808) --------------------------------------------------------
int __fastcall packet_2_nonce_dcr(unsigned int *a1, int a2, int a3, _BYTE *a4, _DWORD *a5, signed int *a6, _DWORD *a7)
{
  if ( *(char *)(a2 + 10) < 0 )
    return sub_57648(a1, a2, a3, a4, a5, a6, a7);
  else
    return 10;
}

//----- (00057820) --------------------------------------------------------
int __fastcall sub_57820(char *a1, _DWORD *a2, _DWORD *a3, int a4)
{
  char v4; // r7
  int result; // r0
  int v10; // r3
  int v11; // r2
  char v12; // [sp+17h] [bp-1005h] BYREF
  char v13[4100]; // [sp+18h] [bp-1004h] BYREF

  v4 = a4;
  *a3 = 0;
  *a2 = -64;
  if ( pic1704_write_iic(*a1, a4) )
  {
    usleep(0x2710u);
    result = pic1704_read_iic(*a1, v4, &v12);
    if ( result )
    {
      v10 = v12;
      *a3 = 1;
      *a2 = v10;
      return result;
    }
    V_LOCK();
    logfmt_raw(v13, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)a1, a4);
    V_UNLOCK();
    v11 = 930;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v13, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)a1, a4);
    V_UNLOCK();
    v11 = 919;
  }
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_read_sensor_temp_local_on_pic_DCR_1727",
    50,
    v11,
    20,
    v13);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00057968) --------------------------------------------------------
int __fastcall sub_57968(char *a1, _DWORD *a2, _DWORD *a3, int a4)
{
  char v4; // r7
  int result; // r0
  int v10; // r3
  int v11; // r2
  char v12; // [sp+17h] [bp-1005h] BYREF
  char v13[4100]; // [sp+18h] [bp-1004h] BYREF

  v4 = a4;
  *a3 = 0;
  *a2 = -64;
  if ( pic1704_write_iic(*a1, a4) )
  {
    usleep(0x2710u);
    result = pic1704_read_iic(*a1, v4, &v12);
    if ( result )
    {
      v10 = v12;
      *a3 = 1;
      *a2 = v10 + 15;
      return result;
    }
    V_LOCK();
    logfmt_raw(v13, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)a1, a4);
    V_UNLOCK();
    v11 = 956;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v13, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)a1, a4);
    V_UNLOCK();
    v11 = 945;
  }
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_read_sensor_temp_remote_on_pic_DCR_1727",
    51,
    v11,
    20,
    v13);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00057AB4) --------------------------------------------------------
int __fastcall sub_57AB4(unsigned int *a1, _DWORD *a2, _DWORD *a3, int a4)
{
  int v8; // r3
  int v10; // [sp+34h] [bp-1030h]
  _BYTE v11[4]; // [sp+3Ch] [bp-1028h] BYREF
  _DWORD v12[7]; // [sp+40h] [bp-1024h] BYREF
  int v13; // [sp+5Ch] [bp-1008h]
  char v14[4100]; // [sp+60h] [bp-1004h] BYREF

  V_LOCK();
  logfmt_raw(
    v14,
    0x1000u,
    0,
    "%s chain[%d] iic_addr:%d",
    "ChipSetting_read_sensor_temp_local_on_ctrlboard_DCR_1727",
    *a1,
    a4);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_read_sensor_temp_local_on_ctrlboard_DCR_1727",
    56,
    970,
    20,
    v14);
  *a3 = 0;
  v10 = tsensor_read(*a1, a4, 0, (int)v11, 2u);
  if ( v10 == 2 )
  {
    v8 = v11[0];
    *a3 = 1;
    *a2 = v8;
    V_LOCK();
    V_INT((int)v12, "chain", (int)*a1);
    logfmt_raw(
      v14,
      0x1000u,
      0,
      v13,
      v12[0],
      v12[1],
      v12[2],
      v12[3],
      v12[4],
      v12[5],
      v12[6],
      v13,
      "read ctrlboard temp, local[%02x] %d",
      a4,
      *a2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_read_sensor_temp_local_on_ctrlboard_DCR_1727",
      56,
      982,
      20,
      v14);
  }
  else
  {
    *a2 = -64;
    v10 = -1;
    V_LOCK();
    logfmt_raw(v14, 0x1000u, 0, "failed to read ctrlboard-temp for chain %d", *a1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_read_sensor_temp_local_on_ctrlboard_DCR_1727",
      56,
      977,
      80,
      v14);
  }
  return v10;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00057C98) --------------------------------------------------------
int __fastcall sub_57C98(unsigned int *a1, unsigned __int8 *a2, _DWORD *a3, _DWORD *a4, unsigned __int8 a5)
{
  int result; // r0
  int v10; // r3
  _BYTE v11[4]; // [sp+14h] [bp-1004h] BYREF
  char v12[4072]; // [sp+18h] [bp-1000h] BYREF

  *a4 = 0;
  result = tsensor_read(*a1, a5, 0, (int)v11, 2u);
  if ( result == 2 )
  {
    v10 = v11[0];
    *a4 = 1;
    *a3 = v10 + *a2;
  }
  else
  {
    *a3 = -64;
    V_LOCK();
    logfmt_raw(v12, 0x1000u, 0, "failed to read ctrlboard-temp for chain %d", *a1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_read_sensor_temp_remote_on_ctrlboard_DCR_1727",
      57,
      996,
      80,
      v12);
    return -1;
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00057D8C) --------------------------------------------------------
int __fastcall softreset_all_chip_dcr(int *a1)
{
  void (__fastcall *v2)(int *, _DWORD *); // r3
  _DWORD v4[2]; // [sp+0h] [bp-14h] BYREF
  int v5; // [sp+8h] [bp-Ch]
  int v6; // [sp+Ch] [bp-8h]

  sub_5473C((int)a1);
  usleep((__useconds_t)"rl_kda_2110");
  v5 = 0;
  v6 = 0;
  v2 = (void (__fastcall *)(int *, _DWORD *))a1[55];
  LOBYTE(v5) = 1;
  HIWORD(v5) = 8;
  LOBYTE(v6) = -1;
  v4[1] = 0;
  v4[0] = 0;
  v2(a1, v4);
  sub_54864(a1, 255);
  return 0;
}

//----- (00057DFC) --------------------------------------------------------
int __fastcall sub_57DFC(_DWORD *a1, int a2, int a3, _DWORD *a4, _DWORD *a5)
{
  char v5; // r8
  int (__fastcall *v9)(_DWORD *, int *); // r3
  signed int v11; // r2
  unsigned __int8 *v12; // r0
  unsigned __int8 *v13; // r4
  void (__fastcall *v14)(_DWORD *, int *, signed int, unsigned __int8 *, int *); // r5
  int v15; // r5
  signed int v16; // [sp+14h] [bp-20h]
  int v17; // [sp+1Ch] [bp-18h] BYREF
  int v18; // [sp+20h] [bp-14h] BYREF
  int v19; // [sp+24h] [bp-10h]
  int v20; // [sp+28h] [bp-Ch]
  int v21; // [sp+2Ch] [bp-8h]

  v5 = a2;
  v20 = 0;
  v19 = 0;
  v21 = 0;
  v18 = a3 | 0x1980000;
  BYTE1(v20) = a2;
  v9 = (int (__fastcall *)(_DWORD *, int *))a1[54];
  HIWORD(v20) = 255;
  if ( v9(a1, &v18) )
    return 0;
  usleep(0xC350u);
  *a4 = 0;
  v19 = 0;
  *a5 = 0;
  v11 = a1[70];
  v20 = 0;
  v21 = 0;
  v18 = 0;
  if ( v11 >= 1 )
    v11 = 1;
  v16 = v11;
  v12 = (unsigned __int8 *)calloc(v11, 0xCu);
  BYTE1(v20) = v5;
  v13 = v12;
  v14 = (void (__fastcall *)(_DWORD *, int *, signed int, unsigned __int8 *, int *))a1[59];
  HIWORD(v20) = 255;
  v14(a1, &v18, v16, v12, &v17);
  v15 = v17;
  if ( v17 == 1 && a2 == v13[4] )
  {
    *a4 = *(_DWORD *)v13;
    *a5 = 1;
  }
  free(v13);
  return v15;
}

//----- (00057F10) --------------------------------------------------------
int __fastcall read_sensor_temp_remote_dcr(int a1, int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int v13; // r0
  int v14; // r1
  int v15; // r3
  int v16; // r2
  int v17; // [sp+8h] [bp-8h] BYREF
  int v18; // [sp+Ch] [bp-4h] BYREF

  if ( a6 )
  {
    if ( a6 == 1 )
    {
      v14 = *(unsigned __int8 *)(*(_DWORD *)(a1 + 432) + a9);
      *a3 = 0;
      *a2 = -64;
      v13 = sub_57DFC((_DWORD *)a1, v14, 256, &v17, &v18);
      if ( v13 == 1 )
      {
        v15 = HIBYTE(v17);
        v16 = v18;
        if ( *(_DWORD *)(a1 + 456) == 1 )
          v15 = HIBYTE(v17) - 64;
        *a2 = v15;
        *a3 = v16;
        return 0;
      }
    }
    else
    {
      if ( a6 != 2 )
        return 4;
      v13 = sub_57C98((unsigned int *)(a1 + 200), (unsigned __int8 *)(a1 + 912), a2, a3, a9);
    }
  }
  else
  {
    v13 = sub_57968((char *)(a1 + 200), a2, a3, a9);
  }
  if ( v13 == -1 )
    return 4;
  return 0;
}

//----- (00057FF4) --------------------------------------------------------
int __fastcall read_sensor_temp_local_dcr(
        _DWORD *a1,
        int *a2,
        _DWORD *a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9)
{
  int v11; // r0
  int v14; // r1
  int v15; // r3
  int v16; // r2
  int v17; // [sp+8h] [bp-8h] BYREF
  int v18; // [sp+Ch] [bp-4h] BYREF

  if ( a6 )
  {
    if ( a6 == 1 )
    {
      v14 = *(unsigned __int8 *)(a1[108] + a9);
      *a3 = 0;
      *a2 = -64;
      v11 = sub_57DFC(a1, v14, 0, &v17, &v18);
      if ( v11 == 1 )
      {
        v15 = HIBYTE(v17);
        v16 = v18;
        if ( a1[114] == 1 )
          v15 = HIBYTE(v17) - 64;
        *a2 = v15;
        *a3 = v16;
        return 0;
      }
    }
    else
    {
      if ( a6 != 2 )
        return 4;
      v11 = sub_57AB4(a1 + 50, a2, a3, a9);
    }
  }
  else
  {
    v11 = sub_57820((char *)a1 + 200, a2, a3, a9);
  }
  if ( v11 == -1 )
    return 4;
  return 0;
}

//----- (000580C4) --------------------------------------------------------
int __fastcall set_baud_dcr_0(int a1, int a2)
{
  int v4; // r4
  int v5; // r4
  _DWORD v7[4]; // [sp+30h] [bp-1034h] BYREF
  _DWORD v8[7]; // [sp+40h] [bp-1024h] BYREF
  int v9; // [sp+5Ch] [bp-1008h]
  char v10[4100]; // [sp+60h] [bp-1004h] BYREF

  v7[2] = 6291457;
  v7[1] = 0;
  v7[3] = 0;
  v7[0] = 0;
  if ( a2 == 1500000 )
    goto LABEL_24;
  if ( a2 <= 1500000 )
  {
    if ( a2 == 460800 )
    {
      v4 = 1568;
      goto LABEL_10;
    }
    if ( a2 > 460800 )
    {
      if ( a2 == 921600 || a2 == 1041666 )
      {
        v4 = 544;
        goto LABEL_10;
      }
    }
    else if ( a2 == 38400 )
    {
      v4 = 20512;
      goto LABEL_10;
    }
    goto LABEL_16;
  }
  if ( a2 == 3125000 )
  {
LABEL_23:
    v4 = 32;
    goto LABEL_10;
  }
  if ( a2 <= 3125000 )
  {
    if ( a2 != 1562500 )
    {
      if ( a2 != 3000000 )
        goto LABEL_16;
      goto LABEL_23;
    }
LABEL_24:
    v4 = 288;
    goto LABEL_10;
  }
  if ( a2 == 6250000 )
  {
    v4 = 289;
    goto LABEL_9;
  }
  if ( a2 != 12500000 )
  {
LABEL_16:
    v4 = 6688;
    goto LABEL_10;
  }
  v4 = 33;
LABEL_9:
  (*(void (__fastcall **)(int, int))(a1 + 176))(a1, 1);
LABEL_10:
  v7[0] = v4;
  V_LOCK();
  V_INT((int)v8, "chain", *(int *)(a1 + 200));
  logfmt_raw(
    v10,
    0x1000u,
    0,
    v9,
    v8[0],
    v8[1],
    v8[2],
    v8[3],
    v8[4],
    v8[5],
    v8[6],
    v9,
    "set fuart cfg value %08x/%d",
    v4,
    a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_fuart_cfg_DCR_1727",
    30,
    421,
    40,
    v10);
  v5 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v7);
  usleep(0x2710u);
  return v5;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (000582C0) --------------------------------------------------------
int __fastcall sub_582C0(int a1)
{
  int v2; // r4
  _DWORD v4[4]; // [sp+28h] [bp-1034h] BYREF
  _DWORD v5[7]; // [sp+38h] [bp-1024h] BYREF
  int v6; // [sp+54h] [bp-1008h]
  char v7[4100]; // [sp+58h] [bp-1004h] BYREF

  v4[0] = 5381904;
  v4[2] = 1835009;
  v4[3] = 0;
  v4[1] = 0;
  V_LOCK();
  V_INT((int)v5, "chain", *(int *)(a1 + 200));
  logfmt_raw(v7, 0x1000u, 0, v6, v5[0], v5[1], v5[2], v5[3], v5[4], v5[5], v5[6], v6, "set misc ctrl %08x", 5381904);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_misc_ctrl_DCR_1727",
    30,
    167,
    40,
    v7);
  v2 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v4);
  usleep(0x2710u);
  return v2;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (000583CC) --------------------------------------------------------
int __fastcall top_init_dcr(int *a1)
{
  int v2; // r7
  int v3; // r4
  int v4; // r0
  int v5; // r1
  char v6; // r3
  void (__fastcall *v7)(int *, int, int); // r3
  _DWORD v9[7]; // [sp+28h] [bp-1024h] BYREF
  int v10; // [sp+44h] [bp-1008h]
  char v11[4100]; // [sp+48h] [bp-1004h] BYREF

  V_LOCK();
  V_INT((int)v9, "chain", a1[50]);
  logfmt_raw(v11, 0x1000u, 0, v10, v9[0], v9[1], v9[2], v9[3], v9[4], v9[5], v9[6], v10, "top_init_dcr");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/backend_dcr_1727/backend_dcr_1727.c",
    171,
    "top_init_dcr",
    12,
    398,
    40,
    v11);
  v2 = a1[70];
  v3 = a1[108];
  v4 = sub_DCEB0(256, (unsigned __int8)v2);
  if ( (_BYTE)v2 )
  {
    v5 = v3 - 1;
    v6 = 0;
    do
    {
      *(_BYTE *)++v5 = v6;
      v6 += v4;
    }
    while ( v5 != v3 - 1 + (unsigned __int8)v2 );
    v3 = a1[108];
  }
  v7 = (void (__fastcall *)(int *, int, int))a1[52];
  a1[93] = v4;
  v7(a1, v3, v2);
  sub_5509C((int)a1, 0);
  sub_582C0((int)a1);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (000584FC) --------------------------------------------------------
int __fastcall dhash_start_dcr(int a1)
{
  int v2; // r3
  int result; // r0
  _DWORD v4[7]; // [sp+28h] [bp-1020h] BYREF
  int v5; // [sp+44h] [bp-1004h]
  char v6[4096]; // [sp+48h] [bp-1000h] BYREF

  V_LOCK();
  V_INT((int)v4, "chain", *(int *)(a1 + 200));
  logfmt_raw(v6, 0x1000u, 0, v5, v4[0], v4[1], v4[2], v4[3], v4[4], v4[5], v4[6], v5, "dhash_start_dcr");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/backend_dcr_1727/backend_dcr_1727.c",
    171,
    "dhash_start_dcr",
    15,
    418,
    40,
    v6);
  sub_582C0(a1);
  v2 = *(unsigned __int8 *)(a1 + 404);
  result = 0;
  *(_BYTE *)(a1 + 205) = 1;
  if ( !v2 )
    *(_DWORD *)(a1 + 408) = (int)*(float *)(a1 + 900);
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (000585DC) --------------------------------------------------------
int get_pcba_test_level_dcr()
{
  return 0;
}

//----- (000585E4) --------------------------------------------------------
int __fastcall makeup_chip_addr_dcr(_BYTE *a1, unsigned int a2)
{
  int result; // r0
  _BYTE *v5; // r2
  char v6; // r3

  result = sub_DCEB0(256, a2);
  if ( a2 )
  {
    v5 = a1;
    v6 = 0;
    do
    {
      *v5++ = v6;
      v6 += result;
    }
    while ( &a1[a2] != v5 );
  }
  return result;
}

//----- (00058628) --------------------------------------------------------
int get_algo_type_dcr()
{
  return 0;
}

//----- (00058630) --------------------------------------------------------
int update_chip_info_dcr()
{
  return 0;
}

//----- (00058638) --------------------------------------------------------
void *runtime_ctrl_dcr_1727()
{
  void *v0; // r0
  void *v1; // r5
  _QWORD v3[117]; // [sp+0h] [bp-3A8h] BYREF

  memset(v3, 0, sizeof(v3));
  LODWORD(v3[31]) = 3625540;
  HIDWORD(v3[39]) = 210;
  LODWORD(v3[40]) = 500;
  LODWORD(v3[33]) = 7496548;
  HIDWORD(v3[41]) = sensor_info_dcr_1727;
  v3[42] = qword_1064DC;
  v3[43] = qword_1064E4;
  v3[44] = qword_1064EC;
  v0 = calloc(1u, 0x3A8u);
  LODWORD(v3[0]) = backend_init_base;
  HIDWORD(v3[1]) = dhash_mining_stop_base;
  LODWORD(v3[2]) = dhash_mining_reset_base;
  HIDWORD(v3[2]) = backend_exit_base;
  LODWORD(v3[4]) = pop_ans_base;
  HIDWORD(v3[4]) = try_pop_ans_base;
  LODWORD(v3[6]) = softreset_all_chip_dcr;
  LODWORD(v3[1]) = dhash_mining_start_base;
  LODWORD(v3[8]) = check_nonce_dcr;
  HIDWORD(v3[8]) = global_idx_init_dcr;
  LODWORD(v3[9]) = global_idx_free_dcr;
  HIDWORD(v3[3]) = async_push_work_base;
  HIDWORD(v3[10]) = sub_56BEC;
  LODWORD(v3[11]) = sub_55190;
  LODWORD(v3[12]) = sub_5691C;
  HIDWORD(v3[0]) = reset_base;
  HIDWORD(v3[7]) = packet_2_nonce_dcr;
  LODWORD(v3[13]) = sub_56178;
  HIDWORD(v3[13]) = sub_55C84;
  LODWORD(v3[14]) = sub_558E0;
  LODWORD(v3[3]) = push_work_base;
  LODWORD(v3[10]) = sub_56D08;
  LODWORD(v3[15]) = get_theory_hashrate_dcr;
  HIDWORD(v3[15]) = get_sale_hashrate_dcr;
  LODWORD(v3[16]) = get_qualify_hashrate_dcr;
  LODWORD(v3[7]) = work_2_packet_dcr;
  HIDWORD(v3[12]) = sub_56540;
  HIDWORD(v3[16]) = get_qualify_nonce_num_dcr;
  LODWORD(v3[17]) = set_sensor_extern_mode_dcr;
  HIDWORD(v3[17]) = read_sensor_temp_local_dcr;
  HIDWORD(v3[9]) = set_baud_dcr;
  HIDWORD(v3[14]) = get_chip_status_dcr;
  LODWORD(v3[18]) = read_sensor_temp_remote_dcr;
  HIDWORD(v3[18]) = parameter_update_dcr;
  LODWORD(v3[19]) = overclock_update_dcr;
  HIDWORD(v3[19]) = get_pcba_test_level_dcr;
  LODWORD(v3[20]) = get_packet_remain_len_dcr;
  LODWORD(v3[22]) = set_frequency_dcr;
  HIDWORD(v3[22]) = sub_57558;
  LODWORD(v3[23]) = sub_551A8;
  HIDWORD(v3[23]) = top_init_dcr;
  LODWORD(v3[24]) = dhash_start_dcr;
  LODWORD(v3[26]) = set_chipaddr_base;
  HIDWORD(v3[26]) = set_inactive_base;
  LODWORD(v3[27]) = set_chip_reg_base;
  HIDWORD(v3[27]) = set_core_reg_base_9;
  LODWORD(v3[28]) = set_core_reg_base_9;
  HIDWORD(v3[28]) = set_core_enable_base;
  LODWORD(v3[29]) = sync_get_status_base;
  HIDWORD(v3[29]) = sync_get_chip_reg_base;
  HIDWORD(v3[30]) = sync_get_core_reg_base3;
  v3[34] = 0x100001727LL;
  v3[35] = 0xC00000005CLL;
  v3[112] = 0x4419C00042480000LL;
  v3[36] = 0x4000002F8LL;
  HIDWORD(v3[37]) = 2;
  LODWORD(v3[47]) = 39;
  v1 = v0;
  HIDWORD(v3[95]) = 280;
  v3[96] = 0x400000050LL;
  v3[97] = 0xB000000BALL;
  LOBYTE(v3[114]) = 15;
  v3[115] = 4774;
  LODWORD(v3[113]) = 1520;
  memcpy(v0, v3, 0x3A8u);
  return v1;
}
// 582BC: using guessed type int set_baud_dcr();
// 1064D8: using guessed type _UNKNOWN *sensor_info_dcr_1727;
// 1064DC: using guessed type __int64;
// 1064E4: using guessed type __int64;
// 1064EC: using guessed type __int64;

//----- (000589C0) --------------------------------------------------------
int get_chip_status_hns()
{
  return 0;
}

//----- (000589C8) --------------------------------------------------------
int __fastcall get_theory_hashrate_hns(int a1, double *a2)
{
  float v2; // s14

  v2 = *(float *)(a1 + 900);
  *a2 = v2 * 5520.0 * 1000.0 * 1000.0;
  return 0;
}

//----- (00058A00) --------------------------------------------------------
int __fastcall get_sale_hashrate_hns(int a1, double *a2, _DWORD *a3)
{
  int result; // r0
  double v7; // [sp+0h] [bp-8h] BYREF

  v7 = 0.0;
  (*(void (__fastcall **)(int, double *))(a1 + 120))(a1, &v7);
  if ( *(_BYTE *)(a1 + 248) != 72 )
    return 24;
  if ( *(_BYTE *)(a1 + 249) != 83 )
    return 24;
  if ( *(_BYTE *)(a1 + 250) != 51 )
    return 24;
  result = *(unsigned __int8 *)(a1 + 251);
  if ( *(_BYTE *)(a1 + 251) )
    return 24;
  *a2 = v7 * 0.98;
  *a3 = 50;
  return result;
}

//----- (00058A98) --------------------------------------------------------
int __fastcall get_qualify_hashrate_hns(int a1, double *a2)
{
  int result; // r0
  double v5; // [sp+0h] [bp-Ch] BYREF

  v5 = 0.0;
  (*(void (__fastcall **)(int, double *))(a1 + 120))(a1, &v5);
  if ( *(_BYTE *)(a1 + 248) != 72 )
    return 24;
  if ( *(_BYTE *)(a1 + 249) != 83 )
    return 24;
  if ( *(_BYTE *)(a1 + 250) != 51 )
    return 24;
  result = *(unsigned __int8 *)(a1 + 251);
  if ( *(_BYTE *)(a1 + 251) )
    return 24;
  *a2 = v5 * 0.99;
  return result;
}

//----- (00058B20) --------------------------------------------------------
int __fastcall get_qualify_nonce_num_hns(int a1, float *a2)
{
  int v4; // r0
  char v5; // r1
  int v6; // r3
  __int64 v7; // r0
  double v8; // r0
  double v9; // d4
  float v11; // s14
  double v12; // [sp+0h] [bp-Ch] BYREF

  v12 = 0.0;
  (*(void (__fastcall **)(int, double *))(a1 + 120))(a1, &v12);
  v4 = *(_DWORD *)(a1 + 376);
  v5 = 32 - v4;
  v6 = 1 << (v4 - 32);
  LODWORD(v7) = 1 << v4;
  HIDWORD(v7) = v6 | (1u >> v5);
  LODWORD(v8) = sub_DD46C(v7);
  v9 = v8;
  v11 = v12 / v9 / 92.0 * 0.5;
  *a2 = v11;
  return 0;
}
// 58B70: variable 'v8' is possibly undefined

//----- (00058BA8) --------------------------------------------------------
int overclock_update_hns()
{
  return 0;
}

//----- (00058BB0) --------------------------------------------------------
unsigned int __fastcall get_packet_remain_len_hns(int a1)
{
  unsigned int result; // r0

  result = a1 - 1;
  if ( result >= 0xA )
    return 9;
  return result;
}

//----- (00058BC0) --------------------------------------------------------
int __fastcall sub_58BC0(int a1, __int16 a2, int a3)
{
  _DWORD v4[2]; // [sp+0h] [bp-14h] BYREF
  __int16 v5; // [sp+8h] [bp-Ch]
  __int16 v6; // [sp+Ah] [bp-Ah]
  int v7; // [sp+Ch] [bp-8h]

  v4[0] = a3;
  v7 = 255;
  v4[1] = 0;
  v6 = a2;
  v5 = 1;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 220))(a1, v4);
}

//----- (00058C04) --------------------------------------------------------
int __fastcall global_idx_init_hns(int a1)
{
  void *v2; // r0

  v2 = calloc(0xA608u, 1u);
  *(_DWORD *)(a1 + 760) = v2;
  printf("__custom_data init %p\n", v2);
  return 0;
}

//----- (00058C34) --------------------------------------------------------
int __fastcall global_idx_free_hns(int a1)
{
  free(*(void **)(a1 + 760));
  return 0;
}

//----- (00058C48) --------------------------------------------------------
int __fastcall sub_58C48(int a1)
{
  _DWORD v3[1025]; // [sp+10h] [bp-1004h] BYREF

  V_LOCK();
  logfmt_raw((char *)v3, 0x1000u, 0, "software_reset %s %02x", "ChipSetting_software_reset_HNS_2130", 68);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_software_reset_HNS_2130",
    35,
    95,
    20,
    v3);
  v3[2] = 4456449;
  v3[3] = 0;
  v3[1] = 0;
  v3[0] = 3;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v3);
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00058D08) --------------------------------------------------------
int __fastcall set_sensor_extern_mode_hns(int a1)
{
  int (__fastcall *v2)(int, _DWORD *); // r3
  int v3; // r6
  int result; // r0
  _DWORD v5[2]; // [sp+0h] [bp-10h] BYREF
  int v6; // [sp+8h] [bp-8h]
  int v7; // [sp+Ch] [bp-4h]

  v5[0] = 26806532;
  v6 = 16711680;
  v5[1] = 0;
  v7 = 0;
  v2 = *(int (__fastcall **)(int, _DWORD *))(a1 + 216);
  LOBYTE(v6) = 1;
  v3 = v2(a1, v5);
  usleep((__useconds_t)"rl_kda_2110");
  result = 0;
  if ( !v3 )
    *(_DWORD *)(a1 + 456) = 1;
  return result;
}

//----- (00058D70) --------------------------------------------------------
int __fastcall sub_58D70(int *a1, int a2)
{
  int v4; // r2
  int (__fastcall *v5)(int *, _DWORD *); // r3
  int v6; // r4
  int v8; // [sp+2Ch] [bp-1038h]
  _DWORD v9[2]; // [sp+30h] [bp-1034h] BYREF
  int v10; // [sp+38h] [bp-102Ch]
  int v11; // [sp+3Ch] [bp-1028h]
  _DWORD v12[7]; // [sp+40h] [bp-1024h] BYREF
  int v13; // [sp+5Ch] [bp-1008h]
  char v14[4100]; // [sp+60h] [bp-1004h] BYREF

  v9[1] = 0;
  v10 = 0;
  v11 = 0;
  v9[0] = 0;
  V_LOCK();
  V_INT((int)v12, "chain", a1[50]);
  logfmt_raw(
    v14,
    0x1000u,
    0,
    v13,
    v12[0],
    v12[1],
    v12[2],
    v12[3],
    v12[4],
    v12[5],
    v12[6],
    v13,
    "set core ticket mask reg %02x tm %02x",
    3,
    a2,
    v8,
    0,
    0,
    0,
    0);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_core_ticket_mask_HNS_2130",
    37,
    141,
    40,
    v14);
  v4 = a1[71];
  LOBYTE(v11) = -1;
  BYTE1(v11) = v4;
  v10 = 196609;
  BYTE2(v11) = 1;
  v5 = (int (__fastcall *)(int *, _DWORD *))a1[55];
  v9[0] = a2;
  v6 = v5(a1, v9);
  usleep(0x3E8u);
  a1[94] = a2;
  return v6;
}
// 58DF8: variable 'v8' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00058E98) --------------------------------------------------------
int __fastcall work_2_packet_hns(int a1, _DWORD *a2, _BYTE *a3, _DWORD *a4)
{
  int v7; // r5
  const char *v9; // r1
  const void *v10; // r8
  int v11; // r12
  int v12; // r2
  const void *v13; // r1
  _DWORD *v14; // r0
  _DWORD *v15; // r3
  int v16; // r11
  int v17; // r10
  int v18; // lr
  int v19; // r12
  int v20; // r12
  int v21; // r11
  int v22; // r10
  char v23; // r12
  __int16 v24; // r0
  int v25; // r3
  char v27[4100]; // [sp+10h] [bp-1004h] BYREF

  v7 = *(_DWORD *)(a1 + 760);
  *a3 = 85;
  a3[1] = -86;
  a3[2] = 32;
  v9 = (const char *)(a2 + 2);
  v10 = a2 + 10;
  if ( *(_DWORD *)(a1 + 436) == 1 )
    a3[2] = 48;
  v11 = *(unsigned __int8 *)(v7 + 42496);
  *(_QWORD *)(v7 + 8 * v11) = *((_QWORD *)v9 - 1);
  strcpy((char *)(v7 + 32 * (v11 + 32)), v9);
  v12 = *(unsigned __int8 *)(v7 + 42496);
  v13 = a2 + 10;
  *(_DWORD *)(v7 + 4 * (v12 + 9472)) = a2[74];
  v14 = (_DWORD *)(v7 + 32 * (v12 + 1200));
  v15 = a2 + 75;
  v16 = a2[75];
  v17 = a2[76];
  v18 = v15[2];
  v19 = v15[3];
  *v14 = v16;
  v14[1] = v17;
  v14[2] = v18;
  v14[3] = v19;
  v20 = v15[7];
  v21 = v15[4];
  v22 = v15[5];
  v14[6] = v15[6];
  v14[7] = v20;
  v14[4] = v21;
  v14[5] = v22;
  memcpy((void *)(v7 + ((*(unsigned __int8 *)(v7 + 42496) + 20) << 8)), v13, 0x100u);
  v23 = *(_BYTE *)(v7 + 42496);
  a3[3] = v23;
  *(_BYTE *)(v7 + 42496) = (v23 + 1) & 0x7F;
  memcpy(a3 + 4, v10, 0x100u);
  if ( !memcmp(&last_header_hns, v10, 0x100u) )
  {
    V_LOCK();
    logfmt_raw(v27, 0x1000u, 0, "found repeat work");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/backend_hns_2130/backend_hns_2130.c",
      171,
      "work_2_packet_hns",
      17,
      118,
      80,
      v27);
  }
  memcpy(&last_header_hns, v10, 0x100u);
  v24 = BM_CRC16(a3 + 2, 258);
  a3[261] = v24;
  a3[260] = HIBYTE(v24);
  v25 = *(unsigned __int8 *)(a1 + 205);
  *a4 = 262;
  if ( !v25 || !*(_BYTE *)(a1 + 206) )
    return 0;
  memset(*(void **)(a1 + 400), 0, 48 * *(_DWORD *)(a1 + 280));
  sub_58D70((int *)a1, 36);
  *(_BYTE *)(a1 + 205) = 0;
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (000590BC) --------------------------------------------------------
int __fastcall sub_590BC(int a1, int a2)
{
  float v2; // s0
  __int16 v3; // r3
  int v4; // r12
  signed int v5; // r6
  float v6; // s19
  int v7; // r10
  int v8; // r11
  int v9; // r8
  int v10; // r5
  int v11; // r2
  int v12; // r4
  float v13; // s17
  int v14; // r0
  int v15; // r0
  float v16; // s16
  int v17; // r2
  signed int v19; // r7
  int v20; // r6
  unsigned int v22; // [sp+38h] [bp-104Ch]
  int v25; // [sp+4Ch] [bp-1038h]
  _DWORD v26[2]; // [sp+50h] [bp-1034h] BYREF
  int v27; // [sp+58h] [bp-102Ch]
  int v28; // [sp+5Ch] [bp-1028h]
  int v29; // [sp+60h] [bp-1024h] BYREF
  int v30; // [sp+64h] [bp-1020h]
  int v31; // [sp+68h] [bp-101Ch]
  int v32; // [sp+6Ch] [bp-1018h]
  __int64 v33; // [sp+70h] [bp-1014h]
  int v34; // [sp+78h] [bp-100Ch]
  int v35; // [sp+7Ch] [bp-1008h]
  char v36[4100]; // [sp+80h] [bp-1004h] BYREF

  v3 = 0;
  v27 = 0;
  v26[1] = 0;
  v28 = 0;
  v26[0] = 0;
  if ( !a2 )
    v3 = 8;
  LOBYTE(v27) = 1;
  if ( a2 )
  {
    if ( a2 == 1 )
      HIWORD(v27) = 12;
  }
  else
  {
    HIWORD(v27) = v3;
  }
  v4 = -1068236443;
  v5 = 2;
  v25 = 2;
LABEL_8:
  v6 = (float)v5;
  v7 = 0;
  v8 = 0;
LABEL_9:
  v9 = v8 + 1;
  v10 = v8;
  v22 = (v5 << 8) | 0xC0000000 | v7;
  while ( 1 )
  {
    v11 = (int)(float)((float)((float)((float)((float)(v10 + 1) * (float)((float)(v8 + 1) * v2)) * v6) / 25.0) * 100.0);
    v12 = v11 / 100;
    if ( v11 % 100 > 50 )
      ++v12;
    if ( (unsigned int)(v12 - 16) <= 0xEA )
    {
      v13 = (float)((float)v12 * 25.0) / v6;
      if ( (v5 != 1 || v13 <= 3125.0) && v13 <= 3200.0 && v13 >= 2000.0 )
      {
        v14 = sub_DCEB0(25 * v12, v5);
        v15 = sub_DCEB0(v14, v8 + 1);
        v16 = (float)sub_DCEB0(v15, v10 + 1);
        v17 = v13 > 2400.0;
        v4 = v10 & 7 | v22 | (v12 << 16) | (v17 << 28);
        if ( fabsf(v16 - v2) < 3.0 )
          break;
      }
    }
    if ( v10-- == 0 )
    {
      v7 += 16;
      ++v8;
      if ( v9 != 8 )
        goto LABEL_9;
      v5 = 1;
      if ( v25 == 1 )
      {
        v26[0] = v4;
        V_LOCK();
        V_INT((int)&v29, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v36,
          0x1000u,
          0,
          v35,
          v29,
          v30,
          v31,
          v32,
          v33,
          v34,
          v35,
          "set pll_no %d freq: %.2f, expected freq: %.2f",
          a2,
          0,
          0,
          v2);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_freq_HNS_2130",
          25,
          500,
          40,
          v36);
        goto LABEL_24;
      }
      v25 = 1;
      goto LABEL_8;
    }
  }
  v19 = v5;
  v20 = v10 & 7 | v22 | (v12 << 16) | (v17 << 28);
  V_LOCK();
  logfmt_raw(
    v36,
    0x1000u,
    0,
    "target_freq:%.2f actual_freq:%.2f,vco:%.2f fbdiv:%d refdiv:%d postdiv1:%d, postdiv2:%d",
    v2,
    v16,
    v13,
    v12,
    v19,
    v8,
    v10);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "inferred_plldivider",
    19,
    473,
    20,
    v36);
  v26[0] = v20;
  V_LOCK();
  V_INT((int)&v29, "chain", *(int *)(a1 + 200));
  logfmt_raw(
    v36,
    0x1000u,
    0,
    v35,
    v29,
    v30,
    v31,
    v32,
    v33,
    v34,
    v35,
    "set pll_no %d freq: %.2f, expected freq: %.2f",
    a2,
    v16,
    v2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_freq_HNS_2130",
    25,
    500,
    40,
    v36);
  if ( v16 > 0.0 )
    v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v26);
  else
    v10 = -1;
LABEL_24:
  usleep(0x2710u);
  return v10;
}
// 5918C: variable 'v2' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (000594F4) --------------------------------------------------------
int __fastcall set_frequency_hns(int a1, int a2)
{
  sub_590BC(a1, a2);
  return 0;
}

//----- (00059504) --------------------------------------------------------
int __fastcall sub_59504(int a1, int a2)
{
  _DWORD v4[4]; // [sp+28h] [bp-1034h] BYREF
  _DWORD v5[7]; // [sp+38h] [bp-1024h] BYREF
  int v6; // [sp+54h] [bp-1008h]
  char v7[4100]; // [sp+58h] [bp-1004h] BYREF

  v4[0] = a2;
  v4[2] = 4194305;
  v4[3] = 0;
  v4[1] = 0;
  V_LOCK();
  V_INT((int)v5, "chain", *(int *)(a1 + 200));
  logfmt_raw(v7, 0x1000u, 0, v6, v5[0], v5[1], v5[2], v5[3], v5[4], v5[5], v5[6], v6, "set analog value %08x", v4[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_analog_mux_HNS_2130",
    31,
    745,
    40,
    v7);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v4);
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (000595F8) --------------------------------------------------------
int __fastcall sub_595F8(int a1, int a2)
{
  if ( sub_59504(a1, a2) )
    return 19;
  else
    return 0;
}

//----- (00059610) --------------------------------------------------------
int __fastcall sub_59610(int a1, int a2)
{
  int v4; // r2
  int v5; // r7
  int v6; // r7
  int v7; // r7
  int *v8; // r6
  int v9; // r0
  int v10; // r12
  int v11; // r2
  int v12; // r3
  int v13; // r8
  int v15; // [sp+4h] [bp-10E8h]
  int v16; // [sp+38h] [bp-10B4h]
  int *ptr; // [sp+4Ch] [bp-10A0h]
  int v18; // [sp+54h] [bp-1098h] BYREF
  _DWORD v19[2]; // [sp+58h] [bp-1094h] BYREF
  int v20; // [sp+60h] [bp-108Ch]
  int v21; // [sp+64h] [bp-1088h]
  _DWORD v22[7]; // [sp+68h] [bp-1084h] BYREF
  int v23; // [sp+84h] [bp-1068h]
  _DWORD v24[7]; // [sp+88h] [bp-1064h] BYREF
  int v25; // [sp+A4h] [bp-1048h]
  _DWORD v26[7]; // [sp+A8h] [bp-1044h] BYREF
  int v27; // [sp+C4h] [bp-1028h]
  _DWORD v28[7]; // [sp+C8h] [bp-1024h] BYREF
  int v29; // [sp+E4h] [bp-1008h]
  char v30[4100]; // [sp+E8h] [bp-1004h] BYREF

  V_LOCK();
  V_INT((int)v22, "chain", *(int *)(a1 + 200));
  logfmt_raw(
    v30,
    0x1000u,
    0,
    v23,
    v22[0],
    v22[1],
    v22[2],
    v22[3],
    v22[4],
    v22[5],
    v22[6],
    v23,
    "set clock delay chip_no %d, value %08x",
    *(_DWORD *)(a1 + 280),
    a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_clock_delay_HNS_2130",
    32,
    597,
    40,
    v30);
  v19[1] = 0;
  v21 = 255;
  v19[0] = a2;
  v20 = 1;
  if ( (*(int (__fastcall **)(int, _DWORD *))(a1 + 220))(a1, v19) < 0 )
  {
    V_LOCK();
    v16 = -1;
    V_INT((int)v24, "chain", *(int *)(a1 + 200));
    logfmt_raw(
      v30,
      0x1000u,
      0,
      v25,
      v24[0],
      v24[1],
      v24[2],
      v24[3],
      v24[4],
      v24[5],
      v24[6],
      v25,
      "%s failed, set reg:%02x",
      "ChipSetting_clock_delay_HNS_2130",
      HIWORD(v20));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_clock_delay_HNS_2130",
      32,
      606,
      100,
      v30);
  }
  else
  {
    usleep((__useconds_t)"rl_kda_2110");
    v4 = *(_DWORD *)(a1 + 280);
    v5 = *(_DWORD *)(a1 + 284);
    LOBYTE(v21) = 0;
    v6 = v5 * v4;
    ptr = (int *)calloc(12 * v6, 1u);
    (*(void (__fastcall **)(int, _DWORD *, int, int *, int *, int, int, _DWORD))(a1 + 244))(
      a1,
      v19,
      v6,
      ptr,
      &v18,
      v15,
      2000,
      0);
    if ( v18 > 0 )
    {
      v7 = 0;
      v16 = 0;
      v8 = ptr;
      do
      {
        v12 = *v8;
        v13 = *((unsigned __int16 *)v8 + 3);
        HIBYTE(v24[0]) = *v8;
        BYTE2(v24[0]) = BYTE1(v12);
        BYTE1(v24[0]) = BYTE2(v12);
        LOBYTE(v24[0]) = HIBYTE(v12);
        V_LOCK();
        if ( v13 )
        {
          V_INT((int)v28, "chain", *(int *)(a1 + 200));
          logfmt_raw(
            v30,
            0x1000u,
            0,
            v29,
            v28[0],
            v28[1],
            v28[2],
            v28[3],
            v28[4],
            v28[5],
            v28[6],
            v29,
            "[DP] chip %02x, expected reg %02x, but %02x, data %08x",
            *((unsigned __int8 *)v8 + 4),
            0,
            *((unsigned __int16 *)v8 + 3),
            v24[0]);
          V_UNLOCK();
          v9 = g_zc;
          v10 = 100;
          v11 = 625;
        }
        else
        {
          ++v16;
          V_INT((int)v26, "chain", *(int *)(a1 + 200));
          logfmt_raw(
            v30,
            0x1000u,
            0,
            v27,
            v26[0],
            v26[1],
            v26[2],
            v26[3],
            v26[4],
            v26[5],
            v26[6],
            v27,
            "[DP] chip %02x, core %02x, reg %02x, clk_delay %08x",
            *((unsigned __int8 *)v8 + 4),
            *((unsigned __int8 *)v8 + 8),
            *((unsigned __int16 *)v8 + 3),
            v24[0]);
          V_UNLOCK();
          v9 = g_zc;
          v10 = 20;
          v11 = 622;
        }
        ++v7;
        v8 += 3;
        zlog(
          v9,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_clock_delay_HNS_2130",
          32,
          v11,
          v10,
          v30);
      }
      while ( v18 > v7 );
    }
    else
    {
      v16 = 0;
    }
    free(ptr);
  }
  return v16;
}
// 59760: variable 'v15' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (000599D0) --------------------------------------------------------
int __fastcall sub_599D0(int a1, int a2)
{
  if ( *(_DWORD *)(a1 + 284) * *(_DWORD *)(a1 + 280) == sub_59610(a1, a2) )
    return 19;
  else
    return 0;
}

//----- (000599F8) --------------------------------------------------------
int __fastcall sub_599F8(int a1, int *a2)
{
  int v2; // r2
  _DWORD *v3; // r6
  int *v5; // r8
  int v6; // r3
  int v7; // r0
  int v8; // r1
  int v9; // r2
  int v10; // r3
  void (__fastcall *v11)(int, int *, int *, _DWORD, int, int, int, int, _DWORD); // r9
  int v12; // r3
  int v13; // r2
  int v14; // r2
  int *v16; // [sp+38h] [bp-109Ch]
  int v17; // [sp+40h] [bp-1094h] BYREF
  int v18; // [sp+44h] [bp-1090h] BYREF
  int v19; // [sp+48h] [bp-108Ch] BYREF
  int v20; // [sp+4Ch] [bp-1088h] BYREF
  _DWORD v21[7]; // [sp+50h] [bp-1084h] BYREF
  int v22; // [sp+6Ch] [bp-1068h]
  _DWORD v23[7]; // [sp+70h] [bp-1064h] BYREF
  int v24; // [sp+8Ch] [bp-1048h]
  _DWORD v25[7]; // [sp+90h] [bp-1044h] BYREF
  int v26; // [sp+ACh] [bp-1028h]
  _DWORD v27[7]; // [sp+B0h] [bp-1024h] BYREF
  int v28; // [sp+CCh] [bp-1008h]
  char v29[4100]; // [sp+D0h] [bp-1004h] BYREF

  v2 = *(_DWORD *)(a1 + 340);
  v3 = *(_DWORD **)(a1 + 332);
  v17 = -64;
  v18 = -64;
  if ( v2 > 0 )
  {
    v16 = &a2[2 * v2];
    v5 = a2;
    do
    {
      v19 = 0;
      (*(void (__fastcall **)(int, int *, int *, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(a1 + 140))(
        a1,
        &v17,
        &v19,
        *v3,
        v3[1],
        v3[2],
        v3[3],
        v3[4],
        v3[5]);
      if ( v19 )
      {
        v6 = v17;
        if ( v17 >= -63 )
          goto LABEL_4;
        v17 = -64;
        V_LOCK();
        V_INT((int)v21, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v29,
          0x1000u,
          0,
          v22,
          v21[0],
          v21[1],
          v21[2],
          v21[3],
          v21[4],
          v21[5],
          v21[6],
          v22,
          "got uneffective temp, sensor[%d], addr:%02x",
          *v3,
          v3[5]);
        V_UNLOCK();
        v13 = 253;
      }
      else
      {
        v17 = -64;
        V_LOCK();
        V_INT((int)v23, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v29,
          0x1000u,
          0,
          v24,
          v23[0],
          v23[1],
          v23[2],
          v23[3],
          v23[4],
          v23[5],
          v23[6],
          v24,
          "read sensor failed, sensor[%d], addr:%02x",
          *v3,
          v3[5]);
        V_UNLOCK();
        v13 = 258;
      }
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/backend_hns_2130/backend_hns_2130.c",
        171,
        "read_temperature_hns",
        20,
        v13,
        100,
        v29);
      v6 = v17;
LABEL_4:
      *v5 = v6;
      v7 = v3[1];
      v8 = v3[2];
      v9 = v3[3];
      v10 = v3[4];
      v11 = *(void (__fastcall **)(int, int *, int *, _DWORD, int, int, int, int, _DWORD))(a1 + 144);
      v20 = 0;
      v11(a1, &v18, &v20, *v3, v7, v8, v9, v10, v3[5]);
      if ( !v20 )
      {
        v18 = -64;
        V_LOCK();
        V_INT((int)v27, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v29,
          0x1000u,
          0,
          v28,
          v27[0],
          v27[1],
          v27[2],
          v27[3],
          v27[4],
          v27[5],
          v27[6],
          v28,
          "read sensor failed, sensor[%d], addr:%02x",
          *v3,
          v3[5]);
        V_UNLOCK();
        v14 = 273;
LABEL_11:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/backend_hns_2130/backend_hns_2130.c",
          171,
          "read_temperature_hns",
          20,
          v14,
          100,
          v29);
        v12 = v18;
        goto LABEL_6;
      }
      v12 = v18;
      if ( v18 < -63 )
      {
        v18 = -64;
        V_LOCK();
        V_INT((int)v25, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v29,
          0x1000u,
          0,
          v26,
          v25[0],
          v25[1],
          v25[2],
          v25[3],
          v25[4],
          v25[5],
          v25[6],
          v26,
          "got uneffective temp, sensor[%d], addr:%02x",
          *v3,
          v3[5]);
        V_UNLOCK();
        v14 = 268;
        goto LABEL_11;
      }
LABEL_6:
      v5[1] = v12;
      v5 += 2;
      usleep((__useconds_t)&loc_7A120);
      v3 += 6;
    }
    while ( v16 != v5 );
  }
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00059D70) --------------------------------------------------------
int __fastcall sub_59D70(int a1, int a2, char a3)
{
  int v4; // r6
  _DWORD *v5; // r10
  _DWORD *v6; // r4
  int (__fastcall *v7)(int, _DWORD *); // r3
  int result; // r0
  int v9; // [sp+40h] [bp-1094h]
  int v10; // [sp+44h] [bp-1090h]
  char v11; // [sp+48h] [bp-108Ch]
  char v12; // [sp+50h] [bp-1084h]
  int v14; // [sp+5Ch] [bp-1078h] BYREF
  _DWORD v15[2]; // [sp+60h] [bp-1074h] BYREF
  int v16; // [sp+68h] [bp-106Ch]
  int v17; // [sp+6Ch] [bp-1068h]
  _DWORD v18[7]; // [sp+70h] [bp-1064h] BYREF
  int v19; // [sp+8Ch] [bp-1048h]
  _DWORD v20[7]; // [sp+90h] [bp-1044h] BYREF
  int v21; // [sp+ACh] [bp-1028h]
  _DWORD v22[7]; // [sp+B0h] [bp-1024h] BYREF
  int v23; // [sp+CCh] [bp-1008h]
  char v24[4100]; // [sp+D0h] [bp-1004h] BYREF

  v9 = a3 & 1;
  v14 = 0;
  if ( a2 == -1 || *(_DWORD *)(a1 + 280) < a2 )
  {
    v11 = 0;
    v12 = 1;
  }
  else
  {
    v12 = 0;
    v11 = *(_BYTE *)(*(_DWORD *)(a1 + 432) + a2);
  }
  v4 = 0;
  v16 = 0x10000;
  v15[1] = 0;
  v15[0] = 0;
  BYTE1(v16) = v11;
  v17 = 0;
  v5 = calloc(0xCu, 1u);
  (*(void (__fastcall **)(int, _DWORD *, int, _DWORD *, int *))(a1 + 244))(a1, v15, 1, v5, &v14);
  if ( v14 <= 0 )
  {
    v10 = v9;
  }
  else
  {
    v6 = v5;
    v10 = v9;
    do
    {
      if ( *((_WORD *)v6 + 3) == 1 )
      {
        V_LOCK();
        V_INT((int)v18, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v24,
          0x1000u,
          0,
          v19,
          v18[0],
          v18[1],
          v18[2],
          v18[3],
          v18[4],
          v18[5],
          v18[6],
          v19,
          "%s chip %02x, core %02x, reg %02x, core_mode %08x",
          "ChipSetting_same_nonce_HNS_2130",
          *((unsigned __int8 *)v6 + 4),
          *((unsigned __int8 *)v6 + 8),
          *((unsigned __int16 *)v6 + 3),
          *v6);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_same_nonce_HNS_2130",
          31,
          268,
          20,
          v24);
        v10 = v9 | *v6;
      }
      else
      {
        V_LOCK();
        V_INT((int)v20, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v24,
          0x1000u,
          0,
          v21,
          v20[0],
          v20[1],
          v20[2],
          v20[3],
          v20[4],
          v20[5],
          v20[6],
          v21,
          "%s chip %02x, expected reg %02x, but %02x, core_mode %08x",
          "ChipSetting_same_nonce_HNS_2130",
          *((unsigned __int8 *)v6 + 4),
          5,
          *((unsigned __int16 *)v6 + 3),
          *v6);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_same_nonce_HNS_2130",
          31,
          272,
          100,
          v24);
      }
      ++v4;
      v6 += 3;
    }
    while ( v14 > v4 );
  }
  free(v5);
  HIWORD(v16) = 1;
  LOBYTE(v17) = -1;
  LOBYTE(v16) = v12;
  v7 = *(int (__fastcall **)(int, _DWORD *))(a1 + 220);
  BYTE1(v16) = v11;
  v15[0] = v10;
  result = v7(a1, v15);
  if ( result < 0 )
  {
    V_LOCK();
    V_INT((int)v22, "chain", *(int *)(a1 + 200));
    logfmt_raw(
      v24,
      0x1000u,
      0,
      v23,
      v22[0],
      v22[1],
      v22[2],
      v22[3],
      v22[4],
      v22[5],
      v22[6],
      v23,
      "set same nonce failed! chip_id:%d",
      a2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_same_nonce_HNS_2130",
      31,
      285,
      100,
      v24);
    return -1;
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005A0EC) --------------------------------------------------------
int __fastcall sub_5A0EC(int a1, int a2, char a3)
{
  sub_59D70(a1, a2, a3);
  usleep(0x2710u);
  return 0;
}

//----- (0005A104) --------------------------------------------------------
bool __fastcall sub_5A104(int a1, int a2, char **a3)
{
  char v3; // r3
  _DWORD *v5; // r8
  int v6; // r6
  _DWORD *v7; // r5
  int v8; // r3
  int v9; // r10
  void *v10; // r0
  char *v11; // r8
  int v12; // r5
  int v13; // r6
  _DWORD *v14; // r5
  const char *v15; // r5
  int v17; // [sp+4h] [bp-10E8h]
  char *s; // [sp+40h] [bp-10ACh]
  char *v20; // [sp+44h] [bp-10A8h]
  _DWORD *ptr; // [sp+4Ch] [bp-10A0h]
  int v22; // [sp+54h] [bp-1098h] BYREF
  int v23; // [sp+58h] [bp-1094h] BYREF
  int v24; // [sp+5Ch] [bp-1090h]
  int v25; // [sp+60h] [bp-108Ch]
  int v26; // [sp+64h] [bp-1088h]
  _DWORD v27[7]; // [sp+68h] [bp-1084h] BYREF
  int v28; // [sp+84h] [bp-1068h]
  _DWORD v29[7]; // [sp+88h] [bp-1064h] BYREF
  int v30; // [sp+A4h] [bp-1048h]
  _DWORD v31[7]; // [sp+A8h] [bp-1044h] BYREF
  int v32; // [sp+C4h] [bp-1028h]
  _DWORD v33[7]; // [sp+C8h] [bp-1024h] BYREF
  int v34; // [sp+E4h] [bp-1008h]
  char v35[4100]; // [sp+E8h] [bp-1004h] BYREF

  v3 = 0;
  v22 = 0;
  if ( a2 != -1 && *(_DWORD *)(a1 + 280) >= a2 )
    v3 = *(_BYTE *)(*(_DWORD *)(a1 + 432) + a2);
  v25 = 3932160;
  v24 = 0;
  v23 = 0;
  v26 = 0;
  BYTE1(v25) = v3;
  v5 = calloc(0xCu, 1u);
  (*(void (__fastcall **)(int, int *, int, _DWORD *, int *))(a1 + 236))(a1, &v23, 1, v5, &v22);
  if ( v22 <= 0 )
  {
    v20 = 0;
  }
  else
  {
    v20 = 0;
    v6 = 0;
    v7 = v5;
    do
    {
      while ( 1 )
      {
        ++v6;
        if ( *((_WORD *)v7 + 3) == 60 )
          break;
        v7 += 3;
        if ( v22 <= v6 )
          goto LABEL_9;
      }
      v8 = *v5;
      v7 += 3;
      HIBYTE(v33[0]) = *v5;
      BYTE2(v33[0]) = BYTE1(v8);
      BYTE1(v33[0]) = BYTE2(v8);
      LOBYTE(v33[0]) = HIBYTE(v8);
      v9 = v33[0];
      V_LOCK();
      v20 += v9;
      V_INT((int)v27, "chain", *(int *)(a1 + 200));
      logfmt_raw(
        v35,
        0x1000u,
        0,
        v28,
        v27[0],
        v27[1],
        v27[2],
        v27[3],
        v27[4],
        v27[5],
        v27[6],
        v28,
        "[Top Nonce Cnt] asic %02x, reg %02x cnt %08x",
        *((unsigned __int8 *)v7 - 8),
        *((unsigned __int16 *)v7 - 3),
        v9);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/chip_setting.c",
        150,
        "ChipSetting_nonce_counter_HNS_2130",
        34,
        321,
        20,
        v35);
    }
    while ( v22 > v6 );
  }
LABEL_9:
  v10 = v5;
  v11 = 0;
  free(v10);
  *a3 = v20;
  v12 = *(_DWORD *)(a1 + 284);
  v25 = 655360;
  v26 = 255;
  v23 = 1;
  v24 = 0;
  ptr = calloc(12 * v12, 1u);
  (*(void (__fastcall **)(int, int *, int, _DWORD *, int *, int, int, _DWORD))(a1 + 244))(
    a1,
    &v23,
    v12,
    ptr,
    &v22,
    v17,
    2000,
    0);
  if ( v22 > 0 )
  {
    v13 = 0;
    v14 = ptr;
    s = 0;
    do
    {
      if ( *((_WORD *)v14 + 3) == 10 )
      {
        s += *v14;
        V_LOCK();
        V_INT((int)v29, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v35,
          0x1000u,
          0,
          v30,
          v29[0],
          v29[1],
          v29[2],
          v29[3],
          v29[4],
          v29[5],
          v29[6],
          v30,
          "%s chip %02x, core %02x, reg %02x, core_nonce_cnt %08x",
          "ChipSetting_nonce_counter_HNS_2130",
          *((unsigned __int8 *)v14 + 4),
          *((unsigned __int8 *)v14 + 8),
          *((unsigned __int16 *)v14 + 3),
          *v14);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_nonce_counter_HNS_2130",
          34,
          344,
          20,
          v35);
      }
      else
      {
        V_LOCK();
        V_INT((int)v31, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v35,
          0x1000u,
          0,
          v32,
          v31[0],
          v31[1],
          v31[2],
          v31[3],
          v31[4],
          v31[5],
          v31[6],
          v32,
          "%s chip %02x, expected reg %02x, but %02x, core_nonce_cnt %08x",
          "ChipSetting_nonce_counter_HNS_2130",
          *((unsigned __int8 *)v14 + 4),
          5,
          *((unsigned __int16 *)v14 + 3),
          *v14);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_nonce_counter_HNS_2130",
          34,
          347,
          100,
          v35);
      }
      ++v13;
      v14 += 3;
    }
    while ( v22 > v13 );
    v11 = s;
  }
  free(ptr);
  V_LOCK();
  V_INT((int)v33, "chain", *(int *)(a1 + 200));
  v15 = "Failed";
  if ( v20 == v11 )
    v15 = "Pass";
  logfmt_raw(
    v35,
    0x1000u,
    0,
    v34,
    v33[0],
    v33[1],
    v33[2],
    v33[3],
    v33[4],
    v33[5],
    v33[6],
    v34,
    "check nonce counter, top_nonce_cnt %d, core_nocne_cnt %d (%s)",
    v20,
    v11,
    v15);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_nonce_counter_HNS_2130",
    34,
    353,
    40,
    v35);
  return v20 != v11;
}
// 5A344: variable 'v17' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005A5E0) --------------------------------------------------------
int __fastcall sub_5A5E0(int a1, int a2, char **a3)
{
  if ( sub_5A104(a1, a2, a3) )
    return 19;
  else
    return 0;
}

//----- (0005A5F8) --------------------------------------------------------
int __fastcall sub_5A5F8(int a1)
{
  int v2; // r6
  int v3; // r2
  int v4; // r0
  int v5; // r9
  int *v6; // r5
  int v7; // r0
  int v8; // r12
  int v9; // r2
  int v10; // r3
  int v11; // r2
  int v13; // [sp+4h] [bp-10E0h]
  int v14; // [sp+3Ch] [bp-10A8h]
  int *ptr; // [sp+44h] [bp-10A0h]
  int v16; // [sp+4Ch] [bp-1098h] BYREF
  _DWORD v17[2]; // [sp+50h] [bp-1094h] BYREF
  int v18; // [sp+58h] [bp-108Ch]
  int v19; // [sp+5Ch] [bp-1088h]
  _DWORD v20[7]; // [sp+60h] [bp-1084h] BYREF
  int v21; // [sp+7Ch] [bp-1068h]
  _DWORD v22[7]; // [sp+80h] [bp-1064h] BYREF
  int v23; // [sp+9Ch] [bp-1048h]
  _DWORD v24[7]; // [sp+A0h] [bp-1044h] BYREF
  int v25; // [sp+BCh] [bp-1028h]
  _DWORD v26[7]; // [sp+C0h] [bp-1024h] BYREF
  int v27; // [sp+DCh] [bp-1008h]
  char v28[4100]; // [sp+E0h] [bp-1004h] BYREF

  V_LOCK();
  V_INT((int)v20, "chain", *(int *)(a1 + 200));
  v2 = 0;
  logfmt_raw(
    v28,
    0x1000u,
    0,
    v21,
    v20[0],
    v20[1],
    v20[2],
    v20[3],
    v20[4],
    v20[5],
    v20[6],
    v21,
    "get hash clock count chip_no %d",
    *(_DWORD *)(a1 + 280));
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_hash_clock_count_HNS_2130",
    37,
    692,
    20,
    v28);
  v18 = 393217;
  v17[1] = 0;
  v17[0] = 1;
  v19 = 255;
  if ( (*(int (__fastcall **)(int, _DWORD *))(a1 + 220))(a1, v17) < 0 )
  {
    V_LOCK();
    v14 = -1;
    V_INT((int)v22, "chain", *(int *)(a1 + 200));
    logfmt_raw(
      v28,
      0x1000u,
      0,
      v23,
      v22[0],
      v22[1],
      v22[2],
      v22[3],
      v22[4],
      v22[5],
      v22[6],
      v23,
      "%s failed, set reg:%02x",
      "ChipSetting_hash_clock_count_HNS_2130",
      HIWORD(v18));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_hash_clock_count_HNS_2130",
      37,
      701,
      100,
      v28);
  }
  else
  {
    usleep(0x4E20u);
    v3 = *(_DWORD *)(a1 + 280);
    v4 = *(_DWORD *)(a1 + 284);
    v18 = 458753;
    v5 = v4 * v3;
    LOBYTE(v19) = 0;
    ptr = (int *)calloc(12 * v4 * v3, 1u);
    (*(void (__fastcall **)(int, _DWORD *, int, int *, int *, int, int, _DWORD))(a1 + 244))(
      a1,
      v17,
      v5,
      ptr,
      &v16,
      v13,
      2000,
      0);
    v14 = 0;
    if ( v16 > 0 )
    {
      v6 = ptr;
      do
      {
        v10 = *v6;
        v11 = *((unsigned __int16 *)v6 + 3);
        HIBYTE(v22[0]) = *v6;
        BYTE2(v22[0]) = BYTE1(v10);
        BYTE1(v22[0]) = BYTE2(v10);
        LOBYTE(v22[0]) = HIBYTE(v10);
        if ( v11 == 7 )
        {
          V_LOCK();
          ++v14;
          V_INT((int)v24, "chain", *(int *)(a1 + 200));
          logfmt_raw(
            v28,
            0x1000u,
            0,
            v25,
            v24[0],
            v24[1],
            v24[2],
            v24[3],
            v24[4],
            v24[5],
            v24[6],
            v25,
            "[Hash clk cnt] chip %02x, core %02x, reg %02x, clk_cnt %08x",
            *((unsigned __int8 *)v6 + 4),
            *((unsigned __int8 *)v6 + 8),
            *((unsigned __int16 *)v6 + 3),
            v22[0]);
          V_UNLOCK();
          v7 = g_zc;
          v8 = 40;
          v9 = 720;
        }
        else
        {
          V_LOCK();
          V_INT((int)v26, "chain", *(int *)(a1 + 200));
          logfmt_raw(
            v28,
            0x1000u,
            0,
            v27,
            v26[0],
            v26[1],
            v26[2],
            v26[3],
            v26[4],
            v26[5],
            v26[6],
            v27,
            "[Hash clk cnt] chip %02x, expected reg %02x, but %02x, clk_cnt %08x",
            *((unsigned __int8 *)v6 + 4),
            7,
            *((unsigned __int16 *)v6 + 3),
            v22[0]);
          V_UNLOCK();
          v7 = g_zc;
          v8 = 100;
          v9 = 723;
        }
        ++v2;
        v6 += 3;
        zlog(
          v7,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_hash_clock_count_HNS_2130",
          37,
          v9,
          v8,
          v28);
      }
      while ( v16 > v2 );
    }
    free(ptr);
  }
  return v14;
}
// 5A754: variable 'v13' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005A9A8) --------------------------------------------------------
int __fastcall sub_5A9A8(int a1)
{
  if ( *(_DWORD *)(a1 + 284) * *(_DWORD *)(a1 + 280) == sub_5A5F8(a1) )
    return 19;
  else
    return 0;
}

//----- (0005A9D0) --------------------------------------------------------
int __fastcall sub_5A9D0(int a1)
{
  int v2; // r6
  int (__fastcall *v3)(int, _DWORD *); // r3
  int v4; // r8
  int v5; // r2
  int v6; // r5
  int v7; // r5
  _WORD *v8; // r5
  int v9; // r0
  int v10; // r12
  int v11; // r2
  int v13; // [sp+3Ch] [bp-1088h]
  _WORD *ptr; // [sp+44h] [bp-1080h]
  int v15; // [sp+48h] [bp-107Ch]
  int v16; // [sp+4Ch] [bp-1078h]
  _DWORD v17[2]; // [sp+50h] [bp-1074h] BYREF
  int v18; // [sp+58h] [bp-106Ch]
  int v19; // [sp+5Ch] [bp-1068h]
  _DWORD v20[7]; // [sp+60h] [bp-1064h] BYREF
  int v21; // [sp+7Ch] [bp-1048h]
  _DWORD v22[7]; // [sp+80h] [bp-1044h] BYREF
  int v23; // [sp+9Ch] [bp-1028h]
  _DWORD v24[7]; // [sp+A0h] [bp-1024h] BYREF
  int v25; // [sp+BCh] [bp-1008h]
  char v26[4100]; // [sp+C0h] [bp-1004h] BYREF

  V_LOCK();
  V_INT((int)v20, "chain", *(int *)(a1 + 200));
  logfmt_raw(
    v26,
    0x1000u,
    0,
    v21,
    v20[0],
    v20[1],
    v20[2],
    v20[3],
    v20[4],
    v20[5],
    v20[6],
    v21,
    "get pmdata chip_no %d",
    *(_DWORD *)(a1 + 280));
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_pmdata_HNS_2130",
    27,
    640,
    20,
    v26);
  v2 = 0;
  v18 = 0;
  v19 = 0;
  v13 = 0;
  v17[1] = 0;
  v3 = *(int (__fastcall **)(int, _DWORD *))(a1 + 220);
  while ( 1 )
  {
    if ( v2 == 3 )
      goto LABEL_12;
    LOBYTE(v18) = 1;
    HIWORD(v18) = 255;
    v17[0] = (16 * v2) | 1;
    LOBYTE(v19) = -1;
    if ( v3(a1, v17) < 0 )
      break;
    v4 = 0;
    usleep(0x4E20u);
    v5 = *(_DWORD *)(a1 + 280);
    v6 = *(_DWORD *)(a1 + 284);
    v18 = 327681;
    v7 = v6 * v5;
    LOBYTE(v19) = 0;
    ptr = calloc(12 * v7, 1u);
    (*(void (__fastcall **)(int, _DWORD *, int))(a1 + 244))(a1, v17, v7);
    if ( v15 > 0 )
    {
      v8 = ptr;
      do
      {
        HIBYTE(v16) = *(_DWORD *)v8;
        BYTE2(v16) = BYTE1(*(_DWORD *)v8);
        BYTE1(v16) = BYTE2(*(_DWORD *)v8);
        LOBYTE(v16) = HIBYTE(*(_DWORD *)v8);
        if ( v8[3] == 5 )
        {
          V_LOCK();
          ++v13;
          V_INT((int)v22, "chain", *(int *)(a1 + 200));
          logfmt_raw(
            v26,
            0x1000u,
            0,
            v23,
            v22[0],
            v22[1],
            v22[2],
            v22[3],
            v22[4],
            v22[5],
            v22[6],
            v23,
            "[PM data] chip %02x, reg %02x mode %d PMDATA %08x",
            *((unsigned __int8 *)v8 + 4),
            (unsigned __int16)v8[3],
            v2,
            v16);
          V_UNLOCK();
          v9 = g_zc;
          v10 = 40;
          v11 = 672;
        }
        else
        {
          V_LOCK();
          V_INT((int)v24, "chain", *(int *)(a1 + 200));
          logfmt_raw(
            v26,
            0x1000u,
            0,
            v25,
            v24[0],
            v24[1],
            v24[2],
            v24[3],
            v24[4],
            v24[5],
            v24[6],
            v25,
            "[PM data] chip %02x, expected reg %02x, but %02x mode %d PMDATA %08x",
            *((unsigned __int8 *)v8 + 4),
            5,
            (unsigned __int16)v8[3],
            v2,
            v16);
          V_UNLOCK();
          v9 = g_zc;
          v10 = 100;
          v11 = 675;
        }
        ++v4;
        v8 += 6;
        zlog(
          v9,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_pmdata_HNS_2130",
          27,
          v11,
          v10,
          v26);
      }
      while ( v15 > v4 );
    }
    if ( v2 == 6 )
    {
      free(ptr);
      return v13;
    }
    v3 = *(int (__fastcall **)(int, _DWORD *))(a1 + 220);
LABEL_12:
    ++v2;
  }
  V_LOCK();
  logfmt_raw(v26, 0x1000u, 0, "%s failed, set reg:%02x", "ChipSetting_pmdata_HNS_2130", HIWORD(v18));
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_pmdata_HNS_2130",
    27,
    653,
    100,
    v26);
  return -1;
}
// 5AB5C: variable 'v15' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005AD84) --------------------------------------------------------
int __fastcall sub_5AD84(int a1)
{
  if ( *(_DWORD *)(a1 + 284) * *(_DWORD *)(a1 + 280) == sub_5A9D0(a1) )
    return 19;
  else
    return 0;
}

//----- (0005ADAC) --------------------------------------------------------
int __fastcall sub_5ADAC(int a1, int a2)
{
  int v3; // r5
  _DWORD *v4; // r11
  _DWORD *v5; // r9
  _DWORD *v6; // r6
  int v7; // r3
  int v8; // r4
  int v11; // [sp+48h] [bp-105Ch] BYREF
  int v12; // [sp+4Ch] [bp-1058h]
  _DWORD v13[2]; // [sp+50h] [bp-1054h] BYREF
  int v14; // [sp+58h] [bp-104Ch]
  int v15; // [sp+5Ch] [bp-1048h]
  _DWORD v16[7]; // [sp+60h] [bp-1044h] BYREF
  int v17; // [sp+7Ch] [bp-1028h]
  _DWORD v18[7]; // [sp+80h] [bp-1024h] BYREF
  int v19; // [sp+9Ch] [bp-1008h]
  char v20[4100]; // [sp+A0h] [bp-1004h] BYREF

  v5 = *(_DWORD **)(a1 + 280);
  v3 = 0;
  v14 = 1835009;
  v13[1] = 0;
  v13[0] = 0;
  v15 = 0;
  v11 = 0;
  v4 = calloc(12 * (_DWORD)v5, 1u);
  (*(void (__fastcall **)(int, _DWORD *, _DWORD *, _DWORD *, int *))(a1 + 236))(a1, v13, v5, v4, &v11);
  LOWORD(v5) = (unsigned __int16)&g_zc;
  if ( v11 > 0 )
  {
    HIWORD(v5) = (unsigned int)&g_zc >> 16;
    v6 = v4;
    do
    {
      while ( 1 )
      {
        ++v3;
        if ( *((_WORD *)v6 + 3) == 28 )
          break;
        v6 += 3;
        if ( v11 <= v3 )
          goto LABEL_7;
      }
      V_LOCK();
      v6 += 3;
      V_INT((int)v16, "chain", *(int *)(a1 + 200));
      logfmt_raw(
        v20,
        0x1000u,
        0,
        v17,
        v16[0],
        v16[1],
        v16[2],
        v16[3],
        v16[4],
        v16[5],
        v16[6],
        v17,
        "[MISC CTRL] asic %02x, reg %02x state %08x",
        *((unsigned __int8 *)v6 - 8),
        *((unsigned __int16 *)v6 - 3),
        *(v6 - 3));
      V_UNLOCK();
      zlog(
        *v5,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/chip_setting.c",
        150,
        "ChipSetting_pll_sel_HNS_2130",
        28,
        189,
        20,
        v20);
    }
    while ( v11 > v3 );
  }
  else
  {
    HIWORD(v5) = (unsigned int)&g_zc >> 16;
  }
LABEL_7:
  v7 = *v4;
  HIBYTE(v12) = *v4;
  BYTE2(v12) = BYTE1(v7);
  BYTE1(v12) = BYTE2(v7);
  LOBYTE(v12) = HIBYTE(v7);
  free(v4);
  v14 = 1835009;
  v13[0] = v12 & 0xFFFFFFFB | (4 * (_BYTE)a2) & 4;
  V_LOCK();
  V_INT((int)v18, "chain", *(int *)(a1 + 200));
  logfmt_raw(
    v20,
    0x1000u,
    0,
    v19,
    v18[0],
    v18[1],
    v18[2],
    v18[3],
    v18[4],
    v18[5],
    v18[6],
    v19,
    "set pll sel %u %08x",
    a2,
    v13[0]);
  V_UNLOCK();
  zlog(
    *v5,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_pll_sel_HNS_2130",
    28,
    201,
    40,
    v20);
  v8 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v13);
  usleep(0x2710u);
  return v8;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005B054) --------------------------------------------------------
int __fastcall sub_5B054(int a1, int a2)
{
  if ( sub_5ADAC(a1, a2) )
    return 19;
  else
    return 0;
}

//----- (0005B06C) --------------------------------------------------------
int __fastcall sub_5B06C(int a1, int a2)
{
  int v3; // r4
  _DWORD v5[4]; // [sp+28h] [bp-1034h] BYREF
  _DWORD v6[7]; // [sp+38h] [bp-1024h] BYREF
  int v7; // [sp+54h] [bp-1008h]
  char v8[4100]; // [sp+58h] [bp-1004h] BYREF

  v5[0] = a2;
  v5[2] = 2883585;
  v5[3] = 0;
  v5[1] = 0;
  V_LOCK();
  V_INT((int)v6, "chain", *(int *)(a1 + 200));
  logfmt_raw(v8, 0x1000u, 0, v7, v6[0], v6[1], v6[2], v6[3], v6[4], v6[5], v6[6], v7, "set io cfg value %08x", v5[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_io_cfg_HNS_2130",
    27,
    233,
    40,
    v8);
  v3 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v5);
  usleep(0x2710u);
  return v3;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005B170) --------------------------------------------------------
int __fastcall sub_5B170(int a1, int a2)
{
  if ( sub_5B06C(a1, a2) )
    return 19;
  else
    return 0;
}

//----- (0005B188) --------------------------------------------------------
int __fastcall check_nonce_hns(int a1, int a2)
{
  int v2; // r7
  int v4; // r4
  unsigned int v5; // r6
  char v6; // r2
  int v7; // r3
  unsigned int v8; // r0
  unsigned int v9; // r7
  unsigned int v10; // r3
  unsigned __int8 *v11; // r3
  int v12; // r4
  int v13; // r2
  int v14; // r4
  unsigned int v15; // r0
  unsigned int v16; // t1
  unsigned int v17; // t1
  bool v18; // cc
  _BYTE s[32]; // [sp+10h] [bp-1124h] BYREF
  _DWORD dest[64]; // [sp+30h] [bp-1104h] BYREF
  char v22[4100]; // [sp+130h] [bp-1004h] BYREF

  v2 = *(unsigned __int8 *)(a2 + 57);
  v4 = *(_DWORD *)(a1 + 760);
  v5 = *(_DWORD *)(v4 + 4 * (v2 + 9472));
  memset(s, 255, sizeof(s));
  memcpy(dest, (const void *)(v4 + ((v2 + 20) << 8)), sizeof(dest));
  v6 = *(_BYTE *)(a2 + 54);
  v7 = *(_DWORD *)(a2 + 48);
  BYTE2(dest[62]) = *(_BYTE *)(a2 + 55);
  HIBYTE(dest[62]) = v6;
  dest[63] = v7;
  hns_hash((int)dest, s);
  v8 = be256_target_to_diff_base_0((int)s);
  v9 = v8;
  if ( v8 <= 0x23 )
  {
    V_LOCK();
    logfmt_raw(
      v22,
      0x1000u,
      0,
      "hw error calculate diff %d ans diff %d TICKET_MASK_HNS_2130 %d",
      v9,
      *(unsigned __int8 *)(a2 + 56),
      36);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/backend_hns_2130/backend_hns_2130.c",
      171,
      "check_nonce_hns",
      15,
      526,
      20,
      v22);
    return 2;
  }
  else
  {
    v10 = *(unsigned __int8 *)(a2 + 56);
    if ( v10 == v8 )
    {
      if ( v5 > v10 )
      {
LABEL_9:
        V_LOCK();
        logfmt_raw(v22, 0x1000u, 0, "hw diff (%d<%d) not reach pool", *(unsigned __int8 *)(a2 + 56), v5);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/backend_hns_2130/backend_hns_2130.c",
          171,
          "check_nonce_hns",
          15,
          562,
          20,
          v22);
        return 1;
      }
      else
      {
        v11 = s;
        v12 = v4 + 32 * (*(unsigned __int8 *)(a2 + 57) + 1200);
        v13 = v12 - 1;
        v14 = v12 + 31;
        do
        {
          v16 = *v11++;
          v15 = v16;
          v17 = *(unsigned __int8 *)++v13;
          v18 = v15 > v17;
          if ( v15 < v17 )
            break;
          if ( v18 )
            goto LABEL_9;
        }
        while ( v13 != v14 );
        return 0;
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(v22, 0x1000u, 0, "diff not match (%d!=%d) expected diff %d", v9, *(unsigned __int8 *)(a2 + 56), v5);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/backend_hns_2130/backend_hns_2130.c",
        171,
        "check_nonce_hns",
        15,
        531,
        20,
        v22);
      return 3;
    }
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005B3E4) --------------------------------------------------------
int __fastcall sub_5B3E4(int *a1, int a2)
{
  const char *v2; // r4
  void *v5; // r0
  void (__fastcall *v6)(int *, _DWORD *, int, void *, int *, int, int, _DWORD); // lr
  unsigned __int16 *v7; // r6
  unsigned int v8; // r9
  int v9; // r1
  int v10; // r0
  unsigned int v11; // r1
  unsigned int v12; // r0
  int v13; // r9
  int v14; // r2
  int **v15; // r12
  int result; // r0
  unsigned __int8 *v17; // r8
  char *v18; // r4
  int v19; // r6
  int v20; // r9
  int v22; // r2
  int *v23; // [sp+0h] [bp-160Ch] BYREF
  int v24; // [sp+4h] [bp-1608h]
  const char *v25; // [sp+8h] [bp-1604h]
  const char *v26; // [sp+54h] [bp-15B8h]
  const char *v27; // [sp+58h] [bp-15B4h]
  const char *v28; // [sp+5Ch] [bp-15B0h]
  int v29; // [sp+60h] [bp-15ACh]
  void *ptr; // [sp+64h] [bp-15A8h]
  int v31; // [sp+68h] [bp-15A4h]
  int **v32; // [sp+6Ch] [bp-15A0h]
  int v33; // [sp+74h] [bp-1598h] BYREF
  _DWORD v34[4]; // [sp+78h] [bp-1594h] BYREF
  _DWORD v35[7]; // [sp+88h] [bp-1584h] BYREF
  int v36; // [sp+A4h] [bp-1568h]
  _BYTE v37[32]; // [sp+A8h] [bp-1564h] BYREF
  _DWORD v38[7]; // [sp+C8h] [bp-1544h] BYREF
  int v39; // [sp+E4h] [bp-1528h]
  _DWORD v40[8]; // [sp+E8h] [bp-1524h] BYREF
  _BYTE s[256]; // [sp+108h] [bp-1504h] BYREF
  char v42[1024]; // [sp+208h] [bp-1404h] BYREF
  char v43[4100]; // [sp+608h] [bp-1004h] BYREF

  v2 = 0;
  v33 = 0;
  memset(s, 0, sizeof(s));
  V_LOCK();
  logfmt_raw(v43, 0x1000u, 0, "%s chip_no %d", "ChipSetting_get_addr_HNS_2130", a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_get_addr_HNS_2130",
    29,
    32,
    20,
    v43);
  v31 = a2;
  v34[0] = 0;
  v34[2] = 1;
  v34[1] = 0;
  v34[3] = 0;
  v5 = calloc(12 * a2, 1u);
  v23 = &v33;
  v6 = (void (__fastcall *)(int *, _DWORD *, int, void *, int *, int, int, _DWORD))a1[59];
  ptr = v5;
  v6(a1, v34, a2, v5, &v33, v24, 3000, 0);
  V_LOCK();
  V_INT((int)v35, "chain", a1[50]);
  logfmt_raw(
    v43,
    0x1000u,
    0,
    v36,
    v35[0],
    v35[1],
    v35[2],
    v35[3],
    v35[4],
    v35[5],
    v35[6],
    v36,
    "%s detect %d chips",
    "ChipSetting_get_addr_HNS_2130",
    v33,
    a1[68]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_get_addr_HNS_2130",
    29,
    43,
    60,
    v43);
  if ( v33 > 0 )
  {
    v26 = "ChipSetting_get_addr_HNS_2130";
    v29 = 0;
    v28 = "[GET ADDR] chip_type %04x/%04x chip %d reg %d addr %02x";
    v27 = "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c";
    v7 = (unsigned __int16 *)ptr;
    do
    {
      while ( 1 )
      {
        v8 = *v7;
        V_LOCK();
        v9 = *((unsigned __int8 *)v7 + 4);
        LOWORD(v8) = __rev16(v8);
        v10 = v7[3];
        v24 = a1[68];
        v25 = v2++;
        logfmt_raw(v43, 0x1000u, 0, v28, (unsigned __int16)v8, v24, v25, v10, v9);
        V_UNLOCK();
        zlog(g_zc, v27, 150, v26, 29, 47, 20, v43);
        if ( a1[68] == (unsigned __int16)v8 )
          break;
        v7 += 6;
        if ( v33 <= (int)v2 )
          goto LABEL_7;
      }
      v7 += 6;
      v11 = a1[93];
      v12 = *((unsigned __int8 *)v7 - 8);
      ++v29;
      v13 = v12 / v11;
      s[v13] = 1;
      V_LOCK();
      v14 = a1[50];
      v32 = (int **)v37;
      V_INT((int)v37, "chain", v14);
      v15 = v32;
      v32 = &v23;
      logfmt_raw(
        v43,
        0x1000u,
        0,
        v15[7],
        *v15,
        v15[1],
        v15[2],
        v15[3],
        v15[4],
        v15[5],
        v15[6],
        v15[7],
        "chip_id:%d, %03d",
        v13,
        *((unsigned __int8 *)v7 - 8));
      V_UNLOCK();
      zlog(g_zc, v27, 150, v26, 29, 53, 20, v43);
    }
    while ( v33 > (int)v2 );
LABEL_7:
    v2 = (const char *)v29;
  }
  else
  {
    v29 = 0;
  }
  if ( a1[70] > v29 )
  {
    V_LOCK();
    V_INT((int)v38, "chain", a1[50]);
    V_STR(v40, "error", "asic num error");
    logfmt_raw(
      v43,
      0x1000u,
      0,
      v39,
      v38[0],
      v38[1],
      v38[2],
      v38[3],
      v38[4],
      v38[5],
      v38[6],
      v39,
      v40[0],
      v40[1],
      v40[2],
      v40[3],
      v40[4],
      v40[5],
      v40[6],
      v40[7],
      "detected asic num less than design(%d<%d)",
      v29,
      a1[70]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_get_addr_HNS_2130",
      29,
      59,
      100,
      v43);
    memset(v42, 0, sizeof(v42));
    v42[0] = 10;
    if ( v31 )
    {
      v26 = v2;
      v17 = s;
      v18 = v42;
      v19 = 0;
      v20 = v31;
      do
      {
        while ( *v17++ )
        {
          if ( v20 == ++v19 )
            goto LABEL_15;
        }
        v22 = v19++;
        sprintf(v18, "%02d ", v22);
        v18 += 3;
      }
      while ( v20 != v19 );
LABEL_15:
      v2 = v26;
    }
    V_LOCK();
    logfmt_raw(v43, 0x1000u, 0, "bad asic:\n%s\n", v42);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_get_addr_HNS_2130",
      29,
      69,
      40,
      v43);
  }
  free(ptr);
  result = v33;
  a1[92] = (int)v2;
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005B904) --------------------------------------------------------
int __fastcall sub_5B904(int *a1)
{
  int v2; // r6
  int v3; // r4

  v2 = a1[70];
  v3 = 3;
  while ( 1 )
  {
    sub_5B3E4(a1, v2);
    if ( a1[92] == v2 )
      break;
    if ( !--v3 )
      return 12;
  }
  return 0;
}

//----- (0005B944) --------------------------------------------------------
int __fastcall parameter_update_hns(int a1, char a2, int a3, char a4, int a5)
{
  int v8; // r1
  int result; // r0
  int v10; // r3
  int v11; // r7
  double v12; // r0

  if ( *(_BYTE *)(a1 + 204) )
    return 0;
  if ( (unsigned int)(a3 - 50) <= 0x28A )
    v8 = a2 & 1;
  else
    v8 = 0;
  if ( v8 )
  {
    v11 = a1 + 928;
    LODWORD(v12) = sub_DD46C(*(_QWORD *)(a1 + 920));
    *(_QWORD *)(v11 - 8) = (unsigned __int64)(v12 / (double)a3 * *(float *)(a1 + 900));
    *(float *)(a1 + 900) = (float)a3;
  }
  result = 0;
  if ( (unsigned int)(a5 - 1400) <= 0x12C )
    v10 = a4 & 1;
  else
    v10 = 0;
  if ( v10 )
    *(_DWORD *)(a1 + 904) = a5;
  return result;
}
// 5B9CC: variable 'v12' is possibly undefined

//----- (0005B9F4) --------------------------------------------------------
int __fastcall packet_2_nonce_hns(unsigned int *a1, int a2, int a3, _BYTE *a4, _DWORD *a5, signed int *a6, _DWORD *a7)
{
  unsigned int v9; // r7
  char *v11; // r0
  int v14; // r6
  int v15; // r3
  int v16; // r2
  const char *v17; // r1
  unsigned int v18; // r7
  char v19; // r3
  signed int v20; // r0
  int v21; // r1
  int v22; // r2
  int v23; // r0
  signed int v24; // r1

  if ( *(char *)(a2 + 11) >= 0 )
    return 10;
  v9 = a1[190];
  v11 = (char *)(a3 + 16);
  v14 = *(_BYTE *)(a2 + 10) & 0x7F;
  v15 = *(_DWORD *)(v9 + 8 * v14);
  v16 = *(_DWORD *)(v9 + 8 * v14 + 4);
  v17 = (const char *)(v9 + 32 * (v14 + 32));
  *(_DWORD *)a3 = v15;
  v18 = v9 + (v14 << 8);
  *(_DWORD *)(a3 + 4) = v16;
  *a7 = v15;
  strcpy(v11, v17);
  *(_BYTE *)(a3 + 52) = *(_BYTE *)(v18 + 5241);
  *(_BYTE *)(a3 + 53) = *(_BYTE *)(v18 + 5240);
  *(_BYTE *)(a3 + 54) = *(_BYTE *)(a2 + 4);
  *(_BYTE *)(a3 + 55) = *(_BYTE *)(a2 + 3);
  *(_DWORD *)(a3 + 48) = *(_DWORD *)(a2 + 5);
  v19 = *(_BYTE *)(a2 + 9);
  *(_BYTE *)(a3 + 57) = v14;
  *(_BYTE *)(a3 + 56) = v19;
  v20 = *(unsigned __int8 *)(a2 + 3) / a1[93];
  if ( v20 >= (int)a1[70] )
  {
    v23 = rand();
    sub_DD144(v23, a1[70]);
    v20 = v24;
  }
  *a6 = v20;
  *(_DWORD *)(a3 + 8) = v20;
  *(_DWORD *)(a3 + 12) = *(_BYTE *)(a2 + 8) & 0x3F;
  v21 = BM_CRC5((_BYTE *)(a2 + 2), 75);
  v22 = *(_BYTE *)(a2 + 11) & 0x1F;
  if ( v21 == v22 )
  {
    *a5 = *(_DWORD *)(a3 + 48);
    *a4 = 1;
    return 0;
  }
  else
  {
    printf("get nonce crc error calc value %04x expected value %04x\n", v21, v22);
    return 11;
  }
}
// 5BB0C: variable 'v24' is possibly undefined

//----- (0005BB28) --------------------------------------------------------
int __fastcall sub_5BB28(char *a1, _DWORD *a2, _DWORD *a3, int a4)
{
  char v4; // r7
  int result; // r0
  int v10; // r3
  int v11; // r2
  char v12; // [sp+17h] [bp-1005h] BYREF
  char v13[4100]; // [sp+18h] [bp-1004h] BYREF

  v4 = a4;
  *a3 = 0;
  *a2 = -64;
  if ( pic1704_write_iic(*a1, a4) )
  {
    usleep(0x2710u);
    result = pic1704_read_iic(*a1, v4, &v12);
    if ( result )
    {
      v10 = v12;
      *a3 = 1;
      *a2 = v10;
      return result;
    }
    V_LOCK();
    logfmt_raw(v13, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)a1, a4);
    V_UNLOCK();
    v11 = 930;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v13, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)a1, a4);
    V_UNLOCK();
    v11 = 919;
  }
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_read_sensor_temp_local_on_pic_HNS_2130",
    50,
    v11,
    20,
    v13);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005BC70) --------------------------------------------------------
int __fastcall sub_5BC70(char *a1, _DWORD *a2, _DWORD *a3, int a4)
{
  char v4; // r7
  int result; // r0
  int v10; // r3
  int v11; // r2
  char v12; // [sp+17h] [bp-1005h] BYREF
  char v13[4100]; // [sp+18h] [bp-1004h] BYREF

  v4 = a4;
  *a3 = 0;
  *a2 = -64;
  if ( pic1704_write_iic(*a1, a4) )
  {
    usleep(0x2710u);
    result = pic1704_read_iic(*a1, v4, &v12);
    if ( result )
    {
      v10 = v12;
      *a3 = 1;
      *a2 = v10 + 15;
      return result;
    }
    V_LOCK();
    logfmt_raw(v13, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)a1, a4);
    V_UNLOCK();
    v11 = 956;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v13, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)a1, a4);
    V_UNLOCK();
    v11 = 945;
  }
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_read_sensor_temp_remote_on_pic_HNS_2130",
    51,
    v11,
    20,
    v13);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005BDBC) --------------------------------------------------------
int __fastcall sub_5BDBC(unsigned int *a1, _DWORD *a2, _DWORD *a3, int a4)
{
  int v8; // r3
  int v10; // [sp+34h] [bp-1030h]
  _BYTE v11[4]; // [sp+3Ch] [bp-1028h] BYREF
  _DWORD v12[7]; // [sp+40h] [bp-1024h] BYREF
  int v13; // [sp+5Ch] [bp-1008h]
  char v14[4100]; // [sp+60h] [bp-1004h] BYREF

  V_LOCK();
  logfmt_raw(
    v14,
    0x1000u,
    0,
    "%s chain[%d] iic_addr:%d",
    "ChipSetting_read_sensor_temp_local_on_ctrlboard_HNS_2130",
    *a1,
    a4);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_read_sensor_temp_local_on_ctrlboard_HNS_2130",
    56,
    970,
    20,
    v14);
  *a3 = 0;
  v10 = tsensor_read(*a1, a4, 0, (int)v11, 2u);
  if ( v10 == 2 )
  {
    v8 = v11[0];
    *a3 = 1;
    *a2 = v8;
    V_LOCK();
    V_INT((int)v12, "chain", (int)*a1);
    logfmt_raw(
      v14,
      0x1000u,
      0,
      v13,
      v12[0],
      v12[1],
      v12[2],
      v12[3],
      v12[4],
      v12[5],
      v12[6],
      v13,
      "read ctrlboard temp, local[%02x] %d",
      a4,
      *a2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_read_sensor_temp_local_on_ctrlboard_HNS_2130",
      56,
      982,
      20,
      v14);
  }
  else
  {
    *a2 = -64;
    v10 = -1;
    V_LOCK();
    logfmt_raw(v14, 0x1000u, 0, "failed to read ctrlboard-temp for chain %d", *a1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_read_sensor_temp_local_on_ctrlboard_HNS_2130",
      56,
      977,
      80,
      v14);
  }
  return v10;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005BFA0) --------------------------------------------------------
int __fastcall sub_5BFA0(unsigned int *a1, unsigned __int8 *a2, _DWORD *a3, _DWORD *a4, unsigned __int8 a5)
{
  int result; // r0
  int v10; // r3
  _BYTE v11[4]; // [sp+14h] [bp-1004h] BYREF
  char v12[4072]; // [sp+18h] [bp-1000h] BYREF

  *a4 = 0;
  result = tsensor_read(*a1, a5, 0, (int)v11, 2u);
  if ( result == 2 )
  {
    v10 = v11[0];
    *a4 = 1;
    *a3 = v10 + *a2;
  }
  else
  {
    *a3 = -64;
    V_LOCK();
    logfmt_raw(v12, 0x1000u, 0, "failed to read ctrlboard-temp for chain %d", *a1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_read_sensor_temp_remote_on_ctrlboard_HNS_2130",
      57,
      996,
      80,
      v12);
    return -1;
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005C094) --------------------------------------------------------
int __fastcall sub_5C094(_DWORD *a1, int a2, int a3, _DWORD *a4, _DWORD *a5)
{
  char v5; // r8
  int (__fastcall *v9)(_DWORD *, int *); // r3
  signed int v11; // r2
  unsigned __int8 *v12; // r0
  unsigned __int8 *v13; // r4
  void (__fastcall *v14)(_DWORD *, int *, signed int, unsigned __int8 *, int *); // r5
  int v15; // r5
  signed int v16; // [sp+14h] [bp-20h]
  int v17; // [sp+1Ch] [bp-18h] BYREF
  int v18; // [sp+20h] [bp-14h] BYREF
  int v19; // [sp+24h] [bp-10h]
  int v20; // [sp+28h] [bp-Ch]
  int v21; // [sp+2Ch] [bp-8h]

  v5 = a2;
  v20 = 0;
  v19 = 0;
  v21 = 0;
  v18 = a3 | 0x1980000;
  BYTE1(v20) = a2;
  v9 = (int (__fastcall *)(_DWORD *, int *))a1[54];
  HIWORD(v20) = 255;
  if ( v9(a1, &v18) )
    return 0;
  usleep(0xC350u);
  *a4 = 0;
  v19 = 0;
  *a5 = 0;
  v11 = a1[70];
  v20 = 0;
  v21 = 0;
  v18 = 0;
  if ( v11 >= 1 )
    v11 = 1;
  v16 = v11;
  v12 = (unsigned __int8 *)calloc(v11, 0xCu);
  BYTE1(v20) = v5;
  v13 = v12;
  v14 = (void (__fastcall *)(_DWORD *, int *, signed int, unsigned __int8 *, int *))a1[59];
  HIWORD(v20) = 255;
  v14(a1, &v18, v16, v12, &v17);
  v15 = v17;
  if ( v17 == 1 && a2 == v13[4] )
  {
    *a4 = *(_DWORD *)v13;
    *a5 = 1;
  }
  free(v13);
  return v15;
}

//----- (0005C1A8) --------------------------------------------------------
int __fastcall read_sensor_temp_remote_hns(int a1, int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int v13; // r0
  int v14; // r1
  int v15; // r3
  int v16; // r2
  int v17; // [sp+8h] [bp-8h] BYREF
  int v18; // [sp+Ch] [bp-4h] BYREF

  if ( a6 )
  {
    if ( a6 == 1 )
    {
      v14 = *(unsigned __int8 *)(*(_DWORD *)(a1 + 432) + a9);
      *a3 = 0;
      *a2 = -64;
      v13 = sub_5C094((_DWORD *)a1, v14, 256, &v17, &v18);
      if ( v13 == 1 )
      {
        v15 = HIBYTE(v17);
        v16 = v18;
        if ( *(_DWORD *)(a1 + 456) == 1 )
          v15 = HIBYTE(v17) - 64;
        *a2 = v15;
        *a3 = v16;
        return 0;
      }
    }
    else
    {
      if ( a6 != 2 )
        return 4;
      v13 = sub_5BFA0((unsigned int *)(a1 + 200), (unsigned __int8 *)(a1 + 912), a2, a3, a9);
    }
  }
  else
  {
    v13 = sub_5BC70((char *)(a1 + 200), a2, a3, a9);
  }
  if ( v13 == -1 )
    return 4;
  return 0;
}

//----- (0005C28C) --------------------------------------------------------
int __fastcall read_sensor_temp_local_hns(
        _DWORD *a1,
        int *a2,
        _DWORD *a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9)
{
  int v11; // r0
  int v14; // r1
  int v15; // r3
  int v16; // r2
  int v17; // [sp+8h] [bp-8h] BYREF
  int v18; // [sp+Ch] [bp-4h] BYREF

  if ( a6 )
  {
    if ( a6 == 1 )
    {
      v14 = *(unsigned __int8 *)(a1[108] + a9);
      *a3 = 0;
      *a2 = -64;
      v11 = sub_5C094(a1, v14, 0, &v17, &v18);
      if ( v11 == 1 )
      {
        v15 = HIBYTE(v17);
        v16 = v18;
        if ( a1[114] == 1 )
          v15 = HIBYTE(v17) - 64;
        *a2 = v15;
        *a3 = v16;
        return 0;
      }
    }
    else
    {
      if ( a6 != 2 )
        return 4;
      v11 = sub_5BDBC(a1 + 50, a2, a3, a9);
    }
  }
  else
  {
    v11 = sub_5BB28((char *)a1 + 200, a2, a3, a9);
  }
  if ( v11 == -1 )
    return 4;
  return 0;
}

//----- (0005C35C) --------------------------------------------------------
int __fastcall set_baud_hns_0(int a1, int a2)
{
  int v4; // r4
  int v5; // r4
  _DWORD v7[4]; // [sp+30h] [bp-1034h] BYREF
  _DWORD v8[7]; // [sp+40h] [bp-1024h] BYREF
  int v9; // [sp+5Ch] [bp-1008h]
  char v10[4100]; // [sp+60h] [bp-1004h] BYREF

  v7[2] = 6291457;
  v7[1] = 0;
  v7[3] = 0;
  v7[0] = 0;
  if ( a2 == 1500000 )
    goto LABEL_24;
  if ( a2 <= 1500000 )
  {
    if ( a2 == 460800 )
    {
      v4 = 1568;
      goto LABEL_10;
    }
    if ( a2 > 460800 )
    {
      if ( a2 == 921600 || a2 == 1041666 )
      {
        v4 = 544;
        goto LABEL_10;
      }
    }
    else if ( a2 == 38400 )
    {
      v4 = 20512;
      goto LABEL_10;
    }
    goto LABEL_16;
  }
  if ( a2 == 3125000 )
  {
LABEL_23:
    v4 = 32;
    goto LABEL_10;
  }
  if ( a2 <= 3125000 )
  {
    if ( a2 != 1562500 )
    {
      if ( a2 != 3000000 )
        goto LABEL_16;
      goto LABEL_23;
    }
LABEL_24:
    v4 = 288;
    goto LABEL_10;
  }
  if ( a2 == 6250000 )
  {
    v4 = 289;
    goto LABEL_9;
  }
  if ( a2 != 12500000 )
  {
LABEL_16:
    v4 = 6688;
    goto LABEL_10;
  }
  v4 = 33;
LABEL_9:
  (*(void (__fastcall **)(int, int))(a1 + 176))(a1, 1);
LABEL_10:
  v7[0] = v4;
  V_LOCK();
  V_INT((int)v8, "chain", *(int *)(a1 + 200));
  logfmt_raw(
    v10,
    0x1000u,
    0,
    v9,
    v8[0],
    v8[1],
    v8[2],
    v8[3],
    v8[4],
    v8[5],
    v8[6],
    v9,
    "set fuart cfg value %08x/%d",
    v4,
    a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_fuart_cfg_HNS_2130",
    30,
    421,
    40,
    v10);
  v5 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v7);
  usleep(0x2710u);
  return v5;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005C558) --------------------------------------------------------
int __fastcall sub_5C558(int a1)
{
  int v2; // r4
  _DWORD v4[4]; // [sp+28h] [bp-1034h] BYREF
  _DWORD v5[7]; // [sp+38h] [bp-1024h] BYREF
  int v6; // [sp+54h] [bp-1008h]
  char v7[4100]; // [sp+58h] [bp-1004h] BYREF

  v4[0] = 5381904;
  v4[2] = 1835009;
  v4[3] = 0;
  v4[1] = 0;
  V_LOCK();
  V_INT((int)v5, "chain", *(int *)(a1 + 200));
  logfmt_raw(v7, 0x1000u, 0, v6, v5[0], v5[1], v5[2], v5[3], v5[4], v5[5], v5[6], v6, "set misc ctrl %08x", 5381904);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_misc_ctrl_HNS_2130",
    30,
    167,
    40,
    v7);
  v2 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v4);
  usleep(0x2710u);
  return v2;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005C664) --------------------------------------------------------
int __fastcall top_init_hns(int *a1)
{
  int v2; // r7
  int v3; // r4
  int v4; // r0
  int v5; // r1
  char v6; // r3
  void (__fastcall *v7)(int *, int, int); // r3
  _DWORD v9[7]; // [sp+28h] [bp-1024h] BYREF
  int v10; // [sp+44h] [bp-1008h]
  char v11[4100]; // [sp+48h] [bp-1004h] BYREF

  V_LOCK();
  V_INT((int)v9, "chain", a1[50]);
  logfmt_raw(v11, 0x1000u, 0, v10, v9[0], v9[1], v9[2], v9[3], v9[4], v9[5], v9[6], v10, "top_init_hns");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/backend_hns_2130/backend_hns_2130.c",
    171,
    "top_init_hns",
    12,
    400,
    40,
    v11);
  v2 = a1[70];
  v3 = a1[108];
  v4 = sub_DCEB0(256, (unsigned __int8)v2);
  if ( (_BYTE)v2 )
  {
    v5 = v3 - 1;
    v6 = 0;
    do
    {
      *(_BYTE *)++v5 = v6;
      v6 += v4;
    }
    while ( v5 != v3 - 1 + (unsigned __int8)v2 );
    v3 = a1[108];
  }
  v7 = (void (__fastcall *)(int *, int, int))a1[52];
  a1[93] = v4;
  v7(a1, v3, v2);
  sub_59504((int)a1, 0);
  sub_5C558((int)a1);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005C794) --------------------------------------------------------
int __fastcall dhash_start_hns(int a1)
{
  int v2; // r3
  int result; // r0
  _DWORD v4[7]; // [sp+28h] [bp-1020h] BYREF
  int v5; // [sp+44h] [bp-1004h]
  char v6[4096]; // [sp+48h] [bp-1000h] BYREF

  V_LOCK();
  V_INT((int)v4, "chain", *(int *)(a1 + 200));
  logfmt_raw(v6, 0x1000u, 0, v5, v4[0], v4[1], v4[2], v4[3], v4[4], v4[5], v4[6], v5, "dhash_start_hns");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/backend_hns_2130/backend_hns_2130.c",
    171,
    "dhash_start_hns",
    15,
    420,
    40,
    v6);
  sub_5C558(a1);
  v2 = *(unsigned __int8 *)(a1 + 404);
  result = 0;
  *(_BYTE *)(a1 + 205) = 1;
  if ( !v2 )
    *(_DWORD *)(a1 + 408) = (int)*(float *)(a1 + 900);
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005C874) --------------------------------------------------------
int get_pcba_test_level_hns()
{
  return 0;
}

//----- (0005C87C) --------------------------------------------------------
int __fastcall makeup_chip_addr_hns(_BYTE *a1, unsigned int a2)
{
  int result; // r0
  _BYTE *v5; // r2
  char v6; // r3

  result = sub_DCEB0(256, a2);
  if ( a2 )
  {
    v5 = a1;
    v6 = 0;
    do
    {
      *v5++ = v6;
      v6 += result;
    }
    while ( &a1[a2] != v5 );
  }
  return result;
}

//----- (0005C8C0) --------------------------------------------------------
int __fastcall set_nonce_cycle_limit(int a1)
{
  unsigned int v2; // r5
  _DWORD v4[7]; // [sp+28h] [bp-1024h] BYREF
  int v5; // [sp+44h] [bp-1008h]
  char v6[4100]; // [sp+48h] [bp-1004h] BYREF

  v2 = (unsigned int)((float)(67109000.0 / *(float *)(a1 + 900)) * 12.5);
  sub_58BC0(a1, 14, HIWORD(v2));
  sub_58BC0(a1, 15, (unsigned __int16)v2);
  V_LOCK();
  V_INT((int)v4, "chain", *(int *)(a1 + 200));
  logfmt_raw(
    v6,
    0x1000u,
    0,
    v5,
    v4[0],
    v4[1],
    v4[2],
    v4[3],
    v4[4],
    v4[5],
    v4[6],
    v5,
    "set nonce cycle limit value %08x",
    v2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/backend_hns_2130/backend_hns_2130.c",
    171,
    "set_nonce_cycle_limit",
    21,
    393,
    40,
    v6);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005C9BC) --------------------------------------------------------
int __fastcall softreset_all_chip_hns(int *a1)
{
  sub_58C48((int)a1);
  usleep((__useconds_t)"rl_kda_2110");
  sub_58BC0((int)a1, 8, 0);
  sub_58BC0((int)a1, 16, 0);
  sub_59610((int)a1, 37);
  set_nonce_cycle_limit((int)a1);
  sub_58D70(a1, 255);
  return 0;
}

//----- (0005CA1C) --------------------------------------------------------
int get_algo_type_hns()
{
  return 0;
}

//----- (0005CA24) --------------------------------------------------------
int update_chip_info_hns()
{
  return 0;
}

//----- (0005CA2C) --------------------------------------------------------
void *runtime_ctrl_hns_2130()
{
  void *v0; // r0
  void *v1; // r7
  _QWORD v3[117]; // [sp+0h] [bp-3A8h] BYREF

  memset(v3, 0, sizeof(v3));
  LODWORD(v3[31]) = 3363656;
  HIDWORD(v3[39]) = 210;
  LODWORD(v3[40]) = 500;
  LODWORD(v3[33]) = 7564904;
  HIDWORD(v3[41]) = sensor_info_hns_2130;
  v3[42] = qword_106528;
  v3[43] = qword_106530;
  v3[44] = qword_106538;
  v0 = calloc(1u, 0x3A8u);
  HIDWORD(v3[1]) = dhash_mining_stop_base;
  LODWORD(v3[2]) = dhash_mining_reset_base;
  LODWORD(v3[4]) = pop_ans_base;
  LODWORD(v3[0]) = backend_init_base;
  HIDWORD(v3[4]) = try_pop_ans_base;
  LODWORD(v3[8]) = check_nonce_hns;
  LODWORD(v3[1]) = dhash_mining_start_base;
  HIDWORD(v3[2]) = backend_exit_base;
  HIDWORD(v3[8]) = global_idx_init_hns;
  HIDWORD(v3[10]) = sub_5B054;
  HIDWORD(v3[3]) = async_push_work_base;
  LODWORD(v3[6]) = softreset_all_chip_hns;
  LODWORD(v3[11]) = sub_595F8;
  LODWORD(v3[13]) = sub_5A5E0;
  HIDWORD(v3[0]) = reset_base;
  HIDWORD(v3[7]) = packet_2_nonce_hns;
  LODWORD(v3[9]) = global_idx_free_hns;
  HIDWORD(v3[13]) = sub_5A0EC;
  LODWORD(v3[15]) = get_theory_hashrate_hns;
  LODWORD(v3[3]) = push_work_base;
  LODWORD(v3[10]) = sub_5B170;
  LODWORD(v3[12]) = sub_5AD84;
  HIDWORD(v3[15]) = get_sale_hashrate_hns;
  HIDWORD(v3[16]) = get_qualify_nonce_num_hns;
  LODWORD(v3[7]) = work_2_packet_hns;
  HIDWORD(v3[12]) = sub_5A9A8;
  LODWORD(v3[14]) = sub_599D0;
  LODWORD(v3[17]) = set_sensor_extern_mode_hns;
  HIDWORD(v3[17]) = read_sensor_temp_local_hns;
  HIDWORD(v3[9]) = set_baud_hns;
  HIDWORD(v3[14]) = get_chip_status_hns;
  LODWORD(v3[16]) = get_qualify_hashrate_hns;
  LODWORD(v3[18]) = read_sensor_temp_remote_hns;
  HIDWORD(v3[18]) = parameter_update_hns;
  LODWORD(v3[19]) = overclock_update_hns;
  HIDWORD(v3[19]) = get_pcba_test_level_hns;
  LODWORD(v3[20]) = get_packet_remain_len_hns;
  LODWORD(v3[22]) = set_frequency_hns;
  HIDWORD(v3[22]) = sub_5B904;
  LODWORD(v3[23]) = sub_599F8;
  HIDWORD(v3[23]) = top_init_hns;
  LODWORD(v3[24]) = dhash_start_hns;
  LODWORD(v3[26]) = set_chipaddr_base;
  HIDWORD(v3[26]) = set_inactive_base;
  LODWORD(v3[27]) = set_chip_reg_base;
  HIDWORD(v3[27]) = set_core_reg_base_9;
  LODWORD(v3[28]) = set_core_reg_base_9;
  LODWORD(v3[29]) = sync_get_status_base;
  HIDWORD(v3[29]) = sync_get_chip_reg_base;
  HIDWORD(v3[30]) = sync_get_core_reg_base3;
  v3[34] = 0x100002130LL;
  HIDWORD(v3[37]) = 3;
  v3[112] = 0x440AC00042480000LL;
  v3[35] = 0x3C0000005CLL;
  v3[36] = 0x10000003CLL;
  v3[96] = 0x400000058LL;
  LODWORD(v3[47]) = 36;
  HIDWORD(v3[95]) = 368;
  v1 = v0;
  v3[97] = 0xC00000106LL;
  HIDWORD(v3[28]) = set_core_enable_base;
  v3[115] = 73214640;
  LODWORD(v3[113]) = 1520;
  LOBYTE(v3[114]) = 13;
  memcpy(v0, v3, 0x3A8u);
  return v1;
}
// 5C554: using guessed type int set_baud_hns();
// 106524: using guessed type _UNKNOWN *sensor_info_hns_2130;
// 106528: using guessed type __int64;
// 106530: using guessed type __int64;
// 106538: using guessed type __int64;

//----- (0005CDB8) --------------------------------------------------------
int get_chip_status_kda()
{
  return 0;
}

//----- (0005CDC0) --------------------------------------------------------
int __fastcall get_theory_hashrate_kda(int a1, double *a2)
{
  float v2; // s14

  v2 = *(float *)(a1 + 900);
  *a2 = v2 * 87584.0 * 1000.0 * 1000.0;
  return 0;
}

//----- (0005CDF8) --------------------------------------------------------
int __fastcall get_sale_hashrate_kda(int a1, double *a2, _DWORD *a3)
{
  int result; // r0
  double v7; // [sp+0h] [bp-8h] BYREF

  v7 = 0.0;
  (*(void (__fastcall **)(int, double *))(a1 + 120))(a1, &v7);
  if ( *(_BYTE *)(a1 + 248) != 75 )
    return 24;
  if ( *(_BYTE *)(a1 + 249) != 65 )
    return 24;
  if ( *(_BYTE *)(a1 + 250) != 51 )
    return 24;
  result = *(unsigned __int8 *)(a1 + 251);
  if ( *(_BYTE *)(a1 + 251) )
    return 24;
  *a2 = v7 * 0.9875;
  *a3 = 100;
  return result;
}

//----- (0005CE90) --------------------------------------------------------
int __fastcall get_qualify_hashrate_kda(int a1, double *a2)
{
  int result; // r0
  double v5; // [sp+0h] [bp-Ch] BYREF

  v5 = 0.0;
  (*(void (__fastcall **)(int, double *))(a1 + 120))(a1, &v5);
  if ( *(_BYTE *)(a1 + 248) != 75 )
    return 24;
  if ( *(_BYTE *)(a1 + 249) != 65 )
    return 24;
  if ( *(_BYTE *)(a1 + 250) != 51 )
    return 24;
  result = *(unsigned __int8 *)(a1 + 251);
  if ( *(_BYTE *)(a1 + 251) )
    return 24;
  *a2 = v5 * 0.993095;
  return result;
}

//----- (0005CF18) --------------------------------------------------------
int __fastcall get_qualify_nonce_num_kda(int a1, float *a2)
{
  int v4; // r0
  char v5; // r1
  int v6; // r3
  __int64 v7; // r0
  double v8; // r0
  double v9; // d4
  float v11; // s14
  double v12; // [sp+0h] [bp-Ch] BYREF

  v12 = 0.0;
  (*(void (__fastcall **)(int, double *))(a1 + 120))(a1, &v12);
  v4 = *(_DWORD *)(a1 + 376);
  v5 = 32 - v4;
  v6 = 1 << (v4 - 32);
  LODWORD(v7) = 1 << v4;
  HIDWORD(v7) = v6 | (1u >> v5);
  LODWORD(v8) = sub_DD46C(v7);
  v9 = v8;
  v11 = v12 / v9 / 92.0 * 0.5;
  *a2 = v11;
  return 0;
}
// 5CF68: variable 'v8' is possibly undefined

//----- (0005CFA0) --------------------------------------------------------
int overclock_update_kda()
{
  return 0;
}

//----- (0005CFA8) --------------------------------------------------------
unsigned int __fastcall get_packet_remain_len_kda(int a1)
{
  unsigned int result; // r0

  result = a1 - 1;
  if ( result >= 9 )
    return 8;
  return result;
}

//----- (0005CFB8) --------------------------------------------------------
int __fastcall global_idx_init_kda(int a1)
{
  void *v2; // r0

  v2 = calloc(0xC688u, 1u);
  *(_DWORD *)(a1 + 760) = v2;
  printf("__custom_data init %p\n", v2);
  return 0;
}

//----- (0005CFE8) --------------------------------------------------------
int __fastcall global_idx_free_kda(int a1)
{
  free(*(void **)(a1 + 760));
  return 0;
}

//----- (0005CFFC) --------------------------------------------------------
int __fastcall sub_5CFFC(int a1)
{
  _DWORD v3[1025]; // [sp+10h] [bp-1004h] BYREF

  V_LOCK();
  logfmt_raw((char *)v3, 0x1000u, 0, "software_reset %s %02x", "ChipSetting_software_reset_KDA_2110", 68);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_software_reset_KDA_2110",
    35,
    95,
    20,
    v3);
  v3[2] = 4456449;
  v3[3] = 0;
  v3[1] = 0;
  v3[0] = 3;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v3);
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005D0BC) --------------------------------------------------------
int __fastcall set_sensor_extern_mode_kda(int a1)
{
  int (__fastcall *v2)(int, _DWORD *); // r3
  int v3; // r6
  int result; // r0
  _DWORD v5[2]; // [sp+0h] [bp-10h] BYREF
  int v6; // [sp+8h] [bp-8h]
  int v7; // [sp+Ch] [bp-4h]

  v5[0] = 26806532;
  v6 = 16711680;
  v5[1] = 0;
  v7 = 0;
  v2 = *(int (__fastcall **)(int, _DWORD *))(a1 + 216);
  LOBYTE(v6) = 1;
  v3 = v2(a1, v5);
  usleep((__useconds_t)"rl_kda_2110");
  result = 0;
  if ( !v3 )
    *(_DWORD *)(a1 + 456) = 1;
  return result;
}

//----- (0005D124) --------------------------------------------------------
int __fastcall sub_5D124(int *a1, int a2)
{
  int v4; // r2
  int (__fastcall *v5)(int *, _DWORD *); // r3
  int v6; // r4
  int v8; // [sp+2Ch] [bp-1038h]
  _DWORD v9[2]; // [sp+30h] [bp-1034h] BYREF
  int v10; // [sp+38h] [bp-102Ch]
  int v11; // [sp+3Ch] [bp-1028h]
  _DWORD v12[7]; // [sp+40h] [bp-1024h] BYREF
  int v13; // [sp+5Ch] [bp-1008h]
  char v14[4100]; // [sp+60h] [bp-1004h] BYREF

  v9[1] = 0;
  v10 = 0;
  v11 = 0;
  v9[0] = 0;
  V_LOCK();
  V_INT((int)v12, "chain", a1[50]);
  logfmt_raw(
    v14,
    0x1000u,
    0,
    v13,
    v12[0],
    v12[1],
    v12[2],
    v12[3],
    v12[4],
    v12[5],
    v12[6],
    v13,
    "set core ticket mask reg %02x tm %02x",
    3,
    a2,
    v8,
    0,
    0,
    0,
    0);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_core_ticket_mask_KDA_2110",
    37,
    141,
    40,
    v14);
  v4 = a1[71];
  LOBYTE(v11) = -1;
  BYTE1(v11) = v4;
  v10 = 196609;
  BYTE2(v11) = 1;
  v5 = (int (__fastcall *)(int *, _DWORD *))a1[55];
  v9[0] = a2;
  v6 = v5(a1, v9);
  usleep(0x3E8u);
  a1[94] = a2;
  return v6;
}
// 5D1AC: variable 'v8' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005D24C) --------------------------------------------------------
int __fastcall work_2_packet_kda(int a1, int a2, int a3, _DWORD *a4)
{
  int v5; // r4
  _WORD *v7; // r10
  _DWORD *v8; // r3
  int v9; // r2
  int v10; // r1
  int v11; // r12
  _DWORD *v12; // r0
  int v13; // t1
  int v14; // r9
  int v15; // lr
  int v16; // r12
  int v17; // r9
  int v18; // lr
  int v19; // r12
  char *v20; // r6
  int v21; // r3
  char v22; // r1
  char v23; // r12
  char v24; // r1
  char *v25; // r3
  int v26; // r2
  char v27; // t1
  int v28; // r4
  __int16 v29; // r0
  int v30; // r3
  void (__fastcall *v31)(int, _DWORD *); // r3
  int v33; // r7
  int v34; // t1
  int v35; // r7
  int v36; // r5
  int v37; // r4
  int v38; // t1
  int v41; // [sp+20h] [bp-200Ch]
  int v42; // [sp+24h] [bp-2008h]
  char v43[4056]; // [sp+28h] [bp-2004h] BYREF
  _DWORD v44[2]; // [sp+1028h] [bp-1004h] BYREF
  int v45; // [sp+1030h] [bp-FFCh]
  int v46; // [sp+1034h] [bp-FF8h]

  v5 = *(_DWORD *)(a1 + 760);
  *(_BYTE *)a3 = 85;
  *(_BYTE *)(a3 + 1) = -86;
  *(_BYTE *)(a3 + 2) = 32;
  v7 = (_WORD *)(a2 + 396);
  if ( *(_DWORD *)(a1 + 436) == 1 )
    *(_BYTE *)(a3 + 2) = 48;
  v8 = (_DWORD *)a2;
  v9 = *(unsigned __int8 *)(v5 + 50816);
  v10 = a2 + 8;
  v11 = *(_DWORD *)(v10 + 352);
  v41 = v10;
  *(_QWORD *)(v5 + 8 * v9) = *(_QWORD *)a2;
  *(_DWORD *)(v5 + 4 * (v9 + 11552)) = v11;
  v12 = (_DWORD *)(v5 + 32 * (v9 + 1460));
  v13 = v8[91];
  v8 += 91;
  v14 = v8[1];
  v15 = v8[2];
  v16 = v8[3];
  *v12 = v13;
  v12[1] = v14;
  v12[2] = v15;
  v12[3] = v16;
  v17 = v8[5];
  v18 = v8[6];
  v19 = v8[7];
  v12[4] = v8[4];
  v20 = (char *)(a2 + 72);
  v12[6] = v18;
  v12[7] = v19;
  v12[5] = v17;
  strcpy((char *)(v5 + ((*(unsigned __int8 *)(v5 + 50816) + 16) << 6)), (const char *)v10);
  memcpy((void *)(v5 + 286 * *(unsigned __int8 *)(v5 + 50816) + 9216), (const void *)(a2 + 72), 0x11Eu);
  v21 = 3 * *(unsigned __int8 *)(v5 + 50816) + 45824;
  v22 = *(_BYTE *)(a2 + 398);
  *(_WORD *)(v5 + v21) = *v7;
  *(_BYTE *)(v5 + v21 + 2) = v22;
  v23 = *(_BYTE *)(v5 + 50816);
  *(_BYTE *)(a3 + 3) = v23;
  *(_BYTE *)(v5 + 50816) = (v23 + 1) & 0x7F;
  memset((void *)(a3 + 4), 0, 0x11Eu);
  v24 = *(_BYTE *)(a2 + 398);
  v25 = (char *)(a2 + 350);
  v26 = a3 + 6;
  *(_WORD *)(a3 + 4) = *v7;
  *(_BYTE *)(a3 + 6) = v24;
  do
  {
    v27 = *--v25;
    *(_BYTE *)++v26 = v27;
  }
  while ( v25 != v20 );
  if ( *(_DWORD *)(a1 + 436) == 1 )
  {
    *(_DWORD *)(a3 + 285) = *(_DWORD *)(a2 + 350);
    *(_BYTE *)(a3 + 289) = *(_BYTE *)(a2 + 354);
  }
  v28 = memcmp(&last_header_kda, (const void *)(a2 + 72), 0x11Eu);
  if ( !v28 )
  {
    V_LOCK();
    logfmt_raw((char *)v44, 0x1000u, 0, "found repeat work");
    V_UNLOCK();
    v33 = a3 - 1;
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/backend_kda_2110/backend_kda_2110.c",
      171,
      "work_2_packet_kda",
      17,
      132,
      20,
      v44);
    v42 = *(unsigned __int8 *)(a3 + 3);
    do
    {
      v34 = *(unsigned __int8 *)++v33;
      snprintf(&v43[v28], 4096 - v28, "%02x", v34);
      v28 += 2;
    }
    while ( v33 != a3 + 291 );
    V_LOCK();
    logfmt_raw((char *)v44, 0x1000u, 0, "dump packet %s", v43);
    V_UNLOCK();
    v35 = a2 + 357;
    v36 = a2 + 71;
    v37 = 0;
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/backend_kda_2110/backend_kda_2110.c",
      171,
      "dump_work_kda",
      13,
      83,
      20,
      v44);
    do
    {
      v38 = *(unsigned __int8 *)++v36;
      snprintf(&v43[v37], 4096 - v37, "%02x", v38);
      v37 += 2;
    }
    while ( v35 != v36 );
    V_LOCK();
    logfmt_raw((char *)v44, 0x1000u, 0, "kda dump work jobid %s, work count %d", v41, v42);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/backend_kda_2110/backend_kda_2110.c",
      171,
      "dump_work_kda",
      13,
      89,
      20,
      v44);
    V_LOCK();
    logfmt_raw((char *)v44, 0x1000u, 0, "dump work: %s", v43);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/backend_kda_2110/backend_kda_2110.c",
      171,
      "dump_work_kda",
      13,
      90,
      20,
      v44);
  }
  memcpy(&last_header_kda, v20, 0x11Eu);
  v29 = BM_CRC16((unsigned __int8 *)(a3 + 2), 288);
  *(_BYTE *)(a3 + 291) = v29;
  *(_BYTE *)(a3 + 290) = HIBYTE(v29);
  v30 = *(unsigned __int8 *)(a1 + 205);
  *a4 = 292;
  if ( v30 && *(_BYTE *)(a1 + 206) )
  {
    memset(*(void **)(a1 + 400), 0, 48 * *(_DWORD *)(a1 + 280));
    sub_5D124((int *)a1, 40);
    *(_BYTE *)(a1 + 205) = 0;
  }
  V_LOCK();
  logfmt_raw((char *)v44, 0x1000u, 0, "bridge reset %s %02x", "ChipSetting_bridge_reset_KDA_2110", 68);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_bridge_reset_KDA_2110",
    33,
    82,
    20,
    v44);
  v44[1] = 0;
  v45 = 4456448;
  v46 = 0;
  v31 = *(void (__fastcall **)(int, _DWORD *))(a1 + 216);
  LOBYTE(v45) = 1;
  v44[0] = 2;
  v31(a1, v44);
  usleep(0x14u);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005D770) --------------------------------------------------------
int __fastcall sub_5D770(int a1, int a2)
{
  float v2; // s0
  __int16 v3; // r3
  int v4; // r12
  signed int v5; // r6
  float v6; // s19
  int v7; // r10
  int v8; // r11
  int v9; // r8
  int v10; // r5
  int v11; // r2
  int v12; // r4
  float v13; // s17
  int v14; // r0
  int v15; // r0
  float v16; // s16
  int v17; // r2
  signed int v19; // r7
  int v20; // r6
  unsigned int v22; // [sp+38h] [bp-104Ch]
  int v25; // [sp+4Ch] [bp-1038h]
  _DWORD v26[2]; // [sp+50h] [bp-1034h] BYREF
  int v27; // [sp+58h] [bp-102Ch]
  int v28; // [sp+5Ch] [bp-1028h]
  int v29; // [sp+60h] [bp-1024h] BYREF
  int v30; // [sp+64h] [bp-1020h]
  int v31; // [sp+68h] [bp-101Ch]
  int v32; // [sp+6Ch] [bp-1018h]
  __int64 v33; // [sp+70h] [bp-1014h]
  int v34; // [sp+78h] [bp-100Ch]
  int v35; // [sp+7Ch] [bp-1008h]
  char v36[4100]; // [sp+80h] [bp-1004h] BYREF

  v3 = 0;
  v27 = 0;
  v26[1] = 0;
  v28 = 0;
  v26[0] = 0;
  if ( !a2 )
    v3 = 8;
  LOBYTE(v27) = 1;
  if ( a2 )
  {
    if ( a2 == 1 )
      HIWORD(v27) = 12;
  }
  else
  {
    HIWORD(v27) = v3;
  }
  v4 = -1068236443;
  v5 = 2;
  v25 = 2;
LABEL_8:
  v6 = (float)v5;
  v7 = 0;
  v8 = 0;
LABEL_9:
  v9 = v8 + 1;
  v10 = v8;
  v22 = (v5 << 8) | 0xC0000000 | v7;
  while ( 1 )
  {
    v11 = (int)(float)((float)((float)((float)((float)(v10 + 1) * (float)((float)(v8 + 1) * v2)) * v6) / 25.0) * 100.0);
    v12 = v11 / 100;
    if ( v11 % 100 > 50 )
      ++v12;
    if ( (unsigned int)(v12 - 16) <= 0xEA )
    {
      v13 = (float)((float)v12 * 25.0) / v6;
      if ( (v5 != 1 || v13 <= 3125.0) && v13 <= 3200.0 && v13 >= 2000.0 )
      {
        v14 = sub_DCEB0(25 * v12, v5);
        v15 = sub_DCEB0(v14, v8 + 1);
        v16 = (float)sub_DCEB0(v15, v10 + 1);
        v17 = v13 > 2400.0;
        v4 = v10 & 7 | v22 | (v12 << 16) | (v17 << 28);
        if ( fabsf(v16 - v2) < 3.0 )
          break;
      }
    }
    if ( v10-- == 0 )
    {
      v7 += 16;
      ++v8;
      if ( v9 != 8 )
        goto LABEL_9;
      v5 = 1;
      if ( v25 == 1 )
      {
        v26[0] = v4;
        V_LOCK();
        V_INT((int)&v29, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v36,
          0x1000u,
          0,
          v35,
          v29,
          v30,
          v31,
          v32,
          v33,
          v34,
          v35,
          "set pll_no %d freq: %.2f, expected freq: %.2f",
          a2,
          0,
          0,
          v2);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_freq_KDA_2110",
          25,
          500,
          40,
          v36);
        goto LABEL_24;
      }
      v25 = 1;
      goto LABEL_8;
    }
  }
  v19 = v5;
  v20 = v10 & 7 | v22 | (v12 << 16) | (v17 << 28);
  V_LOCK();
  logfmt_raw(
    v36,
    0x1000u,
    0,
    "target_freq:%.2f actual_freq:%.2f,vco:%.2f fbdiv:%d refdiv:%d postdiv1:%d, postdiv2:%d",
    v2,
    v16,
    v13,
    v12,
    v19,
    v8,
    v10);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "inferred_plldivider",
    19,
    473,
    20,
    v36);
  v26[0] = v20;
  V_LOCK();
  V_INT((int)&v29, "chain", *(int *)(a1 + 200));
  logfmt_raw(
    v36,
    0x1000u,
    0,
    v35,
    v29,
    v30,
    v31,
    v32,
    v33,
    v34,
    v35,
    "set pll_no %d freq: %.2f, expected freq: %.2f",
    a2,
    v16,
    v2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_freq_KDA_2110",
    25,
    500,
    40,
    v36);
  if ( v16 > 0.0 )
    v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v26);
  else
    v10 = -1;
LABEL_24:
  usleep(0x2710u);
  return v10;
}
// 5D840: variable 'v2' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005DBA8) --------------------------------------------------------
int __fastcall set_frequency_kda_2110(int a1, int a2)
{
  sub_5D770(a1, a2);
  return 0;
}

//----- (0005DBB8) --------------------------------------------------------
int __fastcall sub_5DBB8(int a1, int a2)
{
  _DWORD v4[4]; // [sp+28h] [bp-1034h] BYREF
  _DWORD v5[7]; // [sp+38h] [bp-1024h] BYREF
  int v6; // [sp+54h] [bp-1008h]
  char v7[4100]; // [sp+58h] [bp-1004h] BYREF

  v4[0] = a2;
  v4[2] = 4194305;
  v4[3] = 0;
  v4[1] = 0;
  V_LOCK();
  V_INT((int)v5, "chain", *(int *)(a1 + 200));
  logfmt_raw(v7, 0x1000u, 0, v6, v5[0], v5[1], v5[2], v5[3], v5[4], v5[5], v5[6], v6, "set analog value %08x", v4[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_analog_mux_KDA_2110",
    31,
    745,
    40,
    v7);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v4);
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005DCAC) --------------------------------------------------------
int __fastcall sub_5DCAC(int a1, int a2)
{
  if ( sub_5DBB8(a1, a2) )
    return 19;
  else
    return 0;
}

//----- (0005DCC4) --------------------------------------------------------
int __fastcall sub_5DCC4(int a1, int *a2)
{
  int v2; // r2
  _DWORD *v3; // r6
  int *v5; // r8
  int v6; // r3
  int v7; // r0
  int v8; // r1
  int v9; // r2
  int v10; // r3
  void (__fastcall *v11)(int, int *, int *, _DWORD, int, int, int, int, _DWORD); // r9
  int v12; // r3
  int v13; // r2
  int v14; // r2
  int *v16; // [sp+38h] [bp-109Ch]
  int v17; // [sp+40h] [bp-1094h] BYREF
  int v18; // [sp+44h] [bp-1090h] BYREF
  int v19; // [sp+48h] [bp-108Ch] BYREF
  int v20; // [sp+4Ch] [bp-1088h] BYREF
  _DWORD v21[7]; // [sp+50h] [bp-1084h] BYREF
  int v22; // [sp+6Ch] [bp-1068h]
  _DWORD v23[7]; // [sp+70h] [bp-1064h] BYREF
  int v24; // [sp+8Ch] [bp-1048h]
  _DWORD v25[7]; // [sp+90h] [bp-1044h] BYREF
  int v26; // [sp+ACh] [bp-1028h]
  _DWORD v27[7]; // [sp+B0h] [bp-1024h] BYREF
  int v28; // [sp+CCh] [bp-1008h]
  char v29[4100]; // [sp+D0h] [bp-1004h] BYREF

  v2 = *(_DWORD *)(a1 + 340);
  v3 = *(_DWORD **)(a1 + 332);
  v17 = -64;
  v18 = -64;
  if ( v2 > 0 )
  {
    v16 = &a2[2 * v2];
    v5 = a2;
    do
    {
      v19 = 0;
      (*(void (__fastcall **)(int, int *, int *, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(a1 + 140))(
        a1,
        &v17,
        &v19,
        *v3,
        v3[1],
        v3[2],
        v3[3],
        v3[4],
        v3[5]);
      if ( v19 )
      {
        v6 = v17;
        if ( v17 >= -63 )
          goto LABEL_4;
        v17 = -64;
        V_LOCK();
        V_INT((int)v21, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v29,
          0x1000u,
          0,
          v22,
          v21[0],
          v21[1],
          v21[2],
          v21[3],
          v21[4],
          v21[5],
          v21[6],
          v22,
          "got uneffective temp, sensor[%d], addr:%02x",
          *v3,
          v3[5]);
        V_UNLOCK();
        v13 = 263;
      }
      else
      {
        v17 = -64;
        V_LOCK();
        V_INT((int)v23, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v29,
          0x1000u,
          0,
          v24,
          v23[0],
          v23[1],
          v23[2],
          v23[3],
          v23[4],
          v23[5],
          v23[6],
          v24,
          "read sensor failed, sensor[%d], addr:%02x",
          *v3,
          v3[5]);
        V_UNLOCK();
        v13 = 268;
      }
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/backend_kda_2110/backend_kda_2110.c",
        171,
        "read_temperature_kda",
        20,
        v13,
        100,
        v29);
      v6 = v17;
LABEL_4:
      *v5 = v6;
      v7 = v3[1];
      v8 = v3[2];
      v9 = v3[3];
      v10 = v3[4];
      v11 = *(void (__fastcall **)(int, int *, int *, _DWORD, int, int, int, int, _DWORD))(a1 + 144);
      v20 = 0;
      v11(a1, &v18, &v20, *v3, v7, v8, v9, v10, v3[5]);
      if ( !v20 )
      {
        v18 = -64;
        V_LOCK();
        V_INT((int)v27, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v29,
          0x1000u,
          0,
          v28,
          v27[0],
          v27[1],
          v27[2],
          v27[3],
          v27[4],
          v27[5],
          v27[6],
          v28,
          "read sensor failed, sensor[%d], addr:%02x",
          *v3,
          v3[5]);
        V_UNLOCK();
        v14 = 283;
LABEL_11:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/backend_kda_2110/backend_kda_2110.c",
          171,
          "read_temperature_kda",
          20,
          v14,
          100,
          v29);
        v12 = v18;
        goto LABEL_6;
      }
      v12 = v18;
      if ( v18 < -63 )
      {
        v18 = -64;
        V_LOCK();
        V_INT((int)v25, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v29,
          0x1000u,
          0,
          v26,
          v25[0],
          v25[1],
          v25[2],
          v25[3],
          v25[4],
          v25[5],
          v25[6],
          v26,
          "got uneffective temp, sensor[%d], addr:%02x",
          *v3,
          v3[5]);
        V_UNLOCK();
        v14 = 278;
        goto LABEL_11;
      }
LABEL_6:
      v5[1] = v12;
      v5 += 2;
      usleep((__useconds_t)&loc_7A120);
      v3 += 6;
    }
    while ( v16 != v5 );
  }
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005E03C) --------------------------------------------------------
int __fastcall sub_5E03C(int a1, int a2)
{
  int v4; // r2
  int v5; // r7
  int v6; // r7
  int v7; // r7
  int *v8; // r6
  int v9; // r0
  int v10; // r12
  int v11; // r2
  int v12; // r3
  int v13; // r8
  int v15; // [sp+4h] [bp-10E8h]
  int v16; // [sp+38h] [bp-10B4h]
  int *ptr; // [sp+4Ch] [bp-10A0h]
  int v18; // [sp+54h] [bp-1098h] BYREF
  _DWORD v19[2]; // [sp+58h] [bp-1094h] BYREF
  int v20; // [sp+60h] [bp-108Ch]
  int v21; // [sp+64h] [bp-1088h]
  _DWORD v22[7]; // [sp+68h] [bp-1084h] BYREF
  int v23; // [sp+84h] [bp-1068h]
  _DWORD v24[7]; // [sp+88h] [bp-1064h] BYREF
  int v25; // [sp+A4h] [bp-1048h]
  _DWORD v26[7]; // [sp+A8h] [bp-1044h] BYREF
  int v27; // [sp+C4h] [bp-1028h]
  _DWORD v28[7]; // [sp+C8h] [bp-1024h] BYREF
  int v29; // [sp+E4h] [bp-1008h]
  char v30[4100]; // [sp+E8h] [bp-1004h] BYREF

  V_LOCK();
  V_INT((int)v22, "chain", *(int *)(a1 + 200));
  logfmt_raw(
    v30,
    0x1000u,
    0,
    v23,
    v22[0],
    v22[1],
    v22[2],
    v22[3],
    v22[4],
    v22[5],
    v22[6],
    v23,
    "set clock delay chip_no %d, value %08x",
    *(_DWORD *)(a1 + 280),
    a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_clock_delay_KDA_2110",
    32,
    597,
    40,
    v30);
  v19[1] = 0;
  v21 = 255;
  v19[0] = a2;
  v20 = 1;
  if ( (*(int (__fastcall **)(int, _DWORD *))(a1 + 220))(a1, v19) < 0 )
  {
    V_LOCK();
    v16 = -1;
    V_INT((int)v24, "chain", *(int *)(a1 + 200));
    logfmt_raw(
      v30,
      0x1000u,
      0,
      v25,
      v24[0],
      v24[1],
      v24[2],
      v24[3],
      v24[4],
      v24[5],
      v24[6],
      v25,
      "%s failed, set reg:%02x",
      "ChipSetting_clock_delay_KDA_2110",
      HIWORD(v20));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_clock_delay_KDA_2110",
      32,
      606,
      100,
      v30);
  }
  else
  {
    usleep((__useconds_t)"rl_kda_2110");
    v4 = *(_DWORD *)(a1 + 280);
    v5 = *(_DWORD *)(a1 + 284);
    LOBYTE(v21) = 0;
    v6 = v5 * v4;
    ptr = (int *)calloc(12 * v6, 1u);
    (*(void (__fastcall **)(int, _DWORD *, int, int *, int *, int, int, _DWORD))(a1 + 244))(
      a1,
      v19,
      v6,
      ptr,
      &v18,
      v15,
      2000,
      0);
    if ( v18 > 0 )
    {
      v7 = 0;
      v16 = 0;
      v8 = ptr;
      do
      {
        v12 = *v8;
        v13 = *((unsigned __int16 *)v8 + 3);
        HIBYTE(v24[0]) = *v8;
        BYTE2(v24[0]) = BYTE1(v12);
        BYTE1(v24[0]) = BYTE2(v12);
        LOBYTE(v24[0]) = HIBYTE(v12);
        V_LOCK();
        if ( v13 )
        {
          V_INT((int)v28, "chain", *(int *)(a1 + 200));
          logfmt_raw(
            v30,
            0x1000u,
            0,
            v29,
            v28[0],
            v28[1],
            v28[2],
            v28[3],
            v28[4],
            v28[5],
            v28[6],
            v29,
            "[DP] chip %02x, expected reg %02x, but %02x, data %08x",
            *((unsigned __int8 *)v8 + 4),
            0,
            *((unsigned __int16 *)v8 + 3),
            v24[0]);
          V_UNLOCK();
          v9 = g_zc;
          v10 = 100;
          v11 = 625;
        }
        else
        {
          ++v16;
          V_INT((int)v26, "chain", *(int *)(a1 + 200));
          logfmt_raw(
            v30,
            0x1000u,
            0,
            v27,
            v26[0],
            v26[1],
            v26[2],
            v26[3],
            v26[4],
            v26[5],
            v26[6],
            v27,
            "[DP] chip %02x, core %02x, reg %02x, clk_delay %08x",
            *((unsigned __int8 *)v8 + 4),
            *((unsigned __int8 *)v8 + 8),
            *((unsigned __int16 *)v8 + 3),
            v24[0]);
          V_UNLOCK();
          v9 = g_zc;
          v10 = 20;
          v11 = 622;
        }
        ++v7;
        v8 += 3;
        zlog(
          v9,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_clock_delay_KDA_2110",
          32,
          v11,
          v10,
          v30);
      }
      while ( v18 > v7 );
    }
    else
    {
      v16 = 0;
    }
    free(ptr);
  }
  return v16;
}
// 5E18C: variable 'v15' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005E3FC) --------------------------------------------------------
int __fastcall sub_5E3FC(int a1, int a2)
{
  if ( *(_DWORD *)(a1 + 284) * *(_DWORD *)(a1 + 280) == sub_5E03C(a1, a2) )
    return 19;
  else
    return 0;
}

//----- (0005E424) --------------------------------------------------------
int __fastcall sub_5E424(int a1, int a2, char a3)
{
  int v4; // r6
  _DWORD *v5; // r10
  _DWORD *v6; // r4
  int (__fastcall *v7)(int, _DWORD *); // r3
  int result; // r0
  int v9; // [sp+40h] [bp-1094h]
  int v10; // [sp+44h] [bp-1090h]
  char v11; // [sp+48h] [bp-108Ch]
  char v12; // [sp+50h] [bp-1084h]
  int v14; // [sp+5Ch] [bp-1078h] BYREF
  _DWORD v15[2]; // [sp+60h] [bp-1074h] BYREF
  int v16; // [sp+68h] [bp-106Ch]
  int v17; // [sp+6Ch] [bp-1068h]
  _DWORD v18[7]; // [sp+70h] [bp-1064h] BYREF
  int v19; // [sp+8Ch] [bp-1048h]
  _DWORD v20[7]; // [sp+90h] [bp-1044h] BYREF
  int v21; // [sp+ACh] [bp-1028h]
  _DWORD v22[7]; // [sp+B0h] [bp-1024h] BYREF
  int v23; // [sp+CCh] [bp-1008h]
  char v24[4100]; // [sp+D0h] [bp-1004h] BYREF

  v9 = a3 & 1;
  v14 = 0;
  if ( a2 == -1 || *(_DWORD *)(a1 + 280) < a2 )
  {
    v11 = 0;
    v12 = 1;
  }
  else
  {
    v12 = 0;
    v11 = *(_BYTE *)(*(_DWORD *)(a1 + 432) + a2);
  }
  v4 = 0;
  v16 = 0x10000;
  v15[1] = 0;
  v15[0] = 0;
  BYTE1(v16) = v11;
  v17 = 0;
  v5 = calloc(0xCu, 1u);
  (*(void (__fastcall **)(int, _DWORD *, int, _DWORD *, int *))(a1 + 244))(a1, v15, 1, v5, &v14);
  if ( v14 <= 0 )
  {
    v10 = v9;
  }
  else
  {
    v6 = v5;
    v10 = v9;
    do
    {
      if ( *((_WORD *)v6 + 3) == 1 )
      {
        V_LOCK();
        V_INT((int)v18, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v24,
          0x1000u,
          0,
          v19,
          v18[0],
          v18[1],
          v18[2],
          v18[3],
          v18[4],
          v18[5],
          v18[6],
          v19,
          "%s chip %02x, core %02x, reg %02x, core_mode %08x",
          "ChipSetting_same_nonce_KDA_2110",
          *((unsigned __int8 *)v6 + 4),
          *((unsigned __int8 *)v6 + 8),
          *((unsigned __int16 *)v6 + 3),
          *v6);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_same_nonce_KDA_2110",
          31,
          268,
          20,
          v24);
        v10 = v9 | *v6;
      }
      else
      {
        V_LOCK();
        V_INT((int)v20, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v24,
          0x1000u,
          0,
          v21,
          v20[0],
          v20[1],
          v20[2],
          v20[3],
          v20[4],
          v20[5],
          v20[6],
          v21,
          "%s chip %02x, expected reg %02x, but %02x, core_mode %08x",
          "ChipSetting_same_nonce_KDA_2110",
          *((unsigned __int8 *)v6 + 4),
          5,
          *((unsigned __int16 *)v6 + 3),
          *v6);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_same_nonce_KDA_2110",
          31,
          272,
          100,
          v24);
      }
      ++v4;
      v6 += 3;
    }
    while ( v14 > v4 );
  }
  free(v5);
  HIWORD(v16) = 1;
  LOBYTE(v17) = -1;
  LOBYTE(v16) = v12;
  v7 = *(int (__fastcall **)(int, _DWORD *))(a1 + 220);
  BYTE1(v16) = v11;
  v15[0] = v10;
  result = v7(a1, v15);
  if ( result < 0 )
  {
    V_LOCK();
    V_INT((int)v22, "chain", *(int *)(a1 + 200));
    logfmt_raw(
      v24,
      0x1000u,
      0,
      v23,
      v22[0],
      v22[1],
      v22[2],
      v22[3],
      v22[4],
      v22[5],
      v22[6],
      v23,
      "set same nonce failed! chip_id:%d",
      a2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_same_nonce_KDA_2110",
      31,
      285,
      100,
      v24);
    return -1;
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005E7A0) --------------------------------------------------------
int __fastcall sub_5E7A0(int a1, int a2, char a3)
{
  sub_5E424(a1, a2, a3);
  usleep(0x2710u);
  return 0;
}

//----- (0005E7B8) --------------------------------------------------------
bool __fastcall sub_5E7B8(int a1, int a2, char **a3)
{
  char v3; // r3
  _DWORD *v5; // r8
  int v6; // r6
  _DWORD *v7; // r5
  int v8; // r3
  int v9; // r10
  void *v10; // r0
  char *v11; // r8
  int v12; // r5
  int v13; // r6
  _DWORD *v14; // r5
  const char *v15; // r5
  int v17; // [sp+4h] [bp-10E8h]
  char *s; // [sp+40h] [bp-10ACh]
  char *v20; // [sp+44h] [bp-10A8h]
  _DWORD *ptr; // [sp+4Ch] [bp-10A0h]
  int v22; // [sp+54h] [bp-1098h] BYREF
  int v23; // [sp+58h] [bp-1094h] BYREF
  int v24; // [sp+5Ch] [bp-1090h]
  int v25; // [sp+60h] [bp-108Ch]
  int v26; // [sp+64h] [bp-1088h]
  _DWORD v27[7]; // [sp+68h] [bp-1084h] BYREF
  int v28; // [sp+84h] [bp-1068h]
  _DWORD v29[7]; // [sp+88h] [bp-1064h] BYREF
  int v30; // [sp+A4h] [bp-1048h]
  _DWORD v31[7]; // [sp+A8h] [bp-1044h] BYREF
  int v32; // [sp+C4h] [bp-1028h]
  _DWORD v33[7]; // [sp+C8h] [bp-1024h] BYREF
  int v34; // [sp+E4h] [bp-1008h]
  char v35[4100]; // [sp+E8h] [bp-1004h] BYREF

  v3 = 0;
  v22 = 0;
  if ( a2 != -1 && *(_DWORD *)(a1 + 280) >= a2 )
    v3 = *(_BYTE *)(*(_DWORD *)(a1 + 432) + a2);
  v25 = 3932160;
  v24 = 0;
  v23 = 0;
  v26 = 0;
  BYTE1(v25) = v3;
  v5 = calloc(0xCu, 1u);
  (*(void (__fastcall **)(int, int *, int, _DWORD *, int *))(a1 + 236))(a1, &v23, 1, v5, &v22);
  if ( v22 <= 0 )
  {
    v20 = 0;
  }
  else
  {
    v20 = 0;
    v6 = 0;
    v7 = v5;
    do
    {
      while ( 1 )
      {
        ++v6;
        if ( *((_WORD *)v7 + 3) == 60 )
          break;
        v7 += 3;
        if ( v22 <= v6 )
          goto LABEL_9;
      }
      v8 = *v5;
      v7 += 3;
      HIBYTE(v33[0]) = *v5;
      BYTE2(v33[0]) = BYTE1(v8);
      BYTE1(v33[0]) = BYTE2(v8);
      LOBYTE(v33[0]) = HIBYTE(v8);
      v9 = v33[0];
      V_LOCK();
      v20 += v9;
      V_INT((int)v27, "chain", *(int *)(a1 + 200));
      logfmt_raw(
        v35,
        0x1000u,
        0,
        v28,
        v27[0],
        v27[1],
        v27[2],
        v27[3],
        v27[4],
        v27[5],
        v27[6],
        v28,
        "[Top Nonce Cnt] asic %02x, reg %02x cnt %08x",
        *((unsigned __int8 *)v7 - 8),
        *((unsigned __int16 *)v7 - 3),
        v9);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/chip_setting.c",
        150,
        "ChipSetting_nonce_counter_KDA_2110",
        34,
        321,
        20,
        v35);
    }
    while ( v22 > v6 );
  }
LABEL_9:
  v10 = v5;
  v11 = 0;
  free(v10);
  *a3 = v20;
  v12 = *(_DWORD *)(a1 + 284);
  v25 = 655360;
  v26 = 255;
  v23 = 1;
  v24 = 0;
  ptr = calloc(12 * v12, 1u);
  (*(void (__fastcall **)(int, int *, int, _DWORD *, int *, int, int, _DWORD))(a1 + 244))(
    a1,
    &v23,
    v12,
    ptr,
    &v22,
    v17,
    2000,
    0);
  if ( v22 > 0 )
  {
    v13 = 0;
    v14 = ptr;
    s = 0;
    do
    {
      if ( *((_WORD *)v14 + 3) == 10 )
      {
        s += *v14;
        V_LOCK();
        V_INT((int)v29, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v35,
          0x1000u,
          0,
          v30,
          v29[0],
          v29[1],
          v29[2],
          v29[3],
          v29[4],
          v29[5],
          v29[6],
          v30,
          "%s chip %02x, core %02x, reg %02x, core_nonce_cnt %08x",
          "ChipSetting_nonce_counter_KDA_2110",
          *((unsigned __int8 *)v14 + 4),
          *((unsigned __int8 *)v14 + 8),
          *((unsigned __int16 *)v14 + 3),
          *v14);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_nonce_counter_KDA_2110",
          34,
          344,
          20,
          v35);
      }
      else
      {
        V_LOCK();
        V_INT((int)v31, "chain", *(int *)(a1 + 200));
        logfmt_raw(
          v35,
          0x1000u,
          0,
          v32,
          v31[0],
          v31[1],
          v31[2],
          v31[3],
          v31[4],
          v31[5],
          v31[6],
          v32,
          "%s chip %02x, expected reg %02x, but %02x, core_nonce_cnt %08x",
          "ChipSetting_nonce_counter_KDA_2110",
          *((unsigned __int8 *)v14 + 4),
          5,
          *((unsigned __int16 *)v14 + 3),
          *v14);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_nonce_counter_KDA_2110",
          34,
          347,
          100,
          v35);
      }
      ++v13;
      v14 += 3;
    }
    while ( v22 > v13 );
    v11 = s;
  }
  free(ptr);
  V_LOCK();
  V_INT((int)v33, "chain", *(int *)(a1 + 200));
  v15 = "Failed";
  if ( v20 == v11 )
    v15 = "Pass";
  logfmt_raw(
    v35,
    0x1000u,
    0,
    v34,
    v33[0],
    v33[1],
    v33[2],
    v33[3],
    v33[4],
    v33[5],
    v33[6],
    v34,
    "check nonce counter, top_nonce_cnt %d, core_nocne_cnt %d (%s)",
    v20,
    v11,
    v15);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_nonce_counter_KDA_2110",
    34,
    353,
    40,
    v35);
  return v20 != v11;
}
// 5E9F8: variable 'v17' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005EC94) --------------------------------------------------------
int __fastcall sub_5EC94(int a1, int a2, char **a3)
{
  if ( sub_5E7B8(a1, a2, a3) )
    return 19;
  else
    return 0;
}

//----- (0005ECAC) --------------------------------------------------------
int __fastcall sub_5ECAC(int a1)
{
  int v2; // r6
  int v3; // r2
  int v4; // r0
  int v5; // r9
  int *v6; // r5
  int v7; // r0
  int v8; // r12
  int v9; // r2
  int v10; // r3
  int v11; // r2
  int v13; // [sp+4h] [bp-10E0h]
  int v14; // [sp+3Ch] [bp-10A8h]
  int *ptr; // [sp+44h] [bp-10A0h]
  int v16; // [sp+4Ch] [bp-1098h] BYREF
  _DWORD v17[2]; // [sp+50h] [bp-1094h] BYREF
  int v18; // [sp+58h] [bp-108Ch]
  int v19; // [sp+5Ch] [bp-1088h]
  _DWORD v20[7]; // [sp+60h] [bp-1084h] BYREF
  int v21; // [sp+7Ch] [bp-1068h]
  _DWORD v22[7]; // [sp+80h] [bp-1064h] BYREF
  int v23; // [sp+9Ch] [bp-1048h]
  _DWORD v24[7]; // [sp+A0h] [bp-1044h] BYREF
  int v25; // [sp+BCh] [bp-1028h]
  _DWORD v26[7]; // [sp+C0h] [bp-1024h] BYREF
  int v27; // [sp+DCh] [bp-1008h]
  char v28[4100]; // [sp+E0h] [bp-1004h] BYREF

  V_LOCK();
  V_INT((int)v20, "chain", *(int *)(a1 + 200));
  v2 = 0;
  logfmt_raw(
    v28,
    0x1000u,
    0,
    v21,
    v20[0],
    v20[1],
    v20[2],
    v20[3],
    v20[4],
    v20[5],
    v20[6],
    v21,
    "get hash clock count chip_no %d",
    *(_DWORD *)(a1 + 280));
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_hash_clock_count_KDA_2110",
    37,
    692,
    20,
    v28);
  v18 = 393217;
  v17[1] = 0;
  v17[0] = 1;
  v19 = 255;
  if ( (*(int (__fastcall **)(int, _DWORD *))(a1 + 220))(a1, v17) < 0 )
  {
    V_LOCK();
    v14 = -1;
    V_INT((int)v22, "chain", *(int *)(a1 + 200));
    logfmt_raw(
      v28,
      0x1000u,
      0,
      v23,
      v22[0],
      v22[1],
      v22[2],
      v22[3],
      v22[4],
      v22[5],
      v22[6],
      v23,
      "%s failed, set reg:%02x",
      "ChipSetting_hash_clock_count_KDA_2110",
      HIWORD(v18));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_hash_clock_count_KDA_2110",
      37,
      701,
      100,
      v28);
  }
  else
  {
    usleep(0x4E20u);
    v3 = *(_DWORD *)(a1 + 280);
    v4 = *(_DWORD *)(a1 + 284);
    v18 = 458753;
    v5 = v4 * v3;
    LOBYTE(v19) = 0;
    ptr = (int *)calloc(12 * v4 * v3, 1u);
    (*(void (__fastcall **)(int, _DWORD *, int, int *, int *, int, int, _DWORD))(a1 + 244))(
      a1,
      v17,
      v5,
      ptr,
      &v16,
      v13,
      2000,
      0);
    v14 = 0;
    if ( v16 > 0 )
    {
      v6 = ptr;
      do
      {
        v10 = *v6;
        v11 = *((unsigned __int16 *)v6 + 3);
        HIBYTE(v22[0]) = *v6;
        BYTE2(v22[0]) = BYTE1(v10);
        BYTE1(v22[0]) = BYTE2(v10);
        LOBYTE(v22[0]) = HIBYTE(v10);
        if ( v11 == 7 )
        {
          V_LOCK();
          ++v14;
          V_INT((int)v24, "chain", *(int *)(a1 + 200));
          logfmt_raw(
            v28,
            0x1000u,
            0,
            v25,
            v24[0],
            v24[1],
            v24[2],
            v24[3],
            v24[4],
            v24[5],
            v24[6],
            v25,
            "[Hash clk cnt] chip %02x, core %02x, reg %02x, clk_cnt %08x",
            *((unsigned __int8 *)v6 + 4),
            *((unsigned __int8 *)v6 + 8),
            *((unsigned __int16 *)v6 + 3),
            v22[0]);
          V_UNLOCK();
          v7 = g_zc;
          v8 = 40;
          v9 = 720;
        }
        else
        {
          V_LOCK();
          V_INT((int)v26, "chain", *(int *)(a1 + 200));
          logfmt_raw(
            v28,
            0x1000u,
            0,
            v27,
            v26[0],
            v26[1],
            v26[2],
            v26[3],
            v26[4],
            v26[5],
            v26[6],
            v27,
            "[Hash clk cnt] chip %02x, expected reg %02x, but %02x, clk_cnt %08x",
            *((unsigned __int8 *)v6 + 4),
            7,
            *((unsigned __int16 *)v6 + 3),
            v22[0]);
          V_UNLOCK();
          v7 = g_zc;
          v8 = 100;
          v9 = 723;
        }
        ++v2;
        v6 += 3;
        zlog(
          v7,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_hash_clock_count_KDA_2110",
          37,
          v9,
          v8,
          v28);
      }
      while ( v16 > v2 );
    }
    free(ptr);
  }
  return v14;
}
// 5EE08: variable 'v13' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005F05C) --------------------------------------------------------
int __fastcall sub_5F05C(int a1)
{
  if ( *(_DWORD *)(a1 + 284) * *(_DWORD *)(a1 + 280) == sub_5ECAC(a1) )
    return 19;
  else
    return 0;
}

//----- (0005F084) --------------------------------------------------------
int __fastcall sub_5F084(int a1)
{
  int v2; // r6
  int (__fastcall *v3)(int, _DWORD *); // r3
  int v4; // r8
  int v5; // r2
  int v6; // r5
  int v7; // r5
  _WORD *v8; // r5
  int v9; // r0
  int v10; // r12
  int v11; // r2
  int v13; // [sp+3Ch] [bp-1088h]
  _WORD *ptr; // [sp+44h] [bp-1080h]
  int v15; // [sp+48h] [bp-107Ch]
  int v16; // [sp+4Ch] [bp-1078h]
  _DWORD v17[2]; // [sp+50h] [bp-1074h] BYREF
  int v18; // [sp+58h] [bp-106Ch]
  int v19; // [sp+5Ch] [bp-1068h]
  _DWORD v20[7]; // [sp+60h] [bp-1064h] BYREF
  int v21; // [sp+7Ch] [bp-1048h]
  _DWORD v22[7]; // [sp+80h] [bp-1044h] BYREF
  int v23; // [sp+9Ch] [bp-1028h]
  _DWORD v24[7]; // [sp+A0h] [bp-1024h] BYREF
  int v25; // [sp+BCh] [bp-1008h]
  char v26[4100]; // [sp+C0h] [bp-1004h] BYREF

  V_LOCK();
  V_INT((int)v20, "chain", *(int *)(a1 + 200));
  logfmt_raw(
    v26,
    0x1000u,
    0,
    v21,
    v20[0],
    v20[1],
    v20[2],
    v20[3],
    v20[4],
    v20[5],
    v20[6],
    v21,
    "get pmdata chip_no %d",
    *(_DWORD *)(a1 + 280));
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_pmdata_KDA_2110",
    27,
    640,
    20,
    v26);
  v2 = 0;
  v18 = 0;
  v19 = 0;
  v13 = 0;
  v17[1] = 0;
  v3 = *(int (__fastcall **)(int, _DWORD *))(a1 + 220);
  while ( 1 )
  {
    if ( v2 == 3 )
      goto LABEL_12;
    LOBYTE(v18) = 1;
    HIWORD(v18) = 255;
    v17[0] = (16 * v2) | 1;
    LOBYTE(v19) = -1;
    if ( v3(a1, v17) < 0 )
      break;
    v4 = 0;
    usleep(0x4E20u);
    v5 = *(_DWORD *)(a1 + 280);
    v6 = *(_DWORD *)(a1 + 284);
    v18 = 327681;
    v7 = v6 * v5;
    LOBYTE(v19) = 0;
    ptr = calloc(12 * v7, 1u);
    (*(void (__fastcall **)(int, _DWORD *, int))(a1 + 244))(a1, v17, v7);
    if ( v15 > 0 )
    {
      v8 = ptr;
      do
      {
        HIBYTE(v16) = *(_DWORD *)v8;
        BYTE2(v16) = BYTE1(*(_DWORD *)v8);
        BYTE1(v16) = BYTE2(*(_DWORD *)v8);
        LOBYTE(v16) = HIBYTE(*(_DWORD *)v8);
        if ( v8[3] == 5 )
        {
          V_LOCK();
          ++v13;
          V_INT((int)v22, "chain", *(int *)(a1 + 200));
          logfmt_raw(
            v26,
            0x1000u,
            0,
            v23,
            v22[0],
            v22[1],
            v22[2],
            v22[3],
            v22[4],
            v22[5],
            v22[6],
            v23,
            "[PM data] chip %02x, reg %02x mode %d PMDATA %08x",
            *((unsigned __int8 *)v8 + 4),
            (unsigned __int16)v8[3],
            v2,
            v16);
          V_UNLOCK();
          v9 = g_zc;
          v10 = 40;
          v11 = 672;
        }
        else
        {
          V_LOCK();
          V_INT((int)v24, "chain", *(int *)(a1 + 200));
          logfmt_raw(
            v26,
            0x1000u,
            0,
            v25,
            v24[0],
            v24[1],
            v24[2],
            v24[3],
            v24[4],
            v24[5],
            v24[6],
            v25,
            "[PM data] chip %02x, expected reg %02x, but %02x mode %d PMDATA %08x",
            *((unsigned __int8 *)v8 + 4),
            5,
            (unsigned __int16)v8[3],
            v2,
            v16);
          V_UNLOCK();
          v9 = g_zc;
          v10 = 100;
          v11 = 675;
        }
        ++v4;
        v8 += 6;
        zlog(
          v9,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c",
          150,
          "ChipSetting_pmdata_KDA_2110",
          27,
          v11,
          v10,
          v26);
      }
      while ( v15 > v4 );
    }
    if ( v2 == 6 )
    {
      free(ptr);
      return v13;
    }
    v3 = *(int (__fastcall **)(int, _DWORD *))(a1 + 220);
LABEL_12:
    ++v2;
  }
  V_LOCK();
  logfmt_raw(v26, 0x1000u, 0, "%s failed, set reg:%02x", "ChipSetting_pmdata_KDA_2110", HIWORD(v18));
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_pmdata_KDA_2110",
    27,
    653,
    100,
    v26);
  return -1;
}
// 5F210: variable 'v15' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005F438) --------------------------------------------------------
int __fastcall sub_5F438(int a1)
{
  if ( *(_DWORD *)(a1 + 284) * *(_DWORD *)(a1 + 280) == sub_5F084(a1) )
    return 19;
  else
    return 0;
}

//----- (0005F460) --------------------------------------------------------
int __fastcall sub_5F460(int a1, int a2, int a3)
{
  _DWORD v6[2]; // [sp+30h] [bp-1030h] BYREF
  char v7; // [sp+38h] [bp-1028h]
  char v8; // [sp+39h] [bp-1027h]
  __int16 v9; // [sp+3Ah] [bp-1026h]
  int v10; // [sp+3Ch] [bp-1024h]
  _DWORD v11[7]; // [sp+40h] [bp-1020h] BYREF
  int v12; // [sp+5Ch] [bp-1004h]
  char v13[4096]; // [sp+60h] [bp-1000h] BYREF

  v7 = 0;
  v6[0] = (a3 << 16) | 2;
  v9 = 92;
  v10 = 0;
  v6[1] = 0;
  v8 = a2;
  V_LOCK();
  V_INT((int)v11, "chain", *(int *)(a1 + 200));
  logfmt_raw(
    v13,
    0x1000u,
    0,
    v12,
    v11[0],
    v11[1],
    v11[2],
    v11[3],
    v11[4],
    v11[5],
    v11[6],
    v12,
    "set uart relay, chip:%02x, %08x",
    a2,
    v6[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_uart_relay_KDA_2110",
    31,
    767,
    40,
    v13);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v6);
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005F560) --------------------------------------------------------
int __fastcall sub_5F560(int a1, int a2, int a3)
{
  if ( sub_5F460(a1, a2, a3) )
    return 19;
  else
    return 0;
}

//----- (0005F578) --------------------------------------------------------
int __fastcall sub_5F578(int a1, int a2)
{
  int v3; // r5
  _DWORD *v4; // r11
  _DWORD *v5; // r9
  _DWORD *v6; // r6
  int v7; // r3
  int v8; // r4
  int v11; // [sp+48h] [bp-105Ch] BYREF
  int v12; // [sp+4Ch] [bp-1058h]
  _DWORD v13[2]; // [sp+50h] [bp-1054h] BYREF
  int v14; // [sp+58h] [bp-104Ch]
  int v15; // [sp+5Ch] [bp-1048h]
  _DWORD v16[7]; // [sp+60h] [bp-1044h] BYREF
  int v17; // [sp+7Ch] [bp-1028h]
  _DWORD v18[7]; // [sp+80h] [bp-1024h] BYREF
  int v19; // [sp+9Ch] [bp-1008h]
  char v20[4100]; // [sp+A0h] [bp-1004h] BYREF

  v5 = *(_DWORD **)(a1 + 280);
  v3 = 0;
  v14 = 1835009;
  v13[1] = 0;
  v13[0] = 0;
  v15 = 0;
  v11 = 0;
  v4 = calloc(12 * (_DWORD)v5, 1u);
  (*(void (__fastcall **)(int, _DWORD *, _DWORD *, _DWORD *, int *))(a1 + 236))(a1, v13, v5, v4, &v11);
  LOWORD(v5) = (unsigned __int16)&g_zc;
  if ( v11 > 0 )
  {
    HIWORD(v5) = (unsigned int)&g_zc >> 16;
    v6 = v4;
    do
    {
      while ( 1 )
      {
        ++v3;
        if ( *((_WORD *)v6 + 3) == 28 )
          break;
        v6 += 3;
        if ( v11 <= v3 )
          goto LABEL_7;
      }
      V_LOCK();
      v6 += 3;
      V_INT((int)v16, "chain", *(int *)(a1 + 200));
      logfmt_raw(
        v20,
        0x1000u,
        0,
        v17,
        v16[0],
        v16[1],
        v16[2],
        v16[3],
        v16[4],
        v16[5],
        v16[6],
        v17,
        "[MISC CTRL] asic %02x, reg %02x state %08x",
        *((unsigned __int8 *)v6 - 8),
        *((unsigned __int16 *)v6 - 3),
        *(v6 - 3));
      V_UNLOCK();
      zlog(
        *v5,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/chip_setting.c",
        150,
        "ChipSetting_pll_sel_KDA_2110",
        28,
        189,
        20,
        v20);
    }
    while ( v11 > v3 );
  }
  else
  {
    HIWORD(v5) = (unsigned int)&g_zc >> 16;
  }
LABEL_7:
  v7 = *v4;
  HIBYTE(v12) = *v4;
  BYTE2(v12) = BYTE1(v7);
  BYTE1(v12) = BYTE2(v7);
  LOBYTE(v12) = HIBYTE(v7);
  free(v4);
  v14 = 1835009;
  v13[0] = v12 & 0xFFFFFFFB | (4 * (_BYTE)a2) & 4;
  V_LOCK();
  V_INT((int)v18, "chain", *(int *)(a1 + 200));
  logfmt_raw(
    v20,
    0x1000u,
    0,
    v19,
    v18[0],
    v18[1],
    v18[2],
    v18[3],
    v18[4],
    v18[5],
    v18[6],
    v19,
    "set pll sel %u %08x",
    a2,
    v13[0]);
  V_UNLOCK();
  zlog(
    *v5,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_pll_sel_KDA_2110",
    28,
    201,
    40,
    v20);
  v8 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v13);
  usleep(0x2710u);
  return v8;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005F820) --------------------------------------------------------
int __fastcall sub_5F820(int a1, int a2)
{
  if ( sub_5F578(a1, a2) )
    return 19;
  else
    return 0;
}

//----- (0005F838) --------------------------------------------------------
int __fastcall sub_5F838(int a1, int a2)
{
  int v3; // r4
  _DWORD v5[4]; // [sp+28h] [bp-1034h] BYREF
  _DWORD v6[7]; // [sp+38h] [bp-1024h] BYREF
  int v7; // [sp+54h] [bp-1008h]
  char v8[4100]; // [sp+58h] [bp-1004h] BYREF

  v5[0] = a2;
  v5[2] = 2883585;
  v5[3] = 0;
  v5[1] = 0;
  V_LOCK();
  V_INT((int)v6, "chain", *(int *)(a1 + 200));
  logfmt_raw(v8, 0x1000u, 0, v7, v6[0], v6[1], v6[2], v6[3], v6[4], v6[5], v6[6], v7, "set io cfg value %08x", v5[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_io_cfg_KDA_2110",
    27,
    233,
    40,
    v8);
  v3 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v5);
  usleep(0x2710u);
  return v3;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005F93C) --------------------------------------------------------
int __fastcall sub_5F93C(int a1, int a2)
{
  if ( sub_5F838(a1, a2) )
    return 19;
  else
    return 0;
}

//----- (0005F954) --------------------------------------------------------
int __fastcall check_nonce_kda(int a1, int a2)
{
  int v3; // r4
  int v4; // r1
  unsigned int v5; // r6
  int *v6; // r3
  int *p_src; // r2
  int v8; // r1
  char v9; // r1
  char *v10; // r3
  char *v11; // r2
  char v12; // r1
  unsigned int v13; // r0
  unsigned int v14; // r7
  unsigned int v15; // r3
  int v16; // lr
  int *v17; // r4
  char *v18; // r12
  char *v19; // lr
  int v20; // r0
  int v21; // r1
  int v22; // r2
  int v23; // r3
  int v24; // r1
  int v25; // r2
  int v26; // r3
  char v27; // r3
  char *v28; // r2
  char *v29; // r3
  char v30; // r1
  char *v31; // r3
  char *v32; // r2
  unsigned int v33; // r0
  unsigned int v34; // t1
  unsigned int v35; // t1
  bool v36; // cf
  int v38; // [sp+Ch] [bp-1174h]
  int src; // [sp+10h] [bp-1170h] BYREF
  int v40; // [sp+14h] [bp-116Ch] BYREF
  _DWORD v41[7]; // [sp+18h] [bp-1168h] BYREF
  int v42; // [sp+34h] [bp-114Ch] BYREF
  _DWORD v43[7]; // [sp+38h] [bp-1148h] BYREF
  int v44; // [sp+54h] [bp-112Ch] BYREF
  char dest[288]; // [sp+58h] [bp-1128h] BYREF
  _DWORD v46[7]; // [sp+178h] [bp-1008h] BYREF
  int v47; // [sp+194h] [bp-FECh] BYREF
  char v48; // [sp+198h] [bp-FE8h] BYREF
  _BYTE v49[189]; // [sp+11B7h] [bp+37h] BYREF

  v3 = *(_DWORD *)(a1 + 760);
  v4 = *(unsigned __int8 *)(a2 + 89);
  v5 = *(_DWORD *)(v3 + 4 * (v4 + 11552));
  memcpy(dest, (const void *)(v3 + 286 * v4 + 9216), 0x11Eu);
  v6 = (int *)((char *)&v40 + 3);
  p_src = &src;
  v8 = *(_DWORD *)(a2 + 84);
  src = *(_DWORD *)(a2 + 80);
  v40 = v8;
  do
  {
    v9 = *(_BYTE *)p_src;
    *(_BYTE *)p_src = *(_BYTE *)v6;
    p_src = (int *)((char *)p_src + 1);
    *(_BYTE *)v6 = v9;
    v6 = (int *)((char *)v6 - 1);
  }
  while ( p_src < v6 );
  blake2s_init((int *)((unsigned int)v49 & 0xFFFFFFC0), 32);
  blake2s_update((_DWORD *)((unsigned int)v49 & 0xFFFFFFC0), dest, 0x116u);
  blake2s_update((_DWORD *)((unsigned int)v49 & 0xFFFFFFC0), (char *)&src, 8u);
  blake2s_final((unsigned int)v49 & 0xFFFFFFC0, v41, 0x20u);
  v10 = (char *)&v42 + 3;
  v11 = (char *)v41;
  do
  {
    v12 = *v11;
    *v11++ = *v10;
    *v10-- = v12;
  }
  while ( v11 < v10 );
  v13 = target_to_diff_kda(v41);
  v14 = v13;
  if ( v13 <= 0x27 )
  {
    V_LOCK();
    logfmt_raw(
      (char *)v46,
      0x1000u,
      0,
      "hw error calculate diff %d ans diff %d ticket_mask %d",
      v14,
      *(unsigned __int8 *)(a2 + 88),
      40,
      v38,
      src,
      v40);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/backend_kda_2110/backend_kda_2110.c",
      171,
      "check_nonce_kda",
      15,
      553,
      20,
      v46);
    return 2;
  }
  else
  {
    v15 = *(unsigned __int8 *)(a2 + 88);
    if ( v15 == v13 )
    {
      if ( v5 <= v15 )
      {
        v16 = *(unsigned __int8 *)(a2 + 89);
        v43[0] = v41[0];
        v43[1] = v41[1];
        v43[2] = v41[2];
        v43[3] = v41[3];
        v17 = (int *)(v3 + 32 * (v16 + 1460));
        v18 = (char *)&v44 + 3;
        v19 = (char *)v43;
        v43[4] = v41[4];
        v43[5] = v41[5];
        v43[6] = v41[6];
        v44 = v42;
        v20 = *v17;
        v21 = v17[1];
        v22 = v17[2];
        v23 = v17[3];
        v17 += 4;
        v46[0] = v20;
        v46[1] = v21;
        v46[2] = v22;
        v46[3] = v23;
        v24 = v17[1];
        v25 = v17[2];
        v26 = v17[3];
        v46[4] = *v17;
        v46[5] = v24;
        v46[6] = v25;
        v47 = v26;
        do
        {
          v27 = *v19;
          *v19++ = *v18;
          *v18-- = v27;
        }
        while ( v19 < v18 );
        v28 = (char *)&v47 + 3;
        v29 = (char *)v46;
        do
        {
          v30 = *v29;
          *v29++ = *v28;
          *v28-- = v30;
        }
        while ( v29 < v28 );
        v31 = dest;
        v32 = &v48;
        while ( 1 )
        {
          v34 = *((_DWORD *)v31 - 1);
          v31 -= 4;
          v33 = v34;
          v35 = *((_DWORD *)v32 - 1);
          v32 -= 4;
          v36 = v33 >= v35;
          if ( v33 > v35 )
            break;
          if ( !v36 || v31 == (char *)v43 )
            return 0;
        }
      }
      V_LOCK();
      logfmt_raw((char *)v46, 0x1000u, 0, "diff not enough (%d<%d) not reach pool", *(unsigned __int8 *)(a2 + 88), v5);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/backend_kda_2110/backend_kda_2110.c",
        171,
        "check_nonce_kda",
        15,
        567,
        20,
        v46);
      return 1;
    }
    else
    {
      V_LOCK();
      logfmt_raw(
        (char *)v46,
        0x1000u,
        0,
        "diff not match (%d!=%d) expected diff %d",
        v14,
        *(unsigned __int8 *)(a2 + 88),
        v5,
        v38,
        src,
        v40);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/backend_kda_2110/backend_kda_2110.c",
        171,
        "check_nonce_kda",
        15,
        562,
        20,
        v46);
      return 3;
    }
  }
}
// 5FBC4: variable 'v38' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0005FCA0) --------------------------------------------------------
int __fastcall sub_5FCA0(int *a1, int a2)
{
  const char *v2; // r4
  void *v5; // r0
  void (__fastcall *v6)(int *, _DWORD *, int, void *, int *, int, int, _DWORD); // lr
  unsigned __int16 *v7; // r6
  unsigned int v8; // r9
  int v9; // r1
  int v10; // r0
  unsigned int v11; // r1
  unsigned int v12; // r0
  int v13; // r9
  int v14; // r2
  int **v15; // r12
  int result; // r0
  unsigned __int8 *v17; // r8
  char *v18; // r4
  int v19; // r6
  int v20; // r9
  int v22; // r2
  int *v23; // [sp+0h] [bp-160Ch] BYREF
  int v24; // [sp+4h] [bp-1608h]
  const char *v25; // [sp+8h] [bp-1604h]
  const char *v26; // [sp+54h] [bp-15B8h]
  const char *v27; // [sp+58h] [bp-15B4h]
  const char *v28; // [sp+5Ch] [bp-15B0h]
  int v29; // [sp+60h] [bp-15ACh]
  void *ptr; // [sp+64h] [bp-15A8h]
  int v31; // [sp+68h] [bp-15A4h]
  int **v32; // [sp+6Ch] [bp-15A0h]
  int v33; // [sp+74h] [bp-1598h] BYREF
  _DWORD v34[4]; // [sp+78h] [bp-1594h] BYREF
  _DWORD v35[7]; // [sp+88h] [bp-1584h] BYREF
  int v36; // [sp+A4h] [bp-1568h]
  _BYTE v37[32]; // [sp+A8h] [bp-1564h] BYREF
  _DWORD v38[7]; // [sp+C8h] [bp-1544h] BYREF
  int v39; // [sp+E4h] [bp-1528h]
  _DWORD v40[8]; // [sp+E8h] [bp-1524h] BYREF
  _BYTE s[256]; // [sp+108h] [bp-1504h] BYREF
  char v42[1024]; // [sp+208h] [bp-1404h] BYREF
  char v43[4100]; // [sp+608h] [bp-1004h] BYREF

  v2 = 0;
  v33 = 0;
  memset(s, 0, sizeof(s));
  V_LOCK();
  logfmt_raw(v43, 0x1000u, 0, "%s chip_no %d", "ChipSetting_get_addr_KDA_2110", a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_get_addr_KDA_2110",
    29,
    32,
    20,
    v43);
  v31 = a2;
  v34[0] = 0;
  v34[2] = 1;
  v34[1] = 0;
  v34[3] = 0;
  v5 = calloc(12 * a2, 1u);
  v23 = &v33;
  v6 = (void (__fastcall *)(int *, _DWORD *, int, void *, int *, int, int, _DWORD))a1[59];
  ptr = v5;
  v6(a1, v34, a2, v5, &v33, v24, 3000, 0);
  V_LOCK();
  V_INT((int)v35, "chain", a1[50]);
  logfmt_raw(
    v43,
    0x1000u,
    0,
    v36,
    v35[0],
    v35[1],
    v35[2],
    v35[3],
    v35[4],
    v35[5],
    v35[6],
    v36,
    "%s detect %d chips",
    "ChipSetting_get_addr_KDA_2110",
    v33,
    a1[68]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_get_addr_KDA_2110",
    29,
    43,
    60,
    v43);
  if ( v33 > 0 )
  {
    v26 = "ChipSetting_get_addr_KDA_2110";
    v29 = 0;
    v28 = "[GET ADDR] chip_type %04x/%04x chip %d reg %d addr %02x";
    v27 = "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/chip_setting.c";
    v7 = (unsigned __int16 *)ptr;
    do
    {
      while ( 1 )
      {
        v8 = *v7;
        V_LOCK();
        v9 = *((unsigned __int8 *)v7 + 4);
        LOWORD(v8) = __rev16(v8);
        v10 = v7[3];
        v24 = a1[68];
        v25 = v2++;
        logfmt_raw(v43, 0x1000u, 0, v28, (unsigned __int16)v8, v24, v25, v10, v9);
        V_UNLOCK();
        zlog(g_zc, v27, 150, v26, 29, 47, 20, v43);
        if ( a1[68] == (unsigned __int16)v8 )
          break;
        v7 += 6;
        if ( v33 <= (int)v2 )
          goto LABEL_7;
      }
      v7 += 6;
      v11 = a1[93];
      v12 = *((unsigned __int8 *)v7 - 8);
      ++v29;
      v13 = v12 / v11;
      s[v13] = 1;
      V_LOCK();
      v14 = a1[50];
      v32 = (int **)v37;
      V_INT((int)v37, "chain", v14);
      v15 = v32;
      v32 = &v23;
      logfmt_raw(
        v43,
        0x1000u,
        0,
        v15[7],
        *v15,
        v15[1],
        v15[2],
        v15[3],
        v15[4],
        v15[5],
        v15[6],
        v15[7],
        "chip_id:%d, %03d",
        v13,
        *((unsigned __int8 *)v7 - 8));
      V_UNLOCK();
      zlog(g_zc, v27, 150, v26, 29, 53, 20, v43);
    }
    while ( v33 > (int)v2 );
LABEL_7:
    v2 = (const char *)v29;
  }
  else
  {
    v29 = 0;
  }
  if ( a1[70] > v29 )
  {
    V_LOCK();
    V_INT((int)v38, "chain", a1[50]);
    V_STR(v40, "error", "asic num error");
    logfmt_raw(
      v43,
      0x1000u,
      0,
      v39,
      v38[0],
      v38[1],
      v38[2],
      v38[3],
      v38[4],
      v38[5],
      v38[6],
      v39,
      v40[0],
      v40[1],
      v40[2],
      v40[3],
      v40[4],
      v40[5],
      v40[6],
      v40[7],
      "detected asic num less than design(%d<%d)",
      v29,
      a1[70]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_get_addr_KDA_2110",
      29,
      59,
      100,
      v43);
    memset(v42, 0, sizeof(v42));
    v42[0] = 10;
    if ( v31 )
    {
      v26 = v2;
      v17 = s;
      v18 = v42;
      v19 = 0;
      v20 = v31;
      do
      {
        while ( *v17++ )
        {
          if ( v20 == ++v19 )
            goto LABEL_15;
        }
        v22 = v19++;
        sprintf(v18, "%02d ", v22);
        v18 += 3;
      }
      while ( v20 != v19 );
LABEL_15:
      v2 = v26;
    }
    V_LOCK();
    logfmt_raw(v43, 0x1000u, 0, "bad asic:\n%s\n", v42);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_get_addr_KDA_2110",
      29,
      69,
      40,
      v43);
  }
  free(ptr);
  result = v33;
  a1[92] = (int)v2;
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (000601C0) --------------------------------------------------------
int __fastcall sub_601C0(int *a1)
{
  int v2; // r4

  v2 = a1[70];
  sub_5FCA0(a1, v2);
  if ( v2 == a1[92] )
    return 0;
  else
    return 12;
}

//----- (000601E8) --------------------------------------------------------
int __fastcall parameter_update_kda(int a1, char a2, int a3, char a4, int a5)
{
  int v8; // r1
  int result; // r0
  int v10; // r3
  int v11; // r7
  double v12; // r0

  if ( *(_BYTE *)(a1 + 204) )
    return 0;
  if ( (unsigned int)(a3 - 50) <= 0x28A )
    v8 = a2 & 1;
  else
    v8 = 0;
  if ( v8 )
  {
    v11 = a1 + 928;
    LODWORD(v12) = sub_DD46C(*(_QWORD *)(a1 + 920));
    *(_QWORD *)(v11 - 8) = (unsigned __int64)(v12 / (double)a3 * *(float *)(a1 + 900));
    *(float *)(a1 + 900) = (float)a3;
  }
  result = 0;
  if ( (unsigned int)(a5 - 1400) <= 0x12C )
    v10 = a4 & 1;
  else
    v10 = 0;
  if ( v10 )
    *(_DWORD *)(a1 + 904) = a5;
  return result;
}
// 60270: variable 'v12' is possibly undefined

//----- (00060298) --------------------------------------------------------
int __fastcall sub_60298(int a1, int a2, int a3, _BYTE *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7)
{
  int v7; // r11
  int v11; // r8
  int v12; // r3
  int v14; // lr
  _DWORD *v15; // r7
  char v16; // r3
  char v17; // r3
  signed int v18; // r0
  signed int v19; // r8
  unsigned int v20; // r1
  int v21; // r11
  int v22; // r4
  int v23; // r2
  int v25; // r0
  _DWORD v26[7]; // [sp+30h] [bp-1024h] BYREF
  int v27; // [sp+4Ch] [bp-1008h]
  char v28[4080]; // [sp+50h] [bp-1004h] BYREF

  v7 = *(_DWORD *)(a1 + 760);
  v11 = *(_BYTE *)(a2 + 9) & 0x7F;
  v12 = *(_DWORD *)(v7 + 8 * v11);
  v14 = *(_DWORD *)(v7 + 8 * v11 + 4);
  v15 = (_DWORD *)(a3 + 80);
  *(_DWORD *)a3 = v12;
  *(_DWORD *)(a3 + 4) = v14;
  *a7 = v12;
  strcpy((char *)(a3 + 16), (const char *)(v7 + ((v11 + 16) << 6)));
  *(_DWORD *)(a3 + 80) = *(_DWORD *)(a2 + 3);
  *(_BYTE *)(a3 + 84) = *(_BYTE *)(a2 + 7);
  v16 = *(_BYTE *)(v7 + 3 * v11 + 45826);
  *(_WORD *)(a3 + 85) = *(_WORD *)(v7 + 3 * v11 + 45824);
  *(_BYTE *)(a3 + 87) = v16;
  v17 = *(_BYTE *)(a2 + 8);
  *(_BYTE *)(a3 + 89) = v11;
  *(_BYTE *)(a3 + 88) = v17;
  v18 = (unsigned int)*(unsigned __int8 *)(a2 + 3) / *(_DWORD *)(a1 + 372);
  v19 = v18;
  if ( v18 >= *(_DWORD *)(a1 + 280) )
  {
    v25 = rand();
    sub_DD144(v25, *(_DWORD *)(a1 + 280));
    *a6 = v20;
  }
  else
  {
    v20 = (unsigned int)*(unsigned __int8 *)(a2 + 3) / *(_DWORD *)(a1 + 372);
    *a6 = v18;
  }
  *(_DWORD *)(a3 + 8) = v20;
  *(_DWORD *)(a3 + 12) = (*(_BYTE *)(a2 + 7) & 3)
                       + 4 * ((unsigned __int8)(*(_BYTE *)(a2 + 6) << 6) | (*(unsigned __int8 *)(a2 + 7) >> 2));
  v21 = BM_CRC5((_BYTE *)(a2 + 2), 67);
  v22 = *(_BYTE *)(a2 + 10) & 0x1F;
  if ( v21 != v22 && *(_BYTE *)(a1 + 206) )
  {
    V_LOCK();
    V_INT((int)v26, "chain", *(int *)(a1 + 200));
    logfmt_raw(
      v28,
      0x1000u,
      0,
      v27,
      v26[0],
      v26[1],
      v26[2],
      v26[3],
      v26[4],
      v26[5],
      v26[6],
      v27,
      "chip id %2d, get nonce crc error calc value %04x expected value %04x\n",
      v19,
      v21,
      v22);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/backend_kda_2110/backend_kda_2110.c",
      171,
      "packet_2_nonce_kda",
      18,
      220,
      40,
      v28);
    return 11;
  }
  else
  {
    v23 = v15[1];
    *a5 = *v15;
    a5[1] = v23;
    *a4 = 1;
    return 0;
  }
}
// 60368: variable 'v20' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (000604B8) --------------------------------------------------------
int __fastcall packet_2_nonce_kda(int a1, int a2, int a3, _BYTE *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7)
{
  if ( *(char *)(a2 + 10) < 0 )
    return sub_60298(a1, a2, a3, a4, a5, a6, a7);
  else
    return 10;
}

//----- (000604D0) --------------------------------------------------------
int __fastcall sub_604D0(char *a1, _DWORD *a2, _DWORD *a3, int a4)
{
  char v4; // r7
  int result; // r0
  int v10; // r3
  int v11; // r2
  char v12; // [sp+17h] [bp-1005h] BYREF
  char v13[4100]; // [sp+18h] [bp-1004h] BYREF

  v4 = a4;
  *a3 = 0;
  *a2 = -64;
  if ( pic1704_write_iic(*a1, a4) )
  {
    usleep(0x2710u);
    result = pic1704_read_iic(*a1, v4, &v12);
    if ( result )
    {
      v10 = v12;
      *a3 = 1;
      *a2 = v10;
      return result;
    }
    V_LOCK();
    logfmt_raw(v13, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)a1, a4);
    V_UNLOCK();
    v11 = 930;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v13, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)a1, a4);
    V_UNLOCK();
    v11 = 919;
  }
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_read_sensor_temp_local_on_pic_KDA_2110",
    50,
    v11,
    20,
    v13);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00060618) --------------------------------------------------------
int __fastcall sub_60618(char *a1, _DWORD *a2, _DWORD *a3, int a4)
{
  char v4; // r7
  int result; // r0
  int v10; // r3
  int v11; // r2
  char v12; // [sp+17h] [bp-1005h] BYREF
  char v13[4100]; // [sp+18h] [bp-1004h] BYREF

  v4 = a4;
  *a3 = 0;
  *a2 = -64;
  if ( pic1704_write_iic(*a1, a4) )
  {
    usleep(0x2710u);
    result = pic1704_read_iic(*a1, v4, &v12);
    if ( result )
    {
      v10 = v12;
      *a3 = 1;
      *a2 = v10 + 15;
      return result;
    }
    V_LOCK();
    logfmt_raw(v13, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)a1, a4);
    V_UNLOCK();
    v11 = 956;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v13, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)a1, a4);
    V_UNLOCK();
    v11 = 945;
  }
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_read_sensor_temp_remote_on_pic_KDA_2110",
    51,
    v11,
    20,
    v13);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00060764) --------------------------------------------------------
int __fastcall sub_60764(unsigned int *a1, _DWORD *a2, _DWORD *a3, int a4)
{
  int v8; // r3
  int v10; // [sp+34h] [bp-1030h]
  _BYTE v11[4]; // [sp+3Ch] [bp-1028h] BYREF
  _DWORD v12[7]; // [sp+40h] [bp-1024h] BYREF
  int v13; // [sp+5Ch] [bp-1008h]
  char v14[4100]; // [sp+60h] [bp-1004h] BYREF

  V_LOCK();
  logfmt_raw(
    v14,
    0x1000u,
    0,
    "%s chain[%d] iic_addr:%d",
    "ChipSetting_read_sensor_temp_local_on_ctrlboard_KDA_2110",
    *a1,
    a4);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_read_sensor_temp_local_on_ctrlboard_KDA_2110",
    56,
    970,
    20,
    v14);
  *a3 = 0;
  v10 = tsensor_read(*a1, a4, 0, (int)v11, 2u);
  if ( v10 == 2 )
  {
    v8 = v11[0];
    *a3 = 1;
    *a2 = v8;
    V_LOCK();
    V_INT((int)v12, "chain", (int)*a1);
    logfmt_raw(
      v14,
      0x1000u,
      0,
      v13,
      v12[0],
      v12[1],
      v12[2],
      v12[3],
      v12[4],
      v12[5],
      v12[6],
      v13,
      "read ctrlboard temp, local[%02x] %d",
      a4,
      *a2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_read_sensor_temp_local_on_ctrlboard_KDA_2110",
      56,
      982,
      20,
      v14);
  }
  else
  {
    *a2 = -64;
    v10 = -1;
    V_LOCK();
    logfmt_raw(v14, 0x1000u, 0, "failed to read ctrlboard-temp for chain %d", *a1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_read_sensor_temp_local_on_ctrlboard_KDA_2110",
      56,
      977,
      80,
      v14);
  }
  return v10;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00060948) --------------------------------------------------------
int __fastcall sub_60948(unsigned int *a1, unsigned __int8 *a2, _DWORD *a3, _DWORD *a4, unsigned __int8 a5)
{
  int result; // r0
  int v10; // r3
  _BYTE v11[4]; // [sp+14h] [bp-1004h] BYREF
  char v12[4072]; // [sp+18h] [bp-1000h] BYREF

  *a4 = 0;
  result = tsensor_read(*a1, a5, 0, (int)v11, 2u);
  if ( result == 2 )
  {
    v10 = v11[0];
    *a4 = 1;
    *a3 = v10 + *a2;
  }
  else
  {
    *a3 = -64;
    V_LOCK();
    logfmt_raw(v12, 0x1000u, 0, "failed to read ctrlboard-temp for chain %d", *a1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_setting.c",
      150,
      "ChipSetting_read_sensor_temp_remote_on_ctrlboard_KDA_2110",
      57,
      996,
      80,
      v12);
    return -1;
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00060A3C) --------------------------------------------------------
int __fastcall softreset_all_chip_kda(int *a1)
{
  void (__fastcall *v2)(int *, _DWORD *); // r3
  _DWORD v4[2]; // [sp+0h] [bp-14h] BYREF
  int v5; // [sp+8h] [bp-Ch]
  int v6; // [sp+Ch] [bp-8h]

  sub_5CFFC((int)a1);
  usleep((__useconds_t)"rl_kda_2110");
  v5 = 0;
  v6 = 0;
  v2 = (void (__fastcall *)(int *, _DWORD *))a1[55];
  LOBYTE(v5) = 1;
  HIWORD(v5) = 8;
  LOBYTE(v6) = -1;
  v4[1] = 0;
  v4[0] = 0;
  v2(a1, v4);
  sub_5D124(a1, 255);
  return 0;
}

//----- (00060AAC) --------------------------------------------------------
int __fastcall sub_60AAC(_DWORD *a1, int a2, int a3, _DWORD *a4, _DWORD *a5)
{
  char v5; // r8
  int (__fastcall *v9)(_DWORD *, int *); // r3
  signed int v11; // r2
  unsigned __int8 *v12; // r0
  unsigned __int8 *v13; // r4
  void (__fastcall *v14)(_DWORD *, int *, signed int, unsigned __int8 *, int *); // r5
  int v15; // r5
  signed int v16; // [sp+14h] [bp-20h]
  int v17; // [sp+1Ch] [bp-18h] BYREF
  int v18; // [sp+20h] [bp-14h] BYREF
  int v19; // [sp+24h] [bp-10h]
  int v20; // [sp+28h] [bp-Ch]
  int v21; // [sp+2Ch] [bp-8h]

  v5 = a2;
  v20 = 0;
  v19 = 0;
  v21 = 0;
  v18 = a3 | 0x1980000;
  BYTE1(v20) = a2;
  v9 = (int (__fastcall *)(_DWORD *, int *))a1[54];
  HIWORD(v20) = 255;
  if ( v9(a1, &v18) )
    return 0;
  usleep(0xC350u);
  *a4 = 0;
  v19 = 0;
  *a5 = 0;
  v11 = a1[70];
  v20 = 0;
  v21 = 0;
  v18 = 0;
  if ( v11 >= 1 )
    v11 = 1;
  v16 = v11;
  v12 = (unsigned __int8 *)calloc(v11, 0xCu);
  BYTE1(v20) = v5;
  v13 = v12;
  v14 = (void (__fastcall *)(_DWORD *, int *, signed int, unsigned __int8 *, int *))a1[59];
  HIWORD(v20) = 255;
  v14(a1, &v18, v16, v12, &v17);
  v15 = v17;
  if ( v17 == 1 && a2 == v13[4] )
  {
    *a4 = *(_DWORD *)v13;
    *a5 = 1;
  }
  free(v13);
  return v15;
}

//----- (00060BC0) --------------------------------------------------------
int __fastcall read_sensor_temp_remote_kda(int a1, int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int v13; // r0
  int v14; // r1
  int v15; // r3
  int v16; // r2
  int v17; // [sp+8h] [bp-8h] BYREF
  int v18; // [sp+Ch] [bp-4h] BYREF

  if ( a6 )
  {
    if ( a6 == 1 )
    {
      v14 = *(unsigned __int8 *)(*(_DWORD *)(a1 + 432) + a9);
      *a3 = 0;
      *a2 = -64;
      v13 = sub_60AAC((_DWORD *)a1, v14, 256, &v17, &v18);
      if ( v13 == 1 )
      {
        v15 = HIBYTE(v17);
        v16 = v18;
        if ( *(_DWORD *)(a1 + 456) == 1 )
          v15 = HIBYTE(v17) - 64;
        *a2 = v15;
        *a3 = v16;
        return 0;
      }
    }
    else
    {
      if ( a6 != 2 )
        return 4;
      v13 = sub_60948((unsigned int *)(a1 + 200), (unsigned __int8 *)(a1 + 912), a2, a3, a9);
    }
  }
  else
  {
    v13 = sub_60618((char *)(a1 + 200), a2, a3, a9);
  }
  if ( v13 == -1 )
    return 4;
  return 0;
}

//----- (00060CA4) --------------------------------------------------------
int __fastcall read_sensor_temp_local_kda(
        _DWORD *a1,
        int *a2,
        _DWORD *a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9)
{
  int v11; // r0
  int v14; // r1
  int v15; // r3
  int v16; // r2
  int v17; // [sp+8h] [bp-8h] BYREF
  int v18; // [sp+Ch] [bp-4h] BYREF

  if ( a6 )
  {
    if ( a6 == 1 )
    {
      v14 = *(unsigned __int8 *)(a1[108] + a9);
      *a3 = 0;
      *a2 = -64;
      v11 = sub_60AAC(a1, v14, 0, &v17, &v18);
      if ( v11 == 1 )
      {
        v15 = HIBYTE(v17);
        v16 = v18;
        if ( a1[114] == 1 )
          v15 = HIBYTE(v17) - 64;
        *a2 = v15;
        *a3 = v16;
        return 0;
      }
    }
    else
    {
      if ( a6 != 2 )
        return 4;
      v11 = sub_60764(a1 + 50, a2, a3, a9);
    }
  }
  else
  {
    v11 = sub_604D0((char *)a1 + 200, a2, a3, a9);
  }
  if ( v11 == -1 )
    return 4;
  return 0;
}

//----- (00060D74) --------------------------------------------------------
int __fastcall set_baud_kda_2110_0(int a1, int a2)
{
  int v4; // r4
  int v5; // r4
  _DWORD v7[4]; // [sp+30h] [bp-1034h] BYREF
  _DWORD v8[7]; // [sp+40h] [bp-1024h] BYREF
  int v9; // [sp+5Ch] [bp-1008h]
  char v10[4100]; // [sp+60h] [bp-1004h] BYREF

  v7[2] = 6291457;
  v7[1] = 0;
  v7[3] = 0;
  v7[0] = 0;
  if ( a2 == 1500000 )
    goto LABEL_24;
  if ( a2 <= 1500000 )
  {
    if ( a2 == 460800 )
    {
      v4 = 1568;
      goto LABEL_10;
    }
    if ( a2 > 460800 )
    {
      if ( a2 == 921600 || a2 == 1041666 )
      {
        v4 = 544;
        goto LABEL_10;
      }
    }
    else if ( a2 == 38400 )
    {
      v4 = 20512;
      goto LABEL_10;
    }
    goto LABEL_16;
  }
  if ( a2 == 3125000 )
  {
LABEL_23:
    v4 = 32;
    goto LABEL_10;
  }
  if ( a2 <= 3125000 )
  {
    if ( a2 != 1562500 )
    {
      if ( a2 != 3000000 )
        goto LABEL_16;
      goto LABEL_23;
    }
LABEL_24:
    v4 = 288;
    goto LABEL_10;
  }
  if ( a2 == 6250000 )
  {
    v4 = 289;
    goto LABEL_9;
  }
  if ( a2 != 12500000 )
  {
LABEL_16:
    v4 = 6688;
    goto LABEL_10;
  }
  v4 = 33;
LABEL_9:
  (*(void (__fastcall **)(int, int))(a1 + 176))(a1, 1);
LABEL_10:
  v7[0] = v4;
  V_LOCK();
  V_INT((int)v8, "chain", *(int *)(a1 + 200));
  logfmt_raw(
    v10,
    0x1000u,
    0,
    v9,
    v8[0],
    v8[1],
    v8[2],
    v8[3],
    v8[4],
    v8[5],
    v8[6],
    v9,
    "set fuart cfg value %08x/%d",
    v4,
    a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_fuart_cfg_KDA_2110",
    30,
    421,
    40,
    v10);
  v5 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v7);
  usleep(0x2710u);
  return v5;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00060F70) --------------------------------------------------------
int __fastcall dhash_start_kda(int a1)
{
  int v2; // r3
  int result; // r0
  _DWORD v4[4]; // [sp+28h] [bp-1054h] BYREF
  _DWORD v5[7]; // [sp+38h] [bp-1044h] BYREF
  int v6; // [sp+54h] [bp-1028h]
  _DWORD v7[7]; // [sp+58h] [bp-1024h] BYREF
  int v8; // [sp+74h] [bp-1008h]
  char v9[4100]; // [sp+78h] [bp-1004h] BYREF

  V_LOCK();
  V_INT((int)v5, "chain", *(int *)(a1 + 200));
  logfmt_raw(v9, 0x1000u, 0, v6, v5[0], v5[1], v5[2], v5[3], v5[4], v5[5], v5[6], v6, "dhash_start_kda");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/backend_kda_2110/backend_kda_2110.c",
    171,
    "dhash_start_kda",
    15,
    426,
    40,
    v9);
  v4[2] = 5505025;
  v4[1] = 0;
  v4[0] = 4;
  v4[3] = 0;
  V_LOCK();
  V_INT((int)v7, "chain", *(int *)(a1 + 200));
  logfmt_raw(v9, 0x1000u, 0, v8, v7[0], v7[1], v7[2], v7[3], v7[4], v7[5], v7[6], v8, "set nonce len value %08x", 4);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_nonce_len_KDA_2110",
    30,
    217,
    40,
    v9);
  (*(void (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v4);
  usleep(0x2710u);
  v2 = *(unsigned __int8 *)(a1 + 404);
  result = 0;
  *(_BYTE *)(a1 + 205) = 1;
  if ( !v2 )
    *(_DWORD *)(a1 + 408) = (int)*(float *)(a1 + 900);
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00061110) --------------------------------------------------------
int __fastcall top_init_kda(int a1)
{
  int v2; // r9
  int v3; // r4
  int v4; // r0
  int v5; // r1
  char v6; // r3
  void (__fastcall *v7)(int, int, int); // r3
  _DWORD v9[4]; // [sp+30h] [bp-1054h] BYREF
  _DWORD v10[7]; // [sp+40h] [bp-1044h] BYREF
  int v11; // [sp+5Ch] [bp-1028h]
  _DWORD v12[7]; // [sp+60h] [bp-1024h] BYREF
  int v13; // [sp+7Ch] [bp-1008h]
  char v14[4100]; // [sp+80h] [bp-1004h] BYREF

  V_LOCK();
  V_INT((int)v10, "chain", *(int *)(a1 + 200));
  logfmt_raw(v14, 0x1000u, 0, v11, v10[0], v10[1], v10[2], v10[3], v10[4], v10[5], v10[6], v11, "top_init_kda");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/backend_kda_2110/backend_kda_2110.c",
    171,
    "top_init_kda",
    12,
    407,
    40,
    v14);
  v2 = *(_DWORD *)(a1 + 280);
  v3 = *(_DWORD *)(a1 + 432);
  v4 = sub_DCEB0(256, (unsigned __int8)v2);
  if ( (_BYTE)v2 )
  {
    v5 = v3 - 1;
    v6 = 0;
    do
    {
      *(_BYTE *)++v5 = v6;
      v6 += v4;
    }
    while ( v5 != v3 - 1 + (unsigned __int8)v2 );
    v3 = *(_DWORD *)(a1 + 432);
  }
  v7 = *(void (__fastcall **)(int, int, int))(a1 + 208);
  *(_DWORD *)(a1 + 372) = v4;
  v7(a1, v3, v2);
  sub_5DBB8(a1, 0);
  v9[0] = 5381904;
  v9[2] = 1835009;
  v9[1] = 0;
  v9[3] = 0;
  V_LOCK();
  V_INT((int)v12, "chain", *(int *)(a1 + 200));
  logfmt_raw(
    v14,
    0x1000u,
    0,
    v13,
    v12[0],
    v12[1],
    v12[2],
    v12[3],
    v12[4],
    v12[5],
    v12[6],
    v13,
    "set misc ctrl %08x",
    v9[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_setting.c",
    150,
    "ChipSetting_misc_ctrl_KDA_2110",
    30,
    167,
    40,
    v14);
  (*(void (__fastcall **)(int, _DWORD *))(a1 + 216))(a1, v9);
  usleep(0x2710u);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00061310) --------------------------------------------------------
int get_pcba_test_level_kda()
{
  return 0;
}

//----- (00061318) --------------------------------------------------------
int __fastcall makeup_chip_addr_kda(_BYTE *a1, unsigned int a2)
{
  int result; // r0
  _BYTE *v5; // r2
  char v6; // r3

  result = sub_DCEB0(256, a2);
  if ( a2 )
  {
    v5 = a1;
    v6 = 0;
    do
    {
      *v5++ = v6;
      v6 += result;
    }
    while ( &a1[a2] != v5 );
  }
  return result;
}

//----- (0006135C) --------------------------------------------------------
int get_algo_type_kda()
{
  return 0;
}

//----- (00061364) --------------------------------------------------------
int update_chip_info_kda()
{
  return 0;
}

//----- (0006136C) --------------------------------------------------------
void *runtime_ctrl_kda_2110()
{
  void *v0; // r0
  void *v1; // r5
  _QWORD v3[117]; // [sp+0h] [bp-3ACh] BYREF

  memset(v3, 0, sizeof(v3));
  LODWORD(v3[31]) = 3359051;
  HIDWORD(v3[39]) = 210;
  LODWORD(v3[40]) = 500;
  LODWORD(v3[33]) = 6382699;
  HIDWORD(v3[41]) = sensor_info_kda_2110;
  v3[42] = qword_106574;
  v3[43] = qword_10657C;
  v3[44] = qword_106584;
  v0 = calloc(1u, 0x3A8u);
  LODWORD(v3[0]) = backend_init_base;
  HIDWORD(v3[0]) = reset_base;
  HIDWORD(v3[1]) = dhash_mining_stop_base;
  HIDWORD(v3[2]) = backend_exit_base;
  LODWORD(v3[3]) = push_work_base;
  LODWORD(v3[1]) = dhash_mining_start_base;
  LODWORD(v3[2]) = dhash_mining_reset_base;
  LODWORD(v3[4]) = pop_ans_base;
  LODWORD(v3[6]) = softreset_all_chip_kda;
  LODWORD(v3[7]) = work_2_packet_kda;
  HIDWORD(v3[3]) = async_push_work_base;
  HIDWORD(v3[4]) = try_pop_ans_base;
  LODWORD(v3[8]) = check_nonce_kda;
  LODWORD(v3[9]) = global_idx_free_kda;
  HIDWORD(v3[9]) = set_baud_kda_2110;
  HIDWORD(v3[7]) = packet_2_nonce_kda;
  HIDWORD(v3[8]) = global_idx_init_kda;
  HIDWORD(v3[10]) = sub_5F820;
  HIDWORD(v3[11]) = sub_5F560;
  LODWORD(v3[12]) = sub_5F438;
  LODWORD(v3[10]) = sub_5F93C;
  LODWORD(v3[11]) = sub_5DCAC;
  LODWORD(v3[13]) = sub_5EC94;
  LODWORD(v3[14]) = sub_5E3FC;
  HIDWORD(v3[14]) = get_chip_status_kda;
  HIDWORD(v3[12]) = sub_5F05C;
  HIDWORD(v3[13]) = sub_5E7A0;
  HIDWORD(v3[15]) = get_sale_hashrate_kda;
  HIDWORD(v3[16]) = get_qualify_nonce_num_kda;
  LODWORD(v3[17]) = set_sensor_extern_mode_kda;
  LODWORD(v3[15]) = get_theory_hashrate_kda;
  LODWORD(v3[16]) = get_qualify_hashrate_kda;
  HIDWORD(v3[17]) = read_sensor_temp_local_kda;
  LODWORD(v3[18]) = read_sensor_temp_remote_kda;
  HIDWORD(v3[18]) = parameter_update_kda;
  LODWORD(v3[19]) = overclock_update_kda;
  HIDWORD(v3[19]) = get_pcba_test_level_kda;
  LODWORD(v3[20]) = get_packet_remain_len_kda;
  LODWORD(v3[22]) = set_frequency_kda_2110;
  HIDWORD(v3[22]) = sub_601C0;
  LODWORD(v3[23]) = sub_5DCC4;
  HIDWORD(v3[23]) = top_init_kda;
  LODWORD(v3[24]) = dhash_start_kda;
  LODWORD(v3[26]) = set_chipaddr_base;
  HIDWORD(v3[26]) = set_inactive_base;
  LODWORD(v3[27]) = set_chip_reg_base;
  HIDWORD(v3[27]) = set_core_reg_base_9;
  LODWORD(v3[28]) = set_core_reg_base_9;
  LODWORD(v3[29]) = sync_get_status_base;
  HIDWORD(v3[29]) = sync_get_chip_reg_base;
  HIDWORD(v3[30]) = sync_get_core_reg_base3;
  v3[35] = 0xF00000005CLL;
  HIDWORD(v3[28]) = set_core_enable_base;
  v3[36] = 0x4000003B8LL;
  HIDWORD(v3[37]) = 2;
  HIDWORD(v3[46]) = 2;
  v3[34] = 0x100002110LL;
  LODWORD(v3[47]) = 40;
  v3[96] = 0x800000060LL;
  v3[97] = 0xB00000124LL;
  HIDWORD(v3[95]) = 400;
  v1 = v0;
  LOBYTE(v3[114]) = 10;
  v3[115] = 11671;
  v3[112] = 0x4420000042480000LL;
  LODWORD(v3[113]) = 1520;
  memcpy(v0, v3, 0x3A8u);
  return v1;
}
// 60F6C: using guessed type int set_baud_kda_2110();
// 106570: using guessed type _UNKNOWN *sensor_info_kda_2110;
// 106574: using guessed type __int64;
// 10657C: using guessed type __int64;
// 106584: using guessed type __int64;

//----- (00061708) --------------------------------------------------------
int __fastcall sub_61708(unsigned int a1)
{
  float v1; // s0
  double v2; // d8
  char s[2048]; // [sp+10h] [bp-1804h] BYREF
  char v5[4100]; // [sp+810h] [bp-1004h] BYREF

  v2 = (double)a1 * 3.3 / (float)(v1 * 1024.0);
  snprintf(s, 0x800u, "v_an2 = %f", v2);
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/drv_pic/pic_1704.c",
    165,
    "decode_an_voltage_buf",
    21,
    407,
    20,
    v5);
  snprintf(s, 0x800u, "v_10 = %f", v2 * 7.5999999);
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, s);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-o"
           "rigin_godminer-new/backend/device/hal/drv_pic/pic_1704.c",
           165,
           "decode_an_voltage_buf",
           21,
           410,
           20,
           v5);
}
// 61724: variable 'v1' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0006183C) --------------------------------------------------------
int __fastcall sub_6183C(int a1, int a2, int a3, unsigned __int8 *a4)
{
  int v5; // r0
  int v7; // lr
  __int16 v8; // r3
  char v9; // r2
  __int16 v10; // r3
  int v11; // r1
  unsigned __int8 *v12; // r2
  int v13; // r1
  unsigned __int8 *v14; // r12
  char v15; // t1
  int v16; // r0
  int v17; // r2
  int v18; // r3
  int v20; // r6
  int v21; // r0
  int v22; // r2
  char v23; // [sp+10h] [bp-1824h]
  int v24; // [sp+18h] [bp-181Ch]
  char v27[2048]; // [sp+30h] [bp-1804h] BYREF
  char v28[4100]; // [sp+830h] [bp-1004h] BYREF

  v5 = BYTE1(a1);
  v7 = BYTE1(a1) + 4;
  v8 = (unsigned __int8)(BYTE1(a1) + 4);
  *(_BYTE *)(a3 + 3) = a1;
  v9 = v8 + a1;
  *(_BYTE *)(a3 + 2) = v8;
  v10 = v8 + (unsigned __int8)a1;
  *(_WORD *)a3 = -21931;
  if ( a2 )
  {
    if ( v5 )
    {
      v12 = (unsigned __int8 *)(a2 - 1);
      v13 = a3 + 3;
      v14 = (unsigned __int8 *)(a2 + (unsigned __int8)(v5 - 1));
      do
      {
        v15 = *++v12;
        *(_BYTE *)++v13 = v15;
        v10 += *v12;
      }
      while ( v12 != v14 );
      v11 = v5 + 5;
    }
    else
    {
      v11 = 5;
      v7 = 4;
    }
    *(_BYTE *)(a3 + v7) = HIBYTE(v10);
    *(_BYTE *)(a3 + v11) = v10;
  }
  else
  {
    *(_BYTE *)(a3 + 5) = v9;
    *(_BYTE *)(a3 + 4) = HIBYTE(v10);
  }
  v24 = (unsigned __int8)(v5 + 6);
  v23 = 4;
  while ( 1 )
  {
    pthread_mutex_lock(&i2c_mutex_all);
    iic_write(g_bitmain_pic_state[2 * HIBYTE(a1)], a3, v24);
    usleep(0x2710u);
    iic_read(g_bitmain_pic_state[2 * HIBYTE(a1)], a4, BYTE2(a1));
    pthread_mutex_unlock(&i2c_mutex_all);
    if ( BYTE2(a1) == 2 )
      break;
    if ( BYTE2(a1) > 2u )
    {
      if ( __PAIR64__(a4[1], *a4) == __PAIR64__((unsigned __int8)a1, BYTE2(a1)) )
      {
        snprintf(v27, 0x800u, "PICCMD %d passed on Chain[%d]!", (unsigned __int8)a1, HIBYTE(a1));
        V_LOCK();
        v20 = 1;
        logfmt_raw(v28, 0x1000u, 0, v27);
        V_UNLOCK();
        v21 = g_zc;
        v22 = 111;
        goto LABEL_23;
      }
      snprintf(v27, 0x800u, "PICCMD %d failed on Chain[%d]!", (unsigned __int8)a1, HIBYTE(a1));
      V_LOCK();
      logfmt_raw(v28, 0x1000u, 0, v27);
      V_UNLOCK();
      v16 = g_zc;
      v17 = 116;
      goto LABEL_15;
    }
    snprintf(v27, 0x800u, "ret_len = %d should never happen!!", BYTE2(a1));
    V_LOCK();
    logfmt_raw(v28, 0x1000u, 0, v27);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/drv_pic/pic_1704.c",
      165,
      "pic_process_cmd",
      15,
      121,
      20,
      v28);
LABEL_16:
    v18 = (unsigned __int8)(v23 - 1);
    v23 = v18;
    if ( !v18 )
      return 0;
  }
  if ( *a4 != (unsigned __int8)a1 || a4[1] != 1 )
  {
    snprintf(v27, 0x800u, "PICCMD %d failed on Chain[%d]!", (unsigned __int8)a1, HIBYTE(a1));
    V_LOCK();
    logfmt_raw(v28, 0x1000u, 0, v27);
    V_UNLOCK();
    v16 = g_zc;
    v17 = 103;
LABEL_15:
    zlog(
      v16,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/drv_pic/pic_1704.c",
      165,
      "pic_process_cmd",
      15,
      v17,
      20,
      v28);
    sleep(1u);
    goto LABEL_16;
  }
  v20 = 1;
  snprintf(v27, 0x800u, "PICCMD %d passed on Chain[%d]!", (unsigned __int8)a1, HIBYTE(a1));
  V_LOCK();
  logfmt_raw(v28, 0x1000u, 0, v27);
  V_UNLOCK();
  v21 = g_zc;
  v22 = 98;
LABEL_23:
  zlog(
    v21,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/drv_pic/pic_1704.c",
    165,
    "pic_process_cmd",
    15,
    v22,
    20,
    v28);
  return v20;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1197E4: using guessed type pthread_mutex_t i2c_mutex_all;
// 11A7AC: using guessed type int g_zc;
// 11B3D8: using guessed type _DWORD g_bitmain_pic_state[32];

//----- (00061BC4) --------------------------------------------------------
char __fastcall set_pic_device_high(char result)
{
  byte_1197FC = result;
  return result;
}
// 1197FC: using guessed type char byte_1197FC;

//----- (00061BD4) --------------------------------------------------------
int __fastcall pic1704_get_sw_version(char a1, _BYTE *a2)
{
  int result; // r0
  int v4; // [sp+0h] [bp-18h] BYREF
  char v5; // [sp+4h] [bp-14h]
  int v6; // [sp+8h] [bp-10h] BYREF
  __int16 v7; // [sp+Ch] [bp-Ch]
  int v8; // [sp+10h] [bp-8h]
  int v9; // [sp+14h] [bp-4h]

  BYTE2(v8) = 5;
  LOWORD(v8) = 23;
  HIBYTE(v8) = a1;
  v9 = 0;
  *a2 = -1;
  v4 = 255;
  v6 = 0;
  v7 = 0;
  v5 = 0;
  result = sub_6183C(v8, v9, (int)&v6, (unsigned __int8 *)&v4);
  if ( result )
    *a2 = BYTE2(v4);
  return result;
}

//----- (00061C40) --------------------------------------------------------
int __fastcall pic1704_jump_to_app(char a1)
{
  __int16 v2; // [sp+4h] [bp-18h] BYREF
  int v3; // [sp+8h] [bp-14h] BYREF
  __int16 v4; // [sp+Ch] [bp-10h]
  int v5; // [sp+10h] [bp-Ch]
  int v6; // [sp+14h] [bp-8h]

  v6 = 0;
  v3 = 0;
  v4 = 0;
  LOWORD(v5) = 6;
  HIBYTE(v5) = a1;
  BYTE2(v5) = 2;
  v2 = 255;
  return sub_6183C(v5, 0, (int)&v3, (unsigned __int8 *)&v2);
}

//----- (00061C94) --------------------------------------------------------
int __fastcall pic1704_reset(char a1)
{
  __int16 v2; // [sp+4h] [bp-18h] BYREF
  int v3; // [sp+8h] [bp-14h] BYREF
  __int16 v4; // [sp+Ch] [bp-10h]
  int v5; // [sp+10h] [bp-Ch]
  int v6; // [sp+14h] [bp-8h]

  v6 = 0;
  v3 = 0;
  v4 = 0;
  LOWORD(v5) = 7;
  HIBYTE(v5) = a1;
  BYTE2(v5) = 2;
  v2 = 255;
  return sub_6183C(v5, 0, (int)&v3, (unsigned __int8 *)&v2);
}

//----- (00061CE8) --------------------------------------------------------
int __fastcall pic1704_enable_disable_dc_dc(char a1, char a2)
{
  _BYTE v3[5]; // [sp+7h] [bp-19h] BYREF
  __int16 v4; // [sp+Ch] [bp-14h] BYREF
  _DWORD v5[2]; // [sp+10h] [bp-10h] BYREF
  int v6; // [sp+18h] [bp-8h]
  _BYTE *v7; // [sp+1Ch] [bp-4h]

  v3[0] = a2;
  v7 = v3;
  LOWORD(v6) = 277;
  HIBYTE(v6) = a1;
  BYTE2(v6) = 2;
  v5[0] = 0;
  *(_DWORD *)((char *)v5 + 3) = 0;
  v4 = 255;
  return sub_6183C(v6, (int)v3, (int)v5, (unsigned __int8 *)&v4);
}

//----- (00061D44) --------------------------------------------------------
int __fastcall pic1704_erase_program(char a1)
{
  __int16 v2; // [sp+4h] [bp-18h] BYREF
  int v3; // [sp+8h] [bp-14h] BYREF
  __int16 v4; // [sp+Ch] [bp-10h]
  int v5; // [sp+10h] [bp-Ch]
  int v6; // [sp+14h] [bp-8h]

  v6 = 0;
  v3 = 0;
  v4 = 0;
  LOWORD(v5) = 9;
  HIBYTE(v5) = a1;
  BYTE2(v5) = 2;
  v2 = 255;
  return sub_6183C(v5, 0, (int)&v3, (unsigned __int8 *)&v2);
}

//----- (00061D98) --------------------------------------------------------
int __fastcall pic1704_heart_beat(char a1)
{
  int v2; // [sp+0h] [bp-1Ch] BYREF
  __int16 v3; // [sp+4h] [bp-18h]
  int v4; // [sp+8h] [bp-14h] BYREF
  __int16 v5; // [sp+Ch] [bp-10h]
  int v6; // [sp+10h] [bp-Ch]
  int v7; // [sp+14h] [bp-8h]

  BYTE2(v6) = 6;
  LOWORD(v6) = 22;
  HIBYTE(v6) = a1;
  v7 = 0;
  v4 = 255;
  v2 = 0;
  v3 = 0;
  v5 = 0;
  return sub_6183C(v6, 0, (int)&v2, (unsigned __int8 *)&v4);
}

//----- (00061DF0) --------------------------------------------------------
int __fastcall pic1704_update_app_program(int a1)
{
  FILE *v2; // r6
  char *v3; // r10
  char *v4; // r5
  unsigned int v5; // r0
  int v6; // r9
  int v7; // r7
  int v8; // r2
  char *v9; // r3
  int v10; // r0
  int v11; // r1
  int v12; // r2
  int v13; // r3
  int v15; // r2
  unsigned __int8 v16[4]; // [sp+14h] [bp-1820h] BYREF
  char s[8]; // [sp+18h] [bp-181Ch] BYREF
  int v18; // [sp+20h] [bp-1814h] BYREF
  int v19; // [sp+24h] [bp-1810h]
  int v20; // [sp+28h] [bp-180Ch]
  int v21; // [sp+2Ch] [bp-1808h]
  int v22[512]; // [sp+30h] [bp-1804h] BYREF
  char v23[20]; // [sp+830h] [bp-1004h] BYREF
  __int16 v24; // [sp+844h] [bp-FF0h]

  *(_DWORD *)s = 0;
  v18 = 0;
  *(_DWORD *)&s[3] = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v2 = (FILE *)fopen64("/etc/config/dsPIC33EP16GS202_app.txt", "r");
  if ( !v2 )
  {
    snprintf(
      (char *)v22,
      0x800u,
      "%s open DSPIC33EP16GS202_PIC_PROGRAM failed chain[%d]!",
      "pic1704_update_app_program",
      a1);
    V_LOCK();
    logfmt_raw(v23, 0x1000u, 0, v22);
    V_UNLOCK();
    v6 = -1;
    v15 = 274;
    goto LABEL_19;
  }
  v3 = (char *)calloc(0x3700u, 1u);
  if ( !v3 )
  {
    snprintf((char *)v22, 0x800u, "%s malloc failed chain[%d]!", "pic1704_update_app_program", a1);
    V_LOCK();
    logfmt_raw(v23, 0x1000u, 0, v22);
    V_UNLOCK();
    v6 = -1;
    v15 = 281;
LABEL_19:
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/drv_pic/pic_1704.c",
      165,
      "pic1704_update_app_program",
      26,
      v15,
      20,
      v23);
    return v6;
  }
  v4 = v3;
  fseek(v2, 0, 0);
  do
  {
    v4 += 4;
    fgets(s, 7, v2);
    v5 = strtoul(s, 0, 16);
    *(v4 - 1) = v5;
    *(v4 - 4) = HIBYTE(v5);
    *(v4 - 3) = BYTE2(v5);
    *(v4 - 2) = BYTE1(v5);
  }
  while ( v4 != v3 + 14080 );
  fclose(v2);
  v6 = pic1704_reset(a1);
  if ( v6 )
  {
    v6 = pic1704_erase_program(a1);
    if ( v6 )
    {
      v7 = 0;
      do
      {
        v9 = &v3[16 * v7];
        v22[1] = (int)&v18;
        v10 = *(_DWORD *)v9;
        v11 = *((_DWORD *)v9 + 1);
        v12 = *((_DWORD *)v9 + 2);
        v13 = *((_DWORD *)v9 + 3);
        ++v7;
        HIBYTE(v22[0]) = a1;
        LOWORD(v22[0]) = 4098;
        v18 = v10;
        v19 = v11;
        v20 = v12;
        v21 = v13;
        BYTE2(v22[0]) = 2;
        v16[1] = 0;
        memset(v23, 0, sizeof(v23));
        v24 = 0;
        v16[0] = -1;
        if ( !sub_6183C(v22[0], (int)&v18, (int)v23, v16) )
        {
          v6 = 0;
          snprintf((char *)v22, 0x800u, "%s send data to pic error chain[%d]!", "pic1704_update_app_program", a1);
          V_LOCK();
          logfmt_raw(v23, 0x1000u, 0, v22);
          V_UNLOCK();
          v8 = 335;
          goto LABEL_12;
        }
      }
      while ( v7 != 880 );
      v6 = pic1704_reset(a1);
      if ( v6 )
      {
        v6 = 1;
        free(v3);
        return v6;
      }
      snprintf((char *)v22, 0x800u, "%s reset error after program chain[%d]!", "pic1704_update_app_program", a1);
      V_LOCK();
      logfmt_raw(v23, 0x1000u, 0, v22);
      V_UNLOCK();
      v8 = 345;
    }
    else
    {
      snprintf((char *)v22, 0x800u, "%s erase pic error chain[%d]!", "pic1704_update_app_program", a1);
      V_LOCK();
      logfmt_raw(v23, 0x1000u, 0, v22);
      V_UNLOCK();
      v8 = 315;
    }
  }
  else
  {
    snprintf((char *)v22, 0x800u, "%s reset pic error chain[%d]!", "pic1704_update_app_program", a1);
    V_LOCK();
    logfmt_raw(v23, 0x1000u, 0, v22);
    V_UNLOCK();
    v8 = 306;
  }
LABEL_12:
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/drv_pic/pic_1704.c",
    165,
    "pic1704_update_app_program",
    26,
    v8,
    20,
    v23);
  free(v3);
  return v6;
}
// 1EA0C: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (000621C0) --------------------------------------------------------
int __fastcall pic1704_set_voltage(char a1, unsigned __int8 a2)
{
  __int16 v3; // [sp+4h] [bp-1Ch] BYREF
  __int16 v4; // [sp+8h] [bp-18h] BYREF
  char v5; // [sp+Ah] [bp-16h]
  int v6; // [sp+Ch] [bp-14h]
  __int16 *v7; // [sp+10h] [bp-10h]
  _DWORD v8[2]; // [sp+14h] [bp-Ch] BYREF
  char v9; // [sp+1Ch] [bp-4h]

  HIBYTE(v6) = a1;
  LOWORD(v6) = 784;
  BYTE2(v6) = 2;
  v4 = a2;
  v7 = &v4;
  v8[0] = 0;
  v5 = 0;
  v8[1] = 0;
  v9 = 0;
  v3 = 255;
  return sub_6183C(v6, (int)&v4, (int)v8, (unsigned __int8 *)&v3);
}

//----- (00062228) --------------------------------------------------------
int __fastcall pic1704_get_single_voltage(char a1, _DWORD *a2)
{
  int v2; // r4
  int result; // r0
  int v5; // r1
  int v6; // r3
  int v7; // r0
  unsigned __int8 *i; // r2
  __int16 v9; // t1
  unsigned __int16 v10; // r8
  int v11; // r3
  int v12; // [sp+10h] [bp-181Ch] BYREF
  __int16 v13; // [sp+14h] [bp-1818h]
  unsigned __int8 v14[8]; // [sp+18h] [bp-1814h] BYREF
  int v15; // [sp+20h] [bp-180Ch]
  int v16; // [sp+24h] [bp-1808h]
  char v17[2040]; // [sp+28h] [bp-1804h] BYREF
  char v18[4100]; // [sp+828h] [bp-1004h] BYREF

  LOWORD(v2) = 0;
  BYTE2(v15) = 7;
  LOWORD(v15) = 58;
  *(_DWORD *)v14 = 255;
  HIBYTE(v15) = a1;
  v16 = 0;
  v12 = 0;
  *(_DWORD *)&v14[3] = 0;
  v13 = 0;
  result = sub_6183C(v15, 0, (int)&v12, v14);
  if ( result )
  {
    v5 = v14[2];
    v6 = v14[0];
    v7 = v14[1];
    if ( v14[2] == 1 && v14[0] > 3u )
    {
      for ( i = &v14[3]; ; ++i )
      {
        v2 = (unsigned __int16)(v2 + v6);
        LOWORD(v6) = v7;
        if ( i == &v14[v14[0]] )
          break;
        LOWORD(v7) = v5;
        v9 = *i;
        LOWORD(v5) = v9;
      }
      v10 = __rev16(*(unsigned __int16 *)&v14[v14[0] - 2]);
      snprintf(v17, 0x800u, "sum1,sum2 = %d,%d", v2, v10);
      V_LOCK();
      logfmt_raw(v18, 0x1000u, 0, v17);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/drv_pic/pic_1704.c",
        165,
        "check_pic_crc",
        13,
        397,
        20,
        v18);
      if ( v2 == v10 )
      {
        v11 = (unsigned __int16)__rev16(*(unsigned __int16 *)&v14[3]);
        *a2 = (unsigned __int16)v11;
        snprintf(v17, 0x800u, "Received one voltage response: vol = %d.", v11);
        V_LOCK();
        logfmt_raw(v18, 0x1000u, 0, v17);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/device/hal/drv_pic/pic_1704.c",
          165,
          "pic1704_get_single_voltage",
          26,
          484,
          20,
          v18);
        return 1;
      }
      v6 = v14[0];
      v5 = v14[2];
      v7 = v14[1];
    }
    snprintf(v17, 0x800u, "ret_buff error: buff0 = %d, buff1 = %d, buff2 = %d.", v6, v7, v5);
    V_LOCK();
    logfmt_raw(v18, 0x1000u, 0, v17);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/drv_pic/pic_1704.c",
      165,
      "pic1704_get_single_voltage",
      26,
      480,
      20,
      v18);
    return 1;
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0006248C) --------------------------------------------------------
int __fastcall pic1704_get_an_voltage1(char a1)
{
  int result; // r0
  unsigned int v2; // [sp+4h] [bp-8h] BYREF

  v2 = 0;
  result = pic1704_get_single_voltage(a1, &v2);
  if ( (_BYTE)result )
    return sub_61708(v2);
  return result;
}

//----- (000624D8) --------------------------------------------------------
int __fastcall pic1704_get_all_voltage(char a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  int result; // r0
  unsigned __int16 v8; // r3
  unsigned __int16 v9; // r12
  int v10; // [sp+10h] [bp-1818h] BYREF
  int v11; // [sp+14h] [bp-1814h]
  int v12; // [sp+18h] [bp-1810h]
  _DWORD v13[3]; // [sp+1Ch] [bp-180Ch] BYREF
  char s[2040]; // [sp+28h] [bp-1800h] BYREF
  char v15[4096]; // [sp+828h] [bp-1000h] BYREF

  HIBYTE(v11) = a1;
  BYTE2(v11) = 11;
  v12 = 0;
  LOWORD(v11) = 55;
  v13[0] = 255;
  v13[1] = 0;
  v10 = 0;
  *(_DWORD *)((char *)&v13[1] + 3) = 0;
  result = sub_6183C(v11, 0, (int)&v10, (unsigned __int8 *)v13);
  if ( result )
  {
    v8 = __rev16(*(unsigned __int16 *)((char *)&v13[1] + 1));
    v9 = __rev16(*(unsigned __int16 *)((char *)&v13[1] + 3));
    *a2 = (unsigned __int16)__rev16(*(unsigned __int16 *)((char *)v13 + 3));
    *a3 = v8;
    *a4 = v9;
    snprintf(s, 0x800u, "Received all voltage response: vol0 = %d, vol1 = %d, vol2 = %d.", *a2, *a3, v9);
    V_LOCK();
    logfmt_raw(v15, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/drv_pic/pic_1704.c",
      165,
      "pic1704_get_all_voltage",
      23,
      511,
      20,
      v15);
    return 1;
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00062610) --------------------------------------------------------
int __fastcall pic1704_get_an_voltage2(char a1, int a2)
{
  float v2; // s0
  float v3; // s1
  int result; // r0
  double v6; // d9
  unsigned int v7; // [sp+2Ch] [bp-180Ch] BYREF
  unsigned int v8; // [sp+30h] [bp-1808h] BYREF
  unsigned int v9; // [sp+34h] [bp-1804h] BYREF
  char s[2040]; // [sp+38h] [bp-1800h] BYREF
  char v11[4096]; // [sp+838h] [bp-1000h] BYREF

  v7 = 0;
  v8 = 0;
  v9 = 0;
  result = pic1704_get_all_voltage(a1, &v7, &v8, &v9);
  if ( (_BYTE)result )
  {
    strcpy(s, "Received an voltage response.");
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/drv_pic/pic_1704.c",
      165,
      "pic1704_get_an_voltage2",
      23,
      442,
      20,
      v11);
    snprintf(
      s,
      0x800u,
      "an0 = %f, an2 %f, an6 %f.",
      (double)v7 * 3.3 * 0.0009765625,
      (double)v8 * 3.3 * 0.0009765625,
      (double)v9 * 3.3 * 0.0009765625);
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/drv_pic/pic_1704.c",
      165,
      "pic1704_get_an_voltage2",
      23,
      443,
      20,
      v11);
    if ( a2 && ((v6 = (double)v9 * 3.3 * 0.0009765625, v2 > v6) || v3 < v6) )
    {
      strcpy(s, "Ref an vol too high or too low.");
      V_LOCK();
      logfmt_raw(v11, 0x1000u, 0, s);
      V_UNLOCK();
      return zlog(
               g_zc,
               "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godmin"
               "er-origin_godminer-new/backend/device/hal/drv_pic/pic_1704.c",
               165,
               "pic1704_get_an_voltage2",
               23,
               449,
               20,
               v11);
    }
    else
    {
      return sub_61708(v8);
    }
  }
  return result;
}
// 627BC: variable 'v2' is possibly undefined
// 627E0: variable 'v3' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (000628C4) --------------------------------------------------------
int __fastcall pic1704_voltage_clamp_ctrl(char a1, char a2)
{
  _BYTE v3[5]; // [sp+7h] [bp-19h] BYREF
  __int16 v4; // [sp+Ch] [bp-14h] BYREF
  _DWORD v5[2]; // [sp+10h] [bp-10h] BYREF
  int v6; // [sp+18h] [bp-8h]
  _BYTE *v7; // [sp+1Ch] [bp-4h]

  v3[0] = a2;
  v7 = v3;
  LOWORD(v6) = 305;
  HIBYTE(v6) = a1;
  BYTE2(v6) = 2;
  v5[0] = 0;
  *(_DWORD *)((char *)v5 + 3) = 0;
  v4 = 255;
  return sub_6183C(v6, (int)v3, (int)v5, (unsigned __int8 *)&v4);
}

//----- (00062920) --------------------------------------------------------
int __fastcall pic1704_get_PDCx(char a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  int result; // r0
  unsigned __int16 v8; // r2
  unsigned __int16 v9; // r3
  int v10; // [sp+4h] [bp-1Ch] BYREF
  __int16 v11; // [sp+8h] [bp-18h]
  int v12; // [sp+Ch] [bp-14h]
  int v13; // [sp+10h] [bp-10h]
  _BYTE v14[9]; // [sp+14h] [bp-Ch] BYREF

  HIBYTE(v12) = a1;
  v13 = 0;
  LOWORD(v12) = 43;
  BYTE2(v12) = 9;
  *(_DWORD *)v14 = 255;
  v10 = 0;
  v11 = 0;
  *(_DWORD *)&v14[4] = 0;
  v14[8] = 0;
  result = sub_6183C(v12, 0, (int)&v10, v14);
  if ( result )
  {
    v8 = __rev16(*(unsigned __int16 *)&v14[5]);
    v9 = __rev16(*(unsigned __int16 *)&v14[7]);
    *a2 = (unsigned __int16)__rev16(*(unsigned __int16 *)&v14[3]);
    *a3 = v8;
    *a4 = v9;
    return 1;
  }
  return result;
}

//----- (000629C4) --------------------------------------------------------
int __fastcall pic1704_get_raw_crab_voltage(char a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  int result; // r0
  unsigned int v9; // r3
  unsigned __int16 v10; // r2
  unsigned __int16 v11; // r1
  int v12; // [sp+0h] [bp-20h] BYREF
  __int16 v13; // [sp+4h] [bp-1Ch]
  int v14; // [sp+8h] [bp-18h]
  int v15; // [sp+Ch] [bp-14h]
  _BYTE v16[12]; // [sp+10h] [bp-10h] BYREF
  char v17; // [sp+1Ch] [bp-4h]

  HIBYTE(v14) = a1;
  v15 = 0;
  LOWORD(v14) = 40;
  BYTE2(v14) = 13;
  *(_DWORD *)v16 = 255;
  v12 = 0;
  v13 = 0;
  *(_DWORD *)&v16[4] = 0;
  *(_DWORD *)&v16[8] = 0;
  v17 = 0;
  result = sub_6183C(v14, 0, (int)&v12, v16);
  if ( result )
  {
    v9 = *(unsigned __int16 *)&v16[9];
    v10 = __rev16(*(unsigned __int16 *)&v16[7]);
    v11 = __rev16(*(unsigned __int16 *)&v16[5]);
    *a2 = (unsigned __int16)__rev16(*(unsigned __int16 *)&v16[3]);
    *a3 = v11;
    *a4 = v10;
    *a5 = (unsigned __int16)__rev16(v9);
    return 1;
  }
  return result;
}

//----- (00062A80) --------------------------------------------------------
int __fastcall pic1704_write_iic(char a1, char a2)
{
  __int16 v3; // [sp+0h] [bp-18h] BYREF
  _BYTE v4[4]; // [sp+4h] [bp-14h] BYREF
  int v5; // [sp+8h] [bp-10h]
  _BYTE *v6; // [sp+Ch] [bp-Ch]
  _DWORD v7[2]; // [sp+10h] [bp-8h] BYREF

  v6 = v4;
  LOWORD(v5) = 571;
  BYTE2(v5) = 2;
  v4[0] = a2;
  HIBYTE(v5) = a1;
  v7[0] = 0;
  v4[1] = 0;
  v7[1] = 0;
  v3 = 255;
  return sub_6183C(v5, (int)v4, (int)v7, (unsigned __int8 *)&v3);
}

//----- (00062AE0) --------------------------------------------------------
int __fastcall pic1704_read_iic(char a1, char a2, _BYTE *a3)
{
  int result; // r0
  unsigned int v5; // r3
  _BYTE v6[4]; // [sp+4h] [bp-20h] BYREF
  _DWORD v7[2]; // [sp+8h] [bp-1Ch] BYREF
  _BYTE v8[7]; // [sp+10h] [bp-14h] BYREF
  int v9; // [sp+18h] [bp-Ch]
  _BYTE *v10; // [sp+1Ch] [bp-8h]

  v6[0] = a2;
  v10 = v6;
  LOWORD(v9) = 572;
  BYTE2(v9) = 7;
  HIBYTE(v9) = a1;
  *(_DWORD *)v8 = 255;
  v7[0] = 0;
  *(_DWORD *)&v8[3] = 0;
  *(_DWORD *)((char *)v7 + 3) = 0;
  v6[1] = 2;
  result = sub_6183C(v9, (int)v6, (int)v7, v8);
  if ( result )
  {
    result = v8[2];
    v5 = v8[0] + v8[1] + v8[2] + v8[3] + v8[4];
    if ( v8[5] == v5 >> 8 && v8[6] == (unsigned __int8)v5 && v8[2] == 1 )
      *a3 = v8[3];
    else
      return 0;
  }
  return result;
}

//----- (00062BA8) --------------------------------------------------------
int __fastcall pic1704_write_flash(char a1, const void *a2, char a3, size_t a4)
{
  void *v8; // r7
  _BYTE *v9; // r4
  int v10; // r5
  int v12; // [sp+0h] [bp-10h] BYREF
  char v13; // [sp+4h] [bp-Ch]
  int v14; // [sp+8h] [bp-8h]
  _BYTE *v15; // [sp+Ch] [bp-4h]

  v12 = 255;
  v13 = 0;
  v8 = malloc(a4 + 8);
  v9 = malloc(a4 + 2);
  v9[1] = a4;
  *v9 = a3;
  memcpy(v9 + 2, a2, a4);
  BYTE2(v14) = 5;
  BYTE1(v14) = a4 + 2;
  v15 = v9;
  HIBYTE(v14) = a1;
  LOBYTE(v14) = 51;
  v10 = sub_6183C(v14, (int)v9, (int)v8, (unsigned __int8 *)&v12);
  free(v9);
  free(v8);
  return v10;
}

//----- (00062C5C) --------------------------------------------------------
int __fastcall pic1704_read_flash(char a1, void *a2, char a3, size_t a4)
{
  unsigned __int8 *v7; // r6
  int v8; // lr
  unsigned int v9; // r1
  unsigned __int8 *v10; // r2
  __int16 v11; // t1
  unsigned int v12; // r3
  unsigned __int8 *v13; // r0
  int v14; // r4
  _BYTE v16[4]; // [sp+4h] [bp-18h] BYREF
  int v17; // [sp+8h] [bp-14h]
  _BYTE *v18; // [sp+Ch] [bp-10h]
  _DWORD v19[3]; // [sp+10h] [bp-Ch] BYREF

  v19[1] = 0;
  v19[0] = 0;
  v18 = v16;
  LOWORD(v17) = 564;
  BYTE2(v17) = a4 + 5;
  HIBYTE(v17) = a1;
  v7 = (unsigned __int8 *)malloc(a4 + 5);
  v16[0] = a3;
  v16[1] = a4;
  v8 = sub_6183C(v17, (int)v16, (int)v19, v7);
  if ( !v8 )
    goto LABEL_8;
  if ( a4 == -3 )
  {
    v12 = 0;
    v13 = v7;
    LOBYTE(v9) = 0;
  }
  else
  {
    LOWORD(v9) = 0;
    v10 = v7 - 1;
    do
    {
      v11 = *++v10;
      v9 = (unsigned __int16)(v9 + v11);
    }
    while ( &v7[a4 + 2] != v10 );
    v12 = v9 >> 8;
    v13 = &v7[a4 + 3];
  }
  if ( *v13 == v12 && v7[a4 + 4] == (unsigned __int8)v9 )
  {
    v14 = v8;
    memcpy(a2, v7 + 3, a4);
  }
  else
  {
LABEL_8:
    v14 = 0;
  }
  free(v7);
  return v14;
}

//----- (00062D64) --------------------------------------------------------
int __fastcall open_pic(int a1)
{
  int v1; // r6
  int v4; // [sp+0h] [bp-Ch] BYREF
  __int16 v5; // [sp+4h] [bp-8h]
  char v6; // [sp+6h] [bp-6h]
  char v7; // [sp+7h] [bp-5h]

  v1 = g_bitmain_pic_state[2 * a1];
  if ( !v1 || !g_bitmain_pic_state[2 * a1 + 1] )
  {
    v4 = a1;
    v5 = 0;
    v6 = byte_1197FC;
    v7 = a1;
    pthread_mutex_lock(&i2c_mutex_all);
    v1 = iic_init((int)&v4);
    pthread_mutex_unlock(&i2c_mutex_all);
    if ( v1 >= 0 )
    {
      g_bitmain_pic_state[2 * a1] = v1;
      g_bitmain_pic_state[2 * a1 + 1] = 1;
    }
  }
  return v1;
}
// 1197E4: using guessed type pthread_mutex_t i2c_mutex_all;
// 1197FC: using guessed type char byte_1197FC;
// 11B3D8: using guessed type _DWORD g_bitmain_pic_state[32];

//----- (00062DF0) --------------------------------------------------------
unsigned int __fastcall close_pic(unsigned int result)
{
  unsigned int v1; // r5
  int v2; // r6
  char s[2048]; // [sp+10h] [bp-1800h] BYREF
  char v4[4096]; // [sp+810h] [bp-1000h] BYREF

  v1 = result;
  if ( result > 0xF )
  {
    snprintf(s, 0x800u, "%s: Bad pic param, input chain is %d", "close_pic", result);
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, s);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer"
             "-origin_godminer-new/backend/device/hal/drv_pic/pic_1704.c",
             165,
             "close_pic",
             9,
             762,
             100,
             v4);
  }
  else
  {
    v2 = 2 * result;
    if ( g_bitmain_pic_state[2 * result] || g_bitmain_pic_state[v2 + 1] )
    {
      pthread_mutex_lock(&i2c_mutex_all);
      iic_uninit(g_bitmain_pic_state[2 * v1]);
      g_bitmain_pic_state[v2 + 1] = 0;
      return pthread_mutex_unlock(&i2c_mutex_all);
    }
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1197E4: using guessed type pthread_mutex_t i2c_mutex_all;
// 11A7AC: using guessed type int g_zc;
// 11B3D8: using guessed type _DWORD g_bitmain_pic_state[32];

//----- (00062EF0) --------------------------------------------------------
int sub_62EF0()
{
  char v1[2048]; // [sp+10h] [bp-1800h] BYREF
  char v2[4096]; // [sp+810h] [bp-1000h] BYREF

  strcpy(v1, "Error: set_BC_write_command timeout!\n");
  V_LOCK();
  logfmt_raw(v2, 0x1000u, 0, v1);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-o"
           "rigin_godminer-new/backend/device/hal/platform/7007/7007_common.c",
           174,
           "set_BC_write_command",
           20,
           782,
           100,
           v2);
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00062F8C) --------------------------------------------------------
int __fastcall sub_62F8C(int a1)
{
  int v2; // r4
  int result; // r0
  int v4; // [sp+4h] [bp-4h] BYREF

  fpga_write(192, a1);
  if ( a1 >= 0 )
    return fpga_read(192, &v4);
  v2 = 3001;
  while ( 1 )
  {
    fpga_read(192, &v4);
    result = 1000;
    if ( v4 >= 0 )
      break;
    usleep(0x3E8u);
    if ( !--v2 )
      return sub_62EF0();
  }
  return result;
}

//----- (00063000) --------------------------------------------------------
int __fastcall sub_63000(int a1)
{
  int v2; // r0
  int v3; // r6
  _BYTE *v4; // r3
  int v5; // r2
  char v6; // t1
  char v8[17]; // [sp+10h] [bp-1820h] BYREF
  _BYTE v9[3]; // [sp+21h] [bp-180Fh] BYREF
  char v10[2048]; // [sp+30h] [bp-1800h] BYREF
  char v11[4096]; // [sp+830h] [bp-1000h] BYREF

  v2 = socket(2, 1, 0);
  v3 = v2;
  if ( v2 < 0 )
  {
    strcpy(v10, "error sock");
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, v10);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_common.c",
      174,
      "get_eth_mac",
      11,
      128,
      100,
      v11);
    return -1;
  }
  else
  {
    strcpy(v8, "eth0");
    if ( ioctl(v2, 0x8927u, v8) < 0 )
    {
      strcpy(v10, "error ioctl");
      V_LOCK();
      logfmt_raw(v11, 0x1000u, 0, v10);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_common.c",
        174,
        "get_eth_mac",
        11,
        134,
        100,
        v11);
      close(v3);
      return -2;
    }
    else
    {
      v4 = v9;
      v5 = a1 - 1;
      do
      {
        v6 = *++v4;
        *(_BYTE *)++v5 = v6;
      }
      while ( v5 != a1 + 5 );
      close(v3);
      return 0;
    }
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00063190) --------------------------------------------------------
int platform_init()
{
  int v0; // r5
  int v2; // r0
  int v3; // r3
  int v4; // [sp+14h] [bp-1804h] BYREF
  _DWORD s[510]; // [sp+18h] [bp-1800h] BYREF
  char v6[4096]; // [sp+818h] [bp-1000h] BYREF

  if ( platform_inited )
    return 0;
  strcpy((char *)s, "platform_init\n");
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/platform/7007/7007_common.c",
    174,
    "platform_init",
    13,
    63,
    60,
    v6);
  if ( fpga_init() )
  {
    v0 = -1;
    strcpy((char *)s, "fpga init failed\n");
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, s);
    V_UNLOCK();
    v2 = g_zc;
    v3 = 67;
LABEL_9:
    zlog(
      v2,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_common.c",
      174,
      "platform_init",
      13,
      v3,
      100,
      v6);
    return v0;
  }
  if ( gpio_init() )
  {
    v0 = -2;
    strcpy((char *)s, "gpio init failed\n");
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, s);
    V_UNLOCK();
    v2 = g_zc;
    v3 = 73;
    goto LABEL_9;
  }
  memset(&unk_119804, 0, 0x124u);
  v4 = 0;
  fpga_read(0, &v4);
  v4 |= 0x20000000u;
  snprintf((char *)s, 0x800u, "HARDWARE_VERSION = 0x%x\n", v4);
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/platform/7007/7007_common.c",
    174,
    "platform_init",
    13,
    86,
    40,
    v6);
  fpga_write(0, v4);
  platform_inited = 1;
  fan_init();
  uart_init();
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119800: using guessed type int platform_inited;
// 11A7AC: using guessed type int g_zc;

//----- (000633D8) --------------------------------------------------------
int platform_uninit()
{
  int result; // r0

  if ( platform_inited )
  {
    uart_uninit();
    fpga_uninit();
    fan_uninit();
    ui_uninit();
    result = gpio_uninit();
    platform_inited = 0;
  }
  return result;
}
// 64EA0: using guessed type int fan_uninit(void);
// 683E8: using guessed type int uart_uninit(void);
// 119800: using guessed type int platform_inited;

//----- (00063410) --------------------------------------------------------
void *__fastcall get_system_capability(void *result)
{
  if ( result )
    return memcpy(result, &unk_119804, 0x124u);
  return result;
}

//----- (00063428) --------------------------------------------------------
int __fastcall get_uuid(_DWORD *a1)
{
  if ( !a1 )
    return -1;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  return sub_63000((int)a1);
}

//----- (00063450) --------------------------------------------------------
int __fastcall get_mac_hal(int a1)
{
  if ( a1 )
    return sub_63000(a1);
  else
    return -1;
}

//----- (00063464) --------------------------------------------------------
int __fastcall chain_reset_low(char a1)
{
  int v3; // [sp+4h] [bp-4h] BYREF

  v3 = 0;
  fpga_read(52, &v3);
  return fpga_write(52, v3 | (1 << a1));
}

//----- (000634A8) --------------------------------------------------------
int __fastcall chain_reset_high(char a1)
{
  int v3; // [sp+4h] [bp-4h] BYREF

  v3 = 0;
  fpga_read(52, &v3);
  return fpga_write(52, v3 & ~(1 << a1));
}

//----- (000634EC) --------------------------------------------------------
int __fastcall chain_reset(char a1)
{
  chain_reset_low(a1);
  usleep((__useconds_t)"rl_kda_2110");
  return chain_reset_high(a1);
}

//----- (00063510) --------------------------------------------------------
unsigned int all_chain_reset_high()
{
  unsigned int v1; // [sp+4h] [bp-8h] BYREF

  v1 = 0;
  fpga_read(52, &v1);
  v1 = ~(~HIWORD(v1) << 16);
  fpga_write(52, v1);
  return sleep(2u);
}

//----- (00063558) --------------------------------------------------------
unsigned int all_chain_reset_low()
{
  unsigned int v1; // [sp+4h] [bp-8h] BYREF

  v1 = 0;
  fpga_read(52, &v1);
  v1 = HIWORD(v1) << 16;
  fpga_write(52, v1);
  return sleep(2u);
}

//----- (000635A0) --------------------------------------------------------
int board_reset()
{
  return usleep((__useconds_t)"rl_kda_2110");
}

//----- (000635B4) --------------------------------------------------------
int get_hardware_type()
{
  unsigned int v1; // [sp+14h] [bp-1804h] BYREF
  char v2[2040]; // [sp+18h] [bp-1800h] BYREF
  char v3[4096]; // [sp+818h] [bp-1000h] BYREF

  v1 = 0;
  if ( platform_inited )
  {
    fpga_read(0, &v1);
    return v1 >> 31;
  }
  else
  {
    strcpy(v2, "platform not inited\n");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_common.c",
      174,
      "get_hardware_type",
      17,
      240,
      100,
      v3);
    return 2;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119800: using guessed type int platform_inited;
// 11A7AC: using guessed type int g_zc;

//----- (00063690) --------------------------------------------------------
int __fastcall set_hardware_type(int a1)
{
  int v2; // r1
  int v4; // [sp+14h] [bp-1808h] BYREF
  char v5[2040]; // [sp+18h] [bp-1804h] BYREF
  char v6[4100]; // [sp+818h] [bp-1004h] BYREF

  v4 = 0;
  if ( platform_inited )
  {
    fpga_read(0, &v4);
    v2 = v4;
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        v2 = v4 | 0x80000000;
        v4 |= 0x80000000;
      }
    }
    else
    {
      v2 = v4 & 0x7FFFFFFF;
      v4 &= ~0x80000000;
    }
    fpga_write(0, v2);
    return 0;
  }
  else
  {
    strcpy(v5, "platform not inited\n");
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, v5);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_common.c",
      174,
      "set_hardware_type",
      17,
      257,
      100,
      v6);
    return -2;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119800: using guessed type int platform_inited;
// 11A7AC: using guessed type int g_zc;

//----- (00063794) --------------------------------------------------------
int enable_bypass_mode()
{
  int v1; // [sp+14h] [bp-1808h] BYREF
  char v2[2040]; // [sp+18h] [bp-1804h] BYREF
  char v3[4100]; // [sp+818h] [bp-1004h] BYREF

  v1 = 0;
  if ( platform_inited )
  {
    fpga_read(0, &v1);
    v1 |= 0x20000000u;
    fpga_write(0, v1);
    return 0;
  }
  else
  {
    strcpy(v2, "platform not inited\n");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_common.c",
      174,
      "enable_bypass_mode",
      18,
      280,
      100,
      v3);
    return -2;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119800: using guessed type int platform_inited;
// 11A7AC: using guessed type int g_zc;

//----- (00063880) --------------------------------------------------------
int disable_bypass_mode()
{
  int v1; // [sp+14h] [bp-1808h] BYREF
  char v2[2040]; // [sp+18h] [bp-1804h] BYREF
  char v3[4100]; // [sp+818h] [bp-1004h] BYREF

  v1 = 0;
  if ( platform_inited )
  {
    fpga_read(0, &v1);
    v1 &= ~0x20000000u;
    fpga_write(0, v1);
    return 0;
  }
  else
  {
    strcpy(v2, "platform not inited\n");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_common.c",
      174,
      "disable_bypass_mode",
      19,
      294,
      100,
      v3);
    return -2;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119800: using guessed type int platform_inited;
// 11A7AC: using guessed type int g_zc;

//----- (0006396C) --------------------------------------------------------
int is_bypass_mode_enable()
{
  unsigned int v1; // [sp+14h] [bp-1804h] BYREF
  char v2[2040]; // [sp+18h] [bp-1800h] BYREF
  char v3[4096]; // [sp+818h] [bp-1000h] BYREF

  v1 = 0;
  if ( platform_inited )
  {
    fpga_read(0, &v1);
    return (v1 >> 29) & 1;
  }
  else
  {
    strcpy(v2, "platform not inited\n");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_common.c",
      174,
      "is_bypass_mode_enable",
      21,
      308,
      100,
      v3);
    return 0;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119800: using guessed type int platform_inited;
// 11A7AC: using guessed type int g_zc;

//----- (00063A48) --------------------------------------------------------
int get_hardware_version()
{
  int v1; // [sp+14h] [bp-1804h] BYREF
  char v2[2040]; // [sp+18h] [bp-1800h] BYREF
  char v3[4096]; // [sp+818h] [bp-1000h] BYREF

  v1 = 0;
  if ( platform_inited )
  {
    fpga_read(0, &v1);
    return v1;
  }
  else
  {
    strcpy(v2, "platform not inited\n");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_common.c",
      174,
      "get_hardware_version",
      20,
      322,
      100,
      v3);
    return 0;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119800: using guessed type int platform_inited;
// 11A7AC: using guessed type int g_zc;

//----- (00063B24) --------------------------------------------------------
int get_dhash_acc_control()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  v1 = 0;
  fpga_read(256, &v1);
  return v1;
}

//----- (00063B4C) --------------------------------------------------------
int __fastcall set_dhash_acc_control(int a1)
{
  char s[2048]; // [sp+10h] [bp-1800h] BYREF
  char v4[4096]; // [sp+810h] [bp-1000h] BYREF

  fpga_write(256, a1);
  snprintf(s, 0x800u, "set DHASH_ACC_CONTROL is 0x%x\n", a1);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-o"
           "rigin_godminer-new/backend/device/hal/platform/7007/7007_common.c",
           174,
           "set_dhash_acc_control",
           21,
           343,
           40,
           v4);
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00063BEC) --------------------------------------------------------
int disable_dhash_chip_work()
{
  int v1; // [sp+0h] [bp-8h] BYREF
  int v2; // [sp+4h] [bp-4h] BYREF

  v1 = 0;
  fpga_read(192, &v1);
  v1 &= ~0x400000u;
  fpga_write(192, v1);
  v2 = 0;
  fpga_read(256, &v2);
  return set_dhash_acc_control(v2 & 0xFFFFFFBF);
}

//----- (00063C44) --------------------------------------------------------
int fpga_chain_reset_all()
{
  unsigned int v1; // [sp+14h] [bp-1808h] BYREF
  char s[2040]; // [sp+18h] [bp-1804h] BYREF
  char v3[4100]; // [sp+818h] [bp-1004h] BYREF

  v1 = 0;
  fpga_read(52, &v1);
  fpga_write(52, ~(~HIWORD(v1) << 16));
  sleep(3u);
  fpga_read(52, &v1);
  fpga_write(52, HIWORD(v1) << 16);
  sleep(1u);
  snprintf(s, 0x800u, "fpga fpga_chain_reset_all success 0x%x\n", v1);
  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, s);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-o"
           "rigin_godminer-new/backend/device/hal/platform/7007/7007_common.c",
           174,
           "fpga_chain_reset_all",
           20,
           369,
           20,
           v3);
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00063D28) --------------------------------------------------------
int __fastcall read_fpga_id(char *a1)
{
  int v3; // [sp+10h] [bp-1808h] BYREF
  int v4; // [sp+14h] [bp-1804h] BYREF
  char s[2040]; // [sp+18h] [bp-1800h] BYREF
  char v6[4096]; // [sp+818h] [bp-1000h] BYREF

  v3 = 0;
  v4 = 0;
  fpga_read(240, &v3);
  fpga_read(244, &v4);
  sprintf(a1, "%08x%08x", v4, v3);
  snprintf(s, 0x800u, "\n%x %x\n", v3, v4);
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, s);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-o"
           "rigin_godminer-new/backend/device/hal/platform/7007/7007_common.c",
           174,
           "read_fpga_id",
           12,
           379,
           100,
           v6);
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00063E04) --------------------------------------------------------
int __fastcall set_hardware_version(int a1)
{
  return fpga_write(0, a1);
}

//----- (00063E10) --------------------------------------------------------
int get_job_start_address()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  fpga_read(280, &v1);
  return v1;
}

//----- (00063E30) --------------------------------------------------------
int __fastcall set_job_start_address(int a1)
{
  int v2; // [sp+4h] [bp-8h] BYREF

  fpga_write(280, a1);
  return fpga_read(280, &v2);
}

//----- (00063E58) --------------------------------------------------------
int get_nonce2_and_job_id_store_address()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  fpga_read(272, &v1);
  return v1;
}

//----- (00063E78) --------------------------------------------------------
int __fastcall set_nonce2_and_job_id_store_address(int a1)
{
  int v3; // [sp+4h] [bp-4h] BYREF

  fpga_read(272, &v3);
  fpga_write(272, a1);
  return fpga_read(272, &v3);
}

//----- (00063EB0) --------------------------------------------------------
unsigned int __fastcall get_fan_speed(_BYTE *a1, _DWORD *a2)
{
  int v4; // r2
  unsigned int result; // r0
  unsigned int v6; // [sp+4h] [bp-8h] BYREF

  fpga_read(4, &v6);
  v4 = (v6 >> 8) & 7;
  result = v6;
  *a2 = (unsigned __int8)v6;
  *a1 = v4;
  return result;
}

//----- (00063EEC) --------------------------------------------------------
int __fastcall set_time_out_control(int a1)
{
  int v2; // [sp+4h] [bp-8h] BYREF

  fpga_write(136, a1);
  return fpga_read(136, &v2);
}

//----- (00063F14) --------------------------------------------------------
int get_hash_counting_number()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  fpga_read(144, &v1);
  return v1;
}

//----- (00063F34) --------------------------------------------------------
int __fastcall set_hash_counting_number(int a1)
{
  int v2; // [sp+4h] [bp-8h] BYREF

  fpga_write(144, a1);
  return fpga_read(144, &v2);
}

//----- (00063F5C) --------------------------------------------------------
int enable_mid_auto_gen_rx()
{
  return fpga_write(248, 196608);
}

//----- (00063F68) --------------------------------------------------------
int disable_mid_auto_gen_rx()
{
  return fpga_write(248, 0x10000);
}

//----- (00063F74) --------------------------------------------------------
int get_crc_count()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  fpga_read(248, &v1);
  return (unsigned __int16)v1;
}

//----- (00063F94) --------------------------------------------------------
int __fastcall reset_crc_count(int a1)
{
  if ( a1 )
    return fpga_write(248, 0x80000000);
  else
    return fpga_write(248, 0);
}

//----- (00063FB0) --------------------------------------------------------
int get_hash_on_plug()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  fpga_read(8, &v1);
  return v1;
}

//----- (00063FD0) --------------------------------------------------------
int get_nonce_number_in_fifo()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  fpga_read(24, &v1);
  return v1;
}

//----- (00063FF0) --------------------------------------------------------
int __fastcall get_return_nonce(_QWORD *a1)
{
  int result; // r0
  __int64 v3; // [sp+0h] [bp-8h] BYREF

  fpga_read(16, &v3);
  result = fpga_read(20, (_DWORD *)&v3 + 1);
  *a1 = v3;
  return result;
}

//----- (00064024) --------------------------------------------------------
__int64 __fastcall get_return_nonce_128bit(__int64 *a1)
{
  __int64 result; // r0
  __int64 v3; // r2
  __int64 v4; // [sp+0h] [bp-10h] BYREF
  __int64 v5; // [sp+8h] [bp-8h] BYREF

  v4 = 0;
  v5 = 0;
  fpga_read(16, &v4);
  fpga_read(20, (_DWORD *)&v4 + 1);
  fpga_read(16, &v5);
  fpga_read(20, (_DWORD *)&v5 + 1);
  result = v4;
  v3 = v5;
  *a1 = v4;
  a1[1] = v3;
  return result;
}

//----- (0006408C) --------------------------------------------------------
int get_ticket_mask()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  fpga_read(140, &v1);
  return v1;
}

//----- (000640AC) --------------------------------------------------------
int __fastcall set_ticket_mask(int a1)
{
  int v2; // [sp+4h] [bp-8h] BYREF

  fpga_write(140, a1);
  return fpga_read(140, &v2);
}

//----- (000640D4) --------------------------------------------------------
int get_job_id()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  fpga_read(292, &v1);
  return v1;
}

//----- (000640F4) --------------------------------------------------------
int __fastcall set_job_id(int a1)
{
  int v2; // [sp+4h] [bp-8h] BYREF

  fpga_write(292, a1);
  return fpga_read(292, &v2);
}

//----- (0006411C) --------------------------------------------------------
int get_job_length()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  fpga_read(284, &v1);
  return v1;
}

//----- (0006413C) --------------------------------------------------------
int __fastcall set_job_length(int a1)
{
  int v2; // [sp+4h] [bp-8h] BYREF

  fpga_write(284, a1);
  return fpga_read(284, &v2);
}

//----- (00064164) --------------------------------------------------------
int get_work_fifo_state()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  fpga_read(12, &v1);
  return v1;
}

//----- (00064184) --------------------------------------------------------
int get_block_header_version()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  fpga_read(304, &v1);
  return v1;
}

//----- (000641A4) --------------------------------------------------------
int __fastcall set_block_header_version(int a1)
{
  int v2; // [sp+4h] [bp-8h] BYREF

  fpga_write(304, a1);
  return fpga_read(304, &v2);
}

//----- (000641CC) --------------------------------------------------------
int get_block_header_version_1()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  fpga_read(356, &v1);
  return v1;
}

//----- (000641EC) --------------------------------------------------------
int get_block_header_version_2()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  fpga_read(360, &v1);
  return v1;
}

//----- (0006420C) --------------------------------------------------------
int get_block_header_version_3()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  fpga_read(364, &v1);
  return v1;
}

//----- (0006422C) --------------------------------------------------------
int __fastcall set_block_header_version_1(int a1)
{
  return fpga_write(356, a1);
}

//----- (00064238) --------------------------------------------------------
int __fastcall set_block_header_version_2(int a1)
{
  return fpga_write(360, a1);
}

//----- (00064244) --------------------------------------------------------
int __fastcall set_block_header_version_3(int a1)
{
  return fpga_write(364, a1);
}

//----- (00064250) --------------------------------------------------------
int __fastcall set_block_header_version_4(int a1)
{
  return fpga_write(1136, a1);
}

//----- (0006425C) --------------------------------------------------------
int __fastcall set_block_header_version_5(int a1)
{
  return fpga_write(1140, a1);
}

//----- (00064268) --------------------------------------------------------
int __fastcall set_block_header_version_6(int a1)
{
  return fpga_write(1144, a1);
}

//----- (00064274) --------------------------------------------------------
int __fastcall set_block_header_version_7(int a1)
{
  return fpga_write(1148, a1);
}

//----- (00064280) --------------------------------------------------------
int get_time_stamp()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  fpga_read(308, &v1);
  return v1;
}

//----- (000642A0) --------------------------------------------------------
int __fastcall set_time_stamp(int a1)
{
  int v2; // [sp+4h] [bp-8h] BYREF

  fpga_write(308, a1);
  return fpga_read(308, &v2);
}

//----- (000642C8) --------------------------------------------------------
int get_target_bits()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  fpga_read(312, &v1);
  return v1;
}

//----- (000642E8) --------------------------------------------------------
int __fastcall set_target_bits(int a1)
{
  int v2; // [sp+4h] [bp-8h] BYREF

  fpga_write(312, a1);
  return fpga_read(312, &v2);
}

//----- (00064310) --------------------------------------------------------
int __fastcall set_pre_header_hash(int a1)
{
  int v1; // r5
  int v2; // r4
  int v3; // r0
  int v4; // t1
  int result; // r0

  v1 = a1 - 4;
  v2 = 320;
  do
  {
    v3 = v2;
    v2 += 4;
    v4 = *(_DWORD *)(v1 + 4);
    v1 += 4;
    result = fpga_write(v3, v4);
  }
  while ( v2 != 352 );
  return result;
}

//----- (00064338) --------------------------------------------------------
int __fastcall set_coinbase_length_and_nonce2_length(int a1)
{
  int v2; // [sp+4h] [bp-8h] BYREF

  fpga_write(260, a1);
  return fpga_read(260, &v2);
}

//----- (00064360) --------------------------------------------------------
int __fastcall set_work_nonce2(int *a1)
{
  int v3; // [sp+4h] [bp-4h] BYREF

  fpga_write(264, *a1);
  fpga_write(268, a1[1]);
  fpga_read(264, &v3);
  return fpga_read(268, &v3);
}

//----- (000643A4) --------------------------------------------------------
int __fastcall set_merkle_bin_number(unsigned __int16 a1)
{
  int v2; // [sp+4h] [bp-8h] BYREF

  fpga_write(276, a1);
  return fpga_read(276, &v2);
}

//----- (000643CC) --------------------------------------------------------
int get_nonce_fifo_interrupt()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  fpga_read(28, &v1);
  return v1;
}

//----- (000643EC) --------------------------------------------------------
int __fastcall set_nonce_fifo_interrupt(int a1)
{
  int v2; // [sp+4h] [bp-8h] BYREF

  fpga_write(28, a1);
  return fpga_read(28, &v2);
}

//----- (00064414) --------------------------------------------------------
int set_BC_nullen_all_chain()
{
  int v1; // [sp+4h] [bp-4h] BYREF

  pthread_mutex_lock(&bc_cmd_acc_mutex);
  fpga_read(192, &v1);
  return pthread_mutex_unlock(&bc_cmd_acc_mutex);
}

//----- (00064448) --------------------------------------------------------
int __fastcall set_BC_baud(char a1)
{
  int v1; // r4
  int v3; // [sp+4h] [bp-8h] BYREF

  v1 = a1 & 0x3F;
  pthread_mutex_lock(&bc_cmd_acc_mutex);
  usleep(0xC350u);
  fpga_read(192, &v3);
  sub_62F8C(v3 & 0xFFFFFFC0 | v1);
  return pthread_mutex_unlock(&bc_cmd_acc_mutex);
}

//----- (0006449C) --------------------------------------------------------
int __fastcall set_BC_nullen(int a1, int a2)
{
  unsigned int v4; // r0
  int v6; // [sp+4h] [bp-8h] BYREF

  pthread_mutex_lock(&bc_cmd_acc_mutex);
  fpga_read(192, &v6);
  if ( a2 )
    v4 = v6 & 0xFFF0FFFF | (a1 << 16) | 0xC00000;
  else
    v4 = v6 & 0xFFB0FFFF | (a1 << 16) & 0xFFBFFFFF;
  if ( !a2 )
    v4 |= 0x800000u;
  sub_62F8C(v4);
  return pthread_mutex_unlock(&bc_cmd_acc_mutex);
}

//----- (000644F4) --------------------------------------------------------
int __fastcall send_BC_command(int *a1, int a2)
{
  int v5; // [sp+4h] [bp-4h] BYREF

  pthread_mutex_lock(&bc_cmd_acc_mutex);
  fpga_write(196, *a1);
  fpga_write(200, a1[1]);
  fpga_write(204, a1[2]);
  fpga_read(196, &v5);
  fpga_read(200, &v5);
  fpga_read(204, &v5);
  fpga_read(192, &v5);
  sub_62F8C(v5 & 0x7F70FFFF | 0x80800000 | (a2 << 16));
  return pthread_mutex_unlock(&bc_cmd_acc_mutex);
}

//----- (00064590) --------------------------------------------------------
int __fastcall set_TW_write_command(int a1)
{
  int v1; // r5
  int v2; // r4
  int v3; // r0
  int v4; // t1
  int result; // r0

  v1 = a1 - 4;
  v2 = 64;
  do
  {
    v3 = v2;
    v2 += 4;
    v4 = *(_DWORD *)(v1 + 4);
    v1 += 4;
    result = fpga_write(v3, v4);
  }
  while ( v2 != 116 );
  return result;
}

//----- (000645B8) --------------------------------------------------------
int __fastcall set_TW_write_command_vil(int *a1)
{
  int v2; // r4

  v2 = 0;
  pthread_mutex_lock(&tw_cmd_acc_mutex);
  while ( !v2 )
  {
    fpga_write(64, *a1);
LABEL_2:
    ++v2;
  }
  fpga_write(68, a1[v2]);
  if ( v2 != 12 )
    goto LABEL_2;
  return pthread_mutex_unlock(&tw_cmd_acc_mutex);
}

//----- (00064610) --------------------------------------------------------
int __fastcall set_TW_write_command_chunk0(int *a1)
{
  int v2; // r4

  v2 = 0;
  pthread_mutex_lock(&tw_cmd_acc_mutex);
  while ( !v2 )
  {
    fpga_write(64, *a1);
LABEL_2:
    ++v2;
  }
  fpga_write(68, a1[v2]);
  if ( v2 != 20 )
    goto LABEL_2;
  return pthread_mutex_unlock(&tw_cmd_acc_mutex);
}

//----- (00064668) --------------------------------------------------------
int __fastcall set_TW_write_command_x_midstate(int *a1, int a2)
{
  unsigned int v2; // r4
  unsigned int v4; // r5
  int v5; // r0
  int v6; // r1

  v2 = 0;
  v4 = (unsigned int)(32 * a2 + 20) >> 2;
  pthread_mutex_lock(&tw_cmd_acc_mutex);
  do
  {
    v5 = 64;
    if ( v2 )
    {
      v6 = a1[v2];
      v5 = 68;
    }
    else
    {
      v6 = *a1;
    }
    ++v2;
    fpga_write(v5, v6);
  }
  while ( v2 < v4 );
  return pthread_mutex_unlock(&tw_cmd_acc_mutex);
}

//----- (000646C0) --------------------------------------------------------
int get_QN_write_data_command()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  fpga_read(128, &v1);
  return v1;
}

//----- (000646E0) --------------------------------------------------------
int __fastcall set_QN_write_data_command(int a1)
{
  int v2; // [sp+4h] [bp-8h] BYREF

  fpga_write(128, a1);
  return fpga_read(128, &v2);
}

//----- (00064708) --------------------------------------------------------
int get_temperature_0_3()
{
  int v1; // [sp+14h] [bp-1804h] BYREF
  char v2[2040]; // [sp+18h] [bp-1800h] BYREF
  char v3[4096]; // [sp+818h] [bp-1000h] BYREF

  v1 = 0;
  if ( platform_inited )
  {
    fpga_read(32, &v1);
    return v1;
  }
  else
  {
    strcpy(v2, "platform not inited\n");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_common.c",
      174,
      "get_temperature_0_3",
      19,
      941,
      100,
      v3);
    return 0;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119800: using guessed type int platform_inited;
// 11A7AC: using guessed type int g_zc;

//----- (000647E8) --------------------------------------------------------
int get_temperature_4_7()
{
  int v1; // [sp+14h] [bp-1804h] BYREF
  char v2[2040]; // [sp+18h] [bp-1800h] BYREF
  char v3[4096]; // [sp+818h] [bp-1000h] BYREF

  v1 = 0;
  if ( platform_inited )
  {
    fpga_read(36, &v1);
    return v1;
  }
  else
  {
    strcpy(v2, "platform not inited\n");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_common.c",
      174,
      "get_temperature_4_7",
      19,
      956,
      100,
      v3);
    return 0;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119800: using guessed type int platform_inited;
// 11A7AC: using guessed type int g_zc;

//----- (000648C8) --------------------------------------------------------
int get_temperature_8_11()
{
  int v1; // [sp+14h] [bp-1804h] BYREF
  char v2[2040]; // [sp+18h] [bp-1800h] BYREF
  char v3[4096]; // [sp+818h] [bp-1000h] BYREF

  v1 = 0;
  if ( platform_inited )
  {
    fpga_read(40, &v1);
    return v1;
  }
  else
  {
    strcpy(v2, "platform not inited\n");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_common.c",
      174,
      "get_temperature_8_11",
      20,
      971,
      100,
      v3);
    return 0;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119800: using guessed type int platform_inited;
// 11A7AC: using guessed type int g_zc;

//----- (000649A8) --------------------------------------------------------
int get_temperature_12_15()
{
  int v1; // [sp+14h] [bp-1804h] BYREF
  char v2[2040]; // [sp+18h] [bp-1800h] BYREF
  char v3[4096]; // [sp+818h] [bp-1000h] BYREF

  v1 = 0;
  if ( platform_inited )
  {
    fpga_read(44, &v1);
    return v1;
  }
  else
  {
    strcpy(v2, "platform not inited\n");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_common.c",
      174,
      "get_temperature_12_15",
      21,
      986,
      100,
      v3);
    return 0;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119800: using guessed type int platform_inited;
// 11A7AC: using guessed type int g_zc;

//----- (00064A88) --------------------------------------------------------
int __fastcall set_fan_control(int a1)
{
  int v2; // [sp+14h] [bp-1804h] BYREF
  char v3[2040]; // [sp+18h] [bp-1800h] BYREF
  char v4[4096]; // [sp+818h] [bp-1000h] BYREF

  v2 = 0;
  if ( platform_inited )
  {
    fpga_write(132, a1);
    return fpga_read(132, &v2);
  }
  else
  {
    strcpy(v3, "platform not inited\n");
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, v3);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer"
             "-origin_godminer-new/backend/device/hal/platform/7007/7007_common.c",
             174,
             "set_fan_control",
             15,
             1001,
             100,
             v4);
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119800: using guessed type int platform_inited;
// 11A7AC: using guessed type int g_zc;

//----- (00064B68) --------------------------------------------------------
int __fastcall set_fan_control_1(int a1)
{
  int v2; // [sp+14h] [bp-1804h] BYREF
  char v3[2040]; // [sp+18h] [bp-1800h] BYREF
  char v4[4096]; // [sp+818h] [bp-1000h] BYREF

  v2 = 0;
  if ( platform_inited )
  {
    fpga_write(160, a1);
    return fpga_read(160, &v2);
  }
  else
  {
    strcpy(v3, "platform not inited\n");
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, v3);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer"
             "-origin_godminer-new/backend/device/hal/platform/7007/7007_common.c",
             174,
             "set_fan_control_1",
             17,
             1015,
             100,
             v4);
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119800: using guessed type int platform_inited;
// 11A7AC: using guessed type int g_zc;

//----- (00064C48) --------------------------------------------------------
int get_bt8d_control()
{
  int v1; // [sp+14h] [bp-1804h] BYREF
  char v2[2040]; // [sp+18h] [bp-1800h] BYREF
  char v3[4096]; // [sp+818h] [bp-1000h] BYREF

  v1 = 0;
  if ( platform_inited )
  {
    fpga_read(60, &v1);
    return v1;
  }
  else
  {
    strcpy(v2, "platform not inited\n");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_common.c",
      174,
      "get_bt8d_control",
      16,
      1029,
      100,
      v3);
    return 0;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119800: using guessed type int platform_inited;
// 11A7AC: using guessed type int g_zc;

//----- (00064D28) --------------------------------------------------------
int __fastcall set_bt8d_control(int a1)
{
  char v2[2048]; // [sp+10h] [bp-1804h] BYREF
  char v3[4100]; // [sp+810h] [bp-1004h] BYREF

  if ( platform_inited )
    return fpga_write(60, a1);
  strcpy(v2, "platform not inited\n");
  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, v2);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-o"
           "rigin_godminer-new/backend/device/hal/platform/7007/7007_common.c",
           174,
           "set_bt8d_control",
           16,
           1042,
           100,
           v3);
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119800: using guessed type int platform_inited;
// 11A7AC: using guessed type int g_zc;

//----- (00064DEC) --------------------------------------------------------
int fan_init()
{
  char v1[2048]; // [sp+10h] [bp-1804h] BYREF
  char v2[4100]; // [sp+810h] [bp-1004h] BYREF

  if ( platform_inited )
    return 0;
  strcpy(v1, "please init platform first!!\n");
  V_LOCK();
  logfmt_raw(v2, 0x1000u, 0, v1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/platform/7007/7007_fan.c",
    171,
    "fan_init",
    8,
    25,
    100,
    v2);
  return -1;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119800: using guessed type int platform_inited;
// 11A7AC: using guessed type int g_zc;

//----- (00064EA4) --------------------------------------------------------
int __fastcall fan_get_realtime_speed(int a1)
{
  int v2; // r5
  unsigned int v4; // [sp+14h] [bp-1804h] BYREF
  char s[2040]; // [sp+18h] [bp-1800h] BYREF
  char v6[4096]; // [sp+818h] [bp-1000h] BYREF

  v2 = 8;
  v4 = 0;
  while ( 1 )
  {
    fpga_read(4, &v4);
    snprintf(s, 0x800u, "FAN_SPEED fpga value = 0x%x\n", v4);
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_fan.c",
      171,
      "fan_get_realtime_speed",
      22,
      56,
      20,
      v6);
    if ( ((v4 >> 8) & 7) == a1 )
      break;
    usleep(0x2710u);
    if ( !--v2 )
      return -1;
  }
  return 120 * (unsigned __int8)v4;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00064F98) --------------------------------------------------------
int fpga_init()
{
  int v1; // r0
  int v2; // r0
  int v3; // r0
  int v4; // [sp+4h] [bp-180Ch]
  char s[2048]; // [sp+10h] [bp-1800h] BYREF
  char v6[4096]; // [sp+810h] [bp-1000h] BYREF

  if ( dword_119958 )
    return 0;
  dword_11995C = open64("/dev/axi_fpga_dev");
  if ( dword_11995C < 0 )
  {
    snprintf(s, 0x800u, "/dev/axi_fpga_dev open failed. fd = %d\n", dword_11995C);
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_fpga.c",
      172,
      "fpga_init",
      9,
      45,
      100,
      v6);
    return -1;
  }
  else
  {
    v1 = ((int (__fastcall *)(_DWORD, int, int, int, int))mmap64)(0, 4608, 3, 1, dword_11995C);
    dword_119960 = v1;
    if ( v1 )
    {
      snprintf(s, 0x800u, "fpga_init success. axi_fpga_addr_hal = 0x%x\n", v1);
      V_LOCK();
      logfmt_raw(v6, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_fpga.c",
        172,
        "fpga_init",
        9,
        59,
        20,
        v6);
      v2 = open64("/dev/fpga_mem");
      if ( v2 < 0 )
      {
        snprintf(s, 0x800u, "/dev/fpga_mem open failed. fd_fpga_mem_hal = %d\n", v2);
        V_LOCK();
        logfmt_raw(v6, 0x1000u, 0, s);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/device/hal/platform/7007/7007_fpga.c",
          172,
          "fpga_init",
          9,
          64,
          100,
          v6);
        perror("open");
        return -1;
      }
      else
      {
        v3 = mmap64(0, 0x1000000, 3, 1, v2, v4, 0, 0);
        dword_119964 = v3;
        if ( v3 )
        {
          snprintf(s, 0x800u, "mmap fpga_mem_addr_hal = 0x%x\n", v3);
          V_LOCK();
          logfmt_raw(v6, 0x1000u, 0, s);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/backend/device/hal/platform/7007/7007_fpga.c",
            172,
            "fpga_init",
            9,
            76,
            40,
            v6);
          dword_119958 = 1;
          return 0;
        }
        else
        {
          snprintf(s, 0x800u, "mmap fpga_mem_addr_hal failed. fpga_mem_addr_hal = 0x%x\n", 0);
          V_LOCK();
          logfmt_raw(v6, 0x1000u, 0, s);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/backend/device/hal/platform/7007/7007_fpga.c",
            172,
            "fpga_init",
            9,
            73,
            100,
            v6);
          return -1;
        }
      }
    }
    else
    {
      snprintf(s, 0x800u, "mmap axi_fpga_addr_hal failed. axi_fpga_addr_hal = 0x%x\n", 0);
      V_LOCK();
      logfmt_raw(v6, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_fpga.c",
        172,
        "fpga_init",
        9,
        53,
        100,
        v6);
      close(dword_11995C);
      return -2;
    }
  }
}
// 650C4: variable 'v4' is possibly undefined
// 1E5EC: using guessed type int __fastcall mmap64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1E754: using guessed type int __fastcall open64(_DWORD);
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119958: using guessed type int dword_119958;
// 11995C: using guessed type int dword_11995C;
// 119960: using guessed type int dword_119960;
// 119964: using guessed type int dword_119964;
// 11A7AC: using guessed type int g_zc;

//----- (00065344) --------------------------------------------------------
void fpga_uninit()
{
  char v0[2048]; // [sp+10h] [bp-1804h] BYREF
  char v1[4100]; // [sp+810h] [bp-1004h] BYREF

  if ( dword_119958 )
  {
    if ( munmap((void *)dword_119960, 0x1200u) < 0 )
    {
      strcpy(v0, "munmap axi_fpga_addr_hal failed!\n");
      V_LOCK();
      logfmt_raw(v1, 0x1000u, 0, v0);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_fpga.c",
        172,
        "fpga_uninit",
        11,
        95,
        100,
        v1);
    }
    if ( munmap((void *)dword_119964, 0x1000000u) < 0 )
    {
      strcpy(v0, "munmap fpga_mem_addr_hal failed!\n");
      V_LOCK();
      logfmt_raw(v1, 0x1000u, 0, v0);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_fpga.c",
        172,
        "fpga_uninit",
        11,
        101,
        100,
        v1);
    }
    dword_119958 = 0;
    close(dword_11995C);
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119958: using guessed type int dword_119958;
// 11995C: using guessed type int dword_11995C;
// 119960: using guessed type int dword_119960;
// 119964: using guessed type int dword_119964;
// 11A7AC: using guessed type int g_zc;

//----- (000654C0) --------------------------------------------------------
int __fastcall fpga_read(int a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(dword_119960 + (a1 & 0xFFFFFFFC));
  return 0;
}
// 119960: using guessed type int dword_119960;

//----- (000654E0) --------------------------------------------------------
int __fastcall fpga_write(int a1, int a2)
{
  unsigned int v2; // r2

  v2 = a1 & 0xFFFFFFFC;
  *(_DWORD *)(dword_119960 + v2) = a2;
  return 0;
}
// 119960: using guessed type int dword_119960;

//----- (000654FC) --------------------------------------------------------
int get_fpga_map_mem_addr()
{
  return dword_119964;
}
// 119964: using guessed type int dword_119964;

//----- (00065510) --------------------------------------------------------
int __fastcall sub_65510(_DWORD *a1, _DWORD *a2)
{
  return *a1 - *a2;
}

//----- (00065520) --------------------------------------------------------
int gpio_init()
{
  char v1[2048]; // [sp+10h] [bp-1800h] BYREF
  char v2[4096]; // [sp+810h] [bp-1000h] BYREF

  if ( dword_119968 )
  {
    strcpy(v1, "gpio re init\n");
    V_LOCK();
    logfmt_raw(v2, 0x1000u, 0, v1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_gpio.c",
      172,
      "gpio_init",
      9,
      98,
      80,
      v2);
  }
  else
  {
    pthread_mutex_init(&stru_11996C, 0);
    dword_119984 = (int)new_c_map(414992, 0, 0);
    pthread_mutex_init(&stru_119988, 0);
    dword_1199A0 = 1;
    pthread_create((pthread_t *)&dword_1199A4, 0, (void *(*)(void *))sub_666D4, 0);
    dword_119968 = 1;
  }
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119968: using guessed type int dword_119968;
// 119984: using guessed type int dword_119984;
// 1199A0: using guessed type int dword_1199A0;
// 1199A4: using guessed type int dword_1199A4;
// 11A7AC: using guessed type int g_zc;

//----- (00065628) --------------------------------------------------------
int gpio_uninit()
{
  int result; // r0

  if ( dword_119968 )
  {
    dword_1199A0 = 0;
    pthread_join(dword_1199A4, 0);
    pthread_mutex_destroy(&stru_11996C);
    delete_c_map((void (__fastcall ***)(_DWORD))dword_119984);
    dword_119968 = 0;
    return pthread_mutex_destroy(&stru_119988);
  }
  return result;
}
// 119968: using guessed type int dword_119968;
// 119984: using guessed type int dword_119984;
// 1199A0: using guessed type int dword_1199A0;
// 1199A4: using guessed type int dword_1199A4;

//----- (00065674) --------------------------------------------------------
int __fastcall gpio_reg_callback(int a1, int a2)
{
  int v4; // r2
  int v5; // [sp+14h] [bp-1808h] BYREF
  _DWORD s[510]; // [sp+18h] [bp-1804h] BYREF
  _DWORD v7[1025]; // [sp+818h] [bp-1004h] BYREF

  v5 = a1;
  if ( !a2 )
  {
    strcpy((char *)s, "bad param\n");
    V_LOCK();
    logfmt_raw((char *)v7, 0x1000u, 0, s);
    V_UNLOCK();
    v4 = 147;
    goto LABEL_9;
  }
  if ( pthread_mutex_lock(&stru_11996C) )
  {
    strcpy((char *)s, "fail to lock gpio ctrl mutex\n");
    V_LOCK();
    logfmt_raw((char *)v7, 0x1000u, 0, s);
    V_UNLOCK();
    v4 = 152;
LABEL_9:
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_gpio.c",
      172,
      "gpio_reg_callback",
      17,
      v4,
      100,
      v7);
    return -1;
  }
  if ( exists_c_map((int *)dword_119984, (int)&v5) )
  {
    snprintf((char *)s, 0x800u, "port %d already exist in callback map \n", v5);
    V_LOCK();
    logfmt_raw((char *)v7, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_gpio.c",
      172,
      "gpio_reg_callback",
      17,
      165,
      20,
      v7);
  }
  else
  {
    snprintf((char *)s, 0x800u, "add %d to callback map\n", v5);
    V_LOCK();
    logfmt_raw((char *)v7, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_gpio.c",
      172,
      "gpio_reg_callback",
      17,
      158,
      20,
      v7);
    v7[0] = a2;
    v7[1] = -1;
    insert_c_map((int *)dword_119984, &v5, 4u, v7, 8u);
  }
  pthread_mutex_unlock(&stru_11996C);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119984: using guessed type int dword_119984;
// 11A7AC: using guessed type int g_zc;

//----- (000658E0) --------------------------------------------------------
int __fastcall gpio_unreg_callback(int a1, int a2)
{
  int v3; // r2
  int v4; // [sp+14h] [bp-1808h] BYREF
  _DWORD s[510]; // [sp+18h] [bp-1804h] BYREF
  char v6[4100]; // [sp+818h] [bp-1004h] BYREF

  v4 = a1;
  if ( !a2 )
  {
    strcpy((char *)s, "bad param\n");
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, s);
    V_UNLOCK();
    v3 = 183;
    goto LABEL_9;
  }
  if ( pthread_mutex_lock(&stru_11996C) )
  {
    strcpy((char *)s, "fail to lock gpio ctrl mutex\n");
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, s);
    V_UNLOCK();
    v3 = 189;
LABEL_9:
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_gpio.c",
      172,
      "gpio_unreg_callback",
      19,
      v3,
      100,
      v6);
    return -1;
  }
  if ( exists_c_map((int *)dword_119984, (int)&v4) == (int *)1 )
  {
    snprintf((char *)s, 0x800u, "remove %d from callback list\n", v4);
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_gpio.c",
      172,
      "gpio_unreg_callback",
      19,
      195,
      20,
      v6);
    remove_c_map((int *)dword_119984, (int)&v4);
  }
  else
  {
    strcpy((char *)s, "callback function not registered before\n");
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_gpio.c",
      172,
      "gpio_unreg_callback",
      19,
      200,
      80,
      v6);
  }
  pthread_mutex_unlock(&stru_11996C);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119984: using guessed type int dword_119984;
// 11A7AC: using guessed type int g_zc;

//----- (00065B3C) --------------------------------------------------------
int __fastcall gpio_export(int a1)
{
  int v2; // r6
  size_t v3; // r0
  char s[64]; // [sp+10h] [bp-1840h] BYREF
  char v6[2048]; // [sp+50h] [bp-1800h] BYREF
  char v7[4096]; // [sp+850h] [bp-1000h] BYREF

  if ( pthread_mutex_lock(&stru_119988) )
  {
    strcpy(v6, "failed to api lock\n");
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, v6);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_gpio.c",
      172,
      "gpio_export",
      11,
      221,
      100,
      v7);
    return -1;
  }
  else
  {
    snprintf(s, 0x40u, "/sys/class/gpio/gpio%d", a1);
    if ( access(s, 0) )
    {
      v2 = open64("/sys/class/gpio/export");
      if ( v2 < 0 )
      {
        strcpy(v6, "Failed to open export for writing!\n");
        V_LOCK();
        logfmt_raw(v7, 0x1000u, 0, v6);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/device/hal/platform/7007/7007_gpio.c",
          172,
          "gpio_export",
          11,
          238,
          100,
          v7);
        pthread_mutex_unlock(&stru_119988);
        return -2;
      }
      else
      {
        v3 = snprintf(s, 0x40u, "%d", a1);
        if ( write(v2, s, v3) < 0 )
        {
          snprintf(v6, 0x800u, "Failed to export gpio %d!", a1);
          V_LOCK();
          logfmt_raw(v7, 0x1000u, 0, v6);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/backend/device/hal/platform/7007/7007_gpio.c",
            172,
            "gpio_export",
            11,
            246,
            100,
            v7);
          close(v2);
          pthread_mutex_unlock(&stru_119988);
          return -3;
        }
        else
        {
          snprintf(v6, 0x800u, "export gpio %d success\n", a1);
          V_LOCK();
          logfmt_raw(v7, 0x1000u, 0, v6);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/backend/device/hal/platform/7007/7007_gpio.c",
            172,
            "gpio_export",
            11,
            251,
            20,
            v7);
          close(v2);
          pthread_mutex_unlock(&stru_119988);
          return 0;
        }
      }
    }
    else
    {
      snprintf(v6, 0x800u, "port %d already exported\n", a1);
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, v6);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_gpio.c",
        172,
        "gpio_export",
        11,
        229,
        80,
        v7);
      pthread_mutex_unlock(&stru_119988);
      return 0;
    }
  }
}
// 1E754: using guessed type int __fastcall open64(_DWORD);
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00065E94) --------------------------------------------------------
int __fastcall gpio_unexport(int a1)
{
  int v2; // r0
  int v3; // r5
  int v4; // r6
  size_t v5; // r0
  char s[64]; // [sp+10h] [bp-1840h] BYREF
  char v8[2048]; // [sp+50h] [bp-1800h] BYREF
  char v9[4096]; // [sp+850h] [bp-1000h] BYREF

  if ( pthread_mutex_lock(&stru_119988) )
  {
    v3 = -1;
    strcpy(v8, "failed to api lock\n");
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, v8);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_gpio.c",
      172,
      "gpio_unexport",
      13,
      273,
      100,
      v9);
    return v3;
  }
  snprintf(s, 0x40u, "/sys/class/gpio/gpio%d", a1);
  v2 = access(s, 0);
  v3 = v2;
  if ( !v2 )
  {
    v4 = open64("/sys/class/gpio/unexport");
    if ( v4 < 0 )
    {
      strcpy(v8, "Failed to open unexport for writing!\n");
      V_LOCK();
      logfmt_raw(v9, 0x1000u, 0, v8);
      V_UNLOCK();
      v3 = -2;
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_gpio.c",
        172,
        "gpio_unexport",
        13,
        290,
        100,
        v9);
      pthread_mutex_unlock(&stru_119988);
    }
    else
    {
      v5 = snprintf(s, 0x40u, "%d", a1);
      if ( write(v4, s, v5) < 0 )
      {
        snprintf(v8, 0x800u, "Failed to unexport gpio %d!", a1);
        V_LOCK();
        logfmt_raw(v9, 0x1000u, 0, v8);
        V_UNLOCK();
        v3 = -2;
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/device/hal/platform/7007/7007_gpio.c",
          172,
          "gpio_unexport",
          13,
          298,
          100,
          v9);
      }
      else
      {
        snprintf(v8, 0x800u, "unexport gpio %d success\n", a1);
        V_LOCK();
        logfmt_raw(v9, 0x1000u, 0, v8);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/device/hal/platform/7007/7007_gpio.c",
          172,
          "gpio_unexport",
          13,
          304,
          20,
          v9);
      }
      close(v4);
      pthread_mutex_unlock(&stru_119988);
    }
    return v3;
  }
  snprintf(v8, 0x800u, "port %d already unexported, ret = %d\n", a1, v2);
  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, v8);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/platform/7007/7007_gpio.c",
    172,
    "gpio_unexport",
    13,
    281,
    80,
    v9);
  pthread_mutex_unlock(&stru_119988);
  return 0;
}
// 1E754: using guessed type int __fastcall open64(_DWORD);
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (000661E4) --------------------------------------------------------
int __fastcall gpio_direction(int a1, int a2)
{
  int v4; // r0
  int v5; // r8
  bool v6; // zf
  size_t v7; // r2
  const char *v8; // r5
  char s[64]; // [sp+10h] [bp-1840h] BYREF
  char v11[2048]; // [sp+50h] [bp-1800h] BYREF
  char v12[4096]; // [sp+850h] [bp-1000h] BYREF

  if ( pthread_mutex_lock(&stru_119988) )
  {
    strcpy(v11, "failed to api lock\n");
    V_LOCK();
    logfmt_raw(v12, 0x1000u, 0, v11);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_gpio.c",
      172,
      "gpio_direction",
      14,
      327,
      100,
      v12);
    return -1;
  }
  else
  {
    snprintf(s, 0x40u, "/sys/class/gpio/gpio%d/direction", a1);
    v4 = open64(s);
    v5 = v4;
    if ( v4 < 0 )
    {
      snprintf(v11, 0x800u, "Failed to open gpio %d direction for writing!\n", a1);
      V_LOCK();
      logfmt_raw(v12, 0x1000u, 0, v11);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_gpio.c",
        172,
        "gpio_direction",
        14,
        334,
        100,
        v12);
      pthread_mutex_unlock(&stru_119988);
      return -2;
    }
    else
    {
      v6 = a2 == 0;
      if ( a2 )
        v7 = 3;
      else
        v7 = 2;
      v8 = "out";
      if ( v6 )
        v8 = "in";
      if ( write(v4, v8, v7) < 0 )
      {
        snprintf(v11, 0x800u, "Failed to set gpio %d direction %s !\n", a1, v8);
        V_LOCK();
        logfmt_raw(v12, 0x1000u, 0, v11);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/device/hal/platform/7007/7007_gpio.c",
          172,
          "gpio_direction",
          14,
          343,
          100,
          v12);
        close(v5);
        pthread_mutex_unlock(&stru_119988);
        return -3;
      }
      else
      {
        snprintf(v11, 0x800u, "set gpio %d direction %s success!\n", a1, v8);
        V_LOCK();
        logfmt_raw(v12, 0x1000u, 0, v11);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/device/hal/platform/7007/7007_gpio.c",
          172,
          "gpio_direction",
          14,
          350,
          20,
          v12);
        close(v5);
        pthread_mutex_unlock(&stru_119988);
        return 0;
      }
    }
  }
}
// 1E754: using guessed type int __fastcall open64(_DWORD);
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00066484) --------------------------------------------------------
int __fastcall gpio_read(int a1, _BYTE *a2)
{
  int v4; // r4
  int v5; // r0
  int v6; // r5
  int buf; // [sp+1Ch] [bp-1848h] BYREF
  char s[64]; // [sp+20h] [bp-1844h] BYREF
  char v10[2048]; // [sp+60h] [bp-1804h] BYREF
  char v11[4100]; // [sp+860h] [bp-1004h] BYREF

  buf = 0;
  v4 = pthread_mutex_lock(&stru_119988);
  if ( v4 )
  {
    v4 = -1;
    strcpy(v10, "failed to api lock\n");
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, v10);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_gpio.c",
      172,
      "gpio_read",
      9,
      372,
      100,
      v11);
  }
  else
  {
    snprintf(s, 0x40u, "/sys/class/gpio/gpio%d/value", a1);
    v5 = open64(s);
    v6 = v5;
    if ( v5 < 0 )
    {
      snprintf(v10, 0x800u, "Failed to open gpio %d value for reading!\n", a1);
      V_LOCK();
      logfmt_raw(v11, 0x1000u, 0, v10);
      V_UNLOCK();
      v4 = -2;
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_gpio.c",
        172,
        "gpio_read",
        9,
        380,
        100,
        v11);
      pthread_mutex_unlock(&stru_119988);
    }
    else if ( read(v5, &buf, 4u) < 0 )
    {
      strcpy(v10, "Failed to read value!\n");
      V_LOCK();
      logfmt_raw(v11, 0x1000u, 0, v10);
      V_UNLOCK();
      v4 = -3;
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_gpio.c",
        172,
        "gpio_read",
        9,
        387,
        100,
        v11);
      close(v6);
      pthread_mutex_unlock(&stru_119988);
    }
    else
    {
      close(v6);
      pthread_mutex_unlock(&stru_119988);
      *a2 = strtol((const char *)&buf, 0, 10);
    }
  }
  return v4;
}
// 1E754: using guessed type int __fastcall open64(_DWORD);
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (000666D4) --------------------------------------------------------
int sub_666D4()
{
  _DWORD *v0; // r5
  void (__fastcall *v1)(_DWORD *, _DWORD *, int); // r3
  int v2; // r8
  _DWORD *v3; // r6
  int v4; // r7
  unsigned __int8 v6; // [sp+1Fh] [bp-1805h] BYREF
  char s[2048]; // [sp+20h] [bp-1804h] BYREF
  _DWORD v8[1025]; // [sp+820h] [bp-1004h] BYREF

  while ( dword_1199A0 )
  {
    if ( !pthread_mutex_lock(&stru_11996C) )
    {
      v0 = new_iterator_c_map(dword_119984);
      if ( ((int (*)(void))*v0)() )
      {
        while ( 1 )
        {
          v2 = v0[5];
          v3 = (_DWORD *)((int (*)(void))v0[2])();
          v4 = ***(_DWORD ***)(v2 + 16);
          v6 = 0;
          if ( gpio_read(v4, &v6) )
            break;
          if ( v3[1] != v6 )
          {
            snprintf(s, 0x800u, "gpio port %d, last val = %d, new val = %d\n", ***(_DWORD ***)(v2 + 16), v3[1], v6);
            V_LOCK();
            logfmt_raw((char *)v8, 0x1000u, 0, s);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godmine"
              "r-origin_godminer-new/backend/device/hal/platform/7007/7007_gpio.c",
              172,
              "gpio_thread_function",
              20,
              72,
              20,
              v8);
            ((void (__fastcall *)(int, _DWORD))*v3)(v4, v6);
            v1 = (void (__fastcall *)(_DWORD *, _DWORD *, int))v0[1];
            v8[0] = *v3;
            v8[1] = v6;
            v1(v0, v8, 8);
          }
          free(v3);
          if ( !((int (__fastcall *)(_DWORD *))*v0)(v0) )
            goto LABEL_12;
        }
        snprintf(s, 0x800u, "failed to read gpio port %d\n", v4);
        V_LOCK();
        logfmt_raw((char *)v8, 0x1000u, 0, s);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/device/hal/platform/7007/7007_gpio.c",
          172,
          "gpio_thread_function",
          20,
          65,
          20,
          v8);
        free(v3);
      }
LABEL_12:
      delete_iterator_c_map(v0);
      pthread_mutex_unlock(&stru_11996C);
    }
    usleep(0x30D40u);
  }
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119984: using guessed type int dword_119984;
// 1199A0: using guessed type int dword_1199A0;
// 11A7AC: using guessed type int g_zc;

//----- (00066908) --------------------------------------------------------
int __fastcall gpio_write(int a1, int a2)
{
  int v4; // r0
  int v5; // r5
  char *v6; // r1
  char s[64]; // [sp+10h] [bp-1844h] BYREF
  char v9[2048]; // [sp+50h] [bp-1804h] BYREF
  char v10[4100]; // [sp+850h] [bp-1004h] BYREF

  if ( pthread_mutex_lock(&stru_119988) )
  {
    strcpy(v9, "failed to api lock\n");
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, v9);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_gpio.c",
      172,
      "gpio_write",
      10,
      415,
      100,
      v10);
    return -1;
  }
  else
  {
    snprintf(s, 0x40u, "/sys/class/gpio/gpio%d/value", a1);
    v4 = open64(s);
    v5 = v4;
    if ( v4 < 0 )
    {
      strcpy(v9, "Failed to open gpio value for writing!\n");
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, v9);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_gpio.c",
        172,
        "gpio_write",
        10,
        423,
        100,
        v10);
      pthread_mutex_unlock(&stru_119988);
      return -2;
    }
    else
    {
      if ( a2 )
        v6 = "1";
      else
        v6 = "01";
      if ( write(v4, v6, 1u) < 0 )
      {
        strcpy(v9, "Failed to write value!\n");
        V_LOCK();
        logfmt_raw(v10, 0x1000u, 0, v9);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/device/hal/platform/7007/7007_gpio.c",
          172,
          "gpio_write",
          10,
          429,
          100,
          v10);
        close(v5);
        pthread_mutex_unlock(&stru_119988);
        return -3;
      }
      else
      {
        close(v5);
        pthread_mutex_unlock(&stru_119988);
        return 0;
      }
    }
  }
}
// 1E754: using guessed type int __fastcall open64(_DWORD);
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00066B3C) --------------------------------------------------------
int __fastcall is_gpio_exist(int a1)
{
  char s[64]; // [sp+10h] [bp-1840h] BYREF
  char v4[2048]; // [sp+50h] [bp-1800h] BYREF
  char v5[4096]; // [sp+850h] [bp-1000h] BYREF

  if ( pthread_mutex_lock(&stru_119988) )
  {
    strcpy(v4, "failed to api lock\n");
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_gpio.c",
      172,
      "is_gpio_exist",
      13,
      443,
      100,
      v5);
    return -1;
  }
  else
  {
    snprintf(s, 0x40u, "/sys/class/gpio/gpio%d", a1);
    if ( access(s, 0) )
    {
      pthread_mutex_unlock(&stru_119988);
      return 0;
    }
    else
    {
      snprintf(v4, 0x800u, "port %d already exported\n", a1);
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_gpio.c",
        172,
        "is_gpio_exist",
        13,
        449,
        20,
        v5);
      pthread_mutex_unlock(&stru_119988);
      return 1;
    }
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00066CB4) --------------------------------------------------------
int __fastcall iic_init(int a1)
{
  int v2; // r5
  int v3; // r0
  int v4; // r2
  int v5; // r0
  _DWORD s[512]; // [sp+10h] [bp-1800h] BYREF
  char v8[4096]; // [sp+810h] [bp-1000h] BYREF

  if ( pthread_mutex_lock(&stru_1199A8) )
  {
    v2 = -4;
    strcpy((char *)s, "failed to iic lock\n");
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_iic.c",
      171,
      "iic_init",
      8,
      20,
      100,
      v8);
    return v2;
  }
  if ( a1 )
  {
    v2 = i2c_init();
    if ( v2 < 0 )
    {
      v2 = -1;
      strcpy((char *)s, "failed to i2c_init\n");
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_iic.c",
        171,
        "iic_init",
        8,
        32,
        100,
        v8);
    }
    else
    {
      snprintf(
        (char *)s,
        0x800u,
        "i2c chain = %d, master = 0x%x, slave high= 0x%x, slave low = 0x%x\n",
        *(_DWORD *)a1,
        *(unsigned __int16 *)(a1 + 4),
        *(unsigned __int8 *)(a1 + 6),
        *(unsigned __int8 *)(a1 + 7));
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_iic.c",
        171,
        "iic_init",
        8,
        36,
        20,
        v8);
      if ( i2c_select(v2, *(unsigned __int16 *)(a1 + 4)) )
      {
        strcpy((char *)s, "failed to i2c_select\n");
        V_LOCK();
        logfmt_raw(v8, 0x1000u, 0, s);
        V_UNLOCK();
        v3 = g_zc;
        v4 = 38;
        goto LABEL_6;
      }
      if ( i2c_ioctl(v2, 1795, (2 * *(unsigned __int8 *)(a1 + 7)) | (16 * *(unsigned __int8 *)(a1 + 6))) )
      {
        strcpy((char *)s, "failed to i2c_ioctl\n");
        V_LOCK();
        logfmt_raw(v8, 0x1000u, 0, s);
        V_UNLOCK();
        v3 = g_zc;
        v4 = 43;
LABEL_6:
        zlog(
          v3,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/device/hal/platform/7007/7007_iic.c",
          171,
          "iic_init",
          8,
          v4,
          100,
          v8);
        if ( v2 )
        {
          v5 = v2;
          v2 = -1;
          i2c_uninit(v5);
        }
        else
        {
          v2 = -1;
        }
      }
    }
  }
  else
  {
    v2 = -3;
    strcpy((char *)s, "bad param\n");
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_iic.c",
      171,
      "iic_init",
      8,
      26,
      100,
      v8);
  }
  pthread_mutex_unlock(&stru_1199A8);
  return v2;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1199A8: using guessed type pthread_mutex_t stru_1199A8;
// 11A7AC: using guessed type int g_zc;

//----- (00067020) --------------------------------------------------------
int __fastcall iic_uninit(int a1)
{
  char v3[2048]; // [sp+10h] [bp-1800h] BYREF
  char v4[4096]; // [sp+810h] [bp-1000h] BYREF

  if ( pthread_mutex_lock(&stru_1199A8) )
  {
    strcpy(v3, "failed to i2c lock\n");
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, v3);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer"
             "-origin_godminer-new/backend/device/hal/platform/7007/7007_iic.c",
             171,
             "iic_uninit",
             10,
             64,
             100,
             v4);
  }
  else
  {
    i2c_uninit(a1);
    return pthread_mutex_unlock(&stru_1199A8);
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1199A8: using guessed type pthread_mutex_t stru_1199A8;
// 11A7AC: using guessed type int g_zc;

//----- (000670EC) --------------------------------------------------------
int __fastcall iic_read(int a1, _BYTE *a2, int a3)
{
  int v6; // r4
  char v8[2048]; // [sp+10h] [bp-1800h] BYREF
  char v9[4096]; // [sp+810h] [bp-1000h] BYREF

  if ( pthread_mutex_lock(&stru_1199A8) )
  {
    v6 = -4;
    strcpy(v8, "failed to i2c lock\n");
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, v8);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_iic.c",
      171,
      "iic_read",
      8,
      83,
      100,
      v9);
  }
  else
  {
    v6 = i2c_read(a1, a2, a3);
    pthread_mutex_unlock(&stru_1199A8);
  }
  return v6;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1199A8: using guessed type pthread_mutex_t stru_1199A8;
// 11A7AC: using guessed type int g_zc;

//----- (000671CC) --------------------------------------------------------
int __fastcall iic_write(int a1, int a2, int a3)
{
  int v6; // r4
  char v8[2048]; // [sp+10h] [bp-1800h] BYREF
  char v9[4096]; // [sp+810h] [bp-1000h] BYREF

  if ( pthread_mutex_lock(&stru_1199A8) )
  {
    v6 = -4;
    strcpy(v8, "failed to i2c lock\n");
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, v8);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_iic.c",
      171,
      "iic_write",
      9,
      103,
      100,
      v9);
  }
  else
  {
    v6 = i2c_write(a1, a2, a3);
    pthread_mutex_unlock(&stru_1199A8);
  }
  return v6;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1199A8: using guessed type pthread_mutex_t stru_1199A8;
// 11A7AC: using guessed type int g_zc;

//----- (000672AC) --------------------------------------------------------
int __fastcall iic_read_reg(void *a1, unsigned __int8 *a2, int a3, int a4, unsigned int a5)
{
  int reg; // r4
  char v11[2048]; // [sp+10h] [bp-1804h] BYREF
  char v12[4080]; // [sp+810h] [bp-1004h] BYREF

  if ( pthread_mutex_lock(&stru_1199A8) )
  {
    reg = -4;
    strcpy(v11, "failed to i2c lock\n");
    V_LOCK();
    logfmt_raw(v12, 0x1000u, 0, v11);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_iic.c",
      171,
      "iic_read_reg",
      12,
      124,
      100,
      v12);
  }
  else
  {
    reg = i2c_read_reg(a1, a2, a3, a4, a5);
    pthread_mutex_unlock(&stru_1199A8);
  }
  return reg;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1199A8: using guessed type pthread_mutex_t stru_1199A8;
// 11A7AC: using guessed type int g_zc;

//----- (000673A4) --------------------------------------------------------
int __fastcall iic_write_reg(int a1, unsigned __int8 *a2, int a3, int a4, int a5)
{
  int v9; // r4
  char v11[2048]; // [sp+10h] [bp-1804h] BYREF
  char v12[4080]; // [sp+810h] [bp-1004h] BYREF

  if ( pthread_mutex_lock(&stru_1199A8) )
  {
    v9 = -4;
    strcpy(v11, "failed to i2c lock\n");
    V_LOCK();
    logfmt_raw(v12, 0x1000u, 0, v11);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_iic.c",
      171,
      "iic_write_reg",
      13,
      145,
      100,
      v12);
  }
  else
  {
    v9 = i2c_write_reg(a1, a2, a3, a4, a5);
    pthread_mutex_unlock(&stru_1199A8);
  }
  return v9;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1199A8: using guessed type pthread_mutex_t stru_1199A8;
// 11A7AC: using guessed type int g_zc;

//----- (0006749C) --------------------------------------------------------
int bitmain_power_on()
{
  if ( !is_gpio_exist(dword_1065BC) )
  {
    gpio_export(dword_1065BC);
    gpio_direction(dword_1065BC, 1);
  }
  return gpio_write(dword_1065BC, 0);
}
// 1065BC: using guessed type int dword_1065BC;

//----- (000674DC) --------------------------------------------------------
int bitmain_power_off_0()
{
  if ( !is_gpio_exist(dword_1065BC) )
  {
    gpio_export(dword_1065BC);
    gpio_direction(dword_1065BC, 1);
  }
  return gpio_write(dword_1065BC, 1);
}
// 1065BC: using guessed type int dword_1065BC;

//----- (0006751C) --------------------------------------------------------
int __fastcall set_bitmain_power_gpio_port(int result)
{
  dword_1065BC = result;
  return result;
}
// 1065BC: using guessed type int dword_1065BC;

//----- (0006752C) --------------------------------------------------------
int __fastcall pwm_init(unsigned int a1, int a2)
{
  int result; // r0
  char v4[2048]; // [sp+10h] [bp-1804h] BYREF
  char v5[4100]; // [sp+810h] [bp-1004h] BYREF

  if ( platform_inited )
  {
    if ( a1 > 1 )
    {
      strcpy(v4, "bad param\n");
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_pwm.c",
        171,
        "pwm_init",
        8,
        30,
        100,
        v5);
      return -3;
    }
    else
    {
      result = a1 + 1;
      dword_1199C0[2 * a1] = a2;
      algn_1199C4[8 * a1] = 1;
    }
  }
  else
  {
    strcpy(v4, "please init platform first!!\n");
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_pwm.c",
      171,
      "pwm_init",
      8,
      25,
      100,
      v5);
    return -2;
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119800: using guessed type int platform_inited;
// 1199C0: using guessed type int dword_1199C0[];
// 1199C4: using guessed type _BYTE[12];
// 11A7AC: using guessed type int g_zc;

//----- (00067684) --------------------------------------------------------
int __fastcall pwm_uninit(int a1)
{
  int result; // r0
  char v2[2048]; // [sp+10h] [bp-1808h] BYREF
  char v3[4104]; // [sp+810h] [bp-1008h] BYREF

  if ( a1 > 2 )
  {
    strcpy(v2, "bad param\n");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer"
             "-origin_godminer-new/backend/device/hal/platform/7007/7007_pwm.c",
             171,
             "pwm_uninit",
             10,
             41,
             100,
             v3);
  }
  else
  {
    result = a1 - 1;
    dword_1199C0[2 * result] = 0;
    algn_1199C4[8 * result] = 0;
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1199C0: using guessed type int dword_1199C0[];
// 1199C4: using guessed type _BYTE algn_1199C4[12];
// 11A7AC: using guessed type int g_zc;

//----- (00067744) --------------------------------------------------------
int __fastcall pwm_set(int a1, unsigned int a2)
{
  int v2; // r4
  unsigned int v4; // r5
  _DWORD s[512]; // [sp+10h] [bp-1804h] BYREF
  char v6[4100]; // [sp+810h] [bp-1004h] BYREF

  if ( a1 > 2 )
  {
    strcpy((char *)s, "bad param\n");
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_pwm.c",
      171,
      "pwm_set",
      7,
      62,
      100,
      v6);
    return -3;
  }
  else
  {
    v2 = a1 - 1;
    if ( a1 == 1 )
    {
      if ( a2 >= 0x64 )
        a2 = 100;
      v4 = (unsigned __int16)(dword_1199C0[0] * (100 - a2) / 0x64) | ((dword_1199C0[0] * a2 / 0x64) << 16);
      fpga_write(132, v4);
      fpga_write(160, v4);
      return v2;
    }
    else
    {
      snprintf((char *)s, 0x800u, "pwm type %d not supported\n", a1 - 1);
      V_LOCK();
      logfmt_raw(v6, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_pwm.c",
        171,
        "pwm_set",
        7,
        81,
        100,
        v6);
      return 0;
    }
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1199C0: using guessed type int dword_1199C0[];
// 11A7AC: using guessed type int g_zc;

//----- (000678D0) --------------------------------------------------------
int __fastcall pwm_get(int a1, int a2)
{
  int v2; // r4
  int v4; // r3
  int v5; // r12
  int v6; // r2
  int v7; // r0
  int v8; // r1
  char s[2048]; // [sp+10h] [bp-1804h] BYREF
  char v11[4100]; // [sp+810h] [bp-1004h] BYREF

  if ( a1 > 2 )
  {
    v2 = -3;
    strcpy(s, "bad param\n");
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, s);
    V_UNLOCK();
    v5 = 100;
    v6 = 101;
    v7 = g_zc;
    LOWORD(v8) = -26532;
  }
  else
  {
    v2 = a1 - 1;
    if ( a1 != 1 )
      return -5;
    fpga_read(132, (_DWORD *)a2);
    v4 = *(unsigned __int16 *)(a2 + 2);
    *(_DWORD *)a2 = v4;
    snprintf(s, 0x800u, "duty of fpga = 0x%x\n", v4);
    V_LOCK();
    logfmt_raw(v11, 0x1000u, v2, s);
    V_UNLOCK();
    v5 = 20;
    v6 = 109;
    v7 = g_zc;
    LOWORD(v8) = (unsigned __int16)"/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/"
                                   "release/build/godminer-origin_godminer-new/backend/device/hal/platform/7007/7007_pwm.c";
  }
  HIWORD(v8) = (unsigned int)"/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/releas"
                             "e/build/godminer-origin_godminer-new/backend/device/hal/platform/7007/7007_pwm.c" >> 16;
  zlog(v7, v8, 171, "pwm_get", 7, v6, v5, v11);
  return v2;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (000679F4) --------------------------------------------------------
int __fastcall sub_679F4(int a1, _DWORD *a2, int *a3, int *a4, int *a5)
{
  int v5; // r0
  int v6; // r12
  int v7; // r1
  int result; // r0
  char s[2048]; // [sp+10h] [bp-1800h] BYREF
  char v10[4080]; // [sp+810h] [bp-1000h] BYREF

  switch ( a1 )
  {
    case 0:
      v5 = 384;
      *a2 = 24;
      v6 = 400;
      v7 = 404;
      goto LABEL_3;
    case 1:
      v5 = 384;
      *a2 = 16;
      v6 = 408;
      v7 = 412;
      goto LABEL_3;
    case 2:
      v5 = 384;
      *a2 = 8;
      v6 = 416;
      v7 = 420;
      goto LABEL_3;
    case 3:
      result = 0;
      *a2 = 0;
      v6 = 424;
      v7 = 428;
      *a3 = 384;
      goto LABEL_4;
    case 4:
      v5 = 388;
      *a2 = 24;
      v6 = 432;
      v7 = 436;
      goto LABEL_3;
    case 5:
      v5 = 388;
      *a2 = 16;
      v6 = 440;
      v7 = 444;
      goto LABEL_3;
    case 6:
      v5 = 388;
      *a2 = 8;
      v6 = 448;
      v7 = 452;
      goto LABEL_3;
    case 7:
      result = 0;
      *a2 = 0;
      v6 = 456;
      v7 = 460;
      *a3 = 388;
      goto LABEL_4;
    case 8:
      v5 = 392;
      *a2 = 24;
      v6 = 464;
      v7 = 468;
      goto LABEL_3;
    case 9:
      v5 = 392;
      *a2 = 16;
      v6 = 472;
      v7 = 476;
      goto LABEL_3;
    case 10:
      v5 = 392;
      *a2 = 8;
      v6 = 608;
      v7 = 612;
      goto LABEL_3;
    case 11:
      result = 0;
      *a2 = 0;
      v6 = 616;
      v7 = 620;
      *a3 = 392;
      goto LABEL_4;
    case 12:
      v5 = 396;
      *a2 = 24;
      v6 = 624;
      v7 = 628;
      goto LABEL_3;
    case 13:
      v5 = 396;
      *a2 = 16;
      v6 = 632;
      v7 = 636;
LABEL_3:
      *a3 = v5;
      result = 0;
LABEL_4:
      *a4 = v6;
      *a5 = v7;
      break;
    default:
      snprintf(s, 0x800u, "%s: The uart %d is not supported!!!\n", "get_send_address_info", a1);
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_uart.c",
        172,
        "get_send_address_info",
        21,
        121,
        100,
        v10);
      result = -1;
      break;
  }
  return result;
}
// 67A08: control flows out of bounds to 67A0C
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00067C4C) --------------------------------------------------------
int __fastcall sub_67C4C(int a1)
{
  int result; // r0
  unsigned int v2; // [sp+14h] [bp-1808h] BYREF
  char s[2040]; // [sp+18h] [bp-1804h] BYREF
  char v4[4100]; // [sp+818h] [bp-1004h] BYREF

  v2 = 0;
  switch ( a1 )
  {
    case 0:
      fpga_read(496, &v2);
      result = HIWORD(v2) & 0x3FF;
      break;
    case 1:
      fpga_read(496, &v2);
      result = v2 & 0x3FF;
      break;
    case 2:
      fpga_read(500, &v2);
      result = HIWORD(v2) & 0x3FF;
      break;
    case 3:
      fpga_read(500, &v2);
      result = v2 & 0x3FF;
      break;
    case 4:
      fpga_read(504, &v2);
      result = HIWORD(v2) & 0x3FF;
      break;
    case 5:
      fpga_read(504, &v2);
      result = v2 & 0x3FF;
      break;
    case 6:
      fpga_read(508, &v2);
      result = HIWORD(v2) & 0x3FF;
      break;
    case 7:
      fpga_read(508, &v2);
      result = v2 & 0x3FF;
      break;
    case 8:
      fpga_read(512, &v2);
      result = HIWORD(v2) & 0x3FF;
      break;
    case 9:
      fpga_read(512, &v2);
      result = v2 & 0x3FF;
      break;
    case 10:
      fpga_read(516, &v2);
      result = HIWORD(v2) & 0x3FF;
      break;
    case 11:
      fpga_read(516, &v2);
      result = v2 & 0x3FF;
      break;
    case 12:
      fpga_read(520, &v2);
      result = HIWORD(v2) & 0x3FF;
      break;
    case 13:
      fpga_read(520, &v2);
      result = v2 & 0x3FF;
      break;
    default:
      snprintf(s, 0x800u, "%s: The uart%d is not supported!!!\n", "check_how_many_uart_data_in_fpga", a1);
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_uart.c",
        172,
        "check_how_many_uart_data_in_fpga",
        32,
        273,
        100,
        v4);
      result = 0;
      break;
  }
  return result;
}
// 67C68: control flows out of bounds to 67C6C
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00067E8C) --------------------------------------------------------
int __fastcall sub_67E8C(int a1)
{
  pthread_mutex_t *v1; // r7
  int v3; // r4
  unsigned int v4; // r3
  int v6; // r2
  int v7; // [sp+14h] [bp-1814h] BYREF
  int v8; // [sp+18h] [bp-1810h] BYREF
  int v9; // [sp+1Ch] [bp-180Ch] BYREF
  unsigned int v10; // [sp+20h] [bp-1808h] BYREF
  int v11; // [sp+24h] [bp-1804h] BYREF
  char s[2040]; // [sp+28h] [bp-1800h] BYREF
  char v13[4096]; // [sp+828h] [bp-1000h] BYREF

  v1 = (pthread_mutex_t *)((char *)&unk_1199D0 + 24 * a1);
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  pthread_mutex_lock(v1);
  if ( sub_679F4(a1, &v11, &v7, &v8, &v9) )
  {
    snprintf(s, 0x800u, "get_send_address_info error, chain_id = %d\n", a1);
    V_LOCK();
    logfmt_raw(v13, 0x1000u, 0, s);
    V_UNLOCK();
    v6 = 660;
LABEL_7:
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_uart.c",
      172,
      "clear_uart_tx_fifo",
      18,
      v6,
      100,
      v13);
  }
  else
  {
    v3 = 21;
    while ( 1 )
    {
      fpga_read(v7, &v10);
      v4 = (unsigned __int8)(v10 >> v11);
      v10 = v4;
      if ( v4 == 255 )
        break;
      printf("%s: waiting fpga uart%d clear send fifo space ...\n", "clear_uart_tx_fifo", a1);
      fpga_write(v8, v10 | 0x80000000);
      usleep(0xBB8u);
      if ( !--v3 )
      {
        snprintf(s, 0x800u, "%s: uart%d always dose not has enough send fifo space, break\n", "clear_uart_tx_fifo", a1);
        V_LOCK();
        logfmt_raw(v13, 0x1000u, 0, s);
        V_UNLOCK();
        v6 = 681;
        goto LABEL_7;
      }
    }
  }
  return pthread_mutex_unlock(v1);
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0006804C) --------------------------------------------------------
unsigned int __fastcall sub_6804C(int a1, int a2, unsigned int a3)
{
  unsigned int v6; // r5
  int v8; // r6
  int v9; // r0
  unsigned int v10; // r9
  int v11; // r4
  unsigned int v12; // r3
  int v13; // r4
  int v14; // r3
  unsigned int v15; // r1
  unsigned int v16; // r2
  unsigned int v17; // r2
  unsigned int v18; // [sp+14h] [bp-1808h] BYREF
  char s[2040]; // [sp+18h] [bp-1804h] BYREF
  char v20[4100]; // [sp+818h] [bp-1004h] BYREF

  v18 = 0;
  switch ( a1 )
  {
    case 0:
      v8 = 532;
      v9 = 528;
      goto LABEL_5;
    case 1:
      v8 = 540;
      v9 = 536;
      goto LABEL_5;
    case 2:
      v8 = 548;
      v9 = 544;
      goto LABEL_5;
    case 3:
      v8 = 556;
      v9 = 552;
      goto LABEL_5;
    case 4:
      v8 = 564;
      v9 = 560;
      goto LABEL_5;
    case 5:
      v8 = 572;
      v9 = 568;
      goto LABEL_5;
    case 6:
      v8 = 580;
      v9 = 576;
      goto LABEL_5;
    case 7:
      v8 = 588;
      v9 = 584;
      goto LABEL_5;
    case 8:
      v8 = 596;
      v9 = 592;
      goto LABEL_5;
    case 9:
      v8 = 604;
      v9 = 600;
      goto LABEL_5;
    case 10:
      v8 = 660;
      v9 = 656;
      goto LABEL_5;
    case 11:
      v8 = 668;
      v9 = 664;
      goto LABEL_5;
    case 12:
      v8 = 676;
      v9 = 672;
      goto LABEL_5;
    case 13:
      v8 = 684;
      v9 = 680;
LABEL_5:
      fpga_write(v9, a3 & 0x3FF | 0x80000000);
      v10 = a3 >> 2;
      if ( a3 >> 2 )
      {
        v11 = a2;
        do
        {
          v11 += 4;
          fpga_read(v8, &v18);
          v12 = v18;
          *(_BYTE *)(v11 - 1) = v18;
          *(_BYTE *)(v11 - 4) = HIBYTE(v12);
          *(_BYTE *)(v11 - 3) = BYTE2(v12);
          *(_BYTE *)(v11 - 2) = BYTE1(v12);
        }
        while ( a2 + 4 * v10 != v11 );
      }
      v13 = a3 & 3;
      v6 = a3 & 0xFFFFFFFC;
      if ( v13 )
      {
        fpga_read(v8, &v18);
        v14 = a2 + 4 * v10;
        if ( v13 == 2 )
        {
          v6 += 2;
          v17 = HIWORD(v18);
          *(_BYTE *)(a2 + 4 * v10) = HIBYTE(v18);
          *(_BYTE *)(v14 + 1) = v17;
        }
        else if ( v13 == 3 )
        {
          v6 += 3;
          v15 = HIWORD(v18);
          v16 = v18 >> 8;
          *(_BYTE *)(a2 + 4 * v10) = HIBYTE(v18);
          *(_BYTE *)(v14 + 1) = v15;
          *(_BYTE *)(v14 + 2) = v16;
        }
        else
        {
          ++v6;
          *(_BYTE *)(a2 + 4 * v10) = HIBYTE(v18);
        }
      }
      break;
    default:
      snprintf(s, 0x800u, "%s: The uart%d is not supported!!!\n", "get_read_address_info", a1);
      V_LOCK();
      v6 = 0;
      logfmt_raw(v20, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_uart.c",
        172,
        "get_read_address_info",
        21,
        207,
        100,
        v20);
      snprintf(s, 0x800u, "get_read_address_info error, chain_id = %d\n", a1);
      V_LOCK();
      logfmt_raw(v20, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_uart.c",
        172,
        "read_uart_data_in_fpga",
        22,
        285,
        100,
        v20);
      break;
  }
  return v6;
}
// 68070: control flows out of bounds to 68074
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00068330) --------------------------------------------------------
int uart_init()
{
  char v1[2048]; // [sp+10h] [bp-1804h] BYREF
  char v2[4100]; // [sp+810h] [bp-1004h] BYREF

  if ( platform_inited )
    return 0;
  strcpy(v1, "please init platform first!!\n");
  V_LOCK();
  logfmt_raw(v2, 0x1000u, 0, v1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/platform/7007/7007_uart.c",
    172,
    "uart_init",
    9,
    342,
    100,
    v2);
  return -1;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119800: using guessed type int platform_inited;
// 11A7AC: using guessed type int g_zc;

//----- (000683EC) --------------------------------------------------------
size_t __fastcall uart_send(int a1, const void *a2, size_t a3)
{
  pthread_mutex_t *v6; // r6
  size_t v7; // r3
  size_t v8; // r8
  _DWORD *v9; // r4
  int v10; // r3
  int v11; // r3
  _DWORD *v12; // r8
  int v13; // r1
  int v15; // [sp+14h] [bp-1914h] BYREF
  int v16; // [sp+18h] [bp-1910h] BYREF
  int v17; // [sp+1Ch] [bp-190Ch] BYREF
  size_t v18; // [sp+20h] [bp-1908h] BYREF
  int v19; // [sp+24h] [bp-1904h] BYREF
  _DWORD s[64]; // [sp+28h] [bp-1900h] BYREF
  char v21[2040]; // [sp+128h] [bp-1800h] BYREF
  _DWORD v22[1024]; // [sp+928h] [bp-1000h] BYREF

  memset(s, 0, sizeof(s));
  v6 = (pthread_mutex_t *)(24 * a1 + 1153488);
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  pthread_mutex_lock(v6);
  if ( sub_679F4(a1, &v19, &v15, &v16, &v17) )
  {
    snprintf(v21, 0x800u, "get_send_address_info error, chain_id = %d\n", a1);
    V_LOCK();
    logfmt_raw((char *)v22, 0x1000u, 0, v21);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_uart.c",
      172,
      "uart_send",
      9,
      408,
      100,
      v22);
    pthread_mutex_unlock(v6);
    return 0;
  }
  else
  {
    while ( 1 )
    {
      fpga_read(v15, &v18);
      v7 = (unsigned __int8)(v18 >> v19);
      v18 = v7;
      if ( v7 >= a3 )
        break;
      usleep(0);
    }
    fpga_read(v16, &v18);
    v18 = (unsigned __int8)(v18 >> v19);
    memcpy(s, a2, a3);
    v8 = a3 >> 2;
    if ( a3 >> 2 )
    {
      v9 = s;
      do
      {
        v10 = *((unsigned __int8 *)v9++ + 1);
        fpga_write(
          v17,
          (v10 << 16)
        | (*((unsigned __int8 *)v9 - 4) << 24)
        | *((unsigned __int8 *)v9 - 1)
        | (*((unsigned __int8 *)v9 - 2) << 8));
      }
      while ( &s[v8] != v9 );
    }
    v11 = a3 & 3;
    if ( (a3 & 3) != 0 )
    {
      v12 = &v22[v8];
      v13 = *((unsigned __int8 *)v12 - 2304) << 24;
      if ( v11 == 2 )
      {
        v13 |= *((unsigned __int8 *)v12 - 2303) << 16;
      }
      else if ( v11 == 3 )
      {
        v13 |= (*((unsigned __int8 *)v12 - 2302) << 8) | (*((unsigned __int8 *)v12 - 2303) << 16);
      }
      fpga_write(v17, v13);
    }
    fpga_write(v16, a3 | 0x80000000);
    pthread_mutex_unlock(v6);
    return a3;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00068628) --------------------------------------------------------
unsigned int __fastcall uart_receive(int a1, int a2, unsigned int a3)
{
  pthread_mutex_t *v6; // r5
  unsigned int v7; // r0
  unsigned int v9; // r4

  v6 = (pthread_mutex_t *)((char *)&unk_119B50 + 24 * a1);
  pthread_mutex_lock(v6);
  v7 = sub_67C4C((unsigned __int8)a1);
  if ( v7 < a3 )
    a3 = v7;
  if ( a3 )
  {
    v9 = sub_6804C(a1, a2, a3);
    pthread_mutex_unlock(v6);
    return v9;
  }
  else
  {
    pthread_mutex_unlock(v6);
    return 0;
  }
}

//----- (0006869C) --------------------------------------------------------
int __fastcall uart_set_config(int a1, int a2, int *a3)
{
  pthread_mutex_t *v5; // r6
  char s[2048]; // [sp+10h] [bp-1800h] BYREF
  char v8[4096]; // [sp+810h] [bp-1000h] BYREF

  if ( !a3 )
    return -3;
  v5 = (pthread_mutex_t *)((char *)&unk_1199D0 + 24 * a1);
  pthread_mutex_lock(v5);
  if ( a2 )
  {
    snprintf(s, 0x800u, "unknown set config type = %d\n", a2);
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_uart.c",
      172,
      "uart_set_config",
      15,
      576,
      80,
      v8);
  }
  else
  {
    fpga_write(60, *a3);
  }
  pthread_mutex_unlock(v5);
  return -5;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00068778) --------------------------------------------------------
int __fastcall uart_get_config(int a1, int a2, _DWORD *a3, int a4)
{
  _BOOL4 v4; // r3
  int v5; // r5
  pthread_mutex_t *v8; // r7
  char s[2048]; // [sp+10h] [bp-1804h] BYREF
  char v11[4100]; // [sp+810h] [bp-1004h] BYREF

  v4 = a4 != 0;
  if ( a3 )
    v5 = v4;
  else
    v5 = 1;
  if ( v5 )
    return -3;
  v8 = (pthread_mutex_t *)((char *)&unk_1199D0 + 24 * a1);
  pthread_mutex_lock(v8);
  if ( !a2 )
  {
    *(_DWORD *)v11 = 0;
    fpga_read(60, v11);
    *a3 = *(_DWORD *)v11;
    MEMORY[0] = 0;
    __und(0);
  }
  snprintf(s, 0x800u, "unknown set config type = %d\n", a2);
  V_LOCK();
  logfmt_raw(v11, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/platform/7007/7007_uart.c",
    172,
    "uart_get_config",
    15,
    600,
    80,
    v11);
  pthread_mutex_unlock(v8);
  return -5;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00068880) --------------------------------------------------------
int __fastcall high_speed_uart_set_config(int a1, int a2, _DWORD *a3)
{
  pthread_mutex_t *v5; // r6
  char s[2048]; // [sp+10h] [bp-1800h] BYREF
  char v8[4096]; // [sp+810h] [bp-1000h] BYREF

  if ( !a3 )
    return -3;
  v5 = (pthread_mutex_t *)((char *)&unk_1199D0 + 24 * a1);
  pthread_mutex_lock(v5);
  if ( a2 )
  {
    snprintf(s, 0x800u, "unknown set config type = %d\n", a2);
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_uart.c",
      172,
      "high_speed_uart_set_config",
      26,
      620,
      80,
      v8);
  }
  else
  {
    fpga_write(60, *a3 << 16);
  }
  pthread_mutex_unlock(v5);
  return -5;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00068960) --------------------------------------------------------
int __fastcall high_speed_uart_get_config(int a1, int a2, int *a3, int a4)
{
  _BOOL4 v4; // r3
  int v5; // r6
  pthread_mutex_t *v8; // r5
  char s[2048]; // [sp+10h] [bp-1804h] BYREF
  char v11[4100]; // [sp+810h] [bp-1004h] BYREF

  v4 = a4 != 0;
  if ( a3 )
    v5 = v4;
  else
    v5 = 1;
  if ( v5 )
    return -3;
  v8 = (pthread_mutex_t *)((char *)&unk_1199D0 + 24 * a1);
  pthread_mutex_lock(v8);
  if ( !a2 )
  {
    *(_DWORD *)v11 = 0;
    fpga_read(60, v11);
    *a3 = v11[2] & 0x3F;
    MEMORY[0] = 0;
    __und(0);
  }
  snprintf(s, 0x800u, "unknown set config type = %d\n", a2);
  V_LOCK();
  logfmt_raw(v11, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/platform/7007/7007_uart.c",
    172,
    "high_speed_uart_get_config",
    26,
    644,
    80,
    v11);
  pthread_mutex_unlock(v8);
  return -5;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00068A70) --------------------------------------------------------
int __fastcall clear_uart_rx_fifo(int a1)
{
  pthread_mutex_t *v2; // r4
  size_t v3; // r0
  unsigned int v4; // r6
  void *v5; // r0
  void *v6; // r7
  unsigned int v7; // r0
  char s[2048]; // [sp+10h] [bp-1804h] BYREF
  char v10[4100]; // [sp+810h] [bp-1004h] BYREF

  v2 = (pthread_mutex_t *)((char *)&unk_119B50 + 24 * a1);
  pthread_mutex_lock(v2);
  v3 = sub_67C4C((unsigned __int8)a1);
  v4 = v3;
  if ( !v3 )
    return pthread_mutex_unlock(v2);
  v5 = malloc(v3);
  v6 = v5;
  if ( v5 )
  {
    v7 = sub_6804C(a1, (int)v5, v4);
    if ( v4 != v7 )
    {
      snprintf(s, 0x800u, "%s: uart%d clear rx fifo error. nbytes = %d, len = %d\n", "clear_uart_rx_fifo", a1, v4, v7);
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_uart.c",
        172,
        "clear_uart_rx_fifo",
        18,
        718,
        100,
        v10);
    }
    free(v6);
    usleep(0x2710u);
    return pthread_mutex_unlock(v2);
  }
  snprintf(s, 0x800u, "%s: uart%d malloc buffer error\n", "clear_uart_rx_fifo", a1);
  V_LOCK();
  logfmt_raw(v10, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/platform/7007/7007_uart.c",
    172,
    "clear_uart_rx_fifo",
    18,
    709,
    100,
    v10);
  usleep(0x7A120u);
  return pthread_mutex_unlock(v2);
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00068C10) --------------------------------------------------------
int __fastcall uart_flush(int a1)
{
  char s[2048]; // [sp+10h] [bp-1804h] BYREF
  char v4[4100]; // [sp+810h] [bp-1004h] BYREF

  snprintf(s, 0x800u, "flush uart %d\n", a1);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/platform/7007/7007_uart.c",
    172,
    "uart_flush",
    10,
    737,
    20,
    v4);
  clear_uart_rx_fifo(a1);
  usleep(0x2710u);
  sub_67E8C(a1);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00068CC0) --------------------------------------------------------
int __fastcall uart_flush_tx(int a1)
{
  sub_67E8C(a1);
  return 0;
}

//----- (00068CD0) --------------------------------------------------------
int __fastcall uart_flush_rx(int a1)
{
  clear_uart_rx_fifo(a1);
  return 0;
}

//----- (00068CE0) --------------------------------------------------------
int __fastcall uart_get_readable_byte_num(int a1)
{
  unsigned __int8 v1; // r5
  pthread_mutex_t *v2; // r4
  int v3; // r5

  v1 = a1;
  v2 = (pthread_mutex_t *)((char *)&unk_119B50 + 24 * a1);
  pthread_mutex_lock(v2);
  v3 = sub_67C4C(v1);
  pthread_mutex_unlock(v2);
  return v3;
}

//----- (00068D1C) --------------------------------------------------------
int __fastcall sub_68D1C(_DWORD *a1, _DWORD *a2)
{
  return *a1 - *a2;
}

//----- (00068D2C) --------------------------------------------------------
int sub_68D2C()
{
  _DWORD *v0; // r5
  int v1; // r2
  int v2; // r0
  int v3; // r3
  int *v4; // r0
  int v5; // r3
  int *v6; // r4
  _DWORD v8[3]; // [sp+4h] [bp-Ch] BYREF

  while ( dword_119CD0 )
  {
    if ( !pthread_mutex_lock(&stru_119CD4) )
    {
      v0 = new_iterator_c_map(dword_119CEC);
      if ( ((int (*)(void))*v0)() )
      {
        do
        {
          v4 = (int *)((int (*)(void))v0[2])();
          v5 = v4[1];
          v6 = v4;
          if ( v5 )
          {
            v1 = *v4;
            v2 = v4[2];
          }
          else
          {
            gpio_write(***(_DWORD ***)(v0[5] + 16), *((unsigned __int8 *)v4 + 8));
            v5 = *v6;
            v2 = v6[2] != 1;
            v1 = *v6;
            v6[2] = v2;
          }
          v3 = v5 - 200;
          v6[1] = v3;
          v8[0] = v1;
          v8[1] = v3;
          v8[2] = v2;
          ((void (__fastcall *)(_DWORD *, _DWORD *, int))v0[1])(v0, v8, 12);
          free(v6);
        }
        while ( ((int (__fastcall *)(_DWORD *))*v0)(v0) );
      }
      delete_iterator_c_map(v0);
      pthread_mutex_unlock(&stru_119CD4);
    }
    usleep((__useconds_t)&loc_30D40);
  }
  return 0;
}
// 119CD0: using guessed type int dword_119CD0;
// 119CEC: using guessed type int dword_119CEC;

//----- (00068E54) --------------------------------------------------------
int *__fastcall sub_68E54(int *result, int *a2)
{
  int *v3; // [sp+14h] [bp-1808h] BYREF
  char s[2040]; // [sp+18h] [bp-1804h] BYREF
  char v5[4100]; // [sp+818h] [bp-1004h] BYREF

  v3 = result;
  if ( a2 )
  {
    result = exists_c_map(a2, (int)&v3);
    if ( result == (int *)1 )
    {
      snprintf(s, 0x800u, "remove %d from flicker list\n", v3);
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_ui.c",
        170,
        "remove_port_form_gpio_map",
        25,
        205,
        20,
        v5);
      return (int *)remove_c_map(a2, (int)&v3);
    }
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00068F20) --------------------------------------------------------
int __fastcall sub_68F20(int a1)
{
  char s[2048]; // [sp+10h] [bp-1800h] BYREF
  char v3[4096]; // [sp+810h] [bp-1000h] BYREF

  snprintf(s, 0x800u, "gpio port %d is not a supported key\n", a1);
  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, s);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-o"
           "rigin_godminer-new/backend/device/hal/platform/7007/7007_ui.c",
           170,
           "gpio_key_callback",
           17,
           134,
           80,
           v3);
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00068FB0) --------------------------------------------------------
int __fastcall sub_68FB0(int a1, int a2)
{
  int v2; // r7
  int *v3; // r4
  int (__fastcall *v5)(int, int); // r3
  int v6; // t1
  int result; // r0
  int v8; // r1

  if ( a1 == 921 )
  {
    v2 = 256;
  }
  else
  {
    if ( a1 != 943 )
      return sub_68F20(a1);
    v2 = 257;
  }
  v3 = (int *)&off_119CF0;
  do
  {
    v6 = *v3++;
    v5 = (int (__fastcall *)(int, int))v6;
    result = v2;
    if ( v6 )
    {
      v8 = a2;
      if ( a2 )
        v8 = 1;
      result = v5(v2, v8);
    }
  }
  while ( v3 != &dword_119D04 );
  return result;
}
// 119CF0: using guessed type _UNKNOWN *off_119CF0;
// 119D04: using guessed type int dword_119D04;

//----- (00069018) --------------------------------------------------------
int __fastcall sub_69018(int a1, int a2)
{
  int v3; // r7
  int *v4; // r11
  int v5; // r4
  int v7; // [sp+14h] [bp-1808h] BYREF
  char s[2040]; // [sp+18h] [bp-1804h] BYREF
  _DWORD v9[1025]; // [sp+818h] [bp-1004h] BYREF

  if ( a1 == 1 )
  {
    v3 = 941;
  }
  else
  {
    if ( a1 != 2 )
    {
      strcpy(s, "unsuported gpio port\n");
      V_LOCK();
      logfmt_raw((char *)v9, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_ui.c",
        170,
        "gpio_ctrl_ui",
        12,
        273,
        100,
        v9);
      return -1;
    }
    v3 = 942;
  }
  snprintf(s, 0x800u, "ui type = %d, port = %d, status = %d\n", a1, v3, a2);
  V_LOCK();
  logfmt_raw((char *)v9, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/platform/7007/7007_ui.c",
    170,
    "gpio_ctrl_ui",
    12,
    277,
    20,
    v9);
  if ( pthread_mutex_lock(&stru_119CD4) )
  {
    strcpy(s, "failed to api lock\n");
    V_LOCK();
    logfmt_raw((char *)v9, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_ui.c",
      170,
      "gpio_ctrl_ui",
      12,
      280,
      100,
      v9);
    return -1;
  }
  v4 = (int *)dword_119CEC;
  if ( a2 == 1 )
  {
    sub_68E54((int *)v3, (int *)dword_119CEC);
    v5 = gpio_write(v3, 0);
    pthread_mutex_unlock(&stru_119CD4);
  }
  else if ( a2 == 2 )
  {
    v7 = v3;
    if ( dword_119CEC )
    {
      v5 = -1;
      if ( exists_c_map((int *)dword_119CEC, (int)&v7) )
      {
        snprintf(s, 0x800u, "port %d already exist in map\n", v7);
        V_LOCK();
        logfmt_raw((char *)v9, 0x1000u, 0, s);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/device/hal/platform/7007/7007_ui.c",
          170,
          "add_port_to_gpio_map",
          20,
          227,
          20,
          v9);
      }
      else
      {
        snprintf(s, 0x800u, "add %d to flicker map with interval %d\n", v7, 200);
        V_LOCK();
        logfmt_raw((char *)v9, 0x1000u, 0, s);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/device/hal/platform/7007/7007_ui.c",
          170,
          "add_port_to_gpio_map",
          20,
          221,
          20,
          v9);
        v9[0] = 200;
        v9[1] = 0;
        v9[2] = 1;
        insert_c_map(v4, &v7, 4u, v9, 0xCu);
      }
    }
    else
    {
      v5 = -1;
    }
    pthread_mutex_unlock(&stru_119CD4);
  }
  else
  {
    sub_68E54((int *)v3, (int *)dword_119CEC);
    v5 = gpio_write(v3, 1);
    pthread_mutex_unlock(&stru_119CD4);
  }
  return v5;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119CEC: using guessed type int dword_119CEC;
// 11A7AC: using guessed type int g_zc;

//----- (000693B0) --------------------------------------------------------
int ui_init()
{
  int v0; // r5
  char v2[2048]; // [sp+10h] [bp-1800h] BYREF
  char v3[4096]; // [sp+810h] [bp-1000h] BYREF

  if ( dword_119D04 )
    return 0;
  if ( gpio_init() )
  {
    v0 = -1;
    strcpy(v2, "gpio init failed\n");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_ui.c",
      170,
      "ui_init",
      7,
      152,
      100,
      v3);
    return v0;
  }
  gpio_export(941);
  gpio_export(942);
  gpio_export(921);
  gpio_export(943);
  gpio_reg_callback(921, 430000);
  gpio_reg_callback(943, 430000);
  pthread_mutex_init(&stru_119CD4, 0);
  off_119CF0 = 0;
  dword_119CF4 = 0;
  dword_119CF8 = 0;
  dword_119CFC = 0;
  dword_119D00 = 0;
  dword_119CEC = (int)new_c_map(429340, 0, 0);
  dword_119CD0 = 1;
  pthread_create((pthread_t *)&dword_119D08, 0, (void *(*)(void *))sub_68D2C, 0);
  dword_119D04 = 1;
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119CD0: using guessed type int dword_119CD0;
// 119CEC: using guessed type int dword_119CEC;
// 119CF0: using guessed type _UNKNOWN *off_119CF0;
// 119CF4: using guessed type int dword_119CF4;
// 119CF8: using guessed type int dword_119CF8;
// 119CFC: using guessed type int dword_119CFC;
// 119D00: using guessed type int dword_119D00;
// 119D04: using guessed type int dword_119D04;
// 119D08: using guessed type int dword_119D08;
// 11A7AC: using guessed type int g_zc;

//----- (00069520) --------------------------------------------------------
int ui_uninit()
{
  int result; // r0

  if ( dword_119D04 )
  {
    dword_119CD0[0] = 0;
    pthread_join(dword_119D08, 0);
    delete_c_map((void (__fastcall ***)(_DWORD))dword_119CEC);
    pthread_mutex_destroy(&stru_119CD4);
    gpio_unreg_callback(921, 430000);
    gpio_unreg_callback(943, 430000);
    gpio_unexport(941);
    gpio_unexport(942);
    gpio_unexport(921);
    gpio_unexport(943);
    result = gpio_uninit();
    dword_119D04 = 0;
  }
  return result;
}
// 119CD0: using guessed type int dword_119CD0[];
// 119CEC: using guessed type int dword_119CEC;
// 119D04: using guessed type int dword_119D04;
// 119D08: using guessed type int dword_119D08;

//----- (000695A8) --------------------------------------------------------
int red_led_on()
{
  return sub_69018(1, 0);
}

//----- (000695B4) --------------------------------------------------------
int red_led_off()
{
  return sub_69018(1, 1);
}

//----- (000695C0) --------------------------------------------------------
int red_led_flicker()
{
  return sub_69018(1, 2);
}

//----- (000695CC) --------------------------------------------------------
int green_led_on()
{
  return sub_69018(2, 0);
}

//----- (000695D8) --------------------------------------------------------
int green_led_off()
{
  return sub_69018(2, 1);
}

//----- (000695E4) --------------------------------------------------------
int green_led_flicker()
{
  return sub_69018(2, 2);
}

//----- (000695F0) --------------------------------------------------------
int beeper_on()
{
  return sub_69018(16, 0);
}

//----- (000695FC) --------------------------------------------------------
int beeper_off()
{
  return sub_69018(16, 1);
}

//----- (00069608) --------------------------------------------------------
int beeper_flicker()
{
  return sub_69018(16, 2);
}

//----- (00069614) --------------------------------------------------------
int __fastcall reg_key_callback(int a1)
{
  int v2; // r5
  _DWORD *v3; // r2
  int v4; // r3
  char v7[2048]; // [sp+10h] [bp-1800h] BYREF
  char v8[4096]; // [sp+810h] [bp-1000h] BYREF

  v2 = pthread_mutex_lock(&stru_119CD4);
  if ( v2 )
  {
    v2 = -1;
    strcpy(v7, "failed to api lock\n");
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, v7);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_ui.c",
      170,
      "reg_key_callback",
      16,
      398,
      100,
      v8);
  }
  else
  {
    v3 = &off_119CF0;
    v4 = 0;
    while ( *v3++ )
    {
      if ( ++v4 == 5 )
      {
        v2 = -2;
        strcpy(v7, "no more listener available\n");
        V_LOCK();
        logfmt_raw(v8, 0x1000u, 0, v7);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/device/hal/platform/7007/7007_ui.c",
          170,
          "reg_key_callback",
          16,
          414,
          100,
          v8);
        goto LABEL_7;
      }
    }
    dword_119CD0[v4 + 8] = a1;
LABEL_7:
    pthread_mutex_unlock(&stru_119CD4);
  }
  return v2;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119CD0: using guessed type int dword_119CD0[];
// 119CF0: using guessed type _UNKNOWN *off_119CF0;
// 11A7AC: using guessed type int g_zc;

//----- (00069784) --------------------------------------------------------
int __fastcall unreg_key_callback(int a1)
{
  int v2; // r0
  int *v3; // r3
  int v4; // t1
  char v6[2048]; // [sp+10h] [bp-1804h] BYREF
  char v7[4100]; // [sp+810h] [bp-1004h] BYREF

  v2 = pthread_mutex_lock(&stru_119CD4);
  if ( v2 )
  {
    strcpy(v6, "failed to api lock\n");
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, v6);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_ui.c",
      170,
      "unreg_key_callback",
      18,
      434,
      100,
      v7);
    return -1;
  }
  else
  {
    v3 = (int *)&off_119CF0;
    while ( 1 )
    {
      v4 = *v3++;
      if ( a1 == v4 )
        break;
      if ( ++v2 == 5 )
      {
        strcpy(v6, "listener not registered before\n");
        V_LOCK();
        logfmt_raw(v7, 0x1000u, 0, v6);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/device/hal/platform/7007/7007_ui.c",
          170,
          "unreg_key_callback",
          18,
          448,
          80,
          v7);
        goto LABEL_7;
      }
    }
    dword_119CD0[v2 + 8] = 0;
LABEL_7:
    pthread_mutex_unlock(&stru_119CD4);
    return 0;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119CD0: using guessed type int dword_119CD0[];
// 119CF0: using guessed type _UNKNOWN *off_119CF0;
// 11A7AC: using guessed type int g_zc;

//----- (000698F0) --------------------------------------------------------
int __fastcall lcd_show_result(char a1, int a2, unsigned int a3)
{
  int v6; // r0
  int v7; // r4
  _DWORD s[512]; // [sp+10h] [bp-1804h] BYREF
  char v10[4100]; // [sp+810h] [bp-1004h] BYREF

  if ( pthread_mutex_lock(&stru_119CD4) )
  {
    v7 = -4;
    strcpy((char *)s, "failed to api lock\n");
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_ui.c",
      170,
      "lcd_show_result",
      15,
      470,
      100,
      v10);
  }
  else
  {
    v6 = dword_1065C0;
    if ( dword_1065C0 < 0 )
    {
      dword_1065C0 = lcd_init((int)lcd_path);
      lcd_clear(dword_1065C0);
      v6 = dword_1065C0;
    }
    if ( v6 <= 0 )
    {
      snprintf((char *)s, 0x800u, "failed to init %s\n", lcd_path);
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, s);
      V_UNLOCK();
      v7 = -1;
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_ui.c",
        170,
        "lcd_show_result",
        15,
        486,
        100,
        v10);
    }
    else
    {
      v7 = lcd_write(v6, a1, a2, a3);
    }
    pthread_mutex_unlock(&stru_119CD4);
  }
  return v7;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1065C0: using guessed type int dword_1065C0;
// 1065C4: using guessed type char *lcd_path;
// 11A7AC: using guessed type int g_zc;

//----- (00069A78) --------------------------------------------------------
int lcd_clear_result()
{
  char v1[2048]; // [sp+10h] [bp-1800h] BYREF
  char v2[4096]; // [sp+810h] [bp-1000h] BYREF

  if ( pthread_mutex_lock(&stru_119CD4) )
  {
    strcpy(v1, "failed to api lock\n");
    V_LOCK();
    logfmt_raw(v2, 0x1000u, 0, v1);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer"
             "-origin_godminer-new/backend/device/hal/platform/7007/7007_ui.c",
             170,
             "lcd_clear_result",
             16,
             501,
             100,
             v2);
  }
  else
  {
    if ( dword_1065C0 > 0 )
      lcd_clear(dword_1065C0);
    return pthread_mutex_unlock(&stru_119CD4);
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1065C0: using guessed type int dword_1065C0;
// 11A7AC: using guessed type int g_zc;

//----- (00069E70) --------------------------------------------------------
int sub_69E70()
{
  int v0; // r8
  int v1; // r3
  int v2; // r7
  int v3; // r4
  int v4; // r5
  void *v5; // r9
  int v6; // r2
  int v7; // r0
  int v8; // r1
  _DWORD *v9; // r8
  int v11; // r9
  int v12; // r4
  int v13; // r3
  int v14; // r5
  void *v15; // r0
  char s[2048]; // [sp+10h] [bp-1804h] BYREF
  char v17[4100]; // [sp+810h] [bp-1004h] BYREF

  if ( dword_119D0C[0] || (dword_119D0C[0] = (int)calloc(1u, 0x54u)) != 0 )
  {
    v0 = dword_119D10;
    if ( dword_119D10 <= 0 )
      return 0;
    v1 = 0;
    v2 = dword_119D0C[0];
    LOBYTE(v3) = 0;
    while ( 1 )
    {
      v4 = dword_119D0C[v1 + 2];
      if ( !*(_DWORD *)(v2 + 4 * v4) )
      {
        v5 = calloc(1u, 0x43u);
        *(_DWORD *)(v2 + 4 * v4) = v5;
        if ( !v5 )
          break;
      }
      v3 = (unsigned __int8)(v3 + 1);
      v1 = v3;
      if ( v3 >= v0 )
        return 0;
    }
    snprintf(s, 0x800u, "No memory for configuraion for chain %d.\n", v4);
    V_LOCK();
    logfmt_raw(v17, 0x1000u, 0, s);
    V_UNLOCK();
    v6 = 215;
    v7 = g_zc;
    LOWORD(v8) = (unsigned __int16)"/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/"
                                   "release/build/godminer-origin_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c";
  }
  else
  {
    strcpy(s, "No memory for configuraion.\n");
    V_LOCK();
    logfmt_raw(v17, 0x1000u, 0, s);
    V_UNLOCK();
    v6 = 202;
    v7 = g_zc;
    LOWORD(v8) = -23880;
  }
  HIWORD(v8) = (unsigned int)"/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/releas"
                             "e/build/godminer-origin_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c" >> 16;
  zlog(v7, v8, 170, "_alloc_memory", 13, v6, 100, v17);
  v9 = (_DWORD *)dword_119D0C[0];
  if ( !dword_119D0C[0] )
    return -1;
  v11 = dword_119D10;
  if ( dword_119D10 > 0 )
  {
    LOBYTE(v12) = 0;
    v13 = 0;
    do
    {
      v14 = dword_119D0C[v13 + 2];
      v15 = (void *)v9[v14];
      if ( v15 )
      {
        free(v15);
        v9[v14] = 0;
      }
      v12 = (unsigned __int8)(v12 + 1);
      v13 = v12;
    }
    while ( v11 > v12 );
  }
  free(v9);
  dword_119D0C[0] = 0;
  return -1;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119D0C: using guessed type int dword_119D0C[];
// 119D10: using guessed type int dword_119D10;
// 11A7AC: using guessed type int g_zc;

//----- (0006A070) --------------------------------------------------------
int __fastcall sub_6A070(int a1, void *a2)
{
  const char *v4; // r5
  size_t v5; // r0
  char s[2048]; // [sp+10h] [bp-1804h] BYREF
  char v7[4100]; // [sp+810h] [bp-1004h] BYREF

  if ( dword_119D0C[0] && *(_BYTE *)(dword_119D0C[0] + 80) )
  {
    v4 = *(const char **)(*(_DWORD *)(dword_119D0C[0] + 4 * a1) + 51);
    v5 = strlen(v4);
    memcpy(a2, v4, v5);
    return 0;
  }
  else
  {
    snprintf(s, 0x800u, "%s: g_eeprom_data is not ready, chain = %d.\n", "get_miner_type", a1);
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
      170,
      "get_miner_type",
      14,
      794,
      100,
      v7);
    return 0;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119D0C: using guessed type int dword_119D0C[];
// 11A7AC: using guessed type int g_zc;

//----- (0006A160) --------------------------------------------------------
int __fastcall sub_6A160(int a1, char *s)
{
  char sa[2048]; // [sp+10h] [bp-1800h] BYREF
  char v4[4096]; // [sp+810h] [bp-1000h] BYREF

  if ( dword_119D0C[0] && *(_BYTE *)(dword_119D0C[0] + 80) )
  {
    sprintf(
      s,
      "%x%02x",
      *(unsigned __int8 *)(*(_DWORD *)(dword_119D0C[0] + 4 * a1) + 31),
      *(unsigned __int8 *)(*(_DWORD *)(dword_119D0C[0] + 4 * a1) + 32));
    return 0;
  }
  else
  {
    snprintf(sa, 0x800u, "%s: g_eeprom_data is not ready, chain = %d.\n", "get_pcb_version", a1);
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, sa);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
      170,
      "get_pcb_version",
      15,
      771,
      100,
      v4);
    return 255;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119D0C: using guessed type int dword_119D0C[];
// 11A7AC: using guessed type int g_zc;

//----- (0006A24C) --------------------------------------------------------
int __fastcall sub_6A24C(int a1, char *s)
{
  char sa[2048]; // [sp+10h] [bp-1800h] BYREF
  char v4[4096]; // [sp+810h] [bp-1000h] BYREF

  if ( dword_119D0C[0] && *(_BYTE *)(dword_119D0C[0] + 80) )
  {
    sprintf(
      s,
      "%x%x",
      *(unsigned __int8 *)(*(_DWORD *)(dword_119D0C[0] + 4 * a1) + 33),
      *(unsigned __int8 *)(*(_DWORD *)(dword_119D0C[0] + 4 * a1) + 34));
    return 0;
  }
  else
  {
    snprintf(sa, 0x800u, "%s: g_eeprom_data is not ready, chain = %d.\n", "get_bom_version", a1);
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, sa);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
      170,
      "get_bom_version",
      15,
      782,
      100,
      v4);
    return 255;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119D0C: using guessed type int dword_119D0C[];
// 11A7AC: using guessed type int g_zc;

//----- (0006A338) --------------------------------------------------------
int __fastcall sub_6A338(int a1)
{
  char s[2048]; // [sp+10h] [bp-1804h] BYREF
  char v3[4100]; // [sp+810h] [bp-1004h] BYREF

  snprintf(s, 0x800u, "%s: Bad eeprom param, input chain is %d\n", "eeprom_open", a1);
  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
    170,
    "eeprom_open",
    11,
    50,
    100,
    v3);
  return -2147483391;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0006A3D0) --------------------------------------------------------
int __fastcall eeprom_open(unsigned int a1)
{
  unsigned int v1; // r5
  int *v2; // r2
  int result; // r0
  int *v5; // r4
  unsigned int v6; // [sp+0h] [bp-Ch] BYREF
  __int16 v7; // [sp+4h] [bp-8h]
  char v8; // [sp+6h] [bp-6h]
  char v9; // [sp+7h] [bp-5h]

  if ( a1 > 0xF )
    return sub_6A338(a1);
  v1 = 2 * a1;
  v2 = &dword_119D0C[2 * a1];
  result = v2[18];
  if ( !result || !v2[19] )
  {
    v6 = a1;
    v9 = a1;
    v7 = 0;
    v8 = 10;
    result = iic_init((int)&v6);
    if ( result >= 0 )
    {
      v5 = &dword_119D0C[v1];
      v5[18] = result;
      v5[19] = 1;
    }
  }
  return result;
}
// 119D0C: using guessed type int dword_119D0C[];

//----- (0006A450) --------------------------------------------------------
int *__fastcall eeprom_close(unsigned int a1)
{
  int v1; // r4
  int *v2; // r3
  int *result; // r0
  char s[2048]; // [sp+10h] [bp-1804h] BYREF
  char v5[4100]; // [sp+810h] [bp-1004h] BYREF

  if ( a1 > 0xF )
  {
    snprintf(s, 0x800u, "%s: Bad eeprom param, input chain is %d\n", "eeprom_close", a1);
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, s);
    V_UNLOCK();
    return (int *)zlog(
                    g_zc,
                    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/g"
                    "odminer-origin_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
                    170,
                    "eeprom_close",
                    12,
                    74,
                    100,
                    v5);
  }
  else
  {
    v1 = 2 * a1;
    v2 = &dword_119D0C[2 * a1];
    result = (int *)v2[18];
    if ( result || v2[19] )
    {
      iic_uninit((int)result);
      result = &dword_119D0C[v1];
      result[18] = 0;
      result[19] = 0;
    }
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119D0C: using guessed type int dword_119D0C[];
// 11A7AC: using guessed type int g_zc;

//----- (0006A534) --------------------------------------------------------
int __fastcall eeprom_write(unsigned int a1, unsigned __int8 a2, int a3, int a4)
{
  int v5; // r9
  int v9; // r7
  int v10; // r0
  int v11; // r3
  int v12; // r10
  unsigned __int8 v14; // [sp+17h] [bp-1805h] BYREF
  char s[2040]; // [sp+18h] [bp-1804h] BYREF
  char v16[4100]; // [sp+818h] [bp-1004h] BYREF

  if ( a1 > 0xF )
  {
    snprintf(s, 0x800u, "%s: Bad eeprom param, input chain is %d\n", "eeprom_write", a1);
    V_LOCK();
    logfmt_raw(v16, 0x1000u, 0, s);
    V_UNLOCK();
    v12 = -2147483391;
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
      170,
      "eeprom_write",
      12,
      91,
      100,
      v16);
    return v12;
  }
  v5 = 8 * a1;
  if ( !dword_119D58[2 * a1] )
  {
    v12 = eeprom_open(a1);
    if ( v12 < 0 )
    {
      snprintf(s, 0x800u, "%s: auto exec eeprom_open, but chain %d open eeprom failed\n", "eeprom_write", a1);
      V_LOCK();
      logfmt_raw(v16, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
        170,
        "eeprom_write",
        12,
        96,
        100,
        v16);
      return v12;
    }
  }
  if ( a4 )
  {
    v9 = a3 + a4;
    while ( 1 )
    {
      v10 = *(_DWORD *)(v5 + 1154388);
      v11 = a3;
      v14 = a2;
      ++a3;
      ++a2;
      if ( iic_write_reg(v10, &v14, 1, v11, 1) != 1 )
        break;
      if ( v9 == a3 )
        goto LABEL_10;
    }
    v12 = -2147483392;
    snprintf(s, 0x800u, "fail to write eeprom by iic, chain:%d, addr: %d", a1, v14);
    V_LOCK();
    logfmt_raw(v16, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
      170,
      "eeprom_write",
      12,
      116,
      100,
      v16);
    return v12;
  }
LABEL_10:
  sleep(1u);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119D58: using guessed type _DWORD dword_119D58[32];
// 11A7AC: using guessed type int g_zc;

//----- (0006A794) --------------------------------------------------------
int __fastcall eeprom_read(unsigned int a1, unsigned __int8 a2, int a3, int a4)
{
  int v5; // r6
  int v8; // r11
  int v9; // r6
  int v10; // r7
  void *v11; // r0
  int v12; // r3
  int v13; // r11
  unsigned __int8 v16; // [sp+1Fh] [bp-1805h] BYREF
  _DWORD s[512]; // [sp+20h] [bp-1804h] BYREF
  char v18[4100]; // [sp+820h] [bp-1004h] BYREF

  if ( a1 > 0xF )
  {
    v13 = -2147483391;
    snprintf((char *)s, 0x800u, "%s: Bad eeprom param, input chain is %d\n", "eeprom_read", a1);
    V_LOCK();
    logfmt_raw(v18, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
      170,
      "eeprom_read",
      11,
      131,
      100,
      v18);
    return v13;
  }
  v5 = 8 * a1;
  if ( !dword_119D58[2 * a1] )
  {
    v13 = eeprom_open(a1);
    if ( v13 < 0 )
    {
      snprintf((char *)s, 0x800u, "%s: auto exec eeprom_open, but chain %d open eeprom failed\n", "eeprom_read", a1);
      V_LOCK();
      logfmt_raw(v18, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
        170,
        "eeprom_read",
        11,
        136,
        100,
        v18);
      return v13;
    }
  }
  strcpy((char *)s, "no use at24c512c!\n");
  V_LOCK();
  logfmt_raw(v18, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
    170,
    "eeprom_read",
    11,
    152,
    20,
    v18);
  if ( a4 )
  {
    v8 = a3;
    v9 = v5 + 1154316;
    v10 = a3 + a4;
    while ( 1 )
    {
      v11 = *(void **)(v9 + 72);
      v12 = v8;
      v16 = a2;
      ++v8;
      ++a2;
      if ( iic_read_reg(v11, &v16, 1, v12, 1u) != 1 )
        break;
      if ( v8 == v10 )
        goto LABEL_11;
    }
    v13 = -2147483392;
    snprintf((char *)s, 0x800u, "fail to read eeprom by iic, chain: %d, addr: %d\n", a1, v16);
    V_LOCK();
    logfmt_raw(v18, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
      170,
      "eeprom_read",
      11,
      158,
      100,
      v18);
    return v13;
  }
LABEL_11:
  usleep((__useconds_t)&loc_7A120);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119D58: using guessed type _DWORD[32];
// 11A7AC: using guessed type int g_zc;

//----- (0006AA58) --------------------------------------------------------
int __fastcall eeprom_dump_fixture(unsigned __int8 *a1)
{
  char s[2048]; // [sp+20h] [bp-1804h] BYREF
  char v4[4100]; // [sp+820h] [bp-1004h] BYREF

  snprintf(s, 0x800u, "%-30s : 0x%04x\n", "key_version", *a1 & 0xF);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
    170,
    "eeprom_dump_fixture",
    19,
    366,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : 0x%04x\n", "algorithm_code", *a1 >> 4);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
    170,
    "eeprom_dump_fixture",
    19,
    367,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : 0x%04x\n", "fixture_info_len", a1[1]);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
    170,
    "eeprom_dump_fixture",
    19,
    368,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : 0x%04x\n", "fixture_standard", a1[49]);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
    170,
    "eeprom_dump_fixture",
    19,
    369,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : 0x%04x\n", "test_standard", a1[50]);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
    170,
    "eeprom_dump_fixture",
    19,
    370,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : %s\n", "chip_technology", *(const char **)(a1 + 35));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
    170,
    "eeprom_dump_fixture",
    19,
    371,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : 0x%02x\n", "fixture_fmt_version", a1[2]);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
    170,
    "eeprom_dump_fixture",
    19,
    372,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : %s\n", "SN", *(const char **)(a1 + 3));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
    170,
    "eeprom_dump_fixture",
    19,
    374,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : 0x%02x-%02x\n", "pcb", a1[31], a1[32]);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
    170,
    "eeprom_dump_fixture",
    19,
    375,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : 0x%02x-%02x\n", "bom", a1[33], a1[34]);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
    170,
    "eeprom_dump_fixture",
    19,
    376,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : %u\n", "hash_board_voltage", *(unsigned __int16 *)(a1 + 39));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
    170,
    "eeprom_dump_fixture",
    19,
    377,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : %u\n", "hash_board_freq", *(unsigned __int16 *)(a1 + 41));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
    170,
    "eeprom_dump_fixture",
    19,
    378,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : %.2f\n", "nonce_response_rate", *(float *)(a1 + 43));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
    170,
    "eeprom_dump_fixture",
    19,
    379,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : %u\n", "inlet_temperature", a1[47]);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
    170,
    "eeprom_dump_fixture",
    19,
    380,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : %u\n", "outlet_temperature", a1[48]);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
    170,
    "eeprom_dump_fixture",
    19,
    381,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : 0x%02x-%02x\n", "asic sensor", a1[24] >> 7, a1[24] & 0x7F);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
    170,
    "eeprom_dump_fixture",
    19,
    382,
    100,
    v4);
  snprintf(
    s,
    0x800u,
    "%-30s : 0x%02x-%02x-%02x-%02x\n",
    "asic sensor addr",
    **(unsigned __int8 **)(a1 + 25),
    *(unsigned __int8 *)(*(_DWORD *)(a1 + 25) + 1),
    *(unsigned __int8 *)(*(_DWORD *)(a1 + 25) + 2),
    *(unsigned __int8 *)(*(_DWORD *)(a1 + 25) + 3));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
    170,
    "eeprom_dump_fixture",
    19,
    383,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : 0x%02x-%02x\n", "pic sensor", a1[29] >> 7, a1[29] & 0x7F);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
    170,
    "eeprom_dump_fixture",
    19,
    384,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : 0x%02x\n", "pic sensor addr", a1[30]);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
    170,
    "eeprom_dump_fixture",
    19,
    385,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : bin%d\n", "chip_bin", a1[15]);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
    170,
    "eeprom_dump_fixture",
    19,
    386,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : %s\n", "FT", *((const char **)a1 + 4));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
    170,
    "eeprom_dump_fixture",
    19,
    387,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : %s\n", "chip_die", *(const char **)(a1 + 7));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
    170,
    "eeprom_dump_fixture",
    19,
    388,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : %s\n", "chip_marking", *(const char **)(a1 + 11));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
    170,
    "eeprom_dump_fixture",
    19,
    389,
    100,
    v4);
  strcpy(s, "\n");
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-o"
           "rigin_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
           170,
           "eeprom_dump_fixture",
           19,
           390,
           100,
           v4);
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0006B474) --------------------------------------------------------
int __fastcall add_eeprom_device(int a1, int a2)
{
  int *v2; // r2

  v2 = &dword_119D0C[dword_119D10++];
  v2[2] = a1;
  return a2;
}
// 119D0C: using guessed type int dword_119D0C[];
// 119D10: using guessed type int dword_119D10;

//----- (0006B498) --------------------------------------------------------
int __fastcall eeprom_load_one_chain(unsigned int a1, int a2)
{
  int v4; // r5
  int v5; // r8
  int v6; // r7
  size_t v7; // r1
  int v8; // r3
  int v9; // r2
  bool v10; // zf
  _BOOL4 v11; // r0
  unsigned int v12; // r6
  int v13; // r8
  char *v14; // r7
  char v15; // r3
  int v16; // r3
  int *v17; // r6
  int v19; // r10
  int v20; // r8
  int v21; // lr
  int v22; // r12
  int v23; // r2
  _WORD *v24; // r8
  _DWORD *v25; // r8
  int v26; // r2
  int v27; // r1
  int v28; // r3
  bool v29; // cf
  _DWORD *v30; // r8
  int v31; // r1
  _DWORD *v32; // r8
  _WORD *v33; // r8
  float v34; // s12
  _DWORD *v35; // r0
  char v36; // r2
  int v37; // r1
  int v38; // r0
  int v39; // r3
  char *v40; // r0
  char *v41; // r8
  _DWORD *v42; // r2
  int v43; // r1
  int v44; // r0
  int v45; // r2
  _WORD s[128]; // [sp+18h] [bp-1B04h] BYREF
  _DWORD v48[64]; // [sp+118h] [bp-1A04h] BYREF
  unsigned int dest[64]; // [sp+218h] [bp-1904h] BYREF
  char v50[2040]; // [sp+318h] [bp-1804h] BYREF
  char v51[4100]; // [sp+B18h] [bp-1004h] BYREF

  memset(s, 0, sizeof(s));
  memset(v48, 0, sizeof(v48));
  v4 = *(_DWORD *)(a2 + 4 * a1);
  v5 = 3;
  while ( 1 )
  {
    v6 = eeprom_read(a1, 0, (int)s, 256);
    if ( v6 )
    {
      snprintf(v50, 0x800u, "Read configuration fail for chain %d.\n", a1);
      V_LOCK();
      logfmt_raw(v51, 0x1000u, 0, v50);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
        170,
        "eeprom_load_one_chain",
        21,
        567,
        100,
        v51);
      return v6;
    }
    memset(dest, 0, sizeof(dest));
    v7 = HIBYTE(s[0]) - 2;
    v8 = s[0] & 0xF;
    v9 = LOBYTE(s[0]) >> 4;
    if ( (unsigned __int8)(HIBYTE(s[0]) - 2) > 0xFDu )
    {
      snprintf(
        v50,
        0x800u,
        "EEPROM info error! fixture_len:%d, fixture_without_header_len:%d, fixture_actual_len:%d",
        HIBYTE(s[0]),
        v7,
        HIBYTE(s[0]));
      V_LOCK();
      logfmt_raw(v51, 0x1000u, 0, v50);
      V_UNLOCK();
      v44 = g_zc;
      v45 = 265;
      goto LABEL_42;
    }
    v10 = v9 == 1;
    if ( v9 == 1 )
      v10 = v8 == 1;
    v11 = !v10;
    if ( v10 )
      break;
    snprintf(
      v50,
      0x800u,
      "EEPROM eeprom_key_version or eeprom_encryption_algorithm error! eeprom_key_version:%d, eeprom_encryption_algorithm:%d",
      v8,
      v9);
    V_LOCK();
    logfmt_raw(v51, 0x1000u, 0, v50);
    V_UNLOCK();
    v44 = g_zc;
    v45 = 271;
LABEL_42:
    zlog(
      v44,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
      170,
      "decode_eeprom_fixture_info",
      26,
      v45,
      100,
      v51);
    snprintf(v50, 0x800u, "Data decode fail for chain %d.\n", a1);
    V_LOCK();
    logfmt_raw(v51, 0x1000u, 0, v50);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
      170,
      "eeprom_load_one_chain",
      21,
      581,
      100,
      v51);
    usleep(0x7A120u);
    if ( !--v5 )
    {
      v17 = &g_zc;
      v14 = v50;
      goto LABEL_13;
    }
  }
  v12 = HIBYTE(s[0]) - 2;
  v13 = v11;
  memcpy(dest, &s[1], v7);
  data_dec(dest, v12, 1, 1);
  LOWORD(v48[0]) = s[0];
  v14 = (char *)(LOBYTE(s[0]) >> 4);
  memcpy((char *)v48 + 2, dest, v12);
  v15 = *(_BYTE *)v4 & 0xF | (16 * ((unsigned __int8)v14 & 0xF));
  *(_BYTE *)v4 = v15;
  *(_BYTE *)v4 = v15 & 0xF0 | v48[0] & 0xF;
  *(_BYTE *)(v4 + 1) = BYTE1(v48[0]);
  v16 = BYTE2(v48[0]);
  *(_BYTE *)(v4 + 2) = BYTE2(v48[0]);
  if ( v16 != 3 )
  {
    v14 = v50;
    v17 = &g_zc;
    strcpy(v50, "This FMT is not supported\n");
    V_LOCK();
    logfmt_raw(v51, 0x1000u, v13, v50);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
      170,
      "init_eeprom_fmt_info",
      20,
      359,
      100,
      v51);
LABEL_13:
    *(_BYTE *)(a2 + a1 + 64) = 0;
    snprintf(v14, 0x800u, "Data load fail for chain %d.\n", a1);
    V_LOCK();
    logfmt_raw(v51, 0x1000u, 0, v14);
    V_UNLOCK();
    zlog(
      *v17,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
      170,
      "eeprom_load_one_chain",
      21,
      598,
      100,
      v51);
    return -1;
  }
  v19 = (int)calloc(0x12u, 1u);
  v20 = v19;
  *(_DWORD *)(v4 + 3) = v19;
  if ( v19 )
  {
    v19 = 1;
  }
  else
  {
    v14 = v50;
    strcpy(v50, "Decode SN OOM\n");
    V_LOCK();
    logfmt_raw(v51, 0x1000u, 0, v50);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
      170,
      "eeprom_buf_to_layout",
      20,
      420,
      100,
      v51);
    v20 = *(_DWORD *)(v4 + 3);
  }
  v17 = *(int **)((char *)v48 + 3);
  v21 = *(_DWORD *)((char *)&v48[1] + 3);
  v22 = *(_DWORD *)((char *)&v48[2] + 3);
  v23 = *(_DWORD *)((char *)&v48[3] + 3);
  *(_DWORD *)v20 = *(_DWORD *)((char *)v48 + 3);
  *(_DWORD *)(v20 + 4) = v21;
  *(_DWORD *)(v20 + 8) = v22;
  *(_DWORD *)(v20 + 12) = v23;
  *(_BYTE *)(v20 + 16) = HIBYTE(v48[4]);
  v24 = calloc(3u, 1u);
  *(_DWORD *)(v4 + 7) = v24;
  if ( !v24 )
  {
    v14 = v50;
    v17 = &g_zc;
    v19 = 0;
    strcpy(v50, "Decode Chip Die OOM\n");
    V_LOCK();
    logfmt_raw(v51, 0x1000u, 0, v50);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
      170,
      "eeprom_buf_to_layout",
      20,
      429,
      100,
      v51);
    v24 = *(_WORD **)(v4 + 7);
  }
  *v24 = v48[5];
  v25 = calloc(0xEu, 1u);
  *(_DWORD *)(v4 + 11) = v25;
  if ( !v25 )
  {
    v14 = v50;
    v17 = &g_zc;
    v19 = 0;
    strcpy(v50, "Decode Chip Marking OOM\n");
    V_LOCK();
    logfmt_raw(v51, 0x1000u, 0, v50);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
      170,
      "eeprom_buf_to_layout",
      20,
      438,
      100,
      v51);
    v25 = *(_DWORD **)(v4 + 11);
  }
  v26 = *(_DWORD *)((char *)&v48[7] + 2);
  v27 = *(_DWORD *)((char *)&v48[6] + 2);
  *v25 = *(_DWORD *)((char *)&v48[5] + 2);
  v25[2] = v26;
  v25[1] = v27;
  *((_BYTE *)v25 + 12) = BYTE2(v48[8]);
  v28 = *(unsigned __int8 *)(v4 + 2) - 1;
  v29 = *(_BYTE *)(v4 + 2) != 1;
  *(_BYTE *)(v4 + 15) = HIBYTE(v48[8]);
  if ( v28 != 1 && v29 )
  {
    v30 = calloc(0xAu, 1u);
    *(_DWORD *)(v4 + 16) = v30;
    if ( !v30 )
    {
      v14 = v50;
      v17 = &g_zc;
      v19 = 0;
      strcpy(v50, "Decode Chip FT Program Version OOM\n");
      V_LOCK();
      logfmt_raw(v51, 0x1000u, 0, v50);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
        170,
        "eeprom_buf_to_layout",
        20,
        464,
        100,
        v51);
      v30 = *(_DWORD **)(v4 + 16);
    }
    v31 = v48[10];
    *v30 = v48[9];
    v30[1] = v31;
    *((_BYTE *)v30 + 8) = v48[11];
  }
  else
  {
    memset(dest, 0, 16);
    v40 = (char *)calloc(0xFu, 1u);
    v41 = v40;
    *(_DWORD *)(v4 + 16) = v40;
    if ( !v40 )
    {
      v14 = v50;
      v19 = 0;
      strcpy(v50, "Decode Chip FT Program Version OOM\n");
      V_LOCK();
      logfmt_raw(v51, 0x1000u, 0, v50);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
        170,
        "eeprom_buf_to_layout",
        20,
        453,
        100,
        v51);
      v41 = *(char **)(v4 + 16);
    }
    dest[0] = v48[9];
    dest[1] = v48[10];
    LOBYTE(dest[2]) = v48[11];
    v17 = (int *)HIBYTE(v48[9]);
    snprintf(v41, 0xFu, "F%dV%02dB%dC%d", LOBYTE(v48[9]), BYTE1(v48[9]), BYTE2(v48[9]), HIBYTE(v48[9]));
  }
  *(_BYTE *)(v4 + 24) = *(_BYTE *)(v4 + 24) & 0x80 | BYTE1(v48[19]) & 0x7F;
  *(_BYTE *)(v4 + 24) = *(_BYTE *)(v4 + 24) & 0x7F | (BYTE1(v48[19]) >> 7 << 7);
  v32 = calloc(5u, 1u);
  *(_DWORD *)(v4 + 25) = v32;
  if ( !v32 )
  {
    v14 = v50;
    v17 = &g_zc;
    v19 = 0;
    strcpy(v50, "Decode Chip FT Program Version OOM\n");
    V_LOCK();
    logfmt_raw(v51, 0x1000u, 0, v50);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
      170,
      "eeprom_buf_to_layout",
      20,
      478,
      100,
      v51);
    v32 = *(_DWORD **)(v4 + 25);
  }
  *v32 = *(_DWORD *)((char *)&v48[19] + 2);
  *(_BYTE *)(v4 + 29) = *(_BYTE *)(v4 + 29) & 0x80 | BYTE2(v48[20]) & 0x7F;
  *(_BYTE *)(v4 + 29) = *(_BYTE *)(v4 + 29) & 0x7F | (BYTE2(v48[20]) >> 7 << 7);
  *(_BYTE *)(v4 + 30) = HIBYTE(v48[20]);
  *(_DWORD *)(v4 + 31) = v48[21];
  v33 = calloc(3u, 1u);
  *(_DWORD *)(v4 + 35) = v33;
  if ( !v33 )
  {
    v14 = v50;
    v17 = &g_zc;
    v19 = 0;
    strcpy(v50, "Decode Chip Technology OOM\n");
    V_LOCK();
    logfmt_raw(v51, 0x1000u, 0, v50);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
      170,
      "eeprom_buf_to_layout",
      20,
      502,
      100,
      v51);
    v33 = *(_WORD **)(v4 + 35);
  }
  *v33 = v48[22];
  *(_WORD *)(v4 + 39) = __rev16(HIWORD(v48[22]));
  *(_WORD *)(v4 + 41) = __rev16(LOWORD(v48[23]));
  v34 = (double)((unsigned __int16)(HIWORD(v48[23]) << 8) | HIBYTE(HIWORD(v48[23]))) / 100.0;
  *(float *)(v4 + 43) = v34;
  *(_DWORD *)(v4 + 47) = v48[24];
  v35 = calloc(9u, 1u);
  *(_DWORD *)(v4 + 51) = v35;
  if ( !v35 )
  {
    v14 = v50;
    v17 = &g_zc;
    strcpy(v50, "Decode miner_type OOM\n");
    V_LOCK();
    logfmt_raw(v51, 0x1000u, 0, v50);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
      170,
      "eeprom_buf_to_layout",
      20,
      538,
      100,
      v51);
    v42 = *(_DWORD **)(v4 + 51);
    v43 = v48[26];
    *v42 = v48[25];
    v42[1] = v43;
    *(_BYTE *)(v4 + 59) = BYTE1(v48[28]);
    goto LABEL_13;
  }
  v36 = BYTE1(v48[28]);
  v37 = v48[26];
  if ( !v19 )
  {
    v17 = &g_zc;
    v14 = v50;
  }
  *v35 = v48[25];
  v35[1] = v37;
  *(_BYTE *)(v4 + 59) = v36;
  if ( !v19 )
    goto LABEL_13;
  v38 = BM_CRC5(v48, 8 * (*(unsigned __int8 *)(v4 + 1) - 1));
  v39 = *(unsigned __int8 *)(v4 + 59);
  if ( v38 != v39 )
  {
    v14 = v50;
    v17 = &g_zc;
    snprintf(
      v50,
      0x800u,
      "Fixture CRC check fail.fixture_crc = 0x%x, len = 0x%x, crc = 0x%x\n",
      v39,
      *(unsigned __int8 *)(v4 + 1),
      v38);
    V_LOCK();
    logfmt_raw(v51, 0x1000u, 0, v50);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
      170,
      "_is_fixture_crc_pass",
      20,
      237,
      100,
      v51);
    goto LABEL_13;
  }
  *(_BYTE *)(a2 + a1 + 64) = 1;
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0006C094) --------------------------------------------------------
int eeprom_load()
{
  int v0; // r1
  int v1; // r6
  int v2; // r3
  int v3; // r4

  v0 = dword_119D0C[0];
  if ( dword_119D0C[0] )
  {
    if ( *(_BYTE *)(dword_119D0C[0] + 80) )
      return 0;
    if ( dword_119D10 <= 0 )
    {
LABEL_10:
      v1 = 0;
      *(_BYTE *)(v0 + 80) = 1;
      return v1;
    }
  }
  else
  {
    if ( sub_69E70() )
      return -1;
    v0 = dword_119D0C[0];
    if ( dword_119D10 <= 0 )
      goto LABEL_10;
  }
  v2 = 0;
  v1 = 0;
  LOBYTE(v3) = 0;
  while ( 1 )
  {
    v3 = (unsigned __int8)(v3 + 1);
    v1 |= eeprom_load_one_chain(dword_119D0C[v2 + 2], v0);
    v2 = v3;
    if ( v3 >= dword_119D10 )
      break;
    v0 = dword_119D0C[0];
  }
  if ( !v1 )
  {
    v0 = dword_119D0C[0];
    goto LABEL_10;
  }
  return v1;
}
// 119D0C: using guessed type int dword_119D0C[];
// 119D10: using guessed type int dword_119D10;

//----- (0006C148) --------------------------------------------------------
int __fastcall eeprom_get_voltage(int a1, _DWORD *a2)
{
  int v2; // r3
  int result; // r0
  char s[2048]; // [sp+10h] [bp-1804h] BYREF
  char v5[4100]; // [sp+810h] [bp-1004h] BYREF

  if ( dword_119D0C[0] && *(_BYTE *)(dword_119D0C[0] + 80) )
  {
    v2 = *(unsigned __int16 *)(*(_DWORD *)(dword_119D0C[0] + 4 * a1) + 39);
    if ( a2 )
    {
      result = 0;
      *a2 = v2;
    }
    else
    {
      strcpy(s, "voltage level not match");
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
        170,
        "eeprom_get_voltage",
        18,
        655,
        100,
        v5);
      return -2;
    }
  }
  else
  {
    snprintf(s, 0x800u, "No work mode voltage, chain = %d.\n", a1);
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
      170,
      "eeprom_get_voltage",
      18,
      644,
      100,
      v5);
    return -1;
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119D0C: using guessed type int dword_119D0C[];
// 11A7AC: using guessed type int g_zc;

//----- (0006C29C) --------------------------------------------------------
int eeprom_get_max_voltage()
{
  char *v0; // r3
  int result; // r0
  int v2; // t1
  int v3; // r2
  char s[2048]; // [sp+10h] [bp-1808h] BYREF
  char v5[4104]; // [sp+810h] [bp-1008h] BYREF

  if ( dword_119D0C[0] && *(_BYTE *)(dword_119D0C[0] + 80) )
  {
    if ( dword_119D10 <= 0 )
    {
      return 0;
    }
    else
    {
      v0 = (char *)&unk_119D14;
      result = 0;
      do
      {
        v2 = *(_DWORD *)v0;
        v0 += 4;
        v3 = *(unsigned __int16 *)(*(_DWORD *)(dword_119D0C[0] + 4 * v2) + 39);
        if ( result < v3 )
          result = v3;
      }
      while ( v0 != (char *)&unk_119D14 + 4 * dword_119D10 );
    }
  }
  else
  {
    snprintf(s, 0x800u, "%s: eeprom is not ready\n", "eeprom_get_max_voltage");
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
      170,
      "eeprom_get_max_voltage",
      22,
      665,
      100,
      v5);
    return -1;
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119D0C: using guessed type int dword_119D0C[];
// 119D10: using guessed type int dword_119D10;
// 11A7AC: using guessed type int g_zc;

//----- (0006C394) --------------------------------------------------------
int __fastcall eeprom_get_freq(int a1, _DWORD *a2)
{
  int v2; // r3
  int result; // r0
  char s[2048]; // [sp+10h] [bp-1804h] BYREF
  char v5[4100]; // [sp+810h] [bp-1004h] BYREF

  if ( dword_119D0C[0] && *(_BYTE *)(dword_119D0C[0] + 80) )
  {
    v2 = *(unsigned __int16 *)(*(_DWORD *)(dword_119D0C[0] + 4 * a1) + 41);
    if ( a2 )
    {
      result = 0;
      *a2 = v2;
    }
    else
    {
      strcpy(s, "freq level not match");
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
        170,
        "eeprom_get_freq",
        15,
        694,
        100,
        v5);
      return -2;
    }
  }
  else
  {
    snprintf(s, 0x800u, "No work mode freq, chain = %d.\n", a1);
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
      170,
      "eeprom_get_freq",
      15,
      683,
      100,
      v5);
    return -1;
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119D0C: using guessed type int dword_119D0C[];
// 11A7AC: using guessed type int g_zc;

//----- (0006C4EC) --------------------------------------------------------
int eeprom_get_min_freq()
{
  char *v0; // r3
  int result; // r0
  int v2; // t1
  int v3; // r2
  char s[2048]; // [sp+10h] [bp-1808h] BYREF
  char v5[4104]; // [sp+810h] [bp-1008h] BYREF

  if ( dword_119D0C[0] && *(_BYTE *)(dword_119D0C[0] + 80) )
  {
    if ( dword_119D10 <= 0 )
    {
      return 0xFFFF;
    }
    else
    {
      v0 = (char *)&unk_119D14;
      result = 0xFFFF;
      do
      {
        v2 = *(_DWORD *)v0;
        v0 += 4;
        v3 = *(unsigned __int16 *)(*(_DWORD *)(dword_119D0C[0] + 4 * v2) + 41);
        if ( result >= v3 )
          result = v3;
      }
      while ( v0 != (char *)&unk_119D14 + 4 * dword_119D10 );
    }
  }
  else
  {
    snprintf(s, 0x800u, "%s: g_eeprom_data is not ready\n", "eeprom_get_min_freq");
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
      170,
      "eeprom_get_min_freq",
      19,
      704,
      100,
      v5);
    return -1;
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119D0C: using guessed type int dword_119D0C[];
// 119D10: using guessed type int dword_119D10;
// 11A7AC: using guessed type int g_zc;

//----- (0006C5E4) --------------------------------------------------------
int is_eeprom_loaded()
{
  int result; // r0
  char s[2048]; // [sp+10h] [bp-1808h] BYREF
  char v2[4104]; // [sp+810h] [bp-1008h] BYREF

  if ( !dword_119D0C[0] || (result = *(unsigned __int8 *)(dword_119D0C[0] + 80), !*(_BYTE *)(dword_119D0C[0] + 80)) )
  {
    snprintf(s, 0x800u, "%s: g_eeprom_data is not ready\n", "is_eeprom_loaded");
    V_LOCK();
    logfmt_raw(v2, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
      170,
      "is_eeprom_loaded",
      16,
      720,
      20,
      v2);
    return 0;
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119D0C: using guessed type int dword_119D0C[];
// 11A7AC: using guessed type int g_zc;

//----- (0006C69C) --------------------------------------------------------
int __fastcall api_get_eeprom_nonce_response_rate(int a1, _DWORD *a2)
{
  int v2; // r3
  int result; // r0
  char s[2048]; // [sp+10h] [bp-1804h] BYREF
  char v5[4100]; // [sp+810h] [bp-1004h] BYREF

  v2 = dword_119D0C[a1 + 2];
  if ( dword_119D0C[0] && *(_BYTE *)(dword_119D0C[0] + 80) )
  {
    if ( a2 )
    {
      result = 0;
      *a2 = *(_DWORD *)(*(_DWORD *)(dword_119D0C[0] + 4 * v2) + 43);
    }
    else
    {
      snprintf(
        s,
        0x800u,
        "%s: chain = %d nonce response rate in eeprom is invalid\n",
        "api_get_eeprom_nonce_response_rate",
        dword_119D0C[a1 + 2]);
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
        170,
        "api_get_eeprom_nonce_response_rate",
        34,
        815,
        100,
        v5);
      return -2;
    }
  }
  else
  {
    snprintf(
      s,
      0x800u,
      "%s: g_eeprom_data is not ready, chain = %d.\n",
      "api_get_eeprom_nonce_response_rate",
      dword_119D0C[a1 + 2]);
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
      170,
      "api_get_eeprom_nonce_response_rate",
      34,
      806,
      100,
      v5);
    return -1;
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119D0C: using guessed type int dword_119D0C[];
// 11A7AC: using guessed type int g_zc;

//----- (0006C800) --------------------------------------------------------
int __fastcall api_get_eeprom_freq(int a1)
{
  int v2; // [sp+4h] [bp-8h] BYREF

  v2 = 0;
  eeprom_get_freq(dword_119D14[a1], &v2);
  return v2;
}
// 119D14: using guessed type _DWORD dword_119D14[17];

//----- (0006C834) --------------------------------------------------------
int __fastcall api_get_eeprom_voltage(int a1)
{
  int v2; // [sp+4h] [bp-8h] BYREF

  v2 = 0;
  eeprom_get_voltage(dword_119D0C[a1 + 2], &v2);
  return v2;
}
// 119D0C: using guessed type int dword_119D0C[];

//----- (0006C868) --------------------------------------------------------
int __fastcall api_get_eeprom_chip_bin(int a1)
{
  int v2; // r0
  char s[2048]; // [sp+10h] [bp-1808h] BYREF
  char v4[4104]; // [sp+810h] [bp-1008h] BYREF

  v2 = dword_119D0C[a1 + 2];
  if ( dword_119D0C[0] && *(_BYTE *)(dword_119D0C[0] + 80) )
    return *(unsigned __int8 *)(*(_DWORD *)(dword_119D0C[0] + 4 * v2) + 15);
  snprintf(s, 0x800u, "%s: g_eeprom_data is not ready, chain = %d.\n", "get_chip_bin", v2);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
    170,
    "get_chip_bin",
    12,
    731,
    100,
    v4);
  return 255;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119D0C: using guessed type int dword_119D0C[];
// 11A7AC: using guessed type int g_zc;

//----- (0006C87C) --------------------------------------------------------
int __fastcall api_get_eeprom_chip_ft(int a1)
{
  int v2; // r0
  char s[2048]; // [sp+10h] [bp-1808h] BYREF
  char v4[4104]; // [sp+810h] [bp-1008h] BYREF

  v2 = dword_119D0C[a1 + 2];
  if ( dword_119D0C[0] && *(_BYTE *)(dword_119D0C[0] + 80) )
    return *(_DWORD *)(*(_DWORD *)(dword_119D0C[0] + 4 * v2) + 16);
  snprintf(s, 0x800u, "%s: g_eeprom_data is not ready, chain = %d.\n", "get_chip_ft", v2);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
    170,
    "get_chip_ft",
    11,
    741,
    100,
    v4);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119D0C: using guessed type int dword_119D0C[];
// 11A7AC: using guessed type int g_zc;

//----- (0006C890) --------------------------------------------------------
int __fastcall api_get_eeprom_test_standard_code(int a1)
{
  int v2; // r0
  char s[2048]; // [sp+10h] [bp-1808h] BYREF
  char v4[4104]; // [sp+810h] [bp-1008h] BYREF

  v2 = dword_119D0C[a1 + 2];
  if ( dword_119D0C[0] && *(_BYTE *)(dword_119D0C[0] + 80) )
    return *(unsigned __int8 *)(*(_DWORD *)(dword_119D0C[0] + 4 * v2) + 50);
  snprintf(s, 0x800u, "%s: g_eeprom_data is not ready, chain = %d.\n", "get_test_standard_code", v2);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
    170,
    "get_test_standard_code",
    22,
    751,
    100,
    v4);
  return 255;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119D0C: using guessed type int dword_119D0C[];
// 11A7AC: using guessed type int g_zc;

//----- (0006C8A4) --------------------------------------------------------
int __fastcall api_get_eeprom_chip_sn(int a1)
{
  int v2; // r0
  char s[2048]; // [sp+10h] [bp-1808h] BYREF
  char v4[4104]; // [sp+810h] [bp-1008h] BYREF

  v2 = dword_119D0C[a1 + 2];
  if ( dword_119D0C[0] && *(_BYTE *)(dword_119D0C[0] + 80) )
    return *(_DWORD *)(*(_DWORD *)(dword_119D0C[0] + 4 * v2) + 3);
  snprintf(s, 0x800u, "%s: g_eeprom_data is not ready, chain = %d.\n", "get_chip_sn", v2);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
    170,
    "get_chip_sn",
    11,
    761,
    100,
    v4);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119D0C: using guessed type int dword_119D0C[];
// 11A7AC: using guessed type int g_zc;

//----- (0006C8B8) --------------------------------------------------------
int __fastcall api_get_eeprom_miner_type(int a1, void *a2)
{
  return sub_6A070(dword_119D0C[a1 + 2], a2);
}
// 119D0C: using guessed type int dword_119D0C[];

//----- (0006C8CC) --------------------------------------------------------
int __fastcall api_get_eeprom_chain_load_state(int a1)
{
  int *v1; // r0
  char s[2048]; // [sp+10h] [bp-1804h] BYREF
  char v4[4100]; // [sp+810h] [bp-1004h] BYREF

  v1 = &dword_119D0C[a1];
  if ( dword_119D0C[0] )
    return *(unsigned __int8 *)(dword_119D0C[0] + v1[2] + 64);
  snprintf(s, 0x800u, "%s: g_eeprom_data is not ready, chain = %d.\n", "api_get_eeprom_chain_load_state", v1[2]);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/eeprom/bitmain_eeprom.c",
    170,
    "api_get_eeprom_chain_load_state",
    31,
    864,
    100,
    v4);
  return -1;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119D0C: using guessed type int dword_119D0C[];
// 11A7AC: using guessed type int g_zc;

//----- (0006C990) --------------------------------------------------------
int __fastcall api_get_eeprom_pcb_version(int a1, char *a2)
{
  return sub_6A160(dword_119D0C[a1 + 2], a2);
}
// 119D0C: using guessed type int dword_119D0C[];

//----- (0006C9A4) --------------------------------------------------------
int __fastcall api_get_eeprom_bom_version(int a1, char *a2)
{
  return sub_6A24C(dword_119D0C[a1 + 2], a2);
}
// 119D0C: using guessed type int dword_119D0C[];

//----- (0006C9B8) --------------------------------------------------------
int __fastcall sub_6C9B8(void *a1, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int a5)
{
  unsigned int v7; // r4
  unsigned int v8; // r3
  unsigned int v9; // r4
  unsigned int v10; // r3
  unsigned __int8 *v11; // r1
  int v12; // r3
  __int16 v13; // t1
  int v14; // r0
  int v15; // r12
  int v16; // r5
  unsigned __int8 *v17; // r4
  int v18; // t1
  int v19; // r3
  int v20; // r4
  int v22; // [sp+0h] [bp-850h]
  int v25; // [sp+28h] [bp-828h]
  unsigned __int8 *v27; // [sp+38h] [bp-818h]
  unsigned __int8 *v28; // [sp+3Ch] [bp-814h]
  unsigned __int8 *v29; // [sp+40h] [bp-810h]
  unsigned __int8 *v30; // [sp+44h] [bp-80Ch]
  unsigned __int8 v31; // [sp+4Fh] [bp-801h] BYREF
  char s[2048]; // [sp+50h] [bp-800h] BYREF
  char v33[4080]; // [sp+850h] [bp+0h] BYREF

  v31 = 0;
  v25 = 0;
  pthread_mutex_lock((pthread_mutex_t *)&power_mutex);
  v27 = &a4[a5 - 1];
  v28 = &a4[a5 - 2];
  v30 = a4 + 1;
  v29 = a4 - 3;
  while ( 1 )
  {
    LOBYTE(v7) = 0;
    v8 = 0;
    do
    {
      v7 = (unsigned __int8)(v7 + 1);
      iic_write_reg((int)a1, &v31, 1, (int)&a2[v8], 1);
      v8 = v7;
    }
    while ( v7 < a3 );
    LOBYTE(v9) = 0;
    usleep((__useconds_t)&loc_61A80);
    v10 = 0;
    do
    {
      v9 = (unsigned __int8)(v9 + 1);
      iic_read_reg(a1, &v31, 1, (int)&a4[v10], 1u);
      v10 = v9;
    }
    while ( v9 < a5 );
    usleep((__useconds_t)"rl_kda_2110");
    v11 = v30;
    LOWORD(v12) = 0;
    do
    {
      v13 = *++v11;
      v12 = (unsigned __int16)(v12 + v13);
    }
    while ( &v29[a5] != v11 );
    if ( v12 != (unsigned __int16)(*v28 + (*v27 << 8)) )
    {
      snprintf(
        s,
        0x800u,
        "power reply the bad crc, crc = 0x%04x, crc_read = 0x%04x\n",
        v12,
        (unsigned __int16)(*v28 + (*v27 << 8)));
      V_LOCK();
      logfmt_raw(v33, 0x1000u, 0, s);
      V_UNLOCK();
      v14 = g_zc;
      v15 = 87;
      goto LABEL_10;
    }
    if ( *a2 == *a4 && a2[1] == a4[1] && a2[3] == a4[3] && a5 == a4[2] + 2 )
      break;
    strcpy(s, "power reply the bad data\n");
    V_LOCK();
    logfmt_raw(v33, 0x1000u, 0, s);
    V_UNLOCK();
    v14 = g_zc;
    v15 = 93;
LABEL_10:
    v16 = 0;
    zlog(
      v14,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/power/bitmain_power_APW9.c",
      173,
      "check_read_back_data",
      20,
      v15,
      20,
      v33);
    v17 = a4 - 1;
    do
    {
      v18 = *++v17;
      v19 = v16++;
      snprintf(s, 0x800u, "read_back_data[%d] = 0x%02x", v19, v18);
      V_LOCK();
      logfmt_raw(v33, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/power/bitmain_power_APW9.c",
        173,
        "check_read_back_data",
        20,
        99,
        20,
        v33);
    }
    while ( &a4[a5 - 1] != v17 );
    v22 = v25++;
    snprintf(s, 0x800u, "Send power cmd(0x%02x) failed, retry %d\n", a2[3], v22);
    V_LOCK();
    logfmt_raw(v33, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/power/bitmain_power_APW9.c",
      173,
      "exec_power_cmd",
      14,
      193,
      20,
      v33);
    if ( v25 == 3 )
    {
      v20 = -2147482880;
      goto LABEL_14;
    }
  }
  v20 = 0;
LABEL_14:
  pthread_mutex_unlock((pthread_mutex_t *)&power_mutex);
  return v20;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0006CDB4) --------------------------------------------------------
int sub_6CDB4()
{
  char v1[2048]; // [sp+10h] [bp-1800h] BYREF
  char v2[4096]; // [sp+810h] [bp-1000h] BYREF

  strcpy(v1, "set watchdog failed\n");
  V_LOCK();
  logfmt_raw(v2, 0x1000u, 0, v1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/power/bitmain_power_APW9.c",
    173,
    "_bitmain_set_watchdog",
    21,
    465,
    100,
    v2);
  return -2147482880;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0006CE54) --------------------------------------------------------
int __fastcall sub_6CE54(void *a1, unsigned __int8 a2)
{
  int v3; // [sp+8h] [bp-14h] BYREF
  __int16 v4; // [sp+Ch] [bp-10h]
  char v5; // [sp+Eh] [bp-Eh]
  char v6; // [sp+Fh] [bp-Dh]
  int v7; // [sp+10h] [bp-Ch] BYREF
  int v8; // [sp+14h] [bp-8h]

  v5 = a2 - 121;
  v4 = a2;
  v7 = 0;
  v6 = 0;
  v8 = 0;
  v3 = -2130269611;
  if ( sub_6C9B8(a1, (unsigned __int8 *)&v3, 8u, (unsigned __int8 *)&v7, 8u) )
    return sub_6CDB4();
  else
    return (unsigned __int16)v8;
}

//----- (0006CEB8) --------------------------------------------------------
int sub_6CEB8()
{
  char v1[2048]; // [sp+10h] [bp-1800h] BYREF
  char v2[4096]; // [sp+810h] [bp-1000h] BYREF

  strcpy(v1, "set DA conversion N failed\n");
  V_LOCK();
  logfmt_raw(v2, 0x1000u, 0, v1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/power/bitmain_power_APW9.c",
    173,
    "_bitmain_set_DA_conversion_N",
    28,
    373,
    100,
    v2);
  return -2147482880;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0006CF54) --------------------------------------------------------
int __fastcall sub_6CF54(void *a1, __int16 a2)
{
  int v3; // [sp+8h] [bp-14h] BYREF
  __int16 v4; // [sp+Ch] [bp-10h]
  __int16 v5; // [sp+Eh] [bp-Eh]
  int v6; // [sp+10h] [bp-Ch] BYREF
  int v7; // [sp+14h] [bp-8h]

  v3 = -2096715179;
  v5 = a2 + 137;
  v6 = 0;
  v4 = (unsigned __int8)a2;
  v7 = 0;
  if ( sub_6C9B8(a1, (unsigned __int8 *)&v3, 8u, (unsigned __int8 *)&v6, 8u) )
    return sub_6CEB8();
  else
    return (unsigned __int16)v7;
}

//----- (0006CFC4) --------------------------------------------------------
int sub_6CFC4()
{
  char v1[2048]; // [sp+10h] [bp-1804h] BYREF
  char v2[4100]; // [sp+810h] [bp-1004h] BYREF

  pthread_mutex_lock((pthread_mutex_t *)&power_mutex);
  strcpy(v1, "bitmain power close ===========\n");
  V_LOCK();
  logfmt_raw(v2, 0x1000u, 0, v1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/power/bitmain_power_APW9.c",
    173,
    "bitmain_power_close",
    19,
    622,
    40,
    v2);
  iic_uninit(dword_119DF0);
  dword_119DF4 = 0;
  dword_119DF8 = 0;
  memset(byte_119E00, 0, 0x68u);
  return pthread_mutex_unlock((pthread_mutex_t *)&power_mutex);
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119DF0: using guessed type int dword_119DF0;
// 119DF4: using guessed type int dword_119DF4;
// 119DF8: using guessed type int dword_119DF8;
// 11A7AC: using guessed type int g_zc;

//----- (0006D09C) --------------------------------------------------------
int bitmain_power_close()
{
  if ( dword_119DF0 && dword_119DF4 )
    return 0;
  sub_6CFC4();
  return 0;
}
// 119DF0: using guessed type int dword_119DF0;
// 119DF4: using guessed type int dword_119DF4;

//----- (0006D0D4) --------------------------------------------------------
int bitmain_power_version()
{
  int v0; // r5
  int v2; // [sp+10h] [bp-1810h] BYREF
  __int16 v3; // [sp+14h] [bp-180Ch]
  int v4; // [sp+18h] [bp-1808h] BYREF
  int v5; // [sp+1Ch] [bp-1804h]
  char s[2048]; // [sp+20h] [bp-1800h] BYREF
  char v7[4096]; // [sp+820h] [bp-1000h] BYREF

  if ( dword_119DF4 || (v0 = bitmain_power_open(), v0 >= 0) )
  {
    v5 = 0;
    v4 = 0;
    v2 = 33860181;
    v3 = 6;
    if ( sub_6C9B8((void *)dword_119DF0, (unsigned __int8 *)&v2, 6u, (unsigned __int8 *)&v4, 8u) )
    {
      v0 = -2147482880;
      strcpy(s, "get power version failed\n");
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/power/bitmain_power_APW9.c",
        173,
        "_bitmain_get_power_version",
        26,
        269,
        100,
        v7);
    }
    else
    {
      v0 = (unsigned __int16)v5;
      if ( (_WORD)v5 )
        dword_119DF8 = (unsigned __int16)v5;
    }
  }
  else
  {
    snprintf(s, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_power_version");
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/power/bitmain_power_APW9.c",
      173,
      "bitmain_power_version",
      21,
      646,
      100,
      v7);
  }
  return v0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119DF0: using guessed type int dword_119DF0;
// 119DF4: using guessed type int dword_119DF4;
// 119DF8: using guessed type int dword_119DF8;
// 11A7AC: using guessed type int g_zc;

//----- (0006D270) --------------------------------------------------------
int sub_6D270()
{
  int v0; // r5
  int v1; // r0
  _DWORD v3[2]; // [sp+10h] [bp-1808h] BYREF
  char s[2040]; // [sp+18h] [bp-1800h] BYREF
  char v5[4096]; // [sp+818h] [bp-1000h] BYREF

  v3[1] = sub_20000;
  v3[0] = 0;
  pthread_mutex_lock((pthread_mutex_t *)&power_mutex);
  v0 = iic_init((int)v3);
  pthread_mutex_unlock((pthread_mutex_t *)&power_mutex);
  if ( v0 < 0 )
    return v0;
  dword_119DF0 = v0;
  dword_119DF4 = 1;
  memset(byte_119E00, 0, 0x68u);
  v1 = bitmain_power_version();
  v0 = v1;
  if ( v1 >= 0 )
  {
    dword_119DF8 = v1;
    snprintf(s, 0x800u, "power open power_version = 0x%x", v1);
    V_LOCK();
    v0 = 0;
    logfmt_raw(v5, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/power/bitmain_power_APW9.c",
      173,
      "bitmain_power_open",
      18,
      610,
      40,
      v5);
    return v0;
  }
  strcpy(s, "power open power_version < 0 will close power\n");
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/power/bitmain_power_APW9.c",
    173,
    "bitmain_power_open",
    18,
    605,
    40,
    v5);
  if ( dword_119DF0 && dword_119DF4 )
    return v0;
  sub_6CFC4();
  return v0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 20000: using guessed type int sub_20000();
// 119DF0: using guessed type int dword_119DF0;
// 119DF4: using guessed type int dword_119DF4;
// 119DF8: using guessed type int dword_119DF8;
// 11A7AC: using guessed type int g_zc;

//----- (0006D438) --------------------------------------------------------
int bitmain_power_open()
{
  int result; // r0

  result = dword_119DF0;
  if ( !dword_119DF0 || !dword_119DF4 )
    return sub_6D270();
  return result;
}
// 6D270: using guessed type int sub_6D270(void);
// 119DF0: using guessed type int dword_119DF0;
// 119DF4: using guessed type int dword_119DF4;

//----- (0006D45C) --------------------------------------------------------
int bitmain_get_sample_voltage()
{
  int result; // r0
  int v1; // [sp+10h] [bp-1810h] BYREF
  __int16 v2; // [sp+14h] [bp-180Ch]
  _DWORD v3[2]; // [sp+18h] [bp-1808h] BYREF
  char s[2048]; // [sp+20h] [bp-1800h] BYREF
  char v5[4096]; // [sp+820h] [bp-1000h] BYREF

  if ( dword_119DF4 || sub_6D270() >= 0 )
  {
    v3[1] = 0;
    v3[0] = 0;
    v1 = 67414613;
    v2 = 8;
    result = sub_6C9B8((void *)dword_119DF0, (unsigned __int8 *)&v1, 6u, (unsigned __int8 *)v3, 8u);
    if ( result )
    {
      strcpy(s, "get sample N failed\n");
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/power/bitmain_power_APW9.c",
        173,
        "_bitmain_get_sample_N",
        21,
        428,
        100,
        v5);
      strcpy(s, "can nont get sample voltage\n");
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, s);
      V_UNLOCK();
      return zlog(
               g_zc,
               "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godmin"
               "er-origin_godminer-new/backend/device/hal/power/bitmain_power_APW9.c",
               173,
               "bitmain_get_sample_voltage",
               26,
               537,
               100,
               v5);
    }
  }
  else
  {
    snprintf(s, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_get_sample_voltage");
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, s);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer"
             "-origin_godminer-new/backend/device/hal/power/bitmain_power_APW9.c",
             173,
             "bitmain_get_sample_voltage",
             26,
             533,
             100,
             v5);
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119DF0: using guessed type int dword_119DF0;
// 119DF4: using guessed type int dword_119DF4;
// 119DF8: using guessed type int dword_119DF8;
// 11A7AC: using guessed type int g_zc;

//----- (0006D6D0) --------------------------------------------------------
int bitmain_get_power_status()
{
  int v0; // r6
  int v2; // [sp+10h] [bp-1810h] BYREF
  __int16 v3; // [sp+14h] [bp-180Ch]
  int v4; // [sp+18h] [bp-1808h] BYREF
  int v5; // [sp+1Ch] [bp-1804h]
  char s[2048]; // [sp+20h] [bp-1800h] BYREF
  char v7[4096]; // [sp+820h] [bp-1000h] BYREF

  if ( dword_119DF4 || (v0 = sub_6D270(), v0 >= 0) )
  {
    v5 = 0;
    v4 = 0;
    v2 = 168077909;
    v3 = 14;
    if ( sub_6C9B8((void *)dword_119DF0, (unsigned __int8 *)&v2, 6u, (unsigned __int8 *)&v4, 8u) )
    {
      strcpy(s, "get power status failed\n");
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/power/bitmain_power_APW9.c",
        173,
        "_bitmain_get_power_status",
        25,
        500,
        100,
        v7);
      strcpy(s, "can nont get power status\n");
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/power/bitmain_power_APW9.c",
        173,
        "bitmain_get_power_status",
        24,
        551,
        100,
        v7);
      return -2147482880;
    }
    return (unsigned __int16)v5;
  }
  else
  {
    snprintf(s, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_get_power_status");
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/power/bitmain_power_APW9.c",
      173,
      "bitmain_get_power_status",
      24,
      547,
      100,
      v7);
  }
  return v0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119DF0: using guessed type int dword_119DF0;
// 119DF4: using guessed type int dword_119DF4;
// 11A7AC: using guessed type int g_zc;

//----- (0006D8E8) --------------------------------------------------------
int __fastcall bitmain_set_watchdog(int a1)
{
  int result; // r0
  int v3; // r5
  int v4; // r2
  char s[2048]; // [sp+10h] [bp-1804h] BYREF
  char v6[4100]; // [sp+810h] [bp-1004h] BYREF

  if ( !dword_119DF4 )
  {
    v3 = sub_6D270();
    if ( v3 < 0 )
    {
      snprintf(s, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_set_watchdog");
      V_LOCK();
      logfmt_raw(v6, 0x1000u, 0, s);
      V_UNLOCK();
      v4 = 561;
LABEL_7:
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/power/bitmain_power_APW9.c",
        173,
        "bitmain_set_watchdog",
        20,
        v4,
        100,
        v6);
      return v3;
    }
  }
  result = sub_6CE54((void *)dword_119DF0, a1 == 1);
  v3 = result;
  if ( result < 0 )
  {
    strcpy(s, "can nont set power watchdog\n");
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, s);
    V_UNLOCK();
    v4 = 573;
    goto LABEL_7;
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119DF0: using guessed type int dword_119DF0;
// 119DF4: using guessed type int dword_119DF4;
// 11A7AC: using guessed type int g_zc;

//----- (0006DA24) --------------------------------------------------------
int bitmain_power_fw_version()
{
  int v0; // r5
  int v2; // [sp+10h] [bp-1810h] BYREF
  __int16 v3; // [sp+14h] [bp-180Ch]
  int v4; // [sp+18h] [bp-1808h] BYREF
  int v5; // [sp+1Ch] [bp-1804h]
  char s[2048]; // [sp+20h] [bp-1800h] BYREF
  char v7[4096]; // [sp+820h] [bp-1000h] BYREF

  if ( dword_119DF4 || (v0 = sub_6D270(), v0 >= 0) )
  {
    v5 = 0;
    v4 = 0;
    v2 = 17082965;
    v3 = 5;
    if ( sub_6C9B8((void *)dword_119DF0, (unsigned __int8 *)&v2, 6u, (unsigned __int8 *)&v4, 8u) )
    {
      v0 = -2147482880;
      strcpy(s, "get power version failed\n");
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/power/bitmain_power_APW9.c",
        173,
        "_bitmain_get_power_fw_version",
        29,
        224,
        100,
        v7);
    }
    else
    {
      return (unsigned __int16)v5;
    }
  }
  else
  {
    snprintf(s, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_power_fw_version");
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/power/bitmain_power_APW9.c",
      173,
      "bitmain_power_fw_version",
      24,
      636,
      100,
      v7);
  }
  return v0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119DF0: using guessed type int dword_119DF0;
// 119DF4: using guessed type int dword_119DF4;
// 11A7AC: using guessed type int g_zc;

//----- (0006DBB8) --------------------------------------------------------
int __fastcall bitmain_set_voltage_by_n(__int16 a1)
{
  int v2; // r5
  char s[2048]; // [sp+10h] [bp-1804h] BYREF
  char v5[4100]; // [sp+810h] [bp-1004h] BYREF

  if ( dword_119DF4 )
    return sub_6CF54((void *)dword_119DF0, a1);
  v2 = sub_6D270();
  if ( v2 >= 0 )
    return sub_6CF54((void *)dword_119DF0, a1);
  snprintf(s, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_set_voltage_by_n");
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/power/bitmain_power_APW9.c",
    173,
    "bitmain_set_voltage_by_n",
    24,
    686,
    100,
    v5);
  return v2;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119DF0: using guessed type int dword_119DF0;
// 119DF4: using guessed type int dword_119DF4;
// 11A7AC: using guessed type int g_zc;

//----- (0006DC84) --------------------------------------------------------
void bitmain_convert_N_to_V_calibration()
{
  char *v0; // r12
  char *v1; // r2

  if ( dword_119E60 > 1 )
  {
    v0 = (char *)&unk_119E01;
    v1 = (char *)&unk_119E10;
    do
    {
      ++v0;
      v1 += 8;
    }
    while ( &byte_119E00[dword_119E60] != v0 );
  }
}
// 119E60: using guessed type int dword_119E60;

//----- (0006DD1C) --------------------------------------------------------
int bitmain_convert_V_to_N_calibration()
{
  double v0; // d0
  int v1; // s13
  double *v2; // r1
  int *v3; // r12
  int *v4; // r3
  double v5; // d5
  double v6; // d7

  if ( dword_119E60 > 1 )
  {
    v2 = (double *)&unk_119E10;
    v3 = (int *)((char *)&unk_119DEF + dword_119E60);
    v4 = &dword_119DF0;
    v1 = -1;
    while ( 1 )
    {
      v6 = *v2++;
      if ( v6 <= v0 )
      {
        v5 = *v2;
        if ( *v2 > v0 )
          goto LABEL_5;
      }
      if ( v6 <= v0 )
        goto LABEL_6;
      v5 = *v2;
      if ( *v2 <= v0 )
      {
LABEL_5:
        v1 = (int)((double)*((unsigned __int8 *)v4 + 16)
                 + (double)(*((unsigned __int8 *)v4 + 17) - *((unsigned __int8 *)v4 + 16)) / (v5 - v6) * (v0 - v6));
LABEL_6:
        v4 = (int *)((char *)v4 + 1);
        if ( v4 == v3 )
          return v1;
      }
      else
      {
        v4 = (int *)((char *)v4 + 1);
        if ( v4 == v3 )
          return v1;
      }
    }
  }
  return -1;
}
// 6DD58: variable 'v0' is possibly undefined
// 119DF0: using guessed type int dword_119DF0;
// 119E60: using guessed type int dword_119E60;

//----- (0006DDDC) --------------------------------------------------------
int bitmain_convert_V_to_N()
{
  double v0; // d0
  int v1; // r5
  char v3[4096]; // [sp+10h] [bp-1000h] BYREF

  v1 = bitmain_convert_V_to_N_calibration();
  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "N before calibration %d, N after calibration %d", (int)(1280.57782 - v0 * 73.979365), v1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/power/bitmain_power_APW9.c",
    173,
    "bitmain_convert_V_to_N",
    22,
    740,
    20,
    v3);
  if ( v1 <= 0 )
  {
    switch ( dword_119DF8 )
    {
      case 'A':
      case 'B':
        v1 = (int)(765.411764 - v0 * 35.833333);
        break;
      case 'C':
        v1 = (int)(933.240365 - v0 * 59.806034);
        break;
      case 'a':
        v1 = (int)(1144.50226 - v0 * 52.243589);
        break;
      case 'q':
      case 'r':
        v1 = (int)(1190.93534 - v0 * 78.742588);
        break;
      case 's':
      case 'x':
        v1 = (int)(1280.57782 - v0 * 73.979365);
        break;
      default:
        v1 = -1;
        break;
    }
  }
  return v1;
}
// 6DEA8: control flows out of bounds to 6DEAC
// 6DE20: variable 'v0' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119DF8: using guessed type int dword_119DF8;
// 11A7AC: using guessed type int g_zc;

//----- (0006E054) --------------------------------------------------------
int bitmain_set_voltage()
{
  int v0; // r5
  unsigned int v1; // r0
  char s[2048]; // [sp+10h] [bp-1800h] BYREF
  char v4[4096]; // [sp+810h] [bp-1000h] BYREF

  if ( dword_119DF4 || (v0 = sub_6D270(), v0 >= 0) )
  {
    v1 = bitmain_convert_V_to_N();
    if ( v1 > 0xFF )
      return -2147482879;
    else
      return sub_6CF54((void *)dword_119DF0, (unsigned __int8)v1);
  }
  else
  {
    snprintf(s, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_set_voltage");
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/power/bitmain_power_APW9.c",
      173,
      "bitmain_set_voltage",
      19,
      673,
      100,
      v4);
  }
  return v0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119DF0: using guessed type int dword_119DF0;
// 119DF4: using guessed type int dword_119DF4;
// 11A7AC: using guessed type int g_zc;

//----- (0006E144) --------------------------------------------------------
void bitmain_convert_N_to_V()
{
  bitmain_convert_N_to_V_calibration();
}
// 6E184: control flows out of bounds to 6E188
// 119DF8: using guessed type int dword_119DF8;

//----- (0006E350) --------------------------------------------------------
void bitmain_get_voltage()
{
  int v0; // [sp+10h] [bp-1814h] BYREF
  __int16 v1; // [sp+14h] [bp-1810h]
  _DWORD v2[2]; // [sp+18h] [bp-180Ch] BYREF
  char s[2048]; // [sp+20h] [bp-1804h] BYREF
  char v4[4100]; // [sp+820h] [bp-1004h] BYREF

  if ( dword_119DF4 || sub_6D270() >= 0 )
  {
    v2[1] = 0;
    v2[0] = 0;
    v0 = 50637397;
    v1 = 7;
    if ( sub_6C9B8((void *)dword_119DF0, (unsigned __int8 *)&v0, 6u, (unsigned __int8 *)v2, 8u) )
    {
      strcpy(s, "get AD conversion N failed\n");
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/power/bitmain_power_APW9.c",
        173,
        "_bitmain_get_AD_conversion_N",
        28,
        329,
        100,
        v4);
      strcpy(s, "can nont get voltage\n");
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/power/bitmain_power_APW9.c",
        173,
        "bitmain_get_voltage",
        19,
        661,
        100,
        v4);
    }
    else
    {
      bitmain_convert_N_to_V();
    }
  }
  else
  {
    snprintf(s, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_get_voltage");
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/power/bitmain_power_APW9.c",
      173,
      "bitmain_get_voltage",
      19,
      657,
      100,
      v4);
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119DF0: using guessed type int dword_119DF0;
// 119DF4: using guessed type int dword_119DF4;
// 11A7AC: using guessed type int g_zc;

//----- (0006E568) --------------------------------------------------------
int __fastcall bitmain_power_read(__int16 a1, int a2, int a3)
{
  int v6; // r5
  unsigned __int8 *v7; // r0
  int v8; // r3
  int v9; // r4
  char v10; // t1
  int v12; // r2
  int v13; // [sp+14h] [bp-183Ch] BYREF
  char v14; // [sp+18h] [bp-1838h]
  char v15; // [sp+19h] [bp-1837h]
  __int16 v16; // [sp+1Ah] [bp-1836h]
  unsigned __int8 v17[52]; // [sp+1Ch] [bp-1834h] BYREF
  char s[2048]; // [sp+50h] [bp-1800h] BYREF
  char v19[4096]; // [sp+850h] [bp-1000h] BYREF

  memset(v17, 0, 0x32u);
  v14 = a1;
  v15 = a3;
  v13 = 101100117;
  v16 = a3 + 12 + a1;
  if ( dword_119DF4 )
  {
    v6 = 0;
  }
  else
  {
    v6 = sub_6D270();
    if ( v6 < 0 )
    {
      snprintf(s, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_power_read");
      V_LOCK();
      logfmt_raw(v19, 0x1000u, 0, s);
      V_UNLOCK();
      v12 = 834;
LABEL_10:
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/power/bitmain_power_APW9.c",
        173,
        "bitmain_power_read",
        18,
        v12,
        100,
        v19);
      return v6;
    }
  }
  if ( sub_6C9B8((void *)dword_119DF0, (unsigned __int8 *)&v13, 8u, v17, a3 + 7) )
  {
    v6 = -2147482880;
    strcpy(s, "set DA conversion N failed\n");
    V_LOCK();
    logfmt_raw(v19, 0x1000u, 0, s);
    V_UNLOCK();
    v12 = 844;
    goto LABEL_10;
  }
  if ( a3 )
  {
    v7 = &v17[4];
    v8 = a2 - 1;
    v9 = a2 + (unsigned __int8)(a3 - 1);
    do
    {
      v10 = *++v7;
      *(_BYTE *)++v8 = v10;
    }
    while ( v8 != v9 );
  }
  return v6;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119DF0: using guessed type int dword_119DF0;
// 119DF4: using guessed type int dword_119DF4;
// 11A7AC: using guessed type int g_zc;

//----- (0006E720) --------------------------------------------------------
int get_power_voltage_calibration_data()
{
  int v0; // r0
  unsigned __int16 *v1; // r4
  double *v2; // r6
  unsigned __int8 *v3; // r5
  int v4; // r1
  double v5; // d7
  _BYTE v7[30]; // [sp+10h] [bp-20h] BYREF
  unsigned __int16 v8; // [sp+2Eh] [bp-2h] BYREF
  char v9[4100]; // [sp+30h] [bp+0h] BYREF

  bitmain_power_read(64, (int)v7, 32);
  v8 = HIBYTE(v8) | (v8 << 8);
  v0 = POWER_CRC16((int)v7, 30);
  if ( v8 == v0 )
  {
    v1 = (unsigned __int16 *)v7;
    v2 = (double *)&unk_119E10;
    v3 = &algn_119DFC[3];
    dword_119E60 = 0;
    do
    {
      v4 = *(unsigned __int8 *)v1;
      v1 = (unsigned __int16 *)((char *)v1 + 3);
      if ( !v4 && !*((_BYTE *)v1 - 2) && !*((_BYTE *)v1 - 1) )
        break;
      *v2 = (double)(*((unsigned __int8 *)v1 - 1) | ((unsigned __int8)(*(_BYTE *)(v1 - 1) & 3) << 8)) / 1000.0
          + (double)(*((unsigned __int8 *)v1 - 2) >> 2);
      *++v3 = v4;
      ++dword_119E60;
      V_LOCK();
      v5 = *v2++;
      logfmt_raw(v9, 0x1000u, 0, "vol %f N %d", v5, *v3);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/power/bitmain_power_APW9.c",
        173,
        "get_power_voltage_calibration_data",
        34,
        892,
        40,
        v9);
    }
    while ( v1 != &v8 );
    return 0;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, "%s error!", "get_power_voltage_calibration_data");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/power/bitmain_power_APW9.c",
      173,
      "get_power_voltage_calibration_data",
      34,
      875,
      100,
      v9);
    return -1;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119DFC: using guessed type _BYTE[4];
// 119E60: using guessed type int dword_119E60;
// 11A7AC: using guessed type int g_zc;

//----- (0006E8F0) --------------------------------------------------------
int __fastcall sub_6E8F0(int a1)
{
  char s[2048]; // [sp+10h] [bp-1800h] BYREF
  char v3[4096]; // [sp+810h] [bp-1000h] BYREF

  snprintf(s, 0x800u, " Bad T-sensor param, input chain is %d\n", a1);
  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/tsensor/bitmain_tsensor.c",
    172,
    "find_index",
    10,
    208,
    100,
    v3);
  return -2147482111;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0006E980) --------------------------------------------------------
int __fastcall sub_6E980(unsigned int a1, int a2)
{
  unsigned int v2; // lr
  unsigned __int8 *v3; // r3
  int v4; // r2
  int v5; // r12
  unsigned int v6; // r12
  int result; // r0

  if ( a1 > 0xF )
    return sub_6E8F0(a1);
  v2 = byte_119E68[68 * a1];
  v3 = &byte_119E68[68 * a1];
  if ( !*v3 )
    return -2147482112;
  if ( v3[4] != a2 )
  {
    v4 = 1;
    while ( 1 )
    {
      v6 = (unsigned __int8)v4;
      result = v4++;
      if ( v2 <= v6 )
        break;
      v5 = v3[12];
      v3 += 8;
      if ( v5 == a2 )
        return result;
    }
    return -2147482112;
  }
  return 0;
}
// 119E68: using guessed type unsigned __int8 byte_119E68[1088];

//----- (0006E9FC) --------------------------------------------------------
int __fastcall tsensor_open(unsigned int a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned __int8 *v4; // r11
  unsigned __int8 *v5; // r5
  _BYTE *v6; // r10
  int v7; // r0
  unsigned __int8 *v8; // r4
  int v9; // r2
  unsigned int v10; // r2
  int v11; // r0
  int v12; // r8
  int v13; // r2
  char v14; // r1
  int v15; // r2
  int v16; // r8
  int v18; // r2
  int v19; // [sp+14h] [bp-1810h]
  unsigned int v20; // [sp+18h] [bp-180Ch] BYREF
  __int16 v21; // [sp+1Ch] [bp-1808h]
  char v22; // [sp+1Eh] [bp-1806h]
  char v23; // [sp+1Fh] [bp-1805h]
  char s[2048]; // [sp+20h] [bp-1804h] BYREF
  char v25[4100]; // [sp+820h] [bp-1004h] BYREF

  if ( a1 > 0xF )
  {
    snprintf(s, 0x800u, " Bad T-sensor param, input chain is %d\n", a1);
    V_LOCK();
    logfmt_raw(v25, 0x1000u, 0, s);
    V_UNLOCK();
    v18 = 55;
LABEL_13:
    v16 = -2147482111;
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/tsensor/bitmain_tsensor.c",
      172,
      "tsensor_open",
      12,
      v18,
      100,
      v25);
    return v16;
  }
  if ( a3 > 7 )
  {
    snprintf(s, 0x800u, " Bad T-sensor param, input num is %d\n", a3);
    V_LOCK();
    logfmt_raw(v25, 0x1000u, 0, s);
    V_UNLOCK();
    v18 = 56;
    goto LABEL_13;
  }
  if ( !a3 )
    return 0;
  v19 = 68 * a1;
  v4 = a2;
  v5 = &a2[(unsigned __int8)(a3 - 1) + 1];
  v6 = (_BYTE *)(68 * a1 + 1154664);
  while ( 1 )
  {
    while ( 1 )
    {
      v7 = sub_6E980(a1, *v4);
      v8 = v4++;
      if ( v7 == -2147482112 )
        break;
      if ( v4 == v5 )
        return 0;
    }
    v9 = *(v4 - 1);
    v20 = a1;
    v10 = v9 + a1;
    v21 = 0;
    v22 = (v10 >> 3) & 0xF;
    v23 = v10 & 7;
    v11 = iic_init((int)&v20);
    v12 = v11;
    if ( v11 < 0 )
      break;
    v13 = (unsigned __int8)*v6;
    *v6 = v13 + 1;
    v14 = *(v4 - 1);
    v15 = v19 + 8 * v13 + 1154664;
    *(_DWORD *)(v15 + 8) = v11;
    *(_BYTE *)(v15 + 4) = v14;
    if ( v4 == v5 )
      return 0;
  }
  snprintf(s, 0x800u, " open T-sensor error, chain is %d,slave addr is %d\n", a1, *v8);
  V_LOCK();
  logfmt_raw(v25, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/tsensor/bitmain_tsensor.c",
    172,
    "tsensor_open",
    12,
    75,
    100,
    v25);
  return v12;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0006EC58) --------------------------------------------------------
int __fastcall tsensor_close(unsigned int a1)
{
  int v2; // r6
  int v3; // r5
  unsigned int v4; // r4
  int v5; // r0
  char s[2048]; // [sp+10h] [bp-1804h] BYREF
  char v8[4100]; // [sp+810h] [bp-1004h] BYREF

  if ( a1 > 0xF )
  {
    snprintf(s, 0x800u, " Bad T-sensor param, input chain is %d\n", a1);
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/tsensor/bitmain_tsensor.c",
      172,
      "tsensor_close",
      13,
      91,
      100,
      v8);
    return -2147482111;
  }
  else
  {
    v2 = 16 * a1;
    v3 = 68 * a1;
    if ( byte_119E68[68 * a1] )
    {
      v4 = 0;
      do
      {
        v5 = *(_DWORD *)&byte_119E68[8 * v4 + 8 + v3];
        if ( v5 )
          iic_uninit(v5);
        v4 = (unsigned __int8)(v4 + 1);
      }
      while ( byte_119E68[v3] > v4 );
    }
    return (int)memset(&byte_119E68[4 * v2 + 4 * a1], 0, 0x44u);
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119E68: using guessed type unsigned __int8 byte_119E68[1088];
// 11A7AC: using guessed type int g_zc;

//----- (0006ED78) --------------------------------------------------------
int __fastcall tsensor_write(unsigned int a1, unsigned __int8 a2, unsigned __int8 a3, int a4, int a5)
{
  int v8; // r0
  int v9; // r8
  unsigned __int8 *v10; // r6
  int v11; // r0
  int v12; // r3
  int v13; // r6
  int v14; // r2
  int v16; // r2
  unsigned __int8 v17[8]; // [sp+17h] [bp-1809h] BYREF
  unsigned __int8 v18; // [sp+1Fh] [bp-1801h] BYREF
  char s[2048]; // [sp+20h] [bp-1800h] BYREF
  char v20[4096]; // [sp+820h] [bp-1000h] BYREF

  v17[0] = a2;
  if ( a1 > 0xF )
  {
    LOWORD(v13) = 1537;
    snprintf(s, 0x800u, " Bad T-sensor param, input chain is %d\n", a1);
    V_LOCK();
    logfmt_raw(v20, 0x1000u, 0, s);
    V_UNLOCK();
    v14 = 112;
LABEL_8:
    HIWORD(v13) = 0x8000;
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/tsensor/bitmain_tsensor.c",
      172,
      "tsensor_write",
      13,
      v14,
      100,
      v20);
    return v13;
  }
  v8 = sub_6E980(a1, v17[0]);
  if ( v8 == -2147482112 )
  {
    v13 = tsensor_open(a1, v17, 1u);
    if ( v13 < 0 )
    {
      snprintf(s, 0x800u, " auto exec tsensor_open, but chain %d,slave_addr %d open failed\n", a1, v17[0]);
      V_LOCK();
      logfmt_raw(v20, 0x1000u, 0, s);
      V_UNLOCK();
      v16 = 121;
    }
    else
    {
      v8 = sub_6E980(a1, v17[0]);
      if ( v8 != -2147482112 )
        goto LABEL_3;
      snprintf(s, 0x800u, " auto exec tsensor_open, but chain %d,slave_addr %d open failed\n", a1, v17[0]);
      V_LOCK();
      logfmt_raw(v20, 0x1000u, 0, s);
      V_UNLOCK();
      v16 = 128;
    }
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/tsensor/bitmain_tsensor.c",
      172,
      "tsensor_write",
      13,
      v16,
      100,
      v20);
    return v13;
  }
LABEL_3:
  if ( a5 )
  {
    v9 = a4 + a5;
    v10 = &byte_119E68[68 * a1 + 8 * v8];
    while ( 1 )
    {
      v11 = *((_DWORD *)v10 + 2);
      v12 = a4;
      v18 = a3;
      ++a4;
      ++a3;
      if ( iic_write_reg(v11, &v18, 1, v12, 1) != 1 )
        break;
      if ( a4 == v9 )
        return a5;
    }
    LOWORD(v13) = 1536;
    snprintf(s, 0x800u, "fail to write tsensor by iic, chain:%d, slave: %d, addr: %d", a1, v17[0], v18);
    V_LOCK();
    logfmt_raw(v20, 0x1000u, 0, s);
    V_UNLOCK();
    v14 = 140;
    goto LABEL_8;
  }
  return a5;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119E68: using guessed type unsigned __int8 byte_119E68[1088];
// 11A7AC: using guessed type int g_zc;

//----- (0006F01C) --------------------------------------------------------
int __fastcall tsensor_read(unsigned int a1, unsigned __int8 a2, unsigned __int8 a3, int a4, unsigned int a5)
{
  int v7; // r0
  int v8; // r8
  int v10; // r8
  int v11; // r2
  unsigned __int8 v12; // [sp+16h] [bp-1802h] BYREF
  unsigned __int8 v13; // [sp+17h] [bp-1801h] BYREF
  char s[2040]; // [sp+18h] [bp-1800h] BYREF
  char v15[4072]; // [sp+818h] [bp-1000h] BYREF

  v13 = a2;
  v12 = a3;
  if ( a1 > 0xF )
  {
    v8 = -2147482111;
    snprintf(s, 0x800u, " Bad T-sensor param, input chain is %d\n", a1);
    V_LOCK();
    logfmt_raw(v15, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/tsensor/bitmain_tsensor.c",
      172,
      "tsensor_read",
      12,
      155,
      100,
      v15);
    return v8;
  }
  v7 = sub_6E980(a1, v13);
  if ( v7 != -2147482112 )
    goto LABEL_3;
  v10 = tsensor_open(a1, &v13, 1u);
  if ( v10 < 0 )
  {
    snprintf(s, 0x800u, " auto exec tsensor_open, but chain %d,slave_addr %d open failed\n", a1, v13);
    V_LOCK();
    logfmt_raw(v15, 0x1000u, 0, s);
    V_UNLOCK();
    v11 = 164;
    goto LABEL_9;
  }
  v7 = sub_6E980(a1, v13);
  if ( v7 == -2147482112 )
  {
    snprintf(s, 0x800u, " auto exec tsensor_open, but chain %d,slave_addr %d open failed\n", a1, v13);
    V_LOCK();
    logfmt_raw(v15, 0x1000u, 0, s);
    V_UNLOCK();
    v11 = 171;
  }
  else
  {
LABEL_3:
    v8 = iic_read_reg(*(void **)&byte_119E68[68 * a1 + 8 + 8 * v7], &v12, 2, a4, a5);
    if ( v8 == a5 )
      return v8;
    v10 = -2147482112;
    snprintf(s, 0x800u, "fail to read tsensor by iic, chain: %d, slave: %d, addr: %d\n", a1, v13, v12);
    V_LOCK();
    logfmt_raw(v15, 0x1000u, 0, s);
    V_UNLOCK();
    v11 = 196;
  }
LABEL_9:
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/tsensor/bitmain_tsensor.c",
    172,
    "tsensor_read",
    12,
    v11,
    100,
    v15);
  return v10;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119E68: using guessed type unsigned __int8 byte_119E68[1088];
// 11A7AC: using guessed type int g_zc;

//----- (0006F2B0) --------------------------------------------------------
int __fastcall get_response(int a1)
{
  unsigned int v2; // r8
  char *v3; // r4
  int v4; // r0
  void *v5; // r0
  int v6; // r0
  int v7; // r0
  int v8; // r7
  size_t v9; // r4
  __useconds_t v10; // r0
  char v12[4096]; // [sp+10h] [bp-1000h] BYREF

  v2 = 64;
  v3 = (char *)calloc(1u, 0x40u);
  snprintf(v3, 0x40u, "%.10s_%d", "get_response", *(_DWORD *)(a1 + 196));
  V_LOCK();
  v4 = syscall(224);
  logfmt_raw(v12, 0x1000u, 0, "%s on pid %ld", v3, v4);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/backend_base.c",
    150,
    "get_response",
    12,
    186,
    40,
    v12);
  prctl(15, v3);
  v5 = memset(v12, 0, 0x100u);
  while ( 1 )
  {
    v6 = dev_ctrl(v5);
    v7 = (*(int (__fastcall **)(_DWORD, char *, int))(v6 + 60))(*(_DWORD *)(a1 + 196), v12, 256);
    v8 = *(unsigned __int8 *)(a1 + 821);
    v9 = v7;
    if ( *(_BYTE *)(a1 + 821) )
      break;
    if ( v7 <= 0 )
    {
      v10 = v2;
      v2 *= 2;
      v5 = (void *)usleep(v10);
      if ( v2 >= 0x3E8 )
        v2 = 1000;
    }
    else
    {
      v2 = 64;
      queue_enqueue(*(_DWORD *)(a1 + 792), v12, v7);
      v5 = memset(v12, v8, v9);
    }
  }
  *(_BYTE *)(a1 + 821) = 0;
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4AB8C: using guessed type int __fastcall dev_ctrl(_DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0006F408) --------------------------------------------------------
int __fastcall platform_check_repeat_nonce(int *a1, int a2, char *s2)
{
  size_t v3; // r8
  int v5; // r5
  int v7; // r4
  const void *v8; // r7
  void *v9; // r5
  char *v10; // r9
  char *v11; // r11
  void *v12; // r0
  bool v13; // zf
  char *v15; // r5
  char *v16; // r2
  char *v17; // r8
  int v18; // t1
  char *v19; // r0
  char *v20; // r0
  char *v21; // r0
  size_t v22; // [sp+3Ch] [bp-1040h]
  void *v23; // [sp+40h] [bp-103Ch]
  void *ptr; // [sp+44h] [bp-1038h]
  void *v25; // [sp+48h] [bp-1034h]
  char *v26; // [sp+4Ch] [bp-1030h]
  _DWORD v28[7]; // [sp+58h] [bp-1024h] BYREF
  int v29; // [sp+74h] [bp-1008h]
  char v30[4100]; // [sp+78h] [bp-1004h] BYREF

  v3 = a1[193];
  v5 = a1[107];
  v7 = v3 * 2 * a2;
  v8 = (const void *)(v5 + v7);
  v22 = v3 + v7;
  if ( memcmp((const void *)(v5 + v7), s2, v3) )
  {
    v9 = (void *)(v5 + v3 + v7);
    if ( memcmp(v9, s2, v3) )
    {
      memcpy(v9, v8, v3);
      memcpy((void *)(a1[107] + v7), s2, v3);
      return 0;
    }
  }
  v10 = (char *)calloc(2 * v3 + 1, 1u);
  v25 = v10;
  v11 = (char *)calloc(2 * v3 + 1, 1u);
  v23 = v11;
  v12 = calloc(2 * v3 + 1, 1u);
  v13 = v10 == 0;
  if ( v10 )
    v13 = v11 == 0;
  ptr = v12;
  if ( v13 )
  {
    if ( v12 )
      goto LABEL_17;
    if ( !v11 )
      goto LABEL_9;
LABEL_18:
    free(v23);
    goto LABEL_9;
  }
  if ( !v12 )
    goto LABEL_18;
  if ( v3 )
  {
    v15 = s2 - 1;
    v16 = &s2[v3 - 1];
    v17 = (char *)v12;
    v26 = v16;
    do
    {
      v18 = (unsigned __int8)*++v15;
      v19 = v10;
      v10 += 2;
      sprintf(v19, "%02x", v18);
      v20 = v11;
      v11 += 2;
      sprintf(v20, "%02x", *(unsigned __int8 *)(a1[107] + v7 + v15 - s2));
      v21 = v17;
      v17 += 2;
      sprintf(v21, "%02x", *(unsigned __int8 *)(a1[107] + v22 + v15 - s2));
    }
    while ( v15 != v26 );
  }
  V_LOCK();
  V_INT((int)v28, "chain", a1[50]);
  logfmt_raw(
    v30,
    0x1000u,
    0,
    v29,
    v28[0],
    v28[1],
    v28[2],
    v28[3],
    v28[4],
    v28[5],
    v28[6],
    v29,
    "asic %d repeat nonce %s %s %s",
    a2,
    v25,
    v23,
    ptr);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/backend_base.c",
    150,
    "platform_check_repeat_nonce",
    27,
    80,
    20,
    v30);
LABEL_17:
  free(ptr);
  if ( v23 )
    goto LABEL_18;
LABEL_9:
  if ( v25 )
    free(v25);
  return 4;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0006F69C) --------------------------------------------------------
int __fastcall scanhash(int a1)
{
  char *v2; // r5
  int v3; // r0
  int v4; // r5
  void *v5; // r8
  char *v6; // r9
  int v7; // r3
  unsigned int v9; // r11
  int v10; // r10
  int v11; // r0
  unsigned int v12; // r0
  int v13; // r1
  _QWORD *v14; // r10
  __int64 v15; // kr08_8
  int v16; // r1
  char v17; // [sp+17h] [bp-100Dh] BYREF
  int v18; // [sp+18h] [bp-100Ch] BYREF
  int v19; // [sp+1Ch] [bp-1008h] BYREF
  char v20[4100]; // [sp+20h] [bp-1004h] BYREF

  v2 = (char *)calloc(1u, 0x40u);
  snprintf(v2, 0x40u, "%.10s_%d", "scanhash", *(_DWORD *)(a1 + 196));
  V_LOCK();
  v3 = syscall(224);
  logfmt_raw(v20, 0x1000u, 0, "%s on pid %ld", v2, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/backend_base.c",
    150,
    "scanhash",
    8,
    98,
    40,
    v20);
  prctl(15, v2);
  v4 = *(_DWORD *)(a1 + 792);
  v5 = calloc(1u, *(_DWORD *)(a1 + 768));
  v6 = (char *)calloc(1u, *(_DWORD *)(a1 + 772));
  while ( 1 )
  {
    memset(v20, 0, 0x200u);
    queue_dequeue(v4, v20, 1u);
    if ( *(_BYTE *)(a1 + 820) )
      break;
LABEL_5:
    v7 = (unsigned __int8)v20[0];
    while ( 1 )
    {
      if ( v7 != 170 )
      {
        queue_dequeue(v4, v20, 1u);
        if ( *(_BYTE *)(a1 + 820) )
          goto LABEL_10;
        goto LABEL_5;
      }
      queue_dequeue(v4, &v20[1], 1u);
      if ( *(_BYTE *)(a1 + 820) )
        goto LABEL_10;
      v7 = (unsigned __int8)v20[1];
      if ( v20[1] == 85 )
        break;
      v20[0] = v20[1];
    }
    queue_dequeue(v4, &v20[2], 1u);
    v9 = (*(int (__fastcall **)(_DWORD))(a1 + 160))((unsigned __int8)v20[2]);
    queue_dequeue(v4, &v20[3], v9);
    v10 = *(unsigned __int8 *)(a1 + 820);
    if ( *(_BYTE *)(a1 + 820) )
      break;
    memset(v5, *(unsigned __int8 *)(a1 + 820), *(_DWORD *)(a1 + 768));
    v18 = v10;
    v19 = v10;
    v17 = v10;
    v11 = (*(int (__fastcall **)(int, char *, void *, char *, char *, int *, int *))(a1 + 60))(
            a1,
            v20,
            v5,
            &v17,
            v6,
            &v18,
            &v19);
    if ( v11 == 10 )
    {
      queue_enqueue(*(_DWORD *)(a1 + 800), v20, v9 + 3);
    }
    else if ( v11 == 11 )
    {
      ++*(_QWORD *)(*(_DWORD *)(a1 + 400) + 40);
    }
    else if ( !v11 && *(_BYTE *)(a1 + 206) )
    {
      if ( !*(_BYTE *)(a1 + v19 + 472) && v17 && platform_check_repeat_nonce((int *)a1, v18, v6) )
      {
        ++*(_QWORD *)(*(_DWORD *)(a1 + 400) + 48 * v18 + 32);
      }
      else
      {
        v12 = (*(int (__fastcall **)(int, void *))(a1 + 64))(a1, v5);
        if ( v12 <= 5 )
        {
          v13 = v18;
          v14 = (_QWORD *)(*(_DWORD *)(a1 + 400) + 48 * v18 + 8 * v12);
          ++*v14;
          if ( v12 <= 1 )
          {
            v15 = *(_QWORD *)(a1 + 392) + 1LL;
            ++*(_DWORD *)(*(_DWORD *)(a1 + 424) + 4 * v13);
            v16 = v19;
            *(_QWORD *)(a1 + 392) = v15;
            ++*(_QWORD *)(a1 + 8 * v16 + 504);
            if ( !v12 && !*(_BYTE *)(a1 + v16 + 472) )
              queue_enqueue(*(_DWORD *)(*(_DWORD *)(a1 + 804) + 796), (char *)v5, 1);
          }
        }
      }
    }
  }
LABEL_10:
  *(_BYTE *)(a1 + 820) = 0;
  free(v5);
  free(v6);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0006FA34) --------------------------------------------------------
int __fastcall backend_exit_base(int a1)
{
  void (__fastcall *v2)(int); // r3
  int v3; // r0
  int v4; // r0
  void *thread_return[2]; // [sp+4h] [bp-8h] BYREF

  *(_BYTE *)(a1 + 205) = 0;
  *(_BYTE *)(a1 + 206) = 0;
  *(_BYTE *)(a1 + 204) = 0;
  (*(void (**)(void))(a1 + 48))();
  v2 = *(void (__fastcall **)(int))(a1 + 72);
  if ( v2 )
    v2(a1);
  v3 = *(_DWORD *)(a1 + 792);
  *(_BYTE *)(a1 + 820) = 1;
  *(_BYTE *)(a1 + 821) = 1;
  *(_BYTE *)(a1 + 822) = 1;
  queue_force_wakeup(v3);
  queue_force_wakeup(*(_DWORD *)(a1 + 796));
  queue_force_wakeup(*(_DWORD *)(a1 + 800));
  queue_force_wakeup(*(_DWORD *)(a1 + 788));
  pthread_join(*(_DWORD *)(a1 + 812), thread_return);
  pthread_join(*(_DWORD *)(a1 + 808), thread_return);
  pthread_join(*(_DWORD *)(a1 + 816), thread_return);
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 824));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 848));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 872));
  queue_free(*(_DWORD *)(a1 + 792));
  queue_free(*(_DWORD *)(a1 + 796));
  queue_free(*(_DWORD *)(a1 + 800));
  queue_free(*(_DWORD *)(a1 + 788));
  free(*(void **)(a1 + 432));
  free(*(void **)(a1 + 424));
  free(*(void **)(a1 + 428));
  free(*(void **)(a1 + 400));
  if ( *(_DWORD *)(a1 + 784) )
    free(*(void **)(a1 + 460));
  *(_DWORD *)(a1 + 372) = -1;
  *(_DWORD *)(a1 + 464) = 0;
  *(_QWORD *)(a1 + 384) = 0;
  *(_QWORD *)(a1 + 392) = 0;
  *(_DWORD *)(a1 + 804) = 0;
  v4 = dev_ctrl();
  (*(void (__fastcall **)(_DWORD))(v4 + 28))(*(_DWORD *)(a1 + 196));
  return 0;
}
// 4AB8C: using guessed type int dev_ctrl(void);

//----- (0006FB74) --------------------------------------------------------
int __fastcall async_push_work_base(int a1, char *a2)
{
  queue_enqueue(*(_DWORD *)(a1 + 788), a2, 1);
  return 0;
}

//----- (0006FB8C) --------------------------------------------------------
int __fastcall push_work_base(int a1, int a2)
{
  pthread_mutex_t *v4; // r7
  void *v5; // r6
  unsigned int v6; // r0
  int v7; // r0
  int v8; // r0
  int v9; // r5
  unsigned int v11; // [sp+14h] [bp-101Ch] BYREF
  char v12[4120]; // [sp+18h] [bp-1018h] BYREF

  if ( !*(_BYTE *)(a1 + 206) && !*(_BYTE *)(a1 + 205) )
    return 13;
  v4 = (pthread_mutex_t *)(a1 + 872);
  v5 = calloc(1u, *(_DWORD *)(a1 + 776));
  v11 = 0;
  (*(void (__fastcall **)(int, int, void *, unsigned int *))(a1 + 56))(a1, a2, v5, &v11);
  v6 = pthread_mutex_lock(v4);
  do
  {
    v7 = dev_ctrl(v6);
    v6 = (*(int (__fastcall **)(_DWORD))(v7 + 68))(*(_DWORD *)(a1 + 196));
  }
  while ( v6 < v11 );
  v8 = dev_ctrl(v6);
  v9 = (*(int (__fastcall **)(_DWORD, void *, unsigned int))(v8 + 52))(*(_DWORD *)(a1 + 196), v5, v11);
  pthread_mutex_unlock(v4);
  if ( v9 <= 0 )
  {
    V_LOCK();
    logfmt_raw(v12, 0x1000u, 0, "device %d push work failed,errcode %d", *(_DWORD *)(a1 + 196), v9);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/backend_base.c",
      150,
      "push_work_base",
      14,
      283,
      100,
      v12);
  }
  else
  {
    ++*(_QWORD *)(a1 + 384);
  }
  free(v5);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4AB8C: using guessed type int __fastcall dev_ctrl(_DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0006FCE8) --------------------------------------------------------
int __fastcall send_work(int a1)
{
  char *v2; // r5
  int v3; // r0
  void *v4; // r0
  size_t v5; // r2
  void *v6; // r5
  size_t v8; // [sp+14h] [bp-1004h]
  char v9[4096]; // [sp+18h] [bp-1000h] BYREF

  v2 = (char *)calloc(1u, 0x40u);
  snprintf(v2, 0x40u, "%.10s_%d", "send_work", *(_DWORD *)(a1 + 196));
  V_LOCK();
  v3 = syscall(224);
  logfmt_raw(v9, 0x1000u, 0, "%s on pid %ld", v2, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/backend_base.c",
    150,
    "send_work",
    9,
    45,
    40,
    v9);
  prctl(15, v2);
  v8 = *(_DWORD *)(a1 + 764);
  v4 = calloc(1u, v8);
  v5 = v8;
  v6 = v4;
  while ( 1 )
  {
    memset(v6, 0, v5);
    queue_dequeue(*(_DWORD *)(a1 + 788), (char *)v6, 1u);
    if ( *(_BYTE *)(a1 + 822) )
      break;
    push_work_base(a1, (int)v6);
    v5 = *(_DWORD *)(a1 + 764);
  }
  *(_BYTE *)(a1 + 822) = 0;
  free(v6);
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0006FE1C) --------------------------------------------------------
int __fastcall pop_ans_base(int a1, char *a2)
{
  queue_dequeue(*(_DWORD *)(*(_DWORD *)(a1 + 804) + 796), a2, 1u);
  return 0;
}

//----- (0006FE38) --------------------------------------------------------
int __fastcall try_pop_ans_base(int a1, char *a2)
{
  return queue_try_dequeue(*(_DWORD *)(*(_DWORD *)(a1 + 804) + 796), a2, 1u);
}

//----- (0006FE48) --------------------------------------------------------
int __fastcall backend_init_base(int a1)
{
  int v2; // r0
  int v3; // r0
  int v4; // r0
  int v5; // r0
  int v6; // r0
  size_t v7; // r5
  void *v8; // r0
  int v9; // r1
  void *v10; // r0
  size_t v11; // r1
  int v12; // r3
  bool v13; // zf
  void (__fastcall *v14)(int); // r3

  v2 = dev_ctrl(a1);
  v3 = (*(int (__fastcall **)(_DWORD))(v2 + 48))(*(_DWORD *)(a1 + 196));
  *(_DWORD *)(a1 + 200) = v3;
  v4 = dev_ctrl(v3);
  v5 = (*(int (__fastcall **)(_DWORD))(v4 + 44))(*(_DWORD *)(a1 + 196));
  v6 = dev_ctrl(v5);
  (*(void (__fastcall **)(_DWORD))(v6 + 4))(*(_DWORD *)(a1 + 196));
  *(_DWORD *)(a1 + 792) = queue_new(1, 0);
  *(_DWORD *)(a1 + 796) = queue_new(*(_DWORD *)(a1 + 768), 0);
  *(_DWORD *)(a1 + 800) = queue_new(1, 0);
  *(_DWORD *)(a1 + 788) = queue_new(*(_DWORD *)(a1 + 764), 0);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 824), 0);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 848), 0);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 872), 0);
  v7 = *(_DWORD *)(a1 + 280);
  *(_DWORD *)(a1 + 432) = calloc(v7, 1u);
  v8 = calloc(v7, 4u);
  v9 = *(_DWORD *)(a1 + 772);
  *(_DWORD *)(a1 + 424) = v8;
  *(_DWORD *)(a1 + 428) = calloc(v7, 2 * v9);
  v10 = calloc(v7, 0x30u);
  v11 = *(_DWORD *)(a1 + 784);
  *(_DWORD *)(a1 + 400) = v10;
  *(_QWORD *)(a1 + 384) = 0;
  *(_QWORD *)(a1 + 392) = 0;
  *(_DWORD *)(a1 + 372) = -1;
  *(_DWORD *)(a1 + 416) = 0;
  *(_DWORD *)(a1 + 420) = 0;
  *(_BYTE *)(a1 + 404) = 0;
  *(_DWORD *)(a1 + 408) = 0;
  *(_DWORD *)(a1 + 436) = 0;
  *(_DWORD *)(a1 + 456) = 0;
  if ( v11 )
    *(_DWORD *)(a1 + 460) = calloc(v7, v11);
  *(_DWORD *)(a1 + 464) = 0;
  memset((void *)(a1 + 504), 0, 0x100u);
  v12 = *(_DWORD *)(a1 + 804);
  *(_BYTE *)(a1 + 820) = 0;
  *(_BYTE *)(a1 + 821) = 0;
  v13 = v12 == 0;
  v14 = *(void (__fastcall **)(int))(a1 + 68);
  if ( v13 )
    *(_DWORD *)(a1 + 804) = a1;
  *(_BYTE *)(a1 + 822) = 0;
  if ( v14 )
    v14(a1);
  pthread_create((pthread_t *)(a1 + 812), 0, (void *(*)(void *))get_response, (void *)a1);
  pthread_create((pthread_t *)(a1 + 808), 0, (void *(*)(void *))scanhash, (void *)a1);
  pthread_create((pthread_t *)(a1 + 816), 0, (void *(*)(void *))send_work, (void *)a1);
  *(_BYTE *)(a1 + 204) = 1;
  return 0;
}
// 4AB8C: using guessed type int __fastcall dev_ctrl(_DWORD);

//----- (0007002C) --------------------------------------------------------
int __fastcall reset_base(int a1)
{
  int v2; // r0
  int v3; // r0
  int v4; // r3
  int v5; // r2

  v2 = (*(int (**)(void))(a1 + 48))();
  v3 = dev_ctrl(v2);
  (*(void (__fastcall **)(_DWORD))(v3 + 44))(*(_DWORD *)(a1 + 196));
  queue_clear(*(_DWORD *)(a1 + 792));
  v4 = *(_DWORD *)(a1 + 280);
  v5 = *(_DWORD *)(a1 + 784);
  *(_QWORD *)(a1 + 384) = 0;
  *(_QWORD *)(a1 + 392) = 0;
  *(_DWORD *)(a1 + 464) = 0;
  memset(*(void **)(a1 + 460), 0, v5 * v4);
  return 0;
}
// 4AB8C: using guessed type int __fastcall dev_ctrl(_DWORD);

//----- (00070094) --------------------------------------------------------
int __fastcall dhash_mining_start_base(int a1)
{
  *(_BYTE *)(a1 + 206) = 1;
  return 0;
}

//----- (000700A4) --------------------------------------------------------
int __fastcall dhash_mining_stop_base(int a1)
{
  (*(void (**)(void))(a1 + 4))();
  *(_BYTE *)(a1 + 205) = 0;
  *(_BYTE *)(a1 + 206) = 0;
  return 0;
}

//----- (000700C8) --------------------------------------------------------
int __fastcall dhash_mining_reset_base(int a1)
{
  int v2; // r0
  int v3; // r0
  unsigned int v4; // r0
  int v5; // r0
  unsigned int v6; // r0
  int v7; // r0
  int v8; // r0
  int v9; // r0
  _DWORD v11[7]; // [sp+28h] [bp-1020h] BYREF
  int v12; // [sp+44h] [bp-1004h]
  char v13[4096]; // [sp+48h] [bp-1000h] BYREF

  V_LOCK();
  V_INT((int)v11, "chain", *(int *)(a1 + 200));
  logfmt_raw(v13, 0x1000u, 0, v12, v11[0], v11[1], v11[2], v11[3], v11[4], v11[5], v11[6], v12, "dhash mining reset!");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/backend_base.c",
    150,
    "dhash_mining_reset_base",
    23,
    394,
    80,
    v13);
  v2 = (*(int (__fastcall **)(int))(a1 + 4))(a1);
  *(_BYTE *)(a1 + 205) = 0;
  *(_BYTE *)(a1 + 206) = 0;
  v3 = dev_ctrl(v2);
  (*(void (__fastcall **)(_DWORD))(v3 + 28))(*(_DWORD *)(a1 + 196));
  v4 = sleep(0xAu);
  v5 = dev_ctrl(v4);
  (*(void (__fastcall **)(_DWORD, _DWORD, _DWORD))(v5 + 24))(
    *(_DWORD *)(a1 + 196),
    *(_DWORD *)(a1 + 904),
    *(_DWORD *)(a1 + 928));
  v6 = sleep(1u);
  v7 = dev_ctrl(v6);
  v8 = (*(int (__fastcall **)(_DWORD))(v7 + 44))(*(_DWORD *)(a1 + 196));
  v9 = dev_ctrl(v8);
  (*(void (__fastcall **)(_DWORD))(v9 + 4))(*(_DWORD *)(a1 + 196));
  return (*(int (__fastcall **)(int))(a1 + 8))(a1);
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4AB8C: using guessed type int __fastcall dev_ctrl(_DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (000701FC) --------------------------------------------------------
int __fastcall set_chipaddr_base(int a1, int a2, int a3)
{
  bool v6; // cc
  char v7; // t1
  char v8; // r0
  __int16 v10; // [sp+0h] [bp-18h] BYREF
  int v11; // [sp+2h] [bp-16h] BYREF
  char v12; // [sp+6h] [bp-12h]

  if ( !*(_BYTE *)(a1 + 204) )
    return 4;
  (*(void (**)(void))(a1 + 212))();
  usleep(0x2710u);
  v11 = 0;
  v6 = a3 <= 0;
  v10 = -21931;
  if ( a3 > 0 )
    --a2;
  v12 = 0;
  BYTE1(v11) = 5;
  if ( a3 > 0 )
    a3 += a2;
  LOBYTE(v11) = 64;
  if ( !v6 )
  {
    do
    {
      usleep(0x2710u);
      v7 = *(_BYTE *)++a2;
      BYTE2(v11) = v7;
      v8 = BM_CRC5(&v11, 8 * (BYTE1(v11) - 1));
      v12 = v12 & 0xE0 | v8 & 0x1F;
      send_command_packet(a1, (int)&v10, 7u);
    }
    while ( a2 != a3 );
  }
  return 0;
}

//----- (000702C8) --------------------------------------------------------
int __fastcall set_inactive_base(int a1)
{
  char v2; // r0
  int v4; // [sp+0h] [bp-18h] BYREF
  __int16 v5; // [sp+4h] [bp-14h]
  char v6; // [sp+6h] [bp-12h]

  if ( !*(_BYTE *)(a1 + 204) )
    return 4;
  v5 = 0;
  v6 = 0;
  v4 = 89369173;
  v2 = BM_CRC5((_BYTE *)&v4 + 2, 32);
  v6 = v6 & 0xE0 | v2 & 0x1F;
  send_command_packet(a1, (int)&v4, 7u);
  return 0;
}

//----- (00070338) --------------------------------------------------------
int __fastcall sync_get_chip_reg_base(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  char v12; // lr
  char v13; // r12
  __int16 v14; // lr
  char v15; // r0
  int v16; // r1
  int v17; // r0
  bool v18; // zf
  int (__fastcall *v19)(int, int, int, int, int, int); // r4
  _BYTE v21[2]; // [sp+8h] [bp-28h] BYREF
  int v22; // [sp+Ah] [bp-26h] BYREF
  char v23; // [sp+Eh] [bp-22h]

  if ( !*(_BYTE *)(a1 + 204) )
    return 4;
  v22 = 0;
  v12 = *(_BYTE *)(a2 + 8);
  v23 = 0;
  v13 = (16 * (v12 & 1)) | 2;
  v14 = *(_WORD *)(a2 + 10);
  v21[0] = 85;
  v22 = v13 & 0x1F | 0x40;
  HIBYTE(v22) = v14;
  v21[1] = -86;
  BYTE1(v22) = 5;
  v15 = BM_CRC5(&v22, 32);
  v23 = v23 & 0xE0 | v15 & 0x1F;
  send_command_packet(a1, (int)v21, 7u);
  v16 = *(unsigned __int8 *)(a2 + 8);
  v17 = a1;
  v18 = v16 == 0;
  if ( *(_BYTE *)(a2 + 8) )
    v16 = a3;
  v19 = *(int (__fastcall **)(int, int, int, int, int, int))(a1 + 232);
  if ( v18 )
    v16 = 1;
  return v19(v17, v16, a4, a5, a7, a8);
}

//----- (00070410) --------------------------------------------------------
int __fastcall set_chip_reg_base(int a1, int a2)
{
  char v2; // r2
  __int16 v4; // r12
  char v5; // r3
  char v6; // r2
  unsigned int v7; // r0
  char v8; // r0
  _BYTE v10[2]; // [sp+4h] [bp-1Ch] BYREF
  int v11; // [sp+6h] [bp-1Ah] BYREF
  unsigned int v12; // [sp+Ah] [bp-16h]
  char v13; // [sp+Eh] [bp-12h]

  if ( !*(_BYTE *)(a1 + 204) )
    return 4;
  v2 = *(_BYTE *)(a2 + 8);
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v4 = *(_WORD *)(a2 + 10);
  v5 = (16 * (v2 & 1)) | 1;
  v6 = *(_BYTE *)(a2 + 9);
  v7 = *(_DWORD *)a2;
  LOBYTE(v11) = v5 & 0x1F | 0x40;
  BYTE2(v11) = v6;
  HIBYTE(v11) = v4;
  v10[1] = -86;
  BYTE1(v11) = 9;
  v10[0] = 85;
  v12 = reverse_byte_order_32(v7);
  v8 = BM_CRC5(&v11, 64);
  v13 = v13 & 0xE0 | v8 & 0x1F;
  send_command_packet(a1, (int)v10, 0xBu);
  return 0;
}

//----- (000704D0) --------------------------------------------------------
int __fastcall set_core_reg_base(int a1, int a2)
{
  char v2; // r2
  char v4; // lr
  char v5; // r12
  char v6; // r3
  __int16 v7; // r2
  unsigned int v8; // r0
  char v9; // r0
  _BYTE v11[2]; // [sp+4h] [bp-1Ch] BYREF
  int v12; // [sp+6h] [bp-1Ah] BYREF
  _BYTE v13[5]; // [sp+Ah] [bp-16h]
  char v14; // [sp+Fh] [bp-11h]

  if ( !*(_BYTE *)(a1 + 204) )
    return 4;
  v2 = *(_BYTE *)(a2 + 8);
  v12 = 0;
  v4 = *(_BYTE *)(a2 + 9);
  *(_DWORD *)v13 = 0;
  v5 = *(_BYTE *)(a2 + 12);
  v6 = (16 * (v2 & 1)) | 4;
  v7 = *(_WORD *)(a2 + 10);
  v8 = *(_DWORD *)a2;
  LOBYTE(v12) = v6 & 0x1F | 0x40;
  HIBYTE(v12) = v7;
  BYTE2(v12) = v4;
  v13[0] = v5;
  v11[1] = -86;
  BYTE1(v12) = 10;
  v11[0] = 85;
  v14 = 0;
  *(_DWORD *)&v13[1] = reverse_byte_order_32(v8);
  v9 = BM_CRC5(&v12, 72);
  v14 = v14 & 0xE0 | v9 & 0x1F;
  send_command_packet(a1, (int)v11, 0xCu);
  return 0;
}

//----- (00070598) --------------------------------------------------------
int __fastcall sync_get_core_reg_base(int a1, int a2, int a3, int a4, int *a5, unsigned __int64 a6)
{
  int v7; // r5
  char v10; // r1
  __int16 v12; // r3
  char v13; // r2
  char v14; // r1
  char v15; // lr
  char v16; // r0
  int v17; // r3
  int v18; // r9
  int v19; // r2
  int v20; // r11
  char v22; // r1
  __int16 v23; // r2
  _BYTE v24[2]; // [sp+4h] [bp-20h] BYREF
  int v25; // [sp+6h] [bp-1Eh] BYREF
  __int16 v26; // [sp+Ah] [bp-1Ah]
  int v27[2]; // [sp+Ch] [bp-18h] BYREF
  char v28[2]; // [sp+14h] [bp-10h] BYREF
  _BYTE v29[2]; // [sp+16h] [bp-Eh] BYREF
  int v30; // [sp+18h] [bp-Ch]
  char v31; // [sp+1Ch] [bp-8h]
  unsigned __int8 v32; // [sp+1Dh] [bp-7h]
  char v33; // [sp+1Eh] [bp-6h]

  if ( !*(_BYTE *)(a1 + 204) )
    return 4;
  v25 = 0;
  v10 = *(_BYTE *)(a2 + 8);
  v26 = 0;
  v12 = *(_WORD *)(a2 + 10);
  v13 = (16 * (v10 & 1)) & 0x1A | 0x45;
  v14 = *(_BYTE *)(a2 + 12);
  v15 = *(_BYTE *)(a2 + 9);
  LOBYTE(v25) = v13;
  HIBYTE(v25) = v12;
  LOBYTE(v26) = v14;
  v24[1] = -86;
  BYTE1(v25) = 6;
  BYTE2(v25) = v15;
  v24[0] = 85;
  v16 = BM_CRC5(&v25, 40);
  v17 = *(unsigned __int8 *)(a2 + 8);
  HIBYTE(v26) = HIBYTE(v26) & 0xE0 | v16 & 0x1F;
  if ( !v17 && *(unsigned __int8 *)(a2 + 12) != 255 )
    a3 = 1;
  v7 = 0;
  v18 = 0;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 824));
  queue_clear(*(_DWORD *)(a1 + 800));
  send_command_packet(a1, (int)v24, 8u);
  sub_DD794(a6, 0x3E8u);
  v27[1] = (_DWORD)&unk_F4240 * v19;
  v27[0] = sub_DD794(a6, 0x3E8u);
  while ( a3 > v18 )
  {
    while ( 1 )
    {
      if ( queue_dequeue_for(*(_DWORD *)(a1 + 800), v28, 0xBu, v27) == 110 )
      {
        v7 = 3;
        goto LABEL_15;
      }
      if ( (unsigned __int8)v28[0] != 170 || v28[1] != 85 || v29[0] != 9 || (v33 & 0x40) == 0 )
      {
        v7 = 1;
        *a5 = v18;
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 824));
        return v7;
      }
      v20 = v33 & 0x1F;
      if ( v20 == BM_CRC5(v29, 67) )
        break;
      v7 = 2;
    }
    ++v18;
    v22 = v31;
    v23 = v32;
    *(_BYTE *)(a4 + 8) = v29[1];
    *(_BYTE *)(a4 + 4) = v22;
    *(_WORD *)(a4 + 6) = v23;
    *(_DWORD *)a4 = v30;
    a4 += 12;
  }
LABEL_15:
  *a5 = v18;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 824));
  return v7;
}
// 70698: variable 'v19' is possibly undefined

//----- (00070788) --------------------------------------------------------
int __fastcall sub_70788(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5)
{
  pthread_mutex_t *v5; // r11
  int v8; // r8
  int v9; // r10
  int v10; // r2
  unsigned int v11; // r0
  int *v13; // r5
  int v14; // r12
  int v15; // r0
  int v16; // r1
  int v17; // r2
  int v18; // r3
  int v21; // [sp+1Ch] [bp-1060h]
  int v22[2]; // [sp+24h] [bp-1058h] BYREF
  unsigned __int8 v23; // [sp+2Ch] [bp-1050h] BYREF
  unsigned __int8 v24; // [sp+2Dh] [bp-104Fh]
  unsigned __int8 v25; // [sp+2Eh] [bp-104Eh] BYREF
  unsigned __int8 v26; // [sp+2Fh] [bp-104Dh]
  unsigned int v27; // [sp+30h] [bp-104Ch]
  int v28; // [sp+34h] [bp-1048h] BYREF
  unsigned __int16 v29; // [sp+74h] [bp-1008h] BYREF
  char var1004[4104]; // [sp+78h] [bp-1004h] BYREF

  v5 = (pthread_mutex_t *)(a1 + 824);
  v8 = 0;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 824));
  v21 = a3;
  queue_clear(*(_DWORD *)(a1 + 800));
  sub_DD794(a5, 0x3E8u);
  v9 = 0;
  v22[1] = (_DWORD)&unk_F4240 * v10;
  v22[0] = sub_DD794(a5, 0x3E8u);
  while ( a2 > v9 )
  {
    while ( 1 )
    {
      if ( queue_dequeue_for(*(_DWORD *)(a1 + 800), (char *)&v23, 0x4Au, v22) == 110 )
      {
        v8 = 3;
        goto LABEL_10;
      }
      V_LOCK();
      logfmt_raw(var1004, 0x1000u, 0, "[DAG] header:%02x%02x chip_addr:%02x", v23, v24, v26);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/chip_reg_io_base.c",
        154,
        "sync_get_dag_base",
        17,
        241,
        20,
        var1004);
      if ( v23 != 170 || v24 != 85 )
      {
        v8 = 1;
        goto LABEL_10;
      }
      v11 = BM_CRC16(&v25, 70);
      if ( v29 == (unsigned __int16)__rev16(v11) )
        break;
      v8 = 2;
    }
    v13 = &v28;
    *(_BYTE *)(v21 + 4) = v26;
    *(_DWORD *)v21 = reverse_byte_order_32(v27);
    v14 = v21 + 10;
    do
    {
      v14 += 16;
      v15 = *v13;
      v16 = v13[1];
      v17 = v13[2];
      v18 = v13[3];
      v13 += 4;
      *(_DWORD *)(v14 - 16) = v15;
      *(_DWORD *)(v14 - 12) = v16;
      *(_DWORD *)(v14 - 8) = v17;
      *(_DWORD *)(v14 - 4) = v18;
    }
    while ( v13 != (int *)&v29 );
    ++v9;
    v21 += 76;
  }
LABEL_10:
  *a4 = v9;
  pthread_mutex_unlock(v5);
  return v8;
}
// 70804: variable 'v10' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0007097C) --------------------------------------------------------
int __fastcall sub_7097C(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5)
{
  pthread_mutex_t *v5; // r9
  int v9; // r6
  int v10; // r8
  int v11; // r2
  int v12; // r7
  __int16 v14; // r3
  int v16[2]; // [sp+Ch] [bp-18h] BYREF
  char v17[2]; // [sp+14h] [bp-10h] BYREF
  _BYTE v18[3]; // [sp+16h] [bp-Eh] BYREF
  int v19; // [sp+19h] [bp-Bh]
  char v20; // [sp+1Dh] [bp-7h]

  v5 = (pthread_mutex_t *)(a1 + 824);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 824));
  v9 = 0;
  queue_clear(*(_DWORD *)(a1 + 800));
  v10 = 0;
  sub_DD794(a5, 0x3E8u);
  v16[1] = (_DWORD)&unk_F4240 * v11;
  v16[0] = sub_DD794(a5, 0x3E8u);
  while ( a2 > v10 )
  {
    while ( 1 )
    {
      if ( queue_dequeue_for(*(_DWORD *)(a1 + 800), v17, 0xAu, v16) == 110 )
      {
        v9 = 3;
        goto LABEL_11;
      }
      if ( (unsigned __int8)v17[0] != 170 || v17[1] != 85 || (v18[0] & 0xEF) != 0 )
      {
        v9 = 1;
        goto LABEL_11;
      }
      v12 = v20 & 0x1F;
      if ( v12 == BM_CRC5(v18, 56) )
        break;
      v9 = 2;
    }
    ++v10;
    v14 = v18[2];
    *(_BYTE *)(a3 + 4) = v18[1];
    *(_WORD *)(a3 + 6) = v14;
    *(_DWORD *)a3 = v19;
    a3 += 12;
  }
LABEL_11:
  *a4 = v10;
  pthread_mutex_unlock(v5);
  return v9;
}
// 709DC: variable 'v11' is possibly undefined

//----- (00070AA4) --------------------------------------------------------
int __fastcall sync_get_status_unclear_base(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5)
{
  int v5; // r5
  pthread_mutex_t *v6; // r11
  int v10; // r10
  int v11; // r2
  int v12; // r7
  __int16 v14; // r2
  int v15; // r3
  int v17[2]; // [sp+Ch] [bp-18h] BYREF
  char v18[2]; // [sp+14h] [bp-10h] BYREF
  int v19; // [sp+16h] [bp-Eh] BYREF
  char v20; // [sp+1Ah] [bp-Ah]
  unsigned __int8 v21; // [sp+1Bh] [bp-9h]
  char v22; // [sp+1Dh] [bp-7h]

  if ( !*(_BYTE *)(a1 + 204) )
    return 4;
  v6 = (pthread_mutex_t *)(a1 + 824);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 824));
  v5 = 0;
  sub_DD794(a5, 0x3E8u);
  v10 = 0;
  v17[1] = (_DWORD)&unk_F4240 * v11;
  v17[0] = sub_DD794(a5, 0x3E8u);
  while ( v10 < a2 )
  {
    while ( 1 )
    {
      if ( queue_dequeue_for(*(_DWORD *)(a1 + 800), v18, 0xAu, v17) == 110 )
      {
        v5 = 3;
        goto LABEL_12;
      }
      if ( (unsigned __int8)v18[0] != 170 || v18[1] != 85 )
      {
        *a4 = v10;
        v5 = 1;
        pthread_mutex_unlock(v6);
        return v5;
      }
      v12 = v22 & 0x1F;
      if ( v12 == BM_CRC5(&v19, 59) )
        break;
      v5 = 2;
    }
    ++v10;
    v14 = v21;
    v15 = v19;
    *(_BYTE *)(a3 + 4) = v20;
    *(_WORD *)(a3 + 6) = v14;
    *(_DWORD *)a3 = v15;
    a3 += 12;
  }
LABEL_12:
  *a4 = v10;
  pthread_mutex_unlock(v6);
  return v5;
}
// 70B0C: variable 'v11' is possibly undefined

//----- (00070BD0) --------------------------------------------------------
int __fastcall sync_get_dag_base(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5)
{
  if ( *(_BYTE *)(a1 + 204) )
    return sub_70788(a1, a2, a3, a4, a5);
  else
    return 4;
}

//----- (00070BE8) --------------------------------------------------------
int __fastcall sync_get_dag_node_base(int a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int64 a6)
{
  char v9; // r1
  unsigned int v11; // r0
  _BYTE *v12; // r10
  char v13; // r0
  _BYTE v15[2]; // [sp+Ch] [bp-Ch] BYREF
  __int64 src; // [sp+Eh] [bp-Ah] BYREF

  if ( !*(_BYTE *)(a1 + 204) )
    return 4;
  src = 0;
  v9 = *(_BYTE *)(a2 + 8);
  v15[0] = 85;
  v11 = *(_DWORD *)(a2 + 4);
  src = (16 * (v9 & 1)) & 0x19 | 0x46u;
  v15[1] = -86;
  BYTE1(src) = 8;
  *(_DWORD *)((char *)&src + 3) = reverse_byte_order_32(v11);
  v12 = calloc(8u, 1u);
  memcpy(v12, &src, 7u);
  v13 = BM_CRC5(v12, 64);
  HIBYTE(src) = HIBYTE(src) & 0xE0 | v13 & 0x1F;
  free(v12);
  send_command_packet(a1, (int)v15, 0xAu);
  if ( !*(_BYTE *)(a2 + 8) )
    a3 = 1;
  if ( *(_BYTE *)(a1 + 204) )
    return sub_70788(a1, a3, a4, a5, a6);
  else
    return 4;
}

//----- (00070D18) --------------------------------------------------------
int __fastcall set_core_reg_base_9(int a1, int *a2)
{
  __int16 v3; // lr
  int v4; // r2
  char v5; // r6
  char v6; // r3
  char v7; // r1
  char v8; // r0
  _BYTE v10[2]; // [sp+4h] [bp-1Ch] BYREF
  int v11; // [sp+6h] [bp-1Ah] BYREF
  char v12; // [sp+Ah] [bp-16h]
  char v13; // [sp+Bh] [bp-15h]
  char v14; // [sp+Ch] [bp-14h]
  char v15; // [sp+Dh] [bp-13h]
  char v16; // [sp+Eh] [bp-12h]

  if ( !*(_BYTE *)(a1 + 204) )
    return 4;
  v11 = 0;
  v3 = *((_WORD *)a2 + 5);
  v4 = *a2;
  v5 = *((_BYTE *)a2 + 9);
  v6 = (16 * (a2[2] & 1)) | 4;
  v7 = *((_BYTE *)a2 + 12);
  v15 = v4;
  LOBYTE(v11) = v6 & 0x1F | 0x40;
  v13 = BYTE2(v4);
  v14 = BYTE1(v4);
  v12 = v7;
  HIBYTE(v11) = v3;
  v10[0] = 85;
  v10[1] = -86;
  BYTE1(v11) = 9;
  v16 = 0;
  BYTE2(v11) = v5;
  v8 = BM_CRC5(&v11, 64);
  v16 = v16 & 0xE0 | v8 & 0x1F;
  send_command_packet(a1, (int)v10, 0xBu);
  return 0;
}

//----- (00070DE0) --------------------------------------------------------
int __fastcall sync_get_core_reg_base_3(int a1, int a2, int a3, int a4, int *a5, unsigned __int64 a6)
{
  int v7; // r6
  char v11; // r0
  __int16 v12; // lr
  unsigned __int8 v13; // r12
  char v14; // r0
  int v15; // r2
  int v16; // r2
  int v17; // r11
  __int16 v19; // r1
  int v20; // r3
  char v21; // r2
  int v22; // [sp+24h] [bp-1030h]
  int v23; // [sp+2Ch] [bp-1028h]
  _BYTE v24[2]; // [sp+34h] [bp-1020h] BYREF
  int v25; // [sp+36h] [bp-101Eh] BYREF
  __int16 v26; // [sp+3Ah] [bp-101Ah]
  int v27[2]; // [sp+3Ch] [bp-1018h] BYREF
  unsigned __int8 v28; // [sp+44h] [bp-1010h] BYREF
  unsigned __int8 v29; // [sp+45h] [bp-100Fh]
  char v30; // [sp+46h] [bp-100Eh] BYREF
  unsigned __int8 v31; // [sp+47h] [bp-100Dh]
  unsigned __int8 v32; // [sp+48h] [bp-100Ch]
  unsigned __int8 v33; // [sp+49h] [bp-100Bh]
  unsigned __int8 v34; // [sp+4Ah] [bp-100Ah]
  unsigned __int8 v35; // [sp+4Bh] [bp-1009h]
  char v36; // [sp+4Ch] [bp-1008h]
  char v37[4080]; // [sp+50h] [bp-1004h] BYREF

  if ( !*(_BYTE *)(a1 + 204) )
    return 4;
  v25 = 0;
  v11 = *(_BYTE *)(a2 + 8);
  v24[0] = 85;
  v24[1] = -86;
  v12 = *(_WORD *)(a2 + 10);
  v13 = *(_BYTE *)(a2 + 12);
  v25 = (16 * (v11 & 1)) & 0x1A | 0x45;
  BYTE1(v25) = 6;
  HIBYTE(v25) = v12;
  v26 = v13;
  v14 = BM_CRC5(&v25, 40);
  v15 = *(unsigned __int8 *)(a2 + 8);
  HIBYTE(v26) = HIBYTE(v26) & 0xE0 | v14 & 0x1F;
  if ( !v15 && *(unsigned __int8 *)(a2 + 12) != 255 )
    a3 = 1;
  v23 = a4;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 824));
  queue_clear(*(_DWORD *)(a1 + 800));
  v7 = 0;
  send_command_packet(a1, (int)v24, 8u);
  sub_DD794(a6, 0x3E8u);
  v27[1] = (_DWORD)&unk_F4240 * v16;
  v22 = 0;
  v27[0] = sub_DD794(a6, 0x3E8u);
  while ( v22 < a3 )
  {
    while ( 1 )
    {
      if ( queue_dequeue_for(*(_DWORD *)(a1 + 800), (char *)&v28, 9u, v27) == 110 )
      {
        v7 = 3;
        goto LABEL_14;
      }
      V_LOCK();
      logfmt_raw(
        v37,
        0x1000u,
        0,
        "core reg: %02x %02x chip addr %02x reg addr %02x reg value %02x%02x%02x",
        v28,
        v29,
        v34,
        v35,
        v31,
        v32,
        v33);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/chip_reg_io_base.c",
        154,
        "sync_get_core_reg_base_3",
        24,
        503,
        20,
        v37);
      if ( v28 != 170 || v29 != 85 || (v36 & 0x40) == 0 )
      {
        v7 = 1;
        goto LABEL_14;
      }
      v17 = v36 & 0x1F;
      if ( v17 == BM_CRC5(&v30, 51) )
        break;
      v7 = 2;
    }
    ++v22;
    v19 = v35;
    v20 = (v32 << 16) | (v33 << 24) | v31;
    v21 = v30;
    *(_BYTE *)(v23 + 4) = v34;
    *(_WORD *)(v23 + 6) = v19;
    *(_BYTE *)(v23 + 8) = v21;
    *(_DWORD *)v23 = v20;
    v23 += 12;
  }
LABEL_14:
  *a5 = v22;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 824));
  return v7;
}
// 70EEC: variable 'v16' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00071098) --------------------------------------------------------
int __fastcall sync_get_status_base2(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5)
{
  if ( *(_BYTE *)(a1 + 204) )
    return sub_7097C(a1, a2, a3, a4, a5);
  else
    return 4;
}

//----- (000710B0) --------------------------------------------------------
int __fastcall sync_get_chip_reg_base2(int a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int64 a6)
{
  char v9; // r12
  __int16 v11; // lr
  char v12; // r0
  _BYTE v14[2]; // [sp+8h] [bp-Ch] BYREF
  int v15; // [sp+Ah] [bp-Ah] BYREF
  char v16; // [sp+Eh] [bp-6h]

  if ( !*(_BYTE *)(a1 + 204) )
    return 4;
  v15 = 0;
  v9 = *(_BYTE *)(a2 + 8);
  v16 = 0;
  v14[0] = 85;
  v11 = *(_WORD *)(a2 + 10);
  BYTE2(v15) = *(_BYTE *)(a2 + 9);
  BYTE1(v15) = 5;
  LOBYTE(v15) = (16 * (v9 & 1)) & 0x1D | 0x42;
  HIBYTE(v15) = v11;
  v14[1] = -86;
  v12 = BM_CRC5(&v15, 32);
  v16 = v16 & 0xE0 | v12 & 0x1F;
  send_command_packet(a1, (int)v14, 7u);
  if ( !*(_BYTE *)(a2 + 8) )
    a3 = 1;
  if ( *(_BYTE *)(a1 + 204) )
    return sub_7097C(a1, a3, a4, a5, a6);
  else
    return 4;
}

//----- (00071194) --------------------------------------------------------
int __fastcall set_core_reg_base2(int a1, int a2)
{
  char v4; // r12
  char v5; // r0
  unsigned int v6; // r0
  _BYTE *v7; // r8
  char v8; // r0
  _BYTE v10[2]; // [sp+0h] [bp-28h] BYREF
  _BYTE src[33]; // [sp+2h] [bp-26h] BYREF

  if ( !*(_BYTE *)(a1 + 204) )
    return 4;
  *(_DWORD *)src = 0;
  v4 = *(_BYTE *)(a2 + 9);
  v5 = *(_BYTE *)(a2 + 12);
  *(_DWORD *)src = (16 * (*(_BYTE *)(a2 + 8) & 1)) & 0x1B | 0x44;
  src[3] = v5;
  v6 = *(unsigned __int16 *)(a2 + 10);
  src[2] = v4;
  v10[0] = 85;
  v10[1] = -86;
  src[1] = 11;
  src[6] = 0;
  *(_DWORD *)&src[7] = 0;
  *(_WORD *)&src[4] = reverse_byte_order_16(v6);
  *(_DWORD *)&src[6] = reverse_byte_order_32(*(_DWORD *)a2);
  v7 = calloc(0xCu, 1u);
  memcpy(v7, src, 0xAu);
  v8 = BM_CRC5(v7, 96);
  src[10] = src[10] & 0xE0 | v8 & 0x1F;
  free(v7);
  send_command_packet(a1, (int)v10, 0xDu);
  return 0;
}

//----- (0007129C) --------------------------------------------------------
int __fastcall sync_get_core_reg_base2(int a1, int a2, int a3, int a4, int *a5, unsigned __int64 a6)
{
  int v7; // r5
  char v10; // r1
  unsigned int v12; // r0
  _BYTE *v13; // r10
  char v14; // r0
  int v15; // r9
  int v16; // r2
  char v17; // r11
  char v19; // r2
  unsigned int v20; // r3
  int v21[2]; // [sp+0h] [bp-24h] BYREF
  _BYTE v22[2]; // [sp+8h] [bp-1Ch] BYREF
  _DWORD src[2]; // [sp+Ah] [bp-1Ah] BYREF
  char v24[2]; // [sp+14h] [bp-10h] BYREF
  _BYTE v25[2]; // [sp+16h] [bp-Eh] BYREF
  _BYTE v26[7]; // [sp+18h] [bp-Ch]
  char v27; // [sp+1Fh] [bp-5h]

  if ( !*(_BYTE *)(a1 + 204) )
    return 4;
  memset(src, 0, 7);
  v10 = *(_BYTE *)(a2 + 8);
  v22[0] = 85;
  v12 = *(unsigned __int16 *)(a2 + 10);
  src[0] = (16 * (v10 & 1)) & 0x1A | 0x45;
  v22[1] = -86;
  BYTE1(src[0]) = 7;
  LOWORD(src[1]) = reverse_byte_order_16(v12);
  v13 = calloc(8u, 1u);
  memcpy(v13, src, 6u);
  v14 = BM_CRC5(v13, 64);
  BYTE2(src[1]) = BYTE2(src[1]) & 0xE0 | v14 & 0x1F;
  free(v13);
  if ( !*(_BYTE *)(a2 + 8) && *(unsigned __int8 *)(a2 + 12) != 255 )
    a3 = 1;
  v7 = 0;
  v15 = 0;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 824));
  queue_clear(*(_DWORD *)(a1 + 800));
  send_command_packet(a1, (int)v22, 9u);
  sub_DD794(a6, 0x3E8u);
  v21[1] = (_DWORD)&unk_F4240 * v16;
  v21[0] = sub_DD794(a6, 0x3E8u);
  while ( v15 < a3 )
  {
    while ( 1 )
    {
      if ( queue_dequeue_for(*(_DWORD *)(a1 + 800), v24, 0xCu, v21) == 110 )
      {
        v7 = 3;
        goto LABEL_14;
      }
      if ( (unsigned __int8)v24[0] != 170 || v24[1] != 85 || (v25[0] & 0xEF) != 1 )
      {
        v7 = 1;
        *a5 = v15;
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 824));
        return v7;
      }
      v17 = v27;
      if ( (v17 & 0x1F) == BM_CRC5(v25, 72) )
        break;
      v7 = 2;
    }
    ++v15;
    v19 = v26[0];
    *(_BYTE *)(a4 + 4) = v25[1];
    v20 = *(_DWORD *)v26;
    *(_BYTE *)(a4 + 8) = v19;
    *(_WORD *)(a4 + 6) = v20 >> 8;
    *(_DWORD *)a4 = *(_DWORD *)&v26[3];
    a4 += 12;
  }
LABEL_14:
  *a5 = v15;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 824));
  return v7;
}
// 713E0: variable 'v16' is possibly undefined

//----- (000714D0) --------------------------------------------------------
int __fastcall set_core_enable_base(int result, int a2, __useconds_t a3)
{
  int v3; // r7
  int v4; // r4
  int v6; // r6
  int v8; // r10
  int v9; // r3
  int v10; // r2
  int v11; // r3
  __int16 v12; // r1
  int v13; // r12
  char v14[4100]; // [sp+10h] [bp-1004h] BYREF

  v3 = *(_DWORD *)a2;
  if ( *(_BYTE *)(a2 + 13) )
  {
    v4 = 0;
    v6 = result;
    if ( v3 )
      v8 = 0;
    else
      v8 = -1;
    while ( 1 )
    {
      v9 = v8;
      if ( (v4 & 0x1F) != 0 )
      {
        v9 = *(_DWORD *)a2;
      }
      else
      {
        v12 = *(_WORD *)(a2 + 10);
        v13 = v3 ? v4 & 0x1F : -1;
        *(_DWORD *)a2 = v13;
        *(_WORD *)(a2 + 10) = v12 + 4 * (v4 >> 5);
      }
      v10 = v9 | (1 << (v4 & 0x1F));
      v11 = 2 * v9;
      *(_BYTE *)(a2 + 12) = v4;
      *(_DWORD *)a2 = v3 ? v10 : v11;
      if ( (*(int (__fastcall **)(int, int, int))(v6 + 224))(v6, a2, v10) < 0 )
        break;
      result = usleep(a3);
      if ( *(unsigned __int8 *)(a2 + 13) <= ++v4 )
        return result;
    }
    V_LOCK();
    logfmt_raw(
      v14,
      0x1000u,
      0,
      "%s failed, reg:%02x, core_id:%d",
      "set_core_enable_base",
      *(unsigned __int16 *)(a2 + 10),
      v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_reg_io_base.c",
      154,
      "set_core_enable_base",
      20,
      895,
      100,
      v14);
    return -1;
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00071610) --------------------------------------------------------
int __fastcall set_core_enable_base2(int a1, int a2, __useconds_t a3)
{
  int v6; // r2
  unsigned int v7; // r3
  int v8; // r4
  int v10; // [sp+4h] [bp-1014h]
  int v11; // [sp+14h] [bp-1004h] BYREF
  char v12[4096]; // [sp+18h] [bp-1000h] BYREF

  puts("set_core_enable_base2");
  v7 = *(unsigned __int8 *)(a2 + 13);
  if ( !*(_BYTE *)(a2 + 13) )
    return 0;
  v8 = 0;
  while ( 1 )
  {
    if ( (v8 & 0x1F) == 0 )
    {
      v6 = *(unsigned __int16 *)(a2 + 10) + (v8 >> 5);
      *(_WORD *)(a2 + 10) = v6;
    }
    if ( v7 > 1 )
      *(_BYTE *)(a2 + 12) = v8;
    if ( (*(int (__fastcall **)(int, int, int))(a1 + 224))(a1, a2, v6) < 0 )
      break;
    usleep(a3);
    v11 = 0;
    (*(void (__fastcall **)(int, int, int, char *, int *, int, int, _DWORD))(a1 + 244))(
      a1,
      a2,
      1,
      v12,
      &v11,
      v10,
      2000,
      0);
    v7 = *(unsigned __int8 *)(a2 + 13);
    if ( (int)v7 <= ++v8 )
      return 0;
  }
  V_LOCK();
  logfmt_raw(
    v12,
    0x1000u,
    0,
    "%s failed, reg:%02x, core_id:%d",
    "set_core_enable_base2",
    *(unsigned __int16 *)(a2 + 10),
    v8);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/chip_reg_io_base.c",
    154,
    "set_core_enable_base2",
    21,
    914,
    100,
    v12);
  return 3;
}
// 71678: variable 'v10' is possibly undefined
// 716B0: variable 'v6' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00071754) --------------------------------------------------------
int __fastcall sync_get_status_base(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5)
{
  int v5; // r6
  int v7; // r10
  int v8; // r2
  int v9; // r11
  __int16 v11; // r2
  int v12; // r3
  pthread_mutex_t *mutex; // [sp+1Ch] [bp-1028h]
  int v17[2]; // [sp+2Ch] [bp-1018h] BYREF
  unsigned __int8 v18; // [sp+34h] [bp-1010h] BYREF
  unsigned __int8 v19; // [sp+35h] [bp-100Fh]
  char v20; // [sp+36h] [bp-100Eh] BYREF
  int v21; // [sp+37h] [bp-100Dh]
  unsigned __int8 v22; // [sp+3Bh] [bp-1009h]
  unsigned __int8 v23; // [sp+3Ch] [bp-1008h]
  char v24; // [sp+3Dh] [bp-1007h]
  char v25[4096]; // [sp+40h] [bp-1004h] BYREF

  if ( !*(_BYTE *)(a1 + 204) )
    return 4;
  mutex = (pthread_mutex_t *)(a1 + 824);
  v5 = 0;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 824));
  queue_clear(*(_DWORD *)(a1 + 800));
  v7 = 0;
  sub_DD794(a5, 0x3E8u);
  v17[1] = (_DWORD)&unk_F4240 * v8;
  v17[0] = sub_DD794(a5, 0x3E8u);
  while ( v7 < a2 )
  {
    while ( 1 )
    {
      if ( queue_dequeue_for(*(_DWORD *)(a1 + 800), (char *)&v18, 0xAu, v17) == 110 )
      {
        v5 = 3;
        goto LABEL_14;
      }
      V_LOCK();
      logfmt_raw(
        v25,
        0x1000u,
        0,
        "header:%02x%02x chip_addr:%02x, reg value:%08x, reg addr:%02x",
        v18,
        v19,
        v22,
        v21,
        v23);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/chip_reg_io_base.c",
        154,
        "sync_get_status_base",
        20,
        962,
        20,
        v25);
      if ( v18 != 170 || v19 != 85 || v20 != 8 || (v24 & 0x40) != 0 )
      {
        v5 = 1;
        *a4 = v7;
        pthread_mutex_unlock(mutex);
        return v5;
      }
      v9 = v24 & 0x1F;
      if ( v9 == BM_CRC5(&v20, 59) )
        break;
      v5 = 2;
    }
    ++v7;
    v11 = v23;
    v12 = v21;
    *(_BYTE *)(a3 + 4) = v22;
    *(_WORD *)(a3 + 6) = v11;
    *(_DWORD *)a3 = v12;
    a3 += 12;
  }
LABEL_14:
  *a4 = v7;
  pthread_mutex_unlock(mutex);
  return v5;
}
// 717D8: variable 'v8' is possibly undefined
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00071950) --------------------------------------------------------
int __fastcall sync_get_core_reg_base3(int a1, int a2, int a3, int a4, int *a5, unsigned __int64 a6)
{
  int v7; // r5
  char v10; // r1
  __int16 v12; // r3
  char v13; // r2
  char v14; // r1
  char v15; // lr
  char v16; // r0
  int v17; // r3
  int v18; // r9
  int v19; // r2
  int v20; // r11
  int v22; // r2
  int v23; // r3
  __int16 v24; // r1
  int v25; // r3
  _BYTE v26[2]; // [sp+4h] [bp-20h] BYREF
  int v27; // [sp+6h] [bp-1Eh] BYREF
  __int16 v28; // [sp+Ah] [bp-1Ah]
  int v29[2]; // [sp+Ch] [bp-18h] BYREF
  char v30[2]; // [sp+14h] [bp-10h] BYREF
  _BYTE v31[7]; // [sp+16h] [bp-Eh] BYREF
  char v32; // [sp+1Dh] [bp-7h]

  if ( !*(_BYTE *)(a1 + 204) )
    return 4;
  v27 = 0;
  v10 = *(_BYTE *)(a2 + 8);
  v28 = 0;
  v12 = *(_WORD *)(a2 + 10);
  v13 = (16 * (v10 & 1)) & 0x1A | 0x45;
  v14 = *(_BYTE *)(a2 + 12);
  v15 = *(_BYTE *)(a2 + 9);
  LOBYTE(v27) = v13;
  HIBYTE(v27) = v12;
  LOBYTE(v28) = v14;
  v26[1] = -86;
  BYTE1(v27) = 6;
  BYTE2(v27) = v15;
  v26[0] = 85;
  v16 = BM_CRC5(&v27, 40);
  v17 = *(unsigned __int8 *)(a2 + 8);
  HIBYTE(v28) = HIBYTE(v28) & 0xE0 | v16 & 0x1F;
  if ( !v17 && *(unsigned __int8 *)(a2 + 12) != 255 )
    a3 = 1;
  v7 = 0;
  v18 = 0;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 824));
  queue_clear(*(_DWORD *)(a1 + 800));
  send_command_packet(a1, (int)v26, 8u);
  sub_DD794(a6, 0x3E8u);
  v29[1] = (_DWORD)&unk_F4240 * v19;
  v29[0] = sub_DD794(a6, 0x3E8u);
  while ( v18 < a3 )
  {
    while ( 1 )
    {
      if ( queue_dequeue_for(*(_DWORD *)(a1 + 800), v30, 0xAu, v29) == 110 )
      {
        v7 = 3;
        goto LABEL_15;
      }
      if ( (unsigned __int8)v30[0] != 170 || v30[1] != 85 || v31[0] != 8 || (v32 & 0xC0) != 0x40 )
      {
        v7 = 1;
        *a5 = v18;
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 824));
        return v7;
      }
      v20 = v32 & 0x1F;
      if ( v20 == BM_CRC5(v31, 59) )
        break;
      v7 = 2;
    }
    ++v18;
    v22 = v31[4];
    v23 = (v31[3] << 8) | (v31[2] << 16);
    v24 = v31[6];
    *(_BYTE *)(a4 + 4) = v31[5];
    v25 = v23 | v22;
    LOBYTE(v22) = v31[1];
    *(_WORD *)(a4 + 6) = v24;
    *(_BYTE *)(a4 + 8) = v22;
    *(_DWORD *)a4 = v25;
    a4 += 12;
  }
LABEL_15:
  *a5 = v18;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 824));
  return v7;
}
// 71A50: variable 'v19' is possibly undefined

//----- (00071B58) --------------------------------------------------------
int __fastcall get_fake_regio_runtime(int a1)
{
  _DWORD *v3; // r0
  int v4; // r0
  int v5; // r7
  char *v6; // r0
  int v7; // r4
  __int64 v8; // r0

  if ( dword_11A2A8[a1] )
    return dword_11A2A8[a1];
  v3 = calloc(1u, 0x3A8u);
  v3[49] = a1;
  dword_11A2A8[a1] = v3;
  v4 = dev_ctrl(v3);
  (*(void (__fastcall **)(int))(v4 + 4))(a1);
  v5 = dword_11A2A8[a1];
  pthread_mutex_init((pthread_mutex_t *)(v5 + 824), 0);
  pthread_mutex_init((pthread_mutex_t *)(v5 + 848), 0);
  v6 = queue_new(1, 0);
  v7 = dword_11A2A8[a1];
  *(_DWORD *)(v5 + 800) = v6;
  LODWORD(v8) = set_chip_reg_base;
  HIDWORD(v8) = set_core_reg_base;
  *(_DWORD *)(v7 + 792) = *(_DWORD *)(v7 + 800);
  *(_DWORD *)(v7 + 208) = set_chipaddr_base;
  *(_QWORD *)(v7 + 216) = v8;
  *(_DWORD *)(v7 + 212) = set_inactive_base;
  *(_DWORD *)(v7 + 236) = sync_get_chip_reg_base;
  *(_DWORD *)(v7 + 244) = sync_get_core_reg_base;
  *(_BYTE *)(v7 + 204) = 1;
  return v7;
}
// 4AB8C: using guessed type int __fastcall dev_ctrl(_DWORD);
// 11A2A8: using guessed type _DWORD dword_11A2A8[256];

//----- (00071C2C) --------------------------------------------------------
int __fastcall set_chipaddr_by_id(int a1, int a2, int a3)
{
  int *all_created_runtime; // r0
  int *v7; // r2
  int fake_regio_runtime; // r0
  int v9; // r3
  int v10; // t1
  int v12; // [sp+4h] [bp-8h] BYREF

  v12 = 0;
  all_created_runtime = (int *)get_all_created_runtime(&v12);
  if ( v12 <= 0 )
  {
LABEL_6:
    fake_regio_runtime = get_fake_regio_runtime(a1);
    return (*(int (__fastcall **)(int, int, int))(fake_regio_runtime + 208))(fake_regio_runtime, a2, a3);
  }
  v7 = all_created_runtime;
  fake_regio_runtime = *all_created_runtime;
  if ( a1 != *(_DWORD *)(fake_regio_runtime + 196) )
  {
    v9 = 0;
    while ( ++v9 != v12 )
    {
      v10 = v7[1];
      ++v7;
      fake_regio_runtime = v10;
      if ( a1 == *(_DWORD *)(v10 + 196) )
        return (*(int (__fastcall **)(int, int, int))(fake_regio_runtime + 208))(fake_regio_runtime, a2, a3);
    }
    goto LABEL_6;
  }
  return (*(int (__fastcall **)(int, int, int))(fake_regio_runtime + 208))(fake_regio_runtime, a2, a3);
}

//----- (00071CB8) --------------------------------------------------------
int __fastcall set_inactive_by_id(int a1)
{
  int *all_created_runtime; // r0
  int *v3; // r2
  int fake_regio_runtime; // r0
  int v5; // r3
  int v6; // t1
  int v8; // [sp+4h] [bp-8h] BYREF

  v8 = 0;
  all_created_runtime = (int *)get_all_created_runtime(&v8);
  if ( v8 <= 0 )
  {
LABEL_6:
    fake_regio_runtime = get_fake_regio_runtime(a1);
    return (*(int (**)(void))(fake_regio_runtime + 212))();
  }
  v3 = all_created_runtime;
  fake_regio_runtime = *all_created_runtime;
  if ( a1 != *(_DWORD *)(fake_regio_runtime + 196) )
  {
    v5 = 0;
    while ( ++v5 != v8 )
    {
      v6 = v3[1];
      ++v3;
      fake_regio_runtime = v6;
      if ( a1 == *(_DWORD *)(v6 + 196) )
        return (*(int (**)(void))(fake_regio_runtime + 212))();
    }
    goto LABEL_6;
  }
  return (*(int (**)(void))(fake_regio_runtime + 212))();
}

//----- (00071D34) --------------------------------------------------------
int __fastcall set_chip_reg_by_id(int a1, int a2)
{
  int *all_created_runtime; // r0
  int *v5; // r2
  int fake_regio_runtime; // r0
  int v7; // r3
  int v8; // t1
  int v10; // [sp+4h] [bp-4h] BYREF

  v10 = 0;
  all_created_runtime = (int *)get_all_created_runtime(&v10);
  if ( v10 <= 0 )
  {
LABEL_6:
    fake_regio_runtime = get_fake_regio_runtime(a1);
    return (*(int (__fastcall **)(int, int, int *))(fake_regio_runtime + 216))(fake_regio_runtime, a2, v5);
  }
  v5 = all_created_runtime;
  fake_regio_runtime = *all_created_runtime;
  if ( a1 != *(_DWORD *)(fake_regio_runtime + 196) )
  {
    v7 = 0;
    while ( ++v7 != v10 )
    {
      v8 = v5[1];
      ++v5;
      fake_regio_runtime = v8;
      if ( a1 == *(_DWORD *)(v8 + 196) )
        return (*(int (__fastcall **)(int, int, int *))(fake_regio_runtime + 216))(fake_regio_runtime, a2, v5);
    }
    goto LABEL_6;
  }
  return (*(int (__fastcall **)(int, int, int *))(fake_regio_runtime + 216))(fake_regio_runtime, a2, v5);
}
// 71DAC: variable 'v5' is possibly undefined

//----- (00071DB8) --------------------------------------------------------
int __fastcall set_core_reg_by_id(int a1, int a2)
{
  int *all_created_runtime; // r0
  int *v5; // r2
  int fake_regio_runtime; // r0
  int v7; // r3
  int v8; // t1
  int v10; // [sp+4h] [bp-4h] BYREF

  v10 = 0;
  all_created_runtime = (int *)get_all_created_runtime(&v10);
  if ( v10 <= 0 )
  {
LABEL_6:
    fake_regio_runtime = get_fake_regio_runtime(a1);
    return (*(int (__fastcall **)(int, int, int *))(fake_regio_runtime + 220))(fake_regio_runtime, a2, v5);
  }
  v5 = all_created_runtime;
  fake_regio_runtime = *all_created_runtime;
  if ( a1 != *(_DWORD *)(fake_regio_runtime + 196) )
  {
    v7 = 0;
    while ( ++v7 != v10 )
    {
      v8 = v5[1];
      ++v5;
      fake_regio_runtime = v8;
      if ( a1 == *(_DWORD *)(v8 + 196) )
        return (*(int (__fastcall **)(int, int, int *))(fake_regio_runtime + 220))(fake_regio_runtime, a2, v5);
    }
    goto LABEL_6;
  }
  return (*(int (__fastcall **)(int, int, int *))(fake_regio_runtime + 220))(fake_regio_runtime, a2, v5);
}
// 71E30: variable 'v5' is possibly undefined

//----- (00071E3C) --------------------------------------------------------
int __fastcall sync_get_chip_reg_by_id(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // r4
  int *all_created_runtime; // r0
  int fake_regio_runtime; // r5
  int v12; // t1
  int result; // r0
  int v14; // r4
  pthread_t v15; // r0
  int v16; // [sp+14h] [bp-8h] BYREF

  v5 = 0;
  v16 = 0;
  all_created_runtime = (int *)get_all_created_runtime(&v16);
  if ( v16 <= 0 )
  {
LABEL_6:
    fake_regio_runtime = get_fake_regio_runtime(a1);
    goto LABEL_7;
  }
  fake_regio_runtime = *all_created_runtime;
  if ( a1 != *(_DWORD *)(*all_created_runtime + 196) )
  {
    while ( ++v5 != v16 )
    {
      v12 = all_created_runtime[1];
      ++all_created_runtime;
      fake_regio_runtime = v12;
      if ( a1 == *(_DWORD *)(v12 + 196) )
        goto LABEL_7;
    }
    goto LABEL_6;
  }
LABEL_7:
  if ( *(_DWORD *)(fake_regio_runtime + 792) == *(_DWORD *)(fake_regio_runtime + 800) )
    pthread_create(
      (pthread_t *)(fake_regio_runtime + 812),
      0,
      (void *(*)(void *))get_response,
      (void *)fake_regio_runtime);
  result = (*(int (__fastcall **)(int, int, int, int, int))(fake_regio_runtime + 236))(
             fake_regio_runtime,
             a2,
             a3,
             a4,
             a5);
  v14 = result;
  if ( *(_DWORD *)(fake_regio_runtime + 792) == *(_DWORD *)(fake_regio_runtime + 800) )
  {
    v15 = *(_DWORD *)(fake_regio_runtime + 812);
    *(_BYTE *)(fake_regio_runtime + 821) = 1;
    pthread_join(v15, 0);
    return v14;
  }
  return result;
}

//----- (00071F44) --------------------------------------------------------
int __fastcall sync_get_core_reg_by_id(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // r4
  int *all_created_runtime; // r0
  int fake_regio_runtime; // r5
  int v12; // t1
  int result; // r0
  int v14; // r4
  pthread_t v15; // r0
  int v16; // [sp+14h] [bp-8h] BYREF

  v5 = 0;
  v16 = 0;
  all_created_runtime = (int *)get_all_created_runtime(&v16);
  if ( v16 <= 0 )
  {
LABEL_6:
    fake_regio_runtime = get_fake_regio_runtime(a1);
    goto LABEL_7;
  }
  fake_regio_runtime = *all_created_runtime;
  if ( a1 != *(_DWORD *)(*all_created_runtime + 196) )
  {
    while ( ++v5 != v16 )
    {
      v12 = all_created_runtime[1];
      ++all_created_runtime;
      fake_regio_runtime = v12;
      if ( a1 == *(_DWORD *)(v12 + 196) )
        goto LABEL_7;
    }
    goto LABEL_6;
  }
LABEL_7:
  if ( *(_DWORD *)(fake_regio_runtime + 792) == *(_DWORD *)(fake_regio_runtime + 800) )
    pthread_create(
      (pthread_t *)(fake_regio_runtime + 812),
      0,
      (void *(*)(void *))get_response,
      (void *)fake_regio_runtime);
  result = (*(int (__fastcall **)(int, int, int, int, int))(fake_regio_runtime + 244))(
             fake_regio_runtime,
             a2,
             a3,
             a4,
             a5);
  v14 = result;
  if ( *(_DWORD *)(fake_regio_runtime + 792) == *(_DWORD *)(fake_regio_runtime + 800) )
  {
    v15 = *(_DWORD *)(fake_regio_runtime + 812);
    *(_BYTE *)(fake_regio_runtime + 821) = 1;
    pthread_join(v15, 0);
    return v14;
  }
  return result;
}

//----- (0007204C) --------------------------------------------------------
int __fastcall reverse_byte_order_16(unsigned int a1)
{
  return (unsigned __int16)__rev16(a1);
}

//----- (00072058) --------------------------------------------------------
unsigned int __fastcall reverse_byte_order_32(unsigned int a1)
{
  return bswap32(a1);
}

//----- (00072060) --------------------------------------------------------
int __fastcall send_command_packet(int a1, int a2, unsigned int a3)
{
  pthread_mutex_t *v3; // r6
  int i; // r0
  int v8; // r0
  int v9; // r0
  int v10; // r5
  char v12[4100]; // [sp+10h] [bp-1004h] BYREF

  v3 = (pthread_mutex_t *)(a1 + 848);
  for ( i = pthread_mutex_lock((pthread_mutex_t *)(a1 + 848)); ; i = usleep(0x2710u) )
  {
    v8 = dev_ctrl(i);
    if ( (*(int (__fastcall **)(_DWORD))(v8 + 64))(*(_DWORD *)(a1 + 196)) >= a3 )
      break;
  }
  v9 = dev_ctrl(10000);
  v10 = (*(int (__fastcall **)(_DWORD, int, unsigned int))(v9 + 56))(*(_DWORD *)(a1 + 196), a2, a3);
  pthread_mutex_unlock(v3);
  if ( v10 <= 0 )
  {
    V_LOCK();
    logfmt_raw(v12, 0x1000u, 0, "device %d send cmd failed,errcode %d \n", *(_DWORD *)(a1 + 196), v10);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/chip_reg_io_interface.c",
      159,
      "send_command_packet",
      19,
      44,
      100,
      v12);
  }
  return v10;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4AB8C: using guessed type int __fastcall dev_ctrl(_DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0007215C) --------------------------------------------------------
int __fastcall convert_offset_to_chain_id(int a1)
{
  return g_chain_info[2 * a1];
}
// 11B474: using guessed type _DWORD g_chain_info[32];

//----- (0007216C) --------------------------------------------------------
int scan_miner_device_hal()
{
  return total_chain;
}
// 11A6A8: using guessed type int total_chain;

//----- (0007217C) --------------------------------------------------------
int __fastcall dev_is_valid_hal(int a1)
{
  return LOBYTE(g_chain_info[2 * a1 + 1]);
}
// 11B474: using guessed type _DWORD g_chain_info[32];

//----- (00072190) --------------------------------------------------------
_DWORD *__fastcall set_dev_invalid_hal(int a1)
{
  int v1; // r1
  _DWORD *result; // r0

  v1 = total_chain;
  result = (_DWORD *)(8 * a1 + 1160308);
  *((_BYTE *)result + 4) = 0;
  total_chain = v1 - 1;
  return result;
}
// 11A6A8: using guessed type int total_chain;

//----- (000721BC) --------------------------------------------------------
int dev_get_nonce_reg_fifo_size_hal()
{
  return 0;
}

//----- (000721C4) --------------------------------------------------------
int dev_get_reg_fifo_capacity_hal()
{
  return 0x10000;
}

//----- (000721CC) --------------------------------------------------------
int dev_dma_rw_dispatcher_hal()
{
  return 0;
}

//----- (000721D4) --------------------------------------------------------
int __fastcall sub_dev_init_hal(unsigned int a1)
{
  if ( a1 >= total_chain )
    puts("warning: get pcie fd error");
  return g_chain_info[2 * a1];
}
// 11A6A8: using guessed type int total_chain;
// 11B474: using guessed type _DWORD g_chain_info[32];

//----- (0007220C) --------------------------------------------------------
int __fastcall dev_config_hal(int a1)
{
  int v1; // r4
  int v2; // r2
  int v4; // [sp+4h] [bp-4h] BYREF

  if ( a1 == 3000000 )
    goto LABEL_22;
  if ( a1 <= 3000000 )
  {
    if ( a1 == 921600 )
    {
      v1 = 33686018;
      v2 = 2;
      goto LABEL_13;
    }
    if ( a1 > 921600 )
    {
      if ( a1 == 1500000 || a1 == 1562500 )
      {
        v1 = 16843009;
        v2 = 1;
        goto LABEL_13;
      }
    }
    else if ( a1 == 460800 )
    {
      v1 = 101058054;
      v2 = 6;
      goto LABEL_13;
    }
LABEL_20:
    v1 = 437918234;
    v2 = 26;
    goto LABEL_13;
  }
  if ( a1 == 6250000 )
  {
    v1 = 50529027;
    v2 = 3;
    goto LABEL_13;
  }
  if ( a1 <= 6250000 )
  {
    if ( a1 != 3125000 )
      goto LABEL_20;
LABEL_22:
    v1 = 0;
    v2 = 0;
    goto LABEL_13;
  }
  if ( a1 == 12500000 )
  {
    v1 = 67372036;
    v2 = 4;
    goto LABEL_13;
  }
  if ( a1 != 25000000 )
    goto LABEL_20;
  v1 = 84215045;
  v2 = 5;
LABEL_13:
  printf("%s: set zynq bt8d %d\n", 964052, v2);
  v4 = v1;
  uart_set_config(0, 0, &v4);
  usleep((__useconds_t)"rl_kda_2110");
  return 0;
}

//----- (00072364) --------------------------------------------------------
int dev_init_hal()
{
  int v0; // r4
  unsigned int hash_on_plug; // r8
  int v2; // r3
  int v4; // r0
  int v5; // r3
  unsigned __int8 v6; // [sp+1Fh] [bp-1005h] BYREF
  char v7[4100]; // [sp+20h] [bp-1004h] BYREF

  v0 = platform_init();
  if ( v0 )
  {
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, "platform init failed!\n");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/platform_device_hal.c",
      164,
      "dev_init_hal",
      12,
      55,
      100,
      v7);
    return -1;
  }
  total_chain = 0;
  hash_on_plug = get_hash_on_plug();
  while ( 1 )
  {
    while ( ((hash_on_plug >> v0) & 1) == 0 )
    {
      if ( ++v0 == 16 )
        goto LABEL_7;
    }
    v2 = total_chain;
    g_chain_info[2 * total_chain] = v0;
    LOBYTE(g_chain_info[2 * v2 + 1]) = 1;
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, "chain_offset %d, chain %d", total_chain, g_chain_info[2 * total_chain]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/platform_device_hal.c",
      164,
      "dev_init_hal",
      12,
      65,
      60,
      v7);
    if ( platform_is_pic_mcu_en() )
      break;
LABEL_6:
    ++v0;
    ++total_chain;
    if ( v0 == 16 )
    {
LABEL_7:
      fpga_reset();
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, "reset fpga");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/platform_device_hal.c",
        164,
        "dev_init_hal",
        12,
        95,
        60,
        v7);
      enable_bypass_mode();
      dev_config_hal((int)"_nonce_num_hns");
      return 0;
    }
  }
  if ( open_pic((unsigned __int8)v0) < 0 )
  {
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, "chain_offset %d, chain %d, open pic error!", total_chain, g_chain_info[2 * total_chain]);
    V_UNLOCK();
    v4 = g_zc;
    v5 = 69;
    goto LABEL_12;
  }
  pic1704_reset(v0);
  usleep(0x493E0u);
  pic1704_jump_to_app(v0);
  usleep(0x493E0u);
  if ( pic1704_get_sw_version(g_chain_info[2 * total_chain], &v6) )
  {
    V_LOCK();
    logfmt_raw(
      v7,
      0x1000u,
      0,
      "chain_offset %d, chain %d, pic firmware verion = 0x%02x",
      total_chain,
      g_chain_info[2 * total_chain],
      v6);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/platform_device_hal.c",
      164,
      "dev_init_hal",
      12,
      86,
      60,
      v7);
    goto LABEL_6;
  }
  V_LOCK();
  logfmt_raw(
    v7,
    0x1000u,
    0,
    "chain_offset %d, chain %d, get_sw_version error!",
    total_chain,
    g_chain_info[2 * total_chain]);
  V_UNLOCK();
  v4 = g_zc;
  v5 = 80;
LABEL_12:
  zlog(
    v4,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/platform_device_hal.c",
    164,
    "dev_init_hal",
    12,
    v5,
    100,
    v7);
  return -1;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6550C: using guessed type int fpga_reset(void);
// 11A6A8: using guessed type int total_chain;
// 11A7AC: using guessed type int g_zc;
// 11B474: using guessed type _DWORD g_chain_info[32];

//----- (000726C4) --------------------------------------------------------
int __fastcall dev_config_one_chain_baud(int a1, int a2)
{
  char v4; // r6
  int v5; // r5
  int v7; // [sp+0h] [bp-8h] BYREF
  _BYTE v8[4]; // [sp+4h] [bp-4h] BYREF

  uart_get_config(0, 0, &v7, (int)v8);
  printf("%s: get zynq bt8d %08x\n", "dev_config_one_chain_baud", v7);
  v4 = 8 * a1;
  if ( a2 == 3000000 )
    goto LABEL_22;
  if ( a2 <= 3000000 )
  {
    if ( a2 == 921600 )
    {
      v5 = 2 << v4;
      goto LABEL_13;
    }
    if ( a2 > 921600 )
    {
      if ( a2 == 1500000 || a2 == 1562500 )
      {
        v5 = 1 << v4;
        goto LABEL_13;
      }
    }
    else if ( a2 == 460800 )
    {
      v5 = 6 << v4;
      goto LABEL_13;
    }
LABEL_19:
    v5 = 26 << v4;
    goto LABEL_13;
  }
  if ( a2 == 6250000 )
  {
    v5 = 3 << v4;
    goto LABEL_13;
  }
  if ( a2 <= 6250000 )
  {
    if ( a2 != 3125000 )
      goto LABEL_19;
LABEL_22:
    v5 = 0;
    goto LABEL_13;
  }
  if ( a2 == 12500000 )
  {
    v5 = 4 << v4;
    goto LABEL_13;
  }
  if ( a2 != 25000000 )
    goto LABEL_19;
  v5 = 5 << v4;
LABEL_13:
  printf("%s: set zynq bt8d %d\n", "dev_config_one_chain_baud");
  v7 = v7 & ~(63 << v4) | v5;
  uart_set_config(a1, 0, &v7);
  usleep((__useconds_t)"rl_kda_2110");
  uart_get_config(0, 0, &v7, (int)v8);
  printf("%s: after set baud, get zynq bt8d %08x\n", "dev_config_one_chain_baud", v7);
  return 0;
}

//----- (0007286C) --------------------------------------------------------
size_t __fastcall dev_send_work_cmd_hal(int a1, char *a2, unsigned int a3)
{
  unsigned int v3; // r5
  char v4; // r10
  char *v6; // r9
  unsigned int v7; // r11
  char *v8; // r8
  char *v9; // r4
  char *v10; // r1

  v3 = a3 >> 7;
  v4 = a3;
  v6 = a2;
  if ( a3 >> 7 )
  {
    v7 = v3 << 7;
    v8 = &a2[128 * v3];
    v9 = a2;
    v3 = 0;
    do
    {
      v10 = v9;
      v9 += 128;
      v3 += uart_send(g_chain_info[2 * a1], v10, 0x80u);
    }
    while ( v8 != v9 );
    v6 += v7;
  }
  return uart_send(g_chain_info[2 * a1], v6, v4 & 0x7F) + v3;
}
// 11B474: using guessed type _DWORD g_chain_info[32];

//----- (000728E4) --------------------------------------------------------
size_t __fastcall dev_send_reg_cmd_hal(int a1, const void *a2, size_t a3)
{
  return uart_send(g_chain_info[2 * a1], a2, a3);
}
// 11B474: using guessed type _DWORD g_chain_info[32];

//----- (000728F4) --------------------------------------------------------
unsigned int __fastcall dev_read_nonce_reg_data_hal(int a1, int a2, unsigned int a3)
{
  return uart_receive(g_chain_info[2 * a1], a2, a3);
}
// 11B474: using guessed type _DWORD g_chain_info[32];

//----- (00072908) --------------------------------------------------------
int dev_exit_hal()
{
  uart_uninit();
  fpga_uninit();
  platform_uninit();
  return 0;
}
// 683E8: using guessed type int uart_uninit(void);

//----- (00072920) --------------------------------------------------------
int __fastcall chain_reset_low_hal(int a1)
{
  chain_reset_low(g_chain_info[2 * a1]);
  sleep(3u);
  return 0;
}
// 11B474: using guessed type _DWORD g_chain_info[32];

//----- (00072944) --------------------------------------------------------
unsigned int __fastcall softreset_hal(int a1)
{
  unsigned int result; // r0
  _BYTE v3[20]; // [sp+0h] [bp-14h] BYREF

  while ( uart_receive(g_chain_info[2 * a1], (int)v3, 0x10u) )
    ;
  sleep(1u);
  do
    result = uart_receive(g_chain_info[2 * a1], (int)v3, 0x10u);
  while ( result );
  return result;
}
// 11B474: using guessed type _DWORD g_chain_info[32];

//----- (000729A0) --------------------------------------------------------
int __fastcall power_on_hal(int a1, unsigned __int16 a2, int a3)
{
  int is_pic_mcu_en; // r6
  int v7; // r6
  int v9; // r6
  char v10[4096]; // [sp+10h] [bp-1000h] BYREF

  chain_reset_low(g_chain_info[2 * a1]);
  sleep(1u);
  is_pic_mcu_en = platform_is_pic_mcu_en();
  if ( is_pic_mcu_en )
  {
    v9 = pic1704_reset(g_chain_info[2 * a1]);
    usleep(0x493E0u);
    is_pic_mcu_en = v9 + pic1704_jump_to_app(g_chain_info[2 * a1]);
    usleep(0x493E0u);
  }
  if ( !a3 && platform_is_pic_mcu_en() )
    set_chain_isl_voltage(g_chain_info[2 * a1], a2);
  if ( platform_is_pic_mcu_en() && (v7 = is_pic_mcu_en + pic1704_enable_disable_dc_dc(g_chain_info[2 * a1], 1), v7 != 3) )
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "chain %d, pic init failed, err:%d!!!", g_chain_info[2 * a1], v7);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/platform_device_hal.c",
      164,
      "power_on_hal",
      12,
      379,
      100,
      v10);
    return -1;
  }
  else
  {
    sleep(1u);
    chain_reset_high(g_chain_info[2 * a1]);
    usleep(0x493E0u);
    chain_reset_low(g_chain_info[2 * a1]);
    sleep(1u);
    chain_reset_high(g_chain_info[2 * a1]);
    usleep(0x493E0u);
    return 0;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;
// 11B474: using guessed type _DWORD g_chain_info[32];

//----- (00072B20) --------------------------------------------------------
int __fastcall hardreset_hal(int a1)
{
  chain_reset_low(g_chain_info[2 * a1]);
  sleep(3u);
  chain_reset_high(g_chain_info[2 * a1]);
  sleep(1u);
  return 0;
}
// 11B474: using guessed type _DWORD g_chain_info[32];

//----- (00072B58) --------------------------------------------------------
int __fastcall chain_reset_high_hal(int a1)
{
  chain_reset_high(g_chain_info[2 * a1]);
  sleep(1u);
  return 0;
}
// 11B474: using guessed type _DWORD g_chain_info[32];

//----- (00072B7C) --------------------------------------------------------
int __fastcall sub_72B7C(int a1)
{
  char v3[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( open_pic(LOBYTE(g_chain_info[2 * a1])) < 0 )
  {
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, "chain_offset %d, chain %, open pic error!", total_chain, g_chain_info[2 * total_chain]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/platform_device_hal.c",
      164,
      "dev_init_pic_for_one_chain",
      26,
      139,
      100,
      v3);
    return -1;
  }
  else if ( pic1704_reset(g_chain_info[2 * a1]) )
  {
    usleep(0x493E0u);
    if ( pic1704_jump_to_app(g_chain_info[2 * a1]) )
    {
      usleep(0x493E0u);
      return 0;
    }
    else
    {
      printf("chain_offset %d, chain %, pic jump to app error!", total_chain, g_chain_info[2 * total_chain]);
      return -1;
    }
  }
  else
  {
    printf("chain_offset %d, chain %, reset pic error!", total_chain, g_chain_info[2 * total_chain]);
    return -1;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A6A8: using guessed type int total_chain;
// 11A7AC: using guessed type int g_zc;
// 11B474: using guessed type _DWORD g_chain_info[32];

//----- (00072CB8) --------------------------------------------------------
int __fastcall dev_init_pic_for_one_chain(int a1)
{
  int result; // r0

  result = platform_is_pic_mcu_en();
  if ( result )
  {
    if ( LOBYTE(g_chain_info[2 * a1 + 1]) )
    {
      return sub_72B7C(a1);
    }
    else
    {
      printf("Chain offset %d is invalid\n", a1);
      return -1;
    }
  }
  return result;
}
// 11B474: using guessed type _DWORD g_chain_info[32];

//----- (00072D08) --------------------------------------------------------
int sub_72D08()
{
  char v1[4096]; // [sp+10h] [bp-1000h] BYREF

  V_LOCK();
  logfmt_raw(v1, 0x1000u, 0, "platform init failed!\n");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/platform_device_hal.c",
    164,
    "dev_init_hal_pcba",
    17,
    108,
    100,
    v1);
  return -1;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00072D88) --------------------------------------------------------
int dev_init_hal_pcba()
{
  int v0; // r4
  unsigned int hash_on_plug; // r9
  int v2; // r3
  int v3; // r2

  v0 = platform_init();
  if ( v0 )
    return sub_72D08();
  total_chain = 0;
  hash_on_plug = get_hash_on_plug();
  printf("plug_on_status: %x\n", hash_on_plug);
  do
  {
    while ( ((hash_on_plug >> v0) & 1) == 0 )
    {
      if ( ++v0 == 16 )
        goto LABEL_6;
    }
    v2 = total_chain;
    v3 = v0;
    g_chain_info[2 * total_chain] = v0++;
    LOBYTE(g_chain_info[2 * v2 + 1]) = 1;
    printf("chain_offset %d, chain %d\n", v2, v3);
    ++total_chain;
  }
  while ( v0 != 16 );
LABEL_6:
  enable_bypass_mode();
  dev_config_hal((int)"_nonce_num_hns");
  return 0;
}
// 11A6A8: using guessed type int total_chain;
// 11B474: using guessed type _DWORD g_chain_info[32];

//----- (00072E44) --------------------------------------------------------
int __fastcall power_off_hal(int a1)
{
  if ( platform_is_pic_mcu_en() )
  {
    pic1704_enable_disable_dc_dc(g_chain_info[2 * a1], 0);
    usleep(0x493E0u);
  }
  return 0;
}
// 11B474: using guessed type _DWORD g_chain_info[32];

//----- (00072E80) --------------------------------------------------------
int __fastcall heartbeat_to_hal(int a1)
{
  int result; // r0

  result = platform_is_pic_mcu_en();
  if ( result )
    return pic1704_heart_beat(g_chain_info[2 * a1]);
  return result;
}
// 11B474: using guessed type _DWORD g_chain_info[32];

//----- (00072EAC) --------------------------------------------------------
int __fastcall sub_72EAC(int a1, int a2, unsigned int a3, void *a4)
{
  int flash; // r4
  int v7; // r2
  char v8[4096]; // [sp+10h] [bp-1000h] BYREF

  if ( a2 == 51 )
  {
    flash = pic1704_write_flash(g_chain_info[2 * a1], a4, a3, HIWORD(a3));
    if ( flash == 1 )
      return flash;
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "chain %d, pic1704_write_flash failed!!!", g_chain_info[2 * a1]);
    V_UNLOCK();
    v7 = 458;
  }
  else
  {
    if ( a2 != 52 )
      return -1;
    flash = pic1704_read_flash(g_chain_info[2 * a1], a4, a3, HIWORD(a3));
    if ( flash == 1 )
      return flash;
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "chain %d, pic1704_read_flash failed!!!", g_chain_info[2 * a1]);
    V_UNLOCK();
    v7 = 466;
  }
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/platform_device_hal.c",
    164,
    "pic_operation_to_hal",
    20,
    v7,
    100,
    v8);
  return flash;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;
// 11B474: using guessed type _DWORD g_chain_info[32];

//----- (00072FEC) --------------------------------------------------------
int __fastcall pic_operation_to_hal(int a1, int a2, unsigned int a3, void *a4)
{
  int result; // r0

  result = platform_is_pic_mcu_en();
  if ( result )
    return sub_72EAC(a1, a2, a3, a4);
  return result;
}

//----- (00073028) --------------------------------------------------------
int dev_get_work_fifo_capacity_hal()
{
  return 0x10000;
}

//----- (00073030) --------------------------------------------------------
int __fastcall dump_log_hal(const char *a1, int a2, int a3, int a4)
{
  int v6; // r4
  int v7; // r5
  int v8; // t1

  printf("%s[%d] ", a1, a2);
  if ( a4 > 0 )
  {
    v6 = a3 - 1;
    v7 = v6 + a4;
    do
    {
      v8 = *(unsigned __int8 *)++v6;
      printf("%02x ", v8);
    }
    while ( v6 != v7 );
  }
  return putchar(10);
}

//----- (00073088) --------------------------------------------------------
int (**dev_ctrl_hal())()
{
  return off_106628;
}
// 106628: using guessed type int (*off_106628[26])();

//----- (00073094) --------------------------------------------------------
int __fastcall sub_73094(int a1)
{
  int v2; // [sp+4h] [bp-8h] BYREF

  get_raw_clib_object(a1, &v2);
  return v2;
}

//----- (000730B0) --------------------------------------------------------
void *__fastcall sub_730B0(int a1, const void *a2, size_t a3)
{
  int v4; // r5
  int v7; // r0
  int v9; // [sp+4h] [bp-8h] BYREF

  v4 = *(_DWORD *)(a1 + 12);
  v7 = *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(*(_DWORD *)v4 + 32) )
  {
    get_raw_clib_object(v7, &v9);
    (*(void (__fastcall **)(int))(*(_DWORD *)v4 + 32))(v9);
    v7 = *(_DWORD *)(a1 + 20);
  }
  return replace_raw_clib_object(*(void ***)(v7 + 20), a2, a3);
}

//----- (00073110) --------------------------------------------------------
int *__fastcall sub_73110(int a1)
{
  int v1; // r1
  int *v3; // r0
  int *result; // r0

  v1 = *(_DWORD *)(a1 + 20);
  v3 = **(int ***)(a1 + 12);
  if ( v1 )
    result = tree_successor(v3, v1);
  else
    result = minimum_c_rb((int)v3, (_DWORD *)*v3);
  *(_DWORD *)(a1 + 20) = result;
  if ( result )
    return (int *)result[5];
  return result;
}

//----- (00073150) --------------------------------------------------------
_DWORD *__fastcall new_c_map(int a1, int a2, int a3)
{
  _DWORD *v6; // r4
  _DWORD *v7; // r0

  v6 = malloc(4u);
  if ( v6 && (v7 = new_c_rb(a1, a2, a3), (*v6 = v7) != 0) )
    return v6;
  else
    return 0;
}

//----- (000731A0) --------------------------------------------------------
int __fastcall insert_c_map(int *a1, const void *a2, size_t a3, const void *a4, size_t a5)
{
  if ( a1 )
    return insert_c_rb(*a1, a2, a3, a4, a5);
  else
    return 501;
}

//----- (000731B8) --------------------------------------------------------
int *__fastcall exists_c_map(int *result, int a2)
{
  if ( result )
    return (int *)(find_c_rb(*result, a2) != 0);
  return result;
}

//----- (000731D8) --------------------------------------------------------
int __fastcall remove_c_map(int *a1, int a2)
{
  int *v2; // r0
  int *v3; // r4
  void *ptr[3]; // [sp+4h] [bp-Ch] BYREF

  if ( !a1 )
    return 501;
  v2 = remove_c_rb(*a1, a2);
  v3 = v2;
  if ( v2 )
  {
    get_raw_clib_object(v2[4], ptr);
    free(ptr[0]);
    destroy_sample_buffer((void **)v3[4]);
    get_raw_clib_object(v3[5], ptr);
    free(ptr[0]);
    destroy_sample_buffer((void **)v3[5]);
    free(v3);
  }
  return 0;
}

//----- (00073250) --------------------------------------------------------
int __fastcall find_c_map(int *a1, int a2, _DWORD *a3)
{
  _DWORD *c_rb; // r0

  if ( !a1 )
    return 0;
  c_rb = find_c_rb(*a1, a2);
  if ( !c_rb )
    return 0;
  get_raw_clib_object(c_rb[5], a3);
  return 1;
}

//----- (00073294) --------------------------------------------------------
int __fastcall delete_c_map(void (__fastcall ***a1)(_DWORD))
{
  int v2; // r5

  if ( !a1 )
    return 0;
  v2 = delete_c_rb(*a1);
  free(a1);
  return v2;
}

//----- (000732C0) --------------------------------------------------------
_DWORD *__fastcall new_iterator_c_map(int a1)
{
  _DWORD *result; // r0

  result = malloc(0x18u);
  result[3] = a1;
  *result = 471312;
  result[2] = 471188;
  result[1] = 471216;
  result[4] = 0;
  result[5] = 0;
  return result;
}

//----- (0007330C) --------------------------------------------------------
int **__fastcall sub_7330C(int **result, int *a2)
{
  int *v2; // r3
  int *v3; // r12
  int v4; // r2
  bool v5; // zf
  int v6; // r2

  v2 = (int *)a2[1];
  v3 = (int *)(result + 1);
  v4 = *v2;
  v5 = *v2 == (_DWORD)(result + 1);
  a2[1] = *v2;
  if ( !v5 )
    *(_DWORD *)(v4 + 8) = a2;
  v6 = a2[2];
  if ( v3 != v2 )
  {
    v2[2] = v6;
    v6 = a2[2];
  }
  if ( v6 )
  {
    result = *(int ***)v6;
    if ( *(int **)v6 == a2 )
      *(_DWORD *)v6 = v2;
    else
      *(_DWORD *)(v6 + 4) = v2;
  }
  else
  {
    *result = v2;
  }
  *v2 = (int)a2;
  if ( v3 != a2 )
    a2[2] = (int)v2;
  return result;
}

//----- (00073360) --------------------------------------------------------
_DWORD *__fastcall sub_73360(_DWORD *result, _DWORD *a2)
{
  _DWORD *v2; // r3
  _DWORD *v3; // r12
  _DWORD *v4; // r2
  _DWORD *v5; // r2

  v2 = (_DWORD *)*a2;
  v3 = result + 1;
  v4 = *(_DWORD **)(*a2 + 4);
  *a2 = v4;
  if ( v4 != result + 1 )
    v4[2] = a2;
  v5 = (_DWORD *)a2[2];
  if ( v3 != v2 )
  {
    v2[2] = v5;
    v5 = (_DWORD *)a2[2];
  }
  if ( v5 )
  {
    result = (_DWORD *)v5[1];
    if ( result == a2 )
      v5[1] = v2;
    else
      *v5 = v2;
  }
  else
  {
    *result = v2;
  }
  v2[1] = a2;
  if ( v3 != a2 )
    a2[2] = v2;
  return result;
}

//----- (000733B4) --------------------------------------------------------
int __fastcall sub_733B4(int result, _DWORD *a2)
{
  _DWORD *v2; // r5
  int v3; // r6
  _DWORD *v4; // r4

  v2 = (_DWORD *)(result + 4);
  if ( (_DWORD *)(result + 4) != a2 )
  {
    v3 = result;
    v4 = a2;
    do
    {
      result = sub_733B4(v3, *v4);
      v4 = (_DWORD *)v4[1];
    }
    while ( v4 != v2 );
  }
  return result;
}

//----- (000733E8) --------------------------------------------------------
int __fastcall sub_733E8(int result, _DWORD *a2)
{
  _DWORD *v2; // r5
  int v3; // r6
  _DWORD *v4; // r4

  v2 = (_DWORD *)(result + 4);
  if ( (_DWORD *)(result + 4) != a2 )
  {
    v3 = result;
    v4 = a2;
    do
    {
      result = sub_733E8(v3, *v4);
      v4 = (_DWORD *)v4[1];
    }
    while ( v4 != v2 );
  }
  return result;
}

//----- (0007341C) --------------------------------------------------------
int __fastcall sub_7341C(int result, _DWORD *a2, int a3, _DWORD *a4)
{
  _DWORD *v4; // r4
  _DWORD *v5; // r8
  int v6; // r9
  int v7; // r5
  int i; // r6

  v4 = a2;
  v5 = (_DWORD *)(result + 4);
  v6 = result;
  v7 = a3;
  for ( i = a3 + 1; v4 != v5; v4 = (_DWORD *)v4[1] )
  {
    if ( !v4[3] )
      v7 = i++;
    result = sub_7341C(v6, *v4, v7, a4);
  }
  if ( *a4 == -1 )
    *a4 = i;
  return result;
}

//----- (00073480) --------------------------------------------------------
int __fastcall sub_73480(_DWORD *a1)
{
  _DWORD *v1; // r5
  _DWORD **v3; // r3
  int v4; // r3
  _DWORD **v5; // r2
  _DWORD **v6; // r2
  int v7; // r2
  _DWORD **v8; // r3
  int v10; // [sp+4h] [bp-8h] BYREF

  v1 = (_DWORD *)*a1;
  if ( (_DWORD *)*a1 != a1 + 1 )
  {
    v3 = (_DWORD **)*a1;
    do
    {
      sub_733B4((int)a1, *v3);
      v3 = *(_DWORD ***)(v4 + 4);
    }
    while ( v3 != v5 );
    v6 = (_DWORD **)v1;
    do
    {
      sub_733E8((int)a1, *v6);
      v6 = *(_DWORD ***)(v7 + 4);
    }
    while ( v6 != v8 );
  }
  v10 = -1;
  return sub_7341C((int)a1, v1, 0, &v10);
}
// 734AC: variable 'v4' is possibly undefined
// 734B4: variable 'v5' is possibly undefined
// 734C8: variable 'v7' is possibly undefined
// 734D0: variable 'v8' is possibly undefined

//----- (000734F8) --------------------------------------------------------
_DWORD *__fastcall new_c_rb(int a1, int a2, int a3)
{
  _DWORD *result; // r0

  result = malloc(0x28u);
  if ( result )
  {
    result[5] = 0;
    result[6] = 0;
    result[3] = 0;
    result[4] = 0;
    result[9] = a1;
    result[7] = a2;
    result[8] = a3;
    *result = result + 1;
    result[1] = result + 1;
    result[2] = result + 1;
  }
  return result;
}

//----- (00073550) --------------------------------------------------------
_DWORD *__fastcall find_c_rb(int a1, int a2)
{
  _DWORD *v2; // r4
  _DWORD *v3; // r7
  _DWORD *v6; // r3
  int v7; // r5
  void *ptr; // [sp+4h] [bp-4h] BYREF

  v3 = (_DWORD *)(a1 + 4);
  v2 = *(_DWORD **)a1;
  if ( *(_DWORD *)a1 == a1 + 4 )
    return 0;
  while ( 1 )
  {
    get_raw_clib_object(v2[4], &ptr);
    v7 = (*(int (__fastcall **)(int, void *))(a1 + 36))(a2, ptr);
    free(ptr);
    if ( !v7 )
      break;
    v6 = (_DWORD *)*v2;
    v2 = (_DWORD *)v2[1];
    if ( v7 < 0 )
      v2 = v6;
    if ( v2 == v3 )
      return 0;
  }
  return v2;
}

//----- (000735D0) --------------------------------------------------------
int __fastcall insert_c_rb(int a1, const void *a2, size_t a3, const void *a4, size_t a5)
{
  int *v9; // r5
  int v11; // r8
  int *v12; // r4
  __int64 v13; // r2
  int v14; // r7
  int v15; // r7
  int *v16; // r4
  int v17; // r3
  int *v18; // r7
  int v19; // r0
  int *v20; // r2
  void *ptr; // [sp+0h] [bp-Ch] BYREF
  void *v22[2]; // [sp+4h] [bp-8h] BYREF

  v9 = (int *)malloc(0x18u);
  if ( !v9 )
    return 2;
  v11 = a1 + 4;
  *v9 = a1 + 4;
  v9[1] = a1 + 4;
  v9[3] = 1;
  v9[4] = (int)new_clib_object(a2, a3);
  if ( a4 )
    v9[5] = (int)new_clib_object(a4, a5);
  else
    v9[5] = 0;
  v12 = *(int **)a1;
  if ( v11 == *(_DWORD *)a1 )
  {
    *(_DWORD *)a1 = v9;
    v9[2] = 0;
    v20 = v9;
  }
  else
  {
    while ( 1 )
    {
      get_raw_clib_object(v12[4], &ptr);
      get_raw_clib_object(v9[4], v22);
      v14 = (*(int (__fastcall **)(void *, void *))(a1 + 36))(v22[0], ptr);
      free(ptr);
      free(v22[0]);
      if ( !v14 )
        return 401;
      v13 = *(_QWORD *)v12;
      if ( v14 < 0 )
        HIDWORD(v13) = *v12;
      if ( v11 == HIDWORD(v13) )
        break;
      v12 = (int *)HIDWORD(v13);
    }
    v9[2] = (int)v12;
    get_raw_clib_object(v12[4], &ptr);
    get_raw_clib_object(v9[4], v22);
    v15 = (*(int (__fastcall **)(void *, void *))(a1 + 36))(v22[0], ptr);
    free(ptr);
    free(v22[0]);
    v20 = *(int **)a1;
    if ( v15 >= 0 )
      v12[1] = (int)v9;
    else
      *v12 = (int)v9;
LABEL_17:
    if ( v9 != v20 )
    {
      do
      {
        v16 = (int *)v9[2];
        if ( v16[3] != 1 )
          break;
        v17 = v16[2];
        v18 = *(int **)v17;
        if ( v16 == *(int **)v17 )
        {
          v19 = *(_DWORD *)(v17 + 4);
          if ( *(_DWORD *)(v19 + 12) == 1 )
          {
            v16[3] = 0;
            v9 = (int *)v17;
            *(_DWORD *)(v19 + 12) = 0;
            *(_DWORD *)(v17 + 12) = 1;
          }
          else
          {
            if ( (int *)v18[1] == v9 )
            {
              sub_7330C((int **)a1, *(int **)v17);
              v18 = (int *)v18[2];
              v9 = v16;
              v17 = v18[2];
            }
            v18[3] = 0;
            *(_DWORD *)(v17 + 12) = 1;
            sub_73360((_DWORD *)a1, (_DWORD *)v17);
            v20 = *(int **)a1;
          }
          goto LABEL_17;
        }
        if ( v18[3] == 1 )
        {
          v16[3] = 0;
          v9 = (int *)v17;
          v18[3] = 0;
          *(_DWORD *)(v17 + 12) = 1;
          goto LABEL_17;
        }
        if ( v9 == (int *)*v16 )
        {
          sub_73360((_DWORD *)a1, (_DWORD *)v9[2]);
          v9 = v16;
          v17 = *(_DWORD *)(v16[2] + 8);
          v16 = (int *)v16[2];
        }
        v16[3] = 0;
        *(_DWORD *)(v17 + 12) = 1;
        sub_7330C((int **)a1, (int *)v17);
        v20 = *(int **)a1;
      }
      while ( v9 != *(int **)a1 );
    }
  }
  v20[3] = 0;
  sub_73480((_DWORD *)a1);
  return 0;
}

//----- (00073834) --------------------------------------------------------
int *__fastcall remove_c_rb(int a1, int a2)
{
  int *v2; // r4
  int *v3; // r7
  int v6; // r5
  int *v7; // r3
  int *v8; // r5
  int *v9; // r7
  int **v10; // r3
  int v11; // r1
  int v12; // r3
  int v13; // r2
  int *v15; // r3
  int *v16; // r2
  int *v17; // r3
  int v18; // r1
  int v19; // r12
  int v20; // r0
  int v21; // r12
  int v22; // r0
  void *ptr; // [sp+4h] [bp-4h] BYREF

  v3 = (int *)(a1 + 4);
  v2 = *(int **)a1;
  if ( a1 + 4 == *(_DWORD *)a1 )
    return 0;
  while ( 1 )
  {
    get_raw_clib_object(v2[4], &ptr);
    v6 = (*(int (__fastcall **)(int, void *))(a1 + 36))(a2, ptr);
    free(ptr);
    v7 = (int *)*v2;
    if ( !v6 )
      break;
    v2 = (int *)v2[1];
    if ( v6 < 0 )
      v2 = v7;
    if ( v2 == v3 )
      return 0;
  }
  v8 = (int *)v2[1];
  if ( v3 != v7 )
  {
    if ( v3 != v8 )
    {
      while ( v3 != (int *)*v8 )
        v8 = (int *)*v8;
      v9 = v8;
      v8 = (int *)v8[1];
      goto LABEL_14;
    }
    v8 = (int *)*v2;
  }
  v9 = v2;
LABEL_14:
  v8[2] = v9[2];
  v10 = (int **)v9[2];
  if ( v10 )
  {
    if ( v9 == *v10 )
      *v10 = v8;
    else
      v10[1] = v8;
  }
  else
  {
    *(_DWORD *)a1 = v8;
  }
  if ( v9 != v2 )
  {
    v11 = v2[4];
    v12 = v2[5];
    v13 = v9[5];
    v2[4] = v9[4];
    v9[4] = v11;
    v2[5] = v13;
    v9[5] = v12;
  }
  if ( !v9[3] )
  {
    v15 = *(int **)a1;
LABEL_25:
    if ( v8 != v15 )
    {
      while ( !v8[3] )
      {
        v16 = (int *)v8[2];
        v17 = (int *)*v16;
        if ( v8 == (int *)*v16 )
        {
          v17 = (int *)v16[1];
          if ( v17[3] == 1 )
          {
            v17[3] = 0;
            v16[3] = 1;
            sub_7330C((int **)a1, v16);
            v16 = (int *)v8[2];
            v17 = (int *)v16[1];
          }
          v21 = v17[1];
          v22 = *(_DWORD *)(v21 + 12);
          if ( *(_DWORD *)(*v17 + 12) )
          {
            if ( v22 )
            {
              v8 = v16;
            }
            else
            {
              *(_DWORD *)(*v17 + 12) = 0;
              v17[3] = 1;
              sub_73360((_DWORD *)a1, v17);
              v8 = (int *)v8[2];
              v17 = (int *)v8[1];
              v21 = v17[1];
            }
LABEL_42:
            v17[3] = v8[3];
            v8[3] = 0;
            *(_DWORD *)(v21 + 12) = 0;
            sub_7330C((int **)a1, v8);
            v8 = *(int **)a1;
            v15 = *(int **)a1;
            goto LABEL_25;
          }
          v8 = v16;
          if ( v22 )
            goto LABEL_42;
        }
        else
        {
          if ( v17[3] == 1 )
          {
            v17[3] = 0;
            v16[3] = 1;
            sub_73360((_DWORD *)a1, v16);
            v16 = (int *)v8[2];
            v17 = (int *)*v16;
          }
          v18 = v17[1];
          v19 = *v17;
          v20 = *(_DWORD *)(*v17 + 12);
          if ( *(_DWORD *)(v18 + 12) )
          {
            if ( v20 )
            {
              v8 = v16;
            }
            else
            {
              *(_DWORD *)(v18 + 12) = 0;
              v17[3] = 1;
              sub_7330C((int **)a1, v17);
              v8 = (int *)v8[2];
              v17 = (int *)*v8;
              v19 = *(_DWORD *)*v8;
            }
LABEL_37:
            v17[3] = v8[3];
            v8[3] = 0;
            *(_DWORD *)(v19 + 12) = 0;
            sub_73360((_DWORD *)a1, v8);
            v8 = *(int **)a1;
            v15 = *(int **)a1;
            goto LABEL_25;
          }
          v8 = v16;
          if ( v20 )
            goto LABEL_37;
        }
        v17[3] = 1;
        if ( v8 == *(int **)a1 )
          break;
      }
    }
    v8[3] = 0;
  }
  sub_73480((_DWORD *)a1);
  return v9;
}

//----- (00073AE8) --------------------------------------------------------
int __fastcall delete_c_rb(void (__fastcall **ptr)(_DWORD))
{
  _DWORD *v2; // r4
  void (__fastcall **v3)(_DWORD); // r5
  _DWORD *v5; // r7
  void **v6; // r0
  void **v7; // r0
  int v8; // r8
  _DWORD *v9; // r0
  void *v10; // r0
  int v11; // [sp+0h] [bp-8h] BYREF
  int v12; // [sp+4h] [bp-4h] BYREF

  v3 = ptr + 1;
  v2 = *ptr;
  while ( v2 != v3 )
  {
    if ( (void (__fastcall **)(_DWORD))*v2 == v3 )
    {
      v5 = (_DWORD *)v2[1];
      if ( v3 == v5 )
      {
        v6 = (void **)v2[4];
        if ( ptr[7] )
        {
          get_raw_clib_object((int)v6, &v11);
          ptr[7](v11);
          v6 = (void **)v2[4];
        }
        destroy_sample_buffer(v6);
        v7 = (void **)v2[5];
        if ( v7 )
        {
          if ( ptr[8] )
          {
            get_raw_clib_object((int)v7, &v12);
            ptr[8](v12);
            v7 = (void **)v2[5];
          }
          destroy_sample_buffer(v7);
        }
        v8 = v2[2];
        if ( v8 )
        {
          if ( v5 == *(_DWORD **)v8 )
          {
            v9 = *(_DWORD **)(v8 + 4);
            v2 = (_DWORD *)v2[2];
            if ( v5 != v9 )
            {
              free(v9);
              *(_DWORD *)(v8 + 4) = v5;
            }
          }
          else
          {
            free(*(void **)v8);
            v2 = (_DWORD *)v8;
            *(_DWORD *)v8 = v5;
          }
        }
        else
        {
          v10 = v2;
          v2 = v5;
          free(v10);
        }
      }
      else
      {
        v2 = (_DWORD *)v2[1];
      }
    }
    else
    {
      v2 = (_DWORD *)*v2;
    }
  }
  free(ptr);
  return 0;
}

//----- (00073BF0) --------------------------------------------------------
_DWORD *__fastcall minimum_c_rb(int a1, _DWORD *a2)
{
  int v2; // r0

  v2 = a1 + 4;
  while ( *a2 != v2 )
    a2 = (_DWORD *)*a2;
  return a2;
}

//----- (00073C10) --------------------------------------------------------
int __fastcall maximum_c_rb(int a1, int a2)
{
  int v2; // r0

  v2 = a1 + 4;
  while ( *(_DWORD *)(a2 + 4) != v2 )
    a2 = *(_DWORD *)(a2 + 4);
  return a2;
}

//----- (00073C30) --------------------------------------------------------
bool __fastcall empty_c_rb(_DWORD *a1)
{
  return *a1 != (_DWORD)(a1 + 1);
}

//----- (00073C44) --------------------------------------------------------
int *__fastcall tree_successor(int *a1, int a2)
{
  int *v2; // r3
  int *v3; // r12
  int i; // r2
  int v6; // r2
  bool v7; // zf

  v2 = *(int **)(a2 + 4);
  v3 = a1 + 1;
  if ( v2 != a1 + 1 )
  {
    while ( v3 != (int *)*v2 )
      v2 = (int *)*v2;
    return v2;
  }
  for ( i = *a1; v3 != *(int **)(i + 4); i = *(_DWORD *)(i + 4) )
    ;
  if ( a2 == i )
    return 0;
  v6 = *(_DWORD *)(a2 + 8);
  if ( v3 == (int *)v6 )
    return a1 + 1;
  if ( a2 != *(_DWORD *)(v6 + 4) )
    return *(int **)(a2 + 8);
  while ( 1 )
  {
    v2 = *(int **)(v6 + 8);
    if ( v3 == v2 )
      break;
    v7 = v2[1] == v6;
    v6 = *(_DWORD *)(v6 + 8);
    if ( !v7 )
      return v2;
  }
  return *(int **)(v6 + 8);
}

//----- (00073CF0) --------------------------------------------------------
_DWORD *__fastcall new_clib_object(const void *a1, size_t a2)
{
  _DWORD *v4; // r0
  _DWORD *v5; // r4
  void *v6; // r0
  void *v8; // r0

  v4 = malloc(8u);
  v5 = v4;
  if ( v4 )
  {
    v4[1] = a2;
    v6 = malloc(a2);
    *v5 = v6;
    if ( v6 )
    {
      memcpy(v6, a1, a2);
    }
    else
    {
      v8 = v5;
      v5 = 0;
      free(v8);
    }
  }
  return v5;
}

//----- (00073D4C) --------------------------------------------------------
int __fastcall get_raw_clib_object(int a1, _DWORD *a2)
{
  size_t v3; // r5
  void *v5; // r0

  v3 = *(_DWORD *)(a1 + 4);
  v5 = malloc(v3);
  *a2 = v5;
  if ( !v5 )
    return 3;
  memcpy(v5, *(const void **)a1, v3);
  return 0;
}

//----- (00073D8C) --------------------------------------------------------
void *__fastcall replace_raw_clib_object(void **a1, const void *a2, size_t a3)
{
  void *v6; // r0

  free(*a1);
  v6 = malloc(a3);
  *a1 = v6;
  return memcpy(v6, a2, a3);
}

//----- (00073DC0) --------------------------------------------------------
void __fastcall destroy_sample_buffer(void **a1)
{
  if ( a1 )
  {
    free(*a1);
    free(a1);
  }
}

//----- (00073DE4) --------------------------------------------------------
int __fastcall sub_73DE4(unsigned __int8 a1, int a2, char a3, char *a4, int a5)
{
  __int16 v7; // r4
  int v9; // r6
  char v10; // r3
  char v11; // r1
  int v12; // r2
  _DWORD *v13; // r1
  int v14; // r12
  int v15; // lr
  __int16 v16; // r3
  __int16 v17; // t1
  int v18; // r0
  int v19; // r5
  int v20; // r12
  int v22; // r0
  int v23; // [sp+18h] [bp-1020h] BYREF
  int v24; // [sp+1Ch] [bp-101Ch]
  int v25; // [sp+20h] [bp-1018h]
  int v26; // [sp+24h] [bp-1014h]
  _DWORD v27[4]; // [sp+28h] [bp-1010h] BYREF
  char var1000[4104]; // [sp+38h] [bp-1000h] BYREF

  v7 = (unsigned __int8)(a5 + 6);
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v9 = 2 * a2;
  v23 = 255;
  memset(v27, 0, sizeof(v27));
  pthread_mutex_lock(&i2c_mutex_all);
  v10 = 85;
  v11 = *a4;
  LOWORD(v27[0]) = -21931;
  if ( a5 == 2 )
    v10 = a4[1];
  HIBYTE(v27[0]) = 50;
  if ( a5 == 2 )
    v12 = 10;
  else
    v12 = 9;
  LOBYTE(v27[1]) = v9;
  if ( a5 == 2 )
    HIBYTE(v27[1]) = v10;
  BYTE2(v27[1]) = v11;
  if ( a5 == 2 )
    v9 = v12;
  v13 = (_DWORD *)((char *)v27 + 2);
  BYTE1(v27[1]) = a3;
  BYTE2(v27[0]) = a5 + 6;
  if ( a5 == 2 )
  {
    v14 = 9;
    v15 = 8;
  }
  else
  {
    v14 = 8;
    v9 = v12;
    v15 = 7;
  }
  v16 = 0;
  while ( 1 )
  {
    v16 += v7;
    if ( (_DWORD *)((char *)&v27[1] + a5 + 1) == v13 )
      break;
    v17 = *((unsigned __int8 *)v13 + 1);
    v13 = (_DWORD *)((char *)v13 + 1);
    v7 = v17;
  }
  *((_BYTE *)v27 + v15) = HIBYTE(v16);
  v18 = g_bitmain_pic_state[2 * a1];
  *((_BYTE *)v27 + v14) = v16;
  if ( iic_write(v18, (int)v27, v12) != v9 )
  {
    v19 = 1;
    V_LOCK();
    logfmt_raw(var1000, 0x1000u, 0, "%s write iic err", "write_dc_dc");
    V_UNLOCK();
    v20 = 61;
LABEL_18:
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/drv_pic/isl68127.c",
      165,
      "write_dc_dc",
      11,
      v20,
      100,
      var1000);
    goto LABEL_19;
  }
  usleep((__useconds_t)&loc_30D40);
  v22 = g_bitmain_pic_state[2 * a1];
  v24 = 0;
  v23 = 0;
  v25 = 0;
  v26 = 0;
  if ( iic_read(v22, &v23, 5) != 5 )
  {
    v19 = 1;
    V_LOCK();
    logfmt_raw(var1000, 0x1000u, 0, "%s read iic err", "write_dc_dc");
    V_UNLOCK();
    v20 = 68;
    goto LABEL_18;
  }
  if ( BYTE1(v23) != 50 || (v19 = BYTE2(v23), BYTE2(v23) != 1) )
  {
    V_LOCK();
    v19 = 0;
    logfmt_raw(
      var1000,
      0x1000u,
      0,
      "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x, read_back_data[3] = 0x%02x",
      "write_dc_dc",
      (unsigned __int8)v23,
      BYTE1(v23),
      BYTE2(v23),
      HIBYTE(v23));
    V_UNLOCK();
    v20 = 75;
    goto LABEL_18;
  }
LABEL_19:
  pthread_mutex_unlock(&i2c_mutex_all);
  return v19;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1197E4: using guessed type pthread_mutex_t i2c_mutex_all;
// 11A7AC: using guessed type int g_zc;
// 11B3D8: using guessed type _DWORD g_bitmain_pic_state[32];

//----- (00074090) --------------------------------------------------------
int __fastcall sub_74090(unsigned __int8 a1, char a2, _BYTE *a3)
{
  int v6; // r0
  __int16 v7; // r3
  int v8; // r5
  int v9; // r12
  int v10; // r0
  int v12; // r0
  char v13; // r3
  int v14; // [sp+1Ch] [bp-101Ch] BYREF
  int v15; // [sp+20h] [bp-1018h]
  char v16; // [sp+24h] [bp-1014h]
  int v17; // [sp+28h] [bp-1010h] BYREF
  int v18; // [sp+2Ch] [bp-100Ch]
  int v19; // [sp+30h] [bp-1008h]
  int v20; // [sp+34h] [bp-1004h]
  char v21[4096]; // [sp+38h] [bp-1000h] BYREF

  v17 = 255;
  v15 = 0;
  v16 = 0;
  v14 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  pthread_mutex_lock(&i2c_mutex_all);
  v6 = g_bitmain_pic_state[2 * a1];
  v14 = 839363157;
  v7 = (unsigned __int8)(2 * a2) | 1;
  *(_WORD *)((char *)&v15 + 1) = 545;
  LOBYTE(v15) = (2 * a2) | 1;
  v16 = v7 + 92;
  HIBYTE(v15) = (unsigned __int16)(v7 + 92) >> 8;
  if ( iic_write(v6, (int)&v14, 9) == 9 )
  {
    usleep(0x30D40u);
    v12 = g_bitmain_pic_state[2 * a1];
    v17 = 0;
    v18 = 0;
    v19 = 0;
    v20 = 0;
    if ( iic_read(v12, &v17, 5) == 5 )
    {
      if ( BYTE1(v17) == 50 )
      {
        v8 = BYTE2(v17);
        if ( BYTE2(v17) == 1 )
        {
          v13 = v18;
          *a3 = HIBYTE(v17);
          a3[1] = v13;
          goto LABEL_4;
        }
      }
      V_LOCK();
      v8 = 0;
      logfmt_raw(
        v21,
        0x1000u,
        0,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x, read_back_data[3] = 0x%02x",
        "read_dc_dc",
        (unsigned __int8)v17,
        BYTE1(v17),
        BYTE2(v17),
        HIBYTE(v17));
      V_UNLOCK();
      v9 = 125;
      v10 = g_zc;
    }
    else
    {
      v8 = 1;
      V_LOCK();
      logfmt_raw(v21, 0x1000u, 0, "%s read iic err", "read_dc_dc");
      V_UNLOCK();
      v9 = 118;
      v10 = g_zc;
    }
  }
  else
  {
    v8 = 1;
    V_LOCK();
    logfmt_raw(v21, 0x1000u, 0, "%s write iic err", "read_dc_dc");
    V_UNLOCK();
    v9 = 110;
    v10 = g_zc;
  }
  zlog(
    v10,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/backend/device/hal/drv_pic/isl68127.c",
    165,
    "read_dc_dc",
    10,
    v9,
    100,
    v21);
LABEL_4:
  pthread_mutex_unlock(&i2c_mutex_all);
  return v8;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1197E4: using guessed type pthread_mutex_t i2c_mutex_all;
// 11A7AC: using guessed type int g_zc;
// 11B3D8: using guessed type _DWORD g_bitmain_pic_state[32];

//----- (000742E4) --------------------------------------------------------
int __fastcall sub_742E4(unsigned __int8 a1, char a2, _WORD *a3)
{
  __int16 v5; // [sp+4h] [bp-4h] BYREF

  v5 = 0;
  sub_74090(a1, a2, &v5);
  *a3 = (unsigned __int8)v5 | (HIBYTE(v5) << 8);
  return 1;
}

//----- (0007431C) --------------------------------------------------------
int __fastcall get_chain_isl_voltage(unsigned __int8 a1, int a2, int a3)
{
  char *v3; // r9
  int v4; // r5
  int v5; // r6
  int v6; // t1
  int v8; // [sp+10h] [bp-1038h]
  unsigned __int16 v10; // [sp+1Eh] [bp-102Ah] BYREF
  char v11[4136]; // [sp+20h] [bp-1028h] BYREF

  if ( a3 <= 2 )
    return 0;
  v3 = "QT";
  v4 = a2 - 2;
  v5 = 80;
  v8 = a2 + 4;
  while ( 1 )
  {
    v10 = 0;
    sub_742E4(a1, v5, &v10);
    *(_WORD *)(v4 + 2) = v10;
    v4 += 2;
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, 965500, v5, v10);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/drv_pic/isl68127.c",
      165,
      "get_chain_isl_voltage",
      21,
      202,
      60,
      v11);
    if ( v4 == v8 )
      break;
    v6 = (unsigned __int8)*v3++;
    v5 = v6;
  }
  return 1;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00074408) --------------------------------------------------------
int __fastcall set_chain_isl_voltage(unsigned __int8 a1, int a2)
{
  _DWORD *v2; // r10
  int v3; // r9
  int v5; // r6
  int v6; // r5
  int v7; // r2
  int v9; // [sp+18h] [bp-102Ch]
  int v10; // [sp+28h] [bp-101Ch]
  unsigned int v12; // [sp+30h] [bp-1014h]
  char v13; // [sp+3Bh] [bp-1009h] BYREF
  __int16 v14; // [sp+3Ch] [bp-1008h] BYREF
  unsigned __int16 v15; // [sp+3Eh] [bp-1006h] BYREF
  char v16[4100]; // [sp+40h] [bp-1004h] BYREF

  LOWORD(v2) = -22612;
  v10 = 0;
  v12 = a2 - 810;
  if ( (unsigned int)(a2 - 810) > 0xB4 )
    v3 = 900;
  else
    v3 = a2;
  HIWORD(v2) = 17;
  v5 = 80;
  if ( v12 > 0xB4 )
    goto LABEL_12;
  while ( 1 )
  {
    LOBYTE(v6) = 4;
    v15 = 0;
    while ( 1 )
    {
      v13 = -1;
      sub_73DE4(a1, v5, 0, &v13, 1);
      usleep((__useconds_t)"rl_kda_2110");
      v14 = v3;
      sub_73DE4(a1, v5, 33, (char *)&v14, 2);
      usleep((__useconds_t)&loc_30D40);
      sub_742E4(a1, v5, &v15);
      v7 = v15;
      if ( v15 >= v3 - 9 && v15 <= v3 + 9 )
        break;
      V_LOCK();
      logfmt_raw(v16, 0x1000u, 0, 965596, v3, v15);
      V_UNLOCK();
      zlog(
        *v2,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/drv_pic/isl68127.c",
        165,
        "ISL_set_voltage_dynamic",
        23,
        181,
        60,
        v16);
      usleep((__useconds_t)&loc_30D40);
      v6 = (unsigned __int8)(v6 - 1);
      if ( !v6 )
      {
        v7 = v15;
        break;
      }
    }
    v9 = v7;
    V_LOCK();
    logfmt_raw(v16, 0x1000u, 0, "Set one chain ISL: domain addr = %x set vol %d, get vol %d", v5, a2, v9);
    V_UNLOCK();
    ++v10;
    zlog(
      *v2,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/drv_pic/isl68127.c",
      165,
      "set_chain_isl_voltage",
      21,
      215,
      60,
      v16);
    if ( v10 == 3 )
      return 1;
    v5 = (unsigned __int8)aPqt[v10];
    if ( v12 > 0xB4 )
    {
LABEL_12:
      V_LOCK();
      logfmt_raw(v16, 0x1000u, 0, 965544, 810, 990, 900);
      V_UNLOCK();
      zlog(
        *v2,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/drv_pic/isl68127.c",
        165,
        "ISL_set_voltage_dynamic",
        23,
        154,
        60,
        v16);
    }
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000746C0) --------------------------------------------------------
int __fastcall sub_746C0(_DWORD *a1, _DWORD *a2)
{
  return *a1 - *a2;
}

//----- (000746D0) --------------------------------------------------------
unsigned int sub_746D0()
{
  int v0; // r4
  int v2; // [sp+4h] [bp-8h] BYREF

  v0 = 601;
  v2 = 0;
  do
  {
    fpga_read(48, &v2);
    if ( v2 < 0 )
      return (unsigned int)v2 >> 31;
    usleep(0x1388u);
    --v0;
  }
  while ( v0 );
  return 0;
}

//----- (0007472C) --------------------------------------------------------
unsigned int __fastcall sub_7472C(_BYTE *a1)
{
  int v2; // r5
  unsigned int result; // r0
  int v4; // [sp+14h] [bp-1804h] BYREF
  char s[2040]; // [sp+18h] [bp-1800h] BYREF
  char v6[4096]; // [sp+818h] [bp-1000h] BYREF

  v2 = 601;
  v4 = 0;
  do
  {
    fpga_read(48, &v4);
    snprintf(s, 0x800u, "read status r = 0x%04x\n", v4);
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_i2c.c",
      171,
      "wait4i2c_data",
      13,
      107,
      20,
      v6);
    if ( v4 < 0 )
    {
      result = (unsigned int)v4 >> 31;
      *a1 = v4;
      return result;
    }
    usleep(0x1388u);
    --v2;
  }
  while ( v2 );
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0007481C) --------------------------------------------------------
int i2c_init()
{
  int v0; // r4
  int *v1; // r6
  int v3; // [sp+14h] [bp-1804h] BYREF
  char v4[2040]; // [sp+18h] [bp-1800h] BYREF
  _DWORD v5[1024]; // [sp+818h] [bp-1000h] BYREF

  v3 = -1;
  if ( platform_inited )
  {
    v0 = dword_11A6AC;
    if ( dword_11A6AC )
    {
      v1 = (int *)dword_11A6B0;
    }
    else
    {
      v1 = new_c_map(476864, 0, 0);
      dword_11A6B0 = (int)v1;
      pthread_mutex_init(&stru_11A6B4, 0);
      v0 = dword_11A6AC;
    }
    dword_11A6AC = v0 + 1;
    v3 = v0 + 1;
    v5[0] = 0;
    v5[1] = 0;
    insert_c_map(v1, &v3, 4u, v5, 8u);
    return v3;
  }
  else
  {
    strcpy(v4, "please init platform first!!\n");
    V_LOCK();
    logfmt_raw((char *)v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_i2c.c",
      171,
      "i2c_init",
      8,
      40,
      100,
      v5);
    return -2;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 119800: using guessed type int platform_inited;
// 11A6AC: using guessed type int dword_11A6AC;
// 11A6B0: using guessed type int dword_11A6B0;
// 11A7AC: using guessed type int g_zc;

//----- (00074964) --------------------------------------------------------
int __fastcall i2c_uninit(int a1)
{
  int v1; // r4
  int (**v2)(void); // r5
  int result; // r0
  int v4; // [sp+14h] [bp-7FCh] BYREF
  _DWORD s[512]; // [sp+18h] [bp-7F8h] BYREF
  char v6[4100]; // [sp+818h] [bp+8h] BYREF

  v4 = a1;
  v1 = pthread_mutex_lock(&stru_11A6B4);
  if ( v1 )
  {
    strcpy((char *)s, "failed to i2c lock\n");
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, s);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer"
             "-origin_godminer-new/backend/device/hal/platform/7007/7007_i2c.c",
             171,
             "i2c_uninit",
             10,
             61,
             100,
             v6);
  }
  else
  {
    if ( exists_c_map((int *)dword_11A6B0, (int)&v4) == (int *)1 )
    {
      snprintf((char *)s, 0x800u, "remove %d from callback list\n", v4);
      V_LOCK();
      logfmt_raw(v6, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_i2c.c",
        171,
        "i2c_uninit",
        10,
        65,
        20,
        v6);
      remove_c_map((int *)dword_11A6B0, (int)&v4);
    }
    else
    {
      snprintf((char *)s, 0x800u, "ctx(%d) is not inited\n", v4);
      V_LOCK();
      logfmt_raw(v6, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_i2c.c",
        171,
        "i2c_uninit",
        10,
        68,
        80,
        v6);
    }
    v2 = (int (**)(void))new_iterator_c_map(dword_11A6B0);
    if ( (*v2)() )
    {
      do
        ++v1;
      while ( ((int (__fastcall *)(int (**)(void)))*v2)(v2) );
      delete_iterator_c_map(v2);
      pthread_mutex_unlock(&stru_11A6B4);
      snprintf((char *)s, 0x800u, "still have %d nodes\n", v1);
      V_LOCK();
      logfmt_raw(v6, 0x1000u, 0, s);
      V_UNLOCK();
      return zlog(
               g_zc,
               "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godmin"
               "er-origin_godminer-new/backend/device/hal/platform/7007/7007_i2c.c",
               171,
               "i2c_uninit",
               10,
               84,
               20,
               v6);
    }
    else
    {
      delete_iterator_c_map(v2);
      pthread_mutex_unlock(&stru_11A6B4);
      strcpy((char *)s, "all i2c uninited\n");
      V_LOCK();
      logfmt_raw(v6, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_i2c.c",
        171,
        "i2c_uninit",
        10,
        79,
        20,
        v6);
      dword_11A6AC = 0;
      result = delete_c_map((void (__fastcall ***)(_DWORD))dword_11A6B0);
      dword_11A6B0 = 0;
    }
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A6AC: using guessed type int dword_11A6AC;
// 11A6B0: using guessed type int dword_11A6B0;
// 11A7AC: using guessed type int g_zc;

//----- (00074C60) --------------------------------------------------------
int __fastcall i2c_read(int a1, _BYTE *a2, int a3)
{
  _DWORD *v5; // r9
  int v6; // r5
  _BYTE *v7; // r10
  _BYTE *v8; // r0
  int v10; // [sp+14h] [bp-180Ch] BYREF
  _DWORD *v11; // [sp+1Ch] [bp-1804h] BYREF
  char s[2048]; // [sp+20h] [bp-1800h] BYREF
  char v13[4096]; // [sp+820h] [bp-1000h] BYREF

  v10 = a1;
  if ( pthread_mutex_lock(&stru_11A6B4) )
  {
    strcpy(s, "failed to i2c lock\n");
    V_LOCK();
    logfmt_raw(v13, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_i2c.c",
      171,
      "i2c_read",
      8,
      129,
      100,
      v13);
    return -1;
  }
  else
  {
    v11 = 0;
    if ( find_c_map((int *)dword_11A6B0, (int)&v10, &v11) == 1 )
    {
      v5 = v11;
      snprintf(s, 0x800u, "i2c read master = %d, slave = %d\n", *v11, v11[1]);
      V_LOCK();
      logfmt_raw(v13, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_i2c.c",
        171,
        "i2c_read",
        8,
        136,
        20,
        v13);
      v6 = (*v5 << 26) | 0x2000000 | (v5[1] >> 4 << 20) | (v5[1] << 15) & 0x70000;
      if ( a3 )
      {
        v7 = &a2[a3];
        while ( 1 )
        {
          if ( !sub_746D0() )
          {
            free(v11);
            strcpy(s, "iic not ready 4 read1\n");
            V_LOCK();
            logfmt_raw(v13, 0x1000u, 0, s);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godmine"
              "r-origin_godminer-new/backend/device/hal/platform/7007/7007_i2c.c",
              171,
              "i2c_read",
              8,
              143,
              100,
              v13);
            pthread_mutex_unlock(&stru_11A6B4);
            return -2;
          }
          fpga_write(48, v6);
          v8 = a2++;
          if ( !sub_7472C(v8) )
            break;
          if ( a2 == v7 )
            goto LABEL_9;
        }
        free(v11);
        strcpy(s, "iic not ready 4 read2\n");
        V_LOCK();
        logfmt_raw(v13, 0x1000u, 0, s);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/device/hal/platform/7007/7007_i2c.c",
          171,
          "i2c_read",
          8,
          154,
          100,
          v13);
        pthread_mutex_unlock(&stru_11A6B4);
        return -3;
      }
      else
      {
LABEL_9:
        free(v11);
        pthread_mutex_unlock(&stru_11A6B4);
        return a3;
      }
    }
    else
    {
      snprintf(s, 0x800u, "7007_i2c %s ctx %d not inited\n", "i2c_read", v10);
      V_LOCK();
      logfmt_raw(v13, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_i2c.c",
        171,
        "i2c_read",
        8,
        161,
        100,
        v13);
      pthread_mutex_unlock(&stru_11A6B4);
      return -2;
    }
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A6B0: using guessed type int dword_11A6B0;
// 11A7AC: using guessed type int g_zc;

//----- (00074FE8) --------------------------------------------------------
int __fastcall i2c_write(int a1, int a2, int a3)
{
  _DWORD *v5; // r6
  int v6; // r7
  int v7; // r5
  int v8; // r7
  int v9; // t1
  int v10; // r4
  int v12; // [sp+14h] [bp-1810h] BYREF
  void *ptr; // [sp+1Ch] [bp-1808h] BYREF
  char s[2048]; // [sp+20h] [bp-1804h] BYREF
  char v15[4100]; // [sp+820h] [bp-1004h] BYREF

  v12 = a1;
  if ( pthread_mutex_lock(&stru_11A6B4) )
  {
    strcpy(s, "failed to i2c lock\n");
    V_LOCK();
    logfmt_raw(v15, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_i2c.c",
      171,
      "i2c_write",
      9,
      182,
      100,
      v15);
    return -1;
  }
  else
  {
    ptr = 0;
    if ( find_c_map((int *)dword_11A6B0, (int)&v12, &ptr) == 1 )
    {
      v5 = ptr;
      snprintf(s, 0x800u, "i2c read master = %d, slave = %d\n", *(_DWORD *)ptr, *((_DWORD *)ptr + 1));
      V_LOCK();
      logfmt_raw(v15, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_i2c.c",
        171,
        "i2c_write",
        9,
        189,
        20,
        v15);
      if ( a3 )
      {
        v6 = a2 + a3;
        v7 = a2 - 1;
        v8 = v6 - 1;
        while ( 1 )
        {
          v9 = *(unsigned __int8 *)++v7;
          v10 = v9 | (v5[1] >> 4 << 20) | (*v5 << 26) | (v5[1] << 15) & 0x70000;
          if ( !sub_746D0() )
            break;
          fpga_write(48, v10);
          if ( v8 == v7 )
            goto LABEL_8;
        }
        free(ptr);
        strcpy(s, "iic not ready 4 write\n");
        V_LOCK();
        logfmt_raw(v15, 0x1000u, 0, s);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/device/hal/platform/7007/7007_i2c.c",
          171,
          "i2c_write",
          9,
          196,
          100,
          v15);
        pthread_mutex_unlock(&stru_11A6B4);
        return -2;
      }
      else
      {
LABEL_8:
        free(ptr);
        pthread_mutex_unlock(&stru_11A6B4);
        return a3;
      }
    }
    else
    {
      snprintf(s, 0x800u, "7007_i2c %s ctx %d not inited\n", "i2c_write", v12);
      V_LOCK();
      logfmt_raw(v15, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_i2c.c",
        171,
        "i2c_write",
        9,
        205,
        100,
        v15);
      pthread_mutex_unlock(&stru_11A6B4);
      return -2;
    }
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A6B0: using guessed type int dword_11A6B0;
// 11A7AC: using guessed type int g_zc;

//----- (000752D4) --------------------------------------------------------
int __fastcall i2c_read_reg(void *a1, unsigned __int8 *a2, int a3, int a4, unsigned int a5)
{
  unsigned int v6; // r5
  _DWORD *v7; // r6
  unsigned int v8; // r0
  unsigned int v9; // r2
  unsigned int v10; // r1
  int v11; // r3
  int v12; // r2
  int v13; // r3
  int v14; // r4
  void *ptr; // [sp+1Ch] [bp-804h] BYREF
  _DWORD *v19; // [sp+24h] [bp-7FCh] BYREF
  char s[2048]; // [sp+28h] [bp-7F8h] BYREF
  char _828[4120]; // [sp+828h] [bp+8h] BYREF

  ptr = a1;
  if ( (unsigned int)(a3 - 1) > 1 )
  {
    strcpy(s, "more than one byte reg address is not supported\n");
    V_LOCK();
    logfmt_raw(_828, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_i2c.c",
      171,
      "i2c_read_reg",
      12,
      227,
      100,
      _828);
    return -3;
  }
  else
  {
    v6 = pthread_mutex_lock(&stru_11A6B4);
    if ( v6 )
    {
      strcpy(s, "failed to i2c lock\n");
      V_LOCK();
      logfmt_raw(_828, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_i2c.c",
        171,
        "i2c_read_reg",
        12,
        231,
        100,
        _828);
      return -1;
    }
    else
    {
      v19 = 0;
      if ( find_c_map((int *)dword_11A6B0, (int)&ptr, &v19) == 1 )
      {
        v7 = v19;
        snprintf(s, 0x800u, "i2c read master = %d, slave = %d\n", *v19, v19[1]);
        V_LOCK();
        logfmt_raw(_828, 0x1000u, 0, s);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/device/hal/platform/7007/7007_i2c.c",
          171,
          "i2c_read_reg",
          12,
          238,
          20,
          _828);
        if ( a5 )
        {
          while ( 1 )
          {
            v9 = v7[1];
            v10 = v9 >> 4 << 20;
            v11 = *v7 << 26;
            v12 = (v9 << 15) & 0x70000;
            if ( a3 == 2 )
              v13 = v11 | 0x3000000;
            else
              v13 = v11 | 0x3080000;
            v14 = v13 | v10 | v12 | ((*a2 + v6) << 8);
            if ( !sub_746D0() )
            {
              strcpy(s, "iic not ready 4 read1\n");
              V_LOCK();
              logfmt_raw(_828, 0x1000u, 0, s);
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godmi"
                "ner-origin_godminer-new/backend/device/hal/platform/7007/7007_i2c.c",
                171,
                "i2c_read_reg",
                12,
                249,
                100,
                _828);
              free(v19);
              pthread_mutex_unlock(&stru_11A6B4);
              return -2;
            }
            fpga_write(48, v14);
            snprintf(s, 0x800u, "i2c read master = %d, slave = %d, config = %08x", *v7, v7[1], v14);
            V_LOCK();
            logfmt_raw(_828, 0x1000u, 0, s);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godmine"
              "r-origin_godminer-new/backend/device/hal/platform/7007/7007_i2c.c",
              171,
              "i2c_read_reg",
              12,
              255,
              20,
              _828);
            v8 = sub_7472C((_BYTE *)(a4 + v6));
            v6 += a3 + 1;
            if ( !v8 )
              break;
            if ( a5 <= v6 )
              goto LABEL_13;
          }
          strcpy(s, "iic failed to read data\n");
          V_LOCK();
          logfmt_raw(_828, 0x1000u, 0, s);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/backend/device/hal/platform/7007/7007_i2c.c",
            171,
            "i2c_read_reg",
            12,
            261,
            100,
            _828);
          free(v19);
          pthread_mutex_unlock(&stru_11A6B4);
          return -3;
        }
        else
        {
LABEL_13:
          free(v19);
          pthread_mutex_unlock(&stru_11A6B4);
          return a5;
        }
      }
      else
      {
        snprintf(s, 0x800u, "7007_i2c %s ctx %d not inited\n", "i2c_read_reg", ptr);
        V_LOCK();
        logfmt_raw(_828, 0x1000u, 0, s);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/device/hal/platform/7007/7007_i2c.c",
          171,
          "i2c_read_reg",
          12,
          269,
          100,
          _828);
        pthread_mutex_unlock(&stru_11A6B4);
        return -2;
      }
    }
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A6B0: using guessed type int dword_11A6B0;
// 11A7AC: using guessed type int g_zc;

//----- (000757C0) --------------------------------------------------------
int __fastcall i2c_write_reg(int a1, unsigned __int8 *a2, int a3, int a4, int a5)
{
  int v7; // r10
  _DWORD *v8; // r5
  int v9; // r6
  int v10; // t1
  int v11; // r2
  int v12; // r4
  int v14; // [sp+14h] [bp-180Ch] BYREF
  void *ptr; // [sp+1Ch] [bp-1804h] BYREF
  char s[2048]; // [sp+20h] [bp-1800h] BYREF
  char v17[4096]; // [sp+820h] [bp-1000h] BYREF

  v14 = a1;
  if ( a3 == 1 )
  {
    v7 = pthread_mutex_lock(&stru_11A6B4);
    if ( v7 )
    {
      strcpy(s, "failed to i2c lock\n");
      V_LOCK();
      logfmt_raw(v17, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_i2c.c",
        171,
        "i2c_write_reg",
        13,
        295,
        100,
        v17);
      return -1;
    }
    else
    {
      ptr = 0;
      if ( find_c_map((int *)dword_11A6B0, (int)&v14, &ptr) == 1 )
      {
        v8 = ptr;
        snprintf(s, 0x800u, "i2c read master = %d, slave = %d\n", *(_DWORD *)ptr, *((_DWORD *)ptr + 1));
        V_LOCK();
        logfmt_raw(v17, 0x1000u, 0, s);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/device/hal/platform/7007/7007_i2c.c",
          171,
          "i2c_write_reg",
          13,
          302,
          20,
          v17);
        if ( a5 )
        {
          v9 = a4 - 1;
          while ( 1 )
          {
            v10 = *(unsigned __int8 *)++v9;
            v11 = *a2 + v7++;
            v12 = (*v8 << 26) | 0x1000000 | (v8[1] >> 4 << 20) | v10 | (v8[1] << 15) & 0x70000 | (v11 << 8);
            if ( !sub_746D0() )
              break;
            fpga_write(48, v12);
            if ( a5 == v7 )
              goto LABEL_9;
          }
          strcpy(s, "iic not ready 4 write\n");
          V_LOCK();
          logfmt_raw(v17, 0x1000u, 0, s);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/backend/device/hal/platform/7007/7007_i2c.c",
            171,
            "i2c_write_reg",
            13,
            310,
            100,
            v17);
          free(ptr);
          pthread_mutex_unlock(&stru_11A6B4);
          return -2;
        }
        else
        {
LABEL_9:
          free(ptr);
          pthread_mutex_unlock(&stru_11A6B4);
          return a5;
        }
      }
      else
      {
        snprintf(s, 0x800u, "7007_i2c %s ctx %d not inited\n", "i2c_write_reg", v14);
        V_LOCK();
        logfmt_raw(v17, 0x1000u, 0, s);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/device/hal/platform/7007/7007_i2c.c",
          171,
          "i2c_write_reg",
          13,
          320,
          100,
          v17);
        pthread_mutex_unlock(&stru_11A6B4);
        return -2;
      }
    }
  }
  else
  {
    strcpy(s, "more than one byte reg address is not supported\n");
    V_LOCK();
    logfmt_raw(v17, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_i2c.c",
      171,
      "i2c_write_reg",
      13,
      291,
      100,
      v17);
    return -3;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A6B0: using guessed type int dword_11A6B0;
// 11A7AC: using guessed type int g_zc;

//----- (00075B60) --------------------------------------------------------
int __fastcall i2c_ioctl(int a1, int a2, int a3)
{
  _DWORD *v6; // r4
  int *v7; // r0
  int *v8; // r8
  int v9; // r2
  void (__fastcall *v10)(_DWORD *, _DWORD *, int); // r3
  _DWORD v12[2]; // [sp+10h] [bp-1808h] BYREF
  char s[2040]; // [sp+18h] [bp-1800h] BYREF
  char v14[4096]; // [sp+818h] [bp-1000h] BYREF

  if ( pthread_mutex_lock(&stru_11A6B4) )
  {
    strcpy(s, "failed to i2c lock\n");
    V_LOCK();
    logfmt_raw(v14, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_i2c.c",
      171,
      "i2c_ioctl",
      9,
      340,
      100,
      v14);
    return -4;
  }
  else
  {
    v6 = new_iterator_c_map(dword_11A6B0);
    if ( ((int (*)(void))*v6)() )
    {
      while ( ***(_DWORD ***)(v6[5] + 16) != a1 )
      {
        if ( !((int (__fastcall *)(_DWORD *))*v6)(v6) )
          goto LABEL_8;
      }
      v7 = (int *)((int (*)(void))v6[2])();
      v8 = v7;
      if ( a2 == 1795 )
      {
        v9 = *v7;
        v10 = (void (__fastcall *)(_DWORD *, _DWORD *, int))v6[1];
        v12[1] = a3;
        v12[0] = v9;
        v10(v6, v12, 8);
        snprintf(s, 0x800u, "update the slave address to %d\n", a3);
        V_LOCK();
        logfmt_raw(v14, 0x1000u, 0, s);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/backend/device/hal/platform/7007/7007_i2c.c",
          171,
          "i2c_ioctl",
          9,
          354,
          20,
          v14);
        free(v8);
      }
    }
LABEL_8:
    delete_iterator_c_map(v6);
    pthread_mutex_unlock(&stru_11A6B4);
    return 0;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A6B0: using guessed type int dword_11A6B0;
// 11A7AC: using guessed type int g_zc;

//----- (00075D40) --------------------------------------------------------
int __fastcall i2c_select(int a1, int a2)
{
  _DWORD *v4; // r4
  _DWORD *v5; // r7
  void (__fastcall *v6)(_DWORD *, _DWORD *, int); // r3
  int v7; // r2
  _DWORD v9[2]; // [sp+10h] [bp-180Ch] BYREF
  char s[2040]; // [sp+18h] [bp-1804h] BYREF
  char v11[4100]; // [sp+818h] [bp-1004h] BYREF

  if ( pthread_mutex_lock(&stru_11A6B4) )
  {
    strcpy(s, "failed to i2c lock\n");
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_i2c.c",
      171,
      "i2c_select",
      10,
      373,
      100,
      v11);
    return -4;
  }
  else
  {
    v4 = new_iterator_c_map(dword_11A6B0);
    if ( ((int (*)(void))*v4)() )
    {
      while ( ***(_DWORD ***)(v4[5] + 16) != a1 )
      {
        if ( !((int (__fastcall *)(_DWORD *))*v4)(v4) )
          goto LABEL_7;
      }
      v5 = (_DWORD *)((int (*)(void))v4[2])();
      v6 = (void (__fastcall *)(_DWORD *, _DWORD *, int))v4[1];
      v7 = v5[1];
      v9[0] = a2;
      v9[1] = v7;
      v6(v4, v9, 8);
      snprintf(s, 0x800u, "update the master address to %d\n", a2);
      V_LOCK();
      logfmt_raw(v11, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_i2c.c",
        171,
        "i2c_select",
        10,
        384,
        20,
        v11);
      free(v5);
    }
LABEL_7:
    delete_iterator_c_map(v4);
    pthread_mutex_unlock(&stru_11A6B4);
    return 0;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A6B0: using guessed type int dword_11A6B0;
// 11A7AC: using guessed type int g_zc;

//----- (00075F10) --------------------------------------------------------
int __fastcall lcd_init(int a1)
{
  int result; // r0
  char v2[2048]; // [sp+10h] [bp-1800h] BYREF
  char v3[4096]; // [sp+810h] [bp-1000h] BYREF

  if ( dword_11A6CC )
    return 0;
  if ( a1 )
  {
    result = open64(a1);
    dword_11A6D0 = result;
    if ( result < 0 )
    {
      strcpy(v2, "open lcd failed!!!\n");
      V_LOCK();
      logfmt_raw(v3, 0x1000u, 0, v2);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_lcd.c",
        171,
        "lcd_init",
        8,
        41,
        100,
        v3);
      return -1;
    }
    else
    {
      dword_11A6CC = 1;
    }
  }
  else
  {
    strcpy(v2, "bad param\n");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_lcd.c",
      171,
      "lcd_init",
      8,
      35,
      100,
      v3);
    return -3;
  }
  return result;
}
// 1E754: using guessed type int __fastcall open64(_DWORD);
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A6CC: using guessed type int dword_11A6CC;
// 11A6D0: using guessed type int dword_11A6D0;
// 11A7AC: using guessed type int g_zc;

//----- (0007606C) --------------------------------------------------------
int __fastcall lcd_write(int a1, int a2, int a3, unsigned int a4)
{
  int v4; // r7
  unsigned int v5; // r4
  bool v6; // cc
  int v7; // r5
  int v9; // r11
  unsigned __int8 v10; // r5
  size_t v11; // r6
  const void *v12; // r1
  char v15[2048]; // [sp+10h] [bp-1804h] BYREF
  char v16[4100]; // [sp+810h] [bp-1004h] BYREF

  v4 = a2;
  if ( !dword_11A6CC )
    return -2;
  v5 = a4;
  if ( dword_11A6D0 != a1 )
    goto LABEL_18;
  v6 = a4 > 0x40;
  if ( a4 <= 0x40 )
    v6 = (unsigned __int8)a2 > 3u;
  v7 = v6;
  if ( v6 )
  {
LABEL_18:
    strcpy(v15, "bad param\n");
    V_LOCK();
    logfmt_raw(v16, 0x1000u, 0, v15);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_lcd.c",
      171,
      "lcd_write",
      9,
      69,
      80,
      v16);
    return -3;
  }
  else
  {
    v9 = pthread_mutex_lock(&stru_11A6D4);
    if ( v9 )
    {
      strcpy(v15, "failed to lcd lock\n");
      V_LOCK();
      logfmt_raw(v16, 0x1000u, v7, v15);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_lcd.c",
        171,
        "lcd_write",
        9,
        75,
        100,
        v16);
      return -4;
    }
    else
    {
      do
      {
        v10 = v4 + 1;
        if ( v5 >= 0x10 )
          v11 = 16;
        else
          v11 = v5;
        v12 = (const void *)(a3 + v9);
        v9 += v11;
        memcpy((char *)&unk_11A6EC + 16 * v4, v12, v11);
        v5 -= v11;
        v4 = (char)v10;
      }
      while ( v10 <= 3u && v5 != 0 );
      write(dword_11A6D0, &unk_11A6EC, 0x40u);
      pthread_mutex_unlock(&stru_11A6D4);
      return 0;
    }
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A6CC: using guessed type int dword_11A6CC;
// 11A6D0: using guessed type int dword_11A6D0;
// 11A7AC: using guessed type int g_zc;

//----- (0007625C) --------------------------------------------------------
int lcd_flush()
{
  return 0;
}

//----- (00076264) --------------------------------------------------------
int __fastcall lcd_clear(int a1)
{
  int v1; // r6
  int v2; // r1
  char v4[2048]; // [sp+10h] [bp-1800h] BYREF
  char v5[4096]; // [sp+810h] [bp-1000h] BYREF

  if ( !dword_11A6CC )
    return -2;
  if ( dword_11A6D0 == a1 )
  {
    if ( pthread_mutex_lock(&stru_11A6D4) )
    {
      strcpy(v4, "failed to lcd lock\n");
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/backend/device/hal/platform/7007/7007_lcd.c",
        171,
        "lcd_clear",
        9,
        123,
        100,
        v5);
      return -4;
    }
    else
    {
      memset(&unk_11A6EC, 0x20, 0x40u);
      v1 = dword_11A6D0;
      lseek64(dword_11A6D0, v2, 0, 0, 0);
      write(v1, &unk_11A6EC, 0x40u);
      pthread_mutex_unlock(&stru_11A6D4);
      return 0;
    }
  }
  else
  {
    strcpy(v4, "bad param\n");
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_lcd.c",
      171,
      "lcd_clear",
      9,
      117,
      80,
      v5);
    return -3;
  }
}
// 762C4: variable 'v2' is possibly undefined
// 1E6F4: using guessed type int __fastcall lseek64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A6CC: using guessed type int dword_11A6CC;
// 11A6D0: using guessed type int dword_11A6D0;
// 11A7AC: using guessed type int g_zc;

//----- (00076400) --------------------------------------------------------
int __fastcall lcd_uninit(int a1)
{
  int result; // r0
  char v2[2048]; // [sp+10h] [bp-1804h] BYREF
  char v3[4100]; // [sp+810h] [bp-1004h] BYREF

  if ( !dword_11A6CC )
    return 0;
  result = close(a1);
  if ( result )
  {
    strcpy(v2, "lcd close failed!!!\n");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/backend/device/hal/platform/7007/7007_lcd.c",
      171,
      "lcd_uninit",
      10,
      147,
      100,
      v3);
    result = -1;
  }
  dword_11A6CC = 0;
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A6CC: using guessed type int dword_11A6CC;
// 11A7AC: using guessed type int g_zc;

//----- (000764D8) --------------------------------------------------------
unsigned int __fastcall sph_blake224_0(unsigned int *a1, char *a2, size_t a3)
{
  unsigned int v3; // r5
  size_t v4; // r4
  unsigned int v5; // r1
  unsigned int result; // r0
  char *v7; // r0
  bool v8; // cf
  unsigned int v9; // r0
  unsigned int v10; // lr
  unsigned int v11; // r3
  int v12; // r10
  int v13; // r8
  int v14; // r1
  unsigned int v15; // r3
  int v16; // r2
  int v17; // r9
  int v18; // r12
  int v19; // r6
  int v20; // r4
  int v21; // r11
  int v22; // r7
  unsigned int v23; // r0
  int v24; // lr
  int v25; // r3
  int v26; // r9
  int v27; // r8
  int v28; // r12
  int v29; // r2
  int v30; // r1
  int v31; // r4
  int v32; // r11
  int v33; // lr
  int v34; // r7
  int v35; // r6
  int v36; // r8
  int v37; // r5
  int v38; // r3
  int v39; // r0
  int v40; // r1
  int v41; // r10
  int v42; // r6
  int v43; // lr
  int v44; // r7
  int v45; // r5
  int v46; // r12
  int v47; // r9
  int v48; // r8
  int v49; // r1
  int v50; // r3
  int v51; // r0
  int v52; // r10
  int v53; // r2
  int v54; // r11
  int v55; // r6
  int v56; // r8
  int v57; // r4
  int v58; // r10
  int v59; // r7
  int v60; // r5
  int v61; // r0
  int v62; // r11
  int v63; // r9
  int v64; // r6
  int v65; // r12
  int v66; // r3
  int v67; // r1
  int v68; // r4
  int v69; // r5
  int v70; // r7
  int v71; // lr
  int v72; // r10
  int v73; // r12
  int v74; // r1
  int v75; // r0
  int v76; // r3
  int v77; // r9
  int v78; // r3
  int v79; // r2
  int v80; // r6
  int v81; // r11
  int v82; // r7
  int v83; // r5
  int v84; // r12
  int v85; // r9
  int v86; // r4
  int v87; // r3
  int v88; // r0
  int v89; // r8
  int v90; // r2
  int v91; // r1
  int v92; // r11
  int v93; // r10
  int v94; // lr
  int v95; // r7
  int v96; // r5
  int v97; // r12
  int v98; // r9
  int v99; // r0
  int v100; // r8
  int v101; // r2
  int v102; // r1
  int v103; // r6
  int v104; // r3
  int v105; // r10
  int v106; // r6
  int v107; // r4
  int v108; // r7
  int v109; // r11
  int v110; // lr
  int v111; // r8
  int v112; // r10
  int v113; // r11
  int v114; // r6
  int v115; // r12
  int v116; // r0
  int v117; // r9
  int v118; // r8
  int v119; // r4
  int v120; // r1
  int v121; // r10
  int v122; // r11
  int v123; // r6
  int v124; // r7
  int v125; // lr
  int v126; // r5
  int v127; // r0
  int v128; // lr
  int v129; // r9
  int v130; // r3
  int v131; // r12
  int v132; // r2
  int v133; // r1
  int v134; // r4
  int v135; // r5
  int v136; // lr
  int v137; // r7
  int v138; // r8
  int v139; // r0
  int v140; // r1
  int v141; // r9
  int v142; // r3
  int v143; // r6
  int v144; // r10
  int v145; // r4
  int v146; // r7
  int v147; // r5
  int v148; // r2
  int v149; // lr
  int v150; // r9
  int v151; // r10
  int v152; // r8
  int v153; // r12
  int v154; // r4
  int v155; // r1
  int v156; // r3
  int v157; // r6
  int v158; // r7
  int v159; // r8
  int v160; // r11
  int v161; // r5
  int v162; // r0
  int v163; // r10
  int v164; // lr
  int v165; // r1
  int v166; // r12
  int v167; // r9
  int v168; // r11
  int v169; // r2
  int v170; // r6
  int v171; // r5
  int v172; // r8
  int v173; // r10
  int v174; // r7
  int v175; // r0
  int v176; // lr
  int v177; // r12
  int v178; // r9
  int v179; // t2
  int v180; // r4
  int v181; // r11
  int v182; // r2
  int v183; // r5
  int v184; // r6
  int v185; // lr
  int v186; // r9
  int v187; // r0
  int v188; // r12
  int v189; // r4
  int v190; // r8
  int v191; // r10
  int v192; // r7
  int v193; // r2
  int v194; // r6
  int v195; // lr
  int v196; // r2
  int v197; // r0
  int v198; // r11
  int v199; // r5
  int v200; // r9
  int v201; // r3
  int v202; // lr
  int v203; // r12
  int v204; // r2
  int v205; // r5
  int v206; // r1
  int v207; // r4
  int v208; // r6
  int v209; // r10
  int v210; // r11
  int v211; // lr
  int v212; // r0
  int v213; // r7
  int v214; // r3
  int v215; // r5
  int v216; // r2
  int v217; // r12
  int v218; // r10
  int v219; // r4
  int v220; // r6
  int v221; // r1
  int v222; // r11
  int v223; // lr
  int v224; // r11
  int v225; // r8
  int v226; // r0
  int v227; // r3
  int v228; // r5
  int v229; // r1
  int v230; // r9
  int v231; // r12
  int v232; // r6
  int v233; // r2
  int v234; // r4
  int v235; // r11
  int v236; // lr
  int v237; // r0
  int v238; // r5
  int v239; // r4
  int v240; // r3
  int v241; // r7
  int v242; // r12
  int v243; // r9
  int v244; // r8
  int v245; // r2
  int v246; // r1
  int v247; // r6
  int v248; // r5
  int v249; // r0
  int v250; // r3
  int v251; // r11
  int v252; // r8
  int v253; // r10
  int v254; // lr
  int v255; // r12
  int v256; // r4
  int v257; // r9
  int v258; // r6
  int v259; // r7
  int v260; // r1
  int v261; // r11
  int v262; // r3
  int v263; // r8
  int v264; // r5
  int v265; // lr
  int v266; // r12
  int v267; // r10
  int v268; // r0
  int v269; // r4
  int v270; // r1
  int v271; // r3
  int v272; // r2
  int v273; // r6
  int v274; // r8
  int v275; // lr
  int v276; // r9
  int v277; // r0
  int v278; // r5
  int v279; // r1
  int v280; // r12
  int v281; // r5
  int v282; // r4
  int v283; // r11
  int v284; // r3
  int v285; // r1
  int v286; // r2
  int v287; // r9
  int v288; // lr
  int v289; // r10
  int v290; // r8
  int v291; // r5
  int v292; // r1
  int v293; // r7
  int v294; // r0
  int v295; // r12
  int v296; // r2
  int v297; // r6
  int v298; // r3
  int v299; // r11
  int v300; // r0
  int v301; // r1
  int v302; // r8
  int v303; // r12
  int v304; // r9
  int v305; // r4
  int v306; // r7
  int v307; // r10
  int v308; // r5
  int v309; // r6
  int v310; // r5
  int v311; // r3
  int v312; // r8
  int v313; // r1
  int v314; // r4
  unsigned int v315; // r11
  int v316; // r12
  int v317; // r9
  int v318; // r0
  int v319; // lr
  int v320; // t2
  int v321; // r3
  int v322; // r2
  int v323; // r10
  int v324; // r11
  int v325; // r12
  int v326; // r0
  int v327; // r6
  int v328; // r8
  int v329; // r7
  int v330; // lr
  int v331; // r5
  int v332; // r1
  int v333; // r9
  int v334; // r3
  int v335; // r6
  int v336; // r10
  int v337; // r3
  int v338; // lr
  int v339; // r8
  int v340; // r2
  int v341; // r11
  int v342; // r4
  int v343; // r0
  int v344; // r1
  int v345; // r7
  int v346; // r12
  int v347; // r5
  int v348; // r10
  int v349; // r2
  int v350; // lr
  int v351; // r3
  int v352; // r1
  int v353; // r9
  int v354; // r8
  int v355; // r12
  int v356; // r4
  int v357; // r11
  int v358; // r5
  int v359; // r2
  int v360; // r7
  int v361; // r6
  int v362; // r3
  int v363; // r1
  int v364; // r5
  int v365; // r11
  int v366; // r10
  int v367; // r8
  int v368; // lr
  int v369; // r0
  int v370; // r9
  int v371; // r10
  int v372; // r4
  int v373; // r2
  int v374; // r1
  int v375; // r3
  int v376; // r7
  int v377; // r5
  int v378; // r4
  int v379; // r8
  int v380; // r6
  int v381; // lr
  int v382; // r12
  int v383; // r1
  int v384; // r3
  int v385; // r2
  int v386; // r9
  int v387; // r7
  int v388; // r5
  int v389; // r12
  int v390; // r8
  int v391; // r4
  int v392; // r6
  int v393; // r0
  int v394; // r2
  int v395; // r3
  int v396; // r1
  int v397; // r9
  int v398; // r11
  int v399; // r8
  int v400; // lr
  int v401; // r7
  int v402; // r12
  int v403; // r6
  int v404; // lr
  int v405; // t2
  int v406; // r0
  int v407; // r2
  int v408; // r10
  int v409; // r3
  int v410; // r1
  int v411; // r6
  int v412; // r7
  int v413; // r12
  int v414; // r11
  int v415; // r8
  int v416; // r9
  int v417; // r5
  int v418; // lr
  int v419; // r0
  int v420; // r6
  int v421; // r10
  int v422; // r3
  int v423; // r1
  int v424; // r11
  int v425; // r12
  int v426; // r2
  int v427; // r7
  int v428; // lr
  int v429; // r8
  int v430; // r6
  int v431; // r3
  int v432; // r1
  int v433; // r2
  int v434; // r5
  int v435; // r2
  int v436; // r9
  int v437; // r11
  int v438; // r0
  int v439; // r7
  int v440; // r12
  int v441; // r12
  int v442; // r4
  int v443; // r10
  int v444; // lr
  int v445; // r3
  int v446; // r2
  int v447; // r5
  int v448; // r0
  int v449; // r12
  int v450; // r6
  int v451; // r11
  int v452; // r7
  int v453; // r8
  int v454; // lr
  int v455; // r10
  int v456; // r1
  int v457; // r3
  int v458; // r4
  int v459; // r9
  int v460; // r2
  int v461; // r6
  int v462; // r5
  int v463; // r11
  int v464; // r0
  int v465; // r6
  int v466; // r1
  int v467; // r8
  int v468; // r7
  int v469; // lr
  int v470; // r4
  int v471; // r2
  int v472; // r5
  int v473; // r9
  int v474; // r10
  int v475; // r3
  int v476; // r1
  int v477; // r11
  int v478; // r6
  int v479; // r8
  int v480; // r10
  int v481; // r12
  int v482; // r2
  int v483; // r4
  int v484; // r0
  int v485; // r5
  int v486; // t2
  int v487; // r8
  int v488; // r3
  int v489; // r1
  int v490; // r4
  int v491; // r10
  int v492; // r3
  int v493; // r10
  int v494; // r1
  int v495; // r7
  int v496; // lr
  int v497; // r5
  int v498; // r2
  int v499; // r9
  int v500; // r12
  int v501; // r8
  int v502; // r0
  int v503; // r6
  int v504; // r3
  int v505; // r10
  int v506; // r1
  int v507; // r4
  int v508; // r12
  int v509; // r11
  int v510; // r6
  int v511; // lr
  int v512; // r0
  int v513; // r2
  int v514; // r5
  int v515; // r7
  int v516; // r10
  int v517; // r1
  unsigned int v518; // r11
  int v519; // r6
  int v520; // lr
  int v521; // r9
  int v522; // r12
  int v523; // r4
  int v524; // r7
  int v525; // r8
  int v526; // r0
  int v527; // r5
  int v528; // r11
  int v529; // r10
  int v530; // r6
  int v531; // r9
  int v532; // r2
  int v533; // r1
  int v534; // r3
  int v535; // r2
  int v536; // lr
  int v537; // r4
  int v538; // r12
  int v539; // r9
  int v540; // r8
  int v541; // r0
  int v542; // r2
  int v543; // r3
  int v544; // r5
  int v545; // r8
  int v546; // r1
  int v547; // r4
  int v548; // r10
  int v549; // r7
  int v550; // r12
  int v551; // r0
  int v552; // r6
  int v553; // r2
  int v554; // r9
  int v555; // r5
  int v556; // r10
  int v557; // r3
  int v558; // r8
  int v559; // r4
  int v560; // r1
  int v561; // r7
  int v562; // r12
  int v563; // r0
  int v564; // r6
  int v565; // r9
  int v566; // r11
  int v567; // lr
  int v568; // r2
  int v569; // r10
  int v570; // r3
  int v571; // r1
  int v572; // r7
  int v573; // r6
  int v574; // r8
  int v575; // r0
  int v576; // r12
  int v577; // lr
  int v578; // r4
  int v579; // r2
  int v580; // r5
  int v581; // r11
  int v582; // r10
  int v583; // r7
  int v584; // r3
  int v585; // r1
  int v586; // r9
  int v587; // r12
  int v588; // r2
  int v589; // r8
  int v590; // r11
  int v591; // r0
  int v592; // lr
  int v593; // r10
  int v594; // r4
  int v595; // r5
  int v596; // r3
  int v597; // r8
  int v598; // r1
  int v599; // r4
  int v600; // r6
  int v601; // r11
  int v602; // r0
  int v603; // r12
  int v604; // r5
  int v605; // r9
  int v606; // lr
  int v607; // r2
  int v608; // r8
  int v609; // r4
  int v610; // r10
  int v611; // r1
  int v612; // r3
  int v613; // r6
  int v614; // r7
  int v615; // r0
  int v616; // r8
  int v617; // lr
  int v618; // r12
  int v619; // r11
  int v620; // r4
  int v621; // r8
  int v622; // r2
  int v623; // r10
  int v624; // r3
  int v625; // r1
  int v626; // r5
  unsigned int v627; // r6
  int v628; // r0
  int v629; // r4
  int v630; // r7
  int v631; // r9
  int v632; // r12
  int v633; // lr
  int v634; // r11
  int v635; // r10
  int v636; // r2
  int v637; // r2
  int v638; // r3
  int v639; // r1
  int v640; // r6
  int v641; // r7
  int v642; // r5
  int v643; // r8
  int v644; // r12
  int v645; // r0
  int v646; // r8
  int v647; // r4
  int v648; // lr
  int v649; // r11
  int v650; // r2
  int v651; // r10
  int v652; // r9
  int v653; // r1
  int v654; // r3
  int v655; // r5
  int v656; // r6
  int v657; // lr
  int v658; // r7
  int v659; // r11
  int v660; // r9
  int v661; // r8
  int v662; // r12
  int v663; // r4
  int v664; // r10
  int v665; // r2
  int v666; // r1
  int v667; // r3
  int v668; // r5
  int v669; // r6
  int v670; // lr
  int v671; // r7
  int v672; // r11
  int v673; // r2
  int v674; // r12
  int v675; // r8
  int v676; // r4
  int v677; // r0
  int v678; // r11
  int v679; // r1
  int v680; // r9
  int v681; // r10
  int v682; // r2
  int v683; // r5
  int v684; // r7
  int v685; // r0
  int v686; // r4
  int v687; // r8
  int v688; // r6
  int v689; // lr
  int v690; // r12
  int v691; // r11
  int v692; // r2
  int v693; // r3
  int v694; // r9
  int v695; // r1
  int v696; // r6
  int v697; // r7
  int v698; // r12
  int v699; // r4
  int v700; // r5
  int v701; // r8
  int v702; // r0
  int v703; // lr
  int v704; // r11
  int v705; // r2
  int v706; // r3
  int v707; // r9
  int v708; // r1
  int v709; // r6
  int v710; // r7
  int v711; // r0
  int v712; // r5
  int v713; // r12
  int v714; // lr
  int v715; // r8
  int v716; // r4
  int v717; // r10
  int v718; // r3
  int v719; // r9
  int v720; // r1
  int v721; // r2
  int v722; // r8
  int v723; // r11
  int v724; // r4
  int v725; // r2
  size_t n; // [sp+4h] [bp-1E8h]
  int v729; // [sp+8h] [bp-1E4h]
  int v730; // [sp+8h] [bp-1E4h]
  int v731; // [sp+8h] [bp-1E4h]
  int v732; // [sp+8h] [bp-1E4h]
  int v733; // [sp+8h] [bp-1E4h]
  int v734; // [sp+8h] [bp-1E4h]
  int v735; // [sp+8h] [bp-1E4h]
  int v736; // [sp+8h] [bp-1E4h]
  int v737; // [sp+8h] [bp-1E4h]
  int v738; // [sp+8h] [bp-1E4h]
  int v739; // [sp+8h] [bp-1E4h]
  int v740; // [sp+8h] [bp-1E4h]
  int v741; // [sp+8h] [bp-1E4h]
  int v742; // [sp+8h] [bp-1E4h]
  int v743; // [sp+8h] [bp-1E4h]
  int v744; // [sp+8h] [bp-1E4h]
  int v745; // [sp+8h] [bp-1E4h]
  int v746; // [sp+14h] [bp-1D8h]
  int v747; // [sp+14h] [bp-1D8h]
  int v748; // [sp+14h] [bp-1D8h]
  int v749; // [sp+14h] [bp-1D8h]
  int v750; // [sp+14h] [bp-1D8h]
  int v751; // [sp+14h] [bp-1D8h]
  int v752; // [sp+14h] [bp-1D8h]
  int v753; // [sp+14h] [bp-1D8h]
  int v754; // [sp+14h] [bp-1D8h]
  int v755; // [sp+14h] [bp-1D8h]
  int v756; // [sp+14h] [bp-1D8h]
  int v757; // [sp+14h] [bp-1D8h]
  int v758; // [sp+14h] [bp-1D8h]
  int v759; // [sp+14h] [bp-1D8h]
  int v760; // [sp+14h] [bp-1D8h]
  int v761; // [sp+14h] [bp-1D8h]
  int v762; // [sp+14h] [bp-1D8h]
  int v763; // [sp+14h] [bp-1D8h]
  int v764; // [sp+18h] [bp-1D4h]
  int v765; // [sp+18h] [bp-1D4h]
  int v766; // [sp+18h] [bp-1D4h]
  int v767; // [sp+18h] [bp-1D4h]
  int v768; // [sp+18h] [bp-1D4h]
  int v769; // [sp+18h] [bp-1D4h]
  int v770; // [sp+18h] [bp-1D4h]
  int v771; // [sp+18h] [bp-1D4h]
  int v772; // [sp+18h] [bp-1D4h]
  int v773; // [sp+18h] [bp-1D4h]
  int v774; // [sp+18h] [bp-1D4h]
  int v775; // [sp+20h] [bp-1CCh]
  unsigned int v776; // [sp+20h] [bp-1CCh]
  int v777; // [sp+20h] [bp-1CCh]
  int v778; // [sp+20h] [bp-1CCh]
  int v779; // [sp+20h] [bp-1CCh]
  int v780; // [sp+20h] [bp-1CCh]
  int v781; // [sp+20h] [bp-1CCh]
  int v782; // [sp+20h] [bp-1CCh]
  int v783; // [sp+20h] [bp-1CCh]
  int v784; // [sp+20h] [bp-1CCh]
  int v785; // [sp+20h] [bp-1CCh]
  int v786; // [sp+20h] [bp-1CCh]
  int v787; // [sp+24h] [bp-1C8h]
  unsigned int v788; // [sp+24h] [bp-1C8h]
  int v789; // [sp+24h] [bp-1C8h]
  int v790; // [sp+24h] [bp-1C8h]
  int v791; // [sp+24h] [bp-1C8h]
  unsigned int v792; // [sp+28h] [bp-1C4h]
  int v793; // [sp+28h] [bp-1C4h]
  unsigned int v794; // [sp+2Ch] [bp-1C0h]
  int v795; // [sp+2Ch] [bp-1C0h]
  int v796; // [sp+2Ch] [bp-1C0h]
  unsigned int v797; // [sp+30h] [bp-1BCh]
  int v798; // [sp+38h] [bp-1B4h]
  unsigned int v799; // [sp+38h] [bp-1B4h]
  int v800; // [sp+38h] [bp-1B4h]
  int v801; // [sp+38h] [bp-1B4h]
  int v802; // [sp+38h] [bp-1B4h]
  unsigned int v803; // [sp+3Ch] [bp-1B0h]
  int v804; // [sp+3Ch] [bp-1B0h]
  unsigned int v805; // [sp+40h] [bp-1ACh]
  int v806; // [sp+40h] [bp-1ACh]
  int v807; // [sp+40h] [bp-1ACh]
  int v808; // [sp+40h] [bp-1ACh]
  int v809; // [sp+44h] [bp-1A8h]
  unsigned int v810; // [sp+44h] [bp-1A8h]
  int v811; // [sp+44h] [bp-1A8h]
  int v812; // [sp+44h] [bp-1A8h]
  int v813; // [sp+44h] [bp-1A8h]
  unsigned int v814; // [sp+48h] [bp-1A4h]
  int v815; // [sp+48h] [bp-1A4h]
  int v816; // [sp+48h] [bp-1A4h]
  int v817; // [sp+48h] [bp-1A4h]
  int v818; // [sp+48h] [bp-1A4h]
  int v819; // [sp+48h] [bp-1A4h]
  int v820; // [sp+54h] [bp-198h]
  int v821; // [sp+54h] [bp-198h]
  int v822; // [sp+54h] [bp-198h]
  int v823; // [sp+54h] [bp-198h]
  int v824; // [sp+54h] [bp-198h]
  int v825; // [sp+58h] [bp-194h]
  int v826; // [sp+5Ch] [bp-190h]
  int v827; // [sp+5Ch] [bp-190h]
  unsigned int v828; // [sp+60h] [bp-18Ch]
  unsigned int v829; // [sp+64h] [bp-188h]
  int v830; // [sp+64h] [bp-188h]
  int v831; // [sp+64h] [bp-188h]
  unsigned int v832; // [sp+68h] [bp-184h]
  unsigned int v833; // [sp+6Ch] [bp-180h]
  int v834; // [sp+70h] [bp-17Ch]
  int v835; // [sp+70h] [bp-17Ch]
  int v836; // [sp+70h] [bp-17Ch]
  int v837; // [sp+70h] [bp-17Ch]
  int v838; // [sp+70h] [bp-17Ch]
  int v839; // [sp+70h] [bp-17Ch]
  int v840; // [sp+70h] [bp-17Ch]
  int v841; // [sp+74h] [bp-178h]
  int v842; // [sp+74h] [bp-178h]
  int v843; // [sp+74h] [bp-178h]
  int v844; // [sp+74h] [bp-178h]
  int v845; // [sp+74h] [bp-178h]
  int v846; // [sp+74h] [bp-178h]
  int v847; // [sp+74h] [bp-178h]
  int v848; // [sp+74h] [bp-178h]
  char *src; // [sp+7Ch] [bp-170h]
  unsigned int v850; // [sp+80h] [bp-16Ch]
  unsigned int v851; // [sp+84h] [bp-168h]
  int v852; // [sp+84h] [bp-168h]
  int v853; // [sp+88h] [bp-164h]
  int v854; // [sp+88h] [bp-164h]
  int v855; // [sp+88h] [bp-164h]
  unsigned int v856; // [sp+88h] [bp-164h]
  unsigned int v857; // [sp+8Ch] [bp-160h]
  unsigned int v858; // [sp+90h] [bp-15Ch]
  unsigned int v859; // [sp+94h] [bp-158h]
  unsigned int v860; // [sp+98h] [bp-154h]
  unsigned int v861; // [sp+9Ch] [bp-150h]
  unsigned int v862; // [sp+A0h] [bp-14Ch]
  unsigned int v863; // [sp+A4h] [bp-148h]
  unsigned int v864; // [sp+A8h] [bp-144h]
  unsigned int v865; // [sp+ACh] [bp-140h]
  unsigned int v866; // [sp+B0h] [bp-13Ch]
  unsigned int v867; // [sp+B4h] [bp-138h]
  size_t v868; // [sp+B8h] [bp-134h]
  unsigned int v869; // [sp+BCh] [bp-130h]
  int v870; // [sp+C0h] [bp-12Ch]
  int v871; // [sp+C0h] [bp-12Ch]
  unsigned int v872; // [sp+C0h] [bp-12Ch]
  int v873; // [sp+C4h] [bp-128h]
  int v874; // [sp+C4h] [bp-128h]
  int v875; // [sp+C4h] [bp-128h]
  int v876; // [sp+C4h] [bp-128h]
  int v877; // [sp+C8h] [bp-124h]
  int v878; // [sp+C8h] [bp-124h]
  int v879; // [sp+C8h] [bp-124h]
  int v880; // [sp+C8h] [bp-124h]
  int v881; // [sp+C8h] [bp-124h]
  int v882; // [sp+C8h] [bp-124h]
  int v883; // [sp+C8h] [bp-124h]
  int v884; // [sp+C8h] [bp-124h]
  int v885; // [sp+C8h] [bp-124h]
  int v886; // [sp+C8h] [bp-124h]
  int v887; // [sp+C8h] [bp-124h]
  int v888; // [sp+C8h] [bp-124h]
  int v889; // [sp+C8h] [bp-124h]
  int v890; // [sp+C8h] [bp-124h]
  int v891; // [sp+C8h] [bp-124h]
  int v892; // [sp+C8h] [bp-124h]
  int v893; // [sp+CCh] [bp-120h]
  int v894; // [sp+CCh] [bp-120h]
  int v895; // [sp+CCh] [bp-120h]
  int v896; // [sp+CCh] [bp-120h]
  int v897; // [sp+CCh] [bp-120h]
  int v898; // [sp+CCh] [bp-120h]
  int v899; // [sp+CCh] [bp-120h]
  int v900; // [sp+CCh] [bp-120h]
  int v901; // [sp+CCh] [bp-120h]
  int v902; // [sp+CCh] [bp-120h]
  int v903; // [sp+CCh] [bp-120h]
  int v904; // [sp+CCh] [bp-120h]
  int v905; // [sp+CCh] [bp-120h]
  int v906; // [sp+CCh] [bp-120h]
  int v907; // [sp+CCh] [bp-120h]
  int v908; // [sp+CCh] [bp-120h]
  int v909; // [sp+D0h] [bp-11Ch]
  int v910; // [sp+D0h] [bp-11Ch]
  int v911; // [sp+D0h] [bp-11Ch]
  int v912; // [sp+D0h] [bp-11Ch]
  int v913; // [sp+D0h] [bp-11Ch]
  int v914; // [sp+D0h] [bp-11Ch]
  int v915; // [sp+D0h] [bp-11Ch]
  int v916; // [sp+D0h] [bp-11Ch]
  int v917; // [sp+D0h] [bp-11Ch]
  int v918; // [sp+D0h] [bp-11Ch]
  int v919; // [sp+D0h] [bp-11Ch]
  int v920; // [sp+D0h] [bp-11Ch]
  int v921; // [sp+D0h] [bp-11Ch]
  int v922; // [sp+D0h] [bp-11Ch]
  int v923; // [sp+D0h] [bp-11Ch]
  int v924; // [sp+D0h] [bp-11Ch]
  int v925; // [sp+D0h] [bp-11Ch]
  int v926; // [sp+D0h] [bp-11Ch]
  int v927; // [sp+D0h] [bp-11Ch]
  int v928; // [sp+D0h] [bp-11Ch]
  int v929; // [sp+D0h] [bp-11Ch]
  int v930; // [sp+D0h] [bp-11Ch]
  int v931; // [sp+D4h] [bp-118h]
  int v932; // [sp+D4h] [bp-118h]
  int v933; // [sp+D4h] [bp-118h]
  int v934; // [sp+D4h] [bp-118h]
  int v935; // [sp+D4h] [bp-118h]
  int v936; // [sp+D4h] [bp-118h]
  int v937; // [sp+D4h] [bp-118h]
  int v938; // [sp+D4h] [bp-118h]
  int v939; // [sp+D4h] [bp-118h]
  int v940; // [sp+D4h] [bp-118h]
  int v941; // [sp+D4h] [bp-118h]
  int v942; // [sp+D4h] [bp-118h]
  int v943; // [sp+D4h] [bp-118h]
  int v944; // [sp+D4h] [bp-118h]
  int v945; // [sp+D8h] [bp-114h]
  int v946; // [sp+D8h] [bp-114h]
  int v947; // [sp+D8h] [bp-114h]
  int v948; // [sp+D8h] [bp-114h]
  int v949; // [sp+D8h] [bp-114h]
  int v950; // [sp+D8h] [bp-114h]
  int v951; // [sp+D8h] [bp-114h]
  int v952; // [sp+D8h] [bp-114h]
  int v953; // [sp+D8h] [bp-114h]
  int v954; // [sp+D8h] [bp-114h]
  int v955; // [sp+DCh] [bp-110h]
  int v956; // [sp+DCh] [bp-110h]
  int v957; // [sp+DCh] [bp-110h]
  int v958; // [sp+DCh] [bp-110h]
  int v959; // [sp+DCh] [bp-110h]
  int v960; // [sp+DCh] [bp-110h]
  int v961; // [sp+DCh] [bp-110h]
  unsigned int v962; // [sp+E0h] [bp-10Ch]
  unsigned int v963; // [sp+E4h] [bp-108h]
  unsigned int v964; // [sp+E8h] [bp-104h]
  int v965; // [sp+ECh] [bp-100h]
  unsigned int v966; // [sp+F0h] [bp-FCh]
  int v967; // [sp+F8h] [bp-F4h]
  int v968; // [sp+FCh] [bp-F0h]
  int v969; // [sp+100h] [bp-ECh]
  unsigned int v970; // [sp+104h] [bp-E8h]
  int v971; // [sp+10Ch] [bp-E0h]
  int v972; // [sp+110h] [bp-DCh]
  unsigned int v973; // [sp+114h] [bp-D8h]
  int v974; // [sp+118h] [bp-D4h]
  unsigned int v975; // [sp+11Ch] [bp-D0h]
  int v976; // [sp+120h] [bp-CCh]
  unsigned int v977; // [sp+128h] [bp-C4h]
  int v978; // [sp+12Ch] [bp-C0h]
  int v979; // [sp+130h] [bp-BCh]
  int v980; // [sp+134h] [bp-B8h]
  int v981; // [sp+140h] [bp-ACh]
  int v982; // [sp+144h] [bp-A8h]
  unsigned int v983; // [sp+148h] [bp-A4h]
  int v984; // [sp+14Ch] [bp-A0h]
  int v985; // [sp+150h] [bp-9Ch]
  int v986; // [sp+154h] [bp-98h]
  unsigned int v987; // [sp+158h] [bp-94h]
  int v988; // [sp+15Ch] [bp-90h]
  int v989; // [sp+160h] [bp-8Ch]
  int v990; // [sp+164h] [bp-88h]
  unsigned int v991; // [sp+16Ch] [bp-80h]
  unsigned int v992; // [sp+170h] [bp-7Ch]
  int v993; // [sp+174h] [bp-78h]
  int v994; // [sp+178h] [bp-74h]
  int v995; // [sp+17Ch] [bp-70h]
  int v996; // [sp+180h] [bp-6Ch]
  int v997; // [sp+180h] [bp-6Ch]
  int v998; // [sp+184h] [bp-68h]
  unsigned int v999; // [sp+184h] [bp-68h]
  unsigned int v1000; // [sp+188h] [bp-64h]
  int v1001; // [sp+18Ch] [bp-60h]
  int v1002; // [sp+190h] [bp-5Ch]
  unsigned int v1003; // [sp+194h] [bp-58h]
  int v1004; // [sp+198h] [bp-54h]
  int v1005; // [sp+19Ch] [bp-50h]
  unsigned int v1006; // [sp+1A0h] [bp-4Ch]
  int v1007; // [sp+1A4h] [bp-48h]
  unsigned int v1008; // [sp+1ACh] [bp-40h]
  int v1009; // [sp+1B0h] [bp-3Ch]
  unsigned int v1010; // [sp+1C4h] [bp-28h]
  unsigned int v1011; // [sp+1C8h] [bp-24h]
  unsigned int v1012; // [sp+1D0h] [bp-1Ch]
  int v1013; // [sp+1D4h] [bp-18h]
  int v1014; // [sp+1D8h] [bp-14h]
  int v1015; // [sp+1DCh] [bp-10h]
  int v1016; // [sp+1E0h] [bp-Ch]

  v3 = a1[16];
  v4 = 64 - v3;
  n = a3;
  src = a2;
  if ( 64 - v3 > a3 )
  {
    result = (unsigned int)memcpy((char *)a1 + v3, a2, a3);
    a1[16] = v3 + n;
  }
  else
  {
    v5 = a1[25];
    result = a1[27];
    v862 = a1[17];
    v991 = a1[25];
    v992 = a1[27];
    v861 = a1[18];
    v867 = a1[19];
    v866 = a1[20];
    v860 = a1[21];
    v859 = a1[22];
    v858 = a1[23];
    v857 = a1[24];
    v864 = a1[26];
    v865 = a1[28];
    v863 = a1[29];
    v868 = a1[30];
    if ( a3 )
    {
      v1005 = v5 ^ 0x243F6A88;
      v1006 = result ^ 0x13198A2E;
      while ( 1 )
      {
        if ( v4 >= n )
          v4 = n;
        v7 = (char *)a1 + v3;
        v3 += v4;
        result = (unsigned int)memcpy(v7, src, v4);
        n -= v4;
        src += v4;
        if ( v3 == 64 )
        {
          v8 = __CFADD__(v863, 512);
          v863 += 512;
          if ( v8 )
            ++v868;
          v9 = bswap32(a1[6]);
          v1000 = v9 ^ 0xEC4E6C89;
          v10 = v866 + v857 + (v9 ^ 0xEC4E6C89);
          v11 = bswap32(a1[4]);
          v1007 = v11 ^ 0x299F31D0;
          v12 = __ROR4__(v868 ^ 0xEC4E6C89 ^ v10, 16);
          v814 = bswap32(a1[2]);
          v968 = v814 ^ 0x3707344;
          v13 = v867 + v858 + (v11 ^ 0x299F31D0);
          v851 = v9;
          v805 = v11;
          v797 = bswap32(*a1);
          v14 = __ROR4__(v868 ^ 0x82EFA98 ^ v13, 16);
          v15 = v862 + v860 + (v797 ^ 0x85A308D3);
          v16 = __ROR4__(v863 ^ 0xA4093822 ^ v15, 16);
          v17 = __ROR4__(v863 ^ 0x299F31D0 ^ (v861 + v859 + (v814 ^ 0x3707344)), 16);
          v18 = (v864 ^ 0x85A308D3) + v17;
          v809 = (v865 ^ 0x3707344) + v12;
          v833 = bswap32(a1[7]);
          v19 = __ROR4__(v809 ^ v857, 12);
          v20 = v1005 + v16;
          v21 = v1006 + v14;
          v1001 = v833 ^ 0x82EFA98;
          v22 = __ROR4__(v18 ^ v859, 12);
          v803 = bswap32(a1[5]);
          v792 = bswap32(a1[3]);
          v794 = bswap32(a1[1]);
          v23 = (v833 ^ 0x82EFA98) + v10;
          v24 = __ROR4__((v1005 + v16) ^ v860, 12);
          v729 = __ROR4__((v1006 + v14) ^ v858, 12);
          v775 = v19 + v23;
          v970 = v803 ^ 0xA4093822;
          v969 = v792 ^ 0x13198A2E;
          v967 = v794 ^ 0x243F6A88;
          v787 = __ROR4__(v12 ^ (v19 + v23), 8);
          v798 = v22 + (v792 ^ 0x13198A2E) + v861 + v859 + (v814 ^ 0x3707344);
          v25 = v24 + (v794 ^ 0x243F6A88) + v15;
          v26 = __ROR4__(v17 ^ v798, 8);
          v27 = v729 + (v803 ^ 0xA4093822) + v13;
          v28 = v18 + v26;
          v29 = __ROR4__(v16 ^ v25, 8);
          v30 = __ROR4__(v14 ^ v27, 8);
          v31 = v20 + v29;
          v32 = v21 + v30;
          v33 = __ROR4__(v24 ^ v31, 7);
          v34 = __ROR4__(v22 ^ v28, 7);
          v820 = v809 + v787;
          v35 = __ROR4__(v19 ^ (v809 + v787), 7);
          v850 = bswap32(a1[12]);
          v962 = v850 ^ 0xC97C50DD;
          v36 = v35 + (v850 ^ 0xC97C50DD) + v27;
          v829 = bswap32(a1[14]);
          v37 = __ROR4__(v729 ^ v32, 7);
          v832 = bswap32(a1[8]);
          v810 = bswap32(a1[10]);
          v869 = v829 ^ 0xB5470917;
          v972 = v810 ^ 0x34E90C6C;
          v877 = __ROR4__(v26 ^ v36, 16);
          v38 = v34 + (v832 ^ 0x38D01377) + v25;
          v39 = v37 + (v810 ^ 0x34E90C6C) + v798;
          v909 = v33 + (v829 ^ 0xB5470917) + v775;
          v40 = __ROR4__(v30 ^ v909, 16);
          v873 = __ROR4__(v29 ^ v39, 16);
          v828 = bswap32(a1[13]);
          v41 = __ROR4__(v787 ^ v38, 16);
          v931 = v28 + v40;
          v870 = v32 + v41;
          v42 = __ROR4__(v35 ^ (v31 + v877), 12);
          v963 = v828 ^ 0xC0AC29B7;
          v776 = bswap32(a1[15]);
          v43 = __ROR4__(v33 ^ (v28 + v40), 12);
          v44 = __ROR4__(v34 ^ (v32 + v41), 12);
          v799 = bswap32(a1[9]);
          v788 = bswap32(a1[11]);
          v45 = __ROR4__(v37 ^ (v820 + v873), 12);
          v46 = v42 + (v828 ^ 0xC0AC29B7) + v36;
          v974 = v776 ^ 0x3F84D5B5;
          v971 = v799 ^ 0x452821E6;
          v47 = __ROR4__(v877 ^ v46, 8);
          v973 = v788 ^ 0xBE5466CF;
          v48 = v43 + (v776 ^ 0x3F84D5B5) + v909;
          v49 = __ROR4__(v40 ^ v48, 8);
          v50 = v44 + (v799 ^ 0x452821E6) + v38;
          v51 = v45 + (v788 ^ 0xBE5466CF) + v39;
          v52 = __ROR4__(v41 ^ v50, 8);
          v53 = __ROR4__(v873 ^ v51, 8);
          v910 = v31 + v877 + v47;
          v54 = v820 + v873 + v53;
          v55 = __ROR4__(v42 ^ v910, 7);
          v874 = v931 + v49;
          v56 = v55 + (v828 ^ 0x82EFA98) + v48;
          v57 = v870 + v52;
          v58 = __ROR4__(v52 ^ v56, 16);
          v878 = __ROR4__(v43 ^ (v931 + v49), 7);
          v59 = __ROR4__(v44 ^ v57, 7);
          v60 = __ROR4__(v45 ^ v54, 7);
          v975 = v799 ^ 0xB5470917;
          v1002 = v805 ^ 0x452821E6;
          v61 = v59 + (v805 ^ 0x452821E6) + v51;
          v964 = v829 ^ 0xBE5466CF;
          v932 = v878 + (v829 ^ 0xBE5466CF) + v50;
          v62 = v54 + v58;
          v63 = __ROR4__(v47 ^ v61, 16);
          v64 = __ROR4__(v55 ^ v62, 12);
          v65 = v60 + (v799 ^ 0xB5470917) + v46;
          v1008 = v851 ^ 0xC97C50DD;
          v66 = v874;
          v875 = __ROR4__(v53 ^ v932, 16);
          v893 = v64 + (v851 ^ 0xC97C50DD) + v56;
          v871 = v66 + v63;
          v67 = __ROR4__(v49 ^ v65, 16);
          v68 = v57 + v67;
          v69 = __ROR4__(v60 ^ v68, 12);
          v911 = v910 + v875;
          v70 = __ROR4__(v59 ^ (v66 + v63), 12);
          v976 = v776 ^ 0x38D01377;
          v71 = __ROR4__(v878 ^ v911, 12);
          v966 = v832 ^ 0xA4093822;
          v72 = __ROR4__(v58 ^ v893, 8);
          v73 = v69 + (v776 ^ 0x38D01377) + v65;
          v74 = __ROR4__(v67 ^ v73, 8);
          v965 = v810 ^ 0x3F84D5B5;
          v75 = v70 + (v832 ^ 0xA4093822) + v61;
          v76 = (v810 ^ 0x3F84D5B5) + v932;
          v933 = v62 + v72;
          v77 = __ROR4__(v63 ^ v75, 8);
          v879 = v68 + v74;
          v78 = v71 + v76;
          v79 = __ROR4__(v875 ^ v78, 8);
          v80 = __ROR4__(v64 ^ (v62 + v72), 7);
          v81 = v871 + v77;
          v977 = v788 ^ 0xEC4E6C89;
          v82 = __ROR4__(v70 ^ (v871 + v77), 7);
          v876 = __ROR4__(v71 ^ (v911 + v79), 7);
          v83 = __ROR4__(v69 ^ (v68 + v74), 7);
          v84 = v80 + (v788 ^ 0xEC4E6C89) + v73;
          v978 = v803 ^ 0x3707344;
          v85 = __ROR4__(v77 ^ v84, 16);
          v86 = v911 + v79 + v85;
          v872 = v794 ^ 0xC0AC29B7;
          v912 = __ROR4__(v80 ^ v86, 12);
          v87 = v82 + (v794 ^ 0xC0AC29B7) + v78;
          v88 = v83 + (v797 ^ 0x13198A2E) + v75;
          v89 = v876 + (v803 ^ 0x3707344) + v893;
          v894 = __ROR4__(v72 ^ v87, 16);
          v90 = __ROR4__(v79 ^ v88, 16);
          v91 = __ROR4__(v74 ^ v89, 16);
          v92 = v81 + v91;
          v93 = v879 + v894;
          v94 = __ROR4__(v876 ^ v92, 12);
          v95 = __ROR4__(v82 ^ (v879 + v894), 12);
          v880 = v933 + v90;
          v934 = v93;
          v96 = __ROR4__(v83 ^ v880, 12);
          v97 = v912 + (v833 ^ 0x34E90C6C) + v84;
          v98 = __ROR4__(v85 ^ v97, 8);
          v979 = v792 ^ 0x299F31D0;
          v945 = v86 + v98;
          v1009 = v814 ^ 0x243F6A88;
          v99 = v96 + (v814 ^ 0x243F6A88) + v88;
          v100 = v94 + (v792 ^ 0x299F31D0) + v89;
          v101 = __ROR4__(v90 ^ v99, 8);
          v102 = __ROR4__(v91 ^ v100, 8);
          v103 = v912;
          v104 = v95 + (v850 ^ 0x85A308D3) + v87;
          v913 = v92 + v102;
          v105 = __ROR4__(v894 ^ v104, 8);
          v106 = __ROR4__(v103 ^ (v86 + v98), 7);
          v983 = v776 ^ 0xC97C50DD;
          v107 = v934 + v105;
          v108 = __ROR4__(v95 ^ (v934 + v105), 7);
          v109 = v880 + v101;
          v881 = __ROR4__(v96 ^ (v880 + v101), 7);
          v110 = __ROR4__(v94 ^ v913, 7);
          v111 = v106 + (v776 ^ 0xC97C50DD) + v100;
          v981 = v803 ^ 0x13198A2E;
          v112 = __ROR4__(v105 ^ v111, 16);
          v113 = v109 + v112;
          v114 = __ROR4__(v106 ^ v113, 12);
          v980 = v788 ^ 0x452821E6;
          v935 = v110 + (v788 ^ 0x452821E6) + v104;
          v115 = v881 + (v803 ^ 0x13198A2E) + v97;
          v116 = v108 + (v850 ^ 0x243F6A88) + v99;
          v117 = __ROR4__(v98 ^ v116, 16);
          v895 = __ROR4__(v102 ^ v115, 16);
          v118 = v114 + (v828 ^ 0xB5470917) + v111;
          v119 = v107 + v895;
          v120 = v913;
          v914 = __ROR4__(v101 ^ v935, 16);
          v121 = __ROR4__(v112 ^ v118, 8);
          v122 = v113 + v121;
          v955 = v120 + v117;
          v123 = __ROR4__(v114 ^ v122, 7);
          v124 = __ROR4__(v108 ^ (v120 + v117), 12);
          v125 = v110 ^ (v945 + v914);
          v946 = v945 + v914;
          v126 = __ROR4__(v881 ^ v119, 12);
          v982 = v814 ^ 0x299F31D0;
          v127 = v124 + (v797 ^ 0xC0AC29B7) + v116;
          v128 = __ROR4__(v125, 12);
          v129 = __ROR4__(v117 ^ v127, 8);
          v130 = v128 + (v832 ^ 0x34E90C6C) + v935;
          v131 = v126 + (v814 ^ 0x299F31D0) + v115;
          v132 = __ROR4__(v914 ^ v130, 8);
          v133 = __ROR4__(v895 ^ v131, 8);
          v134 = v119 + v133;
          v896 = v955 + v129;
          v135 = __ROR4__(v126 ^ v134, 7);
          v136 = __ROR4__(v128 ^ (v946 + v132), 7);
          v137 = __ROR4__(v124 ^ (v955 + v129), 7);
          v936 = v123 + (v833 ^ 0x85A308D3) + v131;
          v1011 = v799 ^ 0xA4093822;
          v138 = v136 + (v799 ^ 0xA4093822) + v118;
          v984 = v792 ^ 0x82EFA98;
          v139 = v135 + (v792 ^ 0x82EFA98) + v127;
          v140 = __ROR4__(v133 ^ v138, 16);
          v141 = __ROR4__(v129 ^ v936, 16);
          v947 = v946 + v132 + v141;
          v142 = v137 + (v810 ^ 0x3F84D5B5) + v130;
          v882 = __ROR4__(v132 ^ v139, 16);
          v143 = __ROR4__(v123 ^ v947, 12);
          v1010 = v794 ^ 0xEC4E6C89;
          v144 = __ROR4__(v121 ^ v142, 16);
          v915 = v896 + v140;
          v145 = v134 + v144;
          v146 = __ROR4__(v137 ^ v145, 12);
          v147 = __ROR4__(v135 ^ (v122 + v882), 12);
          v148 = v896 + v140;
          v897 = v143 + (v794 ^ 0xEC4E6C89) + v936;
          v149 = __ROR4__(v136 ^ v148, 12);
          v986 = v805 ^ 0x38D01377;
          v985 = v851 ^ 0x3707344;
          v937 = v146 + (v829 ^ 0xBE5466CF) + v142;
          v150 = __ROR4__(v141 ^ v897, 8);
          v151 = __ROR4__(v144 ^ v937, 8);
          v152 = v149 + (v805 ^ 0x38D01377) + v138;
          v153 = v147 + (v851 ^ 0x3707344) + v139;
          v154 = v145 + v151;
          v155 = __ROR4__(v140 ^ v152, 8);
          v948 = v947 + v150;
          v156 = __ROR4__(v882 ^ v153, 8);
          v157 = __ROR4__(v143 ^ v948, 7);
          v916 = v915 + v155;
          v158 = __ROR4__(v146 ^ v154, 7);
          v1013 = v788 ^ 0x3F84D5B5;
          v159 = v157 + (v788 ^ 0x3F84D5B5) + v152;
          v160 = v122 + v882 + v156;
          v161 = __ROR4__(v147 ^ v160, 7);
          v162 = __ROR4__(v149 ^ v916, 7);
          v987 = v792 ^ 0x85A308D3;
          v163 = __ROR4__(v151 ^ v159, 16);
          v164 = v161 + (v828 ^ 0xC0AC29B7) + v897;
          v165 = __ROR4__(v155 ^ v164, 16);
          v166 = v158 + (v792 ^ 0x85A308D3) + v153;
          v167 = __ROR4__(v150 ^ v166, 16);
          v938 = v162 + (v833 ^ 0x38D01377) + v937;
          v956 = v160 + v163;
          v168 = v154 + v165;
          v169 = __ROR4__(v156 ^ v938, 16);
          v170 = __ROR4__(v157 ^ v956, 12);
          v171 = __ROR4__(v161 ^ (v154 + v165), 12);
          v1014 = v829 ^ 0x34E90C6C;
          v172 = v170 + (v829 ^ 0x34E90C6C) + v159;
          v173 = __ROR4__(v163 ^ v172, 8);
          v898 = v916 + v167;
          v883 = v948 + v169;
          v174 = __ROR4__(v158 ^ (v916 + v167), 12);
          v175 = __ROR4__(v162 ^ (v948 + v169), 12);
          v988 = v794 ^ 0x3707344;
          v1012 = v799 ^ 0xEC4E6C89;
          v176 = v171 + (v850 ^ 0xC97C50DD) + v164;
          v177 = v174 + (v794 ^ 0x3707344) + v166;
          v178 = __ROR4__(v167 ^ v177, 8);
          v179 = __ROR4__(v165 ^ v176, 8);
          v180 = v175 + (v799 ^ 0xEC4E6C89) + v938;
          v181 = v168 + v179;
          v182 = __ROR4__(v169 ^ v180, 8);
          v949 = v956 + v173;
          v183 = __ROR4__(v171 ^ v181, 7);
          v184 = __ROR4__(v170 ^ (v956 + v173), 7);
          v1016 = v805 ^ 0x243F6A88;
          v185 = v184 + (v805 ^ 0x243F6A88) + v176;
          v899 = v898 + v178;
          v186 = __ROR4__(v178 ^ v185, 16);
          v884 = v883 + v182;
          v917 = __ROR4__(v174 ^ v899, 7);
          v187 = __ROR4__(v175 ^ v884, 7);
          v990 = v776 ^ 0x452821E6;
          v1015 = v814 ^ 0x82EFA98;
          v1003 = v803 ^ 0xBE5466CF;
          v188 = v183 + (v803 ^ 0xBE5466CF) + v177;
          v189 = v917 + (v814 ^ 0x82EFA98) + v180;
          v190 = v187 + (v776 ^ 0x452821E6) + v172;
          v939 = __ROR4__(v182 ^ v188, 16);
          v191 = __ROR4__(v173 ^ v189, 16);
          v192 = v884 + v186;
          v193 = v899;
          v194 = __ROR4__(v184 ^ (v884 + v186), 12);
          v885 = v181 + v191;
          v900 = __ROR4__(v179 ^ v190, 16);
          v195 = v194 + (v797 ^ 0xA4093822) + v185;
          v196 = v193 + v900;
          v197 = __ROR4__(v187 ^ v196, 12);
          v993 = v196;
          v198 = v949 + v939;
          v199 = v183 ^ (v949 + v939);
          v200 = __ROR4__(v186 ^ v195, 8);
          v201 = __ROR4__(v917 ^ v885, 12);
          v950 = v195;
          v989 = v851 ^ 0x13198A2E;
          v202 = __ROR4__(v199, 12);
          v1004 = v810 ^ 0x299F31D0;
          v203 = v202 + (v810 ^ 0x299F31D0) + v188;
          v204 = __ROR4__(v939 ^ v203, 8);
          v205 = v197 + (v832 ^ 0xB5470917) + v190;
          v957 = v192 + v200;
          v206 = __ROR4__(v900 ^ v205, 8);
          v207 = v201 + (v851 ^ 0x13198A2E) + v189;
          v208 = __ROR4__(v194 ^ (v192 + v200), 7);
          v209 = __ROR4__(v191 ^ v207, 8);
          v918 = v993 + v206;
          v210 = v198 + v204;
          v211 = __ROR4__(v202 ^ v210, 7);
          v940 = v208 + (v810 ^ 0xB5470917) + v205;
          v886 = v885 + v209;
          v212 = __ROR4__(v197 ^ (v993 + v206), 7);
          v213 = v212 + (v799 ^ 0x243F6A88) + v207;
          v214 = __ROR4__(v201 ^ v886, 7);
          v215 = v211 + (v814 ^ 0xA4093822) + v950;
          v216 = __ROR4__(v204 ^ v213, 16);
          v217 = v214 + (v803 ^ 0xEC4E6C89) + v203;
          v218 = __ROR4__(v209 ^ v940, 16);
          v219 = __ROR4__(v200 ^ v217, 16);
          v994 = v210 + v218;
          v220 = __ROR4__(v208 ^ (v210 + v218), 12);
          v221 = __ROR4__(v206 ^ v215, 16);
          v919 = v918 + v219;
          v222 = v957;
          v958 = v886 + v221;
          v223 = __ROR4__(v211 ^ (v886 + v221), 12);
          v224 = v222 + v216;
          v225 = v220 + (v776 ^ 0xBE5466CF) + v940;
          v226 = __ROR4__(v212 ^ v224, 12);
          v227 = __ROR4__(v214 ^ v919, 12);
          v228 = v223 + (v805 ^ 0x13198A2E) + v215;
          v229 = __ROR4__(v221 ^ v228, 8);
          v230 = v226 + (v797 ^ 0x38D01377) + v213;
          v995 = __ROR4__(v218 ^ v225, 8);
          v231 = v227 + (v833 ^ 0x299F31D0) + v217;
          v232 = __ROR4__(v220 ^ (v994 + v995), 7);
          v233 = __ROR4__(v216 ^ v230, 8);
          v234 = __ROR4__(v219 ^ v231, 8);
          v235 = v224 + v233;
          v236 = __ROR4__(v223 ^ (v958 + v229), 7);
          v237 = __ROR4__(v226 ^ v235, 7);
          v238 = v232 + (v851 ^ 0x452821E6) + v228;
          v920 = v919 + v234;
          v239 = __ROR4__(v234 ^ v238, 16);
          v951 = v958 + v229;
          v240 = __ROR4__(v227 ^ v920, 7);
          v241 = v240 + (v829 ^ 0x85A308D3) + v230;
          v242 = v236 + (v788 ^ 0xC0AC29B7) + v231;
          v243 = __ROR4__(v995 ^ v241, 16);
          v244 = v237 + (v792 ^ 0xC97C50DD) + v225;
          v245 = __ROR4__(v233 ^ v242, 16);
          v998 = v235 + v239;
          v246 = __ROR4__(v229 ^ v244, 16);
          v247 = __ROR4__(v232 ^ (v235 + v239), 12);
          v959 = v920 + v246;
          v941 = v994 + v995 + v245;
          v921 = v951 + v243;
          v248 = v247 + (v832 ^ 0x82EFA98) + v238;
          v249 = __ROR4__(v237 ^ v959, 12);
          v250 = __ROR4__(v240 ^ (v951 + v243), 12);
          v251 = __ROR4__(v236 ^ v941, 12);
          v252 = v249 + (v828 ^ 0x3707344) + v244;
          v253 = v250 + (v794 ^ 0x3F84D5B5) + v241;
          v254 = __ROR4__(v239 ^ v248, 8);
          v255 = v251 + (v850 ^ 0x34E90C6C) + v242;
          v256 = __ROR4__(v246 ^ v252, 8);
          v257 = __ROR4__(v243 ^ v253, 8);
          v952 = __ROR4__(v245 ^ v255, 8);
          v996 = v998 + v254;
          v258 = __ROR4__(v247 ^ (v998 + v254), 7);
          v960 = v959 + v256;
          v259 = v258 + (v832 ^ 0x3707344) + v252;
          v901 = v921 + v257;
          v260 = v941 + v952;
          v261 = __ROR4__(v251 ^ (v941 + v952), 7);
          v262 = __ROR4__(v250 ^ (v921 + v257), 7);
          v942 = __ROR4__(v249 ^ v960, 7);
          v263 = v262 + (v851 ^ 0xBE5466CF) + v255;
          v264 = v261 + (v797 ^ 0x34E90C6C) + v248;
          v265 = __ROR4__(v254 ^ v263, 16);
          v999 = v814 ^ 0xC0AC29B7;
          v266 = v942 + (v814 ^ 0xC0AC29B7) + v253;
          v267 = __ROR4__(v257 ^ v259, 16);
          v268 = __ROR4__(v256 ^ v264, 16);
          v269 = __ROR4__(v952 ^ v266, 16);
          v270 = v260 + v267;
          v922 = __ROR4__(v258 ^ v270, 12);
          v953 = v960 + v265;
          v271 = __ROR4__(v262 ^ (v960 + v265), 12);
          v902 = v901 + v268;
          v841 = v996 + v269;
          v272 = __ROR4__(v261 ^ v902, 12);
          v273 = __ROR4__(v942 ^ (v996 + v269), 12);
          v943 = v922 + (v792 ^ 0x452821E6) + v259;
          v274 = v271 + (v810 ^ 0x82EFA98) + v263;
          v275 = __ROR4__(v265 ^ v274, 8);
          v276 = v272 + (v788 ^ 0x243F6A88) + v264;
          v277 = __ROR4__(v268 ^ v276, 8);
          v961 = __ROR4__(v267 ^ v943, 8);
          v278 = v270 + v961;
          v279 = v922;
          v923 = v278;
          v997 = v850 ^ 0x13198A2E;
          v280 = v273 + (v850 ^ 0x13198A2E) + v266;
          v281 = __ROR4__(v279 ^ v278, 7);
          v282 = __ROR4__(v269 ^ v280, 8);
          v283 = v953 + v275;
          v284 = __ROR4__(v271 ^ (v953 + v275), 7);
          v285 = v841;
          v842 = v902 + v277;
          v286 = __ROR4__(v272 ^ (v902 + v277), 7);
          v287 = v281 + (v776 ^ 0x3F84D5B5) + v276;
          v834 = __ROR4__(v273 ^ (v285 + v282), 7);
          v288 = __ROR4__(v275 ^ v287, 16);
          v289 = v285 + v282 + v288;
          v290 = v286 + (v833 ^ 0x299F31D0) + v274;
          v291 = __ROR4__(v281 ^ v289, 12);
          v292 = v284 + (v805 ^ 0xC97C50DD) + v280;
          v293 = v834 + (v794 ^ 0x38D01377) + v943;
          v903 = __ROR4__(v282 ^ v290, 16);
          v294 = __ROR4__(v277 ^ v293, 16);
          v295 = __ROR4__(v961 ^ v292, 16);
          v296 = __ROR4__(v286 ^ (v923 + v903), 12);
          v843 = v842 + v295;
          v924 = v923 + v903;
          v954 = v283 + v294;
          v887 = v291 + (v829 ^ 0xB5470917) + v287;
          v297 = __ROR4__(v834 ^ (v283 + v294), 12);
          v298 = __ROR4__(v284 ^ v843, 12);
          v299 = v297 + (v799 ^ 0x85A308D3) + v293;
          v300 = __ROR4__(v294 ^ v299, 8);
          v301 = v298 + (v828 ^ 0xA4093822) + v292;
          v302 = v296 + (v803 ^ 0xEC4E6C89) + v290;
          v303 = __ROR4__(v295 ^ v301, 8);
          v304 = __ROR4__(v288 ^ v887, 8);
          v944 = v289 + v304;
          v305 = __ROR4__(v903 ^ v302, 8);
          v904 = v304;
          v306 = v924 + v305;
          v307 = __ROR4__(v291 ^ (v289 + v304), 7);
          v308 = v843;
          v844 = v954 + v300;
          v309 = __ROR4__(v297 ^ (v954 + v300), 7);
          v835 = __ROR4__(v296 ^ (v924 + v305), 7);
          v310 = v308 + v303;
          v311 = __ROR4__(v298 ^ v310, 7);
          v312 = v311 + (v794 ^ 0xB5470917) + v302;
          v313 = v309 + (v850 ^ 0x299F31D0) + v301;
          v314 = __ROR4__(v305 ^ v313, 16);
          v315 = (v805 ^ 0xBE5466CF) + v307 + v299;
          v316 = __ROR4__(v303 ^ v315, 16);
          v317 = v835 + (v829 ^ 0xC97C50DD) + v887;
          v318 = __ROR4__(v300 ^ v317, 16);
          v925 = v306 + v316;
          v319 = __ROR4__(v904 ^ v312, 16);
          v320 = __ROR4__(v307 ^ (v306 + v316), 12);
          v888 = v310 + v318;
          v321 = __ROR4__(v311 ^ (v844 + v319), 12);
          v905 = v844 + v319;
          v322 = __ROR4__(v835 ^ (v310 + v318), 12);
          v323 = v322 + (v828 ^ 0x3F84D5B5) + v317;
          v324 = v320 + (v810 ^ 0xA4093822) + v315;
          v325 = __ROR4__(v316 ^ v324, 8);
          v326 = __ROR4__(v318 ^ v323, 8);
          v327 = __ROR4__(v309 ^ (v944 + v314), 12);
          v328 = v321 + (v776 ^ 0x85A308D3) + v312;
          v329 = v327 + (v803 ^ 0xC0AC29B7) + v313;
          v330 = __ROR4__(v319 ^ v328, 8);
          v836 = __ROR4__(v314 ^ v329, 8);
          v926 = v925 + v325;
          v889 = v888 + v326;
          v331 = __ROR4__(v320 ^ v926, 7);
          v853 = v905 + v330;
          v332 = v944 + v314 + v836;
          v845 = __ROR4__(v322 ^ v889, 7);
          v333 = v321 ^ (v905 + v330);
          v334 = v327 ^ v332;
          v335 = __ROR4__(v333, 7);
          v336 = v331 + (v799 ^ 0x13198A2E) + v323;
          v337 = __ROR4__(v334, 7);
          v338 = __ROR4__(v330 ^ v336, 16);
          v339 = v845 + (v851 ^ 0x3707344) + v328;
          v340 = v332 + v338;
          v341 = v337 + (v832 ^ 0x34E90C6C) + v324;
          v342 = __ROR4__(v836 ^ v339, 16);
          v343 = __ROR4__(v326 ^ v341, 16);
          v344 = v926 + v342;
          v927 = v340;
          v906 = v344;
          v345 = v335 + (v797 ^ 0xEC4E6C89) + v329;
          v346 = __ROR4__(v325 ^ v345, 16);
          v347 = __ROR4__(v331 ^ v340, 12);
          v854 = v853 + v343;
          v837 = v889 + v346;
          v348 = v347 + (v814 ^ 0x38D01377) + v336;
          v349 = __ROR4__(v845 ^ v344, 12);
          v350 = __ROR4__(v338 ^ v348, 8);
          v351 = __ROR4__(v337 ^ v854, 12);
          v352 = __ROR4__(v335 ^ (v889 + v346), 12);
          v353 = v352 + (v833 ^ 0x243F6A88) + v345;
          v354 = v349 + (v792 ^ 0x82EFA98) + v339;
          v355 = __ROR4__(v346 ^ v353, 8);
          v356 = __ROR4__(v342 ^ v354, 8);
          v357 = v351 + (v788 ^ 0x452821E6) + v341;
          v358 = v347 ^ (v927 + v350);
          v928 = v927 + v350;
          v846 = __ROR4__(v343 ^ v357, 8);
          v359 = __ROR4__(v349 ^ (v906 + v356), 7);
          v360 = v854 + v846;
          v361 = __ROR4__(v358, 7);
          v362 = __ROR4__(v351 ^ (v854 + v846), 7);
          v363 = __ROR4__(v352 ^ (v837 + v355), 7);
          v364 = v359 + (v850 ^ 0x85A308D3) + v348;
          v365 = (v792 ^ 0x38D01377) + v361 + v357;
          v366 = __ROR4__(v355 ^ v365, 16);
          v367 = v363 + (v833 ^ 0x3F84D5B5) + v354;
          v890 = v906 + v356 + v366;
          v368 = __ROR4__(v350 ^ v367, 16);
          v369 = __ROR4__(v846 ^ v364, 16);
          v370 = v362 + (v828 ^ 0x34E90C6C) + v353;
          v847 = v366;
          v371 = v837 + v355 + v369;
          v372 = __ROR4__(v356 ^ v370, 16);
          v907 = v360 + v368;
          v373 = __ROR4__(v359 ^ v371, 12);
          v838 = v928 + v372;
          v374 = __ROR4__(v363 ^ (v360 + v368), 12);
          v855 = __ROR4__(v361 ^ v890, 12);
          v375 = __ROR4__(v362 ^ (v928 + v372), 12);
          v376 = v375 + (v788 ^ 0xC97C50DD) + v370;
          v377 = v373 + (v794 ^ 0xC0AC29B7) + v364;
          v378 = __ROR4__(v372 ^ v376, 8);
          v379 = v374 + (v829 ^ 0xEC4E6C89) + v367;
          v380 = v855 + (v799 ^ 0x3707344) + v365;
          v929 = __ROR4__(v369 ^ v377, 8);
          v381 = __ROR4__(v368 ^ v379, 8);
          v382 = __ROR4__(v847 ^ v380, 8);
          v891 = v890 + v382;
          v383 = __ROR4__(v374 ^ (v907 + v381), 7);
          v839 = v838 + v378;
          v384 = __ROR4__(v375 ^ v839, 7);
          v385 = __ROR4__(v373 ^ (v371 + v929), 7);
          v386 = __ROR4__(v855 ^ v891, 7);
          v856 = v814 ^ 0xBE5466CF;
          v387 = v383 + (v803 ^ 0x243F6A88) + v376;
          v388 = v386 + (v832 ^ 0x82EFA98) + v377;
          v389 = __ROR4__(v382 ^ v387, 16);
          v390 = v385 + (v776 ^ 0xA4093822) + v379;
          v815 = v384 + (v814 ^ 0xBE5466CF) + v380;
          v391 = __ROR4__(v378 ^ v390, 16);
          v392 = __ROR4__(v381 ^ v388, 16);
          v393 = __ROR4__(v929 ^ v815, 16);
          v394 = __ROR4__(v385 ^ (v891 + v391), 12);
          v746 = v839 + v392;
          v821 = v891 + v391;
          v395 = __ROR4__(v384 ^ (v907 + v381 + v393), 12);
          v908 = v907 + v381 + v393;
          v892 = v371 + v929 + v389;
          v396 = __ROR4__(v383 ^ v892, 12);
          v397 = __ROR4__(v386 ^ (v839 + v392), 12);
          v930 = v810 ^ 0x13198A2E;
          v398 = v394 + (v805 ^ 0xB5470917) + v390;
          v399 = v392;
          v400 = v810 ^ 0x13198A2E;
          v401 = v396 + (v797 ^ 0x299F31D0) + v387;
          v811 = v398;
          v402 = __ROR4__(v389 ^ v401, 8);
          v403 = v395 + v400 + v815;
          v816 = v397 + (v851 ^ 0x452821E6) + v388;
          v404 = __ROR4__(v399 ^ v816, 8);
          v405 = __ROR4__(v393 ^ v403, 8);
          v840 = __ROR4__(v391 ^ v398, 8);
          v406 = v821 + v840;
          v848 = v405;
          v407 = v394 ^ (v821 + v840);
          v822 = v746 + v404;
          v408 = v908 + v405;
          v409 = __ROR4__(v395 ^ (v908 + v405), 7);
          v826 = v892 + v402;
          v410 = __ROR4__(v396 ^ (v892 + v402), 7);
          v747 = __ROR4__(v397 ^ (v746 + v404), 7);
          v730 = __ROR4__(v407, 7);
          if ( blake256_rounds == 14 )
          {
            v825 = v829 ^ 0x38D01377;
            v411 = (v797 ^ 0x452821E6) + v747 + v403;
            v412 = (v851 ^ 0xB5470917) + v401;
            v413 = __ROR4__(v402 ^ v411, 16);
            v852 = v406 + v413;
            v414 = v730 + (v788 ^ 0x3707344) + v816;
            v415 = v410 + (v829 ^ 0x38D01377) + v811;
            v817 = v409 + v412;
            v416 = __ROR4__(v747 ^ (v406 + v413), 12);
            v830 = v414;
            v417 = __ROR4__(v840 ^ (v409 + v412), 16);
            v418 = __ROR4__(v404 ^ v415, 16);
            v419 = __ROR4__(v848 ^ v414, 16);
            v420 = v416 + (v832 ^ 0x243F6A88) + v411;
            v421 = v408 + v418;
            v422 = v409 ^ (v822 + v417);
            v823 = v822 + v417;
            v423 = __ROR4__(v410 ^ v421, 12);
            v424 = v826 + v419;
            v812 = __ROR4__(v413 ^ v420, 8);
            v425 = __ROR4__(v422, 12);
            v426 = v730 ^ (v826 + v419);
            v827 = v420;
            v731 = v799 ^ 0x3F84D5B5;
            v748 = __ROR4__(v426, 12);
            v427 = v423 + (v799 ^ 0x3F84D5B5) + v415;
            v428 = __ROR4__(v418 ^ v427, 8);
            v429 = v748 + (v792 ^ 0x34E90C6C) + v830;
            v430 = v425 + (v776 ^ 0x82EFA98) + v817;
            v831 = __ROR4__(v416 ^ (v852 + v812), 7);
            v431 = __ROR4__(v419 ^ v429, 8);
            v432 = __ROR4__(v423 ^ (v421 + v428), 7);
            v433 = v417 ^ v430;
            v434 = v831 + (v794 ^ 0xA4093822) + v429;
            v818 = v421 + v428;
            v435 = __ROR4__(v433, 8);
            v436 = __ROR4__(v428 ^ v434, 16);
            v437 = v424 + v431;
            v438 = __ROR4__(v748 ^ v437, 7);
            v439 = v438 + (v828 ^ 0xEC4E6C89) + v427;
            v440 = v425 ^ (v823 + v435);
            v824 = v823 + v435 + v436;
            v441 = __ROR4__(v440, 7);
            v442 = v997 + v430;
            v443 = v441 + v1004 + v827;
            v444 = __ROR4__(v831 ^ v824, 12);
            v445 = __ROR4__(v431 ^ v443, 16);
            v446 = __ROR4__(v435 ^ v439, 16);
            v806 = v444 + (v805 ^ 0x85A308D3) + v434;
            v447 = v852 + v812 + v446;
            v819 = v818 + v445;
            v448 = __ROR4__(v438 ^ v447, 12);
            v449 = __ROR4__(v441 ^ v819, 12);
            v800 = __ROR4__(v436 ^ v806, 8);
            v450 = __ROR4__(v812 ^ (v432 + v997 + v430), 16);
            v451 = v437 + v450;
            v452 = v448 + (v833 ^ 0xC97C50DD) + v439;
            v453 = v432 + v442;
            v813 = v824 + v800;
            v454 = __ROR4__(v444 ^ (v824 + v800), 7);
            v455 = v449 + v1003 + v443;
            v456 = __ROR4__(v432 ^ v451, 12);
            v457 = __ROR4__(v445 ^ v455, 8);
            v458 = v456 + v999 + v453;
            v459 = (v794 ^ 0x299F31D0) + v454 + v455;
            v460 = __ROR4__(v446 ^ v452, 8);
            v461 = __ROR4__(v450 ^ v458, 8);
            v462 = v447 + v460;
            v463 = v451 + v461;
            v749 = __ROR4__(v449 ^ (v819 + v457), 7);
            v464 = __ROR4__(v448 ^ v462, 7);
            v465 = __ROR4__(v461 ^ v459, 16);
            v466 = __ROR4__(v456 ^ v463, 7);
            v467 = v464 + v1001 + v806;
            v807 = v462 + v465;
            v468 = v466 + v966 + v452;
            v469 = __ROR4__(v454 ^ (v462 + v465), 12);
            v470 = v749 + v930 + v458;
            v471 = __ROR4__(v460 ^ v470, 16);
            v472 = __ROR4__(v800 ^ v468, 16);
            v801 = v819 + v457 + v472;
            v473 = v469 + (v803 ^ 0x85A308D3) + v459;
            v474 = v749;
            v475 = __ROR4__(v457 ^ v467, 16);
            v476 = __ROR4__(v466 ^ v801, 12);
            v477 = v463 + v475;
            v750 = __ROR4__(v465 ^ v473, 8);
            v478 = __ROR4__(v464 ^ v477, 12);
            v795 = v813 + v471;
            v479 = v478 + v1000 + v467;
            v480 = __ROR4__(v474 ^ (v813 + v471), 12);
            v481 = v480 + v856 + v470;
            v482 = __ROR4__(v471 ^ v481, 8);
            v808 = v807 + v750;
            v804 = v476 + v1002 + v468;
            v483 = v472 ^ v804;
            v484 = __ROR4__(v475 ^ v479, 8);
            v485 = __ROR4__(v469 ^ v808, 7);
            v486 = __ROR4__(v483, 8);
            v487 = v485 + (v792 ^ 0xC0AC29B7) + v479;
            v488 = v795;
            v796 = v477 + v484;
            v489 = v476 ^ (v801 + v486);
            v793 = v801 + v486;
            v490 = __ROR4__(v486 ^ v487, 16);
            v491 = v480 ^ (v488 + v482);
            v802 = v488 + v482 + v490;
            v492 = __ROR4__(v478 ^ (v477 + v484), 7);
            v493 = __ROR4__(v491, 7);
            v494 = __ROR4__(v489, 7);
            v495 = __ROR4__(v485 ^ v802, 12);
            v496 = v492 + v731 + v804;
            v497 = (v850 ^ 0x3707344) + v487;
            v498 = __ROR4__(v482 ^ v496, 16);
            v499 = v493 + (v828 ^ 0x243F6A88) + v473;
            v500 = v494 + (v776 ^ 0x34E90C6C) + v481;
            v501 = v808 + v498;
            v502 = __ROR4__(v484 ^ v499, 16);
            v503 = __ROR4__(v750 ^ v500, 16);
            v764 = v495 + v497;
            v751 = v793 + v502;
            v504 = __ROR4__(v492 ^ (v808 + v498), 12);
            v732 = v796 + v503;
            v505 = __ROR4__(v493 ^ (v793 + v502), 12);
            v506 = __ROR4__(v494 ^ (v796 + v503), 12);
            v507 = __ROR4__(v490 ^ (v495 + v497), 8);
            v508 = v506 + (v788 ^ 0xB5470917) + v500;
            v509 = v505 + (v797 ^ 0xC97C50DD) + v499;
            v510 = __ROR4__(v503 ^ v508, 8);
            v511 = v504 + v825 + v496;
            v512 = __ROR4__(v502 ^ v509, 8);
            v513 = __ROR4__(v498 ^ v511, 8);
            v514 = v802 + v507;
            v515 = __ROR4__(v495 ^ (v802 + v507), 7);
            v777 = v751 + v512;
            v752 = __ROR4__(v504 ^ (v501 + v513), 7);
            v733 = v732 + v510;
            v516 = __ROR4__(v505 ^ v777, 7);
            v517 = __ROR4__(v506 ^ v733, 7);
            v518 = v1000 + v515 + v509;
            v519 = __ROR4__(v510 ^ v518, 16);
            v520 = v517 + v968 + v511;
            v521 = v501 + v513 + v519;
            v522 = v516 + (v797 ^ 0x85A308D3) + v508;
            v523 = __ROR4__(v507 ^ v520, 16);
            v524 = __ROR4__(v515 ^ v521, 12);
            v525 = v752 + v1007 + v764;
            v526 = __ROR4__(v512 ^ v525, 16);
            v789 = __ROR4__(v513 ^ v522, 16);
            v527 = v514 + v789;
            v528 = v524 + v1001 + v518;
            v529 = __ROR4__(v516 ^ v527, 12);
            v530 = __ROR4__(v519 ^ v528, 8);
            v765 = v777 + v523;
            v531 = v521 + v530;
            v532 = v777 + v523;
            v778 = v733 + v526;
            v734 = __ROR4__(v524 ^ v531, 7);
            v533 = __ROR4__(v517 ^ v532, 12);
            v534 = __ROR4__(v752 ^ v778, 12);
            v535 = v789;
            v536 = v533 + v969 + v520;
            v790 = v531;
            v537 = __ROR4__(v523 ^ v536, 8);
            v538 = v529 + v967 + v522;
            v539 = v765 + v537;
            v540 = v534 + v970 + v525;
            v541 = __ROR4__(v526 ^ v540, 8);
            v542 = __ROR4__(v535 ^ v538, 8);
            v766 = v778 + v541;
            v543 = __ROR4__(v534 ^ (v778 + v541), 7);
            v544 = v527 + v542;
            v545 = v734 + v962 + v540;
            v546 = __ROR4__(v533 ^ v539, 7);
            v547 = __ROR4__(v537 ^ v545, 16);
            v548 = __ROR4__(v529 ^ v544, 7);
            v549 = v548 + v869 + v528;
            v550 = v546 + (v832 ^ 0x38D01377) + v538;
            v551 = __ROR4__(v541 ^ v549, 16);
            v552 = __ROR4__(v530 ^ v550, 16);
            v779 = v543 + v972 + v536;
            v753 = v544 + v547;
            v553 = __ROR4__(v542 ^ v779, 16);
            v554 = v539 + v551;
            v555 = __ROR4__(v734 ^ (v544 + v547), 12);
            v556 = __ROR4__(v548 ^ v554, 12);
            v735 = v766 + v552;
            v767 = v790 + v553;
            v557 = __ROR4__(v543 ^ (v790 + v553), 12);
            v558 = v555 + v963 + v545;
            v559 = __ROR4__(v547 ^ v558, 8);
            v560 = __ROR4__(v546 ^ v735, 12);
            v561 = v556 + v974 + v549;
            v562 = v560 + v971 + v550;
            v563 = __ROR4__(v551 ^ v561, 8);
            v564 = __ROR4__(v552 ^ v562, 8);
            v565 = v554 + v563;
            v566 = v753 + v559;
            v567 = v557 + v973 + v779;
            v568 = __ROR4__(v553 ^ v567, 8);
            v569 = __ROR4__(v556 ^ v565, 7);
            v754 = __ROR4__(v555 ^ (v753 + v559), 7);
            v736 = v735 + v564;
            v570 = __ROR4__(v557 ^ (v767 + v568), 7);
            v571 = __ROR4__(v560 ^ v736, 7);
            v572 = (v828 ^ 0x82EFA98) + v754 + v561;
            v573 = __ROR4__(v564 ^ v572, 16);
            v574 = v570 + v975 + v558;
            v575 = __ROR4__(v563 ^ v574, 16);
            v576 = v569 + v964 + v562;
            v577 = v571 + v1002 + v567;
            v780 = v767 + v568 + v573;
            v578 = __ROR4__(v559 ^ v577, 16);
            v579 = __ROR4__(v568 ^ v576, 16);
            v580 = __ROR4__(v754 ^ v780, 12);
            v581 = v566 + v579;
            v582 = __ROR4__(v569 ^ v581, 12);
            v755 = v736 + v575;
            v737 = v565 + v578;
            v583 = v580 + v1008 + v572;
            v584 = __ROR4__(v570 ^ v755, 12);
            v585 = __ROR4__(v571 ^ (v565 + v578), 12);
            v586 = __ROR4__(v573 ^ v583, 8);
            v587 = v582 + v965 + v576;
            v588 = __ROR4__(v579 ^ v587, 8);
            v589 = v584 + v976 + v574;
            v590 = v581 + v588;
            v591 = __ROR4__(v575 ^ v589, 8);
            v592 = v585 + v966 + v577;
            v593 = __ROR4__(v582 ^ v590, 7);
            v594 = __ROR4__(v578 ^ v592, 8);
            v781 = v780 + v586;
            v595 = __ROR4__(v580 ^ v781, 7);
            v756 = v755 + v591;
            v738 = v737 + v594;
            v596 = __ROR4__(v584 ^ v756, 7);
            v597 = v595 + v977 + v589;
            v598 = __ROR4__(v585 ^ v738, 7);
            v599 = __ROR4__(v594 ^ v597, 16);
            v600 = v593 + v978 + v583;
            v601 = v590 + v599;
            v602 = __ROR4__(v591 ^ v600, 16);
            v603 = v598 + v872 + v587;
            v604 = __ROR4__(v595 ^ v601, 12);
            v605 = __ROR4__(v586 ^ v603, 16);
            v606 = v596 + (v797 ^ 0x13198A2E) + v592;
            v607 = __ROR4__(v588 ^ v606, 16);
            v768 = v738 + v602;
            v739 = v756 + v605;
            v757 = v781 + v607;
            v608 = v604 + (v833 ^ 0x34E90C6C) + v597;
            v609 = v599 ^ v608;
            v610 = __ROR4__(v593 ^ v768, 12);
            v611 = __ROR4__(v598 ^ v739, 12);
            v782 = v608;
            v612 = __ROR4__(v596 ^ v757, 12);
            v613 = v610 + v979 + v600;
            v614 = v611 + (v850 ^ 0x85A308D3) + v603;
            v615 = __ROR4__(v602 ^ v613, 8);
            v616 = v1009 + v606;
            v617 = __ROR4__(v609, 8);
            v618 = v768;
            v619 = v601 + v617;
            v620 = __ROR4__(v605 ^ v614, 8);
            v621 = v612 + v616;
            v769 = __ROR4__(v604 ^ v619, 7);
            v622 = __ROR4__(v607 ^ v621, 8);
            v740 = v739 + v620;
            v791 = v618 + v615;
            v623 = __ROR4__(v610 ^ (v618 + v615), 7);
            v624 = __ROR4__(v612 ^ (v757 + v622), 7);
            v625 = __ROR4__(v611 ^ v740, 7);
            v626 = v624 + v981 + v782;
            v627 = v983 + v769 + v613;
            v628 = __ROR4__(v615 ^ v626, 16);
            v629 = __ROR4__(v620 ^ v627, 16);
            v630 = v623 + v980 + v614;
            v631 = v757 + v622 + v629;
            v632 = v625 + (v850 ^ 0x243F6A88) + v621;
            v633 = __ROR4__(v617 ^ v632, 16);
            v758 = __ROR4__(v622 ^ v630, 16);
            v741 = v740 + v628;
            v634 = v619 + v758;
            v635 = __ROR4__(v623 ^ v634, 12);
            v636 = v769 ^ v631;
            v770 = v791 + v633;
            v637 = __ROR4__(v636, 12);
            v638 = __ROR4__(v624 ^ v741, 12);
            v639 = __ROR4__(v625 ^ (v791 + v633), 12);
            v640 = v637 + (v828 ^ 0xB5470917) + v627;
            v641 = v635 + (v832 ^ 0x34E90C6C) + v630;
            v642 = v638 + v982 + v626;
            v643 = (v797 ^ 0xC0AC29B7) + v632;
            v644 = v758;
            v759 = __ROR4__(v629 ^ v640, 8);
            v645 = __ROR4__(v628 ^ v642, 8);
            v646 = v639 + v643;
            v647 = __ROR4__(v644 ^ v641, 8);
            v648 = __ROR4__(v633 ^ v646, 8);
            v649 = v634 + v647;
            v783 = v631 + v759;
            v650 = __ROR4__(v637 ^ (v631 + v759), 7);
            v651 = __ROR4__(v635 ^ v649, 7);
            v742 = v741 + v645;
            v652 = v770 + v648;
            v653 = __ROR4__(v639 ^ (v770 + v648), 7);
            v654 = __ROR4__(v638 ^ v742, 7);
            v655 = v650 + (v833 ^ 0x85A308D3) + v642;
            v656 = v651 + v1011 + v640;
            v657 = __ROR4__(v648 ^ v655, 16);
            v658 = v653 + v965 + v641;
            v659 = v649 + v657;
            v771 = __ROR4__(v645 ^ v656, 16);
            v660 = v652 + v771;
            v661 = v654 + v984 + v646;
            v662 = __ROR4__(v759 ^ v658, 16);
            v663 = __ROR4__(v647 ^ v661, 16);
            v743 = v742 + v662;
            v664 = __ROR4__(v651 ^ v660, 12);
            v665 = __ROR4__(v650 ^ v659, 12);
            v760 = v783 + v663;
            v666 = __ROR4__(v653 ^ v743, 12);
            v667 = __ROR4__(v654 ^ (v783 + v663), 12);
            v668 = v665 + v1010 + v655;
            v669 = v986 + v656 + v664;
            v670 = __ROR4__(v657 ^ v668, 8);
            v671 = v666 + v964 + v658;
            v672 = v659 + v670;
            v673 = v665 ^ v672;
            v674 = __ROR4__(v662 ^ v671, 8);
            v675 = v667 + v985 + v661;
            v784 = v672;
            v676 = __ROR4__(v663 ^ v675, 8);
            v677 = __ROR4__(v771 ^ v669, 8);
            v772 = v660 + v677;
            v678 = v743 + v674;
            v679 = __ROR4__(v666 ^ (v743 + v674), 7);
            v744 = v760 + v676;
            v680 = __ROR4__(v673, 7);
            v681 = __ROR4__(v664 ^ v772, 7);
            v682 = __ROR4__(v667 ^ (v760 + v676), 7);
            v683 = v963 + v668 + v682;
            v684 = (v833 ^ 0x38D01377) + v671 + v681;
            v685 = __ROR4__(v677 ^ v683, 16);
            v686 = __ROR4__(v676 ^ v684, 16);
            v687 = v679 + v987 + v675;
            v688 = v1013 + v680 + v669;
            v689 = __ROR4__(v670 ^ v687, 16);
            v690 = __ROR4__(v674 ^ v688, 16);
            v691 = v678 + v685;
            v761 = v784 + v686;
            v692 = __ROR4__(v682 ^ v691, 12);
            v785 = v744 + v690;
            v773 = v772 + v689;
            v693 = __ROR4__(v681 ^ v761, 12);
            v694 = __ROR4__(v680 ^ (v744 + v690), 12);
            v695 = __ROR4__(v679 ^ v773, 12);
            v696 = v694 + v1014 + v688;
            v697 = v1012 + v684 + v693;
            v698 = __ROR4__(v690 ^ v696, 8);
            v699 = __ROR4__(v686 ^ v697, 8);
            v700 = v962 + v683 + v692;
            v701 = v988 + v687 + v695;
            v702 = __ROR4__(v685 ^ v700, 8);
            v703 = __ROR4__(v689 ^ v701, 8);
            v745 = v761 + v699;
            v704 = v691 + v702;
            v705 = __ROR4__(v692 ^ v704, 7);
            v786 = v785 + v698;
            v762 = v773 + v703;
            v706 = __ROR4__(v693 ^ v745, 7);
            v707 = __ROR4__(v694 ^ v786, 7);
            v708 = __ROR4__(v695 ^ (v773 + v703), 7);
            v709 = v706 + v990 + v696;
            v710 = v1015 + v697 + v708;
            v711 = __ROR4__(v702 ^ v709, 16);
            v712 = v707 + v1016 + v700;
            v713 = __ROR4__(v698 ^ v710, 16);
            v714 = __ROR4__(v703 ^ v712, 16);
            v715 = v1003 + v701 + v705;
            v774 = v745 + v714;
            v716 = __ROR4__(v699 ^ v715, 16);
            v717 = v762 + v711;
            v718 = __ROR4__(v706 ^ (v762 + v711), 12);
            v763 = v786 + v716;
            v719 = __ROR4__(v707 ^ (v745 + v714), 12);
            v720 = __ROR4__(v708 ^ (v704 + v713), 12);
            v721 = __ROR4__(v705 ^ (v786 + v716), 12);
            v403 = (v832 ^ 0xB5470917) + v709 + v718;
            v816 = v719 + (v797 ^ 0xA4093822) + v712;
            v404 = __ROR4__(v714 ^ v816, 8);
            v401 = v989 + v710 + v720;
            v848 = __ROR4__(v711 ^ v403, 8);
            v722 = v721 + v1004 + v715;
            v408 = v717 + v848;
            v723 = v704 + v713;
            v402 = __ROR4__(v713 ^ v401, 8);
            v724 = __ROR4__(v716 ^ v722, 8);
            v811 = v722;
            v406 = v763 + v724;
            v409 = __ROR4__(v718 ^ v408, 7);
            v410 = __ROR4__(v720 ^ (v723 + v402), 7);
            v840 = v724;
            v725 = __ROR4__(v721 ^ (v763 + v724), 7);
            v822 = v774 + v404;
            v826 = v723 + v402;
            v747 = __ROR4__(v719 ^ (v774 + v404), 7);
            v730 = v725;
          }
          v866 ^= v403 ^ v865 ^ v406;
          v862 ^= v822 ^ v401 ^ v991;
          v861 ^= v811 ^ v864 ^ v408;
          v3 = 0;
          v867 ^= v826 ^ v992 ^ v816;
          result = v840 ^ v409 ^ v860 ^ v991;
          v859 ^= v410 ^ v864 ^ v404;
          v860 = result;
          v858 ^= v848 ^ v992 ^ v730;
          v857 ^= v747 ^ v865 ^ v402;
          if ( !n )
            break;
        }
        else if ( !n )
        {
          break;
        }
        v4 = 64 - v3;
      }
    }
    a1[16] = v3;
    a1[17] = v862;
    a1[18] = v861;
    a1[19] = v867;
    a1[20] = v866;
    a1[21] = v860;
    a1[22] = v859;
    a1[23] = v858;
    a1[24] = v857;
    a1[25] = v991;
    a1[26] = v864;
    a1[27] = v992;
    a1[28] = v865;
    a1[29] = v863;
    a1[30] = v868;
  }
  return result;
}
// 106690: using guessed type int blake256_rounds;

//----- (0007967C) --------------------------------------------------------
void *__fastcall sph_blake384_0(int a1, char *a2, size_t a3)
{
  int v3; // r5
  size_t v4; // r4
  void *v5; // r0
  unsigned int v6; // r3
  unsigned int v7; // r12
  unsigned int v8; // r11
  unsigned int v9; // r5
  _DWORD *v10; // r11
  int v11; // r7
  int v12; // r1
  int v13; // r4
  int v14; // lr
  int v15; // r3
  _BYTE *v16; // r1
  char *v17; // r10
  _BYTE *v18; // r2
  int v19; // r12
  int v20; // r3
  _BYTE *v21; // r5
  int v22; // r0
  int v23; // r7
  __int64 *v24; // r9
  _BYTE *v25; // r1
  int v26; // r12
  int v27; // r3
  int v28; // r7
  __int64 v29; // r2
  __int64 v30; // r4
  unsigned int v31; // lr
  int v32; // r9
  unsigned __int64 v33; // kr78_8
  unsigned int v34; // kr80_4
  unsigned int v35; // lr
  unsigned int v36; // r9
  unsigned __int64 v37; // kr90_8
  unsigned int v38; // r9
  unsigned __int64 v39; // kr98_8
  unsigned int v40; // r0
  int v41; // r0
  unsigned int v42; // kr14_4
  unsigned int v43; // r2
  unsigned int v44; // lr
  __int64 v45; // krA0_8
  unsigned int v46; // r2
  int v47; // r6
  int v48; // lr
  unsigned int v49; // r12
  unsigned int v50; // r0
  unsigned __int64 v51; // krA8_8
  unsigned int v52; // r6
  unsigned int v53; // r10
  unsigned int v54; // r3
  unsigned int v55; // r0
  int v56; // r10
  int v57; // r8
  int v58; // r6
  unsigned __int64 v59; // krB0_8
  unsigned int v60; // r12
  unsigned int v61; // r9
  unsigned int v62; // r10
  unsigned int v63; // r3
  __int64 v64; // r6
  unsigned int v65; // kr2C_4
  unsigned int v66; // r1
  unsigned int v67; // r9
  int v68; // r12
  unsigned int v69; // r9
  int v70; // r10
  unsigned __int64 v71; // krC0_8
  unsigned int v72; // r1
  unsigned int v73; // r9
  unsigned int v74; // r0
  unsigned __int64 v75; // krC8_8
  unsigned int v76; // kr40_4
  unsigned int v77; // r9
  __int64 v78; // r0
  unsigned int v79; // lr
  unsigned __int64 v80; // krE8_8
  unsigned int v81; // r10
  unsigned int v82; // lr
  unsigned int v83; // r9
  unsigned int v84; // r2
  unsigned int v85; // r8
  unsigned int v86; // lr
  unsigned __int64 v87; // krF0_8
  unsigned __int64 v88; // krF8_8
  unsigned __int64 v89; // kr100_8
  unsigned int v90; // r12
  unsigned int v91; // lr
  unsigned __int64 v92; // kr118_8
  unsigned int v93; // lr
  unsigned __int64 v94; // kr120_8
  __int64 v95; // r2
  int v96; // r8
  unsigned __int64 v97; // kr128_8
  unsigned __int64 v98; // kr130_8
  unsigned int v99; // lr
  void *result; // r0
  unsigned __int64 v102; // [sp+4h] [bp-2A0h]
  unsigned int v103; // [sp+4h] [bp-2A0h]
  unsigned int v104; // [sp+8h] [bp-29Ch]
  __int64 v105; // [sp+Ch] [bp-298h]
  __int64 v106; // [sp+14h] [bp-290h]
  unsigned __int64 v107; // [sp+14h] [bp-290h]
  unsigned __int64 v108; // [sp+1Ch] [bp-288h]
  unsigned int v109; // [sp+24h] [bp-280h]
  unsigned int v110; // [sp+24h] [bp-280h]
  unsigned int v111; // [sp+24h] [bp-280h]
  unsigned int v112; // [sp+28h] [bp-27Ch]
  unsigned int v113; // [sp+2Ch] [bp-278h]
  unsigned int v114; // [sp+2Ch] [bp-278h]
  unsigned __int64 v115; // [sp+30h] [bp-274h]
  __int64 v116; // [sp+30h] [bp-274h]
  __int64 v117; // [sp+38h] [bp-26Ch]
  unsigned int v118; // [sp+38h] [bp-26Ch]
  unsigned __int64 v119; // [sp+40h] [bp-264h]
  unsigned int v120; // [sp+40h] [bp-264h]
  __int64 v121; // [sp+48h] [bp-25Ch]
  __int64 v122; // [sp+48h] [bp-25Ch]
  int v123; // [sp+50h] [bp-254h]
  unsigned int v124; // [sp+50h] [bp-254h]
  __int64 v125; // [sp+54h] [bp-250h]
  unsigned __int64 v126; // [sp+5Ch] [bp-248h]
  __int64 v127; // [sp+5Ch] [bp-248h]
  __int64 v128; // [sp+64h] [bp-240h]
  int v129; // [sp+64h] [bp-240h]
  unsigned __int64 v130; // [sp+6Ch] [bp-238h]
  unsigned int v131; // [sp+6Ch] [bp-238h]
  unsigned int v132; // [sp+70h] [bp-234h]
  __int64 v133; // [sp+74h] [bp-230h]
  int v134; // [sp+74h] [bp-230h]
  int v135; // [sp+78h] [bp-22Ch]
  __int64 v136; // [sp+7Ch] [bp-228h]
  int v137; // [sp+7Ch] [bp-228h]
  unsigned int v138; // [sp+7Ch] [bp-228h]
  int v139; // [sp+80h] [bp-224h]
  unsigned int v140; // [sp+84h] [bp-220h]
  char *v141; // [sp+84h] [bp-220h]
  unsigned int v142; // [sp+88h] [bp-21Ch]
  unsigned int v143; // [sp+8Ch] [bp-218h]
  unsigned int v144; // [sp+90h] [bp-214h]
  unsigned __int64 v145; // [sp+94h] [bp-210h]
  unsigned __int64 v146; // [sp+9Ch] [bp-208h]
  unsigned __int64 v147; // [sp+A4h] [bp-200h]
  unsigned int v148; // [sp+ACh] [bp-1F8h]
  unsigned int v149; // [sp+B0h] [bp-1F4h]
  unsigned __int64 v150; // [sp+B4h] [bp-1F0h]
  int v151; // [sp+BCh] [bp-1E8h]
  unsigned int v152; // [sp+C0h] [bp-1E4h]
  unsigned int v153; // [sp+C4h] [bp-1E0h]
  int v154; // [sp+C8h] [bp-1DCh]
  int v155; // [sp+CCh] [bp-1D8h]
  int v156; // [sp+D0h] [bp-1D4h]
  unsigned int v157; // [sp+D4h] [bp-1D0h]
  __int64 v158; // [sp+D8h] [bp-1CCh]
  unsigned int v159; // [sp+E0h] [bp-1C4h]
  int v160; // [sp+E4h] [bp-1C0h]
  int v161; // [sp+E8h] [bp-1BCh]
  unsigned __int64 v162; // [sp+ECh] [bp-1B8h]
  __int64 v163; // [sp+F4h] [bp-1B0h]
  __int64 v164; // [sp+FCh] [bp-1A8h]
  unsigned int v165; // [sp+104h] [bp-1A0h]
  int v166; // [sp+108h] [bp-19Ch]
  int v167; // [sp+10Ch] [bp-198h]
  unsigned __int64 v168; // [sp+110h] [bp-194h]
  unsigned __int64 v169; // [sp+118h] [bp-18Ch]
  unsigned __int64 v170; // [sp+120h] [bp-184h]
  unsigned __int64 v171; // [sp+128h] [bp-17Ch]
  unsigned __int64 v172; // [sp+130h] [bp-174h]
  unsigned __int64 v173; // [sp+138h] [bp-16Ch]
  unsigned __int64 v174; // [sp+140h] [bp-164h]
  __int64 v175; // [sp+148h] [bp-15Ch]
  unsigned __int64 v176; // [sp+150h] [bp-154h]
  __int64 v177; // [sp+158h] [bp-14Ch]
  unsigned __int64 v178; // [sp+160h] [bp-144h]
  unsigned int v179; // [sp+164h] [bp-140h]
  unsigned __int64 v180; // [sp+168h] [bp-13Ch]
  unsigned int v181; // [sp+170h] [bp-134h]
  unsigned int v182; // [sp+170h] [bp-134h]
  __int64 v183; // [sp+174h] [bp-130h]
  __int64 v184; // [sp+17Ch] [bp-128h]
  size_t n; // [sp+188h] [bp-11Ch]
  char *src; // [sp+18Ch] [bp-118h]
  unsigned __int64 v188; // [sp+190h] [bp-114h]
  unsigned __int64 v189; // [sp+198h] [bp-10Ch]
  unsigned __int64 v190; // [sp+1A0h] [bp-104h]
  __int64 v191; // [sp+1A8h] [bp-FCh]
  __int64 v192; // [sp+1B0h] [bp-F4h]
  unsigned int v193; // [sp+1B8h] [bp-ECh]
  int v194; // [sp+1BCh] [bp-E8h]
  unsigned int v195; // [sp+1C0h] [bp-E4h]
  unsigned int v196; // [sp+1C4h] [bp-E0h]
  __int64 v197; // [sp+1C8h] [bp-DCh]
  unsigned __int64 v198; // [sp+1D0h] [bp-D4h]
  __int64 v199; // [sp+1D8h] [bp-CCh]
  __int64 v200; // [sp+1E0h] [bp-C4h]
  __int64 v201; // [sp+1E8h] [bp-BCh]
  __int64 v202; // [sp+1F0h] [bp-B4h]
  __int64 v203; // [sp+1F8h] [bp-ACh]
  unsigned int v204; // [sp+200h] [bp-A4h]
  unsigned int v205; // [sp+204h] [bp-A0h]
  unsigned __int64 v206; // [sp+208h] [bp-9Ch]
  unsigned int v207; // [sp+220h] [bp-84h]
  _DWORD v208[7]; // [sp+224h] [bp-80h]
  unsigned __int64 v209; // [sp+240h] [bp-64h]
  unsigned __int64 v210; // [sp+248h] [bp-5Ch]
  unsigned __int64 v211; // [sp+250h] [bp-54h]
  unsigned int v212; // [sp+258h] [bp-4Ch]
  unsigned int v213; // [sp+25Ch] [bp-48h]
  unsigned __int64 v214; // [sp+260h] [bp-44h]
  unsigned __int64 v215; // [sp+268h] [bp-3Ch]
  unsigned __int64 v216; // [sp+270h] [bp-34h]
  unsigned __int64 v217; // [sp+278h] [bp-2Ch]
  unsigned __int64 v218; // [sp+280h] [bp-24h]
  unsigned __int64 v219; // [sp+288h] [bp-1Ch]
  unsigned int v220; // [sp+290h] [bp-14h]
  unsigned int v221; // [sp+294h] [bp-10h]
  unsigned __int64 v222; // [sp+298h] [bp-Ch]
  _BYTE v223[4]; // [sp+2A0h] [bp-4h] BYREF

  v3 = *(_DWORD *)(a1 + 128);
  v4 = 128 - v3;
  n = a3;
  src = a2;
  if ( 128 - v3 > a3 )
  {
    result = memcpy((void *)(a1 + v3), a2, a3);
    *(_DWORD *)(a1 + 128) = v3 + n;
  }
  else
  {
    v190 = *(_QWORD *)(a1 + 136);
    v189 = *(_QWORD *)(a1 + 144);
    v199 = *(_QWORD *)(a1 + 152);
    v198 = *(_QWORD *)(a1 + 160);
    v197 = *(_QWORD *)(a1 + 168);
    v195 = *(_DWORD *)(a1 + 176);
    v196 = *(_DWORD *)(a1 + 180);
    v193 = *(_DWORD *)(a1 + 184);
    v194 = *(_DWORD *)(a1 + 188);
    v192 = *(_QWORD *)(a1 + 192);
    v200 = *(_QWORD *)(a1 + 200);
    v201 = *(_QWORD *)(a1 + 208);
    v202 = *(_QWORD *)(a1 + 216);
    v191 = *(_QWORD *)(a1 + 224);
    v188 = *(_QWORD *)(a1 + 232);
    v203 = *(_QWORD *)(a1 + 240);
    if ( a3 )
    {
      while ( 1 )
      {
        if ( v4 >= n )
          v4 = n;
        v5 = (void *)(a1 + v3);
        v3 += v4;
        memcpy(v5, src, v4);
        n -= v4;
        src += v4;
        if ( v3 == 128 )
        {
          v188 += 1024LL;
          if ( v188 <= 0x3FF )
            ++v203;
          v142 = bswap32(*(_DWORD *)(a1 + 8));
          v140 = bswap32(*(_DWORD *)(a1 + 12));
          v143 = bswap32(*(_DWORD *)(a1 + 20));
          v144 = bswap32(*(_DWORD *)(a1 + 24));
          v145 = _byteswap_uint64(*(_QWORD *)(a1 + 32));
          v153 = bswap32(*(_DWORD *)a1);
          v152 = bswap32(*(_DWORD *)(a1 + 4));
          v157 = bswap32(*(_DWORD *)(a1 + 16));
          v159 = bswap32(*(_DWORD *)(a1 + 28));
          v146 = _byteswap_uint64(*(_QWORD *)(a1 + 40));
          v147 = _byteswap_uint64(*(_QWORD *)(a1 + 48));
          v6 = *(_DWORD *)(a1 + 60);
          v148 = bswap32(*(_DWORD *)(a1 + 56));
          v208[0] = v153;
          v208[5] = v159;
          v210 = v146;
          v208[1] = v140;
          v151 = 320440878;
          v208[2] = v142;
          v208[3] = v143;
          v211 = v147;
          v213 = v148;
          v7 = *(_DWORD *)(a1 + 64);
          v212 = bswap32(v6);
          v8 = *(_DWORD *)(a1 + 72);
          v9 = *(_DWORD *)(a1 + 68);
          v165 = v212;
          v207 = v152;
          v208[4] = v157;
          v208[6] = v144;
          v209 = v145;
          v154 = 57701188;
          v179 = *(_DWORD *)(a1 + 104);
          v181 = *(_DWORD *)(a1 + 108);
          v204 = *(_DWORD *)(a1 + 112);
          v205 = *(_DWORD *)(a1 + 116);
          v206 = *(_QWORD *)(a1 + 120);
          v133 = v201 ^ 0x13198A2E03707344LL;
          v160 = 698298832;
          v158 = 0x82EFA98EC4E6C89LL;
          v163 = 0x452821E638D01377LL;
          v162 = 0xBE5466CF34E90C6CLL;
          v102 = v202 ^ 0xA4093822299F31D0LL;
          v161 = -1542899678;
          v105 = v191 ^ 0x82EFA98EC4E6C89LL;
          v167 = -1062458953;
          v184 = 0x801F2E2858EFC16LL;
          v183 = 0x636920D871574E69LL;
          v126 = v188 ^ 0xBE5466CF34E90C6CLL;
          v180 = 0xBA7C9045F12C7F99LL;
          v121 = v188 ^ 0x452821E638D01377LL;
          v177 = 0x24A19947B3916CF7LL;
          v106 = v200 ^ 0x243F6A8885A308D3LL;
          v175 = 0x2FFD72DBD01ADFB7LL;
          v173 = 0xB8E1AFED6A267E96LL;
          v108 = v203 ^ 0xC0AC29B7C97C50DDLL;
          v171 = 0x9216D5D98979FB1BLL;
          v117 = v203 ^ 0x3F84D5B5B5470917LL;
          v128 = v192;
          v169 = 0xD1310BA698DFB5ACLL;
          v112 = v193;
          v155 = -2052912941;
          v123 = v194;
          v156 = 608135816;
          v109 = v195;
          v164 = 0x3F84D5B5B5470917LL;
          v113 = v196;
          v136 = v197;
          v166 = -914599715;
          v168 = _byteswap_uint64(__PAIR64__(v9, v7));
          v130 = v198;
          v170 = _byteswap_uint64(__PAIR64__(*(_DWORD *)(a1 + 76), v8));
          v125 = v199;
          v119 = v189;
          v115 = v190;
          v174 = _byteswap_uint64(*(_QWORD *)(a1 + 88));
          v172 = _byteswap_uint64(*(_QWORD *)(a1 + 80));
          v176 = _byteswap_uint64(*(_QWORD *)(a1 + 96));
          v214 = v168;
          v178 = _byteswap_uint64(__PAIR64__(v181, v179));
          v182 = bswap32(v204);
          v215 = v170;
          v149 = bswap32(v205);
          v216 = v172;
          v217 = v174;
          v218 = v176;
          v150 = _byteswap_uint64(v206);
          v219 = v178;
          v221 = v182;
          v220 = v149;
          v222 = v150;
          v10 = &unk_EC098;
          while ( 1 )
          {
            v10 += 16;
            LODWORD(v30) = v140 ^ v155;
            v31 = v121 ^ ((v152 ^ v154) + v136 + v115);
            HIDWORD(v30) = (__PAIR64__(v153 ^ v151, v152 ^ v154) + v136 + v115) >> 32;
            v32 = HIDWORD(v121) ^ HIDWORD(v30);
            v33 = __PAIR64__(v31, HIDWORD(v121) ^ HIDWORD(v30)) + v106;
            v34 = (v140 ^ v155) + (v152 ^ v154) + v136 + v115;
            HIDWORD(v30) = (v30 + __PAIR64__(v142 ^ v156, (v152 ^ v154) + v136 + v115)) >> 32;
            LODWORD(v30) = (__int64)(v33 ^ v136) >> 25;
            v35 = v31
                ^ ((__PAIR64__(
                      ((unsigned int)(HIDWORD(v33) ^ HIDWORD(v136)) >> 25)
                    | (((unsigned int)v33 ^ (unsigned int)v136) << 7),
                      v34)
                  + v30) >> 32);
            v36 = v32 ^ (v34 + v30);
            HIDWORD(v122) = ((unsigned int)(HIDWORD(v33) ^ HIDWORD(v136)) >> 25)
                          | (((unsigned int)v33 ^ (unsigned int)v136) << 7);
            v116 = __PAIR64__(HIDWORD(v122), v34) + v30;
            LODWORD(v122) = v30;
            v137 = HIWORD(v36) | (v35 << 16);
            v107 = v33 + __PAIR64__(HIWORD(v35) | (v36 << 16), v137);
            v139 = HIWORD(v35) | (v36 << 16);
            v37 = __PAIR64__(v157 ^ HIDWORD(v158), v143 ^ (unsigned int)v158) + __PAIR64__(v113, v109) + v119;
            v38 = ((HIDWORD(v126) ^ HIDWORD(v37)) + v133) ^ v109;
            v39 = __PAIR64__((unsigned int)v126 ^ (unsigned int)v37, HIDWORD(v126) ^ HIDWORD(v37)) + v133;
            LODWORD(v30) = ((__PAIR64__((unsigned int)v126 ^ (unsigned int)v37, HIDWORD(v126) ^ HIDWORD(v37)) + v133) >> 32)
                         ^ v113;
            v40 = (unsigned int)v30 >> 25;
            LODWORD(v30) = (v38 >> 25) | ((_DWORD)v30 << 7);
            v41 = v40 | (v38 << 7);
            v42 = (v159 ^ v160) + v37;
            v43 = HIDWORD(v126) ^ HIDWORD(v37) ^ (v42 + v30);
            v110 = v42 + v30;
            v44 = v126
                ^ v37
                ^ ((__PAIR64__(HIDWORD(v37) + __CFADD__(v159 ^ v160, (_DWORD)v37) + (v144 ^ v161), v42)
                  + __PAIR64__(v41, v30)) >> 32);
            v120 = (__PAIR64__(HIDWORD(v37) + __CFADD__(v159 ^ v160, (_DWORD)v37) + (v144 ^ v161), v42)
                  + __PAIR64__(v41, v30)) >> 32;
            LODWORD(v127) = HIWORD(v43) | (v44 << 16);
            HIDWORD(v127) = HIWORD(v44) | (v43 << 16);
            v114 = (v39 + v127) >> 32;
            LODWORD(v30) = v30 ^ (v39 + v127);
            v45 = (v145 ^ v162) + __PAIR64__(v123, v112) + v125;
            v46 = (HIDWORD(v108) ^ HIDWORD(v45)) + v102;
            v47 = v108 ^ v45;
            LODWORD(v108) = v39 + v127;
            v48 = HIDWORD(v102) + __CFADD__(HIDWORD(v108) ^ HIDWORD(v45), (_DWORD)v102) + v47;
            v49 = ((v46 ^ v112) >> 25) | ((v48 ^ v123) << 7);
            HIDWORD(v30) = ((v48 ^ (unsigned int)v123) >> 25) | ((v46 ^ v112) << 7);
            v50 = v41 ^ v114;
            v51 = (v146 ^ v163) + v45 + __PAIR64__(HIDWORD(v30), v49);
            v52 = v47 ^ HIDWORD(v51);
            v104 = ((unsigned int)v30 >> 11) | (v50 << 21);
            v53 = HIDWORD(v108) ^ HIDWORD(v45) ^ v51;
            v54 = v50 >> 11;
            v55 = HIWORD(v53);
            HIDWORD(v108) = (v146 ^ v163) + v45 + v49;
            v56 = HIWORD(v52) | (v53 << 16);
            v57 = v54 | ((_DWORD)v30 << 21);
            v58 = v55 | (v52 << 16);
            v135 = v56;
            v59 = __PAIR64__(v48, v46) + __PAIR64__(v56, v58);
            v60 = v49 ^ (v46 + v58);
            HIDWORD(v30) ^= (__PAIR64__(v48, v46) + __PAIR64__(v56, v58)) >> 32;
            v134 = v58;
            v61 = HIDWORD(v117) ^ (((v147 ^ v164) + v128 + v130) >> 32);
            v62 = HIDWORD(v105);
            HIDWORD(v105) = v117 ^ ((v147 ^ v164) + v128 + v130);
            v63 = v61 + v105;
            v118 = (__PAIR64__(v62, v61) + v105) >> 32;
            LODWORD(v64) = (__int64)((__PAIR64__(v62, v61) + v105) ^ v128) >> 25;
            HIDWORD(v64) = (__PAIR64__(v148 ^ v167, v165 ^ v166) + (v147 ^ v164) + v128 + v130) >> 32;
            v65 = (v165 ^ v166) + (v147 ^ v164) + v128 + v130;
            v66 = ((v118 ^ HIDWORD(v128)) >> 25) | (((v61 + (_DWORD)v105) ^ (unsigned int)v128) << 7);
            v67 = v61 ^ (v65 + v64);
            v129 = v65 + v64;
            LODWORD(v30) = (v60 >> 11) | (HIDWORD(v30) << 21);
            v131 = (__PAIR64__(v66, v65) + v64) >> 32;
            v68 = (HIDWORD(v30) >> 11) | (v60 << 21);
            LODWORD(v105) = v30;
            HIDWORD(v30) = HIWORD(v67);
            v69 = ((HIDWORD(v105) ^ v131) >> 16) | (v67 << 16);
            v70 = HIDWORD(v30) | ((HIDWORD(v105) ^ v131) << 16);
            LODWORD(v64) = v64 ^ (v63 + v70);
            HIDWORD(v105) = v68;
            v71 = __PAIR64__(v118, v63) + __PAIR64__(v69, v70);
            v72 = v66 ^ ((__PAIR64__(v118, v63) + __PAIR64__(v69, v70)) >> 32);
            v103 = v70 ^ ((v168 ^ v169) + v116 + v104);
            v73 = v69 ^ (((v168 ^ v169) + v116 + __PAIR64__(v57, v104)) >> 32);
            v74 = v104 ^ (v59 + v73);
            v75 = v59 + __PAIR64__(v103, v73);
            v132 = (v74 >> 25) | ((v57 ^ ((v59 + __PAIR64__(v103, v73)) >> 32)) << 7);
            HIDWORD(v30) = ((v170 ^ v171) + (v168 ^ v169) + v116 + __PAIR64__(v57, v104)) >> 32;
            v76 = (v170 ^ v171) + (v168 ^ v169) + v116 + v104;
            v77 = v73 ^ (v76 + v132);
            v115 = (v170 ^ v171)
                 + (v168 ^ v169)
                 + v116
                 + __PAIR64__(v57, v104)
                 + __PAIR64__((((unsigned int)v57 ^ HIDWORD(v75)) >> 25) | (v74 << 7), v132);
            LODWORD(v30) = ((unsigned int)v64 >> 11) | (v72 << 21);
            v124 = (((unsigned int)v57 ^ HIDWORD(v75)) >> 25) | (v74 << 7);
            LODWORD(v64) = (v72 >> 11) | ((_DWORD)v64 << 21);
            LODWORD(v117) = HIWORD(v77)
                          | ((v103 ^ ((__PAIR64__(HIDWORD(v30), v76) + __PAIR64__(v124, v132)) >> 32)) << 16);
            HIDWORD(v117) = ((v103 ^ ((__PAIR64__(HIDWORD(v30), v76) + __PAIR64__(v124, v132)) >> 32)) >> 16)
                          | (v77 << 16);
            v102 = v75 + v117;
            LODWORD(v78) = v105;
            HIDWORD(v78) = ((v172 ^ v173) + __PAIR64__(v120, v110)) >> 32;
            v79 = v137 ^ ((v172 ^ v173) + v110 + v105);
            v80 = v71 + __PAIR64__(v79, v139 ^ (unsigned int)((__PAIR64__(v68, (v172 ^ v173) + v110) + v78) >> 32));
            v81 = (((unsigned int)v68 ^ HIDWORD(v80)) >> 25) | (((unsigned int)v105 ^ (unsigned int)v80) << 7);
            v138 = (__int64)(v105
                           ^ (v71
                            + __PAIR64__(
                                v79,
                                v139 ^ (unsigned int)((__PAIR64__(v68, (v172 ^ v173) + v110) + v78) >> 32)))) >> 25;
            v119 = (v174 ^ v175) + __PAIR64__(v68, (v172 ^ v173) + v110) + v78 + __PAIR64__(v81, v138);
            v82 = v79 ^ HIDWORD(v119);
            v83 = v139 ^ ((__PAIR64__(v68, (v172 ^ v173) + v110) + v78) >> 32) ^ v119;
            v84 = (__int64)(v122 ^ v107) >> 11;
            v85 = ((unsigned int)(HIDWORD(v122) ^ HIDWORD(v107)) >> 11)
                | (((unsigned int)v122 ^ (unsigned int)v107) << 21);
            LODWORD(v121) = HIWORD(v83) | (v82 << 16);
            HIDWORD(v121) = HIWORD(v82) | (v83 << 16);
            v105 = v80 + v121;
            v86 = v127 ^ ((v176 ^ v177) + HIDWORD(v108) + v30);
            v87 = (v176 ^ v177) + __PAIR64__(HIDWORD(v51), HIDWORD(v108)) + __PAIR64__(v64, v30);
            HIDWORD(v78) = v30 ^ (v107 + (HIDWORD(v127) ^ HIDWORD(v87)));
            v88 = v107 + __PAIR64__(v86, HIDWORD(v127) ^ HIDWORD(v87));
            v89 = (v178 ^ v180) + v87;
            LODWORD(v64) = v64 ^ ((v107 + __PAIR64__(v86, HIDWORD(v127) ^ HIDWORD(v89))) >> 32);
            LODWORD(v78) = (HIDWORD(v78) >> 25) | ((_DWORD)v64 << 7);
            HIDWORD(v78) = ((unsigned int)v64 >> 25) | (HIDWORD(v78) << 7);
            v90 = HIDWORD(v127) ^ HIDWORD(v87) ^ (v89 + v78);
            v91 = v86 ^ ((v89 + v78) >> 32);
            LODWORD(v126) = HIWORD(v90) | (v91 << 16);
            HIDWORD(v126) = HIWORD(v91) | (v90 << 16);
            v125 = v89 + v78;
            v111 = v132 ^ (v75 + v117);
            v106 = v88 + v126;
            v92 = __PAIR64__(
                    v131 + __CFADD__(v149 ^ v183, v129) + (v182 ^ HIDWORD(v183)),
                    (v149 ^ (unsigned int)v183) + v129)
                + __PAIR64__(v85, v84);
            v93 = v135
                ^ ((__PAIR64__(
                      v131 + __CFADD__(v149 ^ v183, v129) + (v182 ^ HIDWORD(v183)),
                      (v149 ^ (unsigned int)v183) + v129)
                  + __PAIR64__(v85, v84)) >> 32);
            HIDWORD(v30) = v81 ^ ((v80 + v121) >> 32);
            LODWORD(v64) = v134 ^ ((v149 ^ v183) + v129 + v84);
            v94 = __PAIR64__(v114, v108) + __PAIR64__(v64, v93);
            LODWORD(v95) = v84 ^ (v108 + v93);
            HIDWORD(v95) = v85 ^ ((__PAIR64__(v114, v108) + __PAIR64__(v64, v93)) >> 32);
            v96 = HIDWORD(v95) >> 25;
            HIDWORD(v95) = v95 >> 25;
            LODWORD(v95) = v96 | ((_DWORD)v95 << 7);
            v97 = (v150 ^ v184) + v92;
            HIDWORD(v78) ^= (v88 + v126) >> 32;
            v98 = v97 + __PAIR64__(v95, HIDWORD(v95));
            v99 = v93 ^ (v97 + HIDWORD(v95));
            LODWORD(v64) = v64 ^ ((v97 + __PAIR64__(v95, HIDWORD(v95))) >> 32);
            v130 = v97 + __PAIR64__(v95, HIDWORD(v95));
            v113 = ((v124 ^ ((v75 + v117) >> 32)) >> 11) | (v111 << 21);
            v109 = (v111 >> 11) | ((v124 ^ ((v75 + v117) >> 32)) << 21);
            v123 = (HIDWORD(v30) >> 11) | ((v138 ^ ((_DWORD)v80 + (_DWORD)v121)) << 21);
            v112 = ((v138 ^ ((_DWORD)v80 + (_DWORD)v121)) >> 11) | (HIDWORD(v30) << 21);
            LODWORD(v108) = HIWORD(v99) | ((_DWORD)v64 << 16);
            HIDWORD(v108) = WORD1(v64) | (v99 << 16);
            LODWORD(v128) = (((unsigned int)v78 ^ ((_DWORD)v88 + (_DWORD)v126)) >> 11) | (HIDWORD(v78) << 21);
            HIDWORD(v128) = (HIDWORD(v78) >> 11) | (((unsigned int)v78 ^ ((_DWORD)v88 + (_DWORD)v126)) << 21);
            HIDWORD(v95) ^= v94 + (_DWORD)v108;
            LODWORD(v95) = v95 ^ ((v94 + v108) >> 32);
            v133 = v94 + v108;
            HIDWORD(v136) = v95 >> 11;
            LODWORD(v136) = (HIDWORD(v95) >> 11) | ((_DWORD)v95 << 21);
            if ( &unk_EC498 == (_UNKNOWN *)v10 )
              break;
            v11 = *(v10 - 10);
            v12 = 8 * *(v10 - 15);
            v13 = 2 * *(v10 - 16);
            v141 = (char *)&unk_EC458 + v12;
            v14 = 2 * *(v10 - 14);
            v15 = *(v10 - 13);
            v155 = *(_DWORD *)((char *)&unk_EC458 + v13 * 4);
            v16 = &v223[v12];
            v17 = (char *)&unk_EC458 + 8 * v15;
            v18 = &v223[8 * v15];
            v19 = 2 * *(v10 - 12);
            v156 = *(_DWORD *)((char *)&unk_EC458 + v13 * 4 + 4);
            v20 = 2 * *(v10 - 11);
            v21 = &v223[8 * v11];
            v152 = v208[v13 - 1];
            v153 = v208[v13];
            v154 = *((_DWORD *)&unk_EC458 + 2 * *(v10 - 15));
            v151 = *((_DWORD *)v141 + 1);
            v140 = *((_DWORD *)v16 - 32);
            v142 = *((_DWORD *)v16 - 31);
            v160 = *(_DWORD *)((char *)&unk_EC458 + v14 * 4);
            v161 = *(_DWORD *)((char *)&unk_EC458 + v14 * 4 + 4);
            v143 = v208[v14 - 1];
            v157 = v208[v14];
            LODWORD(v158) = *((_DWORD *)&unk_EC458 + 2 * *(v10 - 13));
            HIDWORD(v158) = *((_DWORD *)v17 + 1);
            v159 = *((_DWORD *)v18 - 32);
            v144 = *((_DWORD *)v18 - 31);
            v163 = *(_QWORD *)((char *)&unk_EC458 + v19 * 4);
            v145 = *(_QWORD *)&v208[v19 - 1];
            v162 = *(_QWORD *)((char *)&unk_EC458 + v20 * 4);
            v146 = *(_QWORD *)&v208[v20 - 1];
            v22 = *((_DWORD *)&unk_EC458 + 2 * v11 + 1);
            v23 = *(v10 - 9);
            v147 = *((_QWORD *)v21 - 16);
            v167 = v22;
            v24 = (__int64 *)((char *)&unk_EC458 + 8 * v23);
            v25 = &v223[8 * v23];
            v26 = 2 * *(v10 - 4);
            v27 = 2 * *(v10 - 5);
            v166 = *((_DWORD *)&unk_EC458 + 2 * *(v10 - 10));
            v164 = *v24;
            v28 = 2 * *(v10 - 3);
            v165 = *((_DWORD *)v25 - 32);
            v148 = *((_DWORD *)v25 - 31);
            v171 = *((_QWORD *)&unk_EC458 + *(v10 - 8));
            v168 = *(_QWORD *)&v208[2 * *(v10 - 8) - 1];
            v175 = *((_QWORD *)&unk_EC458 + *(v10 - 6));
            v169 = *((_QWORD *)&unk_EC458 + *(v10 - 7));
            v172 = *(_QWORD *)&v208[2 * *(v10 - 6) - 1];
            v170 = *(_QWORD *)&v208[2 * *(v10 - 7) - 1];
            v173 = *(_QWORD *)((char *)&unk_EC458 + v27 * 4);
            v174 = *(_QWORD *)&v208[v27 - 1];
            v176 = *(_QWORD *)&v208[v26 - 1];
            v180 = *(_QWORD *)((char *)&unk_EC458 + v26 * 4);
            v178 = *(_QWORD *)&v208[v28 - 1];
            v177 = *(_QWORD *)((char *)&unk_EC458 + v28 * 4);
            v29 = *((_QWORD *)v10 - 1);
            v184 = *((_QWORD *)&unk_EC458 + v29);
            v183 = *((_QWORD *)&unk_EC458 + HIDWORD(v29));
            v149 = v208[2 * (_DWORD)v29 - 1];
            v150 = *(_QWORD *)&v208[2 * HIDWORD(v29) - 1];
            v182 = v208[2 * (_DWORD)v29];
          }
          v190 ^= v115 ^ v200 ^ v106;
          v189 ^= v119 ^ v201 ^ v133;
          v199 ^= v125 ^ v202 ^ v102;
          v198 ^= v105 ^ v191 ^ v98;
          v197 ^= v121 ^ v200 ^ v136;
          v3 = 0;
          v195 ^= v126 ^ v201 ^ v109;
          v196 ^= HIDWORD(v126) ^ HIDWORD(v201) ^ v113;
          v193 ^= v112 ^ v202 ^ v108;
          v194 ^= v123 ^ HIDWORD(v202) ^ HIDWORD(v108);
          v192 ^= v117 ^ v128 ^ v191;
          if ( !n )
            break;
        }
        else if ( !n )
        {
          break;
        }
        v4 = 128 - v3;
      }
    }
    *(_QWORD *)(a1 + 136) = v190;
    *(_QWORD *)(a1 + 144) = v189;
    *(_QWORD *)(a1 + 152) = v199;
    *(_QWORD *)(a1 + 160) = v198;
    *(_QWORD *)(a1 + 168) = v197;
    *(_DWORD *)(a1 + 176) = v195;
    *(_DWORD *)(a1 + 180) = v196;
    *(_DWORD *)(a1 + 184) = v193;
    *(_DWORD *)(a1 + 188) = v194;
    *(_QWORD *)(a1 + 192) = v192;
    *(_DWORD *)(a1 + 128) = v3;
    *(_QWORD *)(a1 + 200) = v200;
    *(_QWORD *)(a1 + 208) = v201;
    *(_QWORD *)(a1 + 216) = v202;
    *(_QWORD *)(a1 + 224) = v191;
    *(_QWORD *)(a1 + 232) = v188;
    *(_QWORD *)(a1 + 240) = v203;
    return (void *)v188;
  }
  return result;
}

//----- (0007ADD0) --------------------------------------------------------
unsigned int *__fastcall sub_7ADD0(unsigned int *a1, char a2, int a3, int a4, int a5)
{
  unsigned int v5; // lr
  char v7; // r3
  unsigned int v8; // r9
  unsigned int v9; // r12
  bool v11; // zf
  unsigned int v12; // r2
  unsigned int v13; // r7
  unsigned int v14; // r8
  char *v15; // r0
  char *v16; // r9
  size_t v17; // r10
  char v18; // r3
  unsigned int v19; // r7
  unsigned int *result; // r0
  int v21; // r3
  int v22; // t1
  unsigned int v23; // r7
  char v24[56]; // [sp+0h] [bp-40h] BYREF
  unsigned int v25; // [sp+38h] [bp-8h]
  unsigned int v26; // [sp+3Ch] [bp-4h]

  v5 = a1[16];
  v7 = 128 >> a3;
  v8 = a1[29];
  v9 = a1[30];
  v11 = (v5 | a3) == 0;
  v12 = a3 + 8 * v5;
  v13 = v8 + v12;
  v24[v5] = v7 | a2 & -v7;
  v14 = bswap32(v9);
  if ( v11 )
  {
    a1[30] = -1;
    a1[29] = -512;
  }
  else
  {
    a1[29] = v13 - 512;
    if ( !v8 )
      a1[30] = v9 - 1;
  }
  v15 = &v24[v5 + 1];
  v16 = &v24[v5];
  v17 = 64 - v5;
  if ( v12 > 0x1BE )
  {
    memset(v15, 0, 63 - v5);
    v23 = bswap32(v13);
    sph_blake224_0(a1, v16, v17);
    a1[30] = -1;
    a1[29] = -512;
    memset(v24, 0, sizeof(v24));
    if ( a5 == 8 )
      v24[55] = 1;
    v26 = v23;
    v25 = v14;
    sph_blake224_0(a1, v24, 0x40u);
  }
  else
  {
    memset(v15, 0, 55 - v5);
    v19 = bswap32(v13);
    if ( a5 == 8 )
      v18 = v24[55];
    v26 = v19;
    if ( a5 == 8 )
      v18 |= 1u;
    v25 = v14;
    if ( a5 == 8 )
      v24[55] = v18;
    sph_blake224_0(a1, v16, v17);
  }
  result = a1 + 17;
  v21 = a4;
  do
  {
    v22 = *result++;
    v21 += 4;
    *(_BYTE *)(v21 - 1) = v22;
    *(_BYTE *)(v21 - 4) = HIBYTE(v22);
    *(_BYTE *)(v21 - 3) = BYTE2(v22);
    *(_BYTE *)(v21 - 2) = BYTE1(v22);
  }
  while ( &a1[a5 + 17] != result );
  return result;
}
// 7AE80: variable 'v18' is possibly undefined

//----- (0007AF5C) --------------------------------------------------------
unsigned int __fastcall sub_7AF5C(int a1, char a2, int a3, int a4, int a5)
{
  int v5; // r12
  __int64 v7; // r8
  unsigned int v8; // r0
  unsigned int v9; // lr
  unsigned int v10; // r10
  __int64 v12; // kr00_8
  unsigned int v13; // r9
  unsigned int v14; // r7
  char *v15; // r0
  char *v16; // r10
  size_t v17; // r11
  char v18; // r3
  unsigned int v19; // r8
  int v20; // r7
  int *v21; // r5
  int *v22; // r7
  int v23; // r3
  unsigned int v24; // r2
  unsigned int result; // r0
  char v26; // r3
  __int64 v27; // kr08_8
  __int64 v28; // [sp+0h] [bp-94h]
  char s[112]; // [sp+10h] [bp-84h] BYREF
  unsigned int v30; // [sp+80h] [bp-14h]
  unsigned int v31; // [sp+84h] [bp-10h]
  unsigned int v32; // [sp+88h] [bp-Ch]
  unsigned int v33; // [sp+8Ch] [bp-8h]

  v5 = *(_DWORD *)(a1 + 128);
  v7 = *(_QWORD *)(a1 + 232);
  v8 = *(_DWORD *)(a1 + 240);
  v9 = a3 + 8 * v5;
  v10 = *(_DWORD *)(a1 + 244);
  v28 = v7;
  v12 = v9 + v7;
  s[v5] = (128 >> a3) | a2 & -(128 >> a3);
  v13 = bswap32(v8);
  v14 = bswap32(v10);
  if ( v5 | a3 )
  {
    if ( v28 )
    {
      *(_QWORD *)(a1 + 232) = v28 - (1024 - v9);
    }
    else
    {
      v27 = v9 - 1024LL;
      *(_DWORD *)(a1 + 236) = HIDWORD(v27);
      *(_DWORD *)(a1 + 244) = (__PAIR64__(v10, v8) - 1) >> 32;
      *(_DWORD *)(a1 + 232) = v27;
      *(_DWORD *)(a1 + 240) = v8 - 1;
    }
  }
  else
  {
    *(_QWORD *)(a1 + 232) = -1024;
    *(_QWORD *)(a1 + 240) = -1;
  }
  v15 = &s[v5 + 1];
  v16 = &s[v5];
  v17 = 128 - v5;
  if ( v9 > 0x37E )
  {
    memset(v15, 0, 127 - v5);
    sph_blake384_0(a1, v16, v17);
    *(_QWORD *)(a1 + 232) = -1024;
    *(_QWORD *)(a1 + 240) = -1;
    memset(s, 0, sizeof(s));
    v26 = a5;
    v33 = bswap32(v12);
    v32 = bswap32(HIDWORD(v12));
    if ( a5 == 8 )
      v26 = 1;
    v30 = v14;
    if ( a5 == 8 )
      s[111] = v26;
    v31 = v13;
    sph_blake384_0(a1, s, 0x80u);
  }
  else
  {
    memset(v15, 0, 111 - v5);
    v18 = a5;
    v19 = bswap32(HIDWORD(v12));
    v33 = bswap32(v12);
    if ( a5 == 8 )
      v18 = s[111];
    v32 = v19;
    v30 = v14;
    if ( a5 == 8 )
      v18 |= 1u;
    v31 = v13;
    if ( a5 == 8 )
      s[111] = v18;
    sph_blake384_0(a1, v16, v17);
  }
  v20 = a1 + 8 * a5;
  v21 = (int *)(a1 + 136);
  v22 = (int *)(v20 + 136);
  do
  {
    v23 = *v21;
    v21 += 2;
    v24 = *(v21 - 1);
    a4 += 8;
    *(_BYTE *)(a4 - 1) = v23;
    result = v24 >> 8;
    *(_BYTE *)(a4 - 4) = HIBYTE(v23);
    *(_BYTE *)(a4 - 5) = v24;
    *(_BYTE *)(a4 - 8) = HIBYTE(v24);
    *(_BYTE *)(a4 - 7) = BYTE2(v24);
    *(_BYTE *)(a4 - 6) = BYTE1(v24);
    *(_BYTE *)(a4 - 3) = BYTE2(v23);
    *(_BYTE *)(a4 - 2) = BYTE1(v23);
  }
  while ( v22 != v21 );
  return result;
}

//----- (0007B180) --------------------------------------------------------
int __fastcall sub_7B180(int a1, int *a2)
{
  int *v3; // r4
  int v4; // lr
  int *v5; // r6
  int v6; // r0
  int v7; // r1
  int v8; // r2
  int v9; // r3

  v3 = a2;
  v4 = a1 + 136;
  v5 = a2 + 16;
  do
  {
    v4 += 16;
    v6 = *v3;
    v7 = v3[1];
    v8 = v3[2];
    v9 = v3[3];
    v3 += 4;
    *(_DWORD *)(v4 - 16) = v6;
    *(_DWORD *)(v4 - 12) = v7;
    *(_DWORD *)(v4 - 8) = v8;
    *(_DWORD *)(v4 - 4) = v9;
  }
  while ( v3 != v5 );
  *(_QWORD *)(a1 + 240) = 0;
  *(_QWORD *)(a1 + 232) = 0;
  *(_DWORD *)(a1 + 128) = 0;
  *(_DWORD *)(a1 + 200) = 0;
  *(_DWORD *)(a1 + 204) = 0;
  *(_DWORD *)(a1 + 208) = 0;
  *(_DWORD *)(a1 + 212) = 0;
  *(_DWORD *)(a1 + 216) = 0;
  *(_DWORD *)(a1 + 220) = 0;
  *(_DWORD *)(a1 + 224) = 0;
  *(_DWORD *)(a1 + 228) = 0;
  return 0;
}

//----- (0007B20C) --------------------------------------------------------
int __fastcall sub_7B20C(_DWORD *a1, int *a2)
{
  int *v2; // r12
  int v4; // r0
  int v5; // r1
  int v6; // r2
  int v7; // r3
  int v8; // r0
  int v9; // r1
  int v10; // r2
  int v11; // r3

  v2 = a2;
  v4 = *a2;
  v5 = a2[1];
  v6 = v2[2];
  v7 = v2[3];
  v2 += 4;
  a1[17] = v4;
  a1[18] = v5;
  a1[19] = v6;
  a1[20] = v7;
  v8 = *v2;
  v9 = v2[1];
  v10 = v2[2];
  v11 = v2[3];
  a1[30] = 0;
  a1[21] = v8;
  a1[22] = v9;
  a1[23] = v10;
  a1[24] = v11;
  a1[29] = 0;
  a1[16] = 0;
  a1[25] = 0;
  a1[26] = 0;
  a1[27] = 0;
  a1[28] = 0;
  return 0;
}

//----- (0007B278) --------------------------------------------------------
int __fastcall sph_blake224_init(_DWORD *a1)
{
  return sub_7B20C(a1, dword_EC508);
}
// EC508: using guessed type int dword_EC508[8];

//----- (0007B288) --------------------------------------------------------
int __fastcall sph_blake224_addbits_and_close(unsigned int *a1, char a2, int a3, int a4)
{
  sub_7ADD0(a1, a2, a3, a4, 7);
  return sub_7B20C(a1, dword_EC508);
}
// EC508: using guessed type int dword_EC508[8];

//----- (0007B2B8) --------------------------------------------------------
int __fastcall sph_blake224_close(unsigned int *a1, int a2)
{
  return sph_blake224_addbits_and_close(a1, 0, 0, a2);
}

//----- (0007B2C8) --------------------------------------------------------
int __fastcall sph_blake256_init(_DWORD *a1)
{
  return sub_7B20C(a1, dword_EC528);
}
// EC528: using guessed type int dword_EC528[8];

//----- (0007B2D8) --------------------------------------------------------
int __fastcall sph_blake256_addbits_and_close(unsigned int *a1, char a2, int a3, int a4)
{
  sub_7ADD0(a1, a2, a3, a4, 8);
  return sub_7B20C(a1, dword_EC528);
}
// EC528: using guessed type int dword_EC528[8];

//----- (0007B308) --------------------------------------------------------
int __fastcall sph_blake256_close(unsigned int *a1, int a2)
{
  return sph_blake256_addbits_and_close(a1, 0, 0, a2);
}

//----- (0007B318) --------------------------------------------------------
int __fastcall sph_blake256_set_rounds(int result)
{
  blake256_rounds = result;
  return result;
}
// 106690: using guessed type int blake256_rounds;

//----- (0007B328) --------------------------------------------------------
int __fastcall sph_blake384_init(int a1)
{
  return sub_7B180(a1, dword_EC548);
}
// EC548: using guessed type int dword_EC548[16];

//----- (0007B338) --------------------------------------------------------
int __fastcall sph_blake384_addbits_and_close(int a1, char a2, int a3, int a4)
{
  sub_7AF5C(a1, a2, a3, a4, 6);
  return sub_7B180(a1, dword_EC548);
}
// EC548: using guessed type int dword_EC548[16];

//----- (0007B368) --------------------------------------------------------
int __fastcall sph_blake384_close(int a1, int a2)
{
  return sph_blake384_addbits_and_close(a1, 0, 0, a2);
}

//----- (0007B378) --------------------------------------------------------
int __fastcall sph_blake512_init(int a1)
{
  return sub_7B180(a1, dword_EC588);
}
// EC588: using guessed type int dword_EC588[16];

//----- (0007B388) --------------------------------------------------------
int __fastcall sph_blake512_addbits_and_close(int a1, char a2, int a3, int a4)
{
  sub_7AF5C(a1, a2, a3, a4, 8);
  return sub_7B180(a1, dword_EC588);
}
// EC588: using guessed type int dword_EC588[16];

//----- (0007B3B8) --------------------------------------------------------
int __fastcall sph_blake512_close(int a1, int a2)
{
  return sph_blake512_addbits_and_close(a1, 0, 0, a2);
}

//----- (0007B3C8) --------------------------------------------------------
int __fastcall decred_hash(int a1, char *a2)
{
  unsigned int v5[32]; // [sp+4h] [bp-80h] BYREF

  blake256_rounds = 14;
  sub_7B20C(v5, dword_EC528);
  sph_blake224_0(v5, a2, 0xB4u);
  return sph_blake256_addbits_and_close(v5, 0, 0, a1);
}
// EC528: using guessed type int dword_EC528[8];
// 106690: using guessed type int blake256_rounds;

//----- (0007B424) --------------------------------------------------------
int __fastcall blake2s_init_param(int *a1, int *a2)
{
  int *v2; // r5
  int *v5; // r1
  int v6; // r0
  int *v7; // r3
  int v8; // t1

  v2 = a1 + 8;
  memset(a1 + 8, 0, 0x95u);
  a1[1] = -1150833019;
  a1[2] = 1013904242;
  a1[3] = -1521486534;
  a1[4] = 1359893119;
  a1[5] = -1694144372;
  v5 = a2;
  a1[6] = 528734635;
  v6 = 1779033703;
  v7 = a1;
  a1[7] = 1541459225;
  *a1 = 1779033703;
  while ( 1 )
  {
    v8 = *v5++;
    *v7++ = v8 ^ v6;
    if ( v7 == v2 )
      break;
    v6 = *v7;
  }
  return 0;
}

//----- (0007B4D4) --------------------------------------------------------
int __fastcall blake2s_init(int *a1, int a2)
{
  int v3; // [sp+0h] [bp-28h] BYREF
  char v4; // [sp+4h] [bp-24h]
  char v5; // [sp+5h] [bp-23h]
  char v6; // [sp+6h] [bp-22h]
  char v7; // [sp+7h] [bp-21h]
  char v8; // [sp+8h] [bp-20h]
  char v9; // [sp+9h] [bp-1Fh]
  char v10; // [sp+Ah] [bp-1Eh]
  char v11; // [sp+Bh] [bp-1Dh]
  char v12; // [sp+Ch] [bp-1Ch]
  char v13; // [sp+Dh] [bp-1Bh]
  char v14; // [sp+Eh] [bp-1Ah]
  char v15; // [sp+Fh] [bp-19h]
  int v16; // [sp+10h] [bp-18h]
  int v17; // [sp+14h] [bp-14h]
  int v18; // [sp+18h] [bp-10h]
  int v19; // [sp+1Ch] [bp-Ch]

  if ( (unsigned int)(a2 - 1) > 0x1F )
    return -1;
  v3 = (unsigned __int8)a2 | 0x1010000;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v18 = 0;
  v17 = 0;
  v19 = 0;
  return blake2s_init_param(a1, &v3);
}

//----- (0007B558) --------------------------------------------------------
int __fastcall blake2s_compress(_DWORD *a1, int *a2)
{
  int *v3; // r2
  int *v4; // r0
  _DWORD *v5; // t1
  _DWORD *v6; // r2
  int v7; // t1
  int v8; // r6
  int v9; // r11
  int v10; // r8
  int v11; // r0
  int v12; // r1
  int v13; // r12
  int v14; // lr
  int v15; // r10
  int v16; // r9
  int v17; // r7
  int v18; // r3
  int v19; // r2
  int v20; // r5
  int v21; // r1
  int v22; // r6
  int v23; // r8
  int v24; // r4
  int v25; // lr
  int v26; // r12
  int v27; // r0
  int v28; // r10
  int v29; // r11
  int v30; // r9
  int v31; // r3
  int v32; // r8
  int v33; // r2
  int v34; // r1
  int v35; // r12
  int v36; // r5
  int v37; // r11
  int v38; // r2
  int v39; // r0
  int v40; // r6
  int v41; // r4
  int v42; // r7
  int v43; // r3
  int v44; // lr
  int v45; // r10
  int v46; // r9
  int v47; // r1
  int v48; // r2
  int v49; // r8
  int v50; // r5
  int v51; // r0
  int v52; // r6
  int v53; // r7
  int v54; // r4
  int v55; // lr
  int v56; // t2
  int v57; // r10
  int v58; // r11
  int v59; // r3
  int v60; // r9
  int v61; // r1
  int v62; // r2
  int v63; // r5
  int v64; // r6
  int v65; // r7
  int v66; // r8
  int v67; // r10
  int v68; // r4
  int v69; // r12
  int v70; // r3
  int v71; // r0
  int v72; // r11
  int v73; // r9
  int v74; // r1
  int v75; // r2
  int v76; // r5
  int v77; // r7
  int v78; // r8
  int v79; // r6
  int v80; // r0
  int v81; // r4
  int v82; // r11
  int v83; // r12
  int v84; // lr
  int v85; // r9
  int v86; // r2
  int v87; // r3
  int v88; // r1
  int v89; // r5
  int v90; // r8
  int v91; // r0
  int v92; // r6
  int v93; // r10
  int v94; // r4
  int v95; // r7
  int v96; // lr
  int v97; // r12
  int v98; // r3
  int v99; // r1
  int v100; // r11
  int v101; // r2
  int v102; // r9
  int v103; // r5
  int v104; // r0
  int v105; // r8
  int v106; // r6
  int v107; // r4
  int v108; // r7
  int v109; // lr
  int v110; // r11
  int v111; // r9
  int v112; // r10
  int v113; // r1
  int v114; // r2
  int v115; // r5
  int v116; // r7
  int v117; // r8
  int v118; // r6
  int v119; // r11
  int v120; // r0
  int v121; // t2
  int v122; // r4
  int v123; // r10
  int v124; // r12
  int v125; // r1
  int v126; // r3
  int v127; // r9
  int v128; // r2
  int v129; // r5
  int v130; // r7
  int v131; // r8
  int v132; // r6
  int v133; // r0
  int v134; // r4
  int v135; // r12
  int v136; // lr
  int v137; // r10
  int v138; // r9
  int v139; // r2
  int v140; // r3
  int v141; // r1
  int v142; // r5
  int v143; // r8
  int v144; // r0
  int v145; // r6
  int v146; // r11
  int v147; // r4
  int v148; // r7
  int v149; // lr
  int v150; // r12
  int v151; // r10
  int v152; // r3
  int v153; // r1
  int v154; // r10
  int v155; // r2
  int v156; // r9
  int v157; // r5
  int v158; // r0
  int v159; // r8
  int v160; // r12
  int v161; // r6
  int v162; // r4
  int v163; // r7
  int v164; // lr
  int v165; // r10
  int v166; // r9
  int v167; // r11
  int v168; // r1
  int v169; // r2
  int v170; // r5
  int v171; // r7
  int v172; // r8
  int v173; // r6
  int v174; // r10
  int v175; // r0
  int v176; // t2
  int v177; // r4
  int v178; // r11
  int v179; // r12
  int v180; // r1
  int v181; // r3
  int v182; // r9
  int v183; // r2
  int v184; // r5
  int v185; // r7
  int v186; // r8
  int v187; // r6
  int v188; // r0
  int v189; // r4
  int v190; // r12
  int v191; // lr
  int v192; // r11
  int v193; // r9
  int v194; // r2
  int v195; // r3
  int v196; // r1
  int v197; // r5
  int v198; // r8
  int v199; // r0
  int v200; // r6
  int v201; // r10
  int v202; // r4
  int v203; // r7
  int v204; // lr
  int v205; // r12
  int v206; // r3
  int v207; // r1
  int v208; // r11
  int v209; // r2
  int v210; // r9
  int v211; // r5
  int v212; // r0
  int v213; // r8
  int v214; // r6
  int v215; // r4
  int v216; // r7
  int v217; // lr
  int v218; // r11
  int v219; // r9
  int v220; // r10
  int v221; // r1
  int v222; // r2
  int v223; // t2
  int v224; // r5
  int v225; // r7
  int v226; // r8
  int v227; // r6
  int v228; // r11
  int v229; // r0
  int v230; // t2
  int v231; // r4
  int v232; // r10
  int v233; // r9
  int v234; // r12
  int v235; // r1
  int v236; // r3
  int v237; // r2
  int v238; // r5
  int v239; // r7
  int v240; // r8
  int v241; // r6
  int v242; // r0
  int v243; // r4
  int v244; // r12
  int v245; // lr
  int v246; // r10
  int v247; // r9
  int v248; // r2
  int v249; // r3
  int v250; // r1
  int v251; // r5
  int v252; // r8
  int v253; // r0
  int v254; // r6
  int v255; // r11
  int v256; // r4
  int v257; // r7
  int v258; // lr
  int v259; // r12
  int v260; // r3
  int v261; // r10
  int v262; // r1
  int v263; // r9
  int v264; // r2
  int v265; // r5
  int v266; // r0
  int v267; // r8
  int v268; // r6
  int v269; // r4
  int v270; // r7
  int v271; // lr
  int v272; // r10
  int v273; // r9
  int v274; // r11
  int v275; // r1
  int v276; // r2
  int v277; // r5
  int v278; // r8
  int v279; // r7
  int v280; // r6
  int v281; // r10
  int v282; // r0
  int v283; // t2
  int v284; // r4
  int v285; // r11
  int v286; // r12
  int v287; // r1
  int v288; // r3
  int v289; // r9
  int v290; // r2
  int v291; // r5
  int v292; // r7
  int v293; // r8
  int v294; // r6
  int v295; // r0
  int v296; // r4
  int v297; // r11
  int v298; // r12
  int v299; // lr
  int v300; // r9
  int v301; // r2
  int v302; // r3
  int v303; // r1
  int v304; // r5
  int v305; // r8
  int v306; // r0
  int v307; // r6
  int v308; // r10
  int v309; // r4
  int v310; // r7
  int v311; // lr
  int v312; // r12
  int v313; // r3
  int v314; // r1
  int v315; // r11
  int v316; // r2
  int v317; // r9
  int v318; // r5
  int v319; // r0
  int v320; // r8
  int v321; // r6
  int v322; // r4
  int v323; // r7
  int v324; // lr
  int v325; // r11
  int v326; // r9
  int v327; // r10
  int v328; // r1
  int v329; // r2
  int v330; // r5
  int v331; // r7
  int v332; // r8
  int v333; // r6
  int v334; // r11
  int v335; // r0
  int v336; // t2
  int v337; // r4
  int v338; // r10
  int v339; // r12
  int v340; // r1
  int v341; // r3
  int v342; // r9
  int v343; // r2
  int v344; // r5
  int v345; // r7
  int v346; // r8
  int v347; // r6
  int v348; // r0
  int v349; // r4
  int v350; // r12
  int v351; // lr
  int v352; // r10
  int v353; // r9
  int v354; // r2
  int v355; // r3
  int v356; // r1
  int v357; // r5
  int v358; // r8
  int v359; // r0
  int v360; // r6
  int v361; // r11
  int v362; // r4
  int v363; // r7
  int v364; // lr
  int v365; // r12
  int v366; // r3
  int v367; // r1
  int v368; // r10
  int v369; // r2
  int v370; // r9
  int v371; // r5
  int v372; // r0
  int v373; // r8
  int v374; // r6
  int v375; // r4
  int v376; // r7
  int v377; // lr
  int v378; // r10
  int v379; // r9
  int v380; // r11
  int v381; // r1
  int v382; // r2
  int v383; // r5
  int v384; // r7
  int v385; // r8
  int v386; // r6
  int v387; // r10
  int v388; // r0
  int v389; // t2
  int v390; // r4
  int v391; // r11
  int v392; // r12
  int v393; // r1
  int v394; // r3
  int v395; // r9
  int v396; // r2
  int v397; // r5
  int v398; // r7
  int v399; // r8
  int v400; // r6
  int v401; // r0
  int v402; // r4
  int v403; // r12
  int v404; // lr
  int v405; // r11
  int v406; // r9
  int v407; // r2
  int v408; // r3
  int v409; // r1
  int v410; // r5
  int v411; // r8
  int v412; // r0
  int v413; // r6
  int v414; // r10
  int v415; // r4
  int v416; // r7
  int v417; // lr
  int v418; // r12
  int v419; // r3
  int v420; // r1
  int v421; // r11
  int v422; // r2
  int v423; // r9
  int v424; // r5
  int v425; // r0
  int v426; // r8
  int v427; // r6
  int v428; // r4
  int v429; // r7
  int v430; // lr
  int v431; // r11
  int v432; // r9
  int v433; // r10
  int v434; // r1
  int v435; // r2
  int v436; // r5
  int v437; // r7
  int v438; // r8
  int v439; // r6
  int v440; // r11
  int v441; // r0
  int v442; // t2
  int v443; // r4
  int v444; // r10
  int v445; // r12
  int v446; // r1
  int v447; // r3
  int v448; // r9
  int v449; // r2
  int v450; // r5
  int v451; // r7
  int v452; // r8
  int v453; // r6
  int v454; // r0
  int v455; // r4
  int v456; // r12
  int v457; // lr
  int v458; // r10
  int v459; // r9
  int v460; // r2
  int v461; // r3
  int v462; // r1
  int v463; // r5
  int v464; // r8
  int v465; // r0
  int v466; // r6
  int v467; // r11
  int v468; // r4
  int v469; // r7
  int v470; // lr
  int v471; // r12
  int v472; // r3
  int v473; // r10
  int v474; // r1
  int v475; // r9
  int v476; // r2
  int v477; // r5
  int v478; // r0
  int v479; // r8
  int v480; // r6
  int v481; // r12
  int v482; // r4
  int v483; // r7
  int v484; // lr
  int v485; // r11
  int v486; // r3
  int v487; // r10
  int v488; // r9
  int v489; // r1
  int v490; // r2
  int v491; // r5
  int v492; // r8
  int v493; // r7
  int v494; // r0
  int v495; // r6
  int v496; // r10
  int v497; // r12
  int v498; // lr
  int v499; // r11
  int v500; // r1
  int v501; // r9
  int v502; // r2
  int v503; // r6
  int v504; // r8
  int v505; // lr
  int v506; // r4
  int v507; // r0
  int v508; // r5
  int v509; // r7
  int v510; // r11
  int v511; // r3
  int v512; // r1
  int v513; // r10
  int v514; // r10
  int v515; // r2
  int v516; // r3
  int v517; // r9
  int v518; // r5
  int v519; // r6
  int v520; // r0
  int v521; // r8
  int v522; // r7
  int v523; // r10
  int v524; // lr
  int v525; // r1
  int v526; // r11
  int v527; // r3
  int v528; // r9
  int v529; // r2
  int v530; // r8
  int v531; // r0
  int v532; // r6
  int v533; // r10
  int v534; // r7
  int v535; // r12
  int v536; // lr
  int v537; // r11
  int v538; // r12
  int *v539; // r3
  _DWORD *v540; // r2
  int v541; // t1
  int v542; // t1
  int v544; // [sp+4h] [bp-A0h]
  int v545; // [sp+4h] [bp-A0h]
  int v546; // [sp+4h] [bp-A0h]
  int v547; // [sp+4h] [bp-A0h]
  int v548; // [sp+4h] [bp-A0h]
  int v549; // [sp+4h] [bp-A0h]
  int v550; // [sp+4h] [bp-A0h]
  int v551; // [sp+4h] [bp-A0h]
  int v552; // [sp+4h] [bp-A0h]
  int v553; // [sp+4h] [bp-A0h]
  int v554; // [sp+4h] [bp-A0h]
  int v555; // [sp+4h] [bp-A0h]
  int v556; // [sp+4h] [bp-A0h]
  int v557; // [sp+4h] [bp-A0h]
  int v558; // [sp+4h] [bp-A0h]
  int v559; // [sp+4h] [bp-A0h]
  int v560; // [sp+4h] [bp-A0h]
  int v561; // [sp+4h] [bp-A0h]
  int v562; // [sp+4h] [bp-A0h]
  int v563; // [sp+4h] [bp-A0h]
  int v564; // [sp+4h] [bp-A0h]
  int v565; // [sp+4h] [bp-A0h]
  int v566; // [sp+4h] [bp-A0h]
  int v567; // [sp+8h] [bp-9Ch]
  int v568; // [sp+8h] [bp-9Ch]
  int v569; // [sp+8h] [bp-9Ch]
  int v570; // [sp+8h] [bp-9Ch]
  int v571; // [sp+8h] [bp-9Ch]
  int v572; // [sp+8h] [bp-9Ch]
  int v573; // [sp+8h] [bp-9Ch]
  int v574; // [sp+8h] [bp-9Ch]
  int v575; // [sp+8h] [bp-9Ch]
  int v576; // [sp+8h] [bp-9Ch]
  int v577; // [sp+8h] [bp-9Ch]
  int v578; // [sp+8h] [bp-9Ch]
  int v579; // [sp+8h] [bp-9Ch]
  int v580; // [sp+8h] [bp-9Ch]
  int v581; // [sp+8h] [bp-9Ch]
  int v582; // [sp+8h] [bp-9Ch]
  int v583; // [sp+8h] [bp-9Ch]
  int v584; // [sp+8h] [bp-9Ch]
  int v585; // [sp+8h] [bp-9Ch]
  int v586; // [sp+8h] [bp-9Ch]
  int v587; // [sp+8h] [bp-9Ch]
  int v588; // [sp+Ch] [bp-98h]
  int v589; // [sp+Ch] [bp-98h]
  int v590; // [sp+Ch] [bp-98h]
  int v591; // [sp+Ch] [bp-98h]
  int v592; // [sp+Ch] [bp-98h]
  int v593; // [sp+Ch] [bp-98h]
  int v594; // [sp+Ch] [bp-98h]
  int v595; // [sp+Ch] [bp-98h]
  int v596; // [sp+Ch] [bp-98h]
  int v597; // [sp+Ch] [bp-98h]
  int v598; // [sp+Ch] [bp-98h]
  int v599; // [sp+Ch] [bp-98h]
  int v600; // [sp+Ch] [bp-98h]
  int v601; // [sp+Ch] [bp-98h]
  int v602; // [sp+Ch] [bp-98h]
  int v603; // [sp+Ch] [bp-98h]
  int v604; // [sp+Ch] [bp-98h]
  int v605; // [sp+Ch] [bp-98h]
  int v606; // [sp+Ch] [bp-98h]
  int v607; // [sp+Ch] [bp-98h]
  int v608; // [sp+10h] [bp-94h]
  int v609; // [sp+10h] [bp-94h]
  int v610; // [sp+10h] [bp-94h]
  int v611; // [sp+10h] [bp-94h]
  int v612; // [sp+10h] [bp-94h]
  int v613; // [sp+10h] [bp-94h]
  int v614; // [sp+10h] [bp-94h]
  int v615; // [sp+10h] [bp-94h]
  int v616; // [sp+10h] [bp-94h]
  int v617; // [sp+10h] [bp-94h]
  int v618; // [sp+10h] [bp-94h]
  int v619; // [sp+10h] [bp-94h]
  int v620; // [sp+14h] [bp-90h]
  int v621; // [sp+14h] [bp-90h]
  int v622; // [sp+14h] [bp-90h]
  int v623; // [sp+14h] [bp-90h]
  int v624; // [sp+14h] [bp-90h]
  int v625; // [sp+14h] [bp-90h]
  int v626; // [sp+14h] [bp-90h]
  int v627; // [sp+14h] [bp-90h]
  int v628; // [sp+14h] [bp-90h]
  int v629; // [sp+14h] [bp-90h]
  int v630; // [sp+14h] [bp-90h]
  int v631; // [sp+14h] [bp-90h]
  int v632; // [sp+14h] [bp-90h]
  int v633; // [sp+14h] [bp-90h]
  int v634; // [sp+14h] [bp-90h]
  int v635; // [sp+14h] [bp-90h]
  int v636; // [sp+14h] [bp-90h]
  _DWORD *v637; // [sp+18h] [bp-8Ch]
  _DWORD *v638; // [sp+1Ch] [bp-88h] BYREF
  int v639; // [sp+20h] [bp-84h]
  int v640; // [sp+24h] [bp-80h]
  int v641; // [sp+28h] [bp-7Ch]
  int v642; // [sp+2Ch] [bp-78h]
  int v643; // [sp+30h] [bp-74h]
  int v644; // [sp+34h] [bp-70h]
  int v645; // [sp+38h] [bp-6Ch]
  int v646; // [sp+3Ch] [bp-68h]
  int v647; // [sp+40h] [bp-64h]
  int v648; // [sp+44h] [bp-60h]
  int v649; // [sp+48h] [bp-5Ch]
  int v650; // [sp+4Ch] [bp-58h]
  int v651; // [sp+50h] [bp-54h]
  int v652; // [sp+54h] [bp-50h]
  int v653; // [sp+58h] [bp-4Ch]
  int v654; // [sp+5Ch] [bp-48h] BYREF
  int v655; // [sp+60h] [bp-44h]
  int v656; // [sp+64h] [bp-40h] BYREF
  int v657; // [sp+68h] [bp-3Ch]
  int v658; // [sp+6Ch] [bp-38h]
  int v659; // [sp+70h] [bp-34h]
  int v660; // [sp+74h] [bp-30h]
  int v661; // [sp+78h] [bp-2Ch]
  int v662; // [sp+7Ch] [bp-28h]
  int v663; // [sp+80h] [bp-24h]
  int v664; // [sp+84h] [bp-20h]
  int v665; // [sp+88h] [bp-1Ch]
  int v666; // [sp+8Ch] [bp-18h]
  int v667; // [sp+90h] [bp-14h]
  int v668; // [sp+94h] [bp-10h]
  int v669; // [sp+98h] [bp-Ch]
  int v670; // [sp+9Ch] [bp-8h]

  v3 = (int *)&v638;
  v4 = &v654;
  do
  {
    v5 = (_DWORD *)*a2++;
    v3[1] = (int)v5;
    ++v3;
  }
  while ( &v654 != v3 );
  v6 = a1 - 1;
  v638 = a1 - 1;
  do
  {
    v7 = v6[1];
    ++v6;
    v4[1] = v7;
    ++v4;
  }
  while ( a1 + 7 != v6 );
  v637 = v6;
  v8 = v661 + v657 + v643;
  v9 = v660 + v656 + v641;
  v10 = v659 + v655 + v639;
  v11 = v662 + v658 + v645;
  v12 = __ROR4__(v10 ^ 0x510E527F ^ a1[8], 16);
  v13 = __ROR4__(v11 ^ 0x5BE0CD19 ^ a1[11], 16);
  v608 = __ROR4__(v9 ^ 0x9B05688C ^ a1[9], 16);
  v14 = __ROR4__(v8 ^ 0x1F83D9AB ^ a1[10], 16);
  v15 = v608 - 1150833019;
  v16 = v12 + 1779033703;
  v17 = v13 - 1521486534;
  v18 = __ROR4__(v660 ^ (v608 - 1150833019), 12);
  v19 = __ROR4__(v662 ^ (v13 - 1521486534), 12);
  v588 = v12;
  v20 = v14 + 1013904242;
  v544 = __ROR4__(v659 ^ (v12 + 1779033703), 12);
  v21 = __ROR4__(v661 ^ (v14 + 1013904242), 12);
  v567 = v9 + v642 + v18;
  v22 = v8 + v644 + v21;
  v23 = v10 + v640 + v544;
  v24 = v11 + v646 + v19;
  v25 = __ROR4__(v14 ^ v22, 8);
  v26 = __ROR4__(v13 ^ v24, 8);
  v609 = __ROR4__(v608 ^ v567, 8);
  v27 = __ROR4__(v588 ^ v23, 8);
  v28 = v15 + v609;
  v29 = v20 + v25;
  v589 = v16 + v27;
  v30 = __ROR4__(v544 ^ (v16 + v27), 7);
  v31 = __ROR4__(v18 ^ v28, 7);
  v32 = v23 + v647 + v31;
  v545 = v17 + v26;
  v33 = v19 ^ (v17 + v26);
  v34 = __ROR4__(v21 ^ (v20 + v25), 7);
  v35 = __ROR4__(v26 ^ v32, 16);
  v36 = v567 + v649 + v34;
  v37 = v29 + v35;
  v38 = __ROR4__(v33, 7);
  v39 = __ROR4__(v27 ^ v36, 16);
  v40 = v22 + v651 + v38;
  v41 = v24 + v653 + v30;
  v42 = __ROR4__(v609 ^ v40, 16);
  v43 = __ROR4__(v31 ^ v37, 12);
  v546 = v545 + v39;
  v44 = __ROR4__(v25 ^ v41, 16);
  v45 = v28 + v44;
  v46 = __ROR4__(v30 ^ v45, 12);
  v568 = v589 + v42;
  v47 = __ROR4__(v34 ^ v546, 12);
  v48 = __ROR4__(v38 ^ (v589 + v42), 12);
  v49 = v32 + v648 + v43;
  v50 = v36 + v650 + v47;
  v51 = __ROR4__(v39 ^ v50, 8);
  v52 = v40 + v652 + v48;
  v53 = __ROR4__(v42 ^ v52, 8);
  v54 = v41 + v654 + v46;
  v55 = __ROR4__(v44 ^ v54, 8);
  v56 = __ROR4__(v35 ^ v49, 8);
  v57 = v45 + v55;
  v58 = v37 + v56;
  v59 = __ROR4__(v43 ^ v58, 7);
  v60 = __ROR4__(v46 ^ v57, 7);
  v547 = v546 + v51;
  v569 = v568 + v53;
  v61 = __ROR4__(v47 ^ v547, 7);
  v62 = __ROR4__(v48 ^ v569, 7);
  v63 = v643 + v50 + v59;
  v64 = v648 + v52 + v61;
  v65 = __ROR4__(v53 ^ v63, 16);
  v66 = v49 + v653 + v60;
  v67 = v57 + v65;
  v620 = __ROR4__(v55 ^ v64, 16);
  v68 = v652 + v54 + v62;
  v590 = v58 + v620;
  v69 = __ROR4__(v56 ^ v68, 16);
  v70 = __ROR4__(v59 ^ v67, 12);
  v71 = __ROR4__(v51 ^ v66, 16);
  v72 = v569 + v71;
  v610 = v547 + v69;
  v73 = __ROR4__(v60 ^ (v569 + v71), 12);
  v74 = __ROR4__(v61 ^ v590, 12);
  v75 = __ROR4__(v62 ^ (v547 + v69), 12);
  v76 = v647 + v63 + v70;
  v77 = __ROR4__(v65 ^ v76, 8);
  v78 = v649 + v66 + v73;
  v79 = v654 + v64 + v74;
  v548 = v67 + v77;
  v80 = __ROR4__(v71 ^ v78, 8);
  v81 = v645 + v68 + v75;
  v82 = v72 + v80;
  v83 = __ROR4__(v69 ^ v81, 8);
  v84 = __ROR4__(v620 ^ v79, 8);
  v85 = __ROR4__(v73 ^ v82, 7);
  v570 = v590 + v84;
  v86 = __ROR4__(v75 ^ (v610 + v83), 7);
  v87 = __ROR4__(v70 ^ (v67 + v77), 7);
  v88 = __ROR4__(v74 ^ (v590 + v84), 7);
  v89 = v639 + v76 + v88;
  v90 = v640 + v78 + v87;
  v91 = __ROR4__(v80 ^ v89, 16);
  v92 = v650 + v79 + v86;
  v93 = v610 + v83 + v91;
  v94 = v644 + v81 + v85;
  v95 = __ROR4__(v77 ^ v92, 16);
  v96 = __ROR4__(v84 ^ v94, 16);
  v97 = __ROR4__(v83 ^ v90, 16);
  v611 = v82 + v95;
  v98 = __ROR4__(v87 ^ (v570 + v97), 12);
  v99 = __ROR4__(v88 ^ v93, 12);
  v100 = v548 + v96;
  v101 = __ROR4__(v86 ^ v611, 12);
  v102 = __ROR4__(v85 ^ (v548 + v96), 12);
  v103 = v641 + v89 + v99;
  v104 = __ROR4__(v91 ^ v103, 8);
  v105 = v651 + v90 + v98;
  v106 = v646 + v92 + v101;
  v107 = v642 + v94 + v102;
  v621 = __ROR4__(v97 ^ v105, 8);
  v108 = __ROR4__(v95 ^ v106, 8);
  v109 = __ROR4__(v96 ^ v107, 8);
  v110 = v100 + v109;
  v591 = v93 + v104;
  v111 = __ROR4__(v102 ^ v110, 7);
  v549 = v570 + v97 + v621;
  v112 = v611 + v108;
  v113 = __ROR4__(v99 ^ v591, 7);
  v114 = __ROR4__(v101 ^ (v611 + v108), 7);
  v571 = __ROR4__(v98 ^ v549, 7);
  v115 = v651 + v103 + v571;
  v116 = __ROR4__(v108 ^ v115, 16);
  v117 = v650 + v105 + v111;
  v118 = v644 + v106 + v113;
  v119 = v110 + v116;
  v120 = __ROR4__(v104 ^ v117, 16);
  v121 = __ROR4__(v109 ^ v118, 16);
  v122 = v654 + v107 + v114;
  v123 = v112 + v120;
  v124 = __ROR4__(v621 ^ v122, 16);
  v622 = v549 + v121;
  v125 = __ROR4__(v113 ^ (v549 + v121), 12);
  v592 = v591 + v124;
  v126 = __ROR4__(v571 ^ v119, 12);
  v127 = __ROR4__(v111 ^ v123, 12);
  v128 = __ROR4__(v114 ^ v592, 12);
  v129 = v639 + v115 + v126;
  v130 = __ROR4__(v116 ^ v129, 8);
  v131 = v647 + v117 + v127;
  v132 = v641 + v118 + v125;
  v133 = __ROR4__(v120 ^ v131, 8);
  v134 = v652 + v122 + v128;
  v550 = v119 + v130;
  v135 = __ROR4__(v124 ^ v134, 8);
  v136 = __ROR4__(v121 ^ v132, 8);
  v137 = v123 + v133;
  v572 = v622 + v136;
  v138 = __ROR4__(v127 ^ v137, 7);
  v139 = __ROR4__(v128 ^ (v592 + v135), 7);
  v140 = __ROR4__(v126 ^ (v119 + v130), 7);
  v141 = __ROR4__(v125 ^ (v622 + v136), 7);
  v142 = v642 + v129 + v141;
  v143 = v649 + v131 + v140;
  v144 = __ROR4__(v133 ^ v142, 16);
  v145 = v646 + v132 + v139;
  v146 = v592 + v135 + v144;
  v147 = v648 + v134 + v138;
  v148 = __ROR4__(v130 ^ v145, 16);
  v149 = __ROR4__(v136 ^ v147, 16);
  v150 = __ROR4__(v135 ^ v143, 16);
  v612 = v137 + v148;
  v151 = v550;
  v551 = v572 + v150;
  v152 = __ROR4__(v140 ^ (v572 + v150), 12);
  v153 = __ROR4__(v141 ^ v146, 12);
  v154 = v151 + v149;
  v155 = __ROR4__(v139 ^ v612, 12);
  v156 = __ROR4__(v138 ^ v154, 12);
  v157 = v645 + v142 + v153;
  v158 = __ROR4__(v144 ^ v157, 8);
  v159 = v653 + v143 + v152;
  v160 = __ROR4__(v150 ^ v159, 8);
  v161 = v640 + v145 + v155;
  v162 = v643 + v147 + v156;
  v163 = __ROR4__(v148 ^ v161, 8);
  v164 = __ROR4__(v149 ^ v162, 8);
  v593 = v146 + v158;
  v165 = v154 + v164;
  v166 = __ROR4__(v156 ^ v165, 7);
  v552 = v551 + v160;
  v167 = v612 + v163;
  v168 = __ROR4__(v153 ^ v593, 7);
  v169 = __ROR4__(v155 ^ (v612 + v163), 7);
  v573 = __ROR4__(v152 ^ v552, 7);
  v170 = v642 + v157 + v573;
  v171 = __ROR4__(v163 ^ v170, 16);
  v172 = v646 + v159 + v166;
  v173 = v652 + v161 + v168;
  v174 = v165 + v171;
  v175 = __ROR4__(v158 ^ v172, 16);
  v176 = __ROR4__(v164 ^ v173, 16);
  v177 = v650 + v162 + v169;
  v178 = v167 + v175;
  v179 = __ROR4__(v160 ^ v177, 16);
  v623 = v552 + v176;
  v180 = __ROR4__(v168 ^ (v552 + v176), 12);
  v594 = v593 + v179;
  v181 = __ROR4__(v573 ^ v174, 12);
  v182 = __ROR4__(v166 ^ v178, 12);
  v183 = __ROR4__(v169 ^ v594, 12);
  v184 = v640 + v170 + v181;
  v185 = __ROR4__(v171 ^ v184, 8);
  v186 = v648 + v172 + v182;
  v187 = v651 + v173 + v180;
  v188 = __ROR4__(v175 ^ v186, 8);
  v189 = v653 + v177 + v183;
  v553 = v174 + v185;
  v190 = __ROR4__(v179 ^ v189, 8);
  v191 = __ROR4__(v176 ^ v187, 8);
  v192 = v178 + v188;
  v574 = v623 + v191;
  v193 = __ROR4__(v182 ^ v192, 7);
  v194 = __ROR4__(v183 ^ (v594 + v190), 7);
  v195 = __ROR4__(v181 ^ (v174 + v185), 7);
  v196 = __ROR4__(v180 ^ (v623 + v191), 7);
  v197 = v644 + v184 + v196;
  v198 = v641 + v186 + v195;
  v199 = __ROR4__(v188 ^ v197, 16);
  v200 = v643 + v187 + v194;
  v201 = v594 + v190 + v199;
  v202 = v654 + v189 + v193;
  v203 = __ROR4__(v185 ^ v200, 16);
  v204 = __ROR4__(v191 ^ v202, 16);
  v205 = __ROR4__(v190 ^ v198, 16);
  v613 = v192 + v203;
  v206 = __ROR4__(v195 ^ (v574 + v205), 12);
  v207 = __ROR4__(v196 ^ v201, 12);
  v208 = v553 + v204;
  v209 = __ROR4__(v194 ^ v613, 12);
  v210 = __ROR4__(v193 ^ (v553 + v204), 12);
  v211 = v649 + v197 + v207;
  v212 = __ROR4__(v199 ^ v211, 8);
  v213 = v645 + v198 + v206;
  v214 = v639 + v200 + v209;
  v215 = v647 + v202 + v210;
  v624 = __ROR4__(v205 ^ v213, 8);
  v216 = __ROR4__(v203 ^ v214, 8);
  v217 = __ROR4__(v204 ^ v215, 8);
  v218 = v208 + v217;
  v595 = v201 + v212;
  v219 = __ROR4__(v210 ^ v218, 7);
  v554 = v574 + v205 + v624;
  v220 = v613 + v216;
  v221 = __ROR4__(v207 ^ v595, 7);
  v222 = __ROR4__(v209 ^ (v613 + v216), 7);
  v223 = __ROR4__(v206 ^ v554, 7);
  v224 = v644 + v211 + v223;
  v575 = v223;
  v225 = __ROR4__(v216 ^ v224, 16);
  v226 = v648 + v213 + v219;
  v227 = v641 + v214 + v221;
  v228 = v218 + v225;
  v229 = __ROR4__(v212 ^ v226, 16);
  v230 = __ROR4__(v217 ^ v227, 16);
  v231 = v649 + v215 + v222;
  v232 = v220 + v229;
  v233 = __ROR4__(v219 ^ v232, 12);
  v234 = __ROR4__(v624 ^ v231, 16);
  v625 = v554 + v230;
  v235 = __ROR4__(v221 ^ (v554 + v230), 12);
  v596 = v595 + v234;
  v236 = __ROR4__(v575 ^ v228, 12);
  v237 = __ROR4__(v222 ^ v596, 12);
  v238 = v646 + v224 + v236;
  v239 = __ROR4__(v225 ^ v238, 8);
  v240 = v639 + v226 + v233;
  v241 = v643 + v227 + v235;
  v242 = __ROR4__(v229 ^ v240, 8);
  v243 = v654 + v231 + v237;
  v555 = v228 + v239;
  v244 = __ROR4__(v234 ^ v243, 8);
  v245 = __ROR4__(v230 ^ v241, 8);
  v246 = v232 + v242;
  v576 = v625 + v245;
  v247 = __ROR4__(v233 ^ v246, 7);
  v248 = __ROR4__(v237 ^ (v596 + v244), 7);
  v249 = __ROR4__(v236 ^ (v228 + v239), 7);
  v250 = __ROR4__(v235 ^ (v625 + v245), 7);
  v251 = v650 + v238 + v250;
  v252 = v653 + v240 + v249;
  v253 = __ROR4__(v242 ^ v251, 16);
  v254 = v645 + v241 + v248;
  v255 = v596 + v244 + v253;
  v256 = v642 + v243 + v247;
  v257 = __ROR4__(v239 ^ v254, 16);
  v258 = __ROR4__(v245 ^ v256, 16);
  v259 = __ROR4__(v244 ^ v252, 16);
  v614 = v246 + v257;
  v260 = __ROR4__(v249 ^ (v576 + v259), 12);
  v261 = v555 + v258;
  v262 = __ROR4__(v250 ^ v255, 12);
  v263 = __ROR4__(v247 ^ (v555 + v258), 12);
  v264 = __ROR4__(v248 ^ v614, 12);
  v265 = v651 + v251 + v262;
  v266 = __ROR4__(v253 ^ v265, 8);
  v267 = v640 + v252 + v260;
  v268 = v647 + v254 + v264;
  v269 = v652 + v256 + v263;
  v626 = __ROR4__(v259 ^ v267, 8);
  v270 = __ROR4__(v257 ^ v268, 8);
  v271 = __ROR4__(v258 ^ v269, 8);
  v272 = v261 + v271;
  v597 = v255 + v266;
  v273 = __ROR4__(v263 ^ v272, 7);
  v556 = v576 + v259 + v626;
  v274 = v614 + v270;
  v275 = __ROR4__(v262 ^ v597, 7);
  v276 = __ROR4__(v264 ^ (v614 + v270), 7);
  v577 = __ROR4__(v260 ^ v556, 7);
  v277 = v645 + v265 + v577;
  v278 = v641 + v267 + v273;
  v279 = __ROR4__(v270 ^ v277, 16);
  v280 = v639 + v268 + v275;
  v281 = v272 + v279;
  v282 = __ROR4__(v266 ^ v278, 16);
  v283 = __ROR4__(v271 ^ v280, 16);
  v284 = v647 + v269 + v276;
  v285 = v274 + v282;
  v286 = __ROR4__(v626 ^ v284, 16);
  v627 = v556 + v283;
  v287 = __ROR4__(v275 ^ (v556 + v283), 12);
  v598 = v597 + v286;
  v288 = __ROR4__(v577 ^ v281, 12);
  v289 = __ROR4__(v273 ^ v285, 12);
  v290 = __ROR4__(v276 ^ v598, 12);
  v291 = v649 + v277 + v288;
  v292 = __ROR4__(v279 ^ v291, 8);
  v293 = v651 + v278 + v289;
  v294 = v650 + v280 + v287;
  v295 = __ROR4__(v282 ^ v293, 8);
  v296 = v642 + v284 + v290;
  v297 = v285 + v295;
  v298 = __ROR4__(v286 ^ v296, 8);
  v299 = __ROR4__(v283 ^ v294, 8);
  v300 = __ROR4__(v289 ^ v297, 7);
  v557 = v281 + v292;
  v578 = v627 + v299;
  v301 = __ROR4__(v290 ^ (v598 + v298), 7);
  v302 = __ROR4__(v288 ^ (v281 + v292), 7);
  v303 = __ROR4__(v287 ^ (v627 + v299), 7);
  v304 = v646 + v291 + v303;
  v305 = v643 + v293 + v302;
  v306 = __ROR4__(v295 ^ v304, 16);
  v307 = v654 + v294 + v301;
  v308 = v598 + v298 + v306;
  v309 = v640 + v296 + v300;
  v310 = __ROR4__(v292 ^ v307, 16);
  v311 = __ROR4__(v299 ^ v309, 16);
  v312 = __ROR4__(v298 ^ v305, 16);
  v615 = v297 + v310;
  v313 = __ROR4__(v302 ^ (v578 + v312), 12);
  v314 = __ROR4__(v303 ^ v308, 12);
  v315 = v557 + v311;
  v316 = __ROR4__(v301 ^ v615, 12);
  v317 = __ROR4__(v300 ^ (v557 + v311), 12);
  v318 = v644 + v304 + v314;
  v319 = __ROR4__(v306 ^ v318, 8);
  v320 = v652 + v305 + v313;
  v321 = v653 + v307 + v316;
  v322 = v648 + v309 + v317;
  v628 = __ROR4__(v312 ^ v320, 8);
  v323 = __ROR4__(v310 ^ v321, 8);
  v324 = __ROR4__(v311 ^ v322, 8);
  v325 = v315 + v324;
  v599 = v308 + v319;
  v326 = __ROR4__(v317 ^ v325, 7);
  v558 = v578 + v312 + v628;
  v327 = v615 + v323;
  v328 = __ROR4__(v314 ^ v599, 7);
  v329 = __ROR4__(v316 ^ (v615 + v323), 7);
  v579 = __ROR4__(v313 ^ v558, 7);
  v330 = v640 + v318 + v579;
  v331 = __ROR4__(v323 ^ v330, 16);
  v332 = v651 + v320 + v326;
  v333 = v653 + v321 + v328;
  v334 = v325 + v331;
  v335 = __ROR4__(v319 ^ v332, 16);
  v336 = __ROR4__(v324 ^ v333, 16);
  v337 = v643 + v322 + v329;
  v338 = v327 + v335;
  v339 = __ROR4__(v628 ^ v337, 16);
  v629 = v558 + v336;
  v340 = __ROR4__(v328 ^ (v558 + v336), 12);
  v600 = v599 + v339;
  v341 = __ROR4__(v579 ^ v334, 12);
  v342 = __ROR4__(v326 ^ v338, 12);
  v343 = __ROR4__(v329 ^ v600, 12);
  v344 = v654 + v330 + v341;
  v345 = __ROR4__(v331 ^ v344, 8);
  v346 = v644 + v332 + v342;
  v347 = v652 + v333 + v340;
  v348 = __ROR4__(v335 ^ v346, 8);
  v349 = v649 + v337 + v343;
  v559 = v334 + v345;
  v350 = __ROR4__(v339 ^ v349, 8);
  v351 = __ROR4__(v336 ^ v347, 8);
  v352 = v338 + v348;
  v580 = v629 + v351;
  v353 = __ROR4__(v342 ^ v352, 7);
  v354 = __ROR4__(v343 ^ (v600 + v350), 7);
  v355 = __ROR4__(v341 ^ (v334 + v345), 7);
  v356 = __ROR4__(v340 ^ (v629 + v351), 7);
  v357 = v645 + v344 + v356;
  v358 = v639 + v346 + v355;
  v359 = __ROR4__(v348 ^ v357, 16);
  v360 = v648 + v347 + v354;
  v361 = v600 + v350 + v359;
  v362 = v647 + v349 + v353;
  v363 = __ROR4__(v345 ^ v360, 16);
  v364 = __ROR4__(v351 ^ v362, 16);
  v365 = __ROR4__(v350 ^ v358, 16);
  v616 = v352 + v363;
  v366 = __ROR4__(v355 ^ (v580 + v365), 12);
  v367 = __ROR4__(v356 ^ v361, 12);
  v368 = v559 + v364;
  v369 = __ROR4__(v354 ^ v616, 12);
  v370 = __ROR4__(v353 ^ (v559 + v364), 12);
  v371 = v642 + v357 + v367;
  v372 = __ROR4__(v359 ^ v371, 8);
  v373 = v646 + v358 + v366;
  v374 = v641 + v360 + v369;
  v375 = v650 + v362 + v370;
  v630 = __ROR4__(v365 ^ v373, 8);
  v376 = __ROR4__(v363 ^ v374, 8);
  v377 = __ROR4__(v364 ^ v375, 8);
  v378 = v368 + v377;
  v601 = v361 + v372;
  v379 = __ROR4__(v370 ^ v378, 7);
  v560 = v580 + v365 + v630;
  v380 = v616 + v376;
  v381 = __ROR4__(v367 ^ v601, 7);
  v382 = __ROR4__(v369 ^ (v616 + v376), 7);
  v581 = __ROR4__(v366 ^ v560, 7);
  v383 = v646 + v371 + v581;
  v384 = __ROR4__(v376 ^ v383, 16);
  v385 = v652 + v373 + v379;
  v386 = v651 + v374 + v381;
  v387 = v378 + v384;
  v388 = __ROR4__(v372 ^ v385, 16);
  v389 = __ROR4__(v377 ^ v386, 16);
  v390 = v642 + v375 + v382;
  v391 = v380 + v388;
  v392 = __ROR4__(v630 ^ v390, 16);
  v631 = v560 + v389;
  v393 = __ROR4__(v381 ^ (v560 + v389), 12);
  v602 = v601 + v392;
  v394 = __ROR4__(v581 ^ v387, 12);
  v395 = __ROR4__(v379 ^ v391, 12);
  v396 = __ROR4__(v382 ^ v602, 12);
  v397 = v653 + v383 + v394;
  v398 = __ROR4__(v384 ^ v397, 8);
  v399 = v650 + v385 + v395;
  v400 = v640 + v386 + v393;
  v401 = __ROR4__(v388 ^ v399, 8);
  v402 = v648 + v390 + v396;
  v561 = v387 + v398;
  v403 = __ROR4__(v392 ^ v402, 8);
  v404 = __ROR4__(v389 ^ v400, 8);
  v405 = v391 + v401;
  v582 = v631 + v404;
  v406 = __ROR4__(v395 ^ v405, 7);
  v407 = __ROR4__(v396 ^ (v602 + v403), 7);
  v408 = __ROR4__(v394 ^ (v387 + v398), 7);
  v409 = __ROR4__(v393 ^ (v631 + v404), 7);
  v410 = v654 + v397 + v409;
  v411 = v644 + v399 + v408;
  v412 = __ROR4__(v401 ^ v410, 16);
  v413 = v647 + v400 + v407;
  v414 = v602 + v403 + v412;
  v415 = v641 + v402 + v406;
  v416 = __ROR4__(v398 ^ v413, 16);
  v417 = __ROR4__(v404 ^ v415, 16);
  v418 = __ROR4__(v403 ^ v411, 16);
  v617 = v405 + v416;
  v419 = __ROR4__(v408 ^ (v582 + v418), 12);
  v420 = __ROR4__(v409 ^ v414, 12);
  v421 = v561 + v417;
  v422 = __ROR4__(v407 ^ v617, 12);
  v423 = __ROR4__(v406 ^ (v561 + v417), 12);
  v424 = v643 + v410 + v420;
  v425 = __ROR4__(v412 ^ v424, 8);
  v426 = v639 + v411 + v419;
  v427 = v645 + v413 + v422;
  v428 = v649 + v415 + v423;
  v632 = __ROR4__(v418 ^ v426, 8);
  v429 = __ROR4__(v416 ^ v427, 8);
  v430 = __ROR4__(v417 ^ v428, 8);
  v431 = v421 + v430;
  v603 = v414 + v425;
  v432 = __ROR4__(v423 ^ v431, 7);
  v562 = v582 + v418 + v632;
  v433 = v617 + v429;
  v434 = __ROR4__(v420 ^ v603, 7);
  v435 = __ROR4__(v422 ^ (v617 + v429), 7);
  v583 = __ROR4__(v419 ^ v562, 7);
  v436 = v653 + v424 + v583;
  v437 = __ROR4__(v429 ^ v436, 16);
  v438 = v645 + v426 + v432;
  v439 = v650 + v427 + v434;
  v440 = v431 + v437;
  v441 = __ROR4__(v425 ^ v438, 16);
  v442 = __ROR4__(v430 ^ v439, 16);
  v443 = v639 + v428 + v435;
  v444 = v433 + v441;
  v445 = __ROR4__(v632 ^ v443, 16);
  v633 = v562 + v442;
  v446 = __ROR4__(v434 ^ (v562 + v442), 12);
  v604 = v603 + v445;
  v447 = __ROR4__(v583 ^ v440, 12);
  v448 = __ROR4__(v432 ^ v444, 12);
  v449 = __ROR4__(v435 ^ v604, 12);
  v450 = v648 + v436 + v447;
  v451 = __ROR4__(v437 ^ v450, 8);
  v452 = v654 + v438 + v448;
  v453 = v642 + v439 + v446;
  v454 = __ROR4__(v441 ^ v452, 8);
  v455 = v647 + v443 + v449;
  v563 = v440 + v451;
  v456 = __ROR4__(v445 ^ v455, 8);
  v457 = __ROR4__(v442 ^ v453, 8);
  v458 = v444 + v454;
  v584 = v633 + v457;
  v459 = __ROR4__(v448 ^ v458, 7);
  v460 = __ROR4__(v449 ^ (v604 + v456), 7);
  v461 = __ROR4__(v447 ^ (v440 + v451), 7);
  v462 = __ROR4__(v446 ^ (v633 + v457), 7);
  v463 = v652 + v450 + v462;
  v464 = v651 + v452 + v461;
  v465 = __ROR4__(v454 ^ v463, 16);
  v466 = v640 + v453 + v460;
  v467 = v604 + v456 + v465;
  v468 = v649 + v455 + v459;
  v469 = __ROR4__(v451 ^ v466, 16);
  v470 = __ROR4__(v457 ^ v468, 16);
  v471 = __ROR4__(v456 ^ v464, 16);
  v605 = v458 + v469;
  v634 = v584 + v471;
  v472 = __ROR4__(v461 ^ (v584 + v471), 12);
  v473 = v563 + v470;
  v474 = __ROR4__(v462 ^ v467, 12);
  v475 = __ROR4__(v459 ^ (v563 + v470), 12);
  v476 = __ROR4__(v460 ^ v605, 12);
  v477 = v646 + v463 + v474;
  v478 = __ROR4__(v465 ^ v477, 8);
  v479 = v641 + v464 + v472;
  v480 = v643 + v466 + v476;
  v481 = __ROR4__(v471 ^ v479, 8);
  v482 = v644 + v468 + v475;
  v483 = __ROR4__(v469 ^ v480, 8);
  v564 = v467 + v478;
  v585 = v605 + v483;
  v484 = __ROR4__(v470 ^ v482, 8);
  v485 = v634 + v481;
  v486 = __ROR4__(v472 ^ (v634 + v481), 7);
  v487 = v473 + v484;
  v488 = __ROR4__(v475 ^ v487, 7);
  v489 = __ROR4__(v474 ^ v564, 7);
  v490 = __ROR4__(v476 ^ (v605 + v483), 7);
  v491 = v647 + v477 + v486;
  v492 = v649 + v479 + v488;
  v493 = __ROR4__(v483 ^ v491, 16);
  v494 = __ROR4__(v478 ^ v492, 16);
  v495 = v646 + v480 + v489;
  v496 = v487 + v493;
  v635 = v640 + v482 + v490;
  v497 = __ROR4__(v481 ^ v635, 16);
  v498 = __ROR4__(v484 ^ v495, 16);
  v606 = __ROR4__(v486 ^ v496, 12);
  v586 = v585 + v494;
  v499 = v485 + v498;
  v500 = __ROR4__(v489 ^ v499, 12);
  v501 = __ROR4__(v488 ^ v586, 12);
  v502 = __ROR4__(v490 ^ (v564 + v497), 12);
  v503 = v645 + v495 + v500;
  v504 = v641 + v492 + v501;
  v505 = __ROR4__(v498 ^ v503, 8);
  v506 = v644 + v635 + v502;
  v507 = __ROR4__(v494 ^ v504, 8);
  v508 = v643 + v491 + v606;
  v509 = __ROR4__(v493 ^ v508, 8);
  v636 = __ROR4__(v497 ^ v506, 8);
  v510 = v499 + v505;
  v511 = v496 + v509;
  v512 = __ROR4__(v500 ^ v510, 7);
  v513 = v564 + v497;
  v565 = v586 + v507;
  v618 = v511;
  v514 = v513 + v636;
  v515 = __ROR4__(v502 ^ v514, 7);
  v516 = __ROR4__(v606 ^ v511, 7);
  v517 = __ROR4__(v501 ^ (v586 + v507), 7);
  v518 = v648 + v508 + v512;
  v519 = v642 + v503 + v515;
  v520 = __ROR4__(v507 ^ v518, 16);
  v521 = v654 + v504 + v516;
  v522 = __ROR4__(v509 ^ v519, 16);
  v523 = v514 + v520;
  v607 = v652 + v506 + v517;
  v524 = __ROR4__(v505 ^ v607, 16);
  v525 = __ROR4__(v512 ^ v523, 12);
  v587 = __ROR4__(v636 ^ v521, 16);
  v566 = v565 + v522;
  v526 = v510 + v587;
  v527 = __ROR4__(v516 ^ v526, 12);
  v619 = v618 + v524;
  v528 = __ROR4__(v517 ^ v619, 12);
  v529 = __ROR4__(v515 ^ v566, 12);
  v656 = v653 + v518 + v525;
  v530 = v650 + v521 + v527;
  v531 = __ROR4__(v520 ^ v656, 8);
  v655 = v530;
  v532 = v651 + v519 + v529;
  v533 = v523 + v531;
  v534 = __ROR4__(v522 ^ v532, 8);
  v658 = v639 + v607 + v528;
  v535 = __ROR4__(v587 ^ v530, 8);
  v536 = __ROR4__(v524 ^ v658, 8);
  v667 = v531;
  v537 = v526 + v535;
  v670 = v535;
  v664 = v619 + v536;
  v538 = v566 + v534;
  v660 = __ROR4__(v527 ^ v537, 7);
  v539 = &v656;
  v665 = v537;
  v661 = __ROR4__(v525 ^ v533, 7);
  v662 = __ROR4__(v529 ^ (v566 + v534), 7);
  v666 = v533;
  v663 = v566 + v534;
  v668 = v534;
  v659 = __ROR4__(v528 ^ (v619 + v536), 7);
  v669 = v536;
  v657 = v532;
  v540 = v638;
  while ( 1 )
  {
    v542 = v540[1];
    *++v540 = v542 ^ v538 ^ v530;
    if ( v637 == v540 )
      break;
    v541 = *v539++;
    v530 = v541;
    v538 = v539[7];
  }
  return 0;
}

//----- (0007D06C) --------------------------------------------------------
int __fastcall blake2s_update(_DWORD *a1, char *src, unsigned __int64 n)
{
  unsigned __int64 v3; // r8
  int v5; // r0
  bool v7; // cc
  _DWORD *v8; // r6
  size_t v9; // r5
  int v10; // r2
  int v11; // r12
  unsigned int v12; // r3
  int *v13; // r3
  _DWORD *v14; // r2
  int v15; // lr
  int v16; // r12
  int v17; // r0
  int v18; // r1
  __int64 v20; // [sp+0h] [bp-Ch]

  v3 = n;
  if ( n )
  {
    v5 = a1[44];
    v7 = HIDWORD(n) != 0;
    v8 = a1 + 12;
    v9 = 128 - v5;
    if ( !HIDWORD(n) )
      v7 = (unsigned int)n > v9;
    v20 = v9;
    if ( v7 )
    {
      do
      {
        memcpy((char *)v8 + v5, src, v9);
        v10 = a1[9];
        v11 = a1[44];
        v12 = a1[8] + 64;
        if ( v12 <= 0x3F )
          ++v10;
        a1[8] = v12;
        a1[9] = v10;
        a1[44] = v11 + v9;
        blake2s_compress(a1, a1 + 12);
        v13 = a1 + 28;
        v14 = a1 + 12;
        do
        {
          v15 = *v13;
          v13 += 4;
          v16 = *(v13 - 3);
          v14 += 4;
          v17 = *(v13 - 2);
          v18 = *(v13 - 1);
          *(v14 - 4) = v15;
          *(v14 - 3) = v16;
          *(v14 - 2) = v17;
          *(v14 - 1) = v18;
        }
        while ( v13 != a1 + 44 );
        src += v9;
        v3 -= v20;
        v5 = a1[44] - 64;
        v9 = 192 - a1[44];
        a1[44] = v5;
        v20 = v9;
      }
      while ( v9 < v3 );
    }
    memcpy((char *)v8 + v5, src, v3);
    a1[44] += v3;
  }
  return 0;
}

//----- (0007D194) --------------------------------------------------------
int __fastcall blake2s_init_key(int *a1, int a2, const void *a3, size_t a4)
{
  char *v8; // r3
  int v10; // [sp+0h] [bp-78h] BYREF
  __int16 v11; // [sp+4h] [bp-74h]
  __int16 v12; // [sp+6h] [bp-72h]
  __int16 v13; // [sp+8h] [bp-70h]
  __int16 v14; // [sp+Ah] [bp-6Eh]
  __int16 v15; // [sp+Ch] [bp-6Ch]
  __int16 v16; // [sp+Eh] [bp-6Ah]
  int v17; // [sp+10h] [bp-68h]
  int v18; // [sp+14h] [bp-64h]
  int v19; // [sp+18h] [bp-60h]
  int v20; // [sp+1Ch] [bp-5Ch]
  char s[64]; // [sp+20h] [bp-58h] BYREF
  char v22; // [sp+60h] [bp-18h] BYREF

  if ( (unsigned int)(a2 - 1) > 0x1F )
    return -1;
  if ( a4 - 1 > 0x1F || a3 == 0 )
    return -1;
  LOBYTE(v10) = a2;
  BYTE1(v10) = a4;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  HIWORD(v10) = 257;
  if ( blake2s_init_param(a1, &v10) < 0 )
    return -1;
  memset(s, 0, sizeof(s));
  memcpy(s, a3, a4);
  blake2s_update(a1, s, 0x40u);
  v8 = s;
  do
    *v8++ = 0;
  while ( v8 != &v22 );
  return 0;
}

//----- (0007D28C) --------------------------------------------------------
int __fastcall blake2s_final(int a1, void *a2, size_t a3)
{
  unsigned int v4; // r1
  char *v7; // r7
  int v8; // r3
  int v9; // r2
  int v10; // r0
  _BOOL4 v11; // r3
  int v12; // r1
  _BYTE *v13; // r2
  int v14; // r4
  int v15; // t1
  unsigned int v17; // r3
  size_t v18; // r2
  _BYTE v19[36]; // [sp+0h] [bp-24h] BYREF

  v4 = *(_DWORD *)(a1 + 176);
  v7 = (char *)(a1 + 48);
  v8 = *(_DWORD *)(a1 + 32);
  v9 = *(_DWORD *)(a1 + 36);
  if ( v4 > 0x40 )
  {
    v17 = v8 + 64;
    if ( v17 <= 0x3F )
      ++v9;
    *(_DWORD *)(a1 + 32) = v17;
    *(_DWORD *)(a1 + 36) = v9;
    blake2s_compress((_DWORD *)a1, (int *)(a1 + 48));
    v18 = *(_DWORD *)(a1 + 176) - 64;
    *(_DWORD *)(a1 + 176) = v18;
    memcpy(v7, (const void *)(a1 + 112), v18);
    v4 = *(_DWORD *)(a1 + 176);
    v8 = *(_DWORD *)(a1 + 32);
    v9 = *(_DWORD *)(a1 + 36);
  }
  v10 = *(unsigned __int8 *)(a1 + 180);
  *(_DWORD *)(a1 + 32) = v4 + v8;
  v11 = __CFADD__(v4, v8);
  *(_DWORD *)(a1 + 36) = v11 + v9;
  if ( v10 )
    *(_DWORD *)(a1 + 44) = -1;
  *(_DWORD *)(a1 + 40) = -1;
  memset(&v7[v4], 0, 128 - v4);
  blake2s_compress((_DWORD *)a1, (int *)v7);
  v12 = a1 - 4;
  v13 = v19;
  v14 = a1 + 28;
  do
  {
    v15 = *(_DWORD *)(v12 + 4);
    v12 += 4;
    v13 += 4;
    *((_DWORD *)v13 - 1) = v15;
  }
  while ( v14 != v12 );
  memcpy(a2, v19, a3);
  return 0;
}

//----- (0007D39C) --------------------------------------------------------
int __fastcall blake2s(void *a1, char *a2, const void *a3, size_t a4, unsigned __int64 a5, unsigned __int8 a6)
{
  bool v6; // zf
  bool v7; // zf
  _BYTE v12[197]; // [sp+3Fh] [bp-C5h] BYREF

  v6 = a1 == 0;
  if ( a1 )
    v6 = a2 == 0;
  if ( v6 )
    return -1;
  v7 = a6 == 0;
  if ( a6 )
    v7 = a3 == 0;
  if ( !v7 )
  {
    if ( blake2s_init_key((int *)((unsigned int)v12 & 0xFFFFFFC0), a4, a3, a6) < 0 )
      return -1;
LABEL_9:
    blake2s_update((_DWORD *)((unsigned int)v12 & 0xFFFFFFC0), a2, a5);
    blake2s_final((unsigned int)v12 & 0xFFFFFFC0, a1, a4);
    return 0;
  }
  if ( blake2s_init((int *)((unsigned int)v12 & 0xFFFFFFC0), a4) >= 0 )
    goto LABEL_9;
  return -1;
}

//----- (0007D438) --------------------------------------------------------
int __fastcall PrintState(int a1)
{
  int v1; // r4
  int v2; // r5
  unsigned int v3; // t1

  v1 = a1 - 4;
  v2 = a1 + 60;
  do
  {
    v3 = *(_DWORD *)(v1 + 4);
    v1 += 4;
    printf("0x%02x%02x%02x%02x ", HIBYTE(v3), BYTE2(v3), BYTE1(v3), (unsigned __int8)v3);
  }
  while ( v2 != v1 );
  return putchar(10);
}

//----- (0007D488) --------------------------------------------------------
int __fastcall EaglesongPermutation(int result)
{
  int *v1; // r7
  int *v2; // r8
  int v3; // r11
  _DWORD *v4; // lr
  char *v5; // r6
  char *v6; // r4
  int v7; // r1
  int v8; // r2
  int *v9; // r5
  int *v10; // r0
  int v11; // r12
  int v12; // t1
  int *v13; // r3
  int v14; // t1
  int *v15; // r12
  int *v16; // lr
  unsigned int v17; // t1
  int v18; // r0
  int v19; // r3
  int v20; // r1
  int v21; // r0
  int v22; // r3
  int v23; // t1
  int v24; // t1
  int v25; // r2
  int v26; // r0
  int v27; // r3
  int v28; // t2
  int v29; // [sp+4h] [bp-58h]
  int v30; // [sp+8h] [bp-54h]
  int v31; // [sp+Ch] [bp-50h]
  _DWORD v32[16]; // [sp+14h] [bp-48h] BYREF
  char v33; // [sp+54h] [bp-8h] BYREF

  v31 = result;
  if ( num_rounds > 0 )
  {
    v1 = (int *)(result - 4);
    v2 = (int *)(result + 60);
    v3 = result + 64;
    v30 = 0;
    v29 = 1074836;
    v32[0] = result + 4;
    do
    {
      v4 = &bit_matrix;
      v5 = (char *)v32;
      v6 = (char *)v32;
      do
      {
        v7 = 0;
        v6 += 4;
        v8 = 0;
        v9 = v1;
        v10 = v1;
        do
        {
          v11 = v4[16 * v8++];
          v12 = v10[1];
          ++v10;
          v7 ^= v12 * v11;
        }
        while ( v8 != 16 );
        *(_DWORD *)v6 = v7;
        ++v4;
      }
      while ( &v33 != v6 );
      v13 = v1;
      do
      {
        v14 = *((_DWORD *)v5 + 1);
        v5 += 4;
        v13[1] = v14;
        ++v13;
      }
      while ( v5 != v6 );
      v15 = (int *)&coefficients;
      v16 = v1;
      do
      {
        v17 = v16[1];
        ++v16;
        v18 = v15[1];
        v19 = v15[2];
        v15 += 3;
        *v16 = (v17 << v19) ^ __ROR4__(v17, 32 - v18) ^ v17 ^ (v17 >> (32 - v19));
      }
      while ( &rate != v15 );
      v20 = v31;
      v21 = v29;
      do
      {
        v23 = v9[1];
        ++v9;
        v22 = v23;
        v24 = *(_DWORD *)(v21 + 4);
        v21 += 4;
        *v9 = v22 ^ v24;
      }
      while ( v2 != v9 );
      v25 = v32[0];
      do
      {
        v26 = *(_DWORD *)(v20 + 4);
        v20 += 8;
        v27 = *(_DWORD *)(v25 - 4);
        v25 += 8;
        *(_DWORD *)(v25 - 12) = __ROR4__(v27 + v26, 24);
        v28 = __ROR4__(*(_DWORD *)(v20 - 4), 8);
        *(_DWORD *)(v20 - 4) = v28;
        result = *(_DWORD *)(v25 - 12);
        *(_DWORD *)(v20 - 4) = result + v28;
      }
      while ( v3 != v20 );
      ++v30;
      v29 += 64;
    }
    while ( num_rounds > v30 );
  }
  return result;
}
// 106694: using guessed type int num_rounds;
// 107618: using guessed type int rate;

//----- (0007D608) --------------------------------------------------------
unsigned int __fastcall EaglesongSponge(int a1, unsigned int a2, int a3, unsigned int a4, unsigned __int8 a5)
{
  unsigned int *v8; // r3
  unsigned int v9; // r10
  int v10; // r4
  unsigned int v11; // r6
  unsigned int *v12; // r12
  unsigned int v13; // r1
  unsigned int v14; // r0
  int v15; // r3
  unsigned int v16; // t1
  unsigned int result; // r0
  unsigned int v18; // r8
  unsigned int *v19; // r9
  int v20; // lr
  unsigned int v21; // r12
  unsigned int v22; // t1
  int i; // r2
  int v24; // r3
  char v25; // r4
  int v26; // r1
  int v27; // r3
  unsigned int v28; // [sp+4h] [bp-48h] BYREF
  _BYTE v29[60]; // [sp+8h] [bp-44h] BYREF
  char v30; // [sp+44h] [bp-8h] BYREF

  v28 = a2;
  v8 = &v28;
  do
  {
    v8[1] = 0;
    ++v8;
  }
  while ( &v30 != (char *)v8 );
  v9 = 8 * (a4 + 1);
  v10 = rate;
  if ( (v10 - 1 + v9) / v10 )
  {
    v11 = 0;
    do
    {
      if ( v10 / 32 > 0 )
      {
        v12 = &v28;
        v13 = (int)(v11 * v10) / 8;
        do
        {
          v14 = v13 + 4;
          v15 = 0;
          do
          {
            if ( a4 <= v13 )
            {
              if ( a4 == v13 )
                v15 = a5 | (v15 << 8);
            }
            else
            {
              v15 = *(unsigned __int8 *)(a3 + v13) | (v15 << 8);
            }
            ++v13;
          }
          while ( v14 != v13 );
          v16 = v12[1];
          *++v12 = v15 ^ v16;
        }
        while ( (int)(v11 * v10) / 8 + 4 * (v10 / 32) != v13 );
      }
      ++v11;
      EaglesongPermutation((int)v29);
      v10 = rate;
    }
    while ( (v10 - 1 + v9) / v10 > v11 );
  }
  result = v28 / (v10 / 8);
  if ( result )
  {
    v18 = 0;
    do
    {
      if ( v10 > 31 )
      {
        v19 = (unsigned int *)v29;
        v20 = 0;
        do
        {
          v22 = *v19++;
          v21 = v22;
          for ( i = 0; i != 4; ++i )
          {
            v24 = v10 * v18;
            v25 = 8 * i;
            v26 = a1 + i;
            *(_BYTE *)(v26 + 4 * v20 + v24 / 8) = v21 >> v25;
            v10 = rate;
          }
          v27 = rate + 31;
          ++v20;
          if ( rate >= 0 )
            v27 = rate;
        }
        while ( v20 < v27 >> 5 );
      }
      ++v18;
      EaglesongPermutation((int)v29);
      v10 = rate;
      result = v28 / (rate / 8);
    }
    while ( result > v18 );
  }
  return result;
}
// 107618: using guessed type int rate;

//----- (0007D7CC) --------------------------------------------------------
unsigned int __fastcall EaglesongHash(int a1, int a2, unsigned int a3)
{
  return EaglesongSponge(a1, 0x20u, a2, a3, 6u);
}

//----- (0007D7F8) --------------------------------------------------------
int __fastcall sub_7D7F8(_DWORD *a1, unsigned __int64 *a2)
{
  __int64 *v3; // r12
  unsigned __int64 v5; // r0
  _DWORD *v6; // r3
  _DWORD *v7; // r1
  __int64 v8; // t1
  __int64 v9; // kr3A0_8
  int v10; // r1
  int v11; // lr
  int v12; // r2
  int v13; // r0
  unsigned int v14; // r11
  unsigned int v15; // r5
  unsigned int v16; // r6
  unsigned int v17; // r1
  unsigned int v18; // r2
  int v19; // r7
  int v20; // kr3B0_4
  __int64 v21; // kr3B8_8
  unsigned int v22; // lr
  unsigned int v23; // r2
  int v24; // r5
  int v25; // r0
  unsigned int v26; // r10
  unsigned int v27; // r12
  unsigned int v28; // lr
  unsigned int v29; // r5
  __int64 v30; // kr3D0_8
  int v31; // r7
  int v32; // r2
  int v33; // r1
  int v34; // r4
  __int64 v35; // r10
  __int64 v36; // kr3D8_8
  unsigned int v37; // r7
  unsigned int v38; // r1
  unsigned int v39; // r4
  unsigned int v40; // kr3E0_4
  __int64 v41; // kr3E8_8
  int v42; // r1
  int v43; // r12
  int v44; // lr
  unsigned int v45; // r12
  unsigned int v46; // r1
  int v47; // r0
  int v48; // r12
  unsigned int v49; // lr
  int v50; // kr3F0_4
  int v51; // r1
  unsigned int v52; // r7
  unsigned __int64 v53; // r8
  int v54; // r12
  unsigned int v55; // r5
  unsigned int v56; // r4
  unsigned __int64 v57; // kr400_8
  unsigned int v58; // r6
  int v59; // r6
  unsigned int v60; // r12
  unsigned int v61; // r6
  unsigned int v62; // r0
  int v63; // kr14_4
  unsigned int v64; // r2
  unsigned int v65; // r4
  int v66; // r12
  int v67; // r1
  unsigned int v68; // r7
  unsigned int v69; // lr
  unsigned __int64 v70; // kr410_8
  unsigned int v71; // r6
  __int64 v72; // r4
  unsigned int v73; // r2
  __int64 v74; // kr418_8
  __int64 v75; // r6
  unsigned int v76; // r1
  unsigned int v77; // r12
  unsigned __int64 v78; // kr428_8
  unsigned int v79; // r2
  unsigned int v80; // r0
  unsigned int v81; // lr
  __int64 v82; // r2
  unsigned int v83; // r1
  unsigned __int64 v84; // kr448_8
  unsigned int v85; // r0
  unsigned int v86; // lr
  unsigned __int64 v87; // kr458_8
  unsigned int v88; // kr38_4
  unsigned int v89; // r0
  unsigned __int64 v90; // kr460_8
  unsigned __int64 v91; // kr468_8
  unsigned int v92; // r12
  unsigned int v93; // kr470_4
  int v94; // lr
  unsigned __int64 v95; // kr478_8
  unsigned int v96; // r1
  unsigned int v97; // r1
  unsigned int v98; // r0
  unsigned int v99; // kr488_4
  int v100; // lr
  unsigned int v101; // kr490_4
  unsigned int v102; // lr
  unsigned int v103; // kr4C_4
  unsigned int v104; // lr
  unsigned int v105; // r12
  unsigned int v106; // r0
  unsigned int v107; // r1
  unsigned __int64 v108; // kr4B0_8
  unsigned int v109; // r12
  unsigned int v110; // r0
  unsigned __int64 v111; // kr4B8_8
  int v112; // r12
  unsigned int v113; // r0
  unsigned int v114; // lr
  unsigned int v115; // r12
  unsigned int v116; // r12
  unsigned __int64 v117; // kr4D0_8
  int v118; // lr
  int v119; // lr
  unsigned __int64 v120; // kr4D8_8
  unsigned __int64 v121; // kr4E0_8
  int v122; // lr
  unsigned __int64 v123; // kr4E8_8
  unsigned int v124; // lr
  unsigned __int64 v125; // kr500_8
  unsigned __int64 v126; // kr508_8
  __int64 v127; // r0
  int v128; // r12
  int v129; // r12
  unsigned int v130; // lr
  unsigned int v131; // r12
  signed __int64 v132; // r6
  int v133; // kr7C_4
  unsigned __int64 v134; // kr530_8
  unsigned __int64 v135; // kr538_8
  __int64 v136; // r10
  unsigned __int64 v137; // r8
  int v138; // r12
  unsigned int v139; // kr550_4
  unsigned __int64 v140; // kr558_8
  __int64 v141; // r0
  unsigned __int64 v142; // kr560_8
  unsigned __int64 v143; // kr578_8
  __int64 v144; // r0
  unsigned __int64 v145; // kr580_8
  unsigned __int64 v146; // kr588_8
  unsigned __int64 v147; // kr590_8
  unsigned __int64 v148; // r2
  unsigned __int64 v149; // kr598_8
  int v150; // r12
  unsigned int v151; // kr98_4
  __int64 v152; // r0
  unsigned int v153; // lr
  unsigned int v154; // r12
  unsigned __int64 v155; // kr5B0_8
  unsigned __int64 v156; // kr5B8_8
  int v157; // r12
  unsigned int v158; // lr
  unsigned int v159; // r12
  unsigned int v160; // r12
  unsigned int v161; // lr
  __int64 v162; // kr5D0_8
  int v163; // lr
  int v164; // lr
  unsigned __int64 v165; // kr5D8_8
  unsigned __int64 v166; // kr5E0_8
  int v167; // lr
  unsigned __int64 v168; // kr5E8_8
  unsigned int v169; // lr
  unsigned __int64 v170; // kr608_8
  unsigned __int64 v171; // kr610_8
  unsigned __int64 v172; // kr618_8
  unsigned int v173; // r12
  int v174; // r12
  int v175; // r12
  unsigned __int64 v176; // kr620_8
  unsigned int v177; // kr628_4
  unsigned int v178; // r12
  unsigned __int64 v179; // kr638_8
  unsigned int v180; // r12
  unsigned int v181; // kr640_4
  unsigned __int64 v182; // kr648_8
  unsigned __int64 v183; // r10
  unsigned int v184; // lr
  unsigned __int64 v185; // kr660_8
  __int64 v186; // r0
  unsigned __int64 v187; // kr668_8
  unsigned int v188; // r12
  unsigned __int64 v189; // kr678_8
  unsigned __int64 v190; // kr688_8
  unsigned __int64 v191; // kr690_8
  bool v192; // cf
  int v193; // r12
  unsigned int v194; // lr
  unsigned int v195; // r12
  unsigned __int64 v196; // kr6B8_8
  int v197; // r12
  unsigned int v198; // r12
  unsigned int v199; // lr
  unsigned int v200; // r12
  unsigned int v201; // r12
  unsigned __int64 v202; // kr6D0_8
  int v203; // lr
  int v204; // lr
  unsigned __int64 v205; // kr6D8_8
  unsigned __int64 v206; // kr6E0_8
  int v207; // lr
  int v208; // kr6E8_4
  unsigned int v209; // lr
  int v210; // r12
  unsigned __int64 v211; // kr700_8
  unsigned __int64 v212; // kr708_8
  unsigned int v213; // r12
  int v214; // r12
  int v215; // r12
  unsigned int v216; // lr
  unsigned int v217; // r12
  unsigned __int64 v218; // kr730_8
  unsigned int v219; // r12
  unsigned __int64 v220; // kr738_8
  unsigned __int64 v221; // kr740_8
  __int64 v222; // r10
  int v223; // r12
  unsigned __int64 v224; // kr760_8
  unsigned __int64 v225; // kr768_8
  __int64 v226; // r0
  unsigned __int64 v227; // kr770_8
  int v228; // r12
  unsigned __int64 v229; // kr780_8
  unsigned __int64 v230; // kr788_8
  unsigned __int64 v231; // kr790_8
  unsigned __int64 v232; // kr798_8
  int v233; // lr
  int v234; // r12
  unsigned int v235; // lr
  unsigned int v236; // r12
  unsigned __int64 v237; // kr7B0_8
  int v238; // r12
  unsigned int v239; // lr
  unsigned int v240; // r12
  unsigned int v241; // r12
  int v242; // lr
  int v243; // lr
  unsigned __int64 v244; // kr7D8_8
  unsigned __int64 v245; // kr7E0_8
  int v246; // lr
  unsigned __int64 v247; // kr7E8_8
  unsigned int v248; // lr
  int v249; // r12
  unsigned __int64 v250; // kr800_8
  unsigned __int64 v251; // kr808_8
  unsigned int v252; // r12
  unsigned int v253; // r12
  unsigned int v254; // kr820_4
  unsigned int v255; // r12
  unsigned __int64 v256; // kr830_8
  int v257; // lr
  unsigned int v258; // r12
  unsigned __int64 v259; // kr838_8
  unsigned __int64 v260; // kr840_8
  __int64 v261; // r10
  int v262; // r12
  unsigned __int64 v263; // kr858_8
  unsigned __int64 v264; // kr860_8
  __int64 v265; // r0
  unsigned __int64 v266; // kr868_8
  unsigned int v267; // r12
  int v268; // r12
  int v269; // r12
  unsigned __int64 v270; // kr878_8
  unsigned __int64 v271; // kr880_8
  unsigned __int64 v272; // kr888_8
  unsigned int v273; // lr
  int v274; // r12
  unsigned int v275; // lr
  unsigned int v276; // r12
  unsigned __int64 v277; // kr8A0_8
  unsigned int v278; // lr
  unsigned int v279; // r12
  unsigned int v280; // lr
  unsigned int v281; // kr8B8_4
  unsigned int v282; // r12
  unsigned int v283; // r12
  unsigned __int64 v284; // kr8C0_8
  unsigned int v285; // lr
  unsigned __int64 v286; // kr8C8_8
  unsigned __int64 v287; // kr8D0_8
  int v288; // lr
  unsigned __int64 v289; // kr8D8_8
  unsigned int v290; // lr
  unsigned __int64 v291; // kr8F0_8
  unsigned __int64 v292; // kr8F8_8
  unsigned int v293; // r12
  int v294; // r12
  int v295; // r12
  unsigned int v296; // lr
  unsigned int v297; // r12
  unsigned __int64 v298; // kr928_8
  unsigned __int64 v299; // kr930_8
  unsigned __int64 v300; // kr938_8
  __int64 v301; // r10
  int v302; // r12
  unsigned __int64 v303; // kr960_8
  __int64 v304; // r0
  unsigned __int64 v305; // kr968_8
  unsigned __int64 v306; // kr980_8
  signed __int64 v307; // r0
  unsigned __int64 v308; // kr988_8
  unsigned __int64 v309; // kr990_8
  unsigned int v310; // r12
  unsigned __int64 v311; // kr9A8_8
  int v312; // lr
  unsigned int v313; // kr9C0_4
  unsigned int v314; // r12
  unsigned int v315; // r12
  unsigned __int64 v316; // kr9C8_8
  int v317; // lr
  int v318; // lr
  unsigned __int64 v319; // kr9D0_8
  unsigned __int64 v320; // kr9D8_8
  int v321; // lr
  unsigned __int64 v322; // kr9E0_8
  unsigned int v323; // lr
  int v324; // r12
  unsigned int v325; // lr
  unsigned __int64 v326; // kr9F8_8
  unsigned __int64 v327; // krA00_8
  unsigned __int64 v328; // r10
  unsigned int v329; // r12
  unsigned __int64 v330; // krA08_8
  unsigned int v331; // r12
  unsigned int v332; // lr
  unsigned int v333; // r12
  unsigned __int64 v334; // krA20_8
  unsigned int v335; // r12
  int v336; // lr
  unsigned __int64 v337; // krA28_8
  unsigned __int64 v338; // krA30_8
  __int64 v339; // r10
  int v340; // r12
  unsigned __int64 v341; // krA48_8
  unsigned int v342; // r12
  signed __int64 v343; // r0
  unsigned __int64 v344; // krA50_8
  unsigned int v345; // r12
  int v346; // lr
  signed __int64 v347; // krA60_8
  unsigned __int64 v348; // krA68_8
  signed __int64 v349; // r0
  unsigned __int64 v350; // krA70_8
  unsigned int v351; // kr200_4
  unsigned int v352; // r12
  unsigned __int64 v353; // krA88_8
  int v354; // r12
  unsigned int v355; // lr
  unsigned int v356; // r12
  unsigned int v357; // r12
  unsigned __int64 v358; // krAA8_8
  int v359; // lr
  int v360; // lr
  unsigned __int64 v361; // krAB0_8
  unsigned __int64 v362; // krAB8_8
  int v363; // lr
  unsigned __int64 v364; // krAC0_8
  unsigned int v365; // lr
  unsigned __int64 v366; // krAD8_8
  unsigned int v367; // krAE0_4
  unsigned __int64 v368; // krAE8_8
  unsigned int v369; // r12
  int v370; // r12
  int v371; // r12
  unsigned int v372; // lr
  unsigned int v373; // r12
  unsigned __int64 v374; // krB08_8
  int v375; // lr
  unsigned __int64 v376; // krB18_8
  __int64 v377; // r10
  int v378; // r12
  unsigned __int64 v379; // krB30_8
  unsigned __int64 v380; // krB38_8
  unsigned __int64 v381; // krB48_8
  unsigned __int64 v382; // krB50_8
  unsigned __int64 v383; // krB58_8
  signed __int64 v384; // r0
  unsigned __int64 v385; // krB60_8
  unsigned int v386; // r12
  unsigned int v387; // lr
  unsigned int v388; // r12
  unsigned int v389; // r12
  unsigned int v390; // lr
  unsigned int v391; // r12
  unsigned int v392; // r12
  unsigned __int64 v393; // krBA8_8
  int v394; // lr
  int v395; // lr
  unsigned int v396; // krBB0_4
  unsigned __int64 v397; // krBB8_8
  int v398; // lr
  unsigned __int64 v399; // krBC0_8
  unsigned int v400; // lr
  unsigned __int64 v401; // r0
  unsigned __int64 v402; // krBE0_8
  unsigned __int64 v403; // krBE8_8
  unsigned int v404; // r12
  int v405; // r12
  int v406; // r12
  unsigned int v407; // lr
  unsigned int v408; // r12
  unsigned __int64 v409; // krC10_8
  unsigned int v410; // lr
  unsigned int v411; // krC18_4
  unsigned __int64 v412; // krC20_8
  __int64 v413; // r10
  int v414; // r12
  unsigned __int64 v415; // krC40_8
  unsigned __int64 v416; // krC48_8
  __int64 v417; // r0
  unsigned int v418; // lr
  unsigned __int64 v419; // krC68_8
  unsigned __int64 v420; // krC70_8
  unsigned __int64 v421; // krC88_8
  int v422; // r12
  unsigned int v423; // r12
  unsigned __int64 v424; // krCA0_8
  int v425; // r12
  unsigned int v426; // r12
  unsigned int v427; // lr
  unsigned int v428; // r12
  unsigned int v429; // r12
  unsigned __int64 v430; // krCC0_8
  int v431; // lr
  int v432; // lr
  unsigned __int64 v433; // krCC8_8
  unsigned __int64 v434; // krCD0_8
  int v435; // lr
  unsigned __int64 v436; // krCD8_8
  unsigned int v437; // lr
  unsigned __int64 v438; // krCF0_8
  unsigned __int64 v439; // krCF8_8
  unsigned int v440; // r12
  unsigned int v441; // r12
  unsigned int v442; // krD10_4
  unsigned int v443; // r12
  unsigned __int64 v444; // krD20_8
  unsigned __int64 v445; // krD28_8
  unsigned __int64 v446; // krD30_8
  __int64 v447; // r10
  int v448; // r12
  unsigned __int64 v449; // krD48_8
  signed __int64 v450; // r6
  unsigned __int64 v451; // krD50_8
  __int64 v452; // r0
  unsigned __int64 v453; // krD58_8
  unsigned __int64 v454; // krD70_8
  unsigned __int64 v455; // krD78_8
  unsigned __int64 v456; // krD80_8
  unsigned __int64 v457; // krD88_8
  int v458; // r12
  unsigned int v459; // lr
  unsigned int v460; // r12
  unsigned __int64 v461; // krDA8_8
  int v462; // r12
  unsigned int v463; // lr
  unsigned int v464; // r12
  unsigned int v465; // r12
  int v466; // lr
  int v467; // lr
  unsigned __int64 v468; // krDD0_8
  unsigned __int64 v469; // krDD8_8
  int v470; // lr
  unsigned __int64 v471; // krDE0_8
  unsigned int v472; // lr
  int v473; // r12
  int v474; // lr
  unsigned int v475; // r12
  unsigned __int64 v476; // krE08_8
  unsigned int v477; // r12
  unsigned __int64 v478; // krE10_8
  unsigned int v479; // lr
  int v480; // lr
  int v481; // r12
  int v482; // r12
  unsigned __int64 v483; // krE28_8
  unsigned int v484; // lr
  unsigned int v485; // r12
  unsigned __int64 v486; // krE38_8
  unsigned int v487; // lr
  unsigned __int64 v488; // krE40_8
  unsigned __int64 v489; // krE50_8
  unsigned int v490; // r12
  unsigned int v491; // r12
  unsigned __int64 v492; // krE70_8
  unsigned int v493; // krE80_4
  unsigned int v494; // lr
  unsigned __int64 v495; // krE88_8
  unsigned __int64 v496; // krE90_8
  unsigned __int64 v497; // krE98_8
  unsigned __int64 v498; // krEA0_8
  unsigned int v499; // r12
  unsigned __int64 v500; // krEA8_8
  unsigned int v501; // lr
  int v502; // lr
  unsigned __int64 v503; // krEC0_8
  unsigned __int64 v504; // krEC8_8
  unsigned __int64 v505; // krED8_8
  unsigned int v506; // r12
  unsigned int v507; // r12
  unsigned int v508; // krEE8_4
  unsigned __int64 v509; // krEF0_8
  unsigned __int64 v510; // krEF8_8
  unsigned __int64 v511; // krF10_8
  unsigned int v512; // r12
  unsigned __int64 v513; // r8
  unsigned __int64 v514; // r0
  unsigned int v515; // r12
  unsigned int v516; // krF28_4
  unsigned __int64 v517; // krF30_8
  unsigned int v518; // r1
  __int64 v519; // krF40_8
  unsigned __int64 v520; // krF48_8
  unsigned int v521; // lr
  unsigned int v522; // r12
  unsigned int v523; // r12
  int v524; // r12
  _DWORD *v525; // r2
  unsigned __int64 *v526; // lr
  unsigned __int64 v527; // r4
  unsigned __int64 v528; // t1
  int v529; // t1
  int v530; // r3
  int result; // r0
  int v532; // [sp+0h] [bp-20Ch]
  unsigned int v533; // [sp+4h] [bp-208h]
  __int64 v534; // [sp+8h] [bp-204h]
  unsigned __int64 v535; // [sp+10h] [bp-1FCh]
  int v536; // [sp+14h] [bp-1F8h]
  unsigned __int64 v537; // [sp+18h] [bp-1F4h]
  unsigned int v538; // [sp+20h] [bp-1ECh]
  unsigned __int64 v539; // [sp+20h] [bp-1ECh]
  unsigned int v540; // [sp+30h] [bp-1DCh]
  unsigned __int64 v541; // [sp+58h] [bp-1B4h]
  unsigned __int64 v542; // [sp+60h] [bp-1ACh]
  unsigned int v543; // [sp+70h] [bp-19Ch]
  unsigned int v544; // [sp+74h] [bp-198h]
  unsigned __int64 v545; // [sp+78h] [bp-194h]
  unsigned __int64 v546; // [sp+80h] [bp-18Ch]
  unsigned __int64 v547; // [sp+88h] [bp-184h]
  __int128 v548; // [sp+90h] [bp-17Ch]
  int v549; // [sp+98h] [bp-174h]
  int v550; // [sp+9Ch] [bp-170h]
  _DWORD *v551; // [sp+A0h] [bp-16Ch]
  _DWORD *v552; // [sp+A8h] [bp-164h]
  unsigned int v553; // [sp+ACh] [bp-160h]
  _BYTE v554[28]; // [sp+ACh] [bp-160h]
  unsigned int v555; // [sp+ACh] [bp-160h]
  unsigned int v556; // [sp+ACh] [bp-160h]
  unsigned int v557; // [sp+ACh] [bp-160h]
  unsigned int v558; // [sp+ACh] [bp-160h]
  unsigned int v559; // [sp+ACh] [bp-160h]
  int v560; // [sp+B0h] [bp-15Ch]
  unsigned int v561; // [sp+B0h] [bp-15Ch]
  unsigned int v562; // [sp+B0h] [bp-15Ch]
  unsigned int v563; // [sp+B0h] [bp-15Ch]
  unsigned int v564; // [sp+B0h] [bp-15Ch]
  int v565; // [sp+B4h] [bp-158h]
  unsigned int v566; // [sp+B4h] [bp-158h]
  unsigned int v567; // [sp+B4h] [bp-158h]
  unsigned int v568; // [sp+C0h] [bp-14Ch]
  __int64 v569; // [sp+C0h] [bp-14Ch]
  unsigned __int64 v570; // [sp+C0h] [bp-14Ch]
  unsigned __int64 v571; // [sp+C8h] [bp-144h]
  _BYTE v572[12]; // [sp+C8h] [bp-144h]
  unsigned int v573; // [sp+D0h] [bp-13Ch]
  unsigned int v574; // [sp+D0h] [bp-13Ch]
  int v575; // [sp+D0h] [bp-13Ch]
  unsigned int v576; // [sp+D0h] [bp-13Ch]
  unsigned int v577; // [sp+D0h] [bp-13Ch]
  unsigned int v578; // [sp+D0h] [bp-13Ch]
  unsigned int v579; // [sp+D0h] [bp-13Ch]
  unsigned int v580; // [sp+D0h] [bp-13Ch]
  int v581; // [sp+D4h] [bp-138h]
  unsigned __int64 v582; // [sp+D4h] [bp-138h]
  unsigned __int64 v583; // [sp+D4h] [bp-138h]
  int v584; // [sp+D8h] [bp-134h]
  unsigned int v585; // [sp+D8h] [bp-134h]
  __int64 v586; // [sp+DCh] [bp-130h]
  unsigned __int64 v587; // [sp+DCh] [bp-130h]
  unsigned __int64 v588; // [sp+DCh] [bp-130h]
  unsigned __int64 v589; // [sp+DCh] [bp-130h]
  unsigned __int64 v590; // [sp+DCh] [bp-130h]
  unsigned __int64 v591; // [sp+DCh] [bp-130h]
  unsigned __int64 v592; // [sp+DCh] [bp-130h]
  unsigned __int64 v593; // [sp+DCh] [bp-130h]
  unsigned __int64 v594; // [sp+DCh] [bp-130h]
  int v595; // [sp+E4h] [bp-128h]
  int v596; // [sp+E4h] [bp-128h]
  unsigned int v597; // [sp+E4h] [bp-128h]
  _BYTE v598[12]; // [sp+E4h] [bp-128h]
  int v599; // [sp+E4h] [bp-128h]
  unsigned int v600; // [sp+E4h] [bp-128h]
  unsigned int v601; // [sp+E8h] [bp-124h]
  int v602; // [sp+ECh] [bp-120h]
  int v603; // [sp+ECh] [bp-120h]
  _BYTE v604[24]; // [sp+F0h] [bp-11Ch] BYREF
  __int64 v605; // [sp+108h] [bp-104h]
  __int64 v606; // [sp+110h] [bp-FCh]
  __int64 v607; // [sp+118h] [bp-F4h]
  __int64 v608; // [sp+120h] [bp-ECh]
  __int64 v609; // [sp+128h] [bp-E4h]
  __int64 v610; // [sp+130h] [bp-DCh]
  __int64 v611; // [sp+138h] [bp-D4h]
  __int64 v612; // [sp+140h] [bp-CCh]
  __int64 v613; // [sp+148h] [bp-C4h]
  __int64 v614; // [sp+150h] [bp-BCh]
  __int64 v615; // [sp+158h] [bp-B4h]
  __int64 v616; // [sp+160h] [bp-ACh]
  __int64 v617; // [sp+168h] [bp-A4h]
  __int64 v618; // [sp+170h] [bp-9Ch]
  __int64 v619; // [sp+178h] [bp-94h]
  __int64 v620; // [sp+180h] [bp-8Ch] BYREF
  unsigned __int64 v621; // [sp+188h] [bp-84h]
  unsigned __int64 v622; // [sp+190h] [bp-7Ch] BYREF
  __int64 v623; // [sp+198h] [bp-74h]
  unsigned __int64 v624; // [sp+1A0h] [bp-6Ch]
  __int64 v625; // [sp+1A8h] [bp-64h]
  __int64 v626; // [sp+1B0h] [bp-5Ch]
  __int64 v627; // [sp+1B8h] [bp-54h]
  __int64 v628; // [sp+1C0h] [bp-4Ch]
  unsigned __int64 v629; // [sp+1C8h] [bp-44h]
  unsigned __int64 v630; // [sp+1D0h] [bp-3Ch]
  unsigned __int64 v631; // [sp+1D8h] [bp-34h]
  unsigned __int64 v632; // [sp+1E0h] [bp-2Ch]
  unsigned __int64 v633; // [sp+1E8h] [bp-24h]
  __int64 v634; // [sp+1F0h] [bp-1Ch]
  int v635; // [sp+1F8h] [bp-14h]
  int v636; // [sp+1FCh] [bp-10h]
  unsigned int v637; // [sp+200h] [bp-Ch]
  int v638; // [sp+204h] [bp-8h]

  v3 = (__int64 *)&v604[16];
  do
  {
    v5 = *a2++;
    v621 = v5;
    v3[1] = v5;
    ++v3;
  }
  while ( v3 != &v620 );
  v6 = a1;
  v551 = a1 - 2;
  v7 = a1 - 2;
  do
  {
    v8 = *((_QWORD *)v7 + 1);
    v7 += 2;
    v3[1] = v8;
    ++v3;
  }
  while ( v7 != a1 + 14 );
  v552 = v7;
  v9 = v625 + v621 + v605;
  v10 = HIDWORD(v9) ^ 0x510E527F ^ a1[17];
  v11 = v10 - 205731576;
  v12 = v9 ^ 0xADE682D1 ^ a1[16];
  v13 = __CFADD__(v10, -205731576) + v12 + 1779033703;
  v14 = (((unsigned int)v625 ^ (v10 - 205731576)) >> 24) | ((HIDWORD(v625) ^ v13) << 8);
  v16 = (v9
       + v606
       + __PAIR64__(((HIDWORD(v625) ^ (unsigned int)v13) >> 24) | (((unsigned int)v625 ^ (v10 - 205731576)) << 8), v14)) >> 32;
  v15 = v9 + v606 + v14;
  v17 = v10 ^ v15;
  v18 = v12 ^ v16;
  v537 = __PAIR64__(v16, v15);
  v553 = ((HIDWORD(v625) ^ (unsigned int)v13) >> 24) | (((unsigned int)v625 ^ v11) << 8);
  v19 = HIWORD(v17) | (v18 << 16);
  v20 = v11 + v19;
  v544 = v14;
  v550 = HIWORD(v18) | (v17 << 16);
  v21 = v626 + v622 + v607;
  v543 = (__PAIR64__(v13, v11) + __PAIR64__(v550, v19)) >> 32;
  v549 = v19;
  v22 = HIDWORD(v21) ^ 0x9B05688C ^ v6[19];
  v23 = v22 - 2067093701;
  v24 = v21 ^ 0x2B3E6C1F ^ v6[18];
  v25 = __CFADD__(v22, -2067093701) + v24 - 1150833019;
  HIDWORD(v534) = ((HIDWORD(v626) ^ (unsigned int)v25) >> 24) | (((unsigned int)v626 ^ (v22 - 2067093701)) << 8);
  v27 = (v21
       + v608
       + __PAIR64__(HIDWORD(v534), (((unsigned int)v626 ^ (v22 - 2067093701)) >> 24) | ((HIDWORD(v626) ^ v25) << 8))) >> 32;
  v26 = v21 + v608 + ((((unsigned int)v626 ^ (v22 - 2067093701)) >> 24) | ((HIDWORD(v626) ^ v25) << 8));
  v28 = v22 ^ v26;
  LODWORD(v534) = (((unsigned int)v626 ^ v23) >> 24) | ((HIDWORD(v626) ^ v25) << 8);
  v29 = v24 ^ v27;
  v542 = __PAIR64__(v27, v26);
  v30 = v627 + v623 + v609;
  v565 = HIWORD(v29) | (v28 << 16);
  v547 = __PAIR64__(v25, v23) + __PAIR64__(v565, HIWORD(v28) | (v29 << 16));
  v31 = HIDWORD(v30) ^ 0x1F83D9AB ^ v6[21];
  v32 = v31 - 23791573;
  v33 = v30 ^ 0xFB41BD6B ^ v6[20];
  v34 = __CFADD__(v31, -23791573) + v33 + 1013904242;
  v560 = HIWORD(v28) | (v29 << 16);
  LODWORD(v35) = (((unsigned int)v627 ^ (v31 - 23791573)) >> 24) | ((HIDWORD(v627) ^ v34) << 8);
  HIDWORD(v35) = ((HIDWORD(v627) ^ (unsigned int)v34) >> 24) | (((unsigned int)v627 ^ (v31 - 23791573)) << 8);
  v36 = v30 + v610 + v35;
  v37 = v31 ^ v36;
  v38 = v33 ^ HIDWORD(v36);
  v40 = v32 + (HIWORD(v37) | (v38 << 16));
  v39 = (__PAIR64__(v34, v32) + __PAIR64__(HIWORD(v38) | (v37 << 16), HIWORD(v37) | (v38 << 16))) >> 32;
  v41 = v628 + v624 + v611;
  v581 = HIWORD(v37) | (v38 << 16);
  v584 = HIWORD(v38) | (v37 << 16);
  v42 = HIDWORD(v41) ^ 0x5BE0CD19 ^ v6[23];
  v536 = v42 + 1595750129;
  v43 = v41 ^ 0x137E2179 ^ v6[22];
  v44 = __CFADD__(v42, 1595750129) + v43 - 1521486534;
  v538 = (((unsigned int)v628 ^ (v42 + 1595750129)) >> 24) | ((HIDWORD(v628) ^ v44) << 8);
  v568 = ((HIDWORD(v628) ^ (unsigned int)v44) >> 24) | (((unsigned int)v628 ^ (v42 + 1595750129)) << 8);
  v545 = v41 + v612 + __PAIR64__(v568, v538);
  v45 = v43 ^ HIDWORD(v545);
  v46 = v42 ^ v545;
  v47 = HIWORD(v45) | (v46 << 16);
  v48 = HIWORD(v46) | (v45 << 16);
  v50 = v536 + v48;
  v49 = (__PAIR64__(v44, v536) + __PAIR64__(v47, v48)) >> 32;
  v52 = (v537 + v613 + ((2 * (v547 ^ v534)) | ((unsigned int)(HIDWORD(v547) ^ HIDWORD(v534)) >> 31))) >> 32;
  v51 = v537 + v613 + ((2 * (v547 ^ v534)) | ((unsigned int)(HIDWORD(v547) ^ HIDWORD(v534)) >> 31));
  v53 = __PAIR64__(v39, v40) ^ v35;
  v54 = v48 ^ v51;
  v55 = ((2 * (v547 ^ v534)) | ((unsigned int)(HIDWORD(v547) ^ HIDWORD(v534)) >> 31)) ^ (v40 + (v47 ^ v52));
  v57 = __PAIR64__(v39, v40) + __PAIR64__(v54, v47 ^ v52);
  v56 = (__PAIR64__(v39, v40) + __PAIR64__(v54, v47 ^ v52)) >> 32;
  v58 = ((__int64)(v547 ^ v534) >> 31) ^ v56;
  LODWORD(v586) = HIBYTE(v55) | (v58 << 8);
  HIDWORD(v586) = HIBYTE(v58) | (v55 << 8);
  v59 = 2 * HIDWORD(v53);
  v60 = v54 ^ HIDWORD(v35);
  *(_DWORD *)&v554[16] = HIDWORD(v35);
  HIDWORD(v53) = (2 * v53) | (HIDWORD(v53) >> 31);
  *(_DWORD *)&v554[12] = v51 + v614 + v586;
  v61 = v59 | ((unsigned int)v53 >> 31);
  v62 = v47 ^ v52 ^ *(_DWORD *)&v554[12];
  v63 = HIWORD(v62) | (v60 << 16);
  *(_QWORD *)&v548 = __PAIR64__(v56, v57) + __PAIR64__(HIWORD(v60) | (v62 << 16), v63);
  v602 = HIWORD(v60) | (v62 << 16);
  v64 = (v542 + v615 + __PAIR64__(v61, HIDWORD(v53))) >> 32;
  v65 = v542 + v615 + HIDWORD(v53);
  v66 = v65 ^ v549;
  v67 = v64 ^ v550;
  HIDWORD(v53) ^= v50 + (v64 ^ v550);
  v68 = v49 ^ v568;
  v70 = __PAIR64__(v49, v50) + __PAIR64__(v65 ^ v549, v64 ^ v550);
  v69 = (__PAIR64__(v49, v50) + __PAIR64__(v65 ^ v549, v64 ^ v550)) >> 32;
  v71 = v61 ^ v69;
  HIDWORD(v72) = HIBYTE(v71) | (HIDWORD(v53) << 8);
  v595 = HIBYTE(HIDWORD(v53)) | (v71 << 8);
  v74 = __PAIR64__(v64, v65) + v616;
  v73 = (__PAIR64__(v64, v65) + v616) >> 32;
  LODWORD(v72) = v74;
  *(_DWORD *)v604 = HIDWORD(v72);
  LODWORD(v75) = v617;
  v76 = v67 ^ (v74 + v595);
  v77 = v66 ^ ((v72 + __PAIR64__(v73, v595)) >> 32);
  HIDWORD(v35) = (2 * (v50 ^ v538)) | (v68 >> 31);
  v569 = v72 + __PAIR64__(v73, v595);
  HIDWORD(v53) = (2 * v68) | ((v50 ^ v538) >> 31);
  *(_DWORD *)&v604[4] = HIWORD(v76) | (v77 << 16);
  *((_QWORD *)&v548 + 1) = __PAIR64__(v69, v70) + __PAIR64__(HIWORD(v77) | (v76 << 16), *(unsigned int *)&v604[4]);
  HIDWORD(v75) = HIDWORD(v36);
  *(_DWORD *)&v604[8] = HIWORD(v77) | (v76 << 16);
  v78 = __PAIR64__(HIDWORD(v617), v36) + v75 + __PAIR64__(HIDWORD(v53), HIDWORD(v35));
  v79 = (v20 + (HIDWORD(v78) ^ v565)) ^ HIDWORD(v35);
  v80 = ((__PAIR64__(v543, v20) + __PAIR64__((unsigned int)v78 ^ v560, HIDWORD(v78) ^ (unsigned int)v565)) >> 32)
      ^ HIDWORD(v53);
  HIDWORD(v53) = HIBYTE(v79) | (v80 << 8);
  HIDWORD(v35) = HIBYTE(v80) | (v79 << 8);
  LODWORD(v72) = (2 * (v20 ^ v544)) | ((v543 ^ v553) >> 31);
  v571 = v78 + v618 + __PAIR64__(HIDWORD(v35), HIDWORD(v53));
  v81 = HIDWORD(v78) ^ v565 ^ v571;
  HIDWORD(v72) = v78 ^ v560 ^ HIDWORD(v571);
  LODWORD(v75) = (2 * (v543 ^ v553)) | ((v20 ^ v544) >> 31);
  LODWORD(v82) = HIWORD(v81) | (HIDWORD(v72) << 16);
  HIDWORD(v82) = HIWORD(HIDWORD(v72)) | (v81 << 16);
  v83 = v20 + (HIDWORD(v78) ^ v565) + v82;
  *(_QWORD *)&v604[12] = v82;
  v573 = (__PAIR64__(v543, v20) + __PAIR64__((unsigned int)v78 ^ v560, HIDWORD(v78) ^ (unsigned int)v565) + v82) >> 32;
  LODWORD(v35) = (v545 + v619 + v72) ^ v581;
  v84 = v545 + v619 + __PAIR64__(v75, v72);
  LODWORD(v72) = v72 ^ (v547 + (HIDWORD(v84) ^ v584));
  v566 = v83 ^ HIDWORD(v53);
  v85 = (v547 + __PAIR64__(v35, HIDWORD(v84) ^ (unsigned int)v584)) >> 32;
  LODWORD(v82) = v547 + (HIDWORD(v84) ^ v584);
  LODWORD(v75) = v75 ^ v85;
  v86 = BYTE3(v72) | ((_DWORD)v75 << 8);
  LODWORD(v72) = BYTE3(v75) | ((_DWORD)v72 << 8);
  HIDWORD(v547) = DWORD2(v548) ^ v595;
  v87 = v84 + v620 + __PAIR64__(v72, v86);
  HIDWORD(v75) = HIDWORD(v84) ^ v584 ^ v87;
  LODWORD(v35) = v35 ^ HIDWORD(v87);
  v561 = HIDWORD(v548) ^ *(_DWORD *)v604;
  LODWORD(v75) = HIWORD(HIDWORD(v75)) | ((_DWORD)v35 << 16);
  LODWORD(v35) = WORD1(v35) | (HIDWORD(v75) << 16);
  v88 = v75;
  v596 = v75;
  LODWORD(v75) = (v82 + v75) ^ v86;
  v90 = __PAIR64__(v85, v82) + __PAIR64__(v35, v88);
  v89 = (__PAIR64__(v85, v82) + __PAIR64__(v35, v88)) >> 32;
  LODWORD(v72) = v72 ^ v89;
  HIDWORD(v75) = (2 * v75) | ((unsigned int)v72 >> 31);
  HIDWORD(v35) ^= v573;
  LODWORD(v72) = (2 * v72) | ((unsigned int)v75 >> 31);
  v91 = *(_QWORD *)&v554[12] + v619 + __PAIR64__(v72, HIDWORD(v75));
  v93 = v83 + (HIDWORD(v91) ^ *(_DWORD *)&v604[8]);
  v92 = (__PAIR64__(v573, v83) + __PAIR64__((unsigned int)v91 ^ *(_DWORD *)&v604[4], HIDWORD(v91) ^ *(_DWORD *)&v604[8])) >> 32;
  LODWORD(v72) = v72 ^ v92;
  HIDWORD(v53) = BYTE3(v72);
  LODWORD(v72) = ((v93 ^ HIDWORD(v75)) >> 24) | ((_DWORD)v72 << 8);
  v94 = HIDWORD(v53) | ((v93 ^ HIDWORD(v75)) << 8);
  HIDWORD(v75) = HIDWORD(v569);
  v95 = v615 + v91 + __PAIR64__(v94, v72);
  HIDWORD(v72) = HIDWORD(v91) ^ *(_DWORD *)&v604[8] ^ v95;
  LODWORD(v53) = v91 ^ *(_DWORD *)&v604[4] ^ HIDWORD(v95);
  *(_DWORD *)&v604[4] = WORD1(v53) | (HIDWORD(v72) << 16);
  *(_DWORD *)v604 = HIWORD(HIDWORD(v72)) | ((_DWORD)v53 << 16);
  LODWORD(v75) = (2 * (v548 ^ v586)) | ((unsigned int)(DWORD1(v548) ^ HIDWORD(v586)) >> 31);
  v96 = v569;
  v570 = __PAIR64__(v92, v93) + *(_QWORD *)v604;
  v555 = (v93 + *(_DWORD *)v604) ^ v72;
  LODWORD(v72) = (v609
                + __PAIR64__(HIDWORD(v75), v96)
                + ((2 * ((unsigned __int64)v548 ^ v586)) | ((unsigned int)(DWORD1(v548) ^ HIDWORD(v586)) >> 31))) >> 32;
  v97 = v609 + v96 + v75;
  *(_DWORD *)&v554[12] = ((__PAIR64__(v92, v93) + *(_QWORD *)v604) >> 32) ^ v94;
  HIDWORD(v72) = v97 ^ *(_DWORD *)&v604[12];
  HIDWORD(v75) = v72 ^ *(_DWORD *)&v604[16];
  LODWORD(v75) = v75 ^ (v90 + (v72 ^ *(_DWORD *)&v604[16]));
  v99 = v90 + (v72 ^ *(_DWORD *)&v604[16]);
  v98 = (__PAIR64__(v89, v90) + (v72 ^ *(unsigned int *)&v604[16])) >> 32;
  HIDWORD(v82) = ((__int64)(v548 ^ v586) >> 31) ^ v98;
  v100 = HIBYTE(HIDWORD(v82));
  HIDWORD(v82) = BYTE3(v75) | (HIDWORD(v82) << 8);
  LODWORD(v75) = v100 | ((_DWORD)v75 << 8);
  v101 = v613 + v97 + HIDWORD(v82);
  LODWORD(v72) = (v613 + __PAIR64__(v72, v97) + __PAIR64__(v75, HIDWORD(v82))) >> 32;
  HIDWORD(v75) ^= v101;
  HIDWORD(v72) = v97 ^ *(_DWORD *)&v604[12] ^ v72;
  HIDWORD(v586) = v72;
  *(_DWORD *)&v604[12] = HIWORD(HIDWORD(v72)) | (HIDWORD(v75) << 16);
  *(_DWORD *)&v604[8] = HIWORD(HIDWORD(v75)) | (HIDWORD(v72) << 16);
  LODWORD(v72) = (2 * HIDWORD(v547)) | (v561 >> 31);
  LODWORD(v53) = (2 * v561) | (HIDWORD(v547) >> 31);
  v102 = v571;
  HIDWORD(v82) ^= v99 + *(_DWORD *)&v604[8];
  LODWORD(v571) = v99 + *(_DWORD *)&v604[8];
  v103 = v102;
  v104 = HIDWORD(v571);
  HIDWORD(v571) = (__PAIR64__(v98, v99) + *(_QWORD *)&v604[8]) >> 32;
  v105 = (v614 + v103 + v72) ^ v596;
  v106 = (v614 + __PAIR64__(v104, v103) + __PAIR64__(v53, v72)) >> 32;
  LODWORD(v82) = v614 + v103 + v72;
  LODWORD(v35) = v35 ^ v106;
  HIDWORD(v72) = ((unsigned __int64)v548 + __PAIR64__(v105, v35)) >> 32;
  v107 = v548 + v35;
  LODWORD(v72) = v72 ^ (v548 + v35);
  LODWORD(v53) = v53 ^ HIDWORD(v72);
  HIDWORD(v75) = BYTE3(v72) | ((_DWORD)v53 << 8);
  LODWORD(v72) = BYTE3(v53) | ((_DWORD)v72 << 8);
  LODWORD(v53) = (2 * (HIDWORD(v571) ^ v75)) | (HIDWORD(v82) >> 31);
  LODWORD(v35) = v35 ^ (v620 + v82 + HIDWORD(v75));
  v108 = v620 + __PAIR64__(v106, v82) + __PAIR64__(v72, HIDWORD(v75));
  v109 = v105 ^ HIDWORD(v108);
  v110 = WORD1(v35) | (v109 << 16);
  HIDWORD(v82) = (2 * HIDWORD(v82)) | ((HIDWORD(v571) ^ (unsigned int)v75) >> 31);
  LODWORD(v35) = HIWORD(v109) | ((_DWORD)v35 << 16);
  v111 = __PAIR64__(HIDWORD(v72), v107) + __PAIR64__(v35, v110);
  HIDWORD(v72) = (__PAIR64__(HIDWORD(v72), v107) + __PAIR64__(v35, v110)) >> 32;
  v112 = (2 * HIDWORD(v35)) | (v566 >> 31);
  LODWORD(v75) = (2 * v566) | (HIDWORD(v35) >> 31);
  LODWORD(v547) = v111 ^ HIDWORD(v75);
  *(_DWORD *)&v604[16] = v110;
  HIDWORD(v35) = (v618 + v87 + v75) ^ v63;
  v114 = (v618 + v87 + __PAIR64__(v112, v75)) >> 32;
  v113 = v618 + v87 + v75;
  *(_DWORD *)&v604[20] = v35;
  LODWORD(v548) = HIDWORD(v72) ^ v72;
  LODWORD(v75) = v75 ^ (DWORD2(v548) + (v114 ^ v602));
  LODWORD(v72) = (*((_QWORD *)&v548 + 1) + __PAIR64__(HIDWORD(v35), v114 ^ v602)) >> 32;
  LODWORD(v82) = DWORD2(v548) + (v114 ^ v602);
  v115 = v112 ^ v72;
  HIDWORD(v75) = HIBYTE(v115);
  v116 = BYTE3(v75) | (v115 << 8);
  LODWORD(v75) = HIDWORD(v75) | ((_DWORD)v75 << 8);
  v117 = v611 + __PAIR64__(v114, v113) + __PAIR64__(v75, v116);
  HIDWORD(v53) = v114 ^ v602 ^ v117;
  HIDWORD(v35) ^= HIDWORD(v117);
  v118 = HIWORD(HIDWORD(v35));
  HIDWORD(v35) = HIWORD(HIDWORD(v53)) | (HIDWORD(v35) << 16);
  v119 = v118 | (HIDWORD(v53) << 16);
  v120 = __PAIR64__(v72, v82) + __PAIR64__(v119, HIDWORD(v35));
  LODWORD(v72) = (__PAIR64__(v72, v82) + __PAIR64__(v119, HIDWORD(v35))) >> 32;
  HIDWORD(v75) = v120 ^ v116;
  LODWORD(v75) = v75 ^ v72;
  v121 = v606 + v95 + __PAIR64__(v53, HIDWORD(v82));
  HIDWORD(v35) ^= v121;
  v122 = v119 ^ HIDWORD(v121);
  v123 = __PAIR64__(HIDWORD(v72), v111) + __PAIR64__(HIDWORD(v35), v122);
  HIDWORD(v72) = (__PAIR64__(HIDWORD(v72), v111) + __PAIR64__(HIDWORD(v35), v122)) >> 32;
  HIDWORD(v82) ^= v123;
  LODWORD(v53) = v53 ^ HIDWORD(v72);
  HIDWORD(v53) = (v617 + v121) >> 32;
  LODWORD(v35) = BYTE3(v53);
  LODWORD(v53) = HIBYTE(HIDWORD(v82)) | ((_DWORD)v53 << 8);
  HIDWORD(v82) = v35 | (HIDWORD(v82) << 8);
  v124 = v122 ^ (v617 + v121 + v53);
  HIDWORD(v35) ^= (__PAIR64__(HIDWORD(v82), (int)v617 + (int)v121) + v53) >> 32;
  *(_DWORD *)&v554[16] = v617 + v121 + v53;
  v585 = (__PAIR64__(HIDWORD(v82), (int)v617 + (int)v121) + v53) >> 32;
  HIDWORD(v547) = HIWORD(HIDWORD(v35)) | (v124 << 16);
  v603 = HIWORD(v124) | (HIDWORD(v35) << 16);
  HIDWORD(v53) = (2 * v547) | ((unsigned int)v548 >> 31);
  LODWORD(v35) = (2 * v548) | ((unsigned int)v547 >> 31);
  DWORD1(v548) = (v123 + v603) ^ v53;
  LODWORD(v547) = HIDWORD(v547) + __CFADD__((_DWORD)v123, v603) + HIDWORD(v72);
  v125 = v605 + __PAIR64__(HIDWORD(v586), v101) + __PAIR64__(v35, HIDWORD(v53));
  HIDWORD(v53) ^= v120 + (HIDWORD(v125) ^ *(_DWORD *)&v604[4]);
  v126 = __PAIR64__(v72, v120) + __PAIR64__((unsigned int)v125 ^ *(_DWORD *)v604, HIDWORD(v125) ^ *(_DWORD *)&v604[4]);
  LODWORD(v72) = (__PAIR64__(v72, v120)
                + __PAIR64__((unsigned int)v125 ^ *(_DWORD *)v604, HIDWORD(v125) ^ *(_DWORD *)&v604[4])) >> 32;
  DWORD2(v548) = v547 ^ HIDWORD(v82);
  HIDWORD(v82) = HIBYTE(HIDWORD(v53)) | (((unsigned int)v72 ^ (unsigned int)v35) << 8);
  HIDWORD(v35) = (((unsigned int)v72 ^ (unsigned int)v35) >> 24) | (HIDWORD(v53) << 8);
  HIDWORD(v72) = HIDWORD(v125) ^ *(_DWORD *)&v604[4] ^ (v607 + v125 + HIDWORD(v82));
  LODWORD(v53) = v125 ^ *(_DWORD *)v604 ^ ((v607 + v125 + __PAIR64__(HIDWORD(v35), HIDWORD(v82))) >> 32);
  v587 = v607 + v125 + __PAIR64__(HIDWORD(v35), HIDWORD(v82));
  LODWORD(v127) = HIWORD(HIDWORD(v72)) | ((_DWORD)v53 << 16);
  v128 = 2 * v75;
  LODWORD(v75) = v75 >> 31;
  HIDWORD(v127) = WORD1(v53) | (HIDWORD(v72) << 16);
  v129 = v128 | (HIDWORD(v75) >> 31);
  HIDWORD(v72) = (__PAIR64__(v72, v126) + v127) >> 32;
  v601 = v126 + v127;
  HIDWORD(v548) = (v126 + v127) ^ HIDWORD(v82);
  LODWORD(v35) = (v616 + v108 + v75) ^ *(_DWORD *)&v604[8];
  LODWORD(v72) = (v616 + v108 + __PAIR64__(v129, v75)) >> 32;
  v130 = v616 + v108 + v75;
  v597 = HIDWORD(v72);
  v562 = HIDWORD(v72) ^ HIDWORD(v35);
  LODWORD(v75) = v75 ^ (v570 + (v72 ^ *(_DWORD *)&v604[12]));
  HIDWORD(v72) = (v570 + __PAIR64__(v35, (unsigned int)v72 ^ *(_DWORD *)&v604[12])) >> 32;
  LODWORD(v82) = v570 + (v72 ^ *(_DWORD *)&v604[12]);
  v131 = v129 ^ HIDWORD(v72);
  LODWORD(v53) = BYTE3(v75) | (v131 << 8);
  HIDWORD(v82) = HIBYTE(v131) | ((_DWORD)v75 << 8);
  v132 = v612 + __PAIR64__(v72, v130) + __PAIR64__(HIDWORD(v82), v53);
  HIDWORD(v53) = v72 ^ *(_DWORD *)&v604[12] ^ v132;
  LODWORD(v35) = v35 ^ HIDWORD(v132);
  *(_QWORD *)&v554[20] = v132;
  HIDWORD(v35) = WORD1(v35) | (HIDWORD(v53) << 16);
  v133 = HIWORD(HIDWORD(v53)) | ((_DWORD)v35 << 16);
  v134 = __PAIR64__(HIDWORD(v72), v82) + __PAIR64__(HIDWORD(v35), v133);
  HIDWORD(v72) = (__PAIR64__(HIDWORD(v72), v82) + __PAIR64__(HIDWORD(v35), v133)) >> 32;
  HIDWORD(v132) = (2 * v555) | (*(_DWORD *)&v554[12] >> 31);
  HIDWORD(v53) = (2 * *(_DWORD *)&v554[12]) | (v555 >> 31);
  *(_DWORD *)&v604[4] = HIDWORD(v35);
  v567 = HIDWORD(v72) ^ HIDWORD(v82);
  v556 = v134 ^ v53;
  HIDWORD(v35) = (v610 + v117 + HIDWORD(v132)) ^ *(_DWORD *)&v604[16];
  v135 = v610 + v117 + __PAIR64__(HIDWORD(v53), HIDWORD(v132));
  LODWORD(v35) = HIDWORD(v135) ^ *(_DWORD *)&v604[20];
  HIDWORD(v132) ^= v99 + *(_DWORD *)&v604[8] + (HIDWORD(v135) ^ *(_DWORD *)&v604[20]);
  LODWORD(v548) = v99 + *(_DWORD *)&v604[8] + (HIDWORD(v135) ^ *(_DWORD *)&v604[20]);
  LODWORD(v72) = (v571 + __PAIR64__(HIDWORD(v35), HIDWORD(v135) ^ *(_DWORD *)&v604[20])) >> 32;
  HIDWORD(v53) ^= v72;
  LODWORD(v132) = HIBYTE(HIDWORD(v132)) | (HIDWORD(v53) << 8);
  HIDWORD(v132) = HIBYTE(HIDWORD(v53)) | (HIDWORD(v132) << 8);
  v136 = v35 ^ (v608 + v135 + v132);
  v137 = v608 + v135 + v132;
  *(_DWORD *)&v554[12] = v608 + v135 + v132;
  v138 = HIWORD(HIDWORD(v136));
  HIDWORD(v136) = v136 >> 16;
  LODWORD(v136) = v138 | ((_DWORD)v136 << 16);
  LODWORD(v132) = v132 ^ (v548 + HIDWORD(v136));
  v139 = v548 + HIDWORD(v136);
  LODWORD(v72) = (__PAIR64__(v72, v548) + __PAIR64__(v136, HIDWORD(v136))) >> 32;
  HIDWORD(v132) ^= v72;
  LODWORD(v571) = HIDWORD(v137);
  HIDWORD(v137) = 2 * HIDWORD(v132);
  HIDWORD(v132) = (2 * v132) | (HIDWORD(v132) >> 31);
  LODWORD(v132) = HIDWORD(v137) | ((unsigned int)v132 >> 31);
  v140 = v616 + __PAIR64__(v585, *(unsigned int *)&v554[16]) + __PAIR64__(v132, HIDWORD(v132));
  v141 = v127 ^ v140;
  v142 = __PAIR64__(HIDWORD(v72), v134) + __PAIR64__(v141, HIDWORD(v141));
  HIDWORD(v72) = (__PAIR64__(HIDWORD(v72), v134) + __PAIR64__(v141, HIDWORD(v141))) >> 32;
  HIDWORD(v132) ^= v142;
  LODWORD(v132) = v132 ^ HIDWORD(v72);
  HIDWORD(v137) = BYTE3(v132);
  LODWORD(v132) = HIBYTE(HIDWORD(v132)) | ((_DWORD)v132 << 8);
  HIDWORD(v141) ^= v613 + v140 + (_DWORD)v132;
  *(_DWORD *)&v554[16] = v613 + v140 + v132;
  HIDWORD(v132) = HIDWORD(v137) | (HIDWORD(v132) << 8);
  LODWORD(v141) = v141 ^ ((v613 + v140 + v132) >> 32);
  HIDWORD(v571) = (v613 + v140 + v132) >> 32;
  HIDWORD(v137) = HIWORD(HIDWORD(v141)) | ((_DWORD)v141 << 16);
  *(_DWORD *)&v604[12] = v141 >> 16;
  v143 = __PAIR64__(HIDWORD(v72), v142) + ((v141 << 16) | HIWORD(HIDWORD(v141)));
  v144 = 2LL * *(_QWORD *)((char *)&v548 + 4);
  LODWORD(v144) = (2 * DWORD1(v548)) | (DWORD2(v548) >> 31);
  *(_QWORD *)&v548 = v143 ^ v132;
  v145 = v617 + v587 + v144;
  *(_DWORD *)&v604[8] = HIDWORD(v137);
  LODWORD(v144) = v144 ^ (v139 + (HIDWORD(v145) ^ *(_DWORD *)&v604[4]));
  v146 = __PAIR64__(v72, v139) + __PAIR64__((unsigned int)v145 ^ v133, HIDWORD(v145) ^ *(_DWORD *)&v604[4]);
  LODWORD(v72) = (__PAIR64__(v72, v139) + __PAIR64__((unsigned int)v145 ^ v133, HIDWORD(v145) ^ *(_DWORD *)&v604[4])) >> 32;
  HIDWORD(v144) ^= v72;
  HIDWORD(v132) = HIBYTE(HIDWORD(v144));
  HIDWORD(v144) = v144 >> 24;
  LODWORD(v144) = HIDWORD(v132) | ((_DWORD)v144 << 8);
  v147 = v605 + v145 + __PAIR64__(v144, HIDWORD(v144));
  LODWORD(v132) = HIDWORD(v145) ^ *(_DWORD *)&v604[4] ^ v147;
  HIDWORD(v72) = v145 ^ v133 ^ HIDWORD(v147);
  LODWORD(v82) = WORD1(v132);
  LODWORD(v132) = HIWORD(HIDWORD(v72)) | ((_DWORD)v132 << 16);
  HIDWORD(v72) = v82 | (HIDWORD(v72) << 16);
  v148 = __PAIR64__(v547, v132);
  v149 = __PAIR64__(v72, v146) + __PAIR64__(v132, HIDWORD(v72));
  LODWORD(v72) = (__PAIR64__(v72, v146) + __PAIR64__(v132, HIDWORD(v72))) >> 32;
  LODWORD(v132) = (2 * v562) | (HIDWORD(v548) >> 31);
  v150 = (2 * HIDWORD(v548)) | (v562 >> 31);
  *(_QWORD *)v604 = __PAIR64__(v148, HIDWORD(v72));
  HIDWORD(v72) = v149;
  v151 = *(_DWORD *)&v554[20];
  v152 = v144 ^ v72;
  *(_DWORD *)&v554[20] = v72;
  LODWORD(v72) = (v610 + __PAIR64__(*(unsigned int *)&v554[24], v151) + __PAIR64__(v132, v150)) >> 32;
  v153 = v610 + v151 + v150;
  LODWORD(v148) = v72 ^ v136;
  HIDWORD(v136) ^= v153;
  HIDWORD(v72) = (__PAIR64__(HIDWORD(v136), (int)v123 + v603) + v148) >> 32;
  HIDWORD(v132) = v123 + v603 + (v72 ^ v136);
  v154 = v150 ^ HIDWORD(v132);
  LODWORD(v132) = v132 ^ HIDWORD(v72);
  LODWORD(v137) = (2 * v152) | (HIDWORD(v152) >> 31);
  HIDWORD(v137) = HIBYTE(v154) | ((_DWORD)v132 << 8);
  LODWORD(v136) = BYTE3(v132) | (v154 << 8);
  v155 = v607 + __PAIR64__(v72, v153) + __PAIR64__(v136, HIDWORD(v137));
  LODWORD(v148) = v148 ^ v155;
  HIDWORD(v136) ^= HIDWORD(v155);
  HIDWORD(v148) = v152 >> 31;
  *(_DWORD *)&v604[16] = WORD1(v148) | (HIDWORD(v136) << 16);
  v156 = __PAIR64__(HIDWORD(v72), HIDWORD(v132))
       + __PAIR64__(HIWORD(HIDWORD(v136)) | ((_DWORD)v148 << 16), *(unsigned int *)&v604[16]);
  HIDWORD(v72) = (__PAIR64__(HIDWORD(v72), HIDWORD(v132))
                + __PAIR64__(HIWORD(HIDWORD(v136)) | ((_DWORD)v148 << 16), *(unsigned int *)&v604[16])) >> 32;
  HIDWORD(v132) = v156 ^ HIDWORD(v137);
  LODWORD(v132) = (2 * v556) | (v567 >> 31);
  *(_DWORD *)&v604[20] = HIWORD(HIDWORD(v136)) | ((_DWORD)v148 << 16);
  v157 = (2 * v567) | (v556 >> 31);
  v158 = (v620 + __PAIR64__(v571, *(unsigned int *)&v554[12]) + __PAIR64__(v157, v132)) >> 32;
  LODWORD(v152) = v620 + *(_DWORD *)&v554[12] + v132;
  HIDWORD(v137) = v158 ^ HIDWORD(v547);
  DWORD2(v548) = HIDWORD(v132);
  LODWORD(v148) = v601 + (v158 ^ HIDWORD(v547));
  HIDWORD(v547) = HIDWORD(v72) ^ v136;
  LODWORD(v132) = v132 ^ v148;
  LODWORD(v72) = (__PAIR64__(v597, v601) + __PAIR64__((unsigned int)v152 ^ v603, HIDWORD(v137))) >> 32;
  LODWORD(v148) = v601 + HIDWORD(v137);
  v159 = v157 ^ v72;
  HIDWORD(v132) = HIBYTE(v159);
  v160 = BYTE3(v132) | (v159 << 8);
  v162 = v618 + __PAIR64__(v158, v152);
  v161 = (v618 + __PAIR64__(v158, v152)) >> 32;
  HIDWORD(v137) ^= v162 + v160;
  *(_DWORD *)&v554[8] = v162 + v160;
  LODWORD(v132) = HIDWORD(v132) | ((_DWORD)v132 << 8);
  HIDWORD(v136) = v152 ^ v603 ^ ((__PAIR64__(v161, v162) + __PAIR64__(v132, v160)) >> 32);
  *(_DWORD *)&v554[12] = (__PAIR64__(v161, v162) + __PAIR64__(v132, v160)) >> 32;
  v163 = HIWORD(HIDWORD(v136));
  HIDWORD(v136) = HIWORD(HIDWORD(v137)) | (HIDWORD(v136) << 16);
  v164 = v163 | (HIDWORD(v137) << 16);
  v165 = __PAIR64__(v72, v148) + __PAIR64__(v164, HIDWORD(v136));
  LODWORD(v72) = (__PAIR64__(v72, v148) + __PAIR64__(v164, HIDWORD(v136))) >> 32;
  HIDWORD(v132) = v165 ^ v160;
  LODWORD(v132) = v132 ^ v72;
  v166 = v615 + __PAIR64__(HIDWORD(v571), *(unsigned int *)&v554[16]) + __PAIR64__(v137, HIDWORD(v148));
  HIDWORD(v136) ^= v166;
  v167 = v164 ^ HIDWORD(v166);
  v168 = __PAIR64__(HIDWORD(v72), v156) + __PAIR64__(HIDWORD(v136), v167);
  HIDWORD(v148) ^= v156 + v167;
  LODWORD(v137) = v137 ^ ((__PAIR64__(HIDWORD(v72), v156) + __PAIR64__(HIDWORD(v136), v167)) >> 32);
  LODWORD(v136) = BYTE3(v137);
  LODWORD(v137) = HIBYTE(HIDWORD(v148)) | ((_DWORD)v137 << 8);
  HIDWORD(v137) = (v619 + v166) >> 32;
  HIDWORD(v148) = v136 | (HIDWORD(v148) << 8);
  HIDWORD(v136) ^= (__PAIR64__(HIDWORD(v148), (int)v619 + (int)v166) + v137) >> 32;
  LODWORD(v571) = (__PAIR64__(HIDWORD(v148), (int)v619 + (int)v166) + v137) >> 32;
  v169 = v167 ^ (v619 + v166 + v137);
  *(_DWORD *)&v554[16] = v619 + v166 + v137;
  *(_DWORD *)&v598[8] = HIWORD(HIDWORD(v136)) | (v169 << 16);
  *(_DWORD *)&v598[4] = HIWORD(v169) | (HIDWORD(v136) << 16);
  HIDWORD(v137) = (2 * DWORD2(v548)) | (HIDWORD(v547) >> 31);
  LODWORD(v136) = (2 * HIDWORD(v547)) | (DWORD2(v548) >> 31);
  HIDWORD(v547) = (v168 + *(_DWORD *)&v598[4]) ^ v137;
  DWORD2(v548) = ((v168 + *(_QWORD *)&v598[4]) >> 32) ^ HIDWORD(v148);
  v170 = v608 + v147 + __PAIR64__(v136, HIDWORD(v137));
  HIDWORD(v137) ^= v165 + (HIDWORD(v170) ^ *(_DWORD *)&v604[12]);
  v171 = __PAIR64__(v72, v165)
       + __PAIR64__((unsigned int)v170 ^ *(_DWORD *)&v604[8], HIDWORD(v170) ^ *(_DWORD *)&v604[12]);
  LODWORD(v72) = (__PAIR64__(v72, v165)
                + __PAIR64__((unsigned int)v170 ^ *(_DWORD *)&v604[8], HIDWORD(v170) ^ *(_DWORD *)&v604[12])) >> 32;
  HIDWORD(v148) = HIBYTE(HIDWORD(v137)) | (((unsigned int)v72 ^ (unsigned int)v136) << 8);
  HIDWORD(v72) = (((unsigned int)v72 ^ (unsigned int)v136) >> 24) | (HIDWORD(v137) << 8);
  v172 = v611 + v170 + __PAIR64__(HIDWORD(v72), HIDWORD(v148));
  HIDWORD(v152) = ((v170 ^ *(_QWORD *)&v604[8]) >> 32) ^ v172;
  LODWORD(v152) = v170 ^ *(_DWORD *)&v604[8] ^ HIDWORD(v172);
  v173 = WORD1(v152);
  LODWORD(v152) = HIWORD(HIDWORD(v152)) | ((_DWORD)v152 << 16);
  HIDWORD(v152) = v173 | (HIDWORD(v152) << 16);
  v174 = 2 * v132;
  LODWORD(v132) = v132 >> 31;
  v175 = v174 | (HIDWORD(v132) >> 31);
  v176 = __PAIR64__(v72, v171) + v152;
  HIDWORD(v548) = (v171 + v152) ^ HIDWORD(v148);
  *(_DWORD *)&v554[24] = (__PAIR64__(v72, v171) + v152) >> 32;
  LODWORD(v136) = (v612 + v155 + v132) ^ *(_DWORD *)v604;
  v177 = v612 + v155 + v132;
  LODWORD(v72) = (v612 + v155 + __PAIR64__(v175, v132)) >> 32;
  v557 = *(_DWORD *)&v554[24] ^ HIDWORD(v72);
  LODWORD(v132) = v132 ^ (v143 + (v72 ^ *(_DWORD *)&v604[4]));
  HIDWORD(v72) = (v143 + __PAIR64__(v136, (unsigned int)v72 ^ *(_DWORD *)&v604[4])) >> 32;
  LODWORD(v148) = v143 + (v72 ^ *(_DWORD *)&v604[4]);
  v178 = v175 ^ HIDWORD(v72);
  LODWORD(v137) = BYTE3(v132) | (v178 << 8);
  HIDWORD(v148) = HIBYTE(v178) | ((_DWORD)v132 << 8);
  v179 = v606 + __PAIR64__(v72, v177) + __PAIR64__(HIDWORD(v148), v137);
  HIDWORD(v137) = v72 ^ *(_DWORD *)&v604[4] ^ v179;
  LODWORD(v136) = v136 ^ HIDWORD(v179);
  LODWORD(v72) = HIWORD(HIDWORD(v137)) | ((_DWORD)v136 << 16);
  v599 = v72;
  v180 = WORD1(v136) | (HIDWORD(v137) << 16);
  HIDWORD(v132) = (2 * v548) | (DWORD1(v548) >> 31);
  HIDWORD(v137) = (__int64)v548 >> 31;
  v181 = v148 + v72;
  HIDWORD(v72) = (__PAIR64__(v180, v148) + v72) >> 32;
  *(_DWORD *)v604 = v180;
  LODWORD(v548) = (v148 + v72) ^ v137;
  DWORD1(v548) = HIDWORD(v72) ^ HIDWORD(v148);
  v182 = v614 + *(_QWORD *)&v554[8] + __PAIR64__(HIDWORD(v137), HIDWORD(v132));
  HIDWORD(v136) = v182 ^ *(_DWORD *)&v604[16];
  LODWORD(v136) = HIDWORD(v182) ^ *(_DWORD *)&v604[20];
  HIDWORD(v132) ^= v149 + (HIDWORD(v182) ^ *(_DWORD *)&v604[20]);
  HIDWORD(v148) = v149 + (HIDWORD(v182) ^ *(_DWORD *)&v604[20]);
  HIDWORD(v137) ^= (__PAIR64__(*(unsigned int *)&v554[20], v149) + v136) >> 32;
  v563 = (__PAIR64__(*(unsigned int *)&v554[20], v149) + v136) >> 32;
  LODWORD(v132) = HIBYTE(HIDWORD(v132)) | (HIDWORD(v137) << 8);
  HIDWORD(v132) = HIBYTE(HIDWORD(v137)) | (HIDWORD(v132) << 8);
  v183 = v136 ^ (v609 + v182 + v132);
  v184 = WORD1(v183);
  *(_QWORD *)&v554[8] = v609 + v182 + v132;
  LODWORD(v183) = HIWORD(HIDWORD(v183)) | ((_DWORD)v183 << 16);
  HIDWORD(v183) = v184 | (HIDWORD(v183) << 16);
  LODWORD(v132) = v132 ^ (HIDWORD(v148) + HIDWORD(v183));
  LODWORD(v72) = (__PAIR64__(v563, HIDWORD(v148)) + __PAIR64__(v183, HIDWORD(v183))) >> 32;
  HIDWORD(v148) += HIDWORD(v183);
  HIDWORD(v132) ^= v72;
  HIDWORD(v137) = 2 * HIDWORD(v132);
  HIDWORD(v132) = (2 * v132) | (HIDWORD(v132) >> 31);
  LODWORD(v132) = HIDWORD(v137) | ((unsigned int)v132 >> 31);
  v185 = v612 + __PAIR64__(v571, *(unsigned int *)&v554[16]) + __PAIR64__(v132, HIDWORD(v132));
  v186 = v152 ^ v185;
  v187 = __PAIR64__(HIDWORD(v72), v181) + __PAIR64__(v186, HIDWORD(v186));
  HIDWORD(v72) = (__PAIR64__(HIDWORD(v72), v181) + __PAIR64__(v186, HIDWORD(v186))) >> 32;
  HIDWORD(v132) ^= v187;
  LODWORD(v132) = v132 ^ HIDWORD(v72);
  HIDWORD(v137) = BYTE3(v132);
  LODWORD(v132) = HIBYTE(HIDWORD(v132)) | ((_DWORD)v132 << 8);
  HIDWORD(v132) = HIDWORD(v137) | (HIDWORD(v132) << 8);
  v188 = v186;
  HIDWORD(v186) ^= v614 + v185 + (_DWORD)v132;
  *(_QWORD *)&v554[16] = v614 + v185 + v132;
  LODWORD(v186) = HIWORD(HIDWORD(v186)) | (((unsigned int)v186 ^ *(_DWORD *)&v554[20]) << 16);
  HIDWORD(v186) = ((v188 ^ *(_DWORD *)&v554[20]) >> 16) | (HIDWORD(v186) << 16);
  *(_QWORD *)&v604[4] = v186;
  v189 = __PAIR64__(HIDWORD(v72), v187) + v186;
  HIDWORD(v72) = (__PAIR64__(HIDWORD(v72), v187) + v186) >> 32;
  LODWORD(v186) = (2 * HIDWORD(v547)) | (DWORD2(v548) >> 31);
  HIDWORD(v186) = (2 * DWORD2(v548)) | (HIDWORD(v547) >> 31);
  v574 = HIDWORD(v72);
  DWORD2(v548) = v189 ^ v132;
  v564 = HIDWORD(v72) ^ HIDWORD(v132);
  HIDWORD(v72) = (v608 + v172 + v186) ^ v599;
  v190 = v608 + v172 + v186;
  LODWORD(v186) = v186 ^ (HIDWORD(v148) + (HIDWORD(v190) ^ *(_DWORD *)v604));
  v191 = __PAIR64__(v72, HIDWORD(v148)) + __PAIR64__(HIDWORD(v72), HIDWORD(v190) ^ *(_DWORD *)v604);
  LODWORD(v72) = (__PAIR64__(v72, HIDWORD(v148)) + __PAIR64__(HIDWORD(v72), HIDWORD(v190) ^ *(_DWORD *)v604)) >> 32;
  HIDWORD(v186) ^= v72;
  HIDWORD(v132) = HIBYTE(HIDWORD(v186));
  HIDWORD(v186) = v186 >> 24;
  LODWORD(v186) = HIDWORD(v132) | ((_DWORD)v186 << 8);
  LODWORD(v132) = HIDWORD(v190) ^ *(_DWORD *)v604 ^ (v606 + v190 + HIDWORD(v186));
  HIDWORD(v72) ^= (v606 + v190 + __PAIR64__(v186, HIDWORD(v186))) >> 32;
  v600 = (v606 + v190 + __PAIR64__(v186, HIDWORD(v186))) >> 32;
  LODWORD(v587) = v606 + v190 + HIDWORD(v186);
  *(_DWORD *)&v604[12] = HIWORD(HIDWORD(v72)) | ((_DWORD)v132 << 16);
  LODWORD(v148) = WORD1(v132) | (HIDWORD(v72) << 16);
  v192 = __CFADD__((_DWORD)v191, (_DWORD)v148);
  *(_DWORD *)v604 = v148;
  HIDWORD(v72) = (2 * HIDWORD(v548)) | (v557 >> 31);
  v193 = (2 * v557) | (HIDWORD(v548) >> 31);
  LODWORD(v148) = v191 + v148;
  HIDWORD(v148) = *(_DWORD *)&v604[12] + v192 + (_DWORD)v72;
  HIDWORD(v186) ^= v148;
  v582 = v148;
  LODWORD(v186) = v186 ^ HIDWORD(v148);
  LODWORD(v72) = (v618 + v179 + __PAIR64__(v193, HIDWORD(v72))) >> 32;
  v194 = v618 + v179 + HIDWORD(v72);
  HIDWORD(v183) ^= v194;
  LODWORD(v132) = v72 ^ v183;
  HIDWORD(v72) ^= v168 + *(_DWORD *)&v598[4] + (v72 ^ v183);
  LODWORD(v137) = (2 * v186) | (HIDWORD(v186) >> 31);
  LODWORD(v148) = (v168 + *(_QWORD *)&v598[4] + (v183 ^ (unsigned int)v72)) >> 32;
  HIDWORD(v132) = v168 + *(_DWORD *)&v598[4] + (v183 ^ v72);
  v195 = v193 ^ v148;
  HIDWORD(v137) = HIBYTE(HIDWORD(v72)) | (v195 << 8);
  LODWORD(v183) = HIBYTE(v195) | (HIDWORD(v72) << 8);
  v196 = v617 + __PAIR64__(v72, v194) + __PAIR64__(v183, HIDWORD(v137));
  HIDWORD(v183) ^= HIDWORD(v196);
  v197 = HIWORD(HIDWORD(v183));
  HIDWORD(v183) = (((unsigned int)v196 ^ (unsigned int)v132) >> 16) | (HIDWORD(v183) << 16);
  HIDWORD(v72) = v197 | (((unsigned int)v196 ^ (unsigned int)v132) << 16);
  HIDWORD(v148) = 2 * HIDWORD(v186);
  HIDWORD(v186) = HIDWORD(v132) + HIDWORD(v183);
  *(_DWORD *)&v604[16] = HIDWORD(v183);
  HIDWORD(v148) |= (unsigned int)v186 >> 31;
  LODWORD(v132) = (2 * v548) | (DWORD1(v548) >> 31);
  v198 = (__int64)v548 >> 31;
  LODWORD(v547) = (HIDWORD(v132) + HIDWORD(v183)) ^ HIDWORD(v137);
  *(_DWORD *)&v604[20] = HIDWORD(v72);
  HIDWORD(v72) += __CFADD__(HIDWORD(v132), HIDWORD(v183)) + (_DWORD)v148;
  HIDWORD(v183) = (v616 + *(_DWORD *)&v554[8] + v132) ^ *(_DWORD *)&v598[4];
  LODWORD(v548) = HIDWORD(v72) ^ v183;
  v199 = (v616 + *(_QWORD *)&v554[8] + __PAIR64__(v198, v132)) >> 32;
  LODWORD(v186) = v616 + *(_DWORD *)&v554[8] + v132;
  LODWORD(v132) = v132 ^ (v176 + (v199 ^ *(_DWORD *)&v598[8]));
  LODWORD(v72) = (__PAIR64__(*(unsigned int *)&v554[24], v176) + __PAIR64__(HIDWORD(v183), v199 ^ *(_DWORD *)&v598[8])) >> 32;
  LODWORD(v148) = v176 + (v199 ^ *(_DWORD *)&v598[8]);
  v200 = v198 ^ v72;
  LODWORD(v183) = BYTE3(v132);
  LODWORD(v132) = HIBYTE(v200) | ((_DWORD)v132 << 8);
  v201 = v183 | (v200 << 8);
  v202 = v619 + __PAIR64__(v199, v186) + __PAIR64__(v132, v201);
  HIDWORD(v137) = v199 ^ *(_DWORD *)&v598[8] ^ v202;
  HIDWORD(v183) ^= HIDWORD(v202);
  v203 = HIWORD(HIDWORD(v183));
  HIDWORD(v183) = HIWORD(HIDWORD(v137)) | (HIDWORD(v183) << 16);
  v204 = v203 | (HIDWORD(v137) << 16);
  v205 = __PAIR64__(v72, v148) + __PAIR64__(v204, HIDWORD(v183));
  LODWORD(v72) = (__PAIR64__(v72, v148) + __PAIR64__(v204, HIDWORD(v183))) >> 32;
  LODWORD(v132) = v132 ^ v72;
  v206 = v607 + *(_QWORD *)&v554[16] + __PAIR64__(v137, HIDWORD(v148));
  HIDWORD(v132) = v205 ^ v201;
  v207 = v204 ^ HIDWORD(v206);
  HIDWORD(v183) ^= v206;
  HIDWORD(v148) ^= HIDWORD(v186) + v207;
  v208 = HIDWORD(v186) + v207;
  HIDWORD(v72) = (__PAIR64__(HIDWORD(v72), HIDWORD(v186)) + __PAIR64__(HIDWORD(v183), v207)) >> 32;
  HIDWORD(v137) = (v611 + v206) >> 32;
  LODWORD(v137) = v137 ^ HIDWORD(v72);
  LODWORD(v183) = BYTE3(v137);
  LODWORD(v137) = HIBYTE(HIDWORD(v148)) | ((_DWORD)v137 << 8);
  HIDWORD(v148) = v183 | (HIDWORD(v148) << 8);
  v209 = v207 ^ (v611 + v206 + v137);
  HIDWORD(v183) ^= (__PAIR64__(HIDWORD(v148), (int)v611 + (int)v206) + v137) >> 32;
  *(_QWORD *)&v554[16] = __PAIR64__(HIDWORD(v148), (int)v611 + (int)v206) + v137;
  v210 = HIWORD(v209) | (HIDWORD(v183) << 16);
  HIDWORD(v547) = HIWORD(HIDWORD(v183)) | (v209 << 16);
  *(_DWORD *)&v598[8] = v210;
  HIDWORD(v137) = (2 * v547) | ((unsigned int)v548 >> 31);
  LODWORD(v183) = (2 * v548) | ((unsigned int)v547 >> 31);
  *(_DWORD *)&v554[24] = v208 + v210;
  HIDWORD(v571) = HIDWORD(v547) + __CFADD__(v208, v210) + HIDWORD(v72);
  LODWORD(v548) = HIDWORD(v571) ^ HIDWORD(v148);
  LODWORD(v547) = (v208 + v210) ^ v137;
  v211 = v610 + __PAIR64__(v600, v587) + __PAIR64__(v183, HIDWORD(v137));
  v212 = __PAIR64__(v72, v205)
       + __PAIR64__((unsigned int)v211 ^ *(_DWORD *)&v604[4], HIDWORD(v211) ^ *(_DWORD *)&v604[8]);
  LODWORD(v72) = (__PAIR64__(v72, v205)
                + __PAIR64__((unsigned int)v211 ^ *(_DWORD *)&v604[4], HIDWORD(v211) ^ *(_DWORD *)&v604[8])) >> 32;
  HIDWORD(v137) ^= v212;
  HIDWORD(v148) = HIBYTE(HIDWORD(v137)) | (((unsigned int)v72 ^ (unsigned int)v183) << 8);
  HIDWORD(v72) = (((unsigned int)v72 ^ (unsigned int)v183) >> 24) | (HIDWORD(v137) << 8);
  HIDWORD(v186) = ((v211 ^ *(_QWORD *)&v604[4]) >> 32) ^ (v615 + v211 + HIDWORD(v148));
  LODWORD(v186) = v211 ^ *(_DWORD *)&v604[4] ^ ((v615 + v211 + __PAIR64__(HIDWORD(v72), HIDWORD(v148))) >> 32);
  v213 = WORD1(v186);
  v588 = v615 + v211 + __PAIR64__(HIDWORD(v72), HIDWORD(v148));
  LODWORD(v186) = HIWORD(HIDWORD(v186)) | ((_DWORD)v186 << 16);
  HIDWORD(v186) = v213 | (HIDWORD(v186) << 16);
  v214 = 2 * v132;
  LODWORD(v132) = v132 >> 31;
  v215 = v214 | (HIDWORD(v132) >> 31);
  HIDWORD(v132) = (__PAIR64__(v72, v212) + v186) >> 32;
  *(_QWORD *)v598 = __PAIR64__(v72, v212) + v186;
  DWORD1(v548) = (v212 + v186) ^ HIDWORD(v148);
  LODWORD(v72) = (v609 + v196 + __PAIR64__(v215, v132)) >> 32;
  v216 = v609 + v196 + v132;
  HIDWORD(v548) = HIDWORD(v132) ^ HIDWORD(v72);
  LODWORD(v132) = v132 ^ (v189 + (v72 ^ *(_DWORD *)&v604[12]));
  HIDWORD(v72) = (__PAIR64__(v574, v189) + __PAIR64__(v216 ^ *(_DWORD *)v604, (unsigned int)v72 ^ *(_DWORD *)&v604[12])) >> 32;
  v217 = v215 ^ HIDWORD(v72);
  LODWORD(v137) = BYTE3(v132) | (v217 << 8);
  HIDWORD(v148) = HIBYTE(v217) | ((_DWORD)v132 << 8);
  v218 = v605 + __PAIR64__(v72, v216) + __PAIR64__(HIDWORD(v148), v137);
  HIDWORD(v137) = v72 ^ *(_DWORD *)&v604[12] ^ v218;
  LODWORD(v183) = v216 ^ *(_DWORD *)v604 ^ HIDWORD(v218);
  v219 = WORD1(v183);
  LODWORD(v183) = HIWORD(HIDWORD(v137)) | ((_DWORD)v183 << 16);
  HIDWORD(v183) = v219 | (HIDWORD(v137) << 16);
  HIDWORD(v132) = (2 * DWORD2(v548)) | (v564 >> 31);
  HIDWORD(v137) = (2 * v564) | (DWORD2(v548) >> 31);
  v220 = __PAIR64__(v574, v189) + __PAIR64__(v216 ^ *(_DWORD *)v604, (unsigned int)v72 ^ *(_DWORD *)&v604[12]) + v183;
  *(_QWORD *)v604 = v183;
  DWORD2(v548) = v220 ^ v137;
  v221 = v620 + v202 + __PAIR64__(HIDWORD(v137), HIDWORD(v132));
  HIDWORD(v183) = v221 ^ *(_DWORD *)&v604[16];
  v558 = HIDWORD(v220) ^ HIDWORD(v148);
  LODWORD(v183) = HIDWORD(v221) ^ *(_DWORD *)&v604[20];
  LODWORD(v72) = (v582 + v183) >> 32;
  HIDWORD(v148) = v582 + (HIDWORD(v221) ^ *(_DWORD *)&v604[20]);
  HIDWORD(v132) ^= HIDWORD(v148);
  HIDWORD(v137) ^= v72;
  LODWORD(v132) = HIBYTE(HIDWORD(v132));
  HIDWORD(v132) = HIBYTE(HIDWORD(v137)) | (HIDWORD(v132) << 8);
  LODWORD(v132) = v132 | (HIDWORD(v137) << 8);
  v222 = v183 ^ (v613 + v221 + v132);
  v223 = HIWORD(HIDWORD(v222));
  LODWORD(v582) = (v613 + v221 + v132) >> 32;
  HIDWORD(v222) = v222 >> 16;
  LODWORD(v222) = v223 | ((_DWORD)v222 << 16);
  *(_DWORD *)&v554[12] = v613 + v221 + v132;
  LODWORD(v132) = v132 ^ (HIDWORD(v148) + HIDWORD(v222));
  v224 = __PAIR64__(v72, HIDWORD(v148)) + __PAIR64__(v222, HIDWORD(v222));
  LODWORD(v72) = (__PAIR64__(v72, HIDWORD(v148)) + __PAIR64__(v222, HIDWORD(v222))) >> 32;
  HIDWORD(v132) ^= v72;
  HIDWORD(v137) = 2 * HIDWORD(v132);
  HIDWORD(v132) = (2 * v132) | (HIDWORD(v132) >> 31);
  LODWORD(v132) = HIDWORD(v137) | ((unsigned int)v132 >> 31);
  v225 = v614 + *(_QWORD *)&v554[16] + __PAIR64__(v132, HIDWORD(v132));
  v226 = v186 ^ v225;
  HIDWORD(v132) ^= v220 + HIDWORD(v226);
  v227 = v220 + __PAIR64__(v226, HIDWORD(v226));
  HIDWORD(v72) = (v220 + __PAIR64__(v226, HIDWORD(v226))) >> 32;
  LODWORD(v132) = v132 ^ HIDWORD(v72);
  HIDWORD(v137) = BYTE3(v132);
  LODWORD(v132) = HIBYTE(HIDWORD(v132)) | ((_DWORD)v132 << 8);
  HIDWORD(v132) = HIDWORD(v137) | (HIDWORD(v132) << 8);
  HIDWORD(v226) ^= v605 + v225 + (_DWORD)v132;
  LODWORD(v226) = v226 ^ ((v605 + v225 + v132) >> 32);
  *(_QWORD *)&v554[16] = v605 + v225 + v132;
  *(_DWORD *)&v604[8] = HIWORD(HIDWORD(v226)) | ((_DWORD)v226 << 16);
  v228 = v226 >> 16;
  v229 = __PAIR64__(HIDWORD(v72), v227) + ((v226 << 16) | HIWORD(HIDWORD(v226)));
  LODWORD(v226) = (2 * v547) | ((unsigned int)v548 >> 31);
  HIDWORD(v226) = (2 * v548) | ((unsigned int)v547 >> 31);
  *(_DWORD *)&v604[12] = v228;
  *(_QWORD *)&v554[4] = v229 ^ v132;
  v230 = v610 + v588 + v226;
  LODWORD(v226) = v226 ^ (v224 + (HIDWORD(v230) ^ *(_DWORD *)&v604[4]));
  v231 = __PAIR64__(v72, v224) + __PAIR64__((unsigned int)v230 ^ *(_DWORD *)v604, HIDWORD(v230) ^ *(_DWORD *)&v604[4]);
  LODWORD(v72) = (__PAIR64__(v72, v224)
                + __PAIR64__((unsigned int)v230 ^ *(_DWORD *)v604, HIDWORD(v230) ^ *(_DWORD *)&v604[4])) >> 32;
  HIDWORD(v226) ^= v72;
  HIDWORD(v132) = HIBYTE(HIDWORD(v226));
  HIDWORD(v226) = v226 >> 24;
  LODWORD(v226) = HIDWORD(v132) | ((_DWORD)v226 << 8);
  v232 = v612 + v230 + __PAIR64__(v226, HIDWORD(v226));
  LODWORD(v132) = HIDWORD(v230) ^ *(_DWORD *)&v604[4] ^ v232;
  HIDWORD(v72) = v230 ^ *(_DWORD *)v604 ^ HIDWORD(v232);
  v233 = HIWORD(HIDWORD(v72)) | ((_DWORD)v132 << 16);
  *(_DWORD *)v604 = WORD1(v132) | (HIDWORD(v72) << 16);
  HIDWORD(v72) = (2 * DWORD1(v548)) | (HIDWORD(v548) >> 31);
  v234 = (2 * HIDWORD(v548)) | (DWORD1(v548) >> 31);
  *(_DWORD *)&v604[4] = v233;
  LODWORD(v226) = v226 ^ (v233 + __CFADD__((_DWORD)v231, *(_DWORD *)v604) + (_DWORD)v72);
  LODWORD(v571) = v231 + *(_DWORD *)v604;
  HIDWORD(v226) ^= v231 + *(_DWORD *)v604;
  v575 = v233 + __CFADD__((_DWORD)v231, *(_DWORD *)v604) + (_DWORD)v72;
  LODWORD(v137) = (2 * v226) | (HIDWORD(v226) >> 31);
  LODWORD(v72) = (v607 + v218 + __PAIR64__(v234, HIDWORD(v72))) >> 32;
  v235 = v607 + v218 + HIDWORD(v72);
  HIDWORD(v222) ^= v235;
  LODWORD(v132) = v72 ^ v222;
  HIDWORD(v72) ^= *(_DWORD *)&v554[24] + (v72 ^ v222);
  LODWORD(v148) = (__PAIR64__(HIDWORD(v571), *(unsigned int *)&v554[24]) + (v222 ^ (unsigned int)v72)) >> 32;
  HIDWORD(v132) = *(_DWORD *)&v554[24] + (v222 ^ v72);
  v236 = v234 ^ v148;
  HIDWORD(v137) = HIBYTE(HIDWORD(v72)) | (v236 << 8);
  LODWORD(v222) = HIBYTE(v236) | (HIDWORD(v72) << 8);
  v237 = v609 + __PAIR64__(v72, v235) + __PAIR64__(v222, HIDWORD(v137));
  HIDWORD(v222) ^= HIDWORD(v237);
  *(_DWORD *)&v604[20] = HIWORD(HIDWORD(v222)) | (((unsigned int)v237 ^ (unsigned int)v132) << 16);
  *(_DWORD *)&v604[16] = (((unsigned int)v237 ^ (unsigned int)v132) >> 16) | (HIDWORD(v222) << 16);
  LODWORD(v132) = (2 * DWORD2(v548)) | (v558 >> 31);
  v238 = (2 * v558) | (DWORD2(v548) >> 31);
  HIDWORD(v148) = v226 >> 31;
  HIDWORD(v72) = (__PAIR64__(v148, HIDWORD(v132)) + *(_QWORD *)&v604[16]) >> 32;
  DWORD2(v548) = HIDWORD(v132) + *(_DWORD *)&v604[16];
  LODWORD(v548) = (HIDWORD(v132) + *(_DWORD *)&v604[16]) ^ HIDWORD(v137);
  v239 = (v615 + __PAIR64__(v582, *(unsigned int *)&v554[12]) + __PAIR64__(v238, v132)) >> 32;
  LODWORD(v226) = v615 + *(_DWORD *)&v554[12] + v132;
  DWORD1(v548) = HIDWORD(v72) ^ v222;
  LODWORD(v132) = v132 ^ (*(_DWORD *)v598 + (v239 ^ HIDWORD(v547)));
  LODWORD(v72) = (*(_QWORD *)v598 + __PAIR64__((unsigned int)v226 ^ *(_DWORD *)&v598[8], v239 ^ HIDWORD(v547))) >> 32;
  LODWORD(v148) = *(_DWORD *)v598 + (v239 ^ HIDWORD(v547));
  v240 = v238 ^ v72;
  HIDWORD(v132) = HIBYTE(v240);
  v241 = BYTE3(v132) | (v240 << 8);
  LODWORD(v132) = HIDWORD(v132) | ((_DWORD)v132 << 8);
  HIDWORD(v226) = (v620 + __PAIR64__(v239, v226) + __PAIR64__(v132, v241)) >> 32;
  HIDWORD(v137) = v239 ^ HIDWORD(v547) ^ (v620 + v226 + v241);
  HIDWORD(v222) = v226 ^ *(_DWORD *)&v598[8] ^ HIDWORD(v226);
  v242 = HIWORD(HIDWORD(v222));
  *(_DWORD *)&v554[12] = v620 + v226 + v241;
  HIDWORD(v222) = HIWORD(HIDWORD(v137)) | (HIDWORD(v222) << 16);
  v243 = v242 | (HIDWORD(v137) << 16);
  HIDWORD(v571) = HIDWORD(v226);
  v244 = __PAIR64__(v72, v148) + __PAIR64__(v243, HIDWORD(v222));
  LODWORD(v72) = (__PAIR64__(v72, v148) + __PAIR64__(v243, HIDWORD(v222))) >> 32;
  HIDWORD(v132) = v244 ^ v241;
  LODWORD(v132) = v132 ^ v72;
  v245 = v619 + *(_QWORD *)&v554[16] + __PAIR64__(v137, HIDWORD(v148));
  HIDWORD(v222) ^= v245;
  v246 = v243 ^ HIDWORD(v245);
  v247 = __PAIR64__(HIDWORD(v72), DWORD2(v548)) + __PAIR64__(HIDWORD(v222), v246);
  HIDWORD(v72) = (__PAIR64__(HIDWORD(v72), DWORD2(v548)) + __PAIR64__(HIDWORD(v222), v246)) >> 32;
  HIDWORD(v148) ^= v247;
  LODWORD(v137) = v137 ^ HIDWORD(v72);
  LODWORD(v222) = BYTE3(v137);
  LODWORD(v137) = HIBYTE(HIDWORD(v148)) | ((_DWORD)v137 << 8);
  HIDWORD(v137) = (v606 + v245) >> 32;
  HIDWORD(v148) = v222 | (HIDWORD(v148) << 8);
  v248 = v246 ^ (v606 + v245 + v137);
  HIDWORD(v222) ^= (__PAIR64__(HIDWORD(v148), (int)v606 + (int)v245) + v137) >> 32;
  *(_QWORD *)&v554[16] = __PAIR64__(HIDWORD(v148), (int)v606 + (int)v245) + v137;
  HIDWORD(v137) = HIWORD(HIDWORD(v222));
  v249 = HIWORD(v248) | (HIDWORD(v222) << 16);
  HIDWORD(v222) = v548;
  LODWORD(v548) = HIDWORD(v137) | (v248 << 16);
  *(_DWORD *)&v598[8] = v249;
  LODWORD(v582) = v247 + v249;
  HIDWORD(v137) = (2 * HIDWORD(v222)) | (DWORD1(v548) >> 31);
  LODWORD(v222) = (2 * DWORD1(v548)) | (HIDWORD(v222) >> 31);
  HIDWORD(v547) = v548 + __CFADD__((_DWORD)v247, v249) + HIDWORD(v72);
  DWORD1(v548) = (v247 + v249) ^ v137;
  v250 = v616 + v232 + __PAIR64__(v222, HIDWORD(v137));
  HIDWORD(v137) ^= v244 + (HIDWORD(v250) ^ *(_DWORD *)&v604[12]);
  v251 = __PAIR64__(v72, v244)
       + __PAIR64__((unsigned int)v250 ^ *(_DWORD *)&v604[8], HIDWORD(v250) ^ *(_DWORD *)&v604[12]);
  LODWORD(v72) = (__PAIR64__(v72, v244)
                + __PAIR64__((unsigned int)v250 ^ *(_DWORD *)&v604[8], HIDWORD(v250) ^ *(_DWORD *)&v604[12])) >> 32;
  DWORD2(v548) = HIDWORD(v547) ^ HIDWORD(v148);
  HIDWORD(v148) = HIBYTE(HIDWORD(v137)) | (((unsigned int)v72 ^ (unsigned int)v222) << 8);
  HIDWORD(v72) = (((unsigned int)v72 ^ (unsigned int)v222) >> 24) | (HIDWORD(v137) << 8);
  HIDWORD(v226) = ((v250 ^ *(_QWORD *)&v604[8]) >> 32) ^ (v617 + v250 + HIDWORD(v148));
  LODWORD(v226) = v250 ^ *(_DWORD *)&v604[8] ^ ((v617 + v250 + __PAIR64__(HIDWORD(v72), HIDWORD(v148))) >> 32);
  v252 = WORD1(v226);
  v589 = v617 + v250 + __PAIR64__(HIDWORD(v72), HIDWORD(v148));
  LODWORD(v226) = HIWORD(HIDWORD(v226)) | ((_DWORD)v226 << 16);
  HIDWORD(v226) = v252 | (HIDWORD(v226) << 16);
  v253 = (2 * v132) | (HIDWORD(v132) >> 31);
  *(_DWORD *)v598 = v251 + v226;
  LODWORD(v132) = v132 >> 31;
  HIDWORD(v548) = (v251 + v226) ^ HIDWORD(v148);
  *(_DWORD *)&v554[24] = (__PAIR64__(v72, v251) + v226) >> 32;
  LODWORD(v222) = (v611 + v237 + v132) ^ *(_DWORD *)v604;
  v254 = v611 + v237 + v132;
  LODWORD(v72) = (v611 + v237 + __PAIR64__(v253, v132)) >> 32;
  v559 = *(_DWORD *)&v554[24] ^ HIDWORD(v72);
  LODWORD(v132) = v132 ^ (v229 + (v72 ^ *(_DWORD *)&v604[4]));
  HIDWORD(v72) = (v229 + __PAIR64__(v222, (unsigned int)v72 ^ *(_DWORD *)&v604[4])) >> 32;
  v255 = v253 ^ HIDWORD(v72);
  LODWORD(v137) = BYTE3(v132) | (v255 << 8);
  HIDWORD(v148) = HIBYTE(v255) | ((_DWORD)v132 << 8);
  v256 = v613 + __PAIR64__(v72, v254) + __PAIR64__(HIDWORD(v148), v137);
  HIDWORD(v137) = v72 ^ *(_DWORD *)&v604[4] ^ v256;
  LODWORD(v222) = v222 ^ HIDWORD(v256);
  v257 = HIWORD(HIDWORD(v137)) | ((_DWORD)v222 << 16);
  v258 = WORD1(v222) | (HIDWORD(v137) << 16);
  HIDWORD(v137) = *(__int64 *)&v554[4] >> 31;
  v259 = __PAIR64__(HIDWORD(v72), v229 + (v72 ^ *(_DWORD *)&v604[4])) + __PAIR64__(v258, v257);
  HIDWORD(v72) = (__PAIR64__(HIDWORD(v72), v229 + (v72 ^ *(_DWORD *)&v604[4])) + __PAIR64__(v258, v257)) >> 32;
  *(_QWORD *)v604 = __PAIR64__(v258, v257);
  HIDWORD(v132) = (2 * *(_DWORD *)&v554[4]) | (*(_DWORD *)&v554[8] >> 31);
  *(_DWORD *)&v554[4] = HIDWORD(v72) ^ HIDWORD(v148);
  v260 = v608 + __PAIR64__(HIDWORD(v571), *(unsigned int *)&v554[12]) + __PAIR64__(HIDWORD(v137), HIDWORD(v132));
  HIDWORD(v222) = v260 ^ *(_DWORD *)&v604[16];
  LODWORD(v222) = HIDWORD(v260) ^ *(_DWORD *)&v604[20];
  HIDWORD(v132) ^= v571 + (HIDWORD(v260) ^ *(_DWORD *)&v604[20]);
  LODWORD(v72) = (__PAIR64__(v575, v571) + v222) >> 32;
  HIDWORD(v148) = v571 + (HIDWORD(v260) ^ *(_DWORD *)&v604[20]);
  HIDWORD(v137) ^= v72;
  LODWORD(v132) = HIBYTE(HIDWORD(v132)) | (HIDWORD(v137) << 8);
  HIDWORD(v132) = HIBYTE(HIDWORD(v137)) | (HIDWORD(v132) << 8);
  v261 = v222 ^ (v618 + v260 + v132);
  v262 = HIWORD(HIDWORD(v261));
  *(_QWORD *)&v554[8] = v618 + v260 + v132;
  HIDWORD(v261) = v261 >> 16;
  LODWORD(v261) = v262 | ((_DWORD)v261 << 16);
  LODWORD(v132) = v132 ^ (HIDWORD(v148) + HIDWORD(v261));
  v263 = __PAIR64__(v72, HIDWORD(v148)) + __PAIR64__(v261, HIDWORD(v261));
  LODWORD(v72) = (__PAIR64__(v72, HIDWORD(v148)) + __PAIR64__(v261, HIDWORD(v261))) >> 32;
  HIDWORD(v132) ^= v72;
  HIDWORD(v137) = 2 * HIDWORD(v132);
  HIDWORD(v132) = (2 * v132) | (HIDWORD(v132) >> 31);
  LODWORD(v132) = HIDWORD(v137) | ((unsigned int)v132 >> 31);
  v264 = v607 + *(_QWORD *)&v554[16] + __PAIR64__(v132, HIDWORD(v132));
  v265 = v226 ^ v264;
  v266 = __PAIR64__(HIDWORD(v72), v259) + __PAIR64__(v265, HIDWORD(v265));
  HIDWORD(v132) ^= v259 + HIDWORD(v265);
  *(_DWORD *)&v554[16] = (__PAIR64__(HIDWORD(v72), v259) + __PAIR64__(v265, HIDWORD(v265))) >> 32;
  LODWORD(v132) = v132 ^ *(_DWORD *)&v554[16];
  HIDWORD(v137) = BYTE3(v132);
  LODWORD(v132) = HIBYTE(HIDWORD(v132)) | ((_DWORD)v132 << 8);
  HIDWORD(v132) = HIDWORD(v137) | (HIDWORD(v132) << 8);
  HIDWORD(v265) ^= v617 + v264 + (_DWORD)v132;
  LODWORD(v265) = v265 ^ ((v617 + v264 + v132) >> 32);
  v267 = WORD1(v265);
  *(_DWORD *)&v554[20] = v617 + v264 + v132;
  LODWORD(v571) = (v617 + v264 + v132) >> 32;
  LODWORD(v265) = HIWORD(HIDWORD(v265)) | ((_DWORD)v265 << 16);
  v268 = v267 | (HIDWORD(v265) << 16);
  v192 = __CFADD__((_DWORD)v266, (_DWORD)v265);
  LODWORD(v148) = v266 + v265;
  *(_QWORD *)&v604[8] = __PAIR64__(v268, v265);
  LODWORD(v265) = (2 * DWORD1(v548)) | (DWORD2(v548) >> 31);
  HIDWORD(v72) = v148;
  HIDWORD(v265) = *(__int64 *)((char *)&v548 + 4) >> 31;
  LODWORD(v148) = v268;
  v269 = *(_DWORD *)&v554[16];
  *(_DWORD *)&v554[16] = HIDWORD(v72);
  DWORD1(v548) = HIDWORD(v72) ^ v132;
  v270 = v611 + v589 + v265;
  HIDWORD(v571) = v148 + v192 + v269;
  DWORD2(v548) = HIDWORD(v571) ^ HIDWORD(v132);
  LODWORD(v265) = v265 ^ (v263 + (HIDWORD(v270) ^ *(_DWORD *)&v604[4]));
  v271 = __PAIR64__(v72, v263) + __PAIR64__((unsigned int)v270 ^ *(_DWORD *)v604, HIDWORD(v270) ^ *(_DWORD *)&v604[4]);
  LODWORD(v72) = (__PAIR64__(v72, v263)
                + __PAIR64__((unsigned int)v270 ^ *(_DWORD *)v604, HIDWORD(v270) ^ *(_DWORD *)&v604[4])) >> 32;
  HIDWORD(v265) ^= v72;
  HIDWORD(v132) = HIBYTE(HIDWORD(v265));
  HIDWORD(v265) = v265 >> 24;
  LODWORD(v265) = HIDWORD(v132) | ((_DWORD)v265 << 8);
  v272 = v615 + v270 + __PAIR64__(v265, HIDWORD(v265));
  LODWORD(v132) = HIDWORD(v270) ^ *(_DWORD *)&v604[4] ^ v272;
  HIDWORD(v72) = v270 ^ *(_DWORD *)v604 ^ HIDWORD(v272);
  v576 = v615 + v270 + HIDWORD(v265);
  v273 = WORD1(v132) | (HIDWORD(v72) << 16);
  *(_DWORD *)&v604[4] = HIWORD(HIDWORD(v72)) | ((_DWORD)v132 << 16);
  *(_DWORD *)v604 = v273;
  HIDWORD(v265) ^= v271 + v273;
  HIDWORD(v72) = (2 * HIDWORD(v548)) | (v559 >> 31);
  v274 = (2 * v559) | (HIDWORD(v548) >> 31);
  HIDWORD(v582) = v271 + v273;
  LODWORD(v265) = v265 ^ ((__PAIR64__(v72, v271) + __PAIR64__(*(unsigned int *)&v604[4], v273)) >> 32);
  HIDWORD(v589) = (__PAIR64__(v72, v271) + __PAIR64__(*(unsigned int *)&v604[4], v273)) >> 32;
  LODWORD(v72) = (v605 + v256 + __PAIR64__(v274, HIDWORD(v72))) >> 32;
  v275 = v605 + v256 + HIDWORD(v72);
  HIDWORD(v261) ^= v275;
  LODWORD(v132) = v72 ^ v261;
  HIDWORD(v72) ^= v582 + (v72 ^ v261);
  LODWORD(v148) = (__PAIR64__(HIDWORD(v547), v582) + (v261 ^ (unsigned int)v72)) >> 32;
  HIDWORD(v132) = v582 + (v261 ^ v72);
  v276 = v274 ^ v148;
  HIDWORD(v137) = HIBYTE(HIDWORD(v72)) | (v276 << 8);
  LODWORD(v261) = HIBYTE(v276) | (HIDWORD(v72) << 8);
  v277 = v616 + __PAIR64__(v72, v275) + __PAIR64__(v261, HIDWORD(v137));
  HIDWORD(v261) ^= HIDWORD(v277);
  *(_DWORD *)&v598[4] = (((unsigned int)v277 ^ (unsigned int)v132) >> 16) | (HIDWORD(v261) << 16);
  v278 = HIWORD(HIDWORD(v261)) | (((unsigned int)v277 ^ (unsigned int)v132) << 16);
  HIDWORD(v148) = v265 >> 31;
  v279 = (2 * *(_DWORD *)&v554[4]) | (((unsigned int)v259 ^ (unsigned int)v137) >> 31);
  LODWORD(v132) = (2 * (v259 ^ v137)) | (*(_DWORD *)&v554[4] >> 31);
  LODWORD(v137) = (2 * v265) | (HIDWORD(v265) >> 31);
  HIDWORD(v72) = (__PAIR64__(v148, HIDWORD(v132)) + __PAIR64__(v278, *(unsigned int *)&v598[4])) >> 32;
  HIDWORD(v265) = HIDWORD(v132) + *(_DWORD *)&v598[4];
  LODWORD(v547) = (HIDWORD(v132) + *(_DWORD *)&v598[4]) ^ HIDWORD(v137);
  *(_DWORD *)&v604[16] = v278;
  LODWORD(v72) = v548;
  v280 = (v613 + *(_QWORD *)&v554[8] + __PAIR64__(v279, v132)) >> 32;
  LODWORD(v265) = v613 + *(_DWORD *)&v554[8] + v132;
  LODWORD(v548) = HIDWORD(v72) ^ v261;
  HIDWORD(v137) = v280 ^ v72;
  LODWORD(v132) = v132 ^ (*(_DWORD *)v598 + (v280 ^ v72));
  v281 = *(_DWORD *)v598 + (v280 ^ v72);
  LODWORD(v72) = (__PAIR64__(*(unsigned int *)&v554[24], *(unsigned int *)v598)
                + __PAIR64__((unsigned int)v265 ^ *(_DWORD *)&v598[8], v280 ^ (unsigned int)v72)) >> 32;
  v282 = v279 ^ v72;
  HIDWORD(v132) = HIBYTE(v282);
  v283 = BYTE3(v132) | (v282 << 8);
  LODWORD(v132) = HIDWORD(v132) | ((_DWORD)v132 << 8);
  v284 = v608 + __PAIR64__(v280, v265) + __PAIR64__(v132, v283);
  HIDWORD(v137) ^= v284;
  v285 = (((unsigned int)v265 ^ *(_DWORD *)&v598[8] ^ HIDWORD(v284)) >> 16) | (HIDWORD(v137) << 16);
  HIDWORD(v261) = HIWORD(HIDWORD(v137)) | (((unsigned int)v265 ^ *(_DWORD *)&v598[8] ^ HIDWORD(v284)) << 16);
  v286 = __PAIR64__(v72, v281) + __PAIR64__(v285, HIDWORD(v261));
  LODWORD(v72) = (__PAIR64__(v72, v281) + __PAIR64__(v285, HIDWORD(v261))) >> 32;
  LODWORD(v132) = v132 ^ v72;
  v287 = v609 + __PAIR64__(v571, *(unsigned int *)&v554[20]) + __PAIR64__(v137, HIDWORD(v148));
  HIDWORD(v132) = v286 ^ v283;
  v288 = v285 ^ HIDWORD(v287);
  HIDWORD(v261) ^= v287;
  HIDWORD(v148) ^= HIDWORD(v265) + v288;
  v289 = __PAIR64__(HIDWORD(v72), HIDWORD(v265)) + __PAIR64__(HIDWORD(v261), v288);
  HIDWORD(v72) = (__PAIR64__(HIDWORD(v72), HIDWORD(v265)) + __PAIR64__(HIDWORD(v261), v288)) >> 32;
  HIDWORD(v137) = (v618 + v287) >> 32;
  LODWORD(v137) = v137 ^ HIDWORD(v72);
  LODWORD(v261) = BYTE3(v137);
  LODWORD(v137) = HIBYTE(HIDWORD(v148)) | ((_DWORD)v137 << 8);
  HIDWORD(v148) = v261 | (HIDWORD(v148) << 8);
  v290 = v288 ^ (v618 + v287 + v137);
  HIDWORD(v261) ^= (__PAIR64__(HIDWORD(v148), (int)v618 + (int)v287) + v137) >> 32;
  *(_QWORD *)&v554[20] = __PAIR64__(HIDWORD(v148), (int)v618 + (int)v287) + v137;
  HIDWORD(v547) = HIWORD(HIDWORD(v261)) | (v290 << 16);
  *(_DWORD *)&v598[8] = HIWORD(v290) | (HIDWORD(v261) << 16);
  HIDWORD(v137) = (2 * v547) | ((unsigned int)v548 >> 31);
  LODWORD(v261) = (2 * v548) | ((unsigned int)v547 >> 31);
  LODWORD(v548) = ((v612 + __PAIR64__(HIDWORD(v272), v576)) >> 32) ^ v137;
  v291 = v612 + __PAIR64__(HIDWORD(v272), v576) + __PAIR64__(v261, HIDWORD(v137));
  LODWORD(v547) = HIDWORD(v547) + __CFADD__((_DWORD)v289, *(_DWORD *)&v598[8]) + HIDWORD(v72);
  HIDWORD(v137) ^= v286 + (HIDWORD(v291) ^ *(_DWORD *)&v604[12]);
  v292 = __PAIR64__(v72, v286)
       + __PAIR64__((unsigned int)v291 ^ *(_DWORD *)&v604[8], HIDWORD(v291) ^ *(_DWORD *)&v604[12]);
  LODWORD(v72) = (__PAIR64__(v72, v286)
                + __PAIR64__((unsigned int)v291 ^ *(_DWORD *)&v604[8], HIDWORD(v291) ^ *(_DWORD *)&v604[12])) >> 32;
  HIDWORD(v548) = v547 ^ HIDWORD(v148);
  HIDWORD(v148) = HIBYTE(HIDWORD(v137)) | (((unsigned int)v72 ^ (unsigned int)v261) << 8);
  HIDWORD(v72) = (((unsigned int)v72 ^ (unsigned int)v261) >> 24) | (HIDWORD(v137) << 8);
  HIDWORD(v265) = ((v291 ^ *(_QWORD *)&v604[8]) >> 32) ^ (v610 + v291 + HIDWORD(v148));
  LODWORD(v265) = v291 ^ *(_DWORD *)&v604[8] ^ ((v610 + v291 + __PAIR64__(HIDWORD(v72), HIDWORD(v148))) >> 32);
  LODWORD(v589) = (v610 + v291 + __PAIR64__(HIDWORD(v72), HIDWORD(v148))) >> 32;
  v293 = WORD1(v265);
  LODWORD(v265) = HIWORD(HIDWORD(v265)) | ((_DWORD)v265 << 16);
  HIDWORD(v265) = v293 | (HIDWORD(v265) << 16);
  v294 = 2 * v132;
  LODWORD(v132) = v132 >> 31;
  v295 = v294 | (HIDWORD(v132) >> 31);
  HIDWORD(v132) = (__PAIR64__(v72, v292) + v265) >> 32;
  *(_DWORD *)v598 = v292 + v265;
  v577 = v610 + v291 + HIDWORD(v148);
  LODWORD(v261) = (v620 + v277 + v132) ^ *(_DWORD *)v604;
  *(_DWORD *)v554 = (v292 + v265) ^ HIDWORD(v148);
  LODWORD(v72) = (v620 + v277 + __PAIR64__(v295, v132)) >> 32;
  v296 = v620 + v277 + v132;
  LODWORD(v582) = HIDWORD(v132);
  *(_DWORD *)&v554[4] = HIDWORD(v132) ^ HIDWORD(v72);
  LODWORD(v132) = v132 ^ (*(_DWORD *)&v554[16] + (v72 ^ *(_DWORD *)&v604[4]));
  HIDWORD(v72) = (__PAIR64__(HIDWORD(v571), *(unsigned int *)&v554[16])
                + __PAIR64__(v261, (unsigned int)v72 ^ *(_DWORD *)&v604[4])) >> 32;
  v297 = v295 ^ HIDWORD(v72);
  LODWORD(v137) = BYTE3(v132) | (v297 << 8);
  HIDWORD(v148) = HIBYTE(v297) | ((_DWORD)v132 << 8);
  v298 = v619 + __PAIR64__(v72, v296) + __PAIR64__(HIDWORD(v148), v137);
  HIDWORD(v137) = v72 ^ *(_DWORD *)&v604[4] ^ v298;
  LODWORD(v261) = v261 ^ HIDWORD(v298);
  *(_DWORD *)v604 = HIWORD(HIDWORD(v137)) | ((_DWORD)v261 << 16);
  HIDWORD(v132) = (2 * DWORD1(v548)) | (DWORD2(v548) >> 31);
  v299 = __PAIR64__(HIDWORD(v72), *(_DWORD *)&v554[16] + ((unsigned int)v72 ^ *(_DWORD *)&v604[4]))
       + __PAIR64__(WORD1(v261) | (HIDWORD(v137) << 16), *(unsigned int *)v604);
  HIDWORD(v72) = (__PAIR64__(HIDWORD(v72), *(_DWORD *)&v554[16] + ((unsigned int)v72 ^ *(_DWORD *)&v604[4]))
                + __PAIR64__(WORD1(v261) | (HIDWORD(v137) << 16), *(unsigned int *)v604)) >> 32;
  *(_DWORD *)&v604[4] = WORD1(v261) | (HIDWORD(v137) << 16);
  HIDWORD(v137) = *(__int64 *)((char *)&v548 + 4) >> 31;
  DWORD2(v548) = HIDWORD(v72) ^ HIDWORD(v148);
  DWORD1(v548) = v299 ^ v137;
  v300 = v606 + v284 + __PAIR64__(HIDWORD(v137), HIDWORD(v132));
  HIDWORD(v261) = v300 ^ *(_DWORD *)&v598[4];
  LODWORD(v261) = HIDWORD(v300) ^ *(_DWORD *)&v604[16];
  *(_DWORD *)&v554[8] = HIDWORD(v582) + (HIDWORD(v300) ^ *(_DWORD *)&v604[16]);
  HIDWORD(v132) ^= *(_DWORD *)&v554[8];
  LODWORD(v72) = (__PAIR64__(HIDWORD(v589), HIDWORD(v582)) + v261) >> 32;
  HIDWORD(v137) ^= v72;
  LODWORD(v132) = HIBYTE(HIDWORD(v132)) | (HIDWORD(v137) << 8);
  HIDWORD(v132) = HIBYTE(HIDWORD(v137)) | (HIDWORD(v132) << 8);
  v301 = v261 ^ (v614 + v300 + v132);
  v302 = HIWORD(HIDWORD(v301));
  HIDWORD(v582) = (v614 + v300 + v132) >> 32;
  HIDWORD(v301) = v301 >> 16;
  LODWORD(v301) = v302 | ((_DWORD)v301 << 16);
  *(_DWORD *)&v554[12] = v614 + v300 + v132;
  LODWORD(v132) = v132 ^ (*(_DWORD *)&v554[8] + HIDWORD(v301));
  LODWORD(v72) = (__PAIR64__(v72, *(unsigned int *)&v554[8]) + __PAIR64__(v301, HIDWORD(v301))) >> 32;
  HIDWORD(v132) ^= v72;
  HIDWORD(v137) = 2 * HIDWORD(v132);
  HIDWORD(v132) = (2 * v132) | (HIDWORD(v132) >> 31);
  LODWORD(v132) = HIDWORD(v137) | ((unsigned int)v132 >> 31);
  v303 = v617 + *(_QWORD *)&v554[20] + __PAIR64__(v132, HIDWORD(v132));
  v304 = v265 ^ v303;
  HIDWORD(v132) ^= v299 + HIDWORD(v304);
  v305 = __PAIR64__(HIDWORD(v72), v299) + __PAIR64__(v304, HIDWORD(v304));
  HIDWORD(v72) = (__PAIR64__(HIDWORD(v72), v299) + __PAIR64__(v304, HIDWORD(v304))) >> 32;
  LODWORD(v132) = v132 ^ HIDWORD(v72);
  HIDWORD(v137) = BYTE3(v132);
  LODWORD(v132) = HIBYTE(HIDWORD(v132)) | ((_DWORD)v132 << 8);
  HIDWORD(v132) = HIDWORD(v137) | (HIDWORD(v132) << 8);
  HIDWORD(v304) ^= v610 + v303 + (_DWORD)v132;
  LODWORD(v304) = v304 ^ ((v610 + v303 + v132) >> 32);
  *(_QWORD *)&v554[20] = v610 + v303 + v132;
  LODWORD(v137) = v304 >> 16;
  *(_DWORD *)&v598[4] = HIWORD(HIDWORD(v304)) | ((_DWORD)v304 << 16);
  LODWORD(v304) = (2 * v548) | (HIDWORD(v548) >> 31);
  HIDWORD(v304) = (2 * HIDWORD(v548)) | ((unsigned int)v548 >> 31);
  LODWORD(v548) = (v305 + *(_DWORD *)&v598[4]) ^ v132;
  v306 = v606 + __PAIR64__(v589, v577) + v304;
  HIDWORD(v548) = ((__PAIR64__(v137, v305) + __PAIR64__(HIDWORD(v72), *(unsigned int *)&v598[4])) >> 32) ^ HIDWORD(v132);
  v307 = v304
       ^ (__PAIR64__(v72, *(_DWORD *)&v554[8] + HIDWORD(v301))
        + __PAIR64__((unsigned int)v306 ^ *(_DWORD *)v604, HIDWORD(v306) ^ *(_DWORD *)&v604[4]));
  v308 = __PAIR64__(v72, *(_DWORD *)&v554[8] + HIDWORD(v301))
       + __PAIR64__((unsigned int)v306 ^ *(_DWORD *)v604, HIDWORD(v306) ^ *(_DWORD *)&v604[4]);
  v578 = (__PAIR64__(v137, v305) + __PAIR64__(HIDWORD(v72), *(unsigned int *)&v598[4])) >> 32;
  HIDWORD(v132) = HIBYTE(HIDWORD(v307));
  HIDWORD(v307) = v307 >> 24;
  LODWORD(v307) = HIDWORD(v132) | ((_DWORD)v307 << 8);
  *(_DWORD *)&v604[8] = v137;
  v309 = v620 + v306 + __PAIR64__(v307, HIDWORD(v307));
  LODWORD(v132) = HIDWORD(v306) ^ *(_DWORD *)&v604[4] ^ v309;
  HIDWORD(v72) = v306 ^ *(_DWORD *)v604 ^ HIDWORD(v309);
  *(_DWORD *)&v604[4] = HIWORD(HIDWORD(v72)) | ((_DWORD)v132 << 16);
  *(_DWORD *)v604 = WORD1(v132) | (HIDWORD(v72) << 16);
  *(_DWORD *)&v554[16] = v308 + *(_DWORD *)v604;
  LODWORD(v307) = v307 ^ v132;
  HIDWORD(v307) ^= v308 + *(_DWORD *)v604;
  HIDWORD(v571) = v132;
  LODWORD(v72) = (v619 + v298 + ((2LL * *(_QWORD *)v554) | (*(_DWORD *)&v554[4] >> 31))) >> 32;
  HIDWORD(v301) ^= v619 + v298 + ((2 * *(_DWORD *)v554) | (*(_DWORD *)&v554[4] >> 31));
  LODWORD(v132) = v72 ^ v301;
  LODWORD(v137) = (2 * v307) | (HIDWORD(v307) >> 31);
  HIDWORD(v72) = ((2 * *(_DWORD *)v554) | (*(_DWORD *)&v554[4] >> 31)) ^ (v289 + *(_DWORD *)&v598[8] + (v72 ^ v301));
  LODWORD(v148) = (__PAIR64__(v547, (int)v289 + *(_DWORD *)&v598[8]) + (v301 ^ (unsigned int)v72)) >> 32;
  HIDWORD(v132) = v289 + *(_DWORD *)&v598[8] + (v301 ^ v72);
  v310 = (*(__int64 *)v554 >> 31) ^ v148;
  HIDWORD(v137) = HIBYTE(HIDWORD(v72)) | (v310 << 8);
  LODWORD(v301) = HIBYTE(v310) | (HIDWORD(v72) << 8);
  v311 = v618 + v619 + v298 + ((2LL * *(_QWORD *)v554) | (*(_DWORD *)&v554[4] >> 31)) + __PAIR64__(v301, HIDWORD(v137));
  HIDWORD(v301) ^= HIDWORD(v311);
  LODWORD(v72) = HIWORD(HIDWORD(v301)) | (((unsigned int)v311 ^ (unsigned int)v132) << 16);
  HIDWORD(v301) = (((unsigned int)v311 ^ (unsigned int)v132) >> 16) | (HIDWORD(v301) << 16);
  HIDWORD(v148) = v307 >> 31;
  *(_DWORD *)&v604[16] = v72;
  HIDWORD(v72) = (__PAIR64__(v148, HIDWORD(v132)) + __PAIR64__(v72, HIDWORD(v301))) >> 32;
  HIDWORD(v307) = HIDWORD(v132) + HIDWORD(v301);
  *(_DWORD *)&v604[12] = HIDWORD(v301);
  LODWORD(v547) = (HIDWORD(v132) + HIDWORD(v301)) ^ HIDWORD(v137);
  v312 = (v609
        + __PAIR64__(HIDWORD(v582), *(unsigned int *)&v554[12])
        + ((2LL * *(_QWORD *)((char *)&v548 + 4)) | (DWORD2(v548) >> 31))) >> 32;
  LODWORD(v307) = v609 + *(_DWORD *)&v554[12] + ((2 * DWORD1(v548)) | (DWORD2(v548) >> 31));
  LODWORD(v72) = HIDWORD(v547);
  HIDWORD(v547) = HIDWORD(v72) ^ v301;
  HIDWORD(v137) = v312 ^ v72;
  LODWORD(v132) = ((2 * DWORD1(v548)) | (DWORD2(v548) >> 31)) ^ (*(_DWORD *)v598 + (v312 ^ v72));
  v313 = *(_DWORD *)v598 + (v312 ^ v72);
  LODWORD(v72) = (__PAIR64__(v582, *(unsigned int *)v598)
                + __PAIR64__((unsigned int)v307 ^ *(_DWORD *)&v598[8], v312 ^ (unsigned int)v72)) >> 32;
  v314 = (*(__int64 *)((char *)&v548 + 4) >> 31) ^ v72;
  LODWORD(v301) = BYTE3(v132);
  LODWORD(v132) = HIBYTE(v314) | ((_DWORD)v132 << 8);
  v315 = v301 | (v314 << 8);
  v316 = v615
       + v609
       + __PAIR64__(HIDWORD(v582), *(unsigned int *)&v554[12])
       + ((2LL * *(_QWORD *)((char *)&v548 + 4)) | (DWORD2(v548) >> 31))
       + __PAIR64__(v132, v315);
  HIDWORD(v137) ^= v316;
  HIDWORD(v301) = v307 ^ *(_DWORD *)&v598[8] ^ HIDWORD(v316);
  *(_DWORD *)&v554[12] = v615 + v307 + v315;
  v317 = HIWORD(HIDWORD(v301));
  HIDWORD(v301) = HIWORD(HIDWORD(v137)) | (HIDWORD(v301) << 16);
  v318 = v317 | (HIDWORD(v137) << 16);
  v319 = __PAIR64__(v72, v313) + __PAIR64__(v318, HIDWORD(v301));
  LODWORD(v72) = (__PAIR64__(v72, v313) + __PAIR64__(v318, HIDWORD(v301))) >> 32;
  LODWORD(v132) = v132 ^ v72;
  v320 = v605 + *(_QWORD *)&v554[20] + __PAIR64__(v137, HIDWORD(v148));
  HIDWORD(v132) = v319 ^ v315;
  v321 = v318 ^ HIDWORD(v320);
  HIDWORD(v301) ^= v320;
  HIDWORD(v148) ^= HIDWORD(v307) + v321;
  v322 = __PAIR64__(HIDWORD(v72), HIDWORD(v307)) + __PAIR64__(HIDWORD(v301), v321);
  HIDWORD(v72) = (__PAIR64__(HIDWORD(v72), HIDWORD(v307)) + __PAIR64__(HIDWORD(v301), v321)) >> 32;
  LODWORD(v137) = v137 ^ HIDWORD(v72);
  LODWORD(v301) = BYTE3(v137);
  LODWORD(v137) = HIBYTE(HIDWORD(v148)) | ((_DWORD)v137 << 8);
  HIDWORD(v137) = (v612 + v320) >> 32;
  HIDWORD(v148) = v301 | (HIDWORD(v148) << 8);
  v323 = v321 ^ (v612 + v320 + v137);
  *(_QWORD *)&v554[20] = __PAIR64__(HIDWORD(v148), (int)v612 + (int)v320) + v137;
  HIDWORD(v301) ^= (__PAIR64__(HIDWORD(v148), (int)v612 + (int)v320) + v137) >> 32;
  LODWORD(v301) = HIWORD(HIDWORD(v301)) | (v323 << 16);
  v324 = HIWORD(v323) | (HIDWORD(v301) << 16);
  HIDWORD(v301) = v547;
  v325 = v301;
  *(_DWORD *)&v598[8] = v324;
  LODWORD(v547) = v322 + v324;
  LODWORD(v301) = (2 * HIDWORD(v547)) | (HIDWORD(v301) >> 31);
  HIDWORD(v137) = (2 * HIDWORD(v301)) | (HIDWORD(v547) >> 31);
  HIDWORD(v547) = (__PAIR64__(HIDWORD(v72), v322) + __PAIR64__(v325, v324)) >> 32;
  *(_DWORD *)&v604[20] = v325;
  DWORD1(v548) = (v322 + v324) ^ v137;
  v326 = v611 + v309 + __PAIR64__(v301, HIDWORD(v137));
  DWORD2(v548) = HIDWORD(v547) ^ HIDWORD(v148);
  HIDWORD(v137) ^= v319 + (HIDWORD(v326) ^ *(_DWORD *)&v604[8]);
  v327 = __PAIR64__(v72, v319)
       + __PAIR64__((unsigned int)v326 ^ *(_DWORD *)&v598[4], HIDWORD(v326) ^ *(_DWORD *)&v604[8]);
  LODWORD(v72) = (__PAIR64__(v72, v319)
                + __PAIR64__((unsigned int)v326 ^ *(_DWORD *)&v598[4], HIDWORD(v326) ^ *(_DWORD *)&v604[8])) >> 32;
  HIDWORD(v148) = HIBYTE(HIDWORD(v137)) | (((unsigned int)v72 ^ (unsigned int)v301) << 8);
  HIDWORD(v72) = (((unsigned int)v72 ^ (unsigned int)v301) >> 24) | (HIDWORD(v137) << 8);
  v328 = v608 + v326 + __PAIR64__(HIDWORD(v72), HIDWORD(v148));
  HIDWORD(v307) = HIDWORD(v326) ^ *(_DWORD *)&v604[8] ^ v328;
  LODWORD(v307) = v326 ^ *(_DWORD *)&v598[4] ^ HIDWORD(v328);
  v329 = WORD1(v307);
  LODWORD(v307) = HIWORD(HIDWORD(v307)) | ((_DWORD)v307 << 16);
  HIDWORD(v307) = v329 | (HIDWORD(v307) << 16);
  v583 = v328;
  v330 = __PAIR64__(v72, v327) + v307;
  LODWORD(v72) = (__PAIR64__(v72, v327) + v307) >> 32;
  v331 = (2 * v132) | (HIDWORD(v132) >> 31);
  LODWORD(v132) = v132 >> 31;
  v590 = __PAIR64__(v72, v330);
  *(_DWORD *)v554 = v330 ^ HIDWORD(v148);
  HIDWORD(v72) ^= v72;
  LODWORD(v72) = (v614 + v311 + __PAIR64__(v331, v132)) >> 32;
  v332 = v614 + v311 + v132;
  *(_DWORD *)&v554[4] = HIDWORD(v72);
  LODWORD(v132) = v132 ^ (v305 + *(_DWORD *)&v598[4] + (v72 ^ *(_DWORD *)&v604[4]));
  HIDWORD(v72) = (__PAIR64__(v578, (int)v305 + *(_DWORD *)&v598[4])
                + __PAIR64__(v332 ^ *(_DWORD *)v604, (unsigned int)v72 ^ *(_DWORD *)&v604[4])) >> 32;
  v333 = v331 ^ HIDWORD(v72);
  LODWORD(v137) = BYTE3(v132) | (v333 << 8);
  HIDWORD(v148) = HIBYTE(v333) | ((_DWORD)v132 << 8);
  v334 = v607 + __PAIR64__(v72, v332) + __PAIR64__(HIDWORD(v148), v137);
  HIDWORD(v137) = v72 ^ *(_DWORD *)&v604[4] ^ v334;
  LODWORD(v328) = v332 ^ *(_DWORD *)v604 ^ HIDWORD(v334);
  v335 = WORD1(v328) | (HIDWORD(v137) << 16);
  v336 = HIWORD(HIDWORD(v137)) | ((_DWORD)v328 << 16);
  HIDWORD(v137) = (2 * HIDWORD(v548)) | ((unsigned int)v548 >> 31);
  HIDWORD(v132) = (2 * v548) | (HIDWORD(v548) >> 31);
  *(_DWORD *)v604 = v335;
  v337 = __PAIR64__(HIDWORD(v72), v305 + *(_DWORD *)&v598[4] + (v72 ^ *(_DWORD *)&v604[4])) + __PAIR64__(v335, v336);
  HIDWORD(v72) = (__PAIR64__(HIDWORD(v72), v305 + *(_DWORD *)&v598[4] + (v72 ^ *(_DWORD *)&v604[4]))
                + __PAIR64__(v335, v336)) >> 32;
  *(_DWORD *)&v598[4] = v336;
  HIDWORD(v548) = v337 ^ v137;
  v338 = v613 + __PAIR64__(HIDWORD(v316), *(unsigned int *)&v554[12]) + __PAIR64__(HIDWORD(v137), HIDWORD(v132));
  HIDWORD(v328) = v338 ^ *(_DWORD *)&v604[12];
  LODWORD(v328) = HIDWORD(v338) ^ *(_DWORD *)&v604[16];
  *(_DWORD *)&v554[8] = HIDWORD(v72) ^ HIDWORD(v148);
  HIDWORD(v132) ^= *(_DWORD *)&v554[16] + (HIDWORD(v338) ^ *(_DWORD *)&v604[16]);
  LODWORD(v72) = (__PAIR64__(HIDWORD(v571), *(unsigned int *)&v554[16]) + v328) >> 32;
  HIDWORD(v148) = *(_DWORD *)&v554[16] + (HIDWORD(v338) ^ *(_DWORD *)&v604[16]);
  HIDWORD(v137) ^= v72;
  LODWORD(v132) = HIBYTE(HIDWORD(v132));
  HIDWORD(v132) = HIBYTE(HIDWORD(v137)) | (HIDWORD(v132) << 8);
  LODWORD(v132) = v132 | (HIDWORD(v137) << 8);
  v339 = v328 ^ (v616 + v338 + v132);
  v340 = HIWORD(HIDWORD(v339));
  *(_QWORD *)&v554[12] = v616 + v338 + v132;
  HIDWORD(v339) = v339 >> 16;
  LODWORD(v339) = v340 | ((_DWORD)v339 << 16);
  LODWORD(v132) = v132 ^ (HIDWORD(v148) + HIDWORD(v339));
  v341 = __PAIR64__(v72, HIDWORD(v148)) + __PAIR64__(v339, HIDWORD(v339));
  LODWORD(v72) = (__PAIR64__(v72, HIDWORD(v148)) + __PAIR64__(v339, HIDWORD(v339))) >> 32;
  HIDWORD(v132) ^= v72;
  HIDWORD(v137) = 2 * HIDWORD(v132);
  HIDWORD(v132) = (2 * v132) | (HIDWORD(v132) >> 31);
  LODWORD(v132) = HIDWORD(v137) | ((unsigned int)v132 >> 31);
  v342 = v618 + *(_DWORD *)&v554[20] + HIDWORD(v132);
  v343 = v307 ^ (v618 + *(_QWORD *)&v554[20] + __PAIR64__(v132, HIDWORD(v132)));
  LODWORD(v548) = (v618 + *(_QWORD *)&v554[20] + __PAIR64__(v132, HIDWORD(v132))) >> 32;
  HIDWORD(v132) ^= v337 + HIDWORD(v343);
  v344 = __PAIR64__(HIDWORD(v72), v337) + __PAIR64__(v343, HIDWORD(v343));
  HIDWORD(v72) = (__PAIR64__(HIDWORD(v72), v337) + __PAIR64__(v343, HIDWORD(v343))) >> 32;
  LODWORD(v132) = v132 ^ HIDWORD(v72);
  HIDWORD(v137) = BYTE3(v132);
  LODWORD(v132) = HIBYTE(HIDWORD(v132)) | ((_DWORD)v132 << 8);
  HIDWORD(v132) = HIDWORD(v137) | (HIDWORD(v132) << 8);
  HIDWORD(v137) = (v616 + __PAIR64__(v548, v342) + v132) >> 32;
  v345 = v616 + v342 + v132;
  HIDWORD(v343) ^= v345;
  LODWORD(v343) = v343 ^ HIDWORD(v137);
  *(_QWORD *)&v554[20] = __PAIR64__(HIDWORD(v137), v345);
  v346 = HIWORD(HIDWORD(v343)) | ((_DWORD)v343 << 16);
  LODWORD(v548) = v343 >> 16;
  LODWORD(v343) = (2 * DWORD1(v548)) | (DWORD2(v548) >> 31);
  *(_DWORD *)&v604[4] = v346;
  HIDWORD(v343) = *(__int64 *)((char *)&v548 + 4) >> 31;
  DWORD1(v548) = (v344 + v346) ^ v132;
  HIDWORD(v571) = v548 + __CFADD__((_DWORD)v344, v346) + HIDWORD(v72);
  LODWORD(v571) = v344 + v346;
  v347 = v612 + v583 + v343;
  v348 = __PAIR64__(v72, v341) + __PAIR64__((unsigned int)v347 ^ *(_DWORD *)&v598[4], HIDWORD(v347) ^ *(_DWORD *)v604);
  LODWORD(v72) = (__PAIR64__(v72, v341)
                + __PAIR64__((unsigned int)v347 ^ *(_DWORD *)&v598[4], HIDWORD(v347) ^ *(_DWORD *)v604)) >> 32;
  v349 = v343 ^ __PAIR64__(v72, v348);
  DWORD2(v548) = HIDWORD(v571) ^ HIDWORD(v132);
  HIDWORD(v132) = HIBYTE(HIDWORD(v349));
  HIDWORD(v349) = v349 >> 24;
  LODWORD(v349) = HIDWORD(v132) | ((_DWORD)v349 << 8);
  v350 = v619 + v347 + __PAIR64__(v349, HIDWORD(v349));
  LODWORD(v132) = HIDWORD(v347) ^ *(_DWORD *)v604 ^ v350;
  HIDWORD(v72) = v347 ^ *(_DWORD *)&v598[4] ^ HIDWORD(v350);
  v351 = WORD1(v132) | (HIDWORD(v72) << 16);
  HIDWORD(v349) ^= v348 + v351;
  *(_DWORD *)v604 = HIWORD(HIDWORD(v72)) | ((_DWORD)v132 << 16);
  LODWORD(v349) = v349 ^ ((__PAIR64__(v72, v348) + __PAIR64__(*(unsigned int *)v604, v351)) >> 32);
  *(_DWORD *)v598 = (__PAIR64__(v72, v348) + __PAIR64__(*(unsigned int *)v604, v351)) >> 32;
  LODWORD(v137) = (2 * v349) | (HIDWORD(v349) >> 31);
  LODWORD(v72) = (v617 + v334 + ((2LL * *(_QWORD *)v554) | (*(_DWORD *)&v554[4] >> 31))) >> 32;
  LODWORD(v132) = v72 ^ v339;
  HIDWORD(v339) ^= v617 + v334 + ((2 * *(_DWORD *)v554) | (*(_DWORD *)&v554[4] >> 31));
  HIDWORD(v72) = ((2 * *(_DWORD *)v554) | (*(_DWORD *)&v554[4] >> 31)) ^ (v547 + (v72 ^ v339));
  LODWORD(v148) = (v547 + (v339 ^ (unsigned int)v72)) >> 32;
  HIDWORD(v132) = v547 + (v339 ^ v72);
  v352 = (*(__int64 *)v554 >> 31) ^ v148;
  HIDWORD(v137) = HIBYTE(HIDWORD(v72)) | (v352 << 8);
  LODWORD(v339) = HIBYTE(v352) | (HIDWORD(v72) << 8);
  v353 = v606 + v617 + v334 + ((2LL * *(_QWORD *)v554) | (*(_DWORD *)&v554[4] >> 31)) + __PAIR64__(v339, HIDWORD(v137));
  HIDWORD(v339) ^= HIDWORD(v353);
  *(_DWORD *)&v604[8] = (((unsigned int)v353 ^ (unsigned int)v132) >> 16) | (HIDWORD(v339) << 16);
  *(_DWORD *)&v604[12] = HIWORD(HIDWORD(v339)) | (((unsigned int)v353 ^ (unsigned int)v132) << 16);
  LODWORD(v132) = (2 * HIDWORD(v548)) | (*(_DWORD *)&v554[8] >> 31);
  v354 = (2 * *(_DWORD *)&v554[8]) | (HIDWORD(v548) >> 31);
  HIDWORD(v148) = v349 >> 31;
  HIDWORD(v72) = (__PAIR64__(v148, HIDWORD(v132)) + *(_QWORD *)&v604[8]) >> 32;
  HIDWORD(v349) = HIDWORD(v132) + *(_DWORD *)&v604[8];
  LODWORD(v547) = (HIDWORD(v132) + *(_DWORD *)&v604[8]) ^ HIDWORD(v137);
  HIDWORD(v548) = HIDWORD(v72) ^ v339;
  v355 = (v608 + *(_QWORD *)&v554[12] + __PAIR64__(v354, v132)) >> 32;
  LODWORD(v349) = v608 + *(_DWORD *)&v554[12] + v132;
  LODWORD(v132) = v132 ^ (v590 + (v355 ^ *(_DWORD *)&v604[20]));
  LODWORD(v72) = (v590 + __PAIR64__((unsigned int)v349 ^ *(_DWORD *)&v598[8], v355 ^ *(_DWORD *)&v604[20])) >> 32;
  LODWORD(v148) = v590 + (v355 ^ *(_DWORD *)&v604[20]);
  v356 = v354 ^ v72;
  LODWORD(v339) = BYTE3(v132);
  LODWORD(v132) = HIBYTE(v356) | ((_DWORD)v132 << 8);
  v357 = v339 | (v356 << 8);
  v358 = v614 + __PAIR64__(v355, v349) + __PAIR64__(v132, v357);
  HIDWORD(v137) = v355 ^ *(_DWORD *)&v604[20] ^ v358;
  HIDWORD(v339) = v349 ^ *(_DWORD *)&v598[8] ^ HIDWORD(v358);
  v359 = HIWORD(HIDWORD(v339));
  HIDWORD(v339) = HIWORD(HIDWORD(v137)) | (HIDWORD(v339) << 16);
  v360 = v359 | (HIDWORD(v137) << 16);
  v361 = __PAIR64__(v72, v148) + __PAIR64__(v360, HIDWORD(v339));
  LODWORD(v72) = (__PAIR64__(v72, v148) + __PAIR64__(v360, HIDWORD(v339))) >> 32;
  LODWORD(v132) = v132 ^ v72;
  v362 = v610 + *(_QWORD *)&v554[20] + __PAIR64__(v137, HIDWORD(v148));
  HIDWORD(v132) = v361 ^ v357;
  v363 = v360 ^ HIDWORD(v362);
  HIDWORD(v339) ^= v362;
  HIDWORD(v148) ^= HIDWORD(v349) + v363;
  v364 = __PAIR64__(HIDWORD(v72), HIDWORD(v349)) + __PAIR64__(HIDWORD(v339), v363);
  HIDWORD(v72) = (__PAIR64__(HIDWORD(v72), HIDWORD(v349)) + __PAIR64__(HIDWORD(v339), v363)) >> 32;
  HIDWORD(v137) = (v605 + v362) >> 32;
  LODWORD(v137) = v137 ^ HIDWORD(v72);
  LODWORD(v339) = BYTE3(v137);
  LODWORD(v137) = HIBYTE(HIDWORD(v148)) | ((_DWORD)v137 << 8);
  HIDWORD(v148) = v339 | (HIDWORD(v148) << 8);
  v365 = v363 ^ (v605 + v362 + v137);
  *(_QWORD *)&v554[16] = __PAIR64__(HIDWORD(v148), (int)v605 + (int)v362) + v137;
  HIDWORD(v339) ^= (__PAIR64__(HIDWORD(v148), (int)v605 + (int)v362) + v137) >> 32;
  HIDWORD(v547) = HIWORD(v365) | (HIDWORD(v339) << 16);
  *(_DWORD *)&v598[8] = HIWORD(HIDWORD(v339)) | (v365 << 16);
  HIDWORD(v137) = (2 * v547) | (HIDWORD(v548) >> 31);
  LODWORD(v339) = (2 * HIDWORD(v548)) | ((unsigned int)v547 >> 31);
  *(_DWORD *)&v554[24] = (__PAIR64__(HIDWORD(v72), v364) + __PAIR64__(*(unsigned int *)&v598[8], HIDWORD(v547))) >> 32;
  v366 = v620 + v350 + __PAIR64__(v339, HIDWORD(v137));
  HIDWORD(v548) = (v364 + HIDWORD(v547)) ^ v137;
  HIDWORD(v349) = HIDWORD(v366) ^ v548;
  LODWORD(v148) = v361 + (HIDWORD(v366) ^ v548);
  LODWORD(v548) = *(_DWORD *)&v554[24] ^ HIDWORD(v148);
  HIDWORD(v137) ^= v148;
  v367 = v361 + HIDWORD(v349);
  LODWORD(v72) = (__PAIR64__(v72, v361) + __PAIR64__((unsigned int)v366 ^ *(_DWORD *)&v604[4], HIDWORD(v349))) >> 32;
  HIDWORD(v148) = HIBYTE(HIDWORD(v137)) | (((unsigned int)v72 ^ (unsigned int)v339) << 8);
  HIDWORD(v72) = (((unsigned int)v72 ^ (unsigned int)v339) >> 24) | (HIDWORD(v137) << 8);
  v368 = v609 + v366 + __PAIR64__(HIDWORD(v72), HIDWORD(v148));
  HIDWORD(v349) ^= v368;
  LODWORD(v349) = v366 ^ *(_DWORD *)&v604[4] ^ HIDWORD(v368);
  v369 = WORD1(v349);
  LODWORD(v349) = HIWORD(HIDWORD(v349)) | ((_DWORD)v349 << 16);
  HIDWORD(v349) = v369 | (HIDWORD(v349) << 16);
  v370 = 2 * v132;
  LODWORD(v132) = v132 >> 31;
  v371 = v370 | (HIDWORD(v132) >> 31);
  HIDWORD(v132) = (__PAIR64__(v72, v367) + v349) >> 32;
  v591 = __PAIR64__(v72, v367) + v349;
  *(_DWORD *)v554 = (v367 + v349) ^ HIDWORD(v148);
  LODWORD(v339) = (v613 + v353 + v132) ^ v351;
  LODWORD(v72) = (v613 + v353 + __PAIR64__(v371, v132)) >> 32;
  v372 = v613 + v353 + v132;
  *(_DWORD *)&v554[4] = HIDWORD(v132) ^ HIDWORD(v72);
  LODWORD(v132) = v132 ^ (v571 + (v72 ^ *(_DWORD *)v604));
  HIDWORD(v72) = (v571 + __PAIR64__(v339, (unsigned int)v72 ^ *(_DWORD *)v604)) >> 32;
  LODWORD(v148) = v571 + (v72 ^ *(_DWORD *)v604);
  v373 = v371 ^ HIDWORD(v72);
  LODWORD(v137) = BYTE3(v132) | (v373 << 8);
  HIDWORD(v148) = HIBYTE(v373) | ((_DWORD)v132 << 8);
  v374 = v611 + __PAIR64__(v72, v372) + __PAIR64__(HIDWORD(v148), v137);
  HIDWORD(v137) = v72 ^ *(_DWORD *)v604 ^ v374;
  LODWORD(v339) = v339 ^ HIDWORD(v374);
  v375 = HIWORD(HIDWORD(v137)) | ((_DWORD)v339 << 16);
  HIDWORD(v132) = (2 * DWORD1(v548)) | (DWORD2(v548) >> 31);
  *(_DWORD *)v604 = WORD1(v339) | (HIDWORD(v137) << 16);
  LODWORD(v72) = (__PAIR64__(HIDWORD(v72), v148) + __PAIR64__(*(unsigned int *)v604, v375)) >> 32;
  LODWORD(v148) = v148 + v375;
  HIDWORD(v137) = *(__int64 *)((char *)&v548 + 4) >> 31;
  DWORD1(v548) = v148 ^ v137;
  HIDWORD(v339) = (v607 + v358 + HIDWORD(v132)) ^ *(_DWORD *)&v604[8];
  v376 = v607 + v358 + __PAIR64__(HIDWORD(v137), HIDWORD(v132));
  *(_DWORD *)&v554[8] = v72;
  LODWORD(v339) = HIDWORD(v376) ^ *(_DWORD *)&v604[12];
  DWORD2(v548) = v72 ^ HIDWORD(v148);
  HIDWORD(v132) ^= v348 + v351 + (HIDWORD(v376) ^ *(_DWORD *)&v604[12]);
  LODWORD(v72) = (__PAIR64__(*(unsigned int *)v598, (unsigned int)v348 + v351) + v339) >> 32;
  HIDWORD(v148) = v348 + v351 + (HIDWORD(v376) ^ *(_DWORD *)&v604[12]);
  HIDWORD(v137) ^= v72;
  LODWORD(v132) = HIBYTE(HIDWORD(v132)) | (HIDWORD(v137) << 8);
  HIDWORD(v132) = HIBYTE(HIDWORD(v137)) | (HIDWORD(v132) << 8);
  v377 = v339 ^ (v615 + v376 + v132);
  v378 = HIWORD(HIDWORD(v377));
  *(_DWORD *)&v554[12] = v615 + v376 + v132;
  HIDWORD(v377) = v377 >> 16;
  LODWORD(v377) = v378 | ((_DWORD)v377 << 16);
  v579 = (v615 + v376 + v132) >> 32;
  LODWORD(v132) = v132 ^ (HIDWORD(v148) + HIDWORD(v377));
  v379 = __PAIR64__(v72, HIDWORD(v148)) + __PAIR64__(v377, HIDWORD(v377));
  LODWORD(v72) = (__PAIR64__(v72, HIDWORD(v148)) + __PAIR64__(v377, HIDWORD(v377))) >> 32;
  HIDWORD(v132) ^= v72;
  HIDWORD(v137) = 2 * HIDWORD(v132);
  HIDWORD(v132) = (2 * v132) | (HIDWORD(v132) >> 31);
  LODWORD(v132) = HIDWORD(v137) | ((unsigned int)v132 >> 31);
  v380 = v611 + *(_QWORD *)&v554[16] + __PAIR64__(v132, HIDWORD(v132));
  LODWORD(v349) = v349 ^ v380;
  HIDWORD(v132) ^= v148 + (HIDWORD(v349) ^ HIDWORD(v380));
  HIDWORD(v72) = (__PAIR64__(v349, v148) + __PAIR64__(*(unsigned int *)&v554[8], HIDWORD(v349) ^ HIDWORD(v380))) >> 32;
  LODWORD(v148) = v148 + (HIDWORD(v349) ^ HIDWORD(v380));
  LODWORD(v132) = v132 ^ HIDWORD(v72);
  HIDWORD(v137) = BYTE3(v132);
  LODWORD(v132) = HIBYTE(HIDWORD(v132)) | ((_DWORD)v132 << 8);
  HIDWORD(v132) = HIDWORD(v137) | (HIDWORD(v132) << 8);
  HIDWORD(v137) = v620 + v380 + v132;
  *(_DWORD *)&v554[8] = HIDWORD(v137);
  LODWORD(v349) = v349 ^ ((v620 + v380 + v132) >> 32);
  *(_DWORD *)&v554[16] = (v620 + v380 + v132) >> 32;
  HIDWORD(v349) ^= HIDWORD(v380) ^ HIDWORD(v137);
  *(_DWORD *)&v604[8] = v349 >> 16;
  *(_DWORD *)&v604[4] = HIWORD(HIDWORD(v349)) | ((_DWORD)v349 << 16);
  v381 = __PAIR64__(HIDWORD(v72), v148) + ((v349 << 16) | HIWORD(HIDWORD(v349)));
  LODWORD(v349) = (2 * HIDWORD(v548)) | ((unsigned int)v548 >> 31);
  HIDWORD(v349) = (2 * v548) | (HIDWORD(v548) >> 31);
  LODWORD(v548) = v381 ^ v132;
  v382 = v619 + v368 + v349;
  HIDWORD(v548) = HIDWORD(v381) ^ HIDWORD(v132);
  v383 = __PAIR64__(v72, v379) + __PAIR64__((unsigned int)v382 ^ v375, HIDWORD(v382) ^ *(_DWORD *)v604);
  LODWORD(v72) = (__PAIR64__(v72, v379) + __PAIR64__((unsigned int)v382 ^ v375, HIDWORD(v382) ^ *(_DWORD *)v604)) >> 32;
  v384 = v349 ^ __PAIR64__(v72, v383);
  HIDWORD(v132) = HIBYTE(HIDWORD(v384));
  HIDWORD(v384) = v384 >> 24;
  LODWORD(v384) = HIDWORD(v132) | ((_DWORD)v384 << 8);
  v385 = v614 + v382 + __PAIR64__(v384, HIDWORD(v384));
  LODWORD(v132) = HIDWORD(v382) ^ *(_DWORD *)v604 ^ v385;
  HIDWORD(v72) = v382 ^ v375 ^ HIDWORD(v385);
  HIDWORD(v583) = v614 + v382 + HIDWORD(v384);
  *(_DWORD *)v604 = HIWORD(HIDWORD(v72)) | ((_DWORD)v132 << 16);
  *(_DWORD *)&v598[4] = WORD1(v132) | (HIDWORD(v72) << 16);
  HIDWORD(v72) = (2 * *(_DWORD *)v554) | (*(_DWORD *)&v554[4] >> 31);
  v386 = *(__int64 *)v554 >> 31;
  HIDWORD(v384) ^= v383 + *(_DWORD *)&v598[4];
  *(_DWORD *)&v554[4] = v383 + *(_DWORD *)&v598[4];
  LODWORD(v384) = v384 ^ ((__PAIR64__(v72, v383) + __PAIR64__(*(unsigned int *)v604, *(unsigned int *)&v598[4])) >> 32);
  LODWORD(v571) = (__PAIR64__(v72, v383) + __PAIR64__(*(unsigned int *)v604, *(unsigned int *)&v598[4])) >> 32;
  LODWORD(v72) = (v616 + v374 + __PAIR64__(v386, HIDWORD(v72))) >> 32;
  v387 = v616 + v374 + HIDWORD(v72);
  HIDWORD(v377) ^= v387;
  LODWORD(v132) = v72 ^ v377;
  HIDWORD(v72) ^= v364 + HIDWORD(v547) + (v72 ^ v377);
  LODWORD(v148) = (__PAIR64__(*(unsigned int *)&v554[24], (int)v364 + HIDWORD(v547)) + (v377 ^ (unsigned int)v72)) >> 32;
  HIDWORD(v132) = v364 + HIDWORD(v547) + (v377 ^ v72);
  v388 = v386 ^ v148;
  HIDWORD(v137) = HIBYTE(HIDWORD(v72)) | (v388 << 8);
  LODWORD(v377) = HIBYTE(v388) | (HIDWORD(v72) << 8);
  *(_DWORD *)v554 = v608 + v387 + HIDWORD(v137);
  LODWORD(v72) = (v608 + __PAIR64__(v72, v387) + __PAIR64__(v377, HIDWORD(v137))) >> 32;
  HIDWORD(v377) ^= v72;
  *(_DWORD *)&v554[24] = v72;
  LODWORD(v137) = (2 * v384) | (HIDWORD(v384) >> 31);
  *(_DWORD *)&v604[12] = ((*(_DWORD *)v554 ^ (unsigned int)v132) >> 16) | (HIDWORD(v377) << 16);
  *(_DWORD *)&v604[16] = HIWORD(HIDWORD(v377)) | ((*(_DWORD *)v554 ^ (unsigned int)v132) << 16);
  LODWORD(v132) = (2 * DWORD1(v548)) | (DWORD2(v548) >> 31);
  v389 = *(__int64 *)((char *)&v548 + 4) >> 31;
  HIDWORD(v148) = v384 >> 31;
  HIDWORD(v72) = (__PAIR64__(v148, HIDWORD(v132)) + *(_QWORD *)&v604[12]) >> 32;
  HIDWORD(v384) = HIDWORD(v132) + *(_DWORD *)&v604[12];
  DWORD1(v548) = (HIDWORD(v132) + *(_DWORD *)&v604[12]) ^ HIDWORD(v137);
  v390 = (v605 + __PAIR64__(v579, *(unsigned int *)&v554[12]) + __PAIR64__(v389, v132)) >> 32;
  LODWORD(v384) = v605 + *(_DWORD *)&v554[12] + v132;
  HIDWORD(v377) = HIDWORD(v547);
  HIDWORD(v547) = HIDWORD(v72) ^ v377;
  HIDWORD(v377) ^= v384;
  LODWORD(v132) = v132 ^ (v591 + (v390 ^ *(_DWORD *)&v598[8]));
  LODWORD(v72) = (v591 + __PAIR64__(HIDWORD(v377), v390 ^ *(_DWORD *)&v598[8])) >> 32;
  v391 = v389 ^ v72;
  HIDWORD(v132) = HIBYTE(v391);
  v392 = BYTE3(v132) | (v391 << 8);
  LODWORD(v132) = HIDWORD(v132) | ((_DWORD)v132 << 8);
  v393 = v613 + __PAIR64__(v390, v384) + __PAIR64__(v132, v392);
  HIDWORD(v137) = v390 ^ *(_DWORD *)&v598[8] ^ v393;
  HIDWORD(v377) ^= HIDWORD(v393);
  LODWORD(v148) = v591 + (v390 ^ *(_DWORD *)&v598[8]);
  v394 = HIWORD(HIDWORD(v377));
  HIDWORD(v377) = HIWORD(HIDWORD(v137)) | (HIDWORD(v377) << 16);
  v395 = v394 | (HIDWORD(v137) << 16);
  v396 = v148 + HIDWORD(v377);
  LODWORD(v72) = (__PAIR64__(v72, v148) + __PAIR64__(v395, HIDWORD(v377))) >> 32;
  LODWORD(v132) = v132 ^ v72;
  v397 = v617 + __PAIR64__(*(unsigned int *)&v554[16], *(unsigned int *)&v554[8]) + __PAIR64__(v137, HIDWORD(v148));
  HIDWORD(v377) ^= v397;
  v398 = v395 ^ HIDWORD(v397);
  HIDWORD(v132) = v396 ^ v392;
  v399 = __PAIR64__(HIDWORD(v72), HIDWORD(v384)) + __PAIR64__(HIDWORD(v377), v398);
  HIDWORD(v72) = (__PAIR64__(HIDWORD(v72), HIDWORD(v384)) + __PAIR64__(HIDWORD(v377), v398)) >> 32;
  HIDWORD(v148) ^= v399;
  LODWORD(v137) = v137 ^ HIDWORD(v72);
  LODWORD(v377) = BYTE3(v137);
  LODWORD(v137) = HIBYTE(HIDWORD(v148)) | ((_DWORD)v137 << 8);
  HIDWORD(v137) = (v607 + v397) >> 32;
  HIDWORD(v148) = v377 | (HIDWORD(v148) << 8);
  v400 = v398 ^ (v607 + v397 + v137);
  *(_DWORD *)&v554[8] = v607 + v397 + v137;
  HIDWORD(v377) ^= (__PAIR64__(HIDWORD(v148), (int)v607 + (int)v397) + v137) >> 32;
  *(_DWORD *)&v554[16] = (__PAIR64__(HIDWORD(v148), (int)v607 + (int)v397) + v137) >> 32;
  LODWORD(v547) = HIWORD(v400) | (HIDWORD(v377) << 16);
  *(_DWORD *)&v598[8] = HIWORD(HIDWORD(v377)) | (v400 << 16);
  LODWORD(v377) = (2 * HIDWORD(v547)) | (DWORD1(v548) >> 31);
  HIDWORD(v137) = (2 * DWORD1(v548)) | (HIDWORD(v547) >> 31);
  v401 = __PAIR64__(HIDWORD(v618), HIDWORD(v583));
  HIDWORD(v583) = (__PAIR64__(HIDWORD(v72), v399) + __PAIR64__(*(unsigned int *)&v598[8], v547)) >> 32;
  HIDWORD(v547) = (v399 + v547) ^ v137;
  v402 = __PAIR64__(HIDWORD(v385), v618) + v401 + __PAIR64__(v377, HIDWORD(v137));
  DWORD1(v548) = HIDWORD(v583) ^ HIDWORD(v148);
  v403 = __PAIR64__(v72, v396)
       + __PAIR64__((unsigned int)v402 ^ *(_DWORD *)&v604[4], HIDWORD(v402) ^ *(_DWORD *)&v604[8]);
  LODWORD(v72) = (__PAIR64__(v72, v396)
                + __PAIR64__((unsigned int)v402 ^ *(_DWORD *)&v604[4], HIDWORD(v402) ^ *(_DWORD *)&v604[8])) >> 32;
  HIDWORD(v137) ^= v403;
  HIDWORD(v148) = HIBYTE(HIDWORD(v137)) | (((unsigned int)v72 ^ (unsigned int)v377) << 8);
  HIDWORD(v72) = (((unsigned int)v72 ^ (unsigned int)v377) >> 24) | (HIDWORD(v137) << 8);
  HIDWORD(v401) = HIDWORD(v402) ^ *(_DWORD *)&v604[8] ^ (v612 + v402 + HIDWORD(v148));
  LODWORD(v401) = v402 ^ *(_DWORD *)&v604[4] ^ ((v612 + v402 + __PAIR64__(HIDWORD(v72), HIDWORD(v148))) >> 32);
  v404 = WORD1(v401);
  LODWORD(v401) = HIWORD(HIDWORD(v401)) | ((_DWORD)v401 << 16);
  HIDWORD(v401) = v404 | (HIDWORD(v401) << 16);
  v405 = 2 * v132;
  LODWORD(v132) = v132 >> 31;
  v592 = v612 + v402 + __PAIR64__(HIDWORD(v72), HIDWORD(v148));
  v406 = v405 | (HIDWORD(v132) >> 31);
  LODWORD(v148) = v606;
  HIDWORD(v132) = (__PAIR64__(v72, v403) + v401) >> 32;
  DWORD2(v548) = (v403 + v401) ^ HIDWORD(v148);
  HIDWORD(v148) = *(_DWORD *)&v554[24];
  *(_DWORD *)v598 = v403 + v401;
  LODWORD(v72) = (v148 + __PAIR64__(HIDWORD(v606), *(unsigned int *)v554) + __PAIR64__(v406, v132)) >> 32;
  v407 = v606 + *(_DWORD *)v554 + v132;
  *(_DWORD *)v554 = HIDWORD(v132) ^ HIDWORD(v72);
  LODWORD(v132) = v132 ^ (v381 + (v72 ^ *(_DWORD *)v604));
  HIDWORD(v72) = (v381 + __PAIR64__(v407 ^ *(_DWORD *)&v598[4], (unsigned int)v72 ^ *(_DWORD *)v604)) >> 32;
  LODWORD(v148) = v381 + (v72 ^ *(_DWORD *)v604);
  v408 = v406 ^ HIDWORD(v72);
  LODWORD(v137) = BYTE3(v132) | (v408 << 8);
  HIDWORD(v148) = HIBYTE(v408) | ((_DWORD)v132 << 8);
  v409 = v609 + __PAIR64__(v72, v407) + __PAIR64__(HIDWORD(v148), v137);
  LODWORD(v132) = v409;
  HIDWORD(v137) = v72 ^ *(_DWORD *)v604 ^ v409;
  LODWORD(v377) = v407 ^ *(_DWORD *)&v598[4] ^ HIDWORD(v409);
  *(_QWORD *)&v554[20] = v132;
  v410 = WORD1(v377) | (HIDWORD(v137) << 16);
  LODWORD(v72) = HIWORD(HIDWORD(v137)) | ((_DWORD)v377 << 16);
  *(_DWORD *)&v598[4] = v72;
  v411 = v148 + v72;
  HIDWORD(v132) = (2 * v548) | (HIDWORD(v548) >> 31);
  HIDWORD(v137) = (2 * HIDWORD(v548)) | ((unsigned int)v548 >> 31);
  *(_DWORD *)v604 = v410;
  *(_DWORD *)&v554[12] = (__PAIR64__(v410, v148) + v72) >> 32;
  LODWORD(v548) = (v148 + v72) ^ v137;
  v412 = v615 + v393 + __PAIR64__(HIDWORD(v137), HIDWORD(v132));
  HIDWORD(v548) = *(_DWORD *)&v554[12] ^ HIDWORD(v148);
  HIDWORD(v377) = (v615 + v393 + HIDWORD(v132)) ^ *(_DWORD *)&v604[12];
  LODWORD(v377) = HIDWORD(v412) ^ *(_DWORD *)&v604[16];
  HIDWORD(v132) ^= *(_DWORD *)&v554[4] + (HIDWORD(v412) ^ *(_DWORD *)&v604[16]);
  LODWORD(v72) = (__PAIR64__(v571, *(unsigned int *)&v554[4]) + v377) >> 32;
  HIDWORD(v148) = *(_DWORD *)&v554[4] + (HIDWORD(v412) ^ *(_DWORD *)&v604[16]);
  HIDWORD(v137) ^= v72;
  LODWORD(v132) = HIBYTE(HIDWORD(v132)) | (HIDWORD(v137) << 8);
  HIDWORD(v132) = HIBYTE(HIDWORD(v137)) | (HIDWORD(v132) << 8);
  v413 = v377 ^ (v610 + v412 + v132);
  v414 = HIWORD(HIDWORD(v413));
  LODWORD(v571) = (v610 + v412 + v132) >> 32;
  HIDWORD(v413) = v413 >> 16;
  LODWORD(v413) = v414 | ((_DWORD)v413 << 16);
  *(_DWORD *)&v554[4] = v610 + v412 + v132;
  LODWORD(v132) = v132 ^ (HIDWORD(v148) + HIDWORD(v413));
  v415 = __PAIR64__(v72, HIDWORD(v148)) + __PAIR64__(v413, HIDWORD(v413));
  LODWORD(v72) = (__PAIR64__(v72, HIDWORD(v148)) + __PAIR64__(v413, HIDWORD(v413))) >> 32;
  HIDWORD(v132) ^= v72;
  HIDWORD(v137) = 2 * HIDWORD(v132);
  HIDWORD(v132) = (2 * v132) | (HIDWORD(v132) >> 31);
  LODWORD(v132) = HIDWORD(v137) | ((unsigned int)v132 >> 31);
  v416 = v615 + __PAIR64__(*(unsigned int *)&v554[16], *(unsigned int *)&v554[8]) + __PAIR64__(v132, HIDWORD(v132));
  v417 = v401 ^ v416;
  HIDWORD(v132) ^= v411 + HIDWORD(v417);
  HIDWORD(v72) = (__PAIR64__(*(unsigned int *)&v554[12], v411) + __PAIR64__(v417, HIDWORD(v417))) >> 32;
  LODWORD(v148) = v411 + HIDWORD(v417);
  LODWORD(v132) = v132 ^ HIDWORD(v72);
  HIDWORD(v137) = BYTE3(v132);
  LODWORD(v132) = HIBYTE(HIDWORD(v132)) | ((_DWORD)v132 << 8);
  HIDWORD(v132) = HIDWORD(v137) | (HIDWORD(v132) << 8);
  HIDWORD(v417) ^= v607 + v416 + (_DWORD)v132;
  LODWORD(v417) = v417 ^ ((v607 + v416 + v132) >> 32);
  *(_QWORD *)&v554[8] = v607 + v416 + v132;
  v418 = v417 >> 16;
  *(_DWORD *)&v604[4] = HIWORD(HIDWORD(v417)) | ((_DWORD)v417 << 16);
  *(_DWORD *)&v554[16] = v148 + *(_DWORD *)&v604[4];
  LODWORD(v417) = (2 * HIDWORD(v547)) | (DWORD1(v548) >> 31);
  HIDWORD(v417) = (2 * DWORD1(v548)) | (HIDWORD(v547) >> 31);
  HIDWORD(v547) = (v148 + *(_DWORD *)&v604[4]) ^ v132;
  *(_DWORD *)&v604[8] = v418;
  DWORD1(v548) = ((__PAIR64__(HIDWORD(v72), v148) + __PAIR64__(v418, *(unsigned int *)&v604[4])) >> 32) ^ HIDWORD(v132);
  v419 = v613 + v592 + v417;
  HIDWORD(v571) = (__PAIR64__(HIDWORD(v72), v148) + __PAIR64__(v418, *(unsigned int *)&v604[4])) >> 32;
  LODWORD(v417) = v417 ^ (v415 + (HIDWORD(v419) ^ *(_DWORD *)v604));
  v420 = __PAIR64__(v72, v415) + __PAIR64__((unsigned int)v419 ^ *(_DWORD *)&v598[4], HIDWORD(v419) ^ *(_DWORD *)v604);
  LODWORD(v72) = (__PAIR64__(v72, v415)
                + __PAIR64__((unsigned int)v419 ^ *(_DWORD *)&v598[4], HIDWORD(v419) ^ *(_DWORD *)v604)) >> 32;
  HIDWORD(v417) ^= v72;
  HIDWORD(v132) = HIBYTE(HIDWORD(v417));
  HIDWORD(v417) = v417 >> 24;
  LODWORD(v417) = HIDWORD(v132) | ((_DWORD)v417 << 8);
  LODWORD(v132) = HIDWORD(v419) ^ *(_DWORD *)v604 ^ (v609 + v419 + HIDWORD(v417));
  HIDWORD(v72) = v419 ^ *(_DWORD *)&v598[4] ^ ((v609 + v419 + __PAIR64__(v417, HIDWORD(v417))) >> 32);
  v593 = v609 + v419 + __PAIR64__(v417, HIDWORD(v417));
  *(_DWORD *)&v598[4] = WORD1(v132) | (HIDWORD(v72) << 16);
  v421 = __PAIR64__(v72, v420) + __PAIR64__(HIWORD(HIDWORD(v72)) | ((_DWORD)v132 << 16), *(unsigned int *)&v598[4]);
  *(_DWORD *)v604 = HIWORD(HIDWORD(v72)) | ((_DWORD)v132 << 16);
  v422 = (2 * *(_DWORD *)v554) | (DWORD2(v548) >> 31);
  LODWORD(v417) = v417 ^ ((__PAIR64__(v72, v420) + __PAIR64__(*(unsigned int *)v604, *(unsigned int *)&v598[4])) >> 32);
  HIDWORD(v417) ^= v420 + *(_DWORD *)&v598[4];
  LODWORD(v137) = (2 * v417) | (HIDWORD(v417) >> 31);
  LODWORD(v72) = (v612
                + __PAIR64__(HIDWORD(v409), *(unsigned int *)&v554[20])
                + __PAIR64__(v422, (unsigned int)(2 * DWORD2(v548)) | (*(_DWORD *)v554 >> 31))) >> 32;
  LODWORD(v132) = v72 ^ v413;
  HIDWORD(v413) ^= v612 + *(_DWORD *)&v554[20] + ((2 * DWORD2(v548)) | (*(_DWORD *)v554 >> 31));
  HIDWORD(v72) = ((2 * DWORD2(v548)) | (*(_DWORD *)v554 >> 31)) ^ (v399 + v547 + (v72 ^ v413));
  LODWORD(v148) = (__PAIR64__(HIDWORD(v583), (int)v399 + (int)v547) + (v413 ^ (unsigned int)v72)) >> 32;
  HIDWORD(v132) = v399 + v547 + (v413 ^ v72);
  v423 = v422 ^ v148;
  HIDWORD(v137) = HIBYTE(HIDWORD(v72)) | (v423 << 8);
  LODWORD(v413) = HIBYTE(v423) | (HIDWORD(v72) << 8);
  v424 = v611
       + __PAIR64__(v72, v612 + *(_DWORD *)&v554[20] + ((2 * DWORD2(v548)) | (*(_DWORD *)v554 >> 31)))
       + __PAIR64__(v413, HIDWORD(v137));
  HIDWORD(v413) ^= HIDWORD(v424);
  v425 = HIWORD(HIDWORD(v413));
  HIDWORD(v413) = (((unsigned int)v424 ^ (unsigned int)v132) >> 16) | (HIDWORD(v413) << 16);
  HIDWORD(v148) = 2 * HIDWORD(v417);
  HIDWORD(v72) = (__PAIR64__(v148, HIDWORD(v132))
                + __PAIR64__(v425 | (((unsigned int)v424 ^ (unsigned int)v132) << 16), HIDWORD(v413))) >> 32;
  HIDWORD(v417) = HIDWORD(v132) + HIDWORD(v413);
  HIDWORD(v148) |= (unsigned int)v417 >> 31;
  *(_DWORD *)&v604[16] = v425 | (((unsigned int)v424 ^ (unsigned int)v132) << 16);
  LODWORD(v132) = (2 * v548) | (HIDWORD(v548) >> 31);
  *(_DWORD *)&v604[12] = HIDWORD(v413);
  v426 = (2 * HIDWORD(v548)) | ((unsigned int)v548 >> 31);
  DWORD2(v548) = HIDWORD(v72) ^ v413;
  LODWORD(v548) = (HIDWORD(v132) + HIDWORD(v413)) ^ HIDWORD(v137);
  v427 = (v606 + __PAIR64__(v571, *(unsigned int *)&v554[4]) + __PAIR64__(v426, v132)) >> 32;
  LODWORD(v417) = v606 + *(_DWORD *)&v554[4] + v132;
  LODWORD(v132) = v132 ^ (*(_DWORD *)v598 + (v427 ^ *(_DWORD *)&v598[8]));
  LODWORD(v72) = (__PAIR64__(*(unsigned int *)&v554[24], *(unsigned int *)v598)
                + __PAIR64__((unsigned int)v417 ^ (unsigned int)v547, v427 ^ *(_DWORD *)&v598[8])) >> 32;
  LODWORD(v148) = *(_DWORD *)v598 + (v427 ^ *(_DWORD *)&v598[8]);
  v428 = v426 ^ v72;
  HIDWORD(v132) = HIBYTE(v428);
  v429 = BYTE3(v132) | (v428 << 8);
  LODWORD(v132) = HIDWORD(v132) | ((_DWORD)v132 << 8);
  v430 = v610 + __PAIR64__(v427, v417) + __PAIR64__(v132, v429);
  HIDWORD(v137) = v427 ^ *(_DWORD *)&v598[8] ^ v430;
  HIDWORD(v413) = v417 ^ v547 ^ HIDWORD(v430);
  *(_DWORD *)&v554[4] = v610 + v417 + v429;
  v431 = HIWORD(HIDWORD(v413));
  HIDWORD(v413) = HIWORD(HIDWORD(v137)) | (HIDWORD(v413) << 16);
  v432 = v431 | (HIDWORD(v137) << 16);
  v433 = __PAIR64__(v72, v148) + __PAIR64__(v432, HIDWORD(v413));
  LODWORD(v72) = (__PAIR64__(v72, v148) + __PAIR64__(v432, HIDWORD(v413))) >> 32;
  LODWORD(v132) = v132 ^ v72;
  v434 = v620 + *(_QWORD *)&v554[8] + __PAIR64__(v137, HIDWORD(v148));
  HIDWORD(v132) = v433 ^ v429;
  v435 = v432 ^ HIDWORD(v434);
  HIDWORD(v413) ^= v434;
  HIDWORD(v148) ^= HIDWORD(v417) + v435;
  v436 = __PAIR64__(HIDWORD(v72), HIDWORD(v417)) + __PAIR64__(HIDWORD(v413), v435);
  HIDWORD(v72) = (__PAIR64__(HIDWORD(v72), HIDWORD(v417)) + __PAIR64__(HIDWORD(v413), v435)) >> 32;
  HIDWORD(v137) = (v616 + v434) >> 32;
  LODWORD(v137) = v137 ^ HIDWORD(v72);
  LODWORD(v413) = BYTE3(v137);
  LODWORD(v137) = HIBYTE(HIDWORD(v148)) | ((_DWORD)v137 << 8);
  HIDWORD(v148) = v413 | (HIDWORD(v148) << 8);
  v437 = v435 ^ (v616 + v434 + v137);
  HIDWORD(v413) ^= (__PAIR64__(HIDWORD(v148), (int)v616 + (int)v434) + v137) >> 32;
  *(_QWORD *)&v554[8] = __PAIR64__(HIDWORD(v148), (int)v616 + (int)v434) + v137;
  LODWORD(v547) = HIWORD(HIDWORD(v413)) | (v437 << 16);
  *(_DWORD *)&v598[8] = HIWORD(v437) | (HIDWORD(v413) << 16);
  HIDWORD(v137) = (2 * v548) | (DWORD2(v548) >> 31);
  LODWORD(v413) = (2 * DWORD2(v548)) | ((unsigned int)v548 >> 31);
  LODWORD(v548) = (v436 + *(_DWORD *)&v598[8]) ^ v137;
  HIDWORD(v583) = v547 + __CFADD__((_DWORD)v436, *(_DWORD *)&v598[8]) + HIDWORD(v72);
  DWORD2(v548) = HIDWORD(v583) ^ HIDWORD(v148);
  v438 = v614 + v593 + __PAIR64__(v413, HIDWORD(v137));
  HIDWORD(v137) ^= v433 + (HIDWORD(v438) ^ *(_DWORD *)&v604[8]);
  v439 = __PAIR64__(v72, v433)
       + __PAIR64__((unsigned int)v438 ^ *(_DWORD *)&v604[4], HIDWORD(v438) ^ *(_DWORD *)&v604[8]);
  LODWORD(v72) = (__PAIR64__(v72, v433)
                + __PAIR64__((unsigned int)v438 ^ *(_DWORD *)&v604[4], HIDWORD(v438) ^ *(_DWORD *)&v604[8])) >> 32;
  HIDWORD(v148) = HIBYTE(HIDWORD(v137)) | (((unsigned int)v72 ^ (unsigned int)v413) << 8);
  HIDWORD(v72) = (((unsigned int)v72 ^ (unsigned int)v413) >> 24) | (HIDWORD(v137) << 8);
  HIDWORD(v417) = HIDWORD(v438) ^ *(_DWORD *)&v604[8] ^ (v619 + v438 + HIDWORD(v148));
  LODWORD(v417) = v438 ^ *(_DWORD *)&v604[4] ^ ((v619 + v438 + __PAIR64__(HIDWORD(v72), HIDWORD(v148))) >> 32);
  v440 = WORD1(v417);
  LODWORD(v417) = HIWORD(HIDWORD(v417)) | ((_DWORD)v417 << 16);
  v594 = v619 + v438 + __PAIR64__(HIDWORD(v72), HIDWORD(v148));
  HIDWORD(v417) = v440 | (HIDWORD(v417) << 16);
  v441 = (2 * v132) | (HIDWORD(v132) >> 31);
  LODWORD(v132) = v132 >> 31;
  *(_DWORD *)v598 = v439 + v417;
  HIDWORD(v548) = (v439 + v417) ^ HIDWORD(v148);
  v580 = (__PAIR64__(v72, v439) + v417) >> 32;
  LODWORD(v413) = (v608 + v424 + v132) ^ *(_DWORD *)&v598[4];
  v442 = v608 + v424 + v132;
  LODWORD(v72) = (v608 + v424 + __PAIR64__(v441, v132)) >> 32;
  LODWORD(v132) = v132 ^ (*(_DWORD *)&v554[16] + (v72 ^ *(_DWORD *)v604));
  *(_DWORD *)v554 = v580 ^ HIDWORD(v72);
  HIDWORD(v72) = (__PAIR64__(HIDWORD(v571), *(unsigned int *)&v554[16])
                + __PAIR64__(v413, (unsigned int)v72 ^ *(_DWORD *)v604)) >> 32;
  v443 = v441 ^ HIDWORD(v72);
  LODWORD(v137) = BYTE3(v132) | (v443 << 8);
  HIDWORD(v148) = HIBYTE(v443) | ((_DWORD)v132 << 8);
  v444 = v617 + __PAIR64__(v72, v442) + __PAIR64__(HIDWORD(v148), v137);
  HIDWORD(v137) = v72 ^ *(_DWORD *)v604 ^ v444;
  LODWORD(v413) = v413 ^ HIDWORD(v444);
  LODWORD(v132) = HIWORD(HIDWORD(v137)) | ((_DWORD)v413 << 16);
  v445 = __PAIR64__(WORD1(v413) | (HIDWORD(v137) << 16), *(_DWORD *)&v554[16] + ((unsigned int)v72 ^ *(_DWORD *)v604))
       + __PAIR64__(HIDWORD(v72), v132);
  HIDWORD(v72) = (__PAIR64__(
                    WORD1(v413) | (HIDWORD(v137) << 16),
                    *(_DWORD *)&v554[16] + ((unsigned int)v72 ^ *(_DWORD *)v604))
                + __PAIR64__(HIDWORD(v72), v132)) >> 32;
  *(_DWORD *)v604 = WORD1(v413) | (HIDWORD(v137) << 16);
  HIDWORD(v132) = (2 * HIDWORD(v547)) | (DWORD1(v548) >> 31);
  LODWORD(v413) = *(_DWORD *)&v554[4];
  HIDWORD(v137) = (2 * DWORD1(v548)) | (HIDWORD(v547) >> 31);
  *(_DWORD *)&v554[4] = HIDWORD(v72) ^ HIDWORD(v148);
  DWORD1(v548) = v445 ^ v137;
  *(_DWORD *)&v598[4] = v132;
  v446 = v618 + __PAIR64__(HIDWORD(v430), v413) + __PAIR64__(HIDWORD(v137), HIDWORD(v132));
  HIDWORD(v413) = v446 ^ *(_DWORD *)&v604[12];
  LODWORD(v413) = HIDWORD(v446) ^ *(_DWORD *)&v604[16];
  HIDWORD(v132) ^= v421 + (HIDWORD(v446) ^ *(_DWORD *)&v604[16]);
  LODWORD(v72) = (v421 + v413) >> 32;
  HIDWORD(v137) ^= v72;
  LODWORD(v132) = HIBYTE(HIDWORD(v132)) | (HIDWORD(v137) << 8);
  HIDWORD(v132) = HIBYTE(HIDWORD(v137)) | (HIDWORD(v132) << 8);
  v447 = v413 ^ (v605 + v446 + v132);
  v448 = HIWORD(HIDWORD(v447));
  HIDWORD(v447) = v447 >> 16;
  *(_QWORD *)&v554[20] = v605 + v446 + v132;
  LODWORD(v447) = v448 | ((_DWORD)v447 << 16);
  v449 = __PAIR64__(v72, (int)v421 + (HIDWORD(v446) ^ *(_DWORD *)&v604[16])) + __PAIR64__(v447, HIDWORD(v447));
  LODWORD(v72) = (__PAIR64__(v72, (int)v421 + (HIDWORD(v446) ^ *(_DWORD *)&v604[16])) + __PAIR64__(v447, HIDWORD(v447))) >> 32;
  v450 = v132 ^ __PAIR64__(v72, v449);
  HIDWORD(v137) = 2 * HIDWORD(v450);
  HIDWORD(v450) = (2 * v450) | (HIDWORD(v450) >> 31);
  LODWORD(v450) = HIDWORD(v137) | ((unsigned int)v450 >> 31);
  v451 = v605 + *(_QWORD *)&v554[8] + __PAIR64__(v450, HIDWORD(v450));
  v452 = v417 ^ v451;
  HIDWORD(v450) ^= v445 + HIDWORD(v452);
  v453 = __PAIR64__(HIDWORD(v72), v445) + __PAIR64__(v452, HIDWORD(v452));
  HIDWORD(v72) = (__PAIR64__(HIDWORD(v72), v445) + __PAIR64__(v452, HIDWORD(v452))) >> 32;
  LODWORD(v450) = v450 ^ HIDWORD(v72);
  HIDWORD(v137) = BYTE3(v450);
  LODWORD(v450) = HIBYTE(HIDWORD(v450)) | ((_DWORD)v450 << 8);
  HIDWORD(v452) ^= v606 + v451 + (_DWORD)v450;
  *(_DWORD *)&v554[8] = v606 + v451 + v450;
  HIDWORD(v450) = HIDWORD(v137) | (HIDWORD(v450) << 8);
  LODWORD(v452) = v452 ^ ((v606 + v451 + v450) >> 32);
  *(_DWORD *)&v554[12] = (v606 + v451 + v450) >> 32;
  *(_DWORD *)&v604[4] = HIWORD(HIDWORD(v452)) | ((_DWORD)v452 << 16);
  v454 = __PAIR64__(HIDWORD(v72), v453) + ((v452 << 16) | HIWORD(HIDWORD(v452)));
  *(_DWORD *)&v604[8] = v452 >> 16;
  HIDWORD(v452) = (2 * DWORD2(v548)) | ((unsigned int)v548 >> 31);
  LODWORD(v452) = (2 * v548) | (DWORD2(v548) >> 31);
  LODWORD(v548) = v454 ^ v450;
  v455 = v607 + v594 + v452;
  DWORD2(v548) = HIDWORD(v454) ^ HIDWORD(v450);
  LODWORD(v452) = v452 ^ (v449 + (HIDWORD(v455) ^ *(_DWORD *)v604));
  v456 = __PAIR64__(v72, v449) + __PAIR64__((unsigned int)v455 ^ *(_DWORD *)&v598[4], HIDWORD(v455) ^ *(_DWORD *)v604);
  LODWORD(v72) = (__PAIR64__(v72, v449)
                + __PAIR64__((unsigned int)v455 ^ *(_DWORD *)&v598[4], HIDWORD(v455) ^ *(_DWORD *)v604)) >> 32;
  HIDWORD(v452) ^= v72;
  HIDWORD(v450) = HIBYTE(HIDWORD(v452));
  HIDWORD(v452) = v452 >> 24;
  LODWORD(v452) = HIDWORD(v450) | ((_DWORD)v452 << 8);
  v457 = v608 + v455 + __PAIR64__(v452, HIDWORD(v452));
  LODWORD(v450) = HIDWORD(v455) ^ *(_DWORD *)v604 ^ v457;
  HIDWORD(v72) = v455 ^ *(_DWORD *)&v598[4] ^ HIDWORD(v457);
  *(_DWORD *)&v598[4] = WORD1(v450) | (HIDWORD(v72) << 16);
  HIDWORD(v148) = (__PAIR64__(v72, v456)
                 + __PAIR64__(HIWORD(HIDWORD(v72)) | ((_DWORD)v450 << 16), *(unsigned int *)&v598[4])) >> 32;
  *(_DWORD *)v604 = HIWORD(HIDWORD(v72)) | ((_DWORD)v450 << 16);
  HIDWORD(v72) = (2 * HIDWORD(v548)) | (*(_DWORD *)v554 >> 31);
  v458 = (2 * *(_DWORD *)v554) | (HIDWORD(v548) >> 31);
  HIDWORD(v452) ^= v456 + *(_DWORD *)&v598[4];
  *(_DWORD *)&v554[16] = v456 + *(_DWORD *)&v598[4];
  LODWORD(v452) = v452 ^ HIDWORD(v148);
  LODWORD(v72) = (v609 + v444 + __PAIR64__(v458, HIDWORD(v72))) >> 32;
  v459 = v609 + v444 + HIDWORD(v72);
  HIDWORD(v447) ^= v459;
  LODWORD(v450) = v72 ^ v447;
  HIDWORD(v72) ^= v436 + *(_DWORD *)&v598[8] + (v72 ^ v447);
  LODWORD(v137) = (2 * v452) | (HIDWORD(v452) >> 31);
  LODWORD(v148) = (__PAIR64__(HIDWORD(v583), (int)v436 + *(_DWORD *)&v598[8]) + (v447 ^ (unsigned int)v72)) >> 32;
  HIDWORD(v450) = v436 + *(_DWORD *)&v598[8] + (v447 ^ v72);
  v460 = v458 ^ v148;
  HIDWORD(v137) = HIBYTE(HIDWORD(v72)) | (v460 << 8);
  LODWORD(v447) = HIBYTE(v460) | (HIDWORD(v72) << 8);
  v461 = v610 + __PAIR64__(v72, v459) + __PAIR64__(v447, HIDWORD(v137));
  HIDWORD(v447) ^= HIDWORD(v461);
  *(_QWORD *)v572 = __PAIR64__(HIDWORD(v148), v461);
  *(_DWORD *)&v604[12] = (((unsigned int)v461 ^ (unsigned int)v450) >> 16) | (HIDWORD(v447) << 16);
  HIDWORD(v148) = v452 >> 31;
  *(_DWORD *)&v604[16] = HIWORD(HIDWORD(v447)) | (((unsigned int)v461 ^ (unsigned int)v450) << 16);
  LODWORD(v450) = (2 * DWORD1(v548)) | (*(_DWORD *)&v554[4] >> 31);
  v462 = (2 * *(_DWORD *)&v554[4]) | (DWORD1(v548) >> 31);
  HIDWORD(v72) = (__PAIR64__(v148, HIDWORD(v450)) + *(_QWORD *)&v604[12]) >> 32;
  HIDWORD(v452) = HIDWORD(v450) + *(_DWORD *)&v604[12];
  DWORD1(v548) = (HIDWORD(v450) + *(_DWORD *)&v604[12]) ^ HIDWORD(v137);
  v463 = (v611 + *(_QWORD *)&v554[20] + __PAIR64__(v462, v450)) >> 32;
  LODWORD(v452) = v611 + *(_DWORD *)&v554[20] + v450;
  HIDWORD(v447) = v452 ^ *(_DWORD *)&v598[8];
  HIDWORD(v137) = v463 ^ v547;
  LODWORD(v547) = HIDWORD(v72) ^ v447;
  LODWORD(v450) = v450 ^ (*(_DWORD *)v598 + HIDWORD(v137));
  LODWORD(v72) = (__PAIR64__(v580, *(unsigned int *)v598)
                + __PAIR64__((unsigned int)v452 ^ *(_DWORD *)&v598[8], HIDWORD(v137))) >> 32;
  LODWORD(v148) = *(_DWORD *)v598 + HIDWORD(v137);
  v464 = v462 ^ v72;
  LODWORD(v447) = BYTE3(v450);
  LODWORD(v450) = HIBYTE(v464) | ((_DWORD)v450 << 8);
  v465 = v447 | (v464 << 8);
  HIDWORD(v450) = (v612 + __PAIR64__(v463, v452) + __PAIR64__(v450, v465)) >> 32;
  LODWORD(v452) = v612 + v452 + v465;
  HIDWORD(v137) ^= v452;
  HIDWORD(v447) ^= HIDWORD(v450);
  *(_DWORD *)&v554[4] = v452;
  v466 = HIWORD(HIDWORD(v447));
  HIDWORD(v447) = HIWORD(HIDWORD(v137)) | (HIDWORD(v447) << 16);
  v467 = v466 | (HIDWORD(v137) << 16);
  v468 = __PAIR64__(v72, v148) + __PAIR64__(v467, HIDWORD(v447));
  LODWORD(v72) = (__PAIR64__(v72, v148) + __PAIR64__(v467, HIDWORD(v447))) >> 32;
  HIDWORD(v548) = v468 ^ v465;
  LODWORD(v450) = v450 ^ v72;
  v469 = v613 + *(_QWORD *)&v554[8] + __PAIR64__(v137, HIDWORD(v148));
  HIDWORD(v447) ^= v469;
  v470 = v467 ^ HIDWORD(v469);
  HIDWORD(v148) ^= HIDWORD(v452) + v470;
  v471 = __PAIR64__(HIDWORD(v72), HIDWORD(v452)) + __PAIR64__(HIDWORD(v447), v470);
  HIDWORD(v72) = (__PAIR64__(HIDWORD(v72), HIDWORD(v452)) + __PAIR64__(HIDWORD(v447), v470)) >> 32;
  LODWORD(v137) = v137 ^ HIDWORD(v72);
  LODWORD(v447) = BYTE3(v137);
  LODWORD(v137) = HIBYTE(HIDWORD(v148)) | ((_DWORD)v137 << 8);
  HIDWORD(v137) = (v614 + v469) >> 32;
  HIDWORD(v148) = v447 | (HIDWORD(v148) << 8);
  v472 = v470 ^ (v614 + v469 + v137);
  *(_QWORD *)&v554[8] = __PAIR64__(HIDWORD(v148), (int)v614 + (int)v469) + v137;
  HIDWORD(v447) ^= (__PAIR64__(HIDWORD(v148), (int)v614 + (int)v469) + v137) >> 32;
  v473 = HIWORD(HIDWORD(v447));
  HIDWORD(v447) = HIWORD(v472) | (HIDWORD(v447) << 16);
  v474 = v473 | (v472 << 16);
  *(_DWORD *)v598 = HIDWORD(v447);
  LODWORD(v452) = (2 * DWORD1(v548)) | ((unsigned int)v547 >> 31);
  HIDWORD(v72) = (__PAIR64__(HIDWORD(v72), v471) + __PAIR64__(v474, HIDWORD(v447))) >> 32;
  v475 = (2 * v547) | (DWORD1(v548) >> 31);
  *(_DWORD *)&v598[8] = v474;
  *(_QWORD *)&v554[20] = __PAIR64__(HIDWORD(v72), (int)v471 + HIDWORD(v447));
  DWORD1(v548) = (v471 + HIDWORD(v447)) ^ v137;
  *(_DWORD *)v554 = HIDWORD(v72) ^ HIDWORD(v148);
  LODWORD(v137) = (v615 + v457 + __PAIR64__(v475, v452)) >> 32;
  HIDWORD(v452) = v615 + v457 + v452;
  LODWORD(v452) = v452 ^ (v468 + (v137 ^ *(_DWORD *)&v604[8]));
  v476 = __PAIR64__(v72, v468)
       + __PAIR64__(HIDWORD(v452) ^ *(_DWORD *)&v604[4], (unsigned int)v137 ^ *(_DWORD *)&v604[8]);
  LODWORD(v72) = (__PAIR64__(v72, v468)
                + __PAIR64__(HIDWORD(v452) ^ *(_DWORD *)&v604[4], (unsigned int)v137 ^ *(_DWORD *)&v604[8])) >> 32;
  v477 = v475 ^ v72;
  HIDWORD(v447) = BYTE3(v452) | (v477 << 8);
  LODWORD(v452) = HIBYTE(v477) | ((_DWORD)v452 << 8);
  v478 = v616 + __PAIR64__(v137, HIDWORD(v452)) + __PAIR64__(v452, HIDWORD(v447));
  v479 = v137 ^ *(_DWORD *)&v604[8] ^ v478;
  HIDWORD(v72) = HIDWORD(v452) ^ *(_DWORD *)&v604[4] ^ HIDWORD(v478);
  HIDWORD(v148) = HIWORD(HIDWORD(v72));
  HIDWORD(v72) = HIWORD(v479) | (HIDWORD(v72) << 16);
  v480 = HIDWORD(v148) | (v479 << 16);
  v481 = 2 * v450;
  LODWORD(v148) = (__PAIR64__(v72, v476) + __PAIR64__(v480, HIDWORD(v72))) >> 32;
  LODWORD(v450) = (2 * HIDWORD(v548)) | ((unsigned int)v450 >> 31);
  v482 = v481 | (HIDWORD(v548) >> 31);
  *(_QWORD *)&v604[4] = __PAIR64__(v480, HIDWORD(v72));
  LODWORD(v547) = (v476 + HIDWORD(v72)) ^ HIDWORD(v447);
  v483 = v617 + __PAIR64__(HIDWORD(v461), *(unsigned int *)v572) + __PAIR64__(v482, v450);
  *(_DWORD *)v572 = v476 + HIDWORD(v72);
  LODWORD(v450) = v450 ^ (v454 + (HIDWORD(v483) ^ *(_DWORD *)v604));
  HIDWORD(v548) = v148 ^ v452;
  v484 = (v454 + __PAIR64__((unsigned int)v483 ^ *(_DWORD *)&v598[4], HIDWORD(v483) ^ *(_DWORD *)v604)) >> 32;
  LODWORD(v452) = v454 + (HIDWORD(v483) ^ *(_DWORD *)v604);
  v485 = v482 ^ v484;
  HIDWORD(v137) = BYTE3(v450) | (v485 << 8);
  LODWORD(v447) = HIBYTE(v485) | ((_DWORD)v450 << 8);
  v486 = v618 + v483 + __PAIR64__(v447, HIDWORD(v137));
  HIDWORD(v452) = HIDWORD(v483) ^ *(_DWORD *)v604 ^ v486;
  LODWORD(v72) = v483 ^ *(_DWORD *)&v598[4] ^ HIDWORD(v486);
  LODWORD(v583) = v618 + v483 + HIDWORD(v137);
  *(_DWORD *)&v598[4] = HIWORD(HIDWORD(v452)) | ((_DWORD)v72 << 16);
  *(_DWORD *)v604 = WORD1(v72) | (HIDWORD(v452) << 16);
  LODWORD(v450) = v619;
  LODWORD(v72) = (2 * v548) | (DWORD2(v548) >> 31);
  HIDWORD(v452) = (2 * DWORD2(v548)) | ((unsigned int)v548 >> 31);
  v488 = __PAIR64__(v484, v452) + __PAIR64__(*(unsigned int *)v604, *(unsigned int *)&v598[4]);
  v487 = (__PAIR64__(v484, v452) + __PAIR64__(*(unsigned int *)v604, *(unsigned int *)&v598[4])) >> 32;
  HIDWORD(v137) ^= v488;
  HIDWORD(v447) = (v619 + *(_DWORD *)&v554[4] + v72) ^ *(_DWORD *)&v604[12];
  v489 = v450 + __PAIR64__(HIDWORD(v619), *(unsigned int *)&v554[4]) + __PAIR64__(HIDWORD(v452), v72);
  LODWORD(v72) = v72 ^ (*(_DWORD *)&v554[16] + (HIDWORD(v489) ^ *(_DWORD *)&v604[16]));
  v490 = (__PAIR64__(*(unsigned int *)&v572[4], *(unsigned int *)&v554[16])
        + __PAIR64__(HIDWORD(v447), HIDWORD(v489) ^ *(_DWORD *)&v604[16])) >> 32;
  HIDWORD(v452) ^= v490;
  HIDWORD(v72) = HIBYTE(HIDWORD(v452));
  HIDWORD(v452) = BYTE3(v72) | (HIDWORD(v452) << 8);
  LODWORD(v72) = HIDWORD(v72) | ((_DWORD)v72 << 8);
  LODWORD(v450) = HIDWORD(v489) ^ *(_DWORD *)&v604[16] ^ (v620 + v489 + HIDWORD(v452));
  HIDWORD(v447) ^= (v620 + v489 + __PAIR64__(v72, HIDWORD(v452))) >> 32;
  LODWORD(v548) = v620 + v489 + HIDWORD(v452);
  HIDWORD(v148) = HIWORD(HIDWORD(v447));
  HIDWORD(v72) = WORD1(v450) | (HIDWORD(v447) << 16);
  HIDWORD(v447) = DWORD1(v548);
  DWORD2(v548) = (v620 + v489 + __PAIR64__(v72, HIDWORD(v452))) >> 32;
  HIDWORD(v452) ^= *(_DWORD *)&v554[16] + (HIDWORD(v489) ^ *(_DWORD *)&v604[16]) + HIDWORD(v72);
  v492 = __PAIR64__(HIDWORD(v148) | ((_DWORD)v450 << 16), *(_DWORD *)&v554[16] + (HIDWORD(v489) ^ *(_DWORD *)&v604[16]))
       + __PAIR64__(v490, HIDWORD(v72));
  v491 = (__PAIR64__(
            HIDWORD(v148) | ((_DWORD)v450 << 16),
            *(_DWORD *)&v554[16] + (HIDWORD(v489) ^ *(_DWORD *)&v604[16]))
        + __PAIR64__(v490, HIDWORD(v72))) >> 32;
  LODWORD(v72) = v72 ^ v491;
  *(_DWORD *)&v554[4] = HIDWORD(v72);
  DWORD1(v548) = (2 * DWORD1(v548)) | (*(_DWORD *)v554 >> 31);
  LODWORD(v137) = (2 * *(_DWORD *)v554) | (HIDWORD(v447) >> 31);
  *(_DWORD *)v554 = HIDWORD(v148) | ((_DWORD)v450 << 16);
  LODWORD(v450) = 2 * v72;
  LODWORD(v72) = (2 * HIDWORD(v452)) | ((unsigned int)v72 >> 31);
  HIDWORD(v452) = v450 | (HIDWORD(v452) >> 31);
  HIDWORD(v72) = (unsigned __int64)(v619 + *(_QWORD *)&v554[8]) >> 32;
  v493 = v619 + *(_DWORD *)&v554[8] + v72;
  HIDWORD(v72) = (__PAIR64__(HIDWORD(v452), (int)v619 + *(_DWORD *)&v554[8]) + v72) >> 32;
  HIDWORD(v545) = (2 * v547) | (HIDWORD(v548) >> 31);
  LODWORD(v547) = (2 * HIDWORD(v548)) | ((unsigned int)v547 >> 31);
  LODWORD(v72) = v72 ^ (v488 + (HIDWORD(v72) ^ *(_DWORD *)&v604[8]));
  HIDWORD(v547) = (2 * HIDWORD(v137)) | (((unsigned int)v447 ^ v487) >> 31);
  HIDWORD(v548) = (2 * (v447 ^ v487)) | (HIDWORD(v137) >> 31);
  v495 = __PAIR64__(v487, v488) + __PAIR64__(v493 ^ *(_DWORD *)&v604[4], HIDWORD(v72) ^ *(_DWORD *)&v604[8]);
  v494 = (__PAIR64__(v487, v488) + __PAIR64__(v493 ^ *(_DWORD *)&v604[4], HIDWORD(v72) ^ *(_DWORD *)&v604[8])) >> 32;
  HIDWORD(v452) ^= v494;
  LODWORD(v447) = HIBYTE(HIDWORD(v452));
  HIDWORD(v452) = BYTE3(v72) | (HIDWORD(v452) << 8);
  LODWORD(v72) = v447 | ((_DWORD)v72 << 8);
  v496 = v615 + __PAIR64__(HIDWORD(v72), v493) + __PAIR64__(v72, HIDWORD(v452));
  HIDWORD(v450) = HIDWORD(v72) ^ *(_DWORD *)&v604[8] ^ v496;
  LODWORD(v450) = v493 ^ *(_DWORD *)&v604[4] ^ HIDWORD(v496);
  *(_DWORD *)&v554[8] = HIWORD(HIDWORD(v450)) | ((_DWORD)v450 << 16);
  v497 = __PAIR64__(v494, v495) + ((v450 << 16) | HIWORD(HIDWORD(v450)));
  HIDWORD(v452) ^= v497;
  LODWORD(v72) = v72 ^ HIDWORD(v497);
  *(_DWORD *)&v554[12] = v450 >> 16;
  HIDWORD(v447) = (v609 + v478 + DWORD1(v548)) ^ *(_DWORD *)&v598[4];
  v498 = v609 + v478 + __PAIR64__(v137, DWORD1(v548));
  HIDWORD(v450) = (v492 + (HIDWORD(v498) ^ *(_DWORD *)v604)) ^ DWORD1(v548);
  v500 = __PAIR64__(v491, v492) + __PAIR64__(HIDWORD(v447), HIDWORD(v498) ^ *(_DWORD *)v604);
  v499 = (__PAIR64__(v491, v492) + __PAIR64__(HIDWORD(v447), HIDWORD(v498) ^ *(_DWORD *)v604)) >> 32;
  LODWORD(v137) = v137 ^ v499;
  v501 = BYTE3(v137);
  LODWORD(v137) = HIBYTE(HIDWORD(v450)) | ((_DWORD)v137 << 8);
  v502 = v501 | (HIDWORD(v450) << 8);
  HIDWORD(v72) = HIDWORD(v498) ^ *(_DWORD *)v604 ^ (v613 + v498 + v137);
  HIDWORD(v534) = v613 + v498 + v137;
  DWORD1(v548) = (2 * HIDWORD(v452)) | ((unsigned int)v72 >> 31);
  HIDWORD(v450) = (v613 + v498 + __PAIR64__(v502, v137)) >> 32;
  HIDWORD(v447) ^= HIDWORD(v450);
  LODWORD(v72) = (2 * v72) | (HIDWORD(v452) >> 31);
  LODWORD(v452) = HIWORD(HIDWORD(v72)) | (HIDWORD(v447) << 16);
  HIDWORD(v452) = HIWORD(HIDWORD(v447)) | (HIDWORD(v72) << 16);
  *(_DWORD *)&v554[16] = v72;
  LODWORD(v137) = v137 ^ (v500 + v452);
  LODWORD(v545) = HIDWORD(v450);
  *(_QWORD *)&v572[4] = v452;
  v535 = __PAIR64__(v499, v500) + v452;
  HIDWORD(v447) = (v614 + v583 + HIDWORD(v545)) ^ *(_DWORD *)&v554[4];
  v503 = v614 + __PAIR64__(HIDWORD(v486), v583) + __PAIR64__(v547, HIDWORD(v545));
  HIDWORD(v450) = ((__PAIR64__(v499, v500) + v452) >> 32) ^ v502;
  v504 = *(_QWORD *)&v554[20] + __PAIR64__(HIDWORD(v447), HIDWORD(v503) ^ *(_DWORD *)v554);
  HIDWORD(v148) = (*(_DWORD *)&v554[20] + (HIDWORD(v503) ^ *(_DWORD *)v554)) ^ HIDWORD(v545);
  LODWORD(v452) = ((*(_QWORD *)&v554[20] + __PAIR64__(HIDWORD(v447), HIDWORD(v503) ^ *(_DWORD *)v554)) >> 32) ^ v547;
  LODWORD(v72) = HIBYTE(HIDWORD(v148)) | ((_DWORD)v452 << 8);
  LODWORD(v447) = BYTE3(v452) | (HIDWORD(v148) << 8);
  HIDWORD(v447) ^= (v620 + v503 + __PAIR64__(v447, v72)) >> 32;
  v539 = v620 + v503 + __PAIR64__(v447, v72);
  LODWORD(v450) = HIDWORD(v503) ^ *(_DWORD *)v554 ^ (v620 + v503 + v72);
  HIDWORD(v72) = (2 * HIDWORD(v450)) | ((unsigned int)v137 >> 31);
  v505 = v504 + __PAIR64__(HIWORD(HIDWORD(v447)) | ((_DWORD)v450 << 16), WORD1(v450) | (HIDWORD(v447) << 16));
  LODWORD(v72) = v72 ^ (v504 + (WORD1(v450) | (HIDWORD(v447) << 16)));
  *(_DWORD *)v554 = HIWORD(HIDWORD(v447)) | ((_DWORD)v450 << 16);
  LODWORD(v547) = WORD1(v450) | (HIDWORD(v447) << 16);
  LODWORD(v450) = ((v618 + __PAIR64__(DWORD2(v548), v548) + __PAIR64__(HIDWORD(v548), HIDWORD(v547))) >> 32)
                ^ *(_DWORD *)&v598[8];
  HIDWORD(v545) = (2 * v137) | (HIDWORD(v450) >> 31);
  LODWORD(v452) = *(_DWORD *)v572 + v450;
  LODWORD(v534) = HIDWORD(v505) ^ v447;
  v506 = ((v618 + v548 + HIDWORD(v547)) ^ *(_DWORD *)v598) + __CFADD__(*(_DWORD *)v572, (_DWORD)v450) + (_DWORD)v148;
  HIDWORD(v447) = (((unsigned int)(*(_DWORD *)v572 + v450) ^ HIDWORD(v547)) >> 24) | ((v506 ^ HIDWORD(v548)) << 8);
  LODWORD(v447) = ((v506 ^ HIDWORD(v548)) >> 24) | (((*(_DWORD *)v572 + (_DWORD)v450) ^ HIDWORD(v547)) << 8);
  HIDWORD(v137) = (2 * v72) | ((unsigned int)v534 >> 31);
  v541 = v611
       + v618
       + __PAIR64__(DWORD2(v548), v548)
       + __PAIR64__(HIDWORD(v548), HIDWORD(v547))
       + __PAIR64__(v447, HIDWORD(v447));
  LODWORD(v450) = v450 ^ v541;
  LODWORD(v534) = (2 * v534) | ((unsigned int)v72 >> 31);
  HIDWORD(v450) = (v618 + v548 + HIDWORD(v547)) ^ *(_DWORD *)v598 ^ HIDWORD(v541);
  LODWORD(v72) = v450 >> 16;
  LODWORD(v148) = HIWORD(HIDWORD(v450)) | ((_DWORD)v450 << 16);
  v508 = v452 + v72;
  v507 = (__PAIR64__(v506, v452) + __PAIR64__(v148, v72)) >> 32;
  HIDWORD(v447) ^= v452 + (_DWORD)v72;
  LODWORD(v447) = v447 ^ v507;
  v509 = v606 + v496 + __PAIR64__(HIDWORD(v72), HIDWORD(v545));
  LODWORD(v148) = v148 ^ HIDWORD(v509);
  v510 = v505 + __PAIR64__((unsigned int)v72 ^ (unsigned int)v509, v148);
  HIDWORD(v72) ^= (v505 + __PAIR64__((unsigned int)v72 ^ (unsigned int)v509, v148)) >> 32;
  LODWORD(v137) = HIBYTE(HIDWORD(v72));
  HIDWORD(v72) = (((unsigned int)(v505 + v148) ^ HIDWORD(v545)) >> 24) | (HIDWORD(v72) << 8);
  HIDWORD(v450) = v137 | ((((_DWORD)v505 + (_DWORD)v148) ^ HIDWORD(v545)) << 8);
  v546 = v617 + v509 + __PAIR64__(HIDWORD(v450), HIDWORD(v72));
  v540 = (2 * v447) | (HIDWORD(v447) >> 31);
  LODWORD(v148) = v148 ^ v546;
  v621 = v546;
  LODWORD(v537) = v447 >> 31;
  HIDWORD(v148) = (((unsigned int)v72 ^ (unsigned int)v509 ^ HIDWORD(v546)) >> 16) | ((_DWORD)v148 << 16);
  v637 = WORD1(v148) | (((unsigned int)v72 ^ (unsigned int)v509 ^ HIDWORD(v546)) << 16);
  v638 = HIDWORD(v148);
  HIDWORD(v72) ^= v510 + v637;
  HIDWORD(v450) ^= (v510 + __PAIR64__(HIDWORD(v148), v637)) >> 32;
  v631 = v510 + __PAIR64__(HIDWORD(v148), v637);
  HIDWORD(v447) = HIDWORD(v137);
  v511 = v605 + __PAIR64__(v545, HIDWORD(v534)) + __PAIR64__(v534, HIDWORD(v137));
  LODWORD(v137) = HIDWORD(v511) ^ *(_DWORD *)&v554[12];
  LODWORD(v452) = v452 + v72 + (HIDWORD(v511) ^ *(_DWORD *)&v554[12]);
  HIDWORD(v137) = v511 ^ *(_DWORD *)&v554[8];
  HIDWORD(v534) = v452;
  v512 = (__PAIR64__(v507, v508) + v137) >> 32;
  LODWORD(v72) = (((unsigned int)v452 ^ HIDWORD(v447)) >> 24) | ((v512 ^ (unsigned int)v534) << 8);
  LODWORD(v450) = ((v512 ^ (unsigned int)v534) >> 24) | (((unsigned int)v452 ^ HIDWORD(v447)) << 8);
  v513 = v137 ^ (v607 + v511 + __PAIR64__(v450, v72));
  v514 = v513 >> 16;
  v622 = v607 + v511 + __PAIR64__(v450, v72);
  HIDWORD(v514) = (v513 >> 16 >> 32) | ((_DWORD)v513 << 16);
  v633 = v514;
  LODWORD(v626) = (2 * HIDWORD(v72)) | (HIDWORD(v450) >> 31);
  HIDWORD(v626) = (2 * HIDWORD(v450)) | (HIDWORD(v72) >> 31);
  LODWORD(v72) = v72 ^ (HIDWORD(v534) + (v513 >> 16));
  v516 = HIDWORD(v534) + (v513 >> 16);
  v515 = (__PAIR64__(v512, HIDWORD(v534)) + v514) >> 32;
  LODWORD(v450) = v450 ^ v515;
  v517 = v616 + v539 + __PAIR64__(v540, v537);
  HIDWORD(v513) = v517 ^ *(_DWORD *)&v572[4];
  LODWORD(v513) = HIDWORD(v517) ^ *(_DWORD *)&v572[8];
  LODWORD(v447) = (v497 + (HIDWORD(v517) ^ *(_DWORD *)&v572[8])) ^ v537;
  HIDWORD(v514) = (v497 + v513) >> 32;
  HIDWORD(v148) = v497 + (HIDWORD(v517) ^ *(_DWORD *)&v572[8]);
  HIDWORD(v447) = HIDWORD(v514) ^ v540;
  HIDWORD(v72) = v447 >> 24;
  HIDWORD(v450) = ((HIDWORD(v514) ^ v540) >> 24) | ((_DWORD)v447 << 8);
  LODWORD(v513) = HIDWORD(v517) ^ *(_DWORD *)&v572[8] ^ (v612 + v616 + v539 + v537 + HIDWORD(v72));
  v532 = v612 + v616 + v539 + v537 + HIDWORD(v72);
  HIDWORD(v513) = v517 ^ *(_DWORD *)&v572[4] ^ ((v612 + v517 + __PAIR64__(HIDWORD(v450), HIDWORD(v72))) >> 32);
  LODWORD(v627) = (2 * v72) | ((unsigned int)v450 >> 31);
  HIDWORD(v623) = (v612 + v517 + __PAIR64__(HIDWORD(v450), HIDWORD(v72))) >> 32;
  LODWORD(v634) = (__int64)v513 >> 16;
  HIDWORD(v627) = (2 * v450) | ((unsigned int)v72 >> 31);
  v632 = __PAIR64__(v515, v516);
  HIDWORD(v634) = HIWORD(HIDWORD(v513)) | ((_DWORD)v513 << 16);
  HIDWORD(v72) ^= HIDWORD(v148) + v634;
  v519 = __PAIR64__(HIDWORD(v514), HIDWORD(v148)) + v634;
  v518 = (__PAIR64__(HIDWORD(v514), HIDWORD(v148)) + v634) >> 32;
  HIDWORD(v450) ^= v518;
  v520 = v610 + v541 + __PAIR64__(*(unsigned int *)&v554[16], DWORD1(v548));
  v533 = (v610 + v541 + DWORD1(v548)) ^ v547;
  v629 = __PAIR64__(v518, v519);
  LODWORD(v513) = (v535 + __PAIR64__(v533, HIDWORD(v520) ^ *(_DWORD *)v554)) >> 32;
  v521 = v535 + (HIDWORD(v520) ^ *(_DWORD *)v554);
  v522 = ((v521 ^ DWORD1(v548)) >> 24) | (((unsigned int)v513 ^ *(_DWORD *)&v554[16]) << 8);
  LODWORD(v72) = (((unsigned int)v513 ^ *(_DWORD *)&v554[16]) >> 24) | ((v521 ^ DWORD1(v548)) << 8);
  LODWORD(v623) = v532;
  LODWORD(v514) = (v608 + v520 + __PAIR64__(v72, v522)) >> 32;
  LODWORD(v450) = HIDWORD(v520) ^ *(_DWORD *)v554 ^ (v608 + v520 + v522);
  v624 = v608 + v520 + __PAIR64__(v72, v522);
  HIDWORD(v628) = (2 * HIDWORD(v450)) | (HIDWORD(v72) >> 31);
  HIDWORD(v513) = WORD1(v450) | ((v533 ^ (unsigned int)v514) << 16);
  LODWORD(v628) = (2 * HIDWORD(v72)) | (HIDWORD(v450) >> 31);
  LODWORD(v450) = ((v533 ^ (unsigned int)v514) >> 16) | ((_DWORD)v450 << 16);
  v635 = HIDWORD(v513);
  v523 = v522 ^ (v521 + HIDWORD(v513));
  LODWORD(v72) = v72
               ^ ((v535 + __PAIR64__(v533, HIDWORD(v520) ^ *(_DWORD *)v554) + __PAIR64__(v450, HIDWORD(v513))) >> 32);
  v636 = v450;
  v630 = v535 + __PAIR64__(v533, HIDWORD(v520) ^ *(_DWORD *)v554) + __PAIR64__(v450, HIDWORD(v513));
  LODWORD(v625) = (2 * v523) | ((unsigned int)v72 >> 31);
  HIDWORD(v625) = (2 * v72) | (v523 >> 31);
  v524 = v519;
  v525 = v551;
  v526 = &v622;
  v527 = v546;
  while ( 1 )
  {
    v529 = v525[2];
    v525 += 2;
    v530 = v525[1];
    result = v529 ^ v524 ^ v527;
    *v525 = result;
    v525[1] = v530 ^ v518 ^ HIDWORD(v527);
    if ( v525 == v552 )
      break;
    v528 = *v526++;
    v527 = v528;
    v524 = *((_DWORD *)v526 + 14);
    v518 = *((_DWORD *)v526 + 15);
  }
  return result;
}

//----- (00082590) --------------------------------------------------------
void *__fastcall sub_82590(int a1, unsigned __int64 *src, size_t n)
{
  int v4; // r0
  int v5; // r11
  size_t v6; // r10
  unsigned __int64 *v7; // r5
  size_t v8; // r3
  void *v9; // r0
  void *result; // r0
  __int64 v11; // r8
  bool v12; // cc
  __int64 v13; // r2
  int v14; // r12
  unsigned __int64 *v15; // r1
  __int64 v16; // r2
  __int64 v17; // r6
  bool v18; // cc
  int v19; // r0
  size_t v20; // [sp+0h] [bp-Ch]
  unsigned __int64 *v21; // [sp+0h] [bp-Ch]

  v4 = *(_DWORD *)(a1 + 224);
  v5 = a1 + 96;
  v6 = n;
  v7 = src;
  v8 = 128 - v4;
  v9 = (void *)(a1 + 96 + v4);
  if ( v8 < n )
  {
    v20 = v8;
    *(_DWORD *)(a1 + 224) = 0;
    memcpy(v9, src, v8);
    v11 = *(_QWORD *)(a1 + 64) + 128LL;
    v12 = HIDWORD(v11) != 0;
    v6 -= v20;
    v7 = (unsigned __int64 *)((char *)v7 + v20);
    v13 = *(_QWORD *)(a1 + 72);
    if ( !HIDWORD(v11) )
      v12 = (unsigned int)v11 > 0x7F;
    *(_QWORD *)(a1 + 64) = v11;
    v14 = !v12;
    *(_QWORD *)(a1 + 72) = v13 + (unsigned int)v14;
    sub_7D7F8((_DWORD *)a1, (unsigned __int64 *)(a1 + 96));
    if ( v6 <= 0x80 )
    {
      v9 = (void *)(v5 + *(_DWORD *)(a1 + 224));
    }
    else
    {
      v21 = &v7[16 * ((v6 - 129) >> 7) + 16];
      do
      {
        v15 = v7;
        v7 += 16;
        v16 = *(_QWORD *)(a1 + 72);
        v17 = *(_QWORD *)(a1 + 64) + 128LL;
        v18 = HIDWORD(v17) != 0;
        *(_QWORD *)(a1 + 64) = v17;
        if ( !HIDWORD(v17) )
          v18 = (unsigned int)v17 > 0x7F;
        v19 = !v18;
        *(_QWORD *)(a1 + 72) = v16 + (unsigned int)v19;
        sub_7D7F8((_DWORD *)a1, v15);
      }
      while ( v21 != v7 );
      v6 = v6 - 128 - ((v6 - 129) >> 7 << 7);
      v9 = (void *)(v5 + *(_DWORD *)(a1 + 224));
    }
  }
  result = memcpy(v9, v7, v6);
  *(_DWORD *)(a1 + 224) += v6;
  return result;
}

//----- (000826D8) --------------------------------------------------------
int __fastcall hs_blake2b_init_param(_DWORD *a1, unsigned __int8 *a2)
{
  int *v4; // r3
  __int64 *v5; // r2
  __int64 v6; // r0
  int *v7; // lr
  __int64 v8; // t1
  unsigned __int8 *v9; // r12
  int v10; // r0
  int v11; // r1
  int v12; // t1
  int v13; // r2

  memset(a1, 0, 0xF0u);
  v4 = a1 - 2;
  v5 = (__int64 *)&unk_EC5E8;
  v6 = 0x6A09E667F3BCC908LL;
  v7 = a1 - 2;
  while ( 1 )
  {
    *((_QWORD *)v7 + 1) = v6;
    v7 += 2;
    if ( v7 == a1 + 14 )
      break;
    v8 = *v5++;
    v6 = v8;
  }
  v9 = a2;
  do
  {
    v10 = *(_DWORD *)v9;
    v11 = *((_DWORD *)v9 + 1);
    v9 += 8;
    v12 = v4[2];
    v4 += 2;
    v13 = v4[1];
    *v4 = v12 ^ v10;
    v4[1] = v13 ^ v11;
  }
  while ( v4 != v7 );
  a1[57] = *a2;
  return 0;
}

//----- (0008277C) --------------------------------------------------------
int __fastcall hs_blake2b_init(_DWORD *a1, int a2)
{
  unsigned __int8 v3[4]; // [sp+0h] [bp-48h] BYREF
  int v4; // [sp+4h] [bp-44h]
  int v5; // [sp+8h] [bp-40h]
  int v6; // [sp+Ch] [bp-3Ch]
  char v7; // [sp+10h] [bp-38h]
  char v8; // [sp+11h] [bp-37h]
  int v9; // [sp+12h] [bp-36h]
  int v10; // [sp+16h] [bp-32h]
  int v11; // [sp+1Ah] [bp-2Eh]
  __int16 v12; // [sp+1Eh] [bp-2Ah]
  int v13; // [sp+20h] [bp-28h]
  int v14; // [sp+24h] [bp-24h]
  int v15; // [sp+28h] [bp-20h]
  int v16; // [sp+2Ch] [bp-1Ch]
  int v17; // [sp+30h] [bp-18h]
  int v18; // [sp+34h] [bp-14h]
  int v19; // [sp+38h] [bp-10h]
  int v20; // [sp+3Ch] [bp-Ch]

  if ( (unsigned int)(a2 - 1) > 0x3F )
    return -1;
  v3[0] = a2;
  v3[1] = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v13 = 0;
  v17 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v3[2] = 1;
  v3[3] = 1;
  return hs_blake2b_init_param(a1, v3);
}

//----- (00082804) --------------------------------------------------------
int __fastcall hs_blake2b_init_key(_DWORD *a1, int a2, const void *a3, size_t a4)
{
  unsigned __int8 v9[4]; // [sp+0h] [bp-D8h] BYREF
  int v10; // [sp+4h] [bp-D4h]
  int v11; // [sp+8h] [bp-D0h]
  int v12; // [sp+Ch] [bp-CCh]
  char v13; // [sp+10h] [bp-C8h]
  char v14; // [sp+11h] [bp-C7h]
  int v15; // [sp+12h] [bp-C6h]
  int v16; // [sp+16h] [bp-C2h]
  int v17; // [sp+1Ah] [bp-BEh]
  __int16 v18; // [sp+1Eh] [bp-BAh]
  int v19; // [sp+20h] [bp-B8h]
  int v20; // [sp+24h] [bp-B4h]
  int v21; // [sp+28h] [bp-B0h]
  int v22; // [sp+2Ch] [bp-ACh]
  int v23; // [sp+30h] [bp-A8h]
  int v24; // [sp+34h] [bp-A4h]
  int v25; // [sp+38h] [bp-A0h]
  int v26; // [sp+3Ch] [bp-9Ch]
  unsigned __int64 s[19]; // [sp+40h] [bp-98h] BYREF

  if ( (unsigned int)(a2 - 1) > 0x3F )
    return -1;
  if ( a4 - 1 > 0x3F || a3 == 0 )
    return -1;
  v9[0] = a2;
  v9[1] = a4;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v19 = 0;
  v23 = 0;
  v9[2] = 1;
  v9[3] = 1;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  if ( hs_blake2b_init_param(a1, v9) < 0 )
    return -1;
  memset(s, 0, 0x80u);
  memcpy(s, a3, a4);
  sub_82590((int)a1, s, 0x80u);
  off_107620(s, 0, 0x80u);
  return 0;
}
// 107620: using guessed type void *(*off_107620)(void *s, int c, size_t n);

//----- (00082914) --------------------------------------------------------
int __fastcall hs_blake2b_update(int a1, unsigned __int64 *a2, size_t a3)
{
  if ( a3 )
    sub_82590(a1, a2, a3);
  return 0;
}

//----- (00082934) --------------------------------------------------------
int __fastcall hs_blake2b_final(int a1, void *a2, unsigned int a3)
{
  __int64 v6; // r0
  unsigned int v7; // r2
  int v8; // r12
  __int64 v9; // r6
  bool v10; // cf
  __int64 v11; // r0
  int v12; // r2
  _QWORD *v13; // r3
  __int64 v14; // t1
  _BYTE s[68]; // [sp+8h] [bp-44h] BYREF

  memset(s, 0, 0x40u);
  if ( !a2 || *(_DWORD *)(a1 + 228) > a3 || *(_QWORD *)(a1 + 80) )
    return -1;
  v6 = *(_QWORD *)(a1 + 64);
  v7 = *(_DWORD *)(a1 + 224);
  v8 = *(unsigned __int8 *)(a1 + 232);
  v9 = v6 + v7;
  v10 = __CFADD__(HIDWORD(v6), HIDWORD(v9));
  v11 = *(_QWORD *)(a1 + 72);
  *(_QWORD *)(a1 + 64) = v9;
  *(_QWORD *)(a1 + 72) = v11 + v10;
  if ( v8 )
    *(_QWORD *)(a1 + 88) = -1;
  *(_QWORD *)(a1 + 80) = -1;
  memset((void *)(a1 + 96 + v7), 0, 128 - v7);
  sub_7D7F8((_DWORD *)a1, (unsigned __int64 *)(a1 + 96));
  v12 = a1 - 8;
  v13 = s;
  do
  {
    v14 = *(_QWORD *)(v12 + 8);
    v12 += 8;
    *v13++ = v14;
  }
  while ( v12 != a1 + 56 );
  memcpy(a2, s, *(_DWORD *)(a1 + 228));
  off_107620(s, 0, 0x40u);
  return 0;
}
// 107620: using guessed type void *(*off_107620)(void *s, int c, size_t n);

//----- (00082A5C) --------------------------------------------------------
int __fastcall hs_blake2b(void *a1, unsigned int a2, unsigned __int64 *a3, size_t a4, const void *a5, size_t a6)
{
  size_t v6; // r12
  size_t v7; // lr
  bool v9; // cc
  _DWORD v14[61]; // [sp+0h] [bp-F4h] BYREF

  v6 = a4;
  if ( a4 )
    v6 = 1;
  if ( a3 )
    v6 = 0;
  if ( !a1 )
    v6 = 1;
  if ( v6 )
    return -1;
  v7 = a6;
  if ( a6 )
    v7 = 1;
  if ( a5 )
    v7 = 0;
  if ( v7 )
    return -1;
  v9 = a6 > 0x40;
  if ( a6 <= 0x40 )
    v9 = a2 - 1 > 0x3F;
  if ( v9 )
    return -1;
  if ( a6 )
  {
    if ( hs_blake2b_init_key(v14, a2, a5, a6) >= 0 )
      goto LABEL_18;
    return -1;
  }
  if ( hs_blake2b_init(v14, a2) < 0 )
    return -1;
LABEL_18:
  if ( a4 )
    sub_82590((int)v14, a3, a4);
  hs_blake2b_final((int)v14, a1, a2);
  return 0;
}

//----- (00082B38) --------------------------------------------------------
int __fastcall target_to_diff(int a1, int a2)
{
  int v2; // r12
  int result; // r0
  int v4; // r1
  int v5; // r2
  int v6; // t1
  int v7; // r3

  if ( a2 <= 0 )
    return 0;
  v2 = a1 - 1;
  result = 0;
  v4 = v2 + a2;
LABEL_3:
  v6 = *(unsigned __int8 *)++v2;
  v5 = v6;
  v7 = 7;
  while ( v5 >> v7-- == 0 )
  {
    ++result;
    if ( v7 == -1 )
    {
      if ( v2 != v4 )
        goto LABEL_3;
      return result;
    }
  }
  return result;
}

//----- (00082B84) --------------------------------------------------------
int __fastcall hns_hash(int a1, void *a2)
{
  int v4; // r2
  _BYTE *v5; // r3
  unsigned int v6; // r1
  char v7; // t1
  int v8; // r2
  _BYTE *v9; // r3
  char v10; // t1
  char *v11; // r3
  int v12; // r2
  char v13; // t1
  int v14; // r8
  int v15; // r1
  int v16; // r2
  _DWORD *v17; // r12
  __int16 v18; // r9
  int v19; // r3
  _BYTE *v20; // lr
  char v21; // r10
  char v22; // t1
  int v23; // r2
  _BYTE *v24; // r3
  char v25; // t1
  int v26; // r2
  _BYTE *v27; // r3
  char v28; // t1
  int v29; // r2
  _BYTE *v30; // r3
  char v31; // t1
  int v32; // r2
  _BYTE *v33; // r3
  char v34; // t1
  unsigned int v35; // r2
  unsigned int v36; // r3
  _DWORD v38[4]; // [sp+0h] [bp-120h] BYREF
  char v39; // [sp+10h] [bp-110h]
  char v40; // [sp+11h] [bp-10Fh]
  int v41; // [sp+12h] [bp-10Eh]
  __int16 v42; // [sp+16h] [bp-10Ah]
  _DWORD v43[3]; // [sp+18h] [bp-108h] BYREF
  int v44; // [sp+24h] [bp-FCh] BYREF
  _BYTE v45[32]; // [sp+3Bh] [bp-E5h] BYREF
  _BYTE v46[32]; // [sp+5Bh] [bp-C5h] BYREF
  _BYTE v47[32]; // [sp+7Bh] [bp-A5h] BYREF
  _BYTE v48[24]; // [sp+9Bh] [bp-85h] BYREF
  char v49; // [sp+B3h] [bp-6Dh] BYREF
  _BYTE v50[32]; // [sp+D3h] [bp-4Dh] BYREF
  _BYTE v51[29]; // [sp+F3h] [bp-2Dh] BYREF
  _BYTE v52[5]; // [sp+113h] [bp-Dh] BYREF
  unsigned int v53; // [sp+118h] [bp-8h]

  hs_header_init((int)v43);
  v4 = a1 + 40;
  v5 = v51;
  v6 = bswap32(*(_DWORD *)(a1 + 4));
  v53 = bswap32(*(_DWORD *)a1);
  *(_DWORD *)&v52[1] = v6;
  do
  {
    v7 = *(_BYTE *)--v4;
    *++v5 = v7;
  }
  while ( v52 != v5 );
  v8 = a1 + 72;
  v9 = v50;
  do
  {
    v10 = *(_BYTE *)--v8;
    *++v9 = v10;
  }
  while ( v9 != v51 );
  v11 = &v49;
  v12 = a1 + 104;
  do
  {
    v13 = *(_BYTE *)--v12;
    *++v11 = v13;
  }
  while ( v50 != v11 );
  v14 = *(_DWORD *)(a1 + 120);
  v15 = *(_DWORD *)(a1 + 108);
  v16 = *(_DWORD *)(a1 + 112);
  v17 = v43;
  v18 = *(_WORD *)(a1 + 124);
  v19 = *(_DWORD *)(a1 + 116);
  v20 = v48;
  v21 = *(_BYTE *)(a1 + 250);
  v38[0] = *(_DWORD *)(a1 + 104);
  v38[1] = v15;
  v38[2] = v16;
  v38[3] = v19;
  LOBYTE(v19) = *(_BYTE *)(a1 + 251);
  v42 = v18;
  v41 = v14;
  v39 = v21;
  v40 = v19;
  do
  {
    v22 = *((_BYTE *)v17 - 1);
    v17 = (_DWORD *)((char *)v17 - 1);
    *++v20 = v22;
  }
  while ( v38 != v17 );
  v23 = a1 + 158;
  v24 = v47;
  do
  {
    v25 = *(_BYTE *)--v23;
    *++v24 = v25;
  }
  while ( v48 != v24 );
  v26 = a1 + 190;
  v27 = v46;
  do
  {
    v28 = *(_BYTE *)--v26;
    *++v27 = v28;
  }
  while ( v27 != v47 );
  v29 = a1 + 222;
  v30 = v45;
  do
  {
    v31 = *(_BYTE *)--v29;
    *++v30 = v31;
  }
  while ( v30 != v46 );
  v32 = a1 + 242;
  v33 = (char *)&v44 + 3;
  do
  {
    v34 = *(_BYTE *)--v32;
    *++v33 = v34;
  }
  while ( v45 != v33 );
  v35 = *(_DWORD *)(a1 + 246);
  v36 = *(_DWORD *)(a1 + 252);
  v44 = 0;
  v43[2] = bswap32(v35);
  v43[0] = bswap32(v36);
  return hs_header_pow(v43, a2);
}

//----- (00082D0C) --------------------------------------------------------
int __fastcall sub_82D0C(const void **a1, _DWORD *a2, void *dest, size_t n)
{
  size_t v8; // r3

  memcpy(dest, *a1, n);
  v8 = *a2 - n;
  *a1 = (char *)*a1 + n;
  *a2 = v8;
  return 1;
}

//----- (00082D4C) --------------------------------------------------------
void *__fastcall sub_82D4C(int a1)
{
  void *result; // r0

  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  memset((void *)(a1 + 36), 0, 0x20u);
  memset((void *)(a1 + 68), 0, 0x20u);
  memset((void *)(a1 + 100), 0, 0x20u);
  *(_DWORD *)(a1 + 132) = 0;
  *(_DWORD *)(a1 + 136) = 0;
  *(_DWORD *)(a1 + 140) = 0;
  *(_DWORD *)(a1 + 144) = 0;
  *(_DWORD *)(a1 + 148) = 0;
  *(_DWORD *)(a1 + 152) = 0;
  memset((void *)(a1 + 156), 0, 0x20u);
  memset((void *)(a1 + 188), 0, 0x20u);
  result = memset((void *)(a1 + 220), 0, 0x20u);
  *(_DWORD *)(a1 + 252) = 0;
  *(_DWORD *)(a1 + 256) = 0;
  return result;
}

//----- (00082E04) --------------------------------------------------------
int __fastcall hs_header_init(int a1)
{
  if ( a1 )
    return (int)sub_82D4C(a1);
  return a1;
}

//----- (00082E10) --------------------------------------------------------
void *hs_header_alloc()
{
  void *v0; // r0
  void *v1; // r4

  v0 = malloc(0x108u);
  v1 = v0;
  if ( v0 )
    sub_82D4C((int)v0);
  return v1;
}

//----- (00082E30) --------------------------------------------------------
int __fastcall hs_header_read(const void **a1, _DWORD *a2, _DWORD *a3)
{
  int result; // r0
  unsigned int v4; // lr
  int *v5; // r4
  int v6; // r5
  unsigned int v7; // r4
  _DWORD *v8; // lr
  int v9; // r8
  int v10; // r7
  int v11; // r6
  unsigned int v12; // r4
  _DWORD *v13; // lr
  int v14; // r7
  int v15; // r6
  int v16; // r5
  int v17; // r7
  int v18; // r6
  int v19; // r5
  unsigned int v20; // lr
  _DWORD *v24; // r2
  unsigned int v25; // r3
  int v26; // r3

  if ( *a2 <= 3u )
    return 0;
  *a3 = *(_DWORD *)*a1;
  v4 = *a2 - 4;
  v5 = (int *)((char *)*a1 + 4);
  *a1 = v5;
  *a2 = v4;
  if ( v4 <= 7 )
    return 0;
  v6 = *v5;
  a3[3] = v5[1];
  a3[2] = v6;
  v7 = *a2 - 8;
  v8 = (char *)*a1 + 8;
  *a1 = v8;
  *a2 = v7;
  if ( v7 <= 0x13 )
    return 0;
  v9 = v8[1];
  v10 = v8[2];
  v11 = v8[3];
  a3[4] = *v8;
  a3[5] = v9;
  a3[6] = v10;
  a3[7] = v11;
  a3[8] = v8[4];
  v12 = *a2 - 20;
  v13 = (char *)*a1 + 20;
  *a1 = v13;
  *a2 = v12;
  if ( v12 <= 0x1F )
    return 0;
  v14 = v13[1];
  v15 = v13[2];
  v16 = v13[3];
  a3[9] = *v13;
  a3[10] = v14;
  a3[11] = v15;
  a3[12] = v16;
  v17 = v13[5];
  v18 = v13[6];
  v19 = v13[7];
  a3[13] = v13[4];
  a3[14] = v17;
  a3[15] = v18;
  a3[16] = v19;
  v20 = *a2 - 32;
  *a1 = (char *)*a1 + 32;
  *a2 = v20;
  if ( v20 <= 0x1F )
    return 0;
  if ( !sub_82D0C(a1, a2, a3 + 17, 0x20u) )
    return 0;
  if ( *a2 <= 0x1Fu )
    return 0;
  if ( !sub_82D0C(a1, a2, a3 + 25, 0x20u) )
    return 0;
  if ( *a2 <= 0x17u )
    return 0;
  if ( !sub_82D0C(a1, a2, a3 + 33, 0x18u) )
    return 0;
  if ( *a2 <= 0x1Fu )
    return 0;
  if ( !sub_82D0C(a1, a2, a3 + 39, 0x20u) )
    return 0;
  if ( *a2 <= 0x1Fu )
    return 0;
  if ( !sub_82D0C(a1, a2, a3 + 47, 0x20u) )
    return 0;
  if ( *a2 <= 0x1Fu )
    return 0;
  result = sub_82D0C(a1, a2, a3 + 55, 0x20u);
  if ( !result )
    return 0;
  if ( *a2 <= 3u )
    return 0;
  a3[63] = *(_DWORD *)*a1;
  v24 = *a1;
  v25 = *a2 - 4;
  *a1 = (char *)*a1 + 4;
  *a2 = v25;
  if ( v25 <= 3 )
    return 0;
  a3[64] = v24[1];
  v26 = *a2 - 4;
  *a1 = (char *)*a1 + 4;
  *a2 = v26;
  return result;
}

//----- (00083090) --------------------------------------------------------
int __fastcall hs_header_decode(const void *a1, int a2, _DWORD *a3)
{
  int v4; // [sp+0h] [bp-Ch] BYREF
  const void *v5; // [sp+4h] [bp-8h] BYREF

  v5 = a1;
  v4 = a2;
  return hs_header_read(&v5, &v4, a3);
}

//----- (000830B8) --------------------------------------------------------
int __fastcall hs_header_write(int a1, int *a2)
{
  _DWORD *v3; // r1
  _DWORD *v5; // r5
  __int64 v6; // r0
  int v7; // r4
  _DWORD *v8; // lr
  int v9; // r1
  int v10; // r6
  int v11; // r5
  int v12; // r4
  _DWORD *v13; // r7
  int v14; // r1
  int v15; // r5
  int v16; // r4
  int v17; // lr
  int v18; // r5
  int v19; // r4
  int v20; // lr
  _DWORD *v21; // r6
  int v22; // r1
  int v23; // r4
  int v24; // lr
  int v25; // r0
  int v26; // r4
  int v27; // lr
  int v28; // r0
  _DWORD *v29; // r7
  int v30; // r1
  int v31; // r5
  int v32; // r4
  int v33; // lr
  int v34; // r4
  int v35; // r5
  int v36; // lr
  _DWORD *v37; // r4
  int v38; // r1
  int v39; // r0
  int v40; // r6
  int v41; // r5
  int v42; // r0
  _DWORD *v43; // r7
  int v44; // r1
  int v45; // r5
  int v46; // r4
  int v47; // lr
  int v48; // r5
  int v49; // r4
  int v50; // lr
  _DWORD *v51; // r6
  int v52; // r1
  int v53; // r4
  int v54; // lr
  int v55; // r0
  int v56; // r4
  int v57; // lr
  int v58; // r0
  _DWORD *v59; // r6
  int v60; // r1
  int v61; // r4
  int v62; // lr
  int v63; // r12
  int v64; // r12
  int v65; // r4
  int v66; // lr
  _DWORD *v67; // r1
  int v68; // r12
  int v69; // r0
  _DWORD *v70; // r1
  int v71; // r0

  if ( !a2 )
    return 256;
  v3 = (_DWORD *)*a2;
  if ( !*a2 )
    return 256;
  *v3 = *(_DWORD *)a1;
  v5 = (_DWORD *)*a2;
  v6 = *(_QWORD *)(a1 + 8);
  v7 = *a2 + 4;
  *a2 = v7;
  if ( v7 )
  {
    *(_QWORD *)(v5 + 1) = v6;
    v8 = (_DWORD *)*a2;
    v9 = *a2 + 8;
    *a2 = v9;
    if ( v9 )
    {
      v10 = *(_DWORD *)(a1 + 20);
      v11 = *(_DWORD *)(a1 + 24);
      v12 = *(_DWORD *)(a1 + 28);
      v8[2] = *(_DWORD *)(a1 + 16);
      v8[3] = v10;
      v8[4] = v11;
      v8[5] = v12;
      v8[6] = *(_DWORD *)(a1 + 32);
      v13 = (_DWORD *)*a2;
      v14 = *a2 + 20;
      *a2 = v14;
      if ( v14 )
      {
        v15 = *(_DWORD *)(a1 + 40);
        v16 = *(_DWORD *)(a1 + 44);
        v17 = *(_DWORD *)(a1 + 48);
        v13[5] = *(_DWORD *)(a1 + 36);
        v13[6] = v15;
        v13[7] = v16;
        v13[8] = v17;
        v18 = *(_DWORD *)(a1 + 56);
        v19 = *(_DWORD *)(a1 + 60);
        v20 = *(_DWORD *)(a1 + 64);
        v13[9] = *(_DWORD *)(a1 + 52);
        v13[10] = v18;
        v13[11] = v19;
        v13[12] = v20;
        v21 = (_DWORD *)*a2;
        v22 = *a2 + 32;
        *a2 = v22;
        if ( v22 )
        {
          v23 = *(_DWORD *)(a1 + 72);
          v24 = *(_DWORD *)(a1 + 76);
          v25 = *(_DWORD *)(a1 + 80);
          v21[8] = *(_DWORD *)(a1 + 68);
          v21[9] = v23;
          v21[10] = v24;
          v21[11] = v25;
          v26 = *(_DWORD *)(a1 + 88);
          v27 = *(_DWORD *)(a1 + 92);
          v28 = *(_DWORD *)(a1 + 96);
          v21[12] = *(_DWORD *)(a1 + 84);
          v21[13] = v26;
          v21[14] = v27;
          v21[15] = v28;
          v29 = (_DWORD *)*a2;
          v30 = *a2 + 32;
          *a2 = v30;
          if ( v30 )
          {
            v31 = *(_DWORD *)(a1 + 104);
            v32 = *(_DWORD *)(a1 + 108);
            v33 = *(_DWORD *)(a1 + 112);
            v29[8] = *(_DWORD *)(a1 + 100);
            v29[9] = v31;
            v29[10] = v32;
            v29[11] = v33;
            v34 = *(_DWORD *)(a1 + 124);
            v35 = *(_DWORD *)(a1 + 120);
            v36 = *(_DWORD *)(a1 + 128);
            v29[12] = *(_DWORD *)(a1 + 116);
            v29[13] = v35;
            v29[14] = v34;
            v29[15] = v36;
            v37 = (_DWORD *)*a2;
            v38 = *a2 + 32;
            *a2 = v38;
            if ( v38 )
            {
              v39 = *(_DWORD *)(a1 + 136);
              v40 = *(_DWORD *)(a1 + 140);
              v41 = *(_DWORD *)(a1 + 144);
              v37[8] = *(_DWORD *)(a1 + 132);
              v37[9] = v39;
              v37[10] = v40;
              v37[11] = v41;
              v42 = *(_DWORD *)(a1 + 152);
              v37[12] = *(_DWORD *)(a1 + 148);
              v37[13] = v42;
              v43 = (_DWORD *)*a2;
              v44 = *a2 + 24;
              *a2 = v44;
              if ( v44 )
              {
                v45 = *(_DWORD *)(a1 + 160);
                v46 = *(_DWORD *)(a1 + 164);
                v47 = *(_DWORD *)(a1 + 168);
                v43[6] = *(_DWORD *)(a1 + 156);
                v43[7] = v45;
                v43[8] = v46;
                v43[9] = v47;
                v48 = *(_DWORD *)(a1 + 176);
                v49 = *(_DWORD *)(a1 + 180);
                v50 = *(_DWORD *)(a1 + 184);
                v43[10] = *(_DWORD *)(a1 + 172);
                v43[11] = v48;
                v43[12] = v49;
                v43[13] = v50;
                v51 = (_DWORD *)*a2;
                v52 = *a2 + 32;
                *a2 = v52;
                if ( v52 )
                {
                  v53 = *(_DWORD *)(a1 + 192);
                  v54 = *(_DWORD *)(a1 + 196);
                  v55 = *(_DWORD *)(a1 + 200);
                  v51[8] = *(_DWORD *)(a1 + 188);
                  v51[9] = v53;
                  v51[10] = v54;
                  v51[11] = v55;
                  v56 = *(_DWORD *)(a1 + 208);
                  v57 = *(_DWORD *)(a1 + 212);
                  v58 = *(_DWORD *)(a1 + 216);
                  v51[12] = *(_DWORD *)(a1 + 204);
                  v51[13] = v56;
                  v51[14] = v57;
                  v51[15] = v58;
                  v59 = (_DWORD *)*a2;
                  v60 = *a2 + 32;
                  *a2 = v60;
                  if ( v60 )
                  {
                    v61 = *(_DWORD *)(a1 + 224);
                    v62 = *(_DWORD *)(a1 + 228);
                    v63 = *(_DWORD *)(a1 + 232);
                    v59[8] = *(_DWORD *)(a1 + 220);
                    v59[9] = v61;
                    v59[10] = v62;
                    v59[11] = v63;
                    v64 = *(_DWORD *)(a1 + 248);
                    v65 = *(_DWORD *)(a1 + 240);
                    v66 = *(_DWORD *)(a1 + 244);
                    v59[12] = *(_DWORD *)(a1 + 236);
                    v59[13] = v65;
                    v59[14] = v66;
                    v59[15] = v64;
                    v67 = (_DWORD *)*a2;
                    v68 = *(_DWORD *)(a1 + 252);
                    v69 = *a2 + 32;
                    *a2 = v69;
                    if ( v69 )
                    {
                      v67[8] = v68;
                      v70 = (_DWORD *)*a2;
                      v71 = *a2 + 4;
                      *a2 = v71;
                      if ( v71 )
                      {
                        v70[1] = *(_DWORD *)(a1 + 256);
                        *a2 += 4;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return 256;
}

//----- (000833E8) --------------------------------------------------------
int hs_header_size()
{
  return 256;
}

//----- (000833F0) --------------------------------------------------------
int __fastcall QImagePixmapCleanupHooks::removeImageHook(
        QImagePixmapCleanupHooks *this,
        void (__fastcall *a2)(__int64))
{
  void (__fastcall *v3)(__int64); // [sp+4h] [bp-8h] BYREF

  v3 = a2;
  return hs_header_write((int)this, (int *)&v3);
}

//----- (00083410) --------------------------------------------------------
int __fastcall hs_header_pre_write(int a1, int *a2)
{
  int v4; // r0
  int v5; // r1
  char *v6; // r2
  char v7; // r3
  char v8; // t1
  char v9; // t1
  _DWORD *v10; // lr
  __int64 v11; // r2
  int v12; // r12
  _DWORD *v13; // r6
  int v14; // lr
  int v15; // r1
  int v16; // r2
  int v17; // r3
  int v18; // r0
  _DWORD *v19; // r7
  int v20; // r3
  int v21; // lr
  int v22; // r12
  int v23; // r0
  int v24; // lr
  int v25; // r12
  int v26; // r0
  _DWORD *v27; // r6
  int v28; // r3
  int v29; // r12
  int v30; // r0
  int v31; // r2
  int v32; // r12
  int v33; // r0
  int v34; // r2
  _DWORD *v35; // lr
  int v36; // r3
  _DWORD *v37; // r4
  int v38; // t1
  int v39; // r0
  int v40; // r1
  int v41; // r2
  int v42; // r0
  int v43; // r1
  int v44; // r2
  char v46; // [sp+Bh] [bp-19h] BYREF
  int v47; // [sp+Ch] [bp-18h]
  int v48; // [sp+10h] [bp-14h]
  int v49; // [sp+14h] [bp-10h]
  int v50; // [sp+18h] [bp-Ch]
  int v51; // [sp+1Ch] [bp-8h] BYREF

  v4 = a1 + 35;
  v5 = a1 + 67;
  v6 = &v46;
  do
  {
    v8 = *(_BYTE *)++v4;
    v7 = v8;
    v9 = *(_BYTE *)++v5;
    *++v6 = v7 ^ v9;
  }
  while ( v6 != (char *)&v51 + 3 );
  if ( a2 )
  {
    if ( *a2 )
    {
      *(_DWORD *)*a2 = *(_DWORD *)a1;
      v10 = (_DWORD *)*a2;
      v11 = *(_QWORD *)(a1 + 8);
      v12 = *a2 + 4;
      *a2 = v12;
      if ( v12 )
      {
        *(_QWORD *)(v10 + 1) = v11;
        v13 = (_DWORD *)*a2;
        v14 = *a2 + 8;
        *a2 = v14;
        if ( v14 )
        {
          v15 = v48;
          v16 = v49;
          v17 = v50;
          v13[2] = v47;
          v18 = v51;
          v13[5] = v17;
          v13[3] = v15;
          v13[4] = v16;
          v13[6] = v18;
          v19 = (_DWORD *)*a2;
          v20 = *a2 + 20;
          *a2 = v20;
          if ( v20 )
          {
            v21 = *(_DWORD *)(a1 + 40);
            v22 = *(_DWORD *)(a1 + 44);
            v23 = *(_DWORD *)(a1 + 48);
            v19[5] = *(_DWORD *)(a1 + 36);
            v19[6] = v21;
            v19[7] = v22;
            v19[8] = v23;
            v24 = *(_DWORD *)(a1 + 56);
            v25 = *(_DWORD *)(a1 + 60);
            v26 = *(_DWORD *)(a1 + 64);
            v19[9] = *(_DWORD *)(a1 + 52);
            v19[10] = v24;
            v19[11] = v25;
            v19[12] = v26;
            v27 = (_DWORD *)*a2;
            v28 = *a2 + 32;
            *a2 = v28;
            if ( v28 )
            {
              v29 = *(_DWORD *)(a1 + 72);
              v30 = *(_DWORD *)(a1 + 76);
              v31 = *(_DWORD *)(a1 + 80);
              v27[8] = *(_DWORD *)(a1 + 68);
              v27[9] = v29;
              v27[10] = v30;
              v27[11] = v31;
              v32 = *(_DWORD *)(a1 + 88);
              v33 = *(_DWORD *)(a1 + 92);
              v34 = *(_DWORD *)(a1 + 96);
              v27[12] = *(_DWORD *)(a1 + 84);
              v27[13] = v32;
              v27[14] = v33;
              v27[15] = v34;
              v35 = (_DWORD *)*a2;
              v36 = *a2 + 32;
              *a2 = v36;
              if ( v36 )
              {
                v38 = *(_DWORD *)(a1 + 100);
                v37 = (_DWORD *)(a1 + 100);
                v39 = v37[1];
                v40 = v37[2];
                v41 = v37[3];
                v35[8] = v38;
                v35[9] = v39;
                v35[10] = v40;
                v35[11] = v41;
                v42 = v37[5];
                v43 = v37[6];
                v44 = v37[7];
                v35[12] = v37[4];
                v35[13] = v42;
                v35[14] = v43;
                v35[15] = v44;
                *a2 += 32;
              }
            }
          }
        }
      }
    }
  }
  return 128;
}

//----- (000835DC) --------------------------------------------------------
int __fastcall hs_header_pre_size(int a1)
{
  return hs_header_pre_write(a1, 0);
}

//----- (000835E4) --------------------------------------------------------
int __fastcall hs_header_pre_encode(int a1, int a2)
{
  int v3; // [sp+4h] [bp-8h] BYREF

  v3 = a2;
  return hs_header_pre_write(a1, &v3);
}

//----- (00083604) --------------------------------------------------------
int __fastcall hs_header_sub_write(_DWORD *a1, int *a2)
{
  _DWORD *v2; // r3
  int v3; // lr
  int v4; // r6
  int v5; // r5
  int v6; // lr
  _DWORD *v7; // r6
  int v8; // r3
  int v9; // r4
  int v10; // lr
  int v11; // r12
  int v12; // r4
  int v13; // lr
  int v14; // r12
  _DWORD *v15; // r7
  int v16; // r3
  int v17; // r5
  int v18; // r4
  int v19; // lr
  int v20; // r5
  int v21; // r4
  int v22; // lr
  _DWORD *v23; // r6
  int v24; // r3
  int v25; // r4
  int v26; // lr
  int v27; // r2
  int v28; // r5
  int v29; // r4
  int v30; // lr
  _DWORD *v31; // r3
  int v32; // r2
  _DWORD *v33; // r3
  int v34; // r0
  int v35; // r2

  if ( !a2 )
    return 128;
  v2 = (_DWORD *)*a2;
  if ( !*a2 )
    return 128;
  v3 = a1[34];
  v4 = a1[35];
  v5 = a1[36];
  *v2 = a1[33];
  v2[1] = v3;
  v2[2] = v4;
  v2[3] = v5;
  v6 = a1[38];
  v2[4] = a1[37];
  v2[5] = v6;
  v7 = (_DWORD *)*a2;
  v8 = *a2 + 24;
  *a2 = v8;
  if ( v8 )
  {
    v9 = a1[40];
    v10 = a1[41];
    v11 = a1[42];
    v7[6] = a1[39];
    v7[7] = v9;
    v7[8] = v10;
    v7[9] = v11;
    v12 = a1[44];
    v13 = a1[45];
    v14 = a1[46];
    v7[10] = a1[43];
    v7[11] = v12;
    v7[12] = v13;
    v7[13] = v14;
    v15 = (_DWORD *)*a2;
    v16 = *a2 + 32;
    *a2 = v16;
    if ( v16 )
    {
      v17 = a1[48];
      v18 = a1[49];
      v19 = a1[50];
      v15[8] = a1[47];
      v15[9] = v17;
      v15[10] = v18;
      v15[11] = v19;
      v20 = a1[52];
      v21 = a1[53];
      v22 = a1[54];
      v15[12] = a1[51];
      v15[13] = v20;
      v15[14] = v21;
      v15[15] = v22;
      v23 = (_DWORD *)*a2;
      v24 = *a2 + 32;
      *a2 = v24;
      if ( v24 )
      {
        v25 = a1[56];
        v26 = a1[57];
        v27 = a1[58];
        v23[8] = a1[55];
        v23[9] = v25;
        v23[10] = v26;
        v23[11] = v27;
        v28 = a1[59];
        v29 = a1[60];
        v30 = a1[61];
        v23[15] = a1[62];
        v23[12] = v28;
        v23[13] = v29;
        v23[14] = v30;
        v31 = (_DWORD *)*a2;
        v32 = *a2 + 32;
        *a2 = v32;
        if ( v32 )
        {
          v31[8] = a1[63];
          v33 = (_DWORD *)*a2;
          v34 = a1[64];
          v35 = *a2 + 4;
          *a2 = v35;
          if ( v35 )
          {
            v33[1] = v34;
            *a2 += 4;
          }
        }
      }
    }
  }
  return 128;
}

//----- (000837A0) --------------------------------------------------------
int __fastcall hs_header_share_write(int a1, int *a2)
{
  _DWORD *v4; // lr
  __int64 v5; // r2
  int v6; // r12
  int v7; // r1
  _DWORD *v8; // r0
  int v9; // r3
  int v10; // r6
  int v11; // lr
  int v12; // r12
  _DWORD *v13; // r6
  int v14; // r3
  _DWORD *v15; // r2
  int v16; // lr
  int v17; // r12
  int v18; // r1
  int v19; // lr
  int v20; // r12
  int v21; // r1
  _DWORD *v22; // r4
  int v23; // r3
  int v24; // r12
  int v25; // r0
  int v26; // r1
  int v27; // r12
  int v28; // r0
  int v29; // r1
  _DWORD *v30; // r4
  int v31; // lr
  int v32; // r1
  int v33; // r2
  int v34; // r3
  int v35; // r1
  int v36; // r2
  int v37; // r3
  unsigned __int64 *v39; // [sp+4h] [bp-1BCh] BYREF
  __int64 v40; // [sp+8h] [bp-1B8h]
  unsigned __int64 v41[4]; // [sp+10h] [bp-1B0h] BYREF
  _DWORD v42[8]; // [sp+30h] [bp-190h] BYREF
  unsigned __int64 v43[16]; // [sp+50h] [bp-170h] BYREF
  _DWORD v44[60]; // [sp+D0h] [bp-F0h] BYREF

  v39 = v43;
  hs_header_sub_write((_DWORD *)a1, (int *)&v39);
  hs_blake2b_init(v44, 32);
  hs_blake2b_update((int)v44, v43, 0x80u);
  hs_blake2b_final((int)v44, v41, 0x20u);
  hs_blake2b_init(v44, 32);
  hs_blake2b_update((int)v44, v41, 0x20u);
  hs_blake2b_update((int)v44, (unsigned __int64 *)(a1 + 100), 0x20u);
  hs_blake2b_final((int)v44, v42, 0x20u);
  if ( a2 )
  {
    if ( *a2 )
    {
      *(_DWORD *)*a2 = *(_DWORD *)a1;
      v4 = (_DWORD *)*a2;
      v5 = *(_QWORD *)(a1 + 8);
      v6 = *a2 + 4;
      *a2 = v6;
      v40 = v5;
      if ( v6 )
      {
        v7 = HIDWORD(v40);
        v4[1] = v40;
        v4[2] = v7;
        v8 = (_DWORD *)*a2;
        v9 = *a2 + 8;
        *a2 = v9;
        if ( v9 )
        {
          v10 = *(_DWORD *)(a1 + 20);
          v11 = *(_DWORD *)(a1 + 24);
          v12 = *(_DWORD *)(a1 + 28);
          v8[2] = *(_DWORD *)(a1 + 16);
          v8[3] = v10;
          v8[4] = v11;
          v8[5] = v12;
          v8[6] = *(_DWORD *)(a1 + 32);
          v13 = (_DWORD *)*a2;
          v14 = *a2 + 20;
          *a2 = v14;
          if ( v14 )
          {
            v15 = (_DWORD *)(a1 + 68);
            v16 = *(_DWORD *)(a1 + 40);
            v17 = *(_DWORD *)(a1 + 44);
            v18 = *(_DWORD *)(a1 + 48);
            v13[5] = *(_DWORD *)(a1 + 36);
            v13[6] = v16;
            v13[7] = v17;
            v13[8] = v18;
            v19 = *(_DWORD *)(a1 + 56);
            v20 = *(_DWORD *)(a1 + 60);
            v21 = *(_DWORD *)(a1 + 64);
            v13[9] = *(_DWORD *)(a1 + 52);
            v13[10] = v19;
            v13[11] = v20;
            v13[12] = v21;
            v22 = (_DWORD *)*a2;
            v23 = *a2 + 32;
            *a2 = v23;
            if ( v23 )
            {
              v24 = v15[1];
              v25 = v15[2];
              v26 = v15[3];
              v22[8] = *v15;
              v22[9] = v24;
              v22[10] = v25;
              v22[11] = v26;
              v27 = v15[5];
              v28 = v15[6];
              v29 = v15[7];
              v22[12] = v15[4];
              v22[13] = v27;
              v22[14] = v28;
              v22[15] = v29;
              v30 = (_DWORD *)*a2;
              v31 = *a2 + 32;
              *a2 = v31;
              if ( v31 )
              {
                v32 = v42[1];
                v33 = v42[2];
                v34 = v42[3];
                v30[8] = v42[0];
                v30[9] = v32;
                v30[10] = v33;
                v30[11] = v34;
                v35 = v42[5];
                v36 = v42[6];
                v37 = v42[7];
                v30[12] = v42[4];
                v30[13] = v35;
                v30[14] = v36;
                v30[15] = v37;
                *a2 += 32;
              }
            }
          }
        }
      }
    }
  }
  return 128;
}

//----- (000839B8) --------------------------------------------------------
int __fastcall hs_header_share_encode(int a1, int a2)
{
  int v3; // [sp+4h] [bp-8h] BYREF

  v3 = a2;
  return hs_header_share_write(a1, &v3);
}

//----- (000839D8) --------------------------------------------------------
int hs_header_sub_size()
{
  return 128;
}

//----- (000839E0) --------------------------------------------------------
int __fastcall hs_header_sub_encode(_DWORD *a1, int a2)
{
  int v3; // [sp+4h] [bp-8h] BYREF

  v3 = a2;
  return hs_header_sub_write(a1, &v3);
}

//----- (00083A00) --------------------------------------------------------
int __fastcall hs_header_sub_hash(_DWORD *a1, void *a2)
{
  unsigned __int64 *v4; // [sp+4h] [bp-178h] BYREF
  unsigned __int64 v5[16]; // [sp+8h] [bp-174h] BYREF
  _DWORD v6[60]; // [sp+88h] [bp-F4h] BYREF

  v4 = v5;
  hs_header_sub_write(a1, (int *)&v4);
  hs_blake2b_init(v6, 32);
  hs_blake2b_update((int)v6, v5, 0x80u);
  return hs_blake2b_final((int)v6, a2, 0x20u);
}

//----- (00083A54) --------------------------------------------------------
int __fastcall hs_header_padding(int result, int a2, int a3)
{
  int v3; // r1
  int i; // r12
  int v5; // r3

  if ( a3 )
  {
    v3 = a2 - 1;
    for ( i = 0; i != a3; ++i )
    {
      v5 = i & 0x1F;
      *(_BYTE *)++v3 = *(_BYTE *)(result + v5 + 68) ^ *(_BYTE *)(result + v5 + 36);
    }
  }
  return result;
}

//----- (00083A90) --------------------------------------------------------
int __fastcall hs_header_share_pow(unsigned __int64 *a1, char *a2, void *a3)
{
  unsigned __int64 v7[4]; // [sp+0h] [bp-3D0h] BYREF
  unsigned __int64 v8[8]; // [sp+20h] [bp-3B0h] BYREF
  _DWORD v9[60]; // [sp+60h] [bp-370h] BYREF
  _DWORD v10[60]; // [sp+150h] [bp-280h] BYREF
  int v11[100]; // [sp+240h] [bp-190h] BYREF

  hs_blake2b_init(v9, 64);
  hs_blake2b_update((int)v9, a1, 0x80u);
  hs_blake2b_final((int)v9, v8, 0x40u);
  hs_sha3_256_init(v11);
  hs_sha3_update(v11, (char *)a1, 0x80u);
  hs_sha3_update(v11, a2, 8u);
  hs_sha3_final(v11, v7);
  hs_blake2b_init(v10, 32);
  hs_blake2b_update((int)v10, v8, 0x40u);
  hs_blake2b_update((int)v10, (unsigned __int64 *)a2, 0x20u);
  hs_blake2b_update((int)v10, v7, 0x20u);
  return hs_blake2b_final((int)v10, a3, 0x20u);
}

//----- (00083B58) --------------------------------------------------------
int __fastcall hs_header_pow(_BYTE *a1, void *a2)
{
  char *v3; // r2
  char *v4; // r12
  char *v5; // r1
  char v6; // r3
  char v7; // t1
  char v8; // t1
  _BYTE *v9; // r12
  char *v10; // r2
  _BYTE *v11; // r1
  char v12; // r3
  char v13; // t1
  char v14; // t1
  unsigned __int64 *v16; // [sp+4h] [bp-480h] BYREF
  char v17[7]; // [sp+8h] [bp-47Ch] BYREF
  char v18; // [sp+Fh] [bp-475h] BYREF
  unsigned __int64 v19[3]; // [sp+10h] [bp-474h] BYREF
  char v20; // [sp+2Fh] [bp-455h] BYREF
  unsigned __int64 v21[4]; // [sp+30h] [bp-454h] BYREF
  unsigned __int64 v22[8]; // [sp+50h] [bp-434h] BYREF
  unsigned __int64 v23[16]; // [sp+90h] [bp-3F4h] BYREF
  _DWORD v24[60]; // [sp+110h] [bp-374h] BYREF
  _DWORD v25[60]; // [sp+200h] [bp-284h] BYREF
  int v26[101]; // [sp+2F0h] [bp-194h] BYREF

  v3 = a1 + 36;
  v4 = a1 + 68;
  v5 = (char *)&v16 + 3;
  do
  {
    v7 = *v3++;
    v6 = v7;
    v8 = *v4++;
    *++v5 = v6 ^ v8;
  }
  while ( v3 != a1 + 44 );
  v9 = a1 + 35;
  v10 = &v18;
  v11 = a1 + 67;
  do
  {
    v13 = *++v9;
    v12 = v13;
    v14 = *++v11;
    *++v10 = v12 ^ v14;
  }
  while ( v10 != &v20 );
  v16 = v23;
  hs_header_share_write((int)a1, (int *)&v16);
  hs_blake2b_init(v24, 64);
  hs_blake2b_update((int)v24, v23, 0x80u);
  hs_blake2b_final((int)v24, v22, 0x40u);
  hs_sha3_256_init(v26);
  hs_sha3_update(v26, (char *)v23, 0x80u);
  hs_sha3_update(v26, v17, 8u);
  hs_sha3_final(v26, v21);
  hs_blake2b_init(v25, 32);
  hs_blake2b_update((int)v25, v22, 0x40u);
  hs_blake2b_update((int)v25, v19, 0x20u);
  hs_blake2b_update((int)v25, v21, 0x20u);
  return hs_blake2b_final((int)v25, a2, 0x20u);
}

//----- (00083C84) --------------------------------------------------------
int __fastcall hs_header_verify_pow(_BYTE *a1, const void *a2)
{
  _BYTE v4[32]; // [sp+0h] [bp-20h] BYREF

  hs_header_pow(a1, v4);
  if ( memcmp(v4, a2, 0x20u) <= 0 )
    return 0;
  else
    return 20;
}

//----- (00083CBC) --------------------------------------------------------
int __fastcall hs_header_print(_DWORD *a1, const char *a2)
{
  _BYTE v5[44]; // [sp+0h] [bp-1FCh] BYREF
  _BYTE v6[52]; // [sp+2Ch] [bp-1D0h] BYREF
  _BYTE v7[68]; // [sp+60h] [bp-19Ch] BYREF
  _BYTE v8[68]; // [sp+A4h] [bp-158h] BYREF
  _BYTE v9[68]; // [sp+E8h] [bp-114h] BYREF
  _BYTE v10[68]; // [sp+12Ch] [bp-D0h] BYREF
  _BYTE v11[68]; // [sp+170h] [bp-8Ch] BYREF
  _BYTE v12[72]; // [sp+1B4h] [bp-48h] BYREF

  hs_hex_encode((int)(a1 + 4), 20, v5);
  hs_hex_encode((int)(a1 + 9), 32, v7);
  hs_hex_encode((int)(a1 + 17), 32, v8);
  hs_hex_encode((int)(a1 + 25), 32, v9);
  hs_hex_encode((int)(a1 + 33), 24, v6);
  hs_hex_encode((int)(a1 + 39), 32, v10);
  hs_hex_encode((int)(a1 + 47), 32, v11);
  hs_hex_encode((int)(a1 + 55), 32, v12);
  printf("%sheader\n", a2);
  printf("%s  nonce=%u\n", a2, *a1);
  printf("%s  time=%u\n", a2, a1[2]);
  printf("%s  mask_hash=%s\n", a2, v9);
  printf("%s  prev_block=%s\n", a2, v7);
  printf("%s  name_root=%s\n", a2, v8);
  printf("%s  extra_nonce=%s\n", a2, v6);
  printf("%s  reserved_root=%s\n", a2, v10);
  printf("%s  witness_root=%s\n", a2, v11);
  printf("%s  merkle_root=%s\n", a2, v12);
  printf("%s  version=%u\n", a2, a1[63]);
  return printf("%s  bits=%u\n", a2, a1[64]);
}

//----- (00083E40) --------------------------------------------------------
int __fastcall sub_83E40(int *a1, int a2, unsigned int a3)
{
  int v4; // r4
  int v5; // r12
  int result; // r0
  int v7; // lr
  int v8; // r3
  __int64 v9; // r4
  int v10; // r3
  int v11; // lr
  __int64 v12; // r4
  int v13; // lr
  int v14; // lr
  int v15; // r3
  __int64 v16; // r4
  int v17; // r3
  int v18; // lr
  int v19; // r3
  int v20; // r3
  int v21; // r4
  int v22; // r3
  int v23; // lr
  int v24; // r3
  int v25; // r4
  int v26; // r3
  int v27; // r3
  int v28; // r4
  int v29; // r3
  int v30; // lr
  int v31; // r3
  int v32; // r4
  int v33; // r3
  int v34; // r3
  int v35; // lr
  int v36; // r2
  int v37; // r2
  int v38; // r3
  __int64 v39; // r2
  int v40; // lr
  int v41; // lr
  __int64 *v42; // r4
  int *j; // r1
  int v44; // r0
  int v45; // t1
  int v46; // r12
  int v47; // r0
  int *v48; // r2
  int *v49; // r7
  int v50; // t1
  int v51; // r6
  int v52; // r5
  int v53; // lr
  int v54; // r4
  int v55; // lr
  int v56; // r6
  int v57; // r5
  int v58; // r4
  int v59; // lr
  int v60; // r3
  unsigned int v61; // r7
  int v62; // r12
  unsigned int v63; // r8
  unsigned int v64; // r1
  int v65; // r5
  int v66; // r0
  unsigned int v67; // r2
  int v68; // r4
  int v69; // lr
  int v70; // r12
  unsigned int v71; // r11
  __int64 v72; // r8
  int v73; // r1
  __int64 v74; // r6
  int v75; // r1
  unsigned int v76; // r4
  int v77; // r11
  int v78; // r2
  int v79; // r2
  int v80; // r5
  int v81; // r1
  int v82; // r2
  int v83; // r1
  int v84; // r0
  unsigned int v85; // r4
  __int64 v86; // r0
  int v87; // r0
  unsigned int v88; // r4
  int v89; // r11
  unsigned int v90; // r12
  unsigned int v91; // r11
  int v92; // r11
  int v93; // r5
  int v94; // r4
  int v95; // lr
  int v96; // r12
  int v97; // r2
  int *v98; // r3
  int v99; // r8
  int v100; // r12
  int v101; // lr
  int v102; // r1
  int v103; // r2
  int v104; // r6
  int v105; // r7
  int v106; // r5
  int v107; // lr
  int v108; // r7
  int v109; // r1
  int v110; // r0
  int v111; // r12
  int v112; // r2
  int v113; // r8
  int v114; // r1
  char *v115; // r3
  int v116; // r0
  int v117; // [sp+Ch] [bp-A8h]
  int v118; // [sp+10h] [bp-A4h]
  int v119; // [sp+10h] [bp-A4h]
  int v120; // [sp+14h] [bp-A0h]
  int v121; // [sp+18h] [bp-9Ch]
  int v122; // [sp+1Ch] [bp-98h]
  int v123; // [sp+1Ch] [bp-98h]
  int v124; // [sp+20h] [bp-94h]
  int v125; // [sp+20h] [bp-94h]
  int v126; // [sp+24h] [bp-90h]
  int v127; // [sp+28h] [bp-8Ch]
  unsigned int v128; // [sp+2Ch] [bp-88h]
  int v129; // [sp+30h] [bp-84h]
  int v130; // [sp+34h] [bp-80h]
  unsigned int v131; // [sp+38h] [bp-7Ch]
  int v132; // [sp+3Ch] [bp-78h]
  int v133; // [sp+40h] [bp-74h]
  int v134; // [sp+44h] [bp-70h]
  char *v135; // [sp+48h] [bp-6Ch]
  int v136; // [sp+4Ch] [bp-68h]
  int i; // [sp+50h] [bp-64h]
  __int64 v138; // [sp+60h] [bp-54h] BYREF
  __int64 v139; // [sp+68h] [bp-4Ch]
  __int64 v140; // [sp+70h] [bp-44h]
  __int64 v141; // [sp+78h] [bp-3Ch]
  __int64 v142; // [sp+80h] [bp-34h]
  int v143; // [sp+88h] [bp-2Ch]
  int v144; // [sp+8Ch] [bp-28h]
  _DWORD v145[9]; // [sp+90h] [bp-24h] BYREF

  v4 = a1[2];
  v5 = *a1 ^ *(_DWORD *)a2;
  result = *(_DWORD *)(a2 + 4) ^ a1[1];
  *a1 = v5;
  a1[1] = result;
  v7 = a1[4];
  v8 = a1[3] ^ *(_DWORD *)(a2 + 12);
  a1[2] = v4 ^ *(_DWORD *)(a2 + 8);
  a1[3] = v8;
  v9 = *(_QWORD *)(a2 + 16);
  a1[5] ^= HIDWORD(v9);
  a1[4] = v7 ^ v9;
  HIDWORD(v9) = *(_DWORD *)(a2 + 28);
  v10 = a1[7];
  v11 = a1[8];
  a1[6] ^= *(_DWORD *)(a2 + 24);
  a1[7] = v10 ^ HIDWORD(v9);
  v12 = *(_QWORD *)(a2 + 32);
  v13 = v11 ^ v12;
  a1[9] ^= HIDWORD(v12);
  LODWORD(v12) = a1[10];
  a1[8] = v13;
  v14 = a1[12];
  v15 = a1[11] ^ *(_DWORD *)(a2 + 44);
  a1[10] = v12 ^ *(_DWORD *)(a2 + 40);
  a1[11] = v15;
  v16 = *(_QWORD *)(a2 + 48);
  a1[13] ^= HIDWORD(v16);
  a1[12] = v14 ^ v16;
  HIDWORD(v16) = *(_DWORD *)(a2 + 60);
  v17 = a1[15];
  v18 = a1[16];
  a1[14] ^= *(_DWORD *)(a2 + 56);
  a1[15] = v17 ^ HIDWORD(v16);
  v19 = a1[17] ^ *(_DWORD *)(a2 + 68);
  a1[16] = v18 ^ *(_DWORD *)(a2 + 64);
  a1[17] = v19;
  if ( a3 > 0x48 )
  {
    v20 = a1[19] ^ *(_DWORD *)(a2 + 76);
    a1[18] ^= *(_DWORD *)(a2 + 72);
    a1[19] = v20;
    v21 = *(_DWORD *)(a2 + 84);
    v22 = a1[21];
    a1[20] ^= *(_DWORD *)(a2 + 80);
    v23 = a1[22];
    a1[21] = v22 ^ v21;
    v24 = a1[23] ^ *(_DWORD *)(a2 + 92);
    a1[22] = v23 ^ *(_DWORD *)(a2 + 88);
    a1[23] = v24;
    v25 = *(_DWORD *)(a2 + 100);
    v26 = a1[25];
    a1[24] ^= *(_DWORD *)(a2 + 96);
    a1[25] = v26 ^ v25;
    if ( a3 > 0x68 )
    {
      v27 = a1[27] ^ *(_DWORD *)(a2 + 108);
      a1[26] ^= *(_DWORD *)(a2 + 104);
      a1[27] = v27;
      v28 = *(_DWORD *)(a2 + 116);
      v29 = a1[29];
      a1[28] ^= *(_DWORD *)(a2 + 112);
      v30 = a1[30];
      a1[29] = v29 ^ v28;
      v31 = a1[31] ^ *(_DWORD *)(a2 + 124);
      a1[30] = v30 ^ *(_DWORD *)(a2 + 120);
      a1[31] = v31;
      v32 = *(_DWORD *)(a2 + 132);
      v33 = a1[33];
      a1[32] ^= *(_DWORD *)(a2 + 128);
      a1[33] = v33 ^ v32;
      if ( a3 > 0x88 )
      {
        v34 = a1[35] ^ *(_DWORD *)(a2 + 140);
        a1[34] ^= *(_DWORD *)(a2 + 136);
        a1[35] = v34;
        if ( a3 > 0x90 )
        {
          v35 = a1[38];
          v36 = a1[37] ^ *(_DWORD *)(a2 + 148);
          a1[36] ^= *(_DWORD *)(a2 + 144);
          a1[37] = v36;
          v37 = a1[40];
          v38 = a1[39] ^ *(_DWORD *)(a2 + 156);
          a1[38] = v35 ^ *(_DWORD *)(a2 + 152);
          a1[39] = v38;
          LODWORD(v39) = v37 ^ *(_DWORD *)(a2 + 160);
          v40 = a1[42];
          HIDWORD(v39) = a1[41] ^ *(_DWORD *)(a2 + 164);
          *((_QWORD *)a1 + 20) = v39;
          LODWORD(v39) = a1[44];
          HIDWORD(v39) = a1[43] ^ *(_DWORD *)(a2 + 172);
          a1[42] = v40 ^ *(_DWORD *)(a2 + 168);
          a1[43] = HIDWORD(v39);
          LODWORD(v39) = v39 ^ *(_DWORD *)(a2 + 176);
          v41 = a1[46];
          HIDWORD(v39) = a1[45] ^ *(_DWORD *)(a2 + 180);
          *((_QWORD *)a1 + 22) = v39;
          LODWORD(v39) = a1[48];
          HIDWORD(v39) = a1[47] ^ *(_DWORD *)(a2 + 188);
          a1[46] = v41 ^ *(_DWORD *)(a2 + 184);
          a1[47] = HIDWORD(v39);
          LODWORD(v39) = v39 ^ *(_DWORD *)(a2 + 192);
          HIDWORD(v39) = a1[49] ^ *(_DWORD *)(a2 + 196);
          *((_QWORD *)a1 + 24) = v39;
        }
      }
    }
  }
  v136 = 1;
  v135 = (char *)&unk_EC700;
  for ( i = 0; ; i = *((_DWORD *)v115 + 3) )
  {
    v42 = &v138;
    for ( j = a1; ; result = j[1] )
    {
      ++v42;
      v44 = result ^ j[11] ^ j[21] ^ j[31] ^ j[41];
      *((_DWORD *)v42 - 2) = v5 ^ j[10] ^ j[20] ^ j[30] ^ j[40];
      *((_DWORD *)v42 - 1) = v44;
      if ( a1 + 8 == j )
        break;
      v45 = j[2];
      j += 2;
      v5 = v45;
    }
    v46 = ((2 * v139) | (HIDWORD(v139) >> 31)) ^ v142;
    v145[2] = ((2 * v141) | (HIDWORD(v141) >> 31)) ^ v139;
    v145[3] = (v141 >> 31) ^ HIDWORD(v139);
    v47 = (v139 >> 31) ^ HIDWORD(v142);
    v48 = a1 - 2;
    v145[6] = ((2 * v138) | (HIDWORD(v138) >> 31)) ^ v141;
    v143 = v46;
    v145[0] = v138 ^ ((2 * v140) | (HIDWORD(v140) >> 31));
    v49 = v145;
    v144 = v47;
    v145[7] = HIDWORD(v141) ^ (v138 >> 31);
    v145[1] = HIDWORD(v138) ^ (v140 >> 31);
    v145[4] = ((2 * v142) | (HIDWORD(v142) >> 31)) ^ v140;
    v145[5] = (v142 >> 31) ^ HIDWORD(v140);
    while ( 1 )
    {
      v50 = v48[2];
      v48 += 2;
      v51 = v48[10];
      v52 = v48[11];
      v53 = v48[1] ^ v47;
      *v48 = v50 ^ v46;
      v48[1] = v53;
      v54 = v48[20];
      v55 = v48[21];
      v48[10] = v51 ^ v46;
      v56 = v48[30];
      v48[11] = v52 ^ v47;
      v48[20] = v54 ^ v46;
      v57 = v48[31];
      v58 = v48[40];
      v48[21] = v55 ^ v47;
      v59 = v48[41];
      v48[30] = v56 ^ v46;
      v48[31] = v57 ^ v47;
      v48[40] = v46 ^ v58;
      v48[41] = v47 ^ v59;
      if ( j == v48 )
        break;
      v46 = *v49;
      v49 += 2;
      v47 = *(v49 - 1);
    }
    v60 = (2 * a1[2]) | ((unsigned int)a1[3] >> 31);
    v61 = a1[27];
    v117 = *((__int64 *)a1 + 1) >> 31;
    v118 = ((unsigned int)a1[5] >> 2) | (a1[4] << 30);
    v62 = a1[26];
    v121 = *((__int64 *)a1 + 3) >> 4;
    v120 = (a1[6] << 28) | ((unsigned int)a1[7] >> 4);
    v63 = a1[28];
    v124 = *((__int64 *)a1 + 9) >> 12;
    v64 = a1[29];
    v122 = (a1[18] << 20) | ((unsigned int)a1[19] >> 12);
    v65 = *((__int64 *)a1 + 12) >> 21;
    v66 = ((unsigned int)a1[25] >> 21) | (a1[24] << 11);
    v67 = a1[40];
    v68 = *((__int64 *)a1 + 13) >> 7;
    a1[40] = *((__int64 *)a1 + 2) >> 2;
    v69 = (v62 << 25) | (v61 >> 7);
    v70 = (v63 >> 25) | (v64 << 7);
    v71 = a1[41];
    v72 = *((_QWORD *)a1 + 22);
    v73 = (v64 >> 25) | (a1[28] << 7);
    v74 = *((_QWORD *)a1 + 6);
    a1[41] = v118;
    a1[12] = v122;
    a1[45] = v73;
    a1[25] = v68;
    v75 = (v71 << 18) | (v67 >> 14);
    v76 = a1[39];
    v77 = (v67 << 18) | (v71 >> 14);
    a1[29] = v75;
    v78 = HIDWORD(v72) >> 3;
    a1[5] = v66;
    HIDWORD(v72) = v72 >> 3;
    LODWORD(v72) = v78 | ((_DWORD)v72 << 29);
    v79 = HIDWORD(v74) >> 20;
    a1[4] = v65;
    HIDWORD(v74) = v74 >> 20;
    v80 = a1[15];
    a1[3] = v79 | ((_DWORD)v74 << 12);
    v81 = a1[38];
    LODWORD(v74) = a1[14];
    a1[24] = v69;
    v82 = v81 << 8;
    v83 = a1[39];
    a1[13] = v124;
    a1[44] = v70;
    a1[28] = v77;
    a1[26] = v82 | HIBYTE(v76);
    v84 = v83 << 8;
    v85 = a1[38];
    HIDWORD(v86) = a1[9];
    a1[18] = HIDWORD(v72);
    a1[19] = v72;
    v87 = v84 | HIBYTE(v85);
    v88 = a1[11];
    a1[2] = HIDWORD(v74);
    a1[27] = v87;
    LODWORD(v86) = a1[8];
    v123 = v86 >> 5;
    v119 = ((_DWORD)v86 << 27) | ((unsigned int)a1[9] >> 5);
    v125 = ((unsigned int)a1[10] >> 28) | (16 * v88);
    v126 = (v88 >> 28) | (16 * a1[10]);
    v128 = (v80 << 6) | ((unsigned int)v74 >> 26);
    LODWORD(v72) = a1[17];
    v89 = a1[20];
    LODWORD(v86) = a1[23];
    v90 = a1[33];
    HIDWORD(v72) = a1[16];
    v129 = *((__int64 *)a1 + 8) >> 9;
    v127 = ((_DWORD)v74 << 6) | ((unsigned int)a1[15] >> 26);
    v130 = v72 >> 9;
    a1[15] = *((__int64 *)a1 + 10) >> 29;
    HIDWORD(v86) = a1[23] << 10;
    a1[14] = (8 * v89) | ((unsigned int)a1[21] >> 29);
    v91 = a1[22];
    v132 = HIDWORD(v86) | (v91 >> 22);
    v131 = (v91 << 10) | ((unsigned int)v86 >> 22);
    v133 = *((__int64 *)a1 + 15) >> 23;
    v92 = ((unsigned int)a1[32] >> 19) | (v90 << 13);
    v134 = ((unsigned int)a1[31] >> 23) | (a1[30] << 9);
    HIDWORD(v72) = (v90 >> 19) | (a1[32] << 13);
    LODWORD(v72) = *((__int64 *)a1 + 17) >> 17;
    HIDWORD(v74) = (a1[34] << 15) | ((unsigned int)a1[35] >> 17);
    LODWORD(v74) = *((__int64 *)a1 + 18) >> 11;
    v93 = (a1[36] << 21) | ((unsigned int)a1[37] >> 11);
    v94 = *((__int64 *)a1 + 21) >> 30;
    v95 = (4 * a1[42]) | ((unsigned int)a1[43] >> 30);
    v96 = *((__int64 *)a1 + 23) >> 8;
    HIDWORD(v86) = *((__int64 *)a1 + 24) >> 18;
    LODWORD(v86) = ((unsigned int)a1[47] >> 8) | (a1[46] << 24);
    v97 = (a1[48] << 14) | ((unsigned int)a1[49] >> 18);
    a1[21] = v117;
    a1[20] = v60;
    a1[11] = v121;
    a1[10] = v120;
    a1[31] = v123;
    a1[30] = v119;
    a1[32] = v125;
    a1[33] = v126;
    a1[23] = v128;
    a1[22] = v127;
    a1[42] = v129;
    a1[43] = v130;
    a1[49] = v94;
    a1[35] = v132;
    a1[16] = v92;
    a1[17] = HIDWORD(v72);
    a1[34] = v131;
    a1[37] = v72;
    a1[36] = HIDWORD(v74);
    a1[46] = v133;
    a1[7] = v74;
    a1[6] = v93;
    a1[47] = v134;
    v98 = a1;
    a1[48] = v95;
    a1[38] = v96;
    a1[39] = v86;
    a1[9] = HIDWORD(v86);
    a1[8] = v97;
    do
    {
      v99 = *v98;
      v98 += 10;
      v100 = *(v98 - 2);
      v101 = *(v98 - 4);
      v102 = *(v98 - 6);
      v103 = *(v98 - 8);
      v104 = *(v98 - 9);
      *(v98 - 4) = v99 & ~v100 ^ v101;
      v105 = v101 & ~v102;
      v106 = *(v98 - 1);
      v107 = v100 & ~v101 ^ v102;
      v108 = v105 ^ v103;
      v109 = v102 & ~v103;
      v110 = *(v98 - 3);
      v111 = v100 ^ v103 & ~v99;
      v112 = *(v98 - 5);
      v113 = v99 ^ v109;
      v114 = *(v98 - 7);
      *(v98 - 6) = v107;
      *(v98 - 2) = v111;
      *(v98 - 8) = v108;
      *(v98 - 10) = v113;
      *(v98 - 3) = v104 & ~v106 ^ v110;
      *(v98 - 5) = v106 & ~v110 ^ v112;
      *(v98 - 7) = v110 & ~v112 ^ v114;
      *(v98 - 1) = v114 & ~v104 ^ v106;
      *(v98 - 9) = v112 & ~v114 ^ v104;
    }
    while ( a1 + 50 != v98 );
    v115 = v135;
    v116 = a1[1];
    v5 = v136 ^ *a1;
    *a1 = v5;
    result = i ^ v116;
    a1[1] = result;
    if ( &unk_EC7B8 == (_UNKNOWN *)v135 )
      break;
    v135 += 8;
    v136 = *((_DWORD *)v115 + 2);
  }
  return result;
}

//----- (00084874) --------------------------------------------------------
_DWORD *__fastcall hs_sha3_224_init(void *a1)
{
  _DWORD *result; // r0

  result = memset(a1, 0, 0x190u);
  result[99] = 144;
  return result;
}

//----- (00084890) --------------------------------------------------------
_DWORD *__fastcall hs_sha3_256_init(void *a1)
{
  _DWORD *result; // r0

  result = memset(a1, 0, 0x190u);
  result[99] = 136;
  return result;
}

//----- (000848AC) --------------------------------------------------------
_DWORD *__fastcall hs_sha3_384_init(void *a1)
{
  _DWORD *result; // r0

  result = memset(a1, 0, 0x190u);
  result[99] = 104;
  return result;
}

//----- (000848C8) --------------------------------------------------------
_DWORD *__fastcall hs_sha3_512_init(void *a1)
{
  _DWORD *result; // r0

  result = memset(a1, 0, 0x190u);
  result[99] = 72;
  return result;
}

//----- (000848E4) --------------------------------------------------------
int *__fastcall hs_sha3_update(int *result, char *a2, size_t a3)
{
  int v3; // r8
  unsigned int v4; // r4
  int *v5; // r7
  size_t v7; // r6
  int v8; // r1
  char *v9; // r8
  size_t v10; // r9
  size_t v11; // r2

  v3 = result[98];
  if ( v3 < 0 )
    return result;
  v4 = result[99];
  v5 = result;
  v7 = a3;
  result = (int *)sub_DCE94(v3 + a3, v4);
  v5[98] = v8;
  if ( v3 )
  {
    v10 = v4 - v3;
    if ( v7 >= v4 - v3 )
      v11 = v4 - v3;
    else
      v11 = v7;
    result = (int *)memcpy((char *)v5 + v3 + 200, a2, v11);
    if ( v7 < v10 )
      return result;
    a2 += v10;
    v7 -= v10;
    result = (int *)sub_83E40(v5, (int)(v5 + 50), v4);
  }
  for ( ; v4 <= v7; a2 += v4 )
  {
    v9 = a2;
    if ( ((unsigned __int8)a2 & 7) != 0 )
    {
      v9 = (char *)(v5 + 50);
      memcpy(v5 + 50, a2, v4);
    }
    v7 -= v4;
    result = (int *)sub_83E40(v5, (int)v9, v4);
  }
  if ( v7 )
    return (int *)memcpy(v5 + 50, a2, v7);
  return result;
}
// 84914: variable 'v8' is possibly undefined

//----- (000849D0) --------------------------------------------------------
char *__fastcall hs_sha3_final(int *a1, void *a2)
{
  char *result; // r0
  unsigned int v5; // r6
  int *v6; // r5

  result = (char *)a1[98];
  v5 = a1[99];
  if ( (int)result >= 0 )
  {
    v6 = a1 + 50;
    memset(&result[(_DWORD)(a1 + 50)], 0, v5 - (_DWORD)result);
    *((_BYTE *)v6 + a1[98]) |= 6u;
    *((_BYTE *)v6 + v5 - 1) = ~((unsigned int)~(*((unsigned __int8 *)v6 + v5 - 1) << 25) >> 25);
    result = (char *)sub_83E40(a1, (int)(a1 + 50), v5);
    a1[98] = 0x80000000;
  }
  if ( a2 )
    return (char *)memcpy(a2, a1, 100 - (v5 >> 1));
  return result;
}

//----- (00084A5C) --------------------------------------------------------
char *__fastcall hs_keccak_final(int *a1, void *a2)
{
  char *result; // r0
  unsigned int v5; // r6
  int *v6; // r5

  result = (char *)a1[98];
  v5 = a1[99];
  if ( (int)result >= 0 )
  {
    v6 = a1 + 50;
    memset(&result[(_DWORD)(a1 + 50)], 0, v5 - (_DWORD)result);
    *((_BYTE *)v6 + a1[98]) |= 1u;
    *((_BYTE *)v6 + v5 - 1) = ~((unsigned int)~(*((unsigned __int8 *)v6 + v5 - 1) << 25) >> 25);
    result = (char *)sub_83E40(a1, (int)(a1 + 50), v5);
    a1[98] = 0x80000000;
  }
  if ( a2 )
    return (char *)memcpy(a2, a1, 100 - (v5 >> 1));
  return result;
}

//----- (00084AE8) --------------------------------------------------------
int __fastcall sub_84AE8(int a1, int a2, _BYTE *a3)
{
  int v3; // r1
  int v4; // r4
  _BYTE *v5; // r5
  int v6; // r12
  unsigned int v7; // r3
  char v8; // lr
  unsigned int v9; // r3
  unsigned int v10; // r3
  char v11; // lr

  v3 = 2 * a2;
  if ( v3 <= 0 )
  {
    *a3 = 0;
    return 1;
  }
  else
  {
    v4 = 0;
    v5 = a3 - 1;
    v6 = 0;
    do
    {
      while ( 1 )
      {
        v9 = *(unsigned __int8 *)(a1 + v4);
        if ( (v6 & 1) != 0 )
          break;
        v10 = v9 >> 4;
        ++v6;
        v11 = v10 + 87;
        if ( v10 <= 9 )
          v11 = v10 + 48;
        *++v5 = v11;
        if ( v3 == v6 )
          goto LABEL_10;
      }
      v7 = v9 & 0xF;
      ++v6;
      v8 = v7 + 87;
      if ( v7 <= 9 )
        v8 = v7 + 48;
      ++v4;
      *++v5 = v8;
    }
    while ( v3 != v6 );
LABEL_10:
    a3[v3] = 0;
    return 1;
  }
}

//----- (00084B7C) --------------------------------------------------------
__int64 hs_now()
{
  return time(0);
}

//----- (00084B90) --------------------------------------------------------
int __fastcall hs_date(
        int result,
        int a2,
        unsigned int *a3,
        unsigned int *a4,
        _DWORD *a5,
        int *a6,
        int *a7,
        _DWORD *a8)
{
  unsigned int v8; // r1
  unsigned int v9; // r11
  unsigned int v10; // r8
  unsigned int v11; // r1
  unsigned int v12; // r8
  unsigned int v13; // r1
  unsigned int v14; // lr
  int v15; // r4
  unsigned int v16; // r4
  unsigned int v17; // r11

  v8 = result / 86400 + 719468;
  v9 = v8 / 0x23AB1;
  v8 %= 0x23AB1u;
  v10 = v8 + v8 / 0x8EAC - v8 / 0x5B4 - v8 / 0x23AB0;
  v11 = v8 + v10 / 0x8E94 - v10 / 0x5B4;
  v12 = v10 / 0x16D;
  v13 = v11 - 365 * v12;
  v14 = (5 * v13 + 2) / 0x99;
  if ( v14 >= 0xA )
    v15 = -9;
  else
    v15 = 3;
  v16 = v15 + v14;
  if ( a3 )
  {
    v17 = v12 + 400 * v9;
    if ( v16 <= 2 )
      ++v17;
    *a3 = v17;
  }
  if ( a4 )
    *a4 = v16;
  if ( a5 )
    *a5 = v13 + 1 - (153 * v14 + 2) / 5;
  if ( a6 )
    *a6 = result / 3600 % 24;
  if ( a7 )
    *a7 = result / 60 % 60;
  if ( a8 )
  {
    result %= 60;
    *a8 = result;
  }
  return result;
}

//----- (00084D94) --------------------------------------------------------
int __fastcall hs_ymdh(unsigned int *a1, unsigned int *a2, _DWORD *a3, int *a4)
{
  time_t v8; // r0

  v8 = time(0);
  return hs_date(v8, v8 >> 31, a1, a2, a3, a4, 0, 0);
}

//----- (00084DDC) --------------------------------------------------------
int __fastcall hs_ymd(unsigned int *a1, unsigned int *a2, _DWORD *a3)
{
  time_t v6; // r0

  v6 = time(0);
  return hs_date(v6, v6 >> 31, a1, a2, a3, 0, 0, 0);
}

//----- (00084E28) --------------------------------------------------------
__int64 hs_nonce()
{
  return (unsigned int)rand();
}

//----- (00084E38) --------------------------------------------------------
int __fastcall hs_hex_encode_size(int a1)
{
  return 2 * a1 + 1;
}

//----- (00084E44) --------------------------------------------------------
int __fastcall hs_hex_encode(int a1, int a2, _BYTE *a3)
{
  int v3; // r3

  v3 = a2;
  if ( a2 )
    v3 = 1;
  if ( a1 )
    v3 = 0;
  if ( !a3 )
    v3 = 1;
  if ( v3 )
    return 0;
  else
    return sub_84AE8(a1, a2, a3);
}

//----- (00084E70) --------------------------------------------------------
_BYTE *__fastcall hs_hex_encode32(int a1)
{
  if ( a1 )
    sub_84AE8(a1, 32, byte_11A72C);
  return byte_11A72C;
}
// 11A72C: using guessed type _BYTE byte_11A72C[68];

//----- (00084EA4) --------------------------------------------------------
_BYTE *__fastcall hs_hex_encode20(int a1)
{
  if ( a1 )
    sub_84AE8(a1, 20, byte_11A770);
  return byte_11A770;
}
// 11A770: using guessed type _BYTE byte_11A770[44];

//----- (00084ED0) --------------------------------------------------------
size_t __fastcall hs_hex_decode_size(const char *a1)
{
  if ( a1 )
    return strlen(a1) >> 1;
  else
    return 0;
}

//----- (00084EF0) --------------------------------------------------------
bool __fastcall hs_hex_decode(_BYTE *a1, int a2)
{
  int v2; // r2
  char v3; // lr
  int v4; // r5
  int v5; // r12
  int v6; // t1
  char v7; // r3
  int v8; // t1

  if ( !a1 )
    return 1;
  v2 = (unsigned __int8)*a1;
  if ( !*a1 )
    return 1;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  while ( 1 )
  {
    v7 = v2 - 48;
    if ( (unsigned __int8)(v2 - 48) > 9u )
      break;
LABEL_12:
    if ( (v5 & 1) != 0 )
    {
      v3 |= v7;
      if ( a2 )
        *(_BYTE *)(a2 + v4) = v3;
      ++v5;
      v6 = (unsigned __int8)*++a1;
      v2 = v6;
      ++v4;
      if ( !v6 )
        return (v5 & 1) == 0;
    }
    else
    {
      v8 = (unsigned __int8)*++a1;
      v2 = v8;
      ++v5;
      v3 = 16 * v7;
      if ( !v8 )
        return (v5 & 1) == 0;
    }
  }
  if ( (unsigned int)(v2 - 65) <= 5 )
  {
    v7 = v2 - 55;
    goto LABEL_12;
  }
  if ( (unsigned int)(v2 - 97) <= 5 )
  {
    v7 = v2 - 87;
    goto LABEL_12;
  }
  return 0;
}

//----- (00084FA8) --------------------------------------------------------
_BYTE *__fastcall hs_to_lower(_BYTE *result)
{
  int v1; // r3
  unsigned int v2; // r2
  char v3; // r3
  int v4; // t1

  v1 = (unsigned __int8)*result;
  if ( *result )
  {
    do
    {
      v2 = v1 - 65;
      v3 = v1 + 32;
      if ( v2 <= 0x19 )
        *result = v3;
      v4 = (unsigned __int8)*++result;
      v1 = v4;
    }
    while ( v4 );
  }
  return result;
}

//----- (00084FD4) --------------------------------------------------------
int __fastcall sha256_transf(int result, unsigned __int8 *a2, int a3)
{
  unsigned __int8 *v3; // r0
  int *v4; // lr
  char *v5; // r12
  int v6; // r3
  int v7; // r4
  int v8; // r1
  int v9; // t1
  unsigned int v10; // lr
  char *v11; // r3
  unsigned int v12; // t1
  int *v13; // r0
  int **v14; // r3
  int *v15; // r2
  int *v16; // t1
  int v17; // r6
  int v18; // r3
  int v19; // r4
  int v20; // r10
  int v21; // r9
  int v22; // r5
  int v23; // r8
  int v24; // r7
  int v25; // r11
  int v26; // r2
  int v27; // r12
  int v28; // r3
  int v29; // lr
  int v30; // r1
  int **v31; // r1
  int *v32; // r3
  int *v33; // t1
  bool v34; // zf
  unsigned __int8 *v35; // [sp+4h] [bp-164h]
  int *v36; // [sp+8h] [bp-160h]
  unsigned __int8 *v37; // [sp+14h] [bp-154h]
  int *v38; // [sp+18h] [bp-150h]
  int *v39; // [sp+1Ch] [bp-14Ch] BYREF
  int v40; // [sp+20h] [bp-148h]
  int v41; // [sp+24h] [bp-144h]
  int v42; // [sp+28h] [bp-140h]
  int v43; // [sp+2Ch] [bp-13Ch]
  int v44; // [sp+30h] [bp-138h]
  int v45; // [sp+34h] [bp-134h]
  int v46; // [sp+38h] [bp-130h]
  int v47; // [sp+3Ch] [bp-12Ch] BYREF
  _DWORD v48[15]; // [sp+40h] [bp-128h] BYREF
  char v49; // [sp+7Ch] [bp-ECh] BYREF
  char v50; // [sp+100h] [bp-68h] BYREF

  if ( a3 > 0 )
  {
    v38 = (int *)(result + 136);
    v35 = a2;
    v37 = &a2[64 * a3];
    v39 = (int *)(result + 168);
    do
    {
      v3 = v35;
      v4 = &v47;
      v5 = (char *)v48;
      do
      {
        v6 = v3[1];
        v7 = v3[2];
        v8 = v3[3];
        v9 = *v3;
        v3 += 4;
        v4[1] = (v6 << 16) | (v7 << 8) | v8 | (v9 << 24);
        ++v4;
      }
      while ( &v49 != (char *)v4 );
      do
      {
        v10 = *((_DWORD *)v5 + 14);
        v11 = v5;
        v12 = *((_DWORD *)v5 + 1);
        v5 += 4;
        *((_DWORD *)v5 + 15) = (__ROR4__(v10, 19) ^ __ROR4__(v10, 17) ^ (v10 >> 10))
                             + *((_DWORD *)v11 + 9)
                             + *(_DWORD *)v11
                             + (__ROR4__(v12, 18) ^ __ROR4__(v12, 7) ^ (v12 >> 3));
      }
      while ( &v50 != v5 );
      v13 = v39;
      v14 = &v39;
      v15 = v38;
      do
      {
        v16 = (int *)*v15++;
        v14[1] = v16;
        ++v14;
      }
      while ( v13 != v15 );
      v36 = v15;
      v17 = 0;
      v18 = v47;
      v19 = v44;
      v20 = v45;
      v21 = v46;
      v22 = v40;
      v23 = v41;
      v24 = v42;
      v25 = v43;
      while ( 1 )
      {
        v26 = (__ROR4__(v19, 11) ^ __ROR4__(v19, 6) ^ __ROR4__(v19, 25)) + (v21 & ~v19 ^ v20 & v19) + v48[v17];
        v27 = sha256_k[v17++];
        v28 = v26 + v27 + v18;
        v29 = v25 + v28;
        v30 = (__ROR4__(v22, 13) ^ __ROR4__(v22, 2) ^ __ROR4__(v22, 22)) + ((v24 ^ v23) & v22 ^ v24 & v23) + v28;
        v25 = v24;
        v18 = v21;
        if ( v17 == 64 )
          break;
        v24 = v23;
        v21 = v20;
        v23 = v22;
        v20 = v19;
        v22 = v30;
        v19 = v29;
      }
      v40 = v30;
      v31 = &v39;
      v32 = v38;
      v47 = v21;
      v44 = v29;
      v45 = v19;
      v46 = v20;
      v41 = v22;
      v42 = v23;
      v43 = v24;
      do
      {
        result = *v32;
        v33 = v31[1];
        ++v31;
        *v32++ += (int)v33;
      }
      while ( v36 != v32 );
      v34 = v37 == v35 + 64;
      v35 += 64;
    }
    while ( !v34 );
  }
  return result;
}
// 107624: using guessed type _DWORD sha256_k[63];

//----- (000851D0) --------------------------------------------------------
_DWORD *__fastcall sha256_init(_DWORD *result)
{
  _DWORD *v1; // r2
  _DWORD *v2; // r3
  int v3; // t1

  v1 = &unk_107720;
  v2 = result + 34;
  do
  {
    v3 = v1[1];
    ++v1;
    *v2++ = v3;
  }
  while ( v2 != result + 42 );
  result[1] = 0;
  *result = 0;
  return result;
}

//----- (00085200) --------------------------------------------------------
void *__fastcall sha256_update(unsigned __int8 *a1, char *a2, size_t n)
{
  int v4; // r0
  size_t v7; // r2
  unsigned __int8 *v8; // r0
  size_t v9; // r6
  void *result; // r0
  unsigned int v11; // r3
  size_t v12; // r5
  unsigned __int8 *v13; // r6
  int v14; // r3

  v4 = *((_DWORD *)a1 + 1);
  v7 = 64 - v4;
  v8 = &a1[v4 + 8];
  if ( v7 >= n )
    v9 = n;
  else
    v9 = v7;
  result = memcpy(v8, a2, v9);
  v11 = n + *((_DWORD *)a1 + 1);
  if ( v11 > 0x3F )
  {
    v12 = n - v9;
    v13 = (unsigned __int8 *)&a2[v9];
    sha256_transf((int)a1, a1 + 8, 1);
    sha256_transf((int)a1, v13, v12 >> 6);
    result = memcpy(a1 + 8, &v13[v12 & 0xFFFFFFC0], v12 & 0x3F);
    v14 = *(_DWORD *)a1;
    *((_DWORD *)a1 + 1) = v12 & 0x3F;
    *(_DWORD *)a1 = v14 + (((v12 >> 6) + 1) << 6);
  }
  else
  {
    *((_DWORD *)a1 + 1) = v11;
  }
  return result;
}

//----- (000852AC) --------------------------------------------------------
int __fastcall sha256_final(_DWORD *a1, _BYTE *a2)
{
  int v2; // r3
  unsigned __int8 *v3; // r6
  bool v5; // cf
  int v7; // r2
  int v8; // r7
  size_t v9; // r2
  unsigned __int8 *v10; // r0
  int v11; // r3
  int v12; // r7
  int v13; // r8
  int v14; // r9
  int v15; // r10
  int v16; // r11
  int result; // r0
  int *v18; // r3
  int *v19; // r5
  int v20; // t1
  int v21; // [sp+4h] [bp-8h]

  v2 = a1[1];
  v3 = (unsigned __int8 *)(a1 + 2);
  v5 = (v2 & 0x3Fu) >= 0x38;
  if ( (v2 & 0x3Fu) >= 0x38 )
    v7 = 128;
  else
    v7 = 64;
  v8 = v2 + *a1;
  v9 = v7 - v2;
  v10 = &v3[v2];
  if ( (v2 & 0x3Fu) >= 0x38 )
    v11 = 124;
  else
    v11 = 60;
  v12 = 8 * v8;
  if ( v5 )
    v13 = 125;
  else
    v13 = 61;
  v21 = v11;
  if ( v5 )
    v14 = 126;
  else
    v14 = 62;
  if ( v5 )
    v15 = 127;
  else
    v15 = 63;
  if ( v5 )
    v16 = 2;
  else
    v16 = 1;
  memset(v10, 0, v9);
  *((_BYTE *)a1 + a1[1] + 8) = 0x80;
  v3[v15] = v12;
  v3[v14] = BYTE1(v12);
  v3[v13] = BYTE2(v12);
  v3[v21] = HIBYTE(v12);
  result = sha256_transf((int)a1, v3, v16);
  v18 = a1 + 34;
  v19 = a1 + 42;
  do
  {
    a2[3] = *v18;
    v20 = *v18++;
    a2[2] = BYTE1(v20);
    a2[1] = *((_WORD *)v18 - 1);
    *a2 = *((_BYTE *)v18 - 1);
    a2 += 4;
  }
  while ( v19 != v18 );
  return result;
}

//----- (00085398) --------------------------------------------------------
int __fastcall sha256(char *a1, size_t n, _BYTE *a3)
{
  _DWORD *v3; // r3
  char *v5; // r2
  int v6; // t1
  _DWORD v8[34]; // [sp+0h] [bp-ACh] BYREF
  char v9; // [sp+88h] [bp-24h] BYREF

  v3 = &unk_107720;
  v5 = &v9;
  do
  {
    v6 = v3[1];
    ++v3;
    *(_DWORD *)v5 = v6;
    v5 += 4;
  }
  while ( v3 != (_DWORD *)&unk_107740 );
  v8[0] = 0;
  v8[1] = 0;
  sha256_update((unsigned __int8 *)v8, a1, n);
  return sha256_final(v8, a3);
}

//----- (000853F8) --------------------------------------------------------
#error "853F8: too big function (funcsize=0)"

//----- (00097900) --------------------------------------------------------
FILE *x11_log_work()
{
  FILE *result; // r0
  FILE *v1; // r5
  size_t v2; // r0
  char v3[260]; // [sp+0h] [bp-104h] BYREF

  memset(v3, 0, 0x100u);
  result = (FILE *)fopen64("/tmp/x11_dump_file.log", 909116);
  g_logwork_file = (int)result;
  if ( result )
  {
    v1 = result;
    v2 = strlen(v3);
    fwrite(v3, v2, 1u, v1);
    fwrite("\n", 1u, 1u, (FILE *)g_logwork_file);
    return (FILE *)fflush((FILE *)g_logwork_file);
  }
  return result;
}
// 1EA0C: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 11A79C: using guessed type int g_logwork_file;

//----- (00097994) --------------------------------------------------------
unsigned int __fastcall BM_CRC16(unsigned __int8 *a1, int a2)
{
  unsigned int v2; // r2
  unsigned __int8 *v3; // r1
  int v4; // t1

  if ( !a2 )
    return 0xFFFF;
  v3 = &a1[a2];
  v2 = 0xFFFF;
  do
  {
    v4 = *a1++;
    v2 = (unsigned __int16)(crc_itu_t_table[v4 ^ (v2 >> 8)] ^ ((_WORD)v2 << 8));
  }
  while ( a1 != v3 );
  return v2;
}
// EC918: using guessed type _WORD crc_itu_t_table[256];

//----- (000979D8) --------------------------------------------------------
unsigned int __fastcall BM_CRC16_WITH_KEY(unsigned __int8 *a1, int a2, unsigned int a3)
{
  unsigned __int8 *v3; // r1
  int v4; // t1

  if ( a2 )
  {
    v3 = &a1[a2];
    do
    {
      v4 = *a1++;
      a3 = (unsigned __int16)(crc_itu_t_table[v4 ^ (a3 >> 8)] ^ ((_WORD)a3 << 8));
    }
    while ( a1 != v3 );
  }
  return a3;
}
// EC918: using guessed type _WORD crc_itu_t_table[256];

//----- (00097A14) --------------------------------------------------------
int BM_CRC8()
{
  return 0;
}

//----- (00097A1C) --------------------------------------------------------
int __fastcall BM_CRC5(_BYTE *a1, int a2)
{
  unsigned __int8 v2; // r3
  int v3; // r12
  int v5; // r7
  int result; // r0
  int v7; // r5
  int v8; // r6
  int v9; // r4
  unsigned int v10; // lr
  unsigned int v11; // r2
  int v12; // r9
  int v13; // r2

  if ( !a2 )
  {
    v12 = 1;
    LOBYTE(result) = 28;
LABEL_20:
    result = (unsigned __int8)result | 2;
    goto LABEL_16;
  }
  v2 = 1;
  v3 = 0;
  v5 = 1;
  result = 1;
  v7 = 1;
  v8 = 1;
  v9 = 0;
  v10 = 128;
  while ( 1 )
  {
    ++v3;
    ++v9;
    v11 = *a1 & v10;
    v10 >>= 1;
    if ( v11 )
      v2 ^= 1u;
    v12 = v2;
    if ( v3 == 8 )
    {
      ++a1;
      v3 = 0;
      v10 = 128;
    }
    v13 = (unsigned __int8)(v2 ^ v7);
    v2 = result;
    if ( a2 == v9 )
      break;
    result = v5;
    v7 = v8;
    v5 = v13;
    v8 = v12;
  }
  if ( result )
    result = 16;
  if ( v5 )
    result = (unsigned __int8)result | 8;
  if ( v12 != v7 )
    result = (unsigned __int8)result | 4;
  if ( v8 )
    goto LABEL_20;
LABEL_16:
  if ( v12 )
    return (unsigned __int8)result | 1;
  return result;
}

//----- (00097AF0) --------------------------------------------------------
int __fastcall POWER_CRC16(int a1, int a2)
{
  int v2; // r3
  int v3; // r1
  int v4; // r2
  int v5; // r12
  int v6; // t1
  int v7; // r0

  if ( !a2 )
    return 0xFFFF;
  v2 = 255;
  v3 = a1 + (unsigned __int16)(a2 - 1);
  v4 = a1 - 1;
  v5 = 255;
  do
  {
    v6 = *(unsigned __int8 *)++v4;
    v7 = (v2 ^ v6) + 968984;
    v2 = chCRCHTalbe[v2 ^ v6] ^ v5;
    v5 = *(unsigned __int8 *)(v7 + 768);
  }
  while ( v3 != v4 );
  return v2 | (v5 << 8);
}
// ECB18: using guessed type unsigned __int8 chCRCHTalbe[256];

//----- (00097B4C) --------------------------------------------------------
int __fastcall sub_97B4C(_DWORD *a1, _DWORD *a2, char *s2)
{
  int v3; // r3
  int v4; // r5
  char *v5; // r12
  int v6; // t1
  int v7; // r3
  int v9; // r4
  int v10; // r6

  v3 = (unsigned __int8)*s2;
  if ( *s2 )
  {
    v5 = s2;
    v4 = 5381;
    do
    {
      v4 = (33 * v4) ^ v3;
      v6 = (unsigned __int8)*++v5;
      v3 = v6;
    }
    while ( v6 );
  }
  else
  {
    v4 = 5381;
  }
  if ( !*a2 )
    return 0;
  v7 = (*a2 - 1) & v4;
  v9 = *(_DWORD *)(*a1 + 4 * v7);
  v10 = *a1 + 4 * v7;
  if ( v9 )
  {
    while ( *(_DWORD *)v9 != v4 || strcmp((const char *)(v9 + 12), s2) )
    {
      v10 = v9 + 8;
      v9 = *(_DWORD *)(v9 + 8);
      if ( !v9 )
        return v9;
    }
    return v10;
  }
  return v9;
}

//----- (00097BF8) --------------------------------------------------------
void __fastcall map_deinit_(char **a1)
{
  char *v2; // r3
  char *v3; // r5
  int v4; // r6
  _DWORD *v5; // r0
  _DWORD *v6; // r4

  v2 = *a1;
  v3 = a1[1] - 1;
  v4 = 4 * (_DWORD)v3;
  if ( a1[1] )
  {
    do
    {
      v5 = *(_DWORD **)&v2[v4];
      if ( v5 )
      {
        do
        {
          v6 = (_DWORD *)v5[2];
          free(v5);
          v5 = v6;
        }
        while ( v6 );
        v2 = *a1;
      }
      --v3;
      v4 -= 4;
    }
    while ( v3 != (char *)-1 );
  }
  free(v2);
}

//----- (00097C50) --------------------------------------------------------
int __fastcall map_get_(_DWORD *a1, char *s2)
{
  int result; // r0

  result = sub_97B4C(a1, a1 + 1, s2);
  if ( result )
    return *(_DWORD *)(*(_DWORD *)result + 4);
  return result;
}

//----- (00097C70) --------------------------------------------------------
int __fastcall map_set_(void **a1, char *s2, const void *a3, size_t a4)
{
  const char *v4; // r4
  int v8; // r0
  size_t v10; // r0
  size_t v11; // r10
  int v12; // r5
  int *v13; // r0
  int *v14; // r7
  int v15; // r2
  int v16; // r3
  int v17; // t1
  char *v18; // r0
  char *v19; // r3
  int v20; // r12
  char *v21; // r0
  int v22; // r5
  size_t v23; // r9
  char *v24; // r12
  _DWORD *v25; // r4
  _DWORD *v26; // r3
  _DWORD *v27; // t1
  _DWORD *v28; // r1
  void *v29; // r0
  void *v30; // r8
  char *v31; // r2
  _DWORD *v32; // r1
  int v33; // r3
  int v34; // r12

  v4 = s2;
  v8 = sub_97B4C(a1, a1 + 1, s2);
  if ( v8 )
  {
    memcpy(*(void **)(*(_DWORD *)v8 + 4), a3, a4);
    return 0;
  }
  v10 = strlen(v4);
  v11 = v10 + 1;
  v12 = (~(_BYTE)v10 & 3) + v10 + 1;
  v13 = (int *)malloc(a4 + 12 + v12);
  v14 = v13;
  if ( !v13 )
    return -1;
  memcpy(v13 + 3, v4, v11);
  v15 = *(unsigned __int8 *)v4;
  v16 = 5381;
  if ( *v4 )
  {
    do
    {
      v16 = (33 * v16) ^ v15;
      v17 = *(unsigned __int8 *)++v4;
      v15 = v17;
    }
    while ( v17 );
  }
  *v14 = v16;
  v18 = (char *)v14 + v12 + 12;
  v14[1] = (int)v18;
  memcpy(v18, a3, a4);
  v19 = (char *)a1[2];
  v20 = (int)a1[1];
  if ( (unsigned int)v19 < v20 )
  {
    v31 = (char *)*a1;
    goto LABEL_24;
  }
  v21 = (char *)*a1;
  if ( v20 )
  {
    v22 = 2 * v20;
    v23 = 8 * v20;
  }
  else
  {
    v23 = 4;
    v22 = 1;
  }
  v24 = &v21[4 * v20];
  v25 = 0;
  while ( v21 != v24 )
  {
    v27 = (_DWORD *)*((_DWORD *)v24 - 1);
    v24 -= 4;
    v26 = v27;
    if ( v27 )
    {
      while ( 1 )
      {
        v28 = (_DWORD *)v26[2];
        v26[2] = v25;
        v25 = v26;
        if ( !v28 )
          break;
        v26 = v28;
      }
      v25 = v26;
    }
  }
  v29 = realloc(v21, v23);
  v30 = v29;
  if ( v29 )
  {
    *a1 = v29;
    a1[1] = (void *)v22;
    memset(v29, 0, v23);
    if ( !v25 )
    {
      v31 = (char *)*a1;
      v20 = (int)a1[1];
LABEL_22:
      v19 = (char *)a1[2];
LABEL_24:
      v34 = (v20 - 1) & *v14;
      v14[2] = *(_DWORD *)&v31[4 * v34];
      *(_DWORD *)&v31[4 * v34] = v14;
      a1[2] = v19 + 1;
      return 0;
    }
    goto LABEL_19;
  }
  if ( *a1 )
  {
    memset(*a1, 0, 4 * (_DWORD)a1[1]);
    if ( v25 )
    {
LABEL_19:
      v31 = (char *)*a1;
      v20 = (int)a1[1];
      do
      {
        v32 = (_DWORD *)v25[2];
        v33 = *v25 & (v20 - 1);
        v25[2] = *(_DWORD *)&v31[4 * v33];
        *(_DWORD *)&v31[4 * v33] = v25;
        v25 = v32;
      }
      while ( v32 );
      if ( v30 )
        goto LABEL_22;
    }
  }
  free(v14);
  return -1;
}

//----- (00097E74) --------------------------------------------------------
void __fastcall map_remove_(_DWORD *a1, char *s2)
{
  void **v3; // r0
  void **v4; // r3
  void *v5; // r0

  v3 = (void **)sub_97B4C(a1, a1 + 1, s2);
  v4 = v3;
  if ( v3 )
  {
    v5 = *v3;
    *v4 = (void *)*((_DWORD *)*v4 + 2);
    free(v5);
    --a1[2];
  }
}

//----- (00097EB0) --------------------------------------------------------
_DWORD *__fastcall map_iter_(_DWORD *result)
{
  *result = -1;
  result[1] = 0;
  return result;
}

//----- (00097EC0) --------------------------------------------------------
unsigned int __fastcall map_next_(_DWORD *a1, unsigned int *a2)
{
  unsigned int v2; // r3
  unsigned int v3; // r3
  unsigned int v5; // lr
  unsigned int v6; // r2
  int v7; // r12
  unsigned int v8; // r3

  v2 = a2[1];
  if ( v2 )
  {
    v3 = *(_DWORD *)(v2 + 8);
    a2[1] = v3;
    if ( v3 )
      return v3 + 12;
  }
  v5 = a1[1];
  v6 = *a2 + 1;
  v7 = 4 * v6;
  while ( 1 )
  {
    if ( v6 >= v5 )
    {
      *a2 = v6;
      return 0;
    }
    v8 = *(_DWORD *)(*a1 + v7);
    v7 += 4;
    a2[1] = v8;
    if ( v8 )
      break;
    ++v6;
  }
  *a2 = v6;
  return v8 + 12;
}

//----- (00097F38) --------------------------------------------------------
int __fastcall statusServiceThread(int a1)
{
  char *v2; // r9
  int v3; // r7
  ssize_t v4; // r3
  int v5; // r11
  int v6; // r4
  int v7; // r4
  int v8; // r4
  int v9; // r4
  int v10; // r4
  int v11; // r0
  unsigned int v12; // r4
  size_t v13; // r0
  ssize_t v14; // r0
  int v15; // r0
  int v16; // r12
  int v17; // r3
  int v18; // r1
  int v20; // r12
  int v21; // r5
  ssize_t v22; // r8
  int v23; // r0
  int v24; // r2
  char *v25; // [sp+Ch] [bp-7040h]
  struct sockaddr *v26; // [sp+14h] [bp-7038h]
  int v27; // [sp+18h] [bp-7034h]
  char v28[4]; // [sp+20h] [bp-702Ch] BYREF
  socklen_t addr_len; // [sp+24h] [bp-7028h] BYREF
  char needle[8]; // [sp+28h] [bp-7024h] BYREF
  _DWORD optval[2]; // [sp+30h] [bp-701Ch] BYREF
  struct sockaddr addr; // [sp+38h] [bp-7014h] BYREF
  char s[4096]; // [sp+48h] [bp-7004h] BYREF
  char v34[4088]; // [sp+1048h] [bp-6004h] BYREF
  char v35[10240]; // [sp+2048h] [bp-5004h] BYREF
  char v36[10244]; // [sp+4848h] [bp-2804h] BYREF

  optval[0] = 3;
  optval[1] = 0;
  v2 = v35;
  memset(s, 0, sizeof(s));
  strcpy(v28, "\r\n");
  addr_len = 0;
  v3 = 0;
  strcpy(needle, "\r\n\r\n");
  memset(v35, 0, sizeof(v35));
  do
  {
    v5 = (unsigned __int8)ExitServer;
    if ( ExitServer )
      goto LABEL_6;
    v4 = recvfrom(a1, v2, 10239 - v3, 0, &addr, &addr_len);
    v3 += v4;
    if ( v4 <= 0 )
    {
      close(a1);
      V_LOCK();
      logfmt_raw(v36, 0x1000u, v5, ":statusServiceThread recvfrom<=0");
      V_UNLOCK();
      v20 = 52;
LABEL_25:
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/common/general/http.c",
        149,
        "statusServiceThread",
        19,
        v20,
        20,
        v36);
      return v5;
    }
    v2 = &v35[v3];
    if ( v3 > 10238 )
    {
      close(a1);
      V_LOCK();
      logfmt_raw(v36, 0x1000u, v5, "BUFSIZE is too small!");
      V_UNLOCK();
      v20 = 60;
      goto LABEL_25;
    }
  }
  while ( !strstr(v35, needle) );
  V_LOCK();
  logfmt_raw(v36, 0x1000u, v5, "find http request end flag!");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/common/general/http.c",
    149,
    "statusServiceThread",
    19,
    67,
    20,
    v36);
LABEL_6:
  V_LOCK();
  logfmt_raw(v36, 0x1000u, 0, "get http=%s", v35);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/common/general/http.c",
    149,
    "statusServiceThread",
    19,
    72,
    20,
    v36);
  if ( v35[0] == 71 && v35[1] == 69 && v35[2] == 84 && v35[3] == 32 )
  {
    if ( setsockopt(a1, 1, 21, optval, 8u) )
    {
      close(a1);
      V_LOCK();
      logfmt_raw(v36, 0x1000u, 0, "setsockopt SO_SNDTIMEO failed");
      V_UNLOCK();
      v23 = g_zc;
      v24 = 87;
      goto LABEL_38;
    }
    if ( setsockopt(a1, 1, 20, optval, 8u) )
    {
      close(a1);
      V_LOCK();
      logfmt_raw(v36, 0x1000u, 0, "setsockopt SO_RCVTIMEO failed");
      V_UNLOCK();
      v23 = g_zc;
      v24 = 95;
      goto LABEL_38;
    }
    if ( http_test_case )
    {
      if ( !((int (__fastcall *)(char *, char *, int))http_test_case)(v35, s, 4096) )
        goto LABEL_14;
      close(a1);
      V_LOCK();
      logfmt_raw(v36, 0x1000u, 0, "statusServiceThread exit for Error cmd!");
      V_UNLOCK();
      v23 = g_zc;
      v24 = 108;
LABEL_38:
      zlog(
        v23,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/common/general/http.c",
        149,
        "statusServiceThread",
        19,
        v24,
        20,
        v36);
      return 0;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v36, 0x1000u, 0, "No 6060 test case found.");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/common/general/http.c",
        149,
        "statusServiceThread",
        19,
        103,
        20,
        v36);
LABEL_14:
      v26 = (struct sockaddr *)strlen(s);
      v6 = sprintf(v36, "HTTP/1.0  200  OK%s", v28);
      v7 = v6 + sprintf(&v36[v6], "Server: SearchFreqServer%s", v28);
      v8 = v7 + sprintf(&v36[v7], "Cache-Control: no-cache%s", v28);
      v9 = v8 + sprintf(&v36[v8], "Pragma: no-cache%s", v28);
      v10 = v9 + sprintf(&v36[v9], "Content-Type: text/plain%s", v28);
      v11 = sprintf(&v36[v10], "Content-Length: %d%s", v26, v28);
      sprintf(&v36[v10 + v11], "Connection: Keep-Alive%s", needle);
      V_LOCK();
      logfmt_raw(v34, 0x1000u, 0, "send http response...\n");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/common/general/http.c",
        149,
        "statusServiceThread",
        19,
        123,
        20,
        v34);
      v12 = (unsigned __int8)ExitServer;
      if ( !ExitServer )
      {
        v13 = strlen(v36);
        do
        {
          v14 = send(a1, &v36[v12], v13 - v12, 0x4000);
          if ( v14 == -1 )
          {
            if ( *_errno_location() != 11 )
            {
LABEL_21:
              close(a1);
              V_LOCK();
              logfmt_raw(v34, 0x1000u, 0, "statusServiceThread send http response error");
              V_UNLOCK();
              v15 = g_zc;
              v16 = 139;
              LOWORD(v17) = (unsigned __int16)"statusServiceThread";
              LOWORD(v18) = (unsigned __int16)"/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/bui"
                                              "ldroot/tmp/release/build/godminer-origin_godminer-new/common/general/http.c";
              v25 = v34;
              goto LABEL_23;
            }
            V_LOCK();
            logfmt_raw(v34, 0x1000u, 0, &unk_ECFCC);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godmine"
              "r-origin_godminer-new/common/general/http.c",
              149,
              "statusServiceThread",
              19,
              132,
              20,
              v34);
            usleep((__useconds_t)"rl_kda_2110");
          }
          else
          {
            v12 += v14;
            if ( v14 <= 0 )
              goto LABEL_21;
          }
          v13 = strlen(v36);
        }
        while ( v13 > v12 && !ExitServer );
      }
      V_LOCK();
      logfmt_raw(v34, 0x1000u, 0, "send http data...");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/common/general/http.c",
        149,
        "statusServiceThread",
        19,
        153,
        20,
        v34);
      v21 = 0;
      do
      {
        v22 = send(a1, &s[v21], (size_t)v26 - v21, 0);
        V_LOCK();
        logfmt_raw(v34, 0x1000u, 0, "send http data ret=%d", v22);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/common/general/http.c",
          149,
          "statusServiceThread",
          19,
          159,
          20,
          v34);
        if ( v22 <= 0 )
        {
          v27 = v21;
          V_LOCK();
          logfmt_raw(v34, 0x1000u, 0, "statusServiceThread send http data error");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-"
            "origin_godminer-new/common/general/http.c",
            149,
            "statusServiceThread",
            19,
            163,
            20,
            v34);
          goto LABEL_33;
        }
        v21 += v22;
      }
      while ( (int)v26 > v21 && !ExitServer );
      v27 = v21;
LABEL_33:
      V_LOCK();
      logfmt_raw(v34, 0x1000u, 0, "one client disconnected!");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/common/general/http.c",
        149,
        "statusServiceThread",
        19,
        173,
        20,
        v34);
      close(a1);
      return v27;
    }
  }
  else
  {
    close(a1);
    V_LOCK();
    logfmt_raw(v36, 0x1000u, 0, "statusServiceThread not support http command");
    V_UNLOCK();
    v16 = 79;
    LOWORD(v17) = -13032;
    LOWORD(v18) = -12936;
    v15 = g_zc;
    v25 = v36;
LABEL_23:
    HIWORD(v17) = (unsigned int)"statusServiceThread" >> 16;
    HIWORD(v18) = (unsigned int)"/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/rel"
                                "ease/build/godminer-origin_godminer-new/common/general/http.c" >> 16;
    zlog(v15, v18, 149, v17, 19, v16, 20, v25);
    return 0;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7A0: using guessed type char ExitServer;
// 11A7A4: using guessed type _UNKNOWN *http_test_case;
// 11A7AC: using guessed type int g_zc;

//----- (000987F0) --------------------------------------------------------
int httpListenThread()
{
  int v0; // r0
  int v1; // r0
  int v2; // r4
  int v3; // r10
  int v5; // r0
  int v6; // r2
  socklen_t addr_len; // [sp+1Ch] [bp-1028h] BYREF
  struct sockaddr v8; // [sp+20h] [bp-1024h] BYREF
  struct sockaddr addr; // [sp+30h] [bp-1014h] BYREF
  char v10[4100]; // [sp+40h] [bp-1004h] BYREF

  do
  {
    v0 = socket(2, 1, 6);
    listen_sockfd = v0;
    if ( v0 < 0 )
    {
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, 970916);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/common/general/http.c",
        149,
        "httpListenThread",
        16,
        198,
        80,
        v10);
      sleep(0xAu);
    }
    else
    {
      *(_DWORD *)&v8.sa_family = -1407778814;
      memset(&v8.sa_data[2], 0, 12);
      if ( bind(v0, &v8, 0x10u) < 0 )
      {
        V_LOCK();
        logfmt_raw(v10, 0x1000u, 0, 970964);
        V_UNLOCK();
        v5 = g_zc;
        v6 = 211;
      }
      else
      {
        if ( listen(listen_sockfd, 100) >= 0 )
          break;
        V_LOCK();
        logfmt_raw(v10, 0x1000u, 0, 971012);
        V_UNLOCK();
        v5 = g_zc;
        v6 = 222;
      }
      zlog(
        v5,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/common/general/http.c",
        149,
        "httpListenThread",
        16,
        v6,
        80,
        v10);
      close(listen_sockfd);
      listen_sockfd = -1;
      sleep(0xAu);
    }
  }
  while ( !ExitServer );
  V_LOCK();
  logfmt_raw(v10, 0x1000u, 0, 971056);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/common/general/http.c",
    149,
    "httpListenThread",
    16,
    235,
    60,
    v10);
  if ( !ExitServer )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        usleep(0x2710u);
        addr_len = 16;
        v1 = accept(listen_sockfd, &addr, &addr_len);
        v2 = v1;
        if ( v1 != -1 )
          break;
        if ( ExitServer )
          goto LABEL_10;
      }
      v3 = (unsigned __int8)ExitServer;
      if ( ExitServer )
        break;
      V_LOCK();
      logfmt_raw(v10, 0x1000u, v3, 971084, v2);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/common/general/http.c",
        149,
        "httpListenThread",
        16,
        257,
        20,
        v10);
      statusServiceThread(v2);
      if ( ExitServer )
        goto LABEL_10;
    }
    close(v1);
  }
LABEL_10:
  close(listen_sockfd);
  listen_sockfd = -1;
  return 0;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 987F0: using guessed type int httpListenThread();
// 10784C: using guessed type int listen_sockfd;
// 11A7A0: using guessed type char ExitServer;
// 11A7AC: using guessed type int g_zc;

//----- (00098AC8) --------------------------------------------------------
int start_http_thread()
{
  int v0; // r10
  pthread_t v2; // [sp+10h] [bp-1028h] BYREF
  pthread_attr_t attr; // [sp+14h] [bp-1024h] BYREF
  char v4[4096]; // [sp+38h] [bp-1000h] BYREF

  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, 971116);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/common/general/http.c",
    149,
    "start_http_thread",
    17,
    273,
    60,
    v4);
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 0x200000u);
  v0 = pthread_create(&v2, &attr, (void *(*)(void *))httpListenThread, 0);
  pthread_detach(v2);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, 971140, v0);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-o"
           "rigin_godminer-new/common/general/http.c",
           149,
           "start_http_thread",
           17,
           280,
           60,
           v4);
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 987F0: using guessed type int httpListenThread();
// 11A7AC: using guessed type int g_zc;

//----- (00098BCC) --------------------------------------------------------
int log_init()
{
  char *v0; // r12
  int v1; // r5
  int v3; // r0
  int v4; // r0
  int v5; // r0
  int v6; // r0

  v0 = (char *)opt_zlog_conf_file;
  if ( !opt_zlog_conf_file )
  {
    v0 = (char *)malloc(0xFu);
    if ( v0 )
      strcpy(v0, "/etc/zlog.conf");
    opt_zlog_conf_file = (int)v0;
  }
  v1 = zlog_init(v0);
  if ( v1 )
  {
    v1 = -1;
    puts("zlog init failed");
  }
  else
  {
    g_zc = zlog_get_category("miner_zc");
    if ( g_zc )
    {
      g_temp_zc = zlog_get_category("miner_temp_zc");
      if ( g_temp_zc )
      {
        g_fan_zc = zlog_get_category("miner_fan_zc");
        if ( g_fan_zc )
        {
          g_hash_zc = zlog_get_category("miner_hash_zc");
          if ( g_hash_zc )
          {
            puts("zlog init OK!");
          }
          else
          {
            v1 = -4;
            v6 = puts("zlog get miner_hash_zc category fail");
            zlog_fini(v6);
          }
        }
        else
        {
          v1 = -3;
          v5 = puts("zlog get miner_fan_zc category fail");
          zlog_fini(v5);
        }
      }
      else
      {
        v1 = -3;
        v3 = puts("zlog get miner_temp_zc category fail");
        zlog_fini(v3);
      }
    }
    else
    {
      v1 = -2;
      v4 = puts("zlog get miner_zc category fail");
      zlog_fini(v4);
    }
  }
  return v1;
}
// 1E4D8: using guessed type int __fastcall zlog_init(_DWORD);
// 1E4F0: using guessed type int __fastcall zlog_get_category(_DWORD);
// 1E964: using guessed type int __fastcall zlog_fini(_DWORD);
// 11A7A8: using guessed type int opt_zlog_conf_file;
// 11A7AC: using guessed type int g_zc;
// 11A7B0: using guessed type int g_temp_zc;
// 11A7B4: using guessed type int g_fan_zc;
// 11A7B8: using guessed type int g_hash_zc;

//----- (00098D14) --------------------------------------------------------
int __fastcall log_uninit(int a1)
{
  if ( g_zc || g_temp_zc || g_fan_zc || g_hash_zc )
  {
    zlog_fini(a1);
    g_hash_zc = 0;
    g_temp_zc = 0;
    g_zc = 0;
    puts("zlog uninit!");
  }
  return 0;
}
// 1E964: using guessed type int __fastcall zlog_fini(_DWORD);
// 11A7AC: using guessed type int g_zc;
// 11A7B0: using guessed type int g_temp_zc;
// 11A7B4: using guessed type int g_fan_zc;
// 11A7B8: using guessed type int g_hash_zc;

//----- (00098D7C) --------------------------------------------------------
int log_reload()
{
  if ( !g_zc || !g_temp_zc || !g_fan_zc || !g_hash_zc )
    return 0;
  zlog_reload(opt_zlog_conf_file);
  puts("zlog reload!");
  return 0;
}
// 1E9C4: using guessed type int __fastcall zlog_reload(_DWORD);
// 11A7A8: using guessed type int opt_zlog_conf_file;
// 11A7AC: using guessed type int g_zc;
// 11A7B0: using guessed type int g_temp_zc;
// 11A7B4: using guessed type int g_fan_zc;
// 11A7B8: using guessed type int g_hash_zc;

//----- (00098DDC) --------------------------------------------------------
int logfmt_raw(char *a1, size_t n, int a3, ...)
{
  char *v3; // r9
  int v4; // r5
  const char **v5; // r4
  int v6; // r6
  unsigned int v7; // r8
  int *v8; // r12
  int v9; // r11
  const char *v10; // r8
  int result; // r0
  const char *v12; // r1
  const char *v13; // r12
  double v14; // [sp+30h] [bp-1014h]
  char s[4096]; // [sp+40h] [bp-1004h] BYREF
  va_list va; // [sp+106Ch] [bp+28h] BYREF

  va_start(va, a3);
  v3 = a1;
  memset(a1, 0, n);
  memset(s, 0, sizeof(s));
  if ( dword_11A7BC <= 0 )
  {
    va_copy(v5, va);
  }
  else
  {
    v4 = 0;
    va_copy(v5, va);
    v6 = 0;
    while ( 2 )
    {
      v7 = ((unsigned int)v5 + 7) & 0xFFFFFFF8;
      v5 = (const char **)(v7 + 32);
      v8 = (int *)(v7 + 16);
      v9 = *(_DWORD *)(v7 + 8);
      v10 = *(const char **)v7;
      result = *v8;
      v14 = *(double *)v8;
      switch ( v9 )
      {
        case 0:
          if ( strchr((const char *)LODWORD(v14), 32)
            || !strcmp((const char *)LODWORD(v14), "true") && strlen((const char *)LODWORD(v14)) == 4 )
          {
            v6 += sprintf(&v3[v6], "%s=\"%s\" ", v10, (const char *)LODWORD(v14));
          }
          else
          {
            v6 += sprintf(&v3[v6], "%s=%s ", v10, (const char *)LODWORD(v14));
          }
          goto LABEL_5;
        case 1:
          v6 += sprintf(&v3[v6], "%s=%lf ", v10, v14);
          goto LABEL_5;
        case 2:
          v13 = "false";
          if ( LOBYTE(v14) )
            v13 = "true";
          v6 += sprintf(&v3[v6], "%s=%s ", v10, v13);
          goto LABEL_5;
        case 3:
          v6 += sprintf(&v3[v6], "%s=%lld ", v10, HIDWORD(v14), v14);
LABEL_5:
          if ( dword_11A7BC > ++v4 )
            continue;
          v3 += v6;
          break;
        default:
          return result;
      }
      break;
    }
  }
  vsprintf(s, *v5, v5 + 1);
  if ( strchr(s, 32) )
    LOWORD(v12) = -11536;
  else
    LOWORD(v12) = -11524;
  HIWORD(v12) = 14;
  result = sprintf(v3, v12, s);
  dword_11A7BC = 0;
  return result;
}
// 98E8C: control flows out of bounds to 98E90
// 11A7BC: using guessed type int dword_11A7BC;

//----- (00099020) --------------------------------------------------------
int V_LOCK()
{
  return pthread_mutex_lock(&stru_11A7C0);
}

//----- (0009902C) --------------------------------------------------------
int V_UNLOCK()
{
  return pthread_mutex_unlock(&stru_11A7C0);
}

//----- (00099038) --------------------------------------------------------
_DWORD *__fastcall V_STR(_DWORD *a1, char *s, const char *a3)
{
  size_t v6; // r7

  ++dword_11A7BC;
  v6 = strlen(s);
  a1[6] = strlen(a3);
  *a1 = s;
  a1[1] = v6;
  a1[2] = 0;
  a1[3] = 0;
  a1[5] = 0;
  a1[7] = 0;
  a1[4] = a3;
  return a1;
}
// 11A7BC: using guessed type int dword_11A7BC;

//----- (0009909C) --------------------------------------------------------
int __fastcall V_FLOAT(int a1, char *s)
{
  __int64 v2; // d0
  size_t v5; // r0

  ++dword_11A7BC;
  v5 = strlen(s);
  *(_QWORD *)(a1 + 16) = v2;
  *(_DWORD *)(a1 + 4) = v5;
  *(_DWORD *)a1 = s;
  *(_DWORD *)(a1 + 8) = 1;
  *(_DWORD *)(a1 + 24) = 0;
  return a1;
}
// 990CC: variable 'v2' is possibly undefined
// 11A7BC: using guessed type int dword_11A7BC;

//----- (000990F4) --------------------------------------------------------
int __fastcall V_BOOL(int a1, char *s, char a3)
{
  ++dword_11A7BC;
  *(_DWORD *)(a1 + 4) = strlen(s);
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)a1 = s;
  *(_QWORD *)(a1 + 8) = 2;
  *(_DWORD *)(a1 + 20) = 0;
  *(_BYTE *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  return a1;
}
// 11A7BC: using guessed type int dword_11A7BC;

//----- (00099150) --------------------------------------------------------
int __fastcall V_INT(int a1, char *s, __int64 a3)
{
  ++dword_11A7BC;
  *(_DWORD *)(a1 + 4) = strlen(s);
  *(_DWORD *)a1 = s;
  *(_QWORD *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 8) = 3;
  *(_DWORD *)(a1 + 24) = 0;
  return a1;
}
// 11A7BC: using guessed type int dword_11A7BC;

//----- (000991A4) --------------------------------------------------------
void *new_observable_subject()
{
  return calloc(1u, 0x404u);
}

//----- (000991B4) --------------------------------------------------------
int __fastcall subject_observe(int result, int a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(result + 1024);
  *(_DWORD *)(result + 4 * v2) = a2;
  *(_DWORD *)(result + 1024) = v2 + 1;
  return result;
}

//----- (000991C8) --------------------------------------------------------
int __fastcall subject_notify_all(int result, int a2)
{
  int v3; // r6
  int v4; // r5
  int v5; // r4
  int (__fastcall *v6)(int); // t1

  if ( *(int *)(result + 1024) > 0 )
  {
    v3 = result;
    v4 = result - 4;
    v5 = 0;
    do
    {
      v6 = *(int (__fastcall **)(int))(v4 + 4);
      v4 += 4;
      result = v6(a2);
      ++v5;
    }
    while ( *(_DWORD *)(v3 + 1024) > v5 );
  }
  return result;
}

//----- (00099208) --------------------------------------------------------
int __fastcall send_line(int a1, char *s)
{
  int v3; // r9
  size_t v5; // r0
  int v6; // r8
  int v7; // r3
  int v8; // r8
  signed int v9; // r7
  fd_set *p_tv_usec; // r3
  ssize_t v11; // r0
  int v13; // [sp+14h] [bp-1010h]
  struct timeval timeout; // [sp+18h] [bp-100Ch] BYREF
  fd_set writefds; // [sp+20h] [bp-1004h] BYREF

  if ( a1 == -1 )
  {
    V_LOCK();
    logfmt_raw((char *)&writefds, 0x1000u, 0, 971548);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/common/general/socket.c",
      151,
      "send_line",
      9,
      12,
      20,
      &writefds);
    return 0;
  }
  else
  {
    v3 = 0;
    v5 = strlen(s);
    v6 = a1 + 31;
    if ( a1 >= 0 )
      v6 = a1;
    LOBYTE(v7) = a1 & 0x1F;
    if ( a1 <= 0 )
      v7 = -(-a1 & 0x1F);
    v8 = v6 >> 5;
    v9 = v5 + 1;
    v13 = 1 << v7;
    s[v5] = 10;
    while ( 1 )
    {
      timeout.tv_sec = 0;
      timeout.tv_usec = 0;
      p_tv_usec = (fd_set *)&timeout.tv_usec;
      do
      {
        p_tv_usec->__fds_bits[1] = 0;
        p_tv_usec = (fd_set *)((char *)p_tv_usec + 4);
      }
      while ( &writefds.__fds_bits[31] != (__fd_mask *)p_tv_usec );
      writefds.__fds_bits[v8] |= v13;
      if ( select(a1 + 1, 0, &writefds, 0, &timeout) <= 0 )
        break;
      v11 = send(a1, &s[v3], v9, 0x4000);
      if ( v11 < 0 )
      {
        if ( *_errno_location() != 11 )
          return 0;
      }
      else
      {
        v9 -= v11;
        v3 += v11;
        if ( v9 <= 0 )
          return 1;
      }
    }
    return 0;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00099390) --------------------------------------------------------
int __fastcall socket_full(int a1, __time_t a2)
{
  int v2; // r4
  fd_set *p_tv_usec; // r3
  struct timeval timeout; // [sp+10h] [bp-108Ch] BYREF
  fd_set readfds; // [sp+18h] [bp-1084h] BYREF
  char v7[4100]; // [sp+98h] [bp-1004h] BYREF

  if ( a1 == -1 )
  {
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, 971548);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/common/general/socket.c",
      151,
      "socket_full",
      11,
      47,
      20,
      v7);
    return 0;
  }
  else
  {
    v2 = a1;
    p_tv_usec = (fd_set *)&timeout.tv_usec;
    do
    {
      p_tv_usec->__fds_bits[1] = 0;
      p_tv_usec = (fd_set *)((char *)p_tv_usec + 4);
    }
    while ( p_tv_usec != (fd_set *)&readfds.__fds_bits[31] );
    timeout.tv_usec = 0;
    timeout.tv_sec = a2;
    LOBYTE(a1) = a1 & 0x1F;
    if ( v2 <= 0 )
      a1 = -(-v2 & 0x1F);
    readfds.__fds_bits[v2 / 32] |= 1 << a1;
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, 971716);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/common/general/socket.c",
      151,
      "socket_full",
      11,
      55,
      20,
      v7);
    if ( select(v2 + 1, &readfds, 0, 0, &timeout) <= 0 )
    {
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, 971768);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/common/general/socket.c",
        151,
        "socket_full",
        11,
        60,
        20,
        v7);
      return 0;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, 971744);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/common/general/socket.c",
        151,
        "socket_full",
        11,
        57,
        20,
        v7);
      return 1;
    }
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (000995AC) --------------------------------------------------------
int __fastcall keep_sockalive(int a1)
{
  int optval; // [sp+Ch] [bp-Ch] BYREF
  int v4; // [sp+10h] [bp-8h] BYREF
  int v5; // [sp+14h] [bp-4h] BYREF

  v4 = 45;
  v5 = 30;
  optval = 1;
  setsockopt(a1, 1, 9, &optval, 4u);
  fcntl(a1, 2, 1);
  setsockopt(a1, 6, 1, &optval, 4u);
  setsockopt(a1, 6, 6, &optval, 4u);
  setsockopt(a1, 6, 4, &v4, 4u);
  return setsockopt(a1, 6, 5, &v5, 4u);
}

//----- (00099660) --------------------------------------------------------
int __fastcall task_timer_thread(int a1)
{
  char *v2; // r4
  int v3; // r0
  int result; // r0
  int v5; // r9
  int v6; // r5
  struct timespec *v7; // r6
  struct timespec *v8; // r11
  int v9; // r10
  struct timespec *v10; // r9
  int v11; // r4
  void (__fastcall *v12)(int); // r1
  int v13; // r5
  int v14; // r9
  struct timespec *v15; // r1
  int v16; // t1
  int v17; // r4
  char v19[4100]; // [sp+20h] [bp-1004h] BYREF

  v2 = (char *)calloc(1u, 0x40u);
  snprintf(v2, 0x40u, "%.10s_%d", 971796, 0);
  V_LOCK();
  v3 = syscall(224);
  logfmt_raw(v19, 0x1000u, 0, 914180, v2, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_g"
    "odminer-new/common/general/task_timer.c",
    155,
    "task_timer_thread",
    17,
    44,
    40,
    v19);
  for ( result = prctl(15, v2); ; result = usleep(1000 * v6) )
  {
    v5 = *(_DWORD *)(a1 + 6144);
    if ( v5 > 0 )
    {
      v7 = (struct timespec *)a1;
      v8 = (struct timespec *)a1;
      v9 = a1;
      v10 = (struct timespec *)(a1 + 16 * v5);
      do
      {
        while ( 1 )
        {
          clock_gettime(1, v7 + 257);
          v11 = 1000 * (v7[257].tv_sec - v7[256].tv_sec) + (v7[257].tv_nsec - v7[256].tv_nsec) / 1000000;
          if ( *(_DWORD *)(v9 + 1024) <= v11 )
            break;
          v7 += 2;
          v9 += 4;
          if ( v7 == v10 )
            goto LABEL_8;
        }
        clock_gettime(1, v7 + 256);
        v7 += 2;
        v12 = *(void (__fastcall **)(int))v9;
        v9 += 4;
        v12(v11);
      }
      while ( v7 != v10 );
LABEL_8:
      v13 = 0x7FFFFFFF;
      v14 = a1 + 1020;
      do
      {
        v15 = v8 + 257;
        v16 = *(_DWORD *)(v14 + 4);
        v14 += 4;
        v8 += 2;
        clock_gettime(1, v15);
        result = 1000 * (v8[255].tv_sec - v8[254].tv_sec) + (v8[255].tv_nsec - v8[254].tv_nsec) / 1000000;
        v17 = v16 - result;
        if ( v13 >= v16 - result )
          v13 = v17;
      }
      while ( v7 != v8 );
      v6 = v13 & ~(v13 >> 31);
    }
    else
    {
      v6 = 0x7FFFFFFF;
    }
    if ( !*(_BYTE *)(a1 + 6148) )
      break;
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00099878) --------------------------------------------------------
void *new_task_timer()
{
  return calloc(1u, 0x180Cu);
}

//----- (00099884) --------------------------------------------------------
int __fastcall add_new_task(int a1, int a2, int a3)
{
  int v3; // r4
  int v4; // r3
  int result; // r0

  v3 = a1 + 4096;
  v4 = *(_DWORD *)(a1 + 6144);
  *(_DWORD *)(a1 + 4 * v4) = a2;
  *(_DWORD *)(a1 + 4 * v4 + 1024) = a3;
  result = clock_gettime(1, (struct timespec *)(a1 + 16 * (v4 + 128)));
  ++*(_DWORD *)(v3 + 2048);
  return result;
}

//----- (000998C0) --------------------------------------------------------
int __fastcall _exec_all_task(int result)
{
  int v1; // r8
  int (__fastcall **v2)(int); // r8
  int (__fastcall **v3)(int); // r7
  struct timespec *v4; // r6
  int tv_nsec; // r3
  struct timespec *v6; // r1
  int v7; // r4
  __time_t tv_sec; // lr
  int v9; // r4
  int (__fastcall *v10)(int); // t1

  v1 = *(_DWORD *)(result + 6144);
  if ( v1 > 0 )
  {
    v2 = (int (__fastcall **)(int))(result + 4 * v1);
    v3 = (int (__fastcall **)(int))result;
    v4 = (struct timespec *)(result + 2056);
    do
    {
      clock_gettime(1, v4);
      tv_nsec = v4[-1].tv_nsec;
      v6 = v4 - 1;
      v7 = v4->tv_nsec;
      tv_sec = v4[-1].tv_sec;
      v4 += 2;
      v9 = 1000 * (v4[-2].tv_sec - tv_sec) + (v7 - tv_nsec) / 1000000;
      clock_gettime(1, v6);
      v10 = *v3++;
      result = v10(v9);
    }
    while ( v3 != v2 );
  }
  return result;
}

//----- (00099950) --------------------------------------------------------
int __fastcall start_task_timer(_DWORD *arg)
{
  int v1; // r5
  struct timespec *v3; // r4
  struct timespec *v4; // r5
  struct timespec *v5; // r1

  v1 = arg[1536];
  *((_BYTE *)arg + 6148) = 1;
  if ( v1 > 0 )
  {
    v3 = (struct timespec *)(arg + 512);
    v4 = (struct timespec *)&arg[4 * v1 + 512];
    do
    {
      v5 = v3;
      v3 += 2;
      clock_gettime(1, v5);
    }
    while ( v3 != v4 );
  }
  return pthread_create(arg + 1538, 0, (void *(*)(void *))task_timer_thread, arg);
}
// 99660: using guessed type int task_timer_thread();

//----- (000999B0) --------------------------------------------------------
int __fastcall stop_task_timer(int result)
{
  int v1; // r3
  pthread_t v2; // r0
  void *thread_return; // [sp+4h] [bp-Ch] BYREF

  v1 = result + 4096;
  if ( *(_BYTE *)(result + 6148) )
  {
    v2 = *(_DWORD *)(result + 6152);
    *(_BYTE *)(v1 + 2052) = 0;
    return pthread_join(v2, &thread_return);
  }
  return result;
}

//----- (000999E4) --------------------------------------------------------
void __fastcall destroy_task_timer(_DWORD *ptr)
{
  _DWORD *v1; // r3
  pthread_t v3; // r0
  void *thread_return; // [sp+4h] [bp-4h] BYREF

  v1 = ptr + 1024;
  if ( *((_BYTE *)ptr + 6148) )
  {
    v3 = ptr[1538];
    *((_BYTE *)v1 + 2052) = 0;
    pthread_join(v3, &thread_return);
  }
  free(ptr);
}

//----- (00099A24) --------------------------------------------------------
int __fastcall force_exec_all_task(int a1)
{
  void *thread_return; // [sp+4h] [bp-4h] BYREF

  if ( !*(_BYTE *)(a1 + 6148) )
    return _exec_all_task(a1);
  *(_BYTE *)(a1 + 6148) = 0;
  pthread_join(*(_DWORD *)(a1 + 6152), &thread_return);
  _exec_all_task(a1);
  return start_task_timer((_DWORD *)a1);
}

//----- (00099A78) --------------------------------------------------------
int __fastcall _init_pipe_of_queue(int *a1, int a2, int a3)
{
  _DWORD *v4; // r0
  int result; // r0

  v4 = pipe_new(a2, a3);
  *a1 = (int)v4;
  a1[2] = pipe_consumer_new((int)v4);
  result = pipe_producer_new(*a1);
  a1[1] = result;
  return result;
}

//----- (00099AAC) --------------------------------------------------------
void __fastcall _deinit_pipe_of_queue(int *a1)
{
  pipe_free(*a1);
  pipe_consumer_free(a1[2]);
  pipe_producer_free(a1[1]);
}

//----- (00099AD0) --------------------------------------------------------
char *__fastcall queue_new(int a1, int a2)
{
  char *v4; // r4

  v4 = (char *)calloc(1u, 0x60u);
  _init_pipe_of_queue((int *)v4, a1, a2);
  pthread_mutex_init((pthread_mutex_t *)(v4 + 16), 0);
  pthread_condattr_init((pthread_condattr_t *)v4 + 22);
  pthread_condattr_setclock((pthread_condattr_t *)v4 + 22, 1);
  pthread_cond_init((pthread_cond_t *)(v4 + 40), (const pthread_condattr_t *)v4 + 22);
  *((_DWORD *)v4 + 3) = 0;
  v4[92] = 0;
  return v4;
}

//----- (00099B3C) --------------------------------------------------------
void __fastcall queue_free(int a1)
{
  pthread_cond_destroy((pthread_cond_t *)(a1 + 40));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16));
  _deinit_pipe_of_queue((int *)a1);
  free((void *)a1);
}

//----- (00099B68) --------------------------------------------------------
int __fastcall queue_enqueue(int a1, char *a2, int a3)
{
  pthread_mutex_t *v3; // r5

  v3 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  pipe_push(*(_DWORD **)(a1 + 4), a2, a3);
  *(_DWORD *)(a1 + 12) += a3;
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  return pthread_mutex_unlock(v3);
}

//----- (00099BB8) --------------------------------------------------------
void __fastcall queue_dequeue(int a1, char *a2, unsigned int a3)
{
  pthread_mutex_t *mutex; // [sp+14h] [bp-1128h]
  struct __jmp_buf_tag env; // [sp+20h] [bp-111Ch] BYREF
  char v8[4100]; // [sp+138h] [bp-1004h] BYREF

  mutex = (pthread_mutex_t *)(a1 + 16);
  if ( _sigsetjmp(&env, 0) )
  {
    pthread_mutex_unlock(mutex);
    _pthread_unwind_next((__pthread_unwind_buf_t *)&env);
    queue_dequeue_for();
  }
  else
  {
    _pthread_register_cancel((__pthread_unwind_buf_t *)&env);
    pthread_mutex_lock(mutex);
    while ( *(_DWORD *)(a1 + 12) < a3 )
    {
      if ( *(_BYTE *)(a1 + 92) )
      {
        *(_BYTE *)(a1 + 92) = 0;
        goto LABEL_9;
      }
      pthread_cond_wait((pthread_cond_t *)(a1 + 40), mutex);
    }
    if ( a3 != pipe_pop(*(int **)(a1 + 8), a2, a3) )
    {
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, "%s, unkown error", "queue_dequeue");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/common/general/thread_safe_queue.c",
        162,
        "queue_dequeue",
        13,
        81,
        100,
        v8);
      exit(-1);
    }
    *(_DWORD *)(a1 + 12) -= a3;
LABEL_9:
    pthread_mutex_unlock(mutex);
    _pthread_unregister_cancel((__pthread_unwind_buf_t *)&env);
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 99D18: using guessed type int queue_dequeue_for(void);
// 11A7AC: using guessed type int g_zc;

//----- (00099D18) --------------------------------------------------------
int __fastcall queue_dequeue_for(int a1, char *a2, unsigned int a3, int *a4)
{
  pthread_mutex_t *v4; // r7
  int v9; // r12
  int v10; // r1
  int v11; // r4
  struct timespec tp; // [sp+10h] [bp-100Ch] BYREF
  char v14[4100]; // [sp+18h] [bp-1004h] BYREF

  v4 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  clock_gettime(1, &tp);
  v9 = *a4;
  v10 = a4[1] + tp.tv_nsec;
  v11 = 0;
  tp.tv_sec += v10 / 1000000000 + v9;
  tp.tv_nsec = v10 % 1000000000;
  while ( *(_DWORD *)(a1 + 12) < a3 )
  {
    v11 = pthread_cond_timedwait((pthread_cond_t *)(a1 + 40), v4, &tp);
    if ( v11 == 110 )
      goto LABEL_6;
  }
  if ( pipe_pop(*(int **)(a1 + 8), a2, a3) != a3 )
  {
    V_LOCK();
    logfmt_raw(v14, 0x1000u, 0, "%s, unkown error", "queue_dequeue_for");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/common/general/thread_safe_queue.c",
      162,
      "queue_dequeue_for",
      17,
      106,
      100,
      v14);
    exit(-1);
  }
  *(_DWORD *)(a1 + 12) -= a3;
LABEL_6:
  pthread_mutex_unlock(v4);
  return v11;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00099E70) --------------------------------------------------------
int __fastcall queue_clear(int a1)
{
  pthread_mutex_t *v1; // r6
  size_t v3; // r0
  char *v4; // r5
  int v5; // r3
  bool v6; // zf
  char v8[4096]; // [sp+10h] [bp-1000h] BYREF

  v1 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  v3 = pipe_elem_size(*(_DWORD *)a1);
  v4 = (char *)calloc(1u, v3);
  if ( *(int *)(a1 + 12) > 0 )
  {
    do
    {
      if ( pipe_pop(*(int **)(a1 + 8), v4, 1) != 1 )
      {
        V_LOCK();
        logfmt_raw(v8, 0x1000u, 0, "%s, unkown error", "queue_clear");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
          "igin_godminer-new/common/general/thread_safe_queue.c",
          162,
          "queue_clear",
          11,
          121,
          100,
          v8);
        exit(-1);
      }
      v5 = *(_DWORD *)(a1 + 12) - 1;
      v6 = *(_DWORD *)(a1 + 12) == 1;
      *(_DWORD *)(a1 + 12) = v5;
    }
    while ( v5 >= 0 && !v6 );
  }
  free(v4);
  return pthread_mutex_unlock(v1);
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (00099F64) --------------------------------------------------------
int __fastcall queue_try_dequeue(int a1, char *a2, unsigned int a3)
{
  pthread_mutex_t *v3; // r6
  unsigned int v7; // r0
  int v8; // r5
  char v10[4100]; // [sp+10h] [bp-1004h] BYREF

  v3 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  if ( *(_DWORD *)(a1 + 12) < a3 )
  {
    v8 = 0;
  }
  else
  {
    v7 = pipe_pop(*(int **)(a1 + 8), a2, a3);
    if ( v7 != a3 )
    {
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, "%s, unkown error", "queue_try_dequeue");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/common/general/thread_safe_queue.c",
        162,
        "queue_try_dequeue",
        17,
        140,
        100,
        v10);
      exit(-1);
    }
    v8 = 1;
    *(_DWORD *)(a1 + 12) -= v7;
  }
  pthread_mutex_unlock(v3);
  return v8;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0009A04C) --------------------------------------------------------
int __fastcall queue_element_num(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (0009A054) --------------------------------------------------------
int __fastcall queue_force_wakeup(int a1)
{
  pthread_mutex_t *v1; // r5

  v1 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  *(_BYTE *)(a1 + 92) = 1;
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  return pthread_mutex_unlock(v1);
}

//----- (0009A084) --------------------------------------------------------
int __fastcall xxtea_encode(unsigned int *a1, unsigned int a2, int a3)
{
  unsigned int *v4; // r8
  unsigned int v5; // r4
  unsigned int v6; // r5
  unsigned int v7; // r11
  unsigned int *v8; // r9
  int v9; // lr
  unsigned int v10; // r10
  int v11; // r3
  int result; // r0
  char v13[4100]; // [sp+18h] [bp-1004h] BYREF

  if ( a2 <= 1 )
  {
    V_LOCK();
    logfmt_raw(v13, 0x1000u, 0, 972280);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer"
             "-origin_godminer-new/common/general/xxtea.c",
             150,
             "xxtea_encode",
             12,
             24,
             100,
             v13);
  }
  else
  {
    v4 = &a1[a2 - 1];
    v5 = *v4;
    v6 = a2 - 1;
    v7 = 0;
    do
    {
      v8 = a1;
      v9 = 0;
      v7 -= 1640531527;
      v10 = v7 >> 2;
      do
      {
        v11 = *(_DWORD *)(a3 + 4 * (((unsigned __int8)v10 ^ (unsigned __int8)v9++) & 3));
        v5 = (((v11 ^ v5) + (v7 ^ v8[1])) ^ (((4 * v8[1]) ^ (v5 >> 5)) + ((16 * v5) ^ (v8[1] >> 3)))) + *v8;
        *v8++ = v5;
      }
      while ( v9 != v6 );
      result = (16 * v5) ^ (*a1 >> 3);
      v5 = (((v5 ^ *(_DWORD *)(a3 + 4 * (((unsigned __int8)v10 ^ (unsigned __int8)v6) & 3))) + (v7 ^ *a1))
          ^ (((4 * *a1) ^ (v5 >> 5)) + result))
         + *v4;
      *v4 = v5;
    }
    while ( v7 != -1640531527 * (0x34 / a2) - 1253254570 );
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0009A1F4) --------------------------------------------------------
int __fastcall xxtea_decode(unsigned int *a1, unsigned int a2, int a3)
{
  unsigned int v5; // r2
  unsigned int v6; // r3
  unsigned int *v7; // r10
  unsigned int v8; // r11
  unsigned int v9; // r5
  unsigned int v10; // r9
  unsigned int *v11; // r6
  unsigned int v12; // t1
  int v13; // r4
  int v14; // r4
  int result; // r0
  char v16[4100]; // [sp+18h] [bp-1004h] BYREF

  if ( a2 <= 1 )
  {
    V_LOCK();
    logfmt_raw(v16, 0x1000u, 0, 972472);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer"
             "-origin_godminer-new/common/general/xxtea.c",
             150,
             "xxtea_decode",
             12,
             53,
             100,
             v16);
  }
  else
  {
    v5 = -1640531527 * (0x34 / a2 + 6);
    v6 = *a1;
    v7 = &a1[a2 - 1];
    v8 = v5 + 1640531527 * (0x34 / a2) + 1253254570;
    do
    {
      v9 = a2 - 1;
      v10 = v5 >> 2;
      v11 = v7;
      do
      {
        v12 = *--v11;
        v13 = *(_DWORD *)(a3 + 4 * (((unsigned __int8)v10 ^ (unsigned __int8)v9--) & 3));
        v6 = v11[1] - (((v12 ^ v13) + (v5 ^ v6)) ^ (((4 * v6) ^ (v12 >> 5)) + ((16 * v12) ^ (v6 >> 3))));
        v11[1] = v6;
      }
      while ( v9 );
      v14 = v5 ^ v6;
      v5 += 1640531527;
      result = (4 * v6) ^ (*v7 >> 5);
      v6 = *a1 - ((result + ((16 * *v7) ^ (v6 >> 3))) ^ ((*v7 ^ *(_DWORD *)(a3 + 4 * (v10 & 3))) + v14));
      *a1 = v6;
    }
    while ( v5 != v8 );
  }
  return result;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0009A378) --------------------------------------------------------
int __fastcall data_enc(unsigned int *a1, unsigned int a2, int a3, int a4)
{
  int v5; // r5
  char v7[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( a3 == 1 )
  {
    v5 = a2 & 7;
    if ( (a2 & 7) != 0 )
    {
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, 972512, v5);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-orig"
        "in_godminer-new/common/general/xxtea.c",
        150,
        "data_enc",
        8,
        93,
        100,
        v7);
      return 0;
    }
    else
    {
      xxtea_encode(a1, a2 >> 2, 16 * a4 + 1079376);
      return 1;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, 972568, a3);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/release/build/godminer-origin"
      "_godminer-new/common/general/xxtea.c",
      150,
      "data_enc",
      8,
      100,
      100,
      v7);
    return 0;
  }
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0009A4A4) --------------------------------------------------------
int __fastcall data_dec(unsigned int *a1, unsigned int a2, int a3, int a4)
{
  int v5; // r5
  int v6; // r2
  int v7; // r0
  int v8; // r1
  char v10[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( a3 != 1 )
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "algorithm_type is %d, but not support it", a3);
    V_UNLOCK();
    v6 = 119;
    v7 = g_zc;
    LOWORD(v8) = -10720;
    goto LABEL_4;
  }
  v5 = a2 & 7;
  if ( (a2 & 7) != 0 )
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, " xxtea input data length %% 8 must be 0, but now is %d", v5);
    V_UNLOCK();
    v6 = 112;
    v7 = g_zc;
    LOWORD(v8) = (unsigned __int16)"/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/"
                                   "release/build/godminer-origin_godminer-new/common/general/xxtea.c";
LABEL_4:
    HIWORD(v8) = (unsigned int)"/workspace/jenkins/jenkins/workspace/Antminer_KA3_release/build/rootfs/buildroot/tmp/rele"
                               "ase/build/godminer-origin_godminer-new/common/general/xxtea.c" >> 16;
    zlog(v7, v8, 150, "data_dec", 8, v6, 100, v10);
    return 0;
  }
  xxtea_decode(a1, a2 >> 2, (int)&xxtea_key + 16 * a4);
  return 1;
}
// 1EA84: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 11A7AC: using guessed type int g_zc;

//----- (0009A5AC) --------------------------------------------------------
void *__fastcall sph_cubehash224_0(_DWORD *a1, char *a2, size_t a3)
{
  int v3; // r5
  size_t v4; // r4
  int v5; // r2
  int v6; // r1
  int v7; // r10
  int v8; // r6
  int v9; // r11
  int v10; // r7
  int v11; // r8
  int v12; // r9
  void *result; // r0
  int v14; // r7
  int v15; // r6
  int v16; // r5
  int v17; // r10
  char *v18; // r0
  int v19; // r2
  int v20; // r8
  int v21; // r11
  int v22; // r9
  int v23; // r10
  int v24; // r12
  int v25; // r0
  int v26; // r5
  int v27; // r1
  size_t v28; // r4
  int v29; // r2
  int v30; // r7
  int v31; // lr
  int v32; // r6
  int v33; // r12
  int v34; // r8
  int v35; // r11
  int v36; // r9
  int v37; // r7
  int v38; // r0
  int v39; // r12
  int v40; // r6
  int v41; // lr
  int v42; // r12
  int v43; // r11
  int v44; // r10
  int v45; // r6
  int v46; // r5
  int v47; // r10
  size_t v48; // r4
  int v49; // r3
  int v50; // r2
  int v51; // r1
  int v52; // r6
  int v53; // r0
  int v54; // r1
  int v55; // r10
  int v56; // r9
  int v57; // r2
  int v58; // r0
  int v59; // r4
  size_t v60; // lr
  int v61; // r3
  int v62; // r8
  int v63; // r7
  int v64; // r9
  int v65; // r7
  int v66; // r0
  int v67; // r11
  int v68; // r1
  int v69; // r9
  int v70; // r7
  int v71; // r10
  size_t v72; // lr
  int v73; // r6
  int v74; // r3
  int v75; // r4
  int v76; // r2
  int v77; // r5
  int v78; // r2
  int v79; // r2
  int v80; // r1
  int v81; // r0
  int v82; // r11
  int v83; // r12
  int v84; // r9
  int v85; // r6
  int v86; // lr
  int v87; // r10
  int v88; // r4
  int v89; // r5
  int v90; // r8
  int v91; // r5
  int v92; // r7
  int v93; // r9
  int v94; // r2
  size_t v95; // r7
  int v96; // r1
  int v97; // r11
  int v98; // r10
  int v99; // r12
  int v100; // r4
  int v101; // r12
  int v102; // r11
  int v103; // r0
  int v104; // r3
  size_t v105; // r7
  int v106; // r8
  int v107; // lr
  int v108; // r3
  int v109; // r9
  int v110; // r2
  int v111; // r1
  int v112; // r0
  int v113; // r10
  int v114; // r6
  int v115; // r6
  int v116; // lr
  int v117; // r11
  int v118; // r0
  int v119; // r5
  int v120; // r8
  int v121; // r2
  int v122; // r7
  int v123; // r7
  int v124; // r9
  int v125; // r7
  int v126; // lr
  int v127; // r12
  int v128; // r6
  int v129; // r10
  int v130; // r8
  int v131; // r11
  int v132; // r5
  int v133; // r3
  int v134; // r4
  int v135; // r2
  int v136; // r0
  int v137; // r1
  int v138; // r12
  int v139; // r6
  int v140; // r10
  int v141; // r12
  int v142; // r9
  int v143; // r12
  int v144; // r4
  int v145; // r8
  int v146; // r5
  int v147; // r2
  size_t v148; // r7
  int v149; // lr
  int v150; // r12
  int v151; // r0
  int v152; // r11
  int v153; // r6
  int v154; // r5
  int v155; // r1
  int v156; // r4
  int v157; // r9
  int v158; // r8
  int v159; // r10
  int v160; // r12
  int v161; // r7
  int v162; // r3
  int v163; // r11
  int v164; // lr
  int v165; // r9
  int v166; // r6
  int v167; // r2
  int v168; // r0
  int v169; // r8
  int v170; // r1
  int v171; // r0
  int v172; // r7
  int v173; // r10
  int v174; // r5
  int v175; // lr
  size_t v176; // r2
  int v177; // r11
  int v178; // r0
  int v179; // r7
  int v180; // r1
  int v181; // r3
  int v182; // r4
  int v183; // r9
  int v184; // r6
  size_t v185; // r8
  int v186; // r10
  int v187; // r3
  size_t v188; // r2
  int v189; // r9
  int v190; // r1
  int v191; // r10
  int v192; // r6
  int v193; // t2
  int v194; // r12
  int v195; // r11
  int v196; // r0
  int v197; // lr
  int v198; // r2
  size_t v199; // r8
  int v200; // r4
  int v201; // r5
  int v202; // r7
  int v203; // r0
  int v204; // r9
  int v205; // r3
  int v206; // r6
  int v207; // r11
  int v208; // r4
  int v209; // t2
  int v210; // lr
  int v211; // r8
  int v212; // r5
  int v213; // r7
  int v214; // r2
  int v215; // r10
  size_t v216; // r3
  int v217; // r11
  int v218; // r9
  int v219; // r6
  int v220; // r1
  int v221; // r0
  int v222; // r7
  int v223; // r4
  size_t v224; // lr
  int v225; // r10
  int v226; // r5
  int v227; // r9
  int v228; // r8
  size_t v229; // r3
  int v230; // r12
  int v231; // r0
  int v232; // r2
  int v233; // r8
  int v234; // r2
  int v235; // r10
  int v236; // r11
  int v237; // r5
  size_t v238; // lr
  int v239; // r4
  int v240; // r3
  int v241; // r2
  int v242; // r2
  int v243; // r0
  int v244; // r7
  int v245; // r6
  int v246; // r9
  int v247; // r1
  int v248; // r12
  int v249; // r6
  int v250; // r5
  int v251; // r0
  size_t v252; // r2
  int v253; // lr
  size_t v254; // r3
  int v255; // r9
  int v256; // r4
  int v257; // r8
  size_t v258; // r3
  int v259; // r7
  int v260; // r1
  int v261; // r6
  int v262; // r12
  int v263; // r4
  int v264; // lr
  int v265; // t2
  size_t v266; // r3
  size_t v267; // r5
  int v268; // r11
  int v269; // r7
  int v270; // r4
  int v271; // r12
  int v272; // r10
  int v273; // r9
  int v274; // r0
  int v275; // r1
  int v276; // r4
  int v277; // lr
  int v278; // r10
  int v279; // r2
  int v280; // r8
  size_t v281; // r3
  int v282; // r8
  int v283; // r9
  size_t v284; // r5
  int v285; // r8
  int v286; // r11
  int v287; // r1
  int v288; // lr
  int v289; // r0
  int v290; // r6
  int v291; // r7
  int v292; // r2
  int v293; // r1
  int v294; // r0
  int v295; // r12
  int v296; // r12
  int v297; // r10
  int v298; // r5
  int v299; // r8
  size_t v300; // r3
  int v301; // r6
  int v302; // r4
  int v303; // r7
  int v304; // r9
  int v305; // r12
  size_t v306; // r3
  int v307; // r2
  int v308; // r10
  int v309; // r12
  size_t v310; // lr
  int v311; // r4
  int v312; // r8
  int v313; // r5
  int v314; // r9
  int v315; // r7
  int v316; // r6
  int v317; // r1
  int v318; // r0
  int v319; // r11
  size_t v320; // lr
  int v321; // r11
  int v322; // r4
  int v323; // r12
  int v324; // r6
  int v325; // t2
  size_t v326; // r3
  int v327; // r8
  int v328; // r5
  int v329; // r11
  int v330; // r7
  int v331; // r10
  int v332; // r9
  int v333; // r2
  int v334; // r2
  int v335; // r1
  int v336; // r0
  int v337; // r7
  int v338; // r6
  int v339; // lr
  int v340; // r10
  int v341; // r2
  int v342; // r5
  int v343; // r8
  int v344; // r3
  int v345; // r9
  int v346; // r1
  int v347; // r0
  int v348; // r4
  int v349; // r10
  int v350; // r11
  int v351; // lr
  int v352; // r4
  int v353; // r2
  int v354; // r0
  int v355; // r1
  int v356; // r5
  int v357; // r8
  size_t v358; // r4
  int v359; // r6
  int v360; // r7
  int v361; // r9
  int v362; // r5
  int v363; // r9
  int v364; // r12
  int v365; // r0
  int v366; // r2
  size_t v367; // r3
  int v368; // r4
  size_t v369; // lr
  int v370; // r8
  int v371; // r9
  int v372; // r3
  int v373; // r1
  size_t v374; // r7
  int v375; // r6
  int v376; // r12
  int v377; // r4
  size_t v378; // lr
  int v379; // t2
  int v380; // r3
  int v381; // r5
  int v382; // r11
  size_t v383; // r7
  int v384; // r4
  int v385; // r12
  int v386; // r10
  int v387; // r9
  int v388; // r0
  int v389; // r1
  int v390; // r4
  int v391; // lr
  int v392; // r10
  int v393; // r2
  int v394; // r8
  int v395; // r3
  int v396; // r8
  int v397; // r8
  int v398; // r9
  int v399; // r5
  size_t v400; // r8
  size_t v401; // r8
  int v402; // r11
  int v403; // r1
  int v404; // lr
  int v405; // r0
  int v406; // r6
  int v407; // r7
  int v408; // r2
  int v409; // r1
  int v410; // r0
  int v411; // r12
  int v412; // r5
  size_t v413; // r8
  int v414; // r3
  int v415; // r6
  int v416; // r7
  int v417; // r10
  int v418; // r9
  int v419; // r12
  int v420; // r3
  int v421; // r11
  int v422; // r2
  int v423; // r4
  size_t v424; // r8
  int v425; // r5
  int v426; // r10
  int v427; // r9
  int v428; // r7
  int v429; // r6
  int v430; // r0
  int v431; // r12
  int v432; // r1
  int v433; // lr
  int v434; // r11
  int v435; // r4
  int v436; // r12
  int v437; // r6
  int v438; // r11
  size_t v439; // r8
  int v440; // r5
  int v441; // r2
  int v442; // r3
  int v443; // r11
  int v444; // r0
  int v445; // r10
  int v446; // r7
  int v447; // r8
  int v448; // r1
  int v449; // lr
  size_t v450; // r4
  int v451; // r2
  int v452; // r0
  int v453; // r9
  int v454; // r12
  int v455; // r10
  int v456; // r3
  int v457; // r1
  int v458; // r6
  int v459; // r11
  int v460; // r7
  int v461; // r2
  int v462; // r4
  int v463; // t2
  size_t n; // [sp+0h] [bp-8Ch]
  char *src; // [sp+4h] [bp-88h]
  int v468; // [sp+Ch] [bp-80h]
  int v469; // [sp+Ch] [bp-80h]
  int v470; // [sp+Ch] [bp-80h]
  int v471; // [sp+Ch] [bp-80h]
  int v472; // [sp+Ch] [bp-80h]
  int v473; // [sp+Ch] [bp-80h]
  int v474; // [sp+Ch] [bp-80h]
  int v475; // [sp+Ch] [bp-80h]
  int v476; // [sp+Ch] [bp-80h]
  int v477; // [sp+Ch] [bp-80h]
  int v478; // [sp+Ch] [bp-80h]
  size_t v479; // [sp+Ch] [bp-80h]
  size_t v480; // [sp+Ch] [bp-80h]
  size_t v481; // [sp+Ch] [bp-80h]
  size_t v482; // [sp+Ch] [bp-80h]
  int v483; // [sp+Ch] [bp-80h]
  int v484; // [sp+Ch] [bp-80h]
  int v485; // [sp+Ch] [bp-80h]
  int v486; // [sp+Ch] [bp-80h]
  int v487; // [sp+Ch] [bp-80h]
  int v488; // [sp+Ch] [bp-80h]
  int v489; // [sp+Ch] [bp-80h]
  int v490; // [sp+Ch] [bp-80h]
  int v491; // [sp+Ch] [bp-80h]
  int v492; // [sp+Ch] [bp-80h]
  int v493; // [sp+Ch] [bp-80h]
  int v494; // [sp+Ch] [bp-80h]
  int v495; // [sp+Ch] [bp-80h]
  size_t v496; // [sp+Ch] [bp-80h]
  size_t v497; // [sp+Ch] [bp-80h]
  int v498; // [sp+Ch] [bp-80h]
  int v499; // [sp+Ch] [bp-80h]
  int v500; // [sp+10h] [bp-7Ch]
  int v501; // [sp+10h] [bp-7Ch]
  int v502; // [sp+10h] [bp-7Ch]
  int v503; // [sp+10h] [bp-7Ch]
  int v504; // [sp+10h] [bp-7Ch]
  int v505; // [sp+10h] [bp-7Ch]
  int v506; // [sp+10h] [bp-7Ch]
  int v507; // [sp+10h] [bp-7Ch]
  int v508; // [sp+10h] [bp-7Ch]
  int v509; // [sp+10h] [bp-7Ch]
  int v510; // [sp+10h] [bp-7Ch]
  int v511; // [sp+10h] [bp-7Ch]
  int v512; // [sp+10h] [bp-7Ch]
  int v513; // [sp+10h] [bp-7Ch]
  int v514; // [sp+10h] [bp-7Ch]
  int v515; // [sp+10h] [bp-7Ch]
  int v516; // [sp+10h] [bp-7Ch]
  int v517; // [sp+10h] [bp-7Ch]
  int v518; // [sp+10h] [bp-7Ch]
  int v519; // [sp+10h] [bp-7Ch]
  int v520; // [sp+10h] [bp-7Ch]
  int v521; // [sp+10h] [bp-7Ch]
  int v522; // [sp+10h] [bp-7Ch]
  int v523; // [sp+10h] [bp-7Ch]
  int v524; // [sp+10h] [bp-7Ch]
  int v525; // [sp+10h] [bp-7Ch]
  int v526; // [sp+10h] [bp-7Ch]
  int v527; // [sp+10h] [bp-7Ch]
  int v528; // [sp+10h] [bp-7Ch]
  int v529; // [sp+10h] [bp-7Ch]
  int v530; // [sp+10h] [bp-7Ch]
  int v531; // [sp+10h] [bp-7Ch]
  int v532; // [sp+14h] [bp-78h]
  int v533; // [sp+14h] [bp-78h]
  int v534; // [sp+14h] [bp-78h]
  int v535; // [sp+14h] [bp-78h]
  size_t v536; // [sp+14h] [bp-78h]
  int v537; // [sp+14h] [bp-78h]
  size_t v538; // [sp+14h] [bp-78h]
  int v539; // [sp+14h] [bp-78h]
  int v540; // [sp+14h] [bp-78h]
  int v541; // [sp+14h] [bp-78h]
  int v542; // [sp+14h] [bp-78h]
  int v543; // [sp+14h] [bp-78h]
  size_t v544; // [sp+14h] [bp-78h]
  int v545; // [sp+14h] [bp-78h]
  int v546; // [sp+14h] [bp-78h]
  size_t v547; // [sp+14h] [bp-78h]
  int v548; // [sp+14h] [bp-78h]
  int v549; // [sp+14h] [bp-78h]
  int v550; // [sp+14h] [bp-78h]
  int v551; // [sp+14h] [bp-78h]
  int v552; // [sp+14h] [bp-78h]
  int v553; // [sp+14h] [bp-78h]
  size_t v554; // [sp+14h] [bp-78h]
  int v555; // [sp+14h] [bp-78h]
  int v556; // [sp+14h] [bp-78h]
  int v557; // [sp+14h] [bp-78h]
  int v558; // [sp+14h] [bp-78h]
  int v559; // [sp+14h] [bp-78h]
  int v560; // [sp+14h] [bp-78h]
  int v561; // [sp+14h] [bp-78h]
  int v562; // [sp+14h] [bp-78h]
  int v563; // [sp+18h] [bp-74h]
  int v564; // [sp+18h] [bp-74h]
  int v565; // [sp+18h] [bp-74h]
  int v566; // [sp+18h] [bp-74h]
  int v567; // [sp+18h] [bp-74h]
  int v568; // [sp+18h] [bp-74h]
  int v569; // [sp+18h] [bp-74h]
  int v570; // [sp+18h] [bp-74h]
  int v571; // [sp+18h] [bp-74h]
  int v572; // [sp+18h] [bp-74h]
  int v573; // [sp+18h] [bp-74h]
  int v574; // [sp+18h] [bp-74h]
  int v575; // [sp+18h] [bp-74h]
  int v576; // [sp+18h] [bp-74h]
  int v577; // [sp+18h] [bp-74h]
  int v578; // [sp+18h] [bp-74h]
  int v579; // [sp+18h] [bp-74h]
  int v580; // [sp+18h] [bp-74h]
  int v581; // [sp+18h] [bp-74h]
  int v582; // [sp+18h] [bp-74h]
  int v583; // [sp+18h] [bp-74h]
  int v584; // [sp+18h] [bp-74h]
  int v585; // [sp+18h] [bp-74h]
  int v586; // [sp+18h] [bp-74h]
  int v587; // [sp+18h] [bp-74h]
  int v588; // [sp+18h] [bp-74h]
  int v589; // [sp+18h] [bp-74h]
  int v590; // [sp+18h] [bp-74h]
  int v591; // [sp+18h] [bp-74h]
  int v592; // [sp+18h] [bp-74h]
  size_t v593; // [sp+1Ch] [bp-70h]
  int v594; // [sp+1Ch] [bp-70h]
  int v595; // [sp+1Ch] [bp-70h]
  int v596; // [sp+1Ch] [bp-70h]
  int v597; // [sp+1Ch] [bp-70h]
  int v598; // [sp+1Ch] [bp-70h]
  int v599; // [sp+1Ch] [bp-70h]
  int v600; // [sp+1Ch] [bp-70h]
  int v601; // [sp+1Ch] [bp-70h]
  int v602; // [sp+1Ch] [bp-70h]
  int v603; // [sp+1Ch] [bp-70h]
  int v604; // [sp+1Ch] [bp-70h]
  int v605; // [sp+1Ch] [bp-70h]
  int v606; // [sp+1Ch] [bp-70h]
  int v607; // [sp+1Ch] [bp-70h]
  size_t v608; // [sp+1Ch] [bp-70h]
  size_t v609; // [sp+1Ch] [bp-70h]
  size_t v610; // [sp+1Ch] [bp-70h]
  int v611; // [sp+1Ch] [bp-70h]
  int v612; // [sp+1Ch] [bp-70h]
  int v613; // [sp+1Ch] [bp-70h]
  int v614; // [sp+1Ch] [bp-70h]
  int v615; // [sp+1Ch] [bp-70h]
  int v616; // [sp+1Ch] [bp-70h]
  int v617; // [sp+1Ch] [bp-70h]
  int v618; // [sp+1Ch] [bp-70h]
  int v619; // [sp+1Ch] [bp-70h]
  int v620; // [sp+1Ch] [bp-70h]
  int v621; // [sp+1Ch] [bp-70h]
  int v622; // [sp+1Ch] [bp-70h]
  int v623; // [sp+1Ch] [bp-70h]
  int v624; // [sp+20h] [bp-6Ch]
  int v625; // [sp+20h] [bp-6Ch]
  int v626; // [sp+20h] [bp-6Ch]
  int v627; // [sp+20h] [bp-6Ch]
  int v628; // [sp+20h] [bp-6Ch]
  int v629; // [sp+20h] [bp-6Ch]
  int v630; // [sp+20h] [bp-6Ch]
  int v631; // [sp+20h] [bp-6Ch]
  int v632; // [sp+20h] [bp-6Ch]
  int v633; // [sp+20h] [bp-6Ch]
  int v634; // [sp+20h] [bp-6Ch]
  int v635; // [sp+20h] [bp-6Ch]
  int v636; // [sp+20h] [bp-6Ch]
  int v637; // [sp+20h] [bp-6Ch]
  int v638; // [sp+20h] [bp-6Ch]
  int v639; // [sp+20h] [bp-6Ch]
  int v640; // [sp+20h] [bp-6Ch]
  int v641; // [sp+20h] [bp-6Ch]
  int v642; // [sp+20h] [bp-6Ch]
  int v643; // [sp+20h] [bp-6Ch]
  int v644; // [sp+20h] [bp-6Ch]
  int v645; // [sp+20h] [bp-6Ch]
  int v646; // [sp+20h] [bp-6Ch]
  int v647; // [sp+20h] [bp-6Ch]
  int v648; // [sp+20h] [bp-6Ch]
  int v649; // [sp+20h] [bp-6Ch]
  int v650; // [sp+20h] [bp-6Ch]
  int v651; // [sp+20h] [bp-6Ch]
  int v652; // [sp+20h] [bp-6Ch]
  int v653; // [sp+20h] [bp-6Ch]
  int v654; // [sp+24h] [bp-68h]
  int v655; // [sp+24h] [bp-68h]
  int v656; // [sp+24h] [bp-68h]
  int v657; // [sp+24h] [bp-68h]
  int v658; // [sp+24h] [bp-68h]
  int v659; // [sp+24h] [bp-68h]
  int v660; // [sp+24h] [bp-68h]
  size_t v661; // [sp+24h] [bp-68h]
  size_t v662; // [sp+24h] [bp-68h]
  size_t v663; // [sp+24h] [bp-68h]
  size_t v664; // [sp+24h] [bp-68h]
  int v665; // [sp+24h] [bp-68h]
  int v666; // [sp+24h] [bp-68h]
  size_t v667; // [sp+24h] [bp-68h]
  size_t v668; // [sp+24h] [bp-68h]
  int v669; // [sp+24h] [bp-68h]
  int v670; // [sp+24h] [bp-68h]
  int v671; // [sp+24h] [bp-68h]
  int v672; // [sp+24h] [bp-68h]
  int v673; // [sp+24h] [bp-68h]
  int v674; // [sp+24h] [bp-68h]
  int v675; // [sp+24h] [bp-68h]
  int v676; // [sp+24h] [bp-68h]
  int v677; // [sp+24h] [bp-68h]
  int v678; // [sp+24h] [bp-68h]
  int v679; // [sp+24h] [bp-68h]
  int v680; // [sp+24h] [bp-68h]
  int v681; // [sp+24h] [bp-68h]
  int v682; // [sp+24h] [bp-68h]
  int v683; // [sp+24h] [bp-68h]
  int v684; // [sp+24h] [bp-68h]
  int v685; // [sp+28h] [bp-64h]
  int v686; // [sp+28h] [bp-64h]
  int v687; // [sp+28h] [bp-64h]
  int v688; // [sp+28h] [bp-64h]
  int v689; // [sp+28h] [bp-64h]
  int v690; // [sp+28h] [bp-64h]
  int v691; // [sp+28h] [bp-64h]
  int v692; // [sp+28h] [bp-64h]
  int v693; // [sp+28h] [bp-64h]
  int v694; // [sp+28h] [bp-64h]
  int v695; // [sp+28h] [bp-64h]
  int v696; // [sp+28h] [bp-64h]
  int v697; // [sp+28h] [bp-64h]
  int v698; // [sp+28h] [bp-64h]
  int v699; // [sp+28h] [bp-64h]
  int v700; // [sp+28h] [bp-64h]
  size_t v701; // [sp+28h] [bp-64h]
  int v702; // [sp+28h] [bp-64h]
  int v703; // [sp+28h] [bp-64h]
  size_t v704; // [sp+28h] [bp-64h]
  size_t v705; // [sp+28h] [bp-64h]
  int v706; // [sp+28h] [bp-64h]
  int v707; // [sp+28h] [bp-64h]
  size_t v708; // [sp+28h] [bp-64h]
  int v709; // [sp+28h] [bp-64h]
  int v710; // [sp+28h] [bp-64h]
  int v711; // [sp+28h] [bp-64h]
  int v712; // [sp+28h] [bp-64h]
  int v713; // [sp+28h] [bp-64h]
  int v714; // [sp+28h] [bp-64h]
  int v715; // [sp+2Ch] [bp-60h]
  int v716; // [sp+2Ch] [bp-60h]
  int v717; // [sp+2Ch] [bp-60h]
  int v718; // [sp+2Ch] [bp-60h]
  size_t v719; // [sp+2Ch] [bp-60h]
  size_t v720; // [sp+2Ch] [bp-60h]
  int v721; // [sp+2Ch] [bp-60h]
  size_t v722; // [sp+2Ch] [bp-60h]
  int v723; // [sp+2Ch] [bp-60h]
  int v724; // [sp+2Ch] [bp-60h]
  int v725; // [sp+2Ch] [bp-60h]
  int v726; // [sp+2Ch] [bp-60h]
  int v727; // [sp+2Ch] [bp-60h]
  int v728; // [sp+2Ch] [bp-60h]
  int v729; // [sp+2Ch] [bp-60h]
  int v730; // [sp+2Ch] [bp-60h]
  int v731; // [sp+2Ch] [bp-60h]
  int v732; // [sp+2Ch] [bp-60h]
  size_t v733; // [sp+2Ch] [bp-60h]
  int v734; // [sp+2Ch] [bp-60h]
  int v735; // [sp+2Ch] [bp-60h]
  int v736; // [sp+2Ch] [bp-60h]
  int v737; // [sp+2Ch] [bp-60h]
  int v738; // [sp+2Ch] [bp-60h]
  int v739; // [sp+2Ch] [bp-60h]
  int v740; // [sp+2Ch] [bp-60h]
  int v741; // [sp+2Ch] [bp-60h]
  int v742; // [sp+2Ch] [bp-60h]
  int v743; // [sp+30h] [bp-5Ch]
  int v744; // [sp+30h] [bp-5Ch]
  int v745; // [sp+30h] [bp-5Ch]
  int v746; // [sp+30h] [bp-5Ch]
  int v747; // [sp+30h] [bp-5Ch]
  int v748; // [sp+30h] [bp-5Ch]
  int v749; // [sp+30h] [bp-5Ch]
  int v750; // [sp+30h] [bp-5Ch]
  int v751; // [sp+30h] [bp-5Ch]
  size_t v752; // [sp+30h] [bp-5Ch]
  int v753; // [sp+30h] [bp-5Ch]
  size_t v754; // [sp+30h] [bp-5Ch]
  size_t v755; // [sp+30h] [bp-5Ch]
  int v756; // [sp+30h] [bp-5Ch]
  int v757; // [sp+30h] [bp-5Ch]
  int v758; // [sp+30h] [bp-5Ch]
  int v759; // [sp+30h] [bp-5Ch]
  int v760; // [sp+30h] [bp-5Ch]
  int v761; // [sp+30h] [bp-5Ch]
  int v762; // [sp+30h] [bp-5Ch]
  int v763; // [sp+30h] [bp-5Ch]
  int v764; // [sp+30h] [bp-5Ch]
  int v765; // [sp+30h] [bp-5Ch]
  int v766; // [sp+30h] [bp-5Ch]
  int v767; // [sp+30h] [bp-5Ch]
  int v768; // [sp+30h] [bp-5Ch]
  int v769; // [sp+30h] [bp-5Ch]
  int v770; // [sp+30h] [bp-5Ch]
  int v771; // [sp+30h] [bp-5Ch]
  int v772; // [sp+34h] [bp-58h]
  int v773; // [sp+34h] [bp-58h]
  int v774; // [sp+34h] [bp-58h]
  int v775; // [sp+34h] [bp-58h]
  int v776; // [sp+34h] [bp-58h]
  int v777; // [sp+34h] [bp-58h]
  int v778; // [sp+34h] [bp-58h]
  int v779; // [sp+34h] [bp-58h]
  int v780; // [sp+34h] [bp-58h]
  int v781; // [sp+34h] [bp-58h]
  int v782; // [sp+34h] [bp-58h]
  int v783; // [sp+34h] [bp-58h]
  int v784; // [sp+34h] [bp-58h]
  int v785; // [sp+34h] [bp-58h]
  size_t v786; // [sp+34h] [bp-58h]
  int v787; // [sp+34h] [bp-58h]
  int v788; // [sp+34h] [bp-58h]
  int v789; // [sp+34h] [bp-58h]
  int v790; // [sp+34h] [bp-58h]
  int v791; // [sp+34h] [bp-58h]
  int v792; // [sp+34h] [bp-58h]
  int v793; // [sp+34h] [bp-58h]
  int v794; // [sp+34h] [bp-58h]
  int v795; // [sp+34h] [bp-58h]
  int v796; // [sp+34h] [bp-58h]
  int v797; // [sp+34h] [bp-58h]
  int v798; // [sp+38h] [bp-54h]
  int v799; // [sp+38h] [bp-54h]
  int v800; // [sp+38h] [bp-54h]
  int v801; // [sp+38h] [bp-54h]
  int v802; // [sp+38h] [bp-54h]
  size_t v803; // [sp+38h] [bp-54h]
  size_t v804; // [sp+38h] [bp-54h]
  int v805; // [sp+38h] [bp-54h]
  int v806; // [sp+38h] [bp-54h]
  int v807; // [sp+38h] [bp-54h]
  int v808; // [sp+38h] [bp-54h]
  int v809; // [sp+38h] [bp-54h]
  int v810; // [sp+38h] [bp-54h]
  size_t v811; // [sp+38h] [bp-54h]
  size_t v812; // [sp+38h] [bp-54h]
  int v813; // [sp+38h] [bp-54h]
  int v814; // [sp+38h] [bp-54h]
  int v815; // [sp+38h] [bp-54h]
  int v816; // [sp+38h] [bp-54h]
  int v817; // [sp+38h] [bp-54h]
  size_t v818; // [sp+38h] [bp-54h]
  int v819; // [sp+38h] [bp-54h]
  int v820; // [sp+38h] [bp-54h]
  int v821; // [sp+38h] [bp-54h]
  int v822; // [sp+38h] [bp-54h]
  int v823; // [sp+38h] [bp-54h]
  int v824; // [sp+3Ch] [bp-50h]
  size_t v825; // [sp+3Ch] [bp-50h]
  int v826; // [sp+3Ch] [bp-50h]
  int v827; // [sp+3Ch] [bp-50h]
  size_t v828; // [sp+3Ch] [bp-50h]
  size_t v829; // [sp+3Ch] [bp-50h]
  int v830; // [sp+3Ch] [bp-50h]
  int v831; // [sp+3Ch] [bp-50h]
  size_t v832; // [sp+3Ch] [bp-50h]
  int v833; // [sp+3Ch] [bp-50h]
  int v834; // [sp+3Ch] [bp-50h]
  int v835; // [sp+3Ch] [bp-50h]
  int v836; // [sp+3Ch] [bp-50h]
  int v837; // [sp+3Ch] [bp-50h]
  int v838; // [sp+3Ch] [bp-50h]
  int v839; // [sp+3Ch] [bp-50h]
  int v840; // [sp+3Ch] [bp-50h]
  int v841; // [sp+3Ch] [bp-50h]
  int v842; // [sp+3Ch] [bp-50h]
  int v843; // [sp+3Ch] [bp-50h]
  int v844; // [sp+3Ch] [bp-50h]
  int v845; // [sp+3Ch] [bp-50h]
  int v846; // [sp+3Ch] [bp-50h]
  int v847; // [sp+3Ch] [bp-50h]
  size_t v848; // [sp+3Ch] [bp-50h]
  size_t v849; // [sp+3Ch] [bp-50h]
  int v850; // [sp+40h] [bp-4Ch]
  int v851; // [sp+40h] [bp-4Ch]
  int v852; // [sp+40h] [bp-4Ch]
  int v853; // [sp+40h] [bp-4Ch]
  int v854; // [sp+40h] [bp-4Ch]
  int v855; // [sp+40h] [bp-4Ch]
  int v856; // [sp+40h] [bp-4Ch]
  int v857; // [sp+40h] [bp-4Ch]
  int v858; // [sp+40h] [bp-4Ch]
  int v859; // [sp+40h] [bp-4Ch]
  int v860; // [sp+40h] [bp-4Ch]
  int v861; // [sp+40h] [bp-4Ch]
  int v862; // [sp+40h] [bp-4Ch]
  int v863; // [sp+40h] [bp-4Ch]
  int v864; // [sp+40h] [bp-4Ch]
  int v865; // [sp+40h] [bp-4Ch]
  int v866; // [sp+40h] [bp-4Ch]
  int v867; // [sp+40h] [bp-4Ch]
  size_t v868; // [sp+40h] [bp-4Ch]
  size_t v869; // [sp+40h] [bp-4Ch]
  int v870; // [sp+40h] [bp-4Ch]
  int v871; // [sp+40h] [bp-4Ch]
  int v872; // [sp+40h] [bp-4Ch]
  int v873; // [sp+40h] [bp-4Ch]
  int v874; // [sp+40h] [bp-4Ch]
  int v875; // [sp+40h] [bp-4Ch]
  int v876; // [sp+40h] [bp-4Ch]
  int v877; // [sp+44h] [bp-48h]
  int v878; // [sp+44h] [bp-48h]
  size_t v879; // [sp+44h] [bp-48h]
  size_t v880; // [sp+44h] [bp-48h]
  int v881; // [sp+44h] [bp-48h]
  int v882; // [sp+44h] [bp-48h]
  int v883; // [sp+44h] [bp-48h]
  int v884; // [sp+44h] [bp-48h]
  size_t v885; // [sp+44h] [bp-48h]
  int v886; // [sp+44h] [bp-48h]
  int v887; // [sp+44h] [bp-48h]
  int v888; // [sp+44h] [bp-48h]
  int v889; // [sp+44h] [bp-48h]
  int v890; // [sp+44h] [bp-48h]
  int v891; // [sp+44h] [bp-48h]
  int v892; // [sp+44h] [bp-48h]
  int v893; // [sp+44h] [bp-48h]
  int v894; // [sp+44h] [bp-48h]
  int v895; // [sp+44h] [bp-48h]
  int v896; // [sp+44h] [bp-48h]
  int v897; // [sp+44h] [bp-48h]
  int v898; // [sp+44h] [bp-48h]
  int v899; // [sp+44h] [bp-48h]
  int v900; // [sp+44h] [bp-48h]
  int v901; // [sp+44h] [bp-48h]
  int v902; // [sp+44h] [bp-48h]
  int v903; // [sp+44h] [bp-48h]
  int v904; // [sp+48h] [bp-44h]
  int v905; // [sp+48h] [bp-44h]
  int v906; // [sp+48h] [bp-44h]
  int v907; // [sp+48h] [bp-44h]
  int v908; // [sp+48h] [bp-44h]
  int v909; // [sp+48h] [bp-44h]
  int v910; // [sp+48h] [bp-44h]
  size_t v911; // [sp+48h] [bp-44h]
  size_t v912; // [sp+48h] [bp-44h]
  int v913; // [sp+48h] [bp-44h]
  int v914; // [sp+48h] [bp-44h]
  int v915; // [sp+48h] [bp-44h]
  int v916; // [sp+48h] [bp-44h]
  int v917; // [sp+48h] [bp-44h]
  int v918; // [sp+48h] [bp-44h]
  int v919; // [sp+48h] [bp-44h]
  int v920; // [sp+48h] [bp-44h]
  int v921; // [sp+48h] [bp-44h]
  int v922; // [sp+48h] [bp-44h]
  int v923; // [sp+48h] [bp-44h]
  int v924; // [sp+48h] [bp-44h]
  int v925; // [sp+48h] [bp-44h]
  int v926; // [sp+48h] [bp-44h]
  int v927; // [sp+48h] [bp-44h]
  size_t v928; // [sp+48h] [bp-44h]
  int v929; // [sp+48h] [bp-44h]
  size_t v930; // [sp+4Ch] [bp-40h]
  size_t v931; // [sp+4Ch] [bp-40h]
  size_t v932; // [sp+4Ch] [bp-40h]
  size_t v933; // [sp+4Ch] [bp-40h]
  size_t v934; // [sp+4Ch] [bp-40h]
  size_t v935; // [sp+4Ch] [bp-40h]
  size_t v936; // [sp+4Ch] [bp-40h]
  size_t v937; // [sp+4Ch] [bp-40h]
  size_t v938; // [sp+4Ch] [bp-40h]
  size_t v939; // [sp+4Ch] [bp-40h]
  size_t v940; // [sp+4Ch] [bp-40h]
  size_t v941; // [sp+4Ch] [bp-40h]
  size_t v942; // [sp+4Ch] [bp-40h]
  size_t v943; // [sp+4Ch] [bp-40h]
  size_t v944; // [sp+4Ch] [bp-40h]
  size_t v945; // [sp+4Ch] [bp-40h]
  size_t v946; // [sp+4Ch] [bp-40h]
  size_t v947; // [sp+4Ch] [bp-40h]
  size_t v948; // [sp+4Ch] [bp-40h]
  size_t v949; // [sp+4Ch] [bp-40h]
  size_t v950; // [sp+4Ch] [bp-40h]
  size_t v951; // [sp+4Ch] [bp-40h]
  size_t v952; // [sp+4Ch] [bp-40h]
  size_t v953; // [sp+4Ch] [bp-40h]
  size_t v954; // [sp+4Ch] [bp-40h]
  size_t v955; // [sp+4Ch] [bp-40h]
  int v956; // [sp+50h] [bp-3Ch]
  int v957; // [sp+50h] [bp-3Ch]
  int v958; // [sp+50h] [bp-3Ch]
  int v959; // [sp+50h] [bp-3Ch]
  int v960; // [sp+50h] [bp-3Ch]
  int v961; // [sp+50h] [bp-3Ch]
  int v962; // [sp+50h] [bp-3Ch]
  int v963; // [sp+50h] [bp-3Ch]
  int v964; // [sp+50h] [bp-3Ch]
  int v965; // [sp+50h] [bp-3Ch]
  int v966; // [sp+50h] [bp-3Ch]
  int v967; // [sp+50h] [bp-3Ch]
  int v968; // [sp+50h] [bp-3Ch]
  size_t v969; // [sp+50h] [bp-3Ch]
  int v970; // [sp+50h] [bp-3Ch]
  int v971; // [sp+50h] [bp-3Ch]
  int v972; // [sp+50h] [bp-3Ch]
  int v973; // [sp+50h] [bp-3Ch]
  int v974; // [sp+50h] [bp-3Ch]
  int v975; // [sp+50h] [bp-3Ch]
  int v976; // [sp+50h] [bp-3Ch]
  int v977; // [sp+50h] [bp-3Ch]
  int v978; // [sp+50h] [bp-3Ch]
  int v979; // [sp+50h] [bp-3Ch]
  int v980; // [sp+50h] [bp-3Ch]
  int v981; // [sp+54h] [bp-38h]
  int v982; // [sp+54h] [bp-38h]
  int v983; // [sp+54h] [bp-38h]
  int v984; // [sp+54h] [bp-38h]
  int v985; // [sp+54h] [bp-38h]
  int v986; // [sp+54h] [bp-38h]
  int v987; // [sp+54h] [bp-38h]
  int v988; // [sp+54h] [bp-38h]
  int v989; // [sp+54h] [bp-38h]
  int v990; // [sp+54h] [bp-38h]
  int v991; // [sp+54h] [bp-38h]
  int v992; // [sp+54h] [bp-38h]
  int v993; // [sp+54h] [bp-38h]
  int v994; // [sp+54h] [bp-38h]
  int v995; // [sp+54h] [bp-38h]
  int v996; // [sp+54h] [bp-38h]
  int v997; // [sp+54h] [bp-38h]
  size_t v998; // [sp+54h] [bp-38h]
  int v999; // [sp+54h] [bp-38h]
  int v1000; // [sp+54h] [bp-38h]
  int v1001; // [sp+54h] [bp-38h]
  int v1002; // [sp+54h] [bp-38h]
  int v1003; // [sp+54h] [bp-38h]
  int v1004; // [sp+58h] [bp-34h]
  int v1005; // [sp+58h] [bp-34h]
  int v1006; // [sp+58h] [bp-34h]
  int v1007; // [sp+58h] [bp-34h]
  int v1008; // [sp+58h] [bp-34h]
  int v1009; // [sp+58h] [bp-34h]
  int v1010; // [sp+58h] [bp-34h]
  int v1011; // [sp+58h] [bp-34h]
  int v1012; // [sp+58h] [bp-34h]
  int v1013; // [sp+58h] [bp-34h]
  int v1014; // [sp+58h] [bp-34h]
  int v1015; // [sp+58h] [bp-34h]
  int v1016; // [sp+58h] [bp-34h]
  int v1017; // [sp+58h] [bp-34h]
  int v1018; // [sp+58h] [bp-34h]
  int v1019; // [sp+58h] [bp-34h]
  int v1020; // [sp+58h] [bp-34h]
  int v1021; // [sp+58h] [bp-34h]
  int v1022; // [sp+58h] [bp-34h]
  int v1023; // [sp+58h] [bp-34h]
  int v1024; // [sp+58h] [bp-34h]
  int v1025; // [sp+5Ch] [bp-30h]
  int v1026; // [sp+5Ch] [bp-30h]
  int v1027; // [sp+5Ch] [bp-30h]
  int v1028; // [sp+5Ch] [bp-30h]
  int v1029; // [sp+5Ch] [bp-30h]
  int v1030; // [sp+5Ch] [bp-30h]
  int v1031; // [sp+5Ch] [bp-30h]
  int v1032; // [sp+5Ch] [bp-30h]
  int v1033; // [sp+5Ch] [bp-30h]
  int v1034; // [sp+5Ch] [bp-30h]
  int v1035; // [sp+5Ch] [bp-30h]
  int v1036; // [sp+5Ch] [bp-30h]
  size_t v1037; // [sp+5Ch] [bp-30h]
  size_t v1038; // [sp+5Ch] [bp-30h]
  int v1039; // [sp+5Ch] [bp-30h]
  int v1040; // [sp+5Ch] [bp-30h]
  int v1041; // [sp+5Ch] [bp-30h]
  size_t v1042; // [sp+5Ch] [bp-30h]
  int v1043; // [sp+5Ch] [bp-30h]
  int v1044; // [sp+5Ch] [bp-30h]
  size_t v1045; // [sp+5Ch] [bp-30h]
  int v1046; // [sp+5Ch] [bp-30h]
  int v1047; // [sp+5Ch] [bp-30h]
  int v1048; // [sp+60h] [bp-2Ch]
  int v1049; // [sp+60h] [bp-2Ch]
  int v1050; // [sp+60h] [bp-2Ch]
  int v1051; // [sp+60h] [bp-2Ch]
  int v1052; // [sp+60h] [bp-2Ch]
  int v1053; // [sp+60h] [bp-2Ch]
  int v1054; // [sp+60h] [bp-2Ch]
  int v1055; // [sp+60h] [bp-2Ch]
  int v1056; // [sp+60h] [bp-2Ch]
  int v1057; // [sp+60h] [bp-2Ch]
  int v1058; // [sp+60h] [bp-2Ch]
  int v1059; // [sp+60h] [bp-2Ch]
  int v1060; // [sp+60h] [bp-2Ch]
  int v1061; // [sp+60h] [bp-2Ch]
  int v1062; // [sp+60h] [bp-2Ch]
  int v1063; // [sp+60h] [bp-2Ch]
  int v1064; // [sp+60h] [bp-2Ch]
  int v1065; // [sp+60h] [bp-2Ch]
  size_t v1066; // [sp+60h] [bp-2Ch]
  int v1067; // [sp+60h] [bp-2Ch]
  int v1068; // [sp+60h] [bp-2Ch]
  int v1069; // [sp+60h] [bp-2Ch]
  int v1070; // [sp+60h] [bp-2Ch]
  int v1071; // [sp+60h] [bp-2Ch]
  int v1072; // [sp+60h] [bp-2Ch]
  int v1073; // [sp+64h] [bp-28h]
  int v1074; // [sp+64h] [bp-28h]
  int v1075; // [sp+64h] [bp-28h]
  int v1076; // [sp+64h] [bp-28h]
  int v1077; // [sp+64h] [bp-28h]
  size_t v1078; // [sp+64h] [bp-28h]
  int v1079; // [sp+64h] [bp-28h]
  int v1080; // [sp+64h] [bp-28h]
  int v1081; // [sp+64h] [bp-28h]
  int v1082; // [sp+64h] [bp-28h]
  int v1083; // [sp+64h] [bp-28h]
  int v1084; // [sp+64h] [bp-28h]
  int v1085; // [sp+64h] [bp-28h]
  int v1086; // [sp+64h] [bp-28h]
  int v1087; // [sp+64h] [bp-28h]
  int v1088; // [sp+64h] [bp-28h]
  int v1089; // [sp+64h] [bp-28h]
  int v1090; // [sp+68h] [bp-24h]
  int v1091; // [sp+68h] [bp-24h]
  size_t v1092; // [sp+68h] [bp-24h]
  int v1093; // [sp+68h] [bp-24h]
  int v1094; // [sp+68h] [bp-24h]
  int v1095; // [sp+68h] [bp-24h]
  int v1096; // [sp+68h] [bp-24h]
  int v1097; // [sp+68h] [bp-24h]
  int v1098; // [sp+68h] [bp-24h]
  int v1099; // [sp+68h] [bp-24h]
  int v1100; // [sp+6Ch] [bp-20h]
  int v1101; // [sp+70h] [bp-1Ch]
  int v1102; // [sp+70h] [bp-1Ch]
  unsigned int v1103; // [sp+74h] [bp-18h]
  int v1104; // [sp+74h] [bp-18h]
  int v1105; // [sp+78h] [bp-14h]
  int v1106; // [sp+78h] [bp-14h]
  int v1107; // [sp+7Ch] [bp-10h]
  int v1108; // [sp+7Ch] [bp-10h]
  int v1109; // [sp+80h] [bp-Ch]
  int v1110; // [sp+80h] [bp-Ch]
  int v1111; // [sp+84h] [bp-8h]

  v3 = a1[8];
  v4 = 32 - v3;
  n = a3;
  src = a2;
  if ( 32 - v3 > a3 )
  {
    result = memcpy((char *)a1 + v3, a2, a3);
    a1[8] = v3 + n;
  }
  else
  {
    v5 = a1[9];
    v1101 = a1[12];
    v1103 = a1[10];
    v6 = a1[11];
    v1100 = a1[13];
    v1090 = a1[14];
    v1073 = a1[15];
    v1048 = a1[16];
    v743 = a1[17];
    v715 = a1[18];
    v877 = a1[19];
    v685 = a1[20];
    v850 = a1[21];
    v654 = a1[22];
    v824 = a1[23];
    v624 = a1[24];
    v7 = a1[25];
    v8 = a1[26];
    v9 = a1[27];
    v798 = a1[29];
    v10 = a1[28];
    v11 = a1[33];
    v1025 = a1[30];
    v12 = a1[35];
    v772 = a1[31];
    v593 = a1[32];
    v563 = a1[34];
    v532 = a1[36];
    v500 = a1[37];
    v468 = a1[38];
    result = (void *)a1[39];
    v904 = a1[39];
    v930 = a1[40];
    if ( n )
    {
      v956 = v10;
      v14 = v6;
      v981 = v8;
      v15 = v3;
      v1004 = v7;
      v16 = v9;
      v17 = v5;
      while ( 1 )
      {
        if ( v4 >= n )
          v4 = n;
        v18 = (char *)a1 + v15;
        v15 += v4;
        result = memcpy(v18, src, v4);
        n -= v4;
        src += v4;
        if ( v15 == 32 )
        {
          v19 = v743 + v11;
          v20 = v1100 ^ a1[4];
          v21 = *a1 ^ v17;
          v1107 = v877 + v12;
          v22 = v1103 ^ a1[1];
          v1109 = v715 + v563;
          v23 = v1101 ^ a1[3];
          v24 = a1[2] ^ v14;
          v1105 = v19;
          v25 = v1073 ^ a1[6];
          v26 = v24 + v16;
          v1074 = v685 + v532;
          v27 = v1090 ^ a1[5];
          v1091 = v850 + v500;
          v501 = v1048 ^ a1[7];
          v1049 = v654 + v468;
          v905 = v824 + v904;
          v28 = v624 + v930;
          v931 = v21 + v1004;
          v469 = v20 + v798;
          v29 = v22 + v981;
          v30 = v23 + v956;
          v564 = v25 + v772;
          v31 = v501 + v593;
          v957 = (v21 + v1004) ^ __ROR4__(v743, 25);
          v32 = v20 + v798;
          v773 = v1105 ^ __ROR4__(v21, 25);
          v594 = v26 ^ __ROR4__(v877, 25);
          v799 = v1107 ^ __ROR4__(v24, 25);
          v33 = v715;
          v716 = v1109 ^ __ROR4__(v22, 25);
          v744 = v32 ^ __ROR4__(v850, 25);
          v34 = v1091 ^ __ROR4__(v20, 25);
          v35 = (v22 + v981) ^ __ROR4__(v33, 25);
          v36 = v30 ^ __ROR4__(v685, 25);
          v37 = v30 + v35;
          v878 = v29 + v36;
          v851 = (v685 + v532) ^ __ROR4__(v23, 25);
          v686 = v564 ^ __ROR4__(v824, 25);
          v38 = v905 ^ __ROR4__(v25, 25);
          v39 = (v27 + v1025) ^ __ROR4__(v654, 25);
          v655 = v1049 ^ __ROR4__(v27, 25);
          v40 = v31 ^ __ROR4__(v624, 25);
          v41 = v31 + v39;
          v42 = v37 ^ __ROR4__(v39, 21);
          v625 = v40;
          v43 = v41 ^ __ROR4__(v35, 21);
          v502 = v28 ^ __ROR4__(v501, 25);
          v44 = v957;
          v45 = v26 + v957;
          v825 = v931 + v594;
          v932 = v1107 + v773;
          v982 = v1105 + v799;
          v958 = v1074 + v716;
          v906 = v905 + v34;
          v46 = v564 + v744;
          v47 = (v564 + v744) ^ __ROR4__(v44, 21);
          v470 = v469 + v686;
          v565 = v1091 + v38;
          v48 = v28 + v655;
          v49 = v27 + v1025 + v625;
          v533 = v1049 + v502;
          v50 = v45 ^ __ROR4__(v744, 21);
          v51 = v773;
          v774 = v47;
          v52 = v45 + v42;
          v745 = v50;
          v1075 = v932 ^ __ROR4__(v34, 21);
          v687 = v825 ^ __ROR4__(v686, 21);
          v1050 = v906 ^ __ROR4__(v51, 21);
          v1026 = v470 ^ __ROR4__(v594, 21);
          v53 = (v1105 + v799) ^ __ROR4__(v38, 21);
          v800 = v565 ^ __ROR4__(v799, 21);
          v54 = v958 ^ __ROR4__(v655, 21);
          v656 = v48 ^ __ROR4__(v716, 21);
          v595 = v878 ^ __ROR4__(v625, 21);
          v55 = v37 + v50;
          v626 = v49 ^ __ROR4__(v36, 21);
          v503 = (v1109 + v851) ^ __ROR4__(v502, 21);
          v717 = v533 ^ __ROR4__(v851, 21);
          v959 = v958 + v1075;
          v56 = (v37 + v50) ^ __ROR4__(v1075, 25);
          v57 = v878 + v687;
          v1005 = v1109 + v851 + v53;
          v58 = (v878 + v687) ^ __ROR4__(v53, 25);
          v879 = v932 + v54;
          v933 = v48 + v1050;
          v907 = v906 + v656;
          v59 = v41 + v774;
          v852 = v46 + v43;
          v60 = v825 + v595;
          v61 = v49 + v1026;
          v471 = v470 + v626;
          v62 = v982 + v503;
          v534 = v533 + v800;
          v63 = v565;
          v566 = v56;
          v64 = v745;
          v65 = v63 + v717;
          v746 = v58;
          v826 = v959 ^ __ROR4__(v64, 25);
          v1076 = v1005 ^ __ROR4__(v687, 25);
          v688 = v52 ^ __ROR4__(v54, 25);
          v983 = v879 ^ __ROR4__(v42, 25);
          v1051 = v59 ^ __ROR4__(v1050, 25);
          v657 = (v46 + v43) ^ __ROR4__(v656, 25);
          v66 = v933 ^ __ROR4__(v774, 25);
          v67 = v907 ^ __ROR4__(v43, 25);
          v504 = v60 ^ __ROR4__(v503, 25);
          v68 = v62 ^ __ROR4__(v595, 25);
          v596 = v61 ^ __ROR4__(v800, 25);
          v775 = v534 ^ __ROR4__(v1026, 25);
          v718 = v471 ^ __ROR4__(v717, 25);
          v69 = v65 ^ __ROR4__(v626, 25);
          v70 = v65 + v67;
          v627 = v57 + v566;
          v71 = v55 + v746;
          v801 = v1005 + v826;
          v1006 = v959 + v1076;
          v72 = v60 + v688;
          v73 = v52 + v504;
          v960 = v62 + v983;
          v880 = v879 + v68;
          v74 = v61 + v1051;
          v75 = v59 + v596;
          v535 = v534 + v66;
          v934 = v933 + v775;
          v76 = v852;
          v853 = v627 ^ __ROR4__(v1051, 21);
          v472 = v471 + v657;
          v77 = v76 + v718;
          v78 = v907;
          v597 = v71 ^ __ROR4__(v596, 21);
          v908 = v74 ^ __ROR4__(v566, 21);
          v79 = v78 + v69;
          v80 = v79 ^ __ROR4__(v68, 21);
          v747 = v75 ^ __ROR4__(v746, 21);
          v81 = v801 ^ __ROR4__(v66, 21);
          v1052 = v535 ^ __ROR4__(v826, 21);
          v776 = v1006 ^ __ROR4__(v775, 21);
          v827 = v934 ^ __ROR4__(v1076, 21);
          v567 = v72 ^ __ROR4__(v657, 21);
          v689 = v472 ^ __ROR4__(v688, 21);
          v658 = v73 ^ __ROR4__(v718, 21);
          v505 = v77 ^ __ROR4__(v504, 21);
          v82 = (v62 + v983) ^ __ROR4__(v67, 21);
          v83 = v70 ^ __ROR4__(v983, 21);
          v84 = v880 ^ __ROR4__(v69, 21);
          v719 = v72 + v853;
          v628 = v627 + v567;
          v473 = v472 + v908;
          v85 = v73 + v597;
          v984 = v74 + v689;
          v86 = v1052;
          v1027 = v77 + v747;
          v87 = v71 + v658;
          v88 = v75 + v505;
          v89 = v960;
          v961 = v70 + v1052;
          v90 = v89 + v81;
          v1053 = v535 + v83;
          v91 = v801 + v82;
          v536 = v880 + v776;
          v92 = v1006 + v84;
          v93 = v87 ^ __ROR4__(v84, 25);
          v802 = v92;
          v94 = v79 + v827;
          v881 = v719 ^ __ROR4__(v81, 25);
          v95 = v934 + v80;
          v96 = v88 ^ __ROR4__(v80, 25);
          v854 = v90 ^ __ROR4__(v853, 25);
          v97 = v628 ^ __ROR4__(v82, 25);
          v98 = v87 + v97;
          v935 = v91 ^ __ROR4__(v567, 25);
          v1077 = v473 ^ __ROR4__(v86, 25);
          v99 = (v74 + v689) ^ __ROR4__(v83, 25);
          v909 = v961 ^ __ROR4__(v908, 25);
          v100 = v88 + v99;
          v101 = v98 ^ __ROR4__(v99, 21);
          v102 = v100 ^ __ROR4__(v97, 21);
          v103 = v1053 ^ __ROR4__(v689, 25);
          v568 = v85 ^ __ROR4__(v776, 25);
          v690 = v536 ^ __ROR4__(v597, 25);
          v659 = v802 ^ __ROR4__(v658, 25);
          v598 = v1027 ^ __ROR4__(v827, 25);
          v748 = v94 ^ __ROR4__(v747, 25);
          v104 = v95 ^ __ROR4__(v505, 25);
          v105 = v95 + v103;
          v506 = v104;
          v777 = v85 + v881;
          v720 = v719 + v568;
          v828 = v536 + v854;
          v537 = v628 + v93;
          v106 = v90 + v690;
          v803 = v802 + v935;
          v1007 = v91 + v659;
          v629 = v1027 + v1077;
          v474 = v473 + v598;
          v107 = v94 + v909;
          v962 = v961 + v748;
          v108 = v984 + v96;
          v109 = (v984 + v96) ^ __ROR4__(v93, 21);
          v110 = v1053 + v506;
          v985 = (v85 + v881) ^ __ROR4__(v1077, 21);
          v882 = (v1027 + v1077) ^ __ROR4__(v881, 21);
          v599 = v720 ^ __ROR4__(v598, 21);
          v569 = v474 ^ __ROR4__(v568, 21);
          v1028 = v828 ^ __ROR4__(v909, 21);
          v855 = v107 ^ __ROR4__(v854, 21);
          v749 = v106 ^ __ROR4__(v748, 21);
          v910 = v962 ^ __ROR4__(v690, 21);
          v111 = v537 ^ __ROR4__(v96, 21);
          v112 = v803 ^ __ROR4__(v103, 21);
          v691 = v105 ^ __ROR4__(v935, 21);
          v507 = (v91 + v659) ^ __ROR4__(v506, 21);
          v113 = v98 + v985;
          v114 = v659;
          v660 = v777 + v101;
          v115 = v110 ^ __ROR4__(v114, 21);
          v778 = v100 + v882;
          v630 = v629 + v102;
          v1054 = v537 + v599;
          v538 = v720 + v111;
          v721 = v108 + v569;
          v475 = v474 + v109;
          v1078 = v803 + v1028;
          v936 = v113 ^ __ROR4__(v1028, 25);
          v804 = v828 + v112;
          v829 = v105 + v855;
          v116 = v107 + v691;
          v117 = v116 ^ __ROR4__(v102, 25);
          v118 = v660 ^ __ROR4__(v112, 25);
          v119 = v1007 + v749;
          v120 = v106 + v507;
          v121 = v110 + v910;
          v122 = v962;
          v963 = v1078 ^ __ROR4__(v985, 25);
          v123 = v122 + v115;
          v124 = v123 ^ __ROR4__(v109, 25);
          v125 = v123 + v117;
          v126 = v116 + v124;
          v986 = v804 ^ __ROR4__(v101, 25);
          v127 = (v100 + v882) ^ __ROR4__(v855, 25);
          v1029 = v829 ^ __ROR4__(v882, 25);
          v883 = v630 ^ __ROR4__(v691, 25);
          v692 = v1054 ^ __ROR4__(v749, 25);
          v750 = (v1007 + v749) ^ __ROR4__(v599, 25);
          v508 = v538 ^ __ROR4__(v507, 25);
          v1008 = v120 ^ __ROR4__(v111, 25);
          v600 = (v108 + v569) ^ __ROR4__(v910, 25);
          v128 = v475 ^ __ROR4__(v115, 25);
          v570 = v121 ^ __ROR4__(v569, 25);
          v911 = v1054 + v936;
          v1055 = v119 + v963;
          v129 = v113 + v692;
          v1079 = v1078 + v750;
          v1092 = v538 + v118;
          v539 = v660 + v508;
          v130 = v120 + v986;
          v131 = v130 ^ __ROR4__(v117, 21);
          v661 = v804 + v1008;
          v132 = v121 + v1029;
          v133 = v721 + v127;
          v722 = v829 + v570;
          v134 = v778 + v600;
          v135 = v475 + v883;
          v136 = (v475 + v883) ^ __ROR4__(v118, 21);
          v476 = v630 + v128;
          v631 = v911 ^ __ROR4__(v127, 21);
          v137 = v133 ^ __ROR4__(v936, 21);
          v601 = v129 ^ __ROR4__(v600, 21);
          v693 = v134 ^ __ROR4__(v692, 21);
          v138 = v1029;
          v1030 = v132;
          v805 = v1055 ^ __ROR4__(v138, 21);
          v856 = v132 ^ __ROR4__(v963, 21);
          v830 = v1079 ^ __ROR4__(v570, 21);
          v751 = v722 ^ __ROR4__(v750, 21);
          v571 = v1092 ^ __ROR4__(v883, 21);
          v139 = v539 ^ __ROR4__(v128, 21);
          v140 = v129 + v139;
          v509 = v476 ^ __ROR4__(v508, 21);
          v141 = v986;
          v142 = v661 ^ __ROR4__(v124, 21);
          v987 = v133 + v136;
          v143 = v125 ^ __ROR4__(v141, 21);
          v884 = v126 ^ __ROR4__(v1008, 21);
          v937 = v1092 + v631;
          v912 = v911 + v571;
          v964 = v135 + v137;
          v1093 = v539 + v601;
          v477 = v476 + v693;
          v144 = v134 + v509;
          v145 = v130 + v805;
          v146 = v1055 + v131;
          v147 = v125 + v856;
          v1009 = v1030 + v143;
          v148 = v661 + v830;
          v540 = v1079 + v142;
          v149 = v126 + v751;
          v662 = v722 + v884;
          v723 = v937 ^ __ROR4__(v805, 25);
          v1031 = v145 ^ __ROR4__(v631, 25);
          v632 = v912 ^ __ROR4__(v131, 25);
          v1056 = (v1055 + v131) ^ __ROR4__(v571, 25);
          v806 = v964 ^ __ROR4__(v856, 25);
          v857 = v147 ^ __ROR4__(v137, 25);
          v150 = (v133 + v136) ^ __ROR4__(v143, 25);
          v779 = v148 ^ __ROR4__(v601, 25);
          v1080 = v1009 ^ __ROR4__(v136, 25);
          v151 = v1093 ^ __ROR4__(v830, 25);
          v152 = v140 ^ __ROR4__(v142, 25);
          v153 = v540 ^ __ROR4__(v139, 25);
          v154 = v146 + v153;
          v602 = v477 ^ __ROR4__(v751, 25);
          v694 = v149 ^ __ROR4__(v693, 25);
          v155 = v144 ^ __ROR4__(v884, 25);
          v156 = v144 + v150;
          v157 = v662 ^ __ROR4__(v509, 25);
          v510 = v1093 + v723;
          v752 = v937 + v151;
          v885 = v148 + v1031;
          v831 = v912 + v152;
          v158 = v145 + v779;
          v159 = v140 + v632;
          v160 = v159 ^ __ROR4__(v150, 21);
          v913 = v540 + v1056;
          v478 = v477 + v806;
          v541 = v964 + v602;
          v161 = v149 + v857;
          v162 = v987 + v155;
          v938 = v147 + v694;
          v163 = (v987 + v155) ^ __ROR4__(v152, 21);
          v663 = v662 + v1080;
          v164 = v1009 + v157;
          v165 = v154 ^ __ROR4__(v157, 21);
          v166 = v164 ^ __ROR4__(v153, 21);
          v807 = (v1093 + v723) ^ __ROR4__(v806, 21);
          v724 = v478 ^ __ROR4__(v723, 21);
          v167 = v964 + v602;
          v603 = v752 ^ __ROR4__(v602, 21);
          v965 = v167 ^ __ROR4__(v151, 21);
          v1094 = v885 ^ __ROR4__(v857, 21);
          v858 = v161 ^ __ROR4__(v1031, 21);
          v168 = v158 ^ __ROR4__(v694, 21);
          v169 = v158 + v165;
          v695 = v168;
          v780 = v938 ^ __ROR4__(v779, 21);
          v633 = v156 ^ __ROR4__(v632, 21);
          v572 = v831 ^ __ROR4__(v155, 21);
          v170 = v913 ^ __ROR4__(v1080, 21);
          v171 = v663 ^ __ROR4__(v1056, 21);
          v172 = v161 + v171;
          v173 = v159 + v807;
          v511 = v510 + v160;
          v988 = v156 + v724;
          v1010 = v478 + v633;
          v1032 = v831 + v603;
          v479 = v752 + v572;
          v753 = v162 + v965;
          v1057 = v541 + v163;
          v542 = v913 + v1094;
          v832 = v885 + v170;
          v664 = v663 + v858;
          v174 = v154 + v695;
          v886 = v173 ^ __ROR4__(v1094, 25);
          v175 = v164 + v780;
          v176 = v938 + v166;
          v177 = (v938 + v166) ^ __ROR4__(v163, 25);
          v914 = (v913 + v1094) ^ __ROR4__(v807, 25);
          v808 = v511 ^ __ROR4__(v170, 25);
          v939 = v832 ^ __ROR4__(v160, 25);
          v1095 = (v156 + v724) ^ __ROR4__(v858, 25);
          v725 = v664 ^ __ROR4__(v724, 25);
          v178 = v1010 ^ __ROR4__(v171, 25);
          v859 = v172 ^ __ROR4__(v633, 25);
          v179 = v172 + v177;
          v634 = v1032 ^ __ROR4__(v695, 25);
          v180 = v174 ^ __ROR4__(v603, 25);
          v181 = v780;
          v604 = v479 ^ __ROR4__(v165, 25);
          v781 = v175 ^ __ROR4__(v965, 25);
          v182 = v1057;
          v573 = v169 ^ __ROR4__(v572, 25);
          v183 = v753 ^ __ROR4__(v181, 25);
          v184 = v1057 ^ __ROR4__(v166, 25);
          v966 = v1032 + v886;
          v1033 = v173 + v634;
          v1058 = v174 + v914;
          v1081 = v542 + v180;
          v185 = v169 + v939;
          v480 = v479 + v808;
          v512 = v511 + v604;
          v833 = v832 + v573;
          v186 = v753 + v1095;
          v543 = v988 + v183;
          v187 = v175 + v725;
          v754 = v664 + v781;
          v989 = v966 ^ __ROR4__(v1095, 21);
          v665 = v1010 + v184;
          v1011 = v186 ^ __ROR4__(v886, 21);
          v887 = v1033 ^ __ROR4__(v183, 21);
          v188 = v176 + v859;
          v1096 = v543 ^ __ROR4__(v634, 21);
          v726 = (v174 + v914) ^ __ROR4__(v725, 21);
          v189 = v187 ^ __ROR4__(v914, 21);
          v782 = v1081 ^ __ROR4__(v781, 21);
          v915 = v754 ^ __ROR4__(v180, 21);
          v696 = v512 ^ __ROR4__(v184, 21);
          v190 = (v182 + v178) ^ __ROR4__(v808, 21);
          v635 = v480 ^ __ROR4__(v178, 21);
          v191 = v186 + v190;
          v605 = v665 ^ __ROR4__(v604, 21);
          v192 = v185 ^ __ROR4__(v859, 21);
          v193 = __ROR4__(v939, 21);
          v194 = v191 ^ __ROR4__(v188 ^ v193, 25);
          v195 = v833 ^ __ROR4__(v177, 21);
          v574 = v179 ^ __ROR4__(v573, 21);
          v481 = v480 + v989;
          v860 = v182 + v178 + v1011;
          v809 = v966 + v635;
          v196 = v543;
          v513 = v512 + v887;
          v544 = v188 + v189;
          v940 = v187 + (v188 ^ v193);
          v197 = v1033 + v696;
          v666 = v665 + v1096;
          v198 = v833 + v782;
          v199 = v185 + v726;
          v200 = v196 + v605;
          v201 = v1058 + v192;
          v202 = v179 + v915;
          v755 = v754 + v574;
          v727 = v481 ^ __ROR4__(v726, 25);
          v967 = v199 ^ __ROR4__(v989, 25);
          v834 = v809 ^ __ROR4__(v192, 25);
          v203 = (v1058 + v192) ^ __ROR4__(v635, 25);
          v204 = v860 ^ __ROR4__(v189, 25);
          v1012 = v544 ^ __ROR4__(v1011, 25);
          v205 = v782;
          v783 = (v1033 + v696) ^ __ROR4__(v195, 25);
          v1034 = v940 ^ __ROR4__(v190, 25);
          v636 = v513 ^ __ROR4__(v205, 25);
          v888 = v198 ^ __ROR4__(v887, 25);
          v206 = v1081 + v195;
          v990 = (v1081 + v195) ^ __ROR4__(v696, 25);
          v697 = v666 ^ __ROR4__(v915, 25);
          v916 = v202 ^ __ROR4__(v1096, 25);
          v207 = v200 ^ __ROR4__(v574, 25);
          v208 = v200 + v194;
          v575 = v207;
          v209 = __ROR4__(v605, 25);
          v514 = v513 + v727;
          v482 = v481 + v636;
          v1059 = v198 + v967;
          v210 = v197 + v834;
          v211 = v199 + v888;
          v606 = v809 + v783;
          v810 = v206 + v203;
          v212 = v201 + v990;
          v213 = v202 + v1012;
          v214 = v860 + v697;
          v1082 = v666 + v204;
          v667 = v544 + v916;
          v215 = v191 + v207;
          v545 = v755 + v1034;
          v216 = v940 + (v755 ^ v209);
          v217 = v212 ^ __ROR4__(v755 ^ v209, 21);
          v756 = v514 ^ __ROR4__(v204, 21);
          v728 = v1082 ^ __ROR4__(v727, 21);
          v698 = v482 ^ __ROR4__(v697, 21);
          v861 = v214 ^ __ROR4__(v636, 21);
          v218 = v213 ^ __ROR4__(v967, 21);
          v941 = v1059 ^ __ROR4__(v1012, 21);
          v917 = v211 ^ __ROR4__(v916, 21);
          v889 = v667 ^ __ROR4__(v888, 21);
          v637 = v210 ^ __ROR4__(v194, 21);
          v219 = v208 ^ __ROR4__(v834, 21);
          v968 = v216 ^ __ROR4__(v990, 21);
          v576 = v606 ^ __ROR4__(v575, 21);
          v991 = v210 + v756;
          v784 = v215 ^ __ROR4__(v783, 21);
          v220 = v810 ^ __ROR4__(v1034, 21);
          v221 = v545 ^ __ROR4__(v203, 21);
          v222 = v213 + v221;
          v515 = v514 + v637;
          v223 = v208 + v728;
          v1013 = v1082 + v219;
          v607 = v606 + v698;
          v224 = v482 + v576;
          v225 = v215 + v861;
          v483 = v214 + v784;
          v811 = v810 + v941;
          v1035 = v1059 + v220;
          v226 = v212 + v917;
          v546 = v545 + v218;
          v227 = v223 ^ __ROR4__(v218, 25);
          v228 = v211 + v217;
          v229 = v216 + v889;
          v668 = v667 + v968;
          v942 = v991 ^ __ROR4__(v941, 25);
          v1060 = v811 ^ __ROR4__(v756, 25);
          v757 = v515 ^ __ROR4__(v220, 25);
          v230 = v1035 ^ __ROR4__(v637, 25);
          v1097 = v222 ^ __ROR4__(v219, 25);
          v1083 = v546 ^ __ROR4__(v728, 25);
          v231 = v1013 ^ __ROR4__(v221, 25);
          v638 = v607 ^ __ROR4__(v917, 25);
          v232 = v228 ^ __ROR4__(v576, 25);
          v233 = v228 + v230;
          v729 = v226 ^ __ROR4__(v698, 25);
          v835 = v232;
          v234 = v225 ^ __ROR4__(v889, 25);
          v235 = v225 + v227;
          v577 = v234;
          v236 = v224 ^ __ROR4__(v217, 25);
          v862 = v229 ^ __ROR4__(v861, 25);
          v699 = v483 ^ __ROR4__(v968, 25);
          v785 = v668 ^ __ROR4__(v784, 25);
          v608 = v607 + v942;
          v890 = v991 + v638;
          v237 = v226 + v1060;
          v812 = v811 + v729;
          v238 = v224 + v757;
          v516 = v515 + v236;
          v918 = v1035 + v835;
          v239 = v223 + v234;
          v969 = v229 + v1083;
          v240 = v546 + v862;
          v241 = v483;
          v484 = v1013 + v699;
          v242 = v241 + v231;
          v243 = v238 ^ __ROR4__(v231, 21);
          v547 = v668 + v1097;
          v244 = v222 + v785;
          v669 = v608 ^ __ROR4__(v227, 21);
          v245 = v1060;
          v943 = v235 ^ __ROR4__(v942, 21);
          v1061 = v240;
          v578 = (v991 + v638) ^ __ROR4__(v577, 21);
          v992 = v239 ^ __ROR4__(v638, 21);
          v1036 = v237 ^ __ROR4__(v1083, 21);
          v246 = v969 ^ __ROR4__(v245, 21);
          v863 = v812 ^ __ROR4__(v862, 21);
          v1014 = v240 ^ __ROR4__(v729, 21);
          v247 = v242 ^ __ROR4__(v757, 21);
          v639 = v516 ^ __ROR4__(v699, 21);
          v700 = v484 ^ __ROR4__(v236, 21);
          v248 = v547 ^ __ROR4__(v230, 21);
          v249 = v233 ^ __ROR4__(v1097, 21);
          v250 = v237 + v249;
          v730 = v918 ^ __ROR4__(v785, 21);
          v758 = v244 ^ __ROR4__(v835, 21);
          v786 = v238 + v669;
          v836 = v235 + v247;
          v609 = v608 + v243;
          v251 = v250 ^ __ROR4__(v243, 25);
          v252 = v242 + v943;
          v517 = v516 + v578;
          v485 = v484 + v992;
          v253 = v890 + v639;
          v254 = v547 + v246;
          v255 = v252 ^ __ROR4__(v246, 25);
          v891 = v239 + v700;
          v256 = v1036;
          v548 = v918 + v863;
          v257 = v233 + v1036;
          v1037 = v254;
          v813 = v812 + v730;
          v258 = v969 + v248;
          v259 = v244 + v1014;
          v260 = (v969 + v248) ^ __ROR4__(v247, 25);
          v919 = v1061 + v758;
          v970 = v786 ^ __ROR4__(v256, 25);
          v1062 = v257 ^ __ROR4__(v669, 25);
          v261 = v609 ^ __ROR4__(v249, 25);
          v1084 = v1037 ^ __ROR4__(v943, 25);
          v262 = v836 ^ __ROR4__(v248, 25);
          v670 = v517 ^ __ROR4__(v863, 25);
          v864 = v548 ^ __ROR4__(v578, 25);
          v263 = v253 ^ __ROR4__(v730, 25);
          v264 = v253 + v261;
          v579 = v263;
          v944 = v813 ^ __ROR4__(v639, 25);
          v640 = v485 ^ __ROR4__(v1014, 25);
          v993 = v259 ^ __ROR4__(v992, 25);
          v731 = v891 ^ __ROR4__(v758, 25);
          v265 = __ROR4__(v700, 25);
          v266 = v258 + (v919 ^ v265);
          v518 = v517 + v970;
          v701 = v786 + v670;
          v759 = v548 + v1062;
          v1015 = v257 + v864;
          v549 = v609 + v263;
          v787 = v813 + v251;
          v267 = v250 + v944;
          v268 = v267 ^ __ROR4__(v919 ^ v265, 21);
          v486 = v485 + v255;
          v610 = v252 + v640;
          v269 = v259 + v1084;
          v1038 = v1037 + v993;
          v270 = v891 + v262;
          v271 = v264 ^ __ROR4__(v262, 21);
          v272 = v836 + v731;
          v814 = v919 + v260;
          v837 = v518 ^ __ROR4__(v255, 21);
          v892 = v486 ^ __ROR4__(v970, 21);
          v641 = v701 ^ __ROR4__(v640, 21);
          v920 = v610 ^ __ROR4__(v670, 21);
          v971 = v759 ^ __ROR4__(v1084, 21);
          v273 = v269 ^ __ROR4__(v1062, 21);
          v994 = (v257 + v864) ^ __ROR4__(v993, 21);
          v1063 = v1038 ^ __ROR4__(v864, 21);
          v865 = v270 ^ __ROR4__(v261, 21);
          v671 = v549 ^ __ROR4__(v731, 21);
          v274 = v814 ^ __ROR4__(v251, 21);
          v580 = v272 ^ __ROR4__(v579, 21);
          v732 = v266 ^ __ROR4__(v944, 21);
          v275 = v787 ^ __ROR4__(v260, 21);
          v945 = v264 + v837;
          v519 = v518 + v271;
          v276 = v270 + v892;
          v1085 = v486 + v865;
          v487 = v549 + v641;
          v277 = v701 + v671;
          v278 = v272 + v920;
          v279 = v610 + v580;
          v280 = v759;
          v550 = v787 + v971;
          v760 = v269 + v274;
          v611 = v280 + v275;
          v281 = v266 + v1063;
          v788 = v1038 + v732;
          v282 = v814 + v273;
          v283 = v276 ^ __ROR4__(v273, 25);
          v702 = v282;
          v284 = v267 + v994;
          v815 = v945 ^ __ROR4__(v971, 25);
          v285 = v1015 + v268;
          v286 = v277 ^ __ROR4__(v268, 25);
          v972 = v550 ^ __ROR4__(v837, 25);
          v287 = v519 ^ __ROR4__(v275, 25);
          v288 = v277 + v287;
          v1016 = v611 ^ __ROR4__(v271, 25);
          v1039 = v702 ^ __ROR4__(v892, 25);
          v289 = v1085 ^ __ROR4__(v274, 25);
          v290 = v760 ^ __ROR4__(v865, 25);
          v838 = v487 ^ __ROR4__(v994, 25);
          v291 = v279 ^ __ROR4__(v732, 25);
          v292 = v279 + v289;
          v293 = v292 ^ __ROR4__(v287, 21);
          v294 = v288 ^ __ROR4__(v289, 21);
          v866 = v284 ^ __ROR4__(v641, 25);
          v295 = v671;
          v672 = v291;
          v893 = v285 ^ __ROR4__(v295, 25);
          v296 = v278 ^ __ROR4__(v1063, 25);
          v297 = v278 + v283;
          v921 = v281 ^ __ROR4__(v920, 25);
          v581 = v788 ^ __ROR4__(v580, 25);
          v488 = v487 + v815;
          v733 = v945 + v838;
          v298 = v284 + v972;
          v946 = v550 + v866;
          v1064 = v519 + v286;
          v299 = v285 + v1016;
          v612 = v611 + v893;
          v520 = v276 + v296;
          v300 = v281 + v1039;
          v995 = v702 + v921;
          v551 = v1085 + v291;
          v703 = v788 + v290;
          v301 = v299 ^ __ROR4__(v290, 21);
          v302 = v760;
          v761 = v488 ^ __ROR4__(v283, 21);
          v789 = v297 ^ __ROR4__(v815, 21);
          v303 = v302 + v581;
          v642 = v733 ^ __ROR4__(v296, 21);
          v839 = v520 ^ __ROR4__(v838, 21);
          v1040 = v298 ^ __ROR4__(v1039, 21);
          v304 = v300 ^ __ROR4__(v972, 21);
          v922 = v946 ^ __ROR4__(v921, 21);
          v973 = v995 ^ __ROR4__(v866, 21);
          v673 = v1064 ^ __ROR4__(v672, 21);
          v867 = v551 ^ __ROR4__(v286, 21);
          v305 = v703 ^ __ROR4__(v1016, 21);
          v306 = v300 + v305;
          v582 = v612 ^ __ROR4__(v581, 21);
          v894 = v303 ^ __ROR4__(v893, 21);
          v1017 = v288 + v761;
          v489 = v488 + v294;
          v307 = v292 + v789;
          v308 = v297 + v293;
          v309 = v308 ^ __ROR4__(v305, 25);
          v310 = v733 + v673;
          v552 = v551 + v839;
          v311 = v520 + v867;
          v312 = v299 + v1040;
          v521 = v298 + v301;
          v313 = v703 + v304;
          v314 = v307 ^ __ROR4__(v304, 25);
          v1098 = v313;
          v613 = v612 + v922;
          v704 = v946 + v582;
          v315 = v303 + v973;
          v734 = v995 + v894;
          v947 = v1017 ^ __ROR4__(v1040, 25);
          v996 = v312 ^ __ROR4__(v761, 25);
          v316 = v489 ^ __ROR4__(v301, 25);
          v1041 = v521 ^ __ROR4__(v294, 25);
          v317 = v306 ^ __ROR4__(v293, 25);
          v318 = v1064 + v642;
          v1065 = v313 ^ __ROR4__(v789, 25);
          v762 = v318 ^ __ROR4__(v922, 25);
          v790 = v613 ^ __ROR4__(v642, 25);
          v319 = v310 ^ __ROR4__(v582, 25);
          v320 = v310 + v316;
          v583 = v319;
          v816 = v704 ^ __ROR4__(v673, 25);
          v643 = v552 ^ __ROR4__(v973, 25);
          v840 = v315 ^ __ROR4__(v839, 25);
          v321 = v311 ^ __ROR4__(v894, 25);
          v322 = v311 + v309;
          v323 = v320 ^ __ROR4__(v309, 21);
          v324 = v322 ^ __ROR4__(v316, 21);
          v674 = v321;
          v325 = __ROR4__(v867, 25);
          v326 = v306 + (v734 ^ v325);
          v868 = v318 + v947;
          v895 = v1017 + v762;
          v614 = v613 + v996;
          v327 = v312 + v790;
          v490 = v489 + v583;
          v705 = v704 + v1041;
          v328 = v521 + v816;
          v329 = (v521 + v816) ^ __ROR4__(v734 ^ v325, 21);
          v522 = v552 + v314;
          v553 = v307 + v643;
          v330 = v315 + v1065;
          v923 = v1098 + v840;
          v331 = v308 + v674;
          v735 = v734 + v317;
          v974 = (v318 + v947) ^ __ROR4__(v314, 21);
          v948 = v522 ^ __ROR4__(v947, 21);
          v644 = (v1017 + v762) ^ __ROR4__(v643, 21);
          v763 = v553 ^ __ROR4__(v762, 21);
          v1018 = v614 ^ __ROR4__(v1065, 21);
          v332 = v330 ^ __ROR4__(v996, 21);
          v333 = v1098 + v840;
          v841 = v327 ^ __ROR4__(v840, 21);
          v997 = v333 ^ __ROR4__(v790, 21);
          v675 = v490 ^ __ROR4__(v674, 21);
          v334 = v1041;
          v817 = v326 ^ __ROR4__(v816, 21);
          v584 = v331 ^ __ROR4__(v583, 21);
          v1042 = v320 + v974;
          v335 = v705 ^ __ROR4__(v317, 21);
          v336 = v735 ^ __ROR4__(v334, 21);
          v337 = v330 + v336;
          v869 = v868 + v323;
          v1066 = v322 + v948;
          v523 = v522 + v324;
          v338 = v337 ^ __ROR4__(v324, 25);
          v491 = v490 + v644;
          v339 = v895 + v675;
          v340 = v331 + v763;
          v341 = v553 + v584;
          v554 = v705 + v1018;
          v615 = v614 + v335;
          v706 = v735 + v332;
          v342 = v328 + v841;
          v343 = v327 + v329;
          v344 = v326 + v997;
          v736 = v923 + v817;
          v896 = v1042 ^ __ROR4__(v1018, 25);
          v924 = v554 ^ __ROR4__(v974, 25);
          v345 = (v322 + v948) ^ __ROR4__(v332, 25);
          v346 = v869 ^ __ROR4__(v335, 25);
          v975 = v615 ^ __ROR4__(v323, 25);
          v1019 = v706 ^ __ROR4__(v948, 25);
          v347 = v523 ^ __ROR4__(v336, 25);
          v842 = v491 ^ __ROR4__(v841, 25);
          v949 = v342 ^ __ROR4__(v644, 25);
          v348 = v340 ^ __ROR4__(v997, 25);
          v791 = v343 ^ __ROR4__(v675, 25);
          v349 = v340 + v345;
          v645 = v348;
          v350 = v339 ^ __ROR4__(v329, 25);
          v351 = v339 + v346;
          v764 = v344 ^ __ROR4__(v763, 25);
          v352 = v341 ^ __ROR4__(v817, 25);
          v353 = v341 + v347;
          v354 = v351 ^ __ROR4__(v347, 21);
          v676 = v352;
          v355 = v353 ^ __ROR4__(v346, 21);
          v585 = v736 ^ __ROR4__(v584, 25);
          v492 = v491 + v896;
          v818 = v1042 + v842;
          v356 = v342 + v924;
          v998 = v554 + v949;
          v555 = v869 + v350;
          v357 = v343 + v975;
          v616 = v615 + v791;
          v358 = v1066 + v645;
          v870 = v344 + v1019;
          v1043 = v706 + v764;
          v524 = v523 + v676;
          v707 = v736 + v338;
          v359 = v357 ^ __ROR4__(v338, 21);
          v360 = v337 + v585;
          v737 = v492 ^ __ROR4__(v345, 21);
          v897 = v349 ^ __ROR4__(v896, 21);
          v646 = v818 ^ __ROR4__(v645, 21);
          v843 = v358 ^ __ROR4__(v842, 21);
          v361 = v356 ^ __ROR4__(v1019, 21);
          v362 = v356 + v359;
          v1067 = v361;
          v363 = (v344 + v1019) ^ __ROR4__(v924, 21);
          v925 = v998 ^ __ROR4__(v764, 21);
          v950 = v1043 ^ __ROR4__(v949, 21);
          v677 = v555 ^ __ROR4__(v676, 21);
          v765 = v524 ^ __ROR4__(v350, 21);
          v364 = v707 ^ __ROR4__(v975, 21);
          v586 = v616 ^ __ROR4__(v585, 21);
          v792 = v360 ^ __ROR4__(v791, 21);
          v976 = v351 + v737;
          v1020 = v349 + v355;
          v493 = v492 + v354;
          v365 = v362 ^ __ROR4__(v354, 25);
          v366 = v353 + v897;
          v367 = v818;
          v556 = v555 + v646;
          v819 = v358 + v765;
          v368 = v1067;
          v369 = v367 + v677;
          v370 = v357 + v1067;
          v525 = v524 + v843;
          v1068 = v707 + v363;
          v371 = v366 ^ __ROR4__(v363, 25);
          v372 = v870 + v364;
          v373 = (v870 + v364) ^ __ROR4__(v355, 25);
          v617 = v616 + v925;
          v708 = v998 + v586;
          v374 = v360 + v950;
          v871 = v1043 + v792;
          v999 = v976 ^ __ROR4__(v368, 25);
          v1044 = v370 ^ __ROR4__(v737, 25);
          v375 = v493 ^ __ROR4__(v359, 25);
          v1086 = v1068 ^ __ROR4__(v897, 25);
          v376 = v1020 ^ __ROR4__(v364, 25);
          v738 = v556 ^ __ROR4__(v925, 25);
          v898 = v617 ^ __ROR4__(v646, 25);
          v377 = v369 ^ __ROR4__(v586, 25);
          v378 = v369 + v375;
          v587 = v377;
          v926 = v708 ^ __ROR4__(v677, 25);
          v647 = v525 ^ __ROR4__(v950, 25);
          v844 = v374 ^ __ROR4__(v843, 25);
          v678 = v819 ^ __ROR4__(v792, 25);
          v379 = __ROR4__(v765, 25);
          v380 = v372 + (v871 ^ v379);
          v557 = v556 + v999;
          v766 = v976 + v738;
          v793 = v617 + v1044;
          v951 = v370 + v898;
          v494 = v493 + v377;
          v709 = v708 + v365;
          v381 = v362 + v926;
          v382 = v381 ^ __ROR4__(v871 ^ v379, 21);
          v526 = v525 + v371;
          v618 = v366 + v647;
          v383 = v374 + v1086;
          v977 = v1068 + v844;
          v384 = v819 + v376;
          v385 = v378 ^ __ROR4__(v376, 21);
          v386 = v1020 + v678;
          v820 = v871 + v373;
          v872 = v557 ^ __ROR4__(v371, 21);
          v1000 = v526 ^ __ROR4__(v999, 21);
          v648 = v766 ^ __ROR4__(v647, 21);
          v1021 = v618 ^ __ROR4__(v738, 21);
          v1069 = v793 ^ __ROR4__(v1086, 21);
          v387 = v383 ^ __ROR4__(v1044, 21);
          v845 = (v370 + v898) ^ __ROR4__(v844, 21);
          v899 = v977 ^ __ROR4__(v898, 21);
          v739 = v384 ^ __ROR4__(v375, 21);
          v679 = v494 ^ __ROR4__(v678, 21);
          v388 = v820 ^ __ROR4__(v365, 21);
          v588 = v386 ^ __ROR4__(v587, 21);
          v927 = v380 ^ __ROR4__(v926, 21);
          v389 = v709 ^ __ROR4__(v373, 21);
          v1045 = v378 + v872;
          v558 = v557 + v385;
          v390 = v384 + v1000;
          v527 = v526 + v739;
          v495 = v494 + v648;
          v391 = v766 + v679;
          v392 = v386 + v1021;
          v393 = v618 + v588;
          v394 = v793;
          v619 = v709 + v1069;
          v794 = v383 + v388;
          v710 = v394 + v389;
          v395 = v380 + v899;
          v396 = v820;
          v821 = v977 + v927;
          v397 = v396 + v387;
          v398 = v390 ^ __ROR4__(v387, 25);
          v767 = v397;
          v399 = v381 + v845;
          v400 = v951;
          v952 = v1045 ^ __ROR4__(v1069, 25);
          v401 = v400 + v382;
          v402 = v391 ^ __ROR4__(v382, 25);
          v873 = v619 ^ __ROR4__(v872, 25);
          v403 = v558 ^ __ROR4__(v389, 25);
          v404 = v391 + v403;
          v978 = v710 ^ __ROR4__(v385, 25);
          v1070 = v767 ^ __ROR4__(v1000, 25);
          v405 = v527 ^ __ROR4__(v388, 25);
          v406 = v794 ^ __ROR4__(v739, 25);
          v740 = v495 ^ __ROR4__(v845, 25);
          v407 = v393 ^ __ROR4__(v927, 25);
          v408 = v393 + v405;
          v409 = v408 ^ __ROR4__(v403, 21);
          v410 = v404 ^ __ROR4__(v405, 21);
          v846 = v399 ^ __ROR4__(v648, 25);
          v411 = v679;
          v680 = v407;
          v1001 = v401 ^ __ROR4__(v411, 25);
          v649 = v392 ^ __ROR4__(v899, 25);
          v900 = v395 ^ __ROR4__(v1021, 25);
          v589 = v821 ^ __ROR4__(v588, 25);
          v496 = v495 + v952;
          v928 = v1045 + v740;
          v412 = v399 + v873;
          v1022 = v619 + v846;
          v1087 = v558 + v402;
          v559 = v392 + v398;
          v413 = v401 + v978;
          v620 = v390 + v649;
          v414 = v395 + v1070;
          v711 = v710 + v1001;
          v1046 = v767 + v900;
          v528 = v527 + v407;
          v768 = v821 + v406;
          v415 = v413 ^ __ROR4__(v406, 21);
          v416 = v794 + v589;
          v417 = v496 ^ __ROR4__(v398, 21);
          v795 = v559 ^ __ROR4__(v952, 21);
          v650 = v928 ^ __ROR4__(v649, 21);
          v822 = v620 ^ __ROR4__(v740, 21);
          v953 = v412 ^ __ROR4__(v1070, 21);
          v418 = v414 ^ __ROR4__(v873, 21);
          v874 = v1022 ^ __ROR4__(v900, 21);
          v901 = v1046 ^ __ROR4__(v846, 21);
          v681 = v1087 ^ __ROR4__(v680, 21);
          v847 = v528 ^ __ROR4__(v402, 21);
          v419 = v768 ^ __ROR4__(v978, 21);
          v420 = v414 + v419;
          v590 = v711 ^ __ROR4__(v589, 21);
          v421 = v1001;
          v1002 = v404 + v417;
          v497 = v496 + v410;
          v979 = v416 ^ __ROR4__(v421, 21);
          v422 = v408 + v795;
          v560 = v559 + v409;
          v1071 = v1087 + v650;
          v529 = v528 + v822;
          v423 = v620 + v847;
          v424 = v413 + v953;
          v621 = v412 + v415;
          v425 = v768 + v418;
          v426 = v424 ^ __ROR4__(v417, 25);
          v427 = v422 ^ __ROR4__(v418, 25);
          v1088 = v425;
          v712 = v711 + v874;
          v769 = v1022 + v590;
          v428 = v416 + v901;
          v1023 = v1046 + v979;
          v954 = v1002 ^ __ROR4__(v953, 25);
          v429 = v497 ^ __ROR4__(v415, 25);
          v1047 = v621 ^ __ROR4__(v410, 25);
          v430 = v425 ^ __ROR4__(v795, 25);
          v431 = v560 ^ __ROR4__(v419, 25);
          v432 = v420 ^ __ROR4__(v409, 25);
          v741 = v1071 ^ __ROR4__(v874, 25);
          v796 = v712 ^ __ROR4__(v650, 25);
          v433 = v928 + v681 + v429;
          v591 = (v928 + v681) ^ __ROR4__(v590, 25);
          v875 = v769 ^ __ROR4__(v681, 25);
          v651 = v529 ^ __ROR4__(v901, 25);
          v823 = v428 ^ __ROR4__(v822, 25);
          v434 = v423 ^ __ROR4__(v979, 25);
          v435 = v423 + v431;
          v436 = v433 ^ __ROR4__(v431, 21);
          v437 = v435 ^ __ROR4__(v429, 21);
          v682 = v434;
          v438 = v1023 ^ __ROR4__(v847, 25);
          v848 = v1071 + v954;
          v902 = v1002 + v741;
          v713 = v712 + v426;
          v439 = v424 + v796;
          v498 = v497 + v591;
          v770 = v769 + v1047;
          v440 = v621 + v875;
          v530 = v529 + v427;
          v622 = v428 + v430;
          v441 = v422 + v651;
          v1003 = v1088 + v823;
          v561 = v560 + v682;
          v980 = v1023 + v432;
          v929 = (v1071 + v954) ^ __ROR4__(v427, 21);
          v442 = v420 + v438;
          v443 = v440 ^ __ROR4__(v438, 21);
          v955 = v530 ^ __ROR4__(v954, 21);
          v652 = v902 ^ __ROR4__(v651, 21);
          v742 = v441 ^ __ROR4__(v741, 21);
          v444 = v713 ^ __ROR4__(v430, 21);
          v445 = v622 ^ __ROR4__(v426, 21);
          v446 = v439 ^ __ROR4__(v823, 21);
          v447 = v439 + v443;
          v1024 = (v1088 + v823) ^ __ROR4__(v796, 21);
          v683 = v498 ^ __ROR4__(v682, 21);
          v592 = v561 ^ __ROR4__(v591, 21);
          v448 = v770 ^ __ROR4__(v432, 21);
          v797 = v980 ^ __ROR4__(v1047, 21);
          v876 = v442 ^ __ROR4__(v875, 21);
          v449 = v433 + v929;
          v849 = v848 + v436;
          v450 = v435 + v955;
          v1072 = v530 + v437;
          v499 = v498 + v652;
          v531 = v902 + v683;
          v903 = v561 + v742;
          v1089 = v441 + v592;
          v451 = v770 + v444;
          v452 = v449 ^ __ROR4__(v444, 25);
          v562 = v451;
          v453 = v713 + v448;
          v454 = (v713 + v448) ^ __ROR4__(v436, 25);
          v714 = v980 + v445;
          v455 = v450 ^ __ROR4__(v445, 25);
          v771 = v622 + v797;
          v623 = v440 + v446;
          v456 = v442 + v1024;
          v1099 = v1003 + v876;
          v457 = v849 ^ __ROR4__(v448, 25);
          v1106 = v451 ^ __ROR4__(v929, 25);
          v1104 = v1072 ^ __ROR4__(v797, 25);
          v458 = v771 ^ __ROR4__(v437, 25);
          v1102 = v499 ^ __ROR4__(v446, 25);
          v1108 = (v440 + v446) ^ __ROR4__(v652, 25);
          v459 = v531 ^ __ROR4__(v443, 25);
          v1110 = v447 ^ __ROR4__(v683, 25);
          v11 = v447 + v454;
          v460 = v903 ^ __ROR4__(v1024, 25);
          v684 = v456 ^ __ROR4__(v742, 25);
          v653 = v1089 ^ __ROR4__(v876, 25);
          v461 = v623;
          v593 = v450 + v460;
          v1111 = (v1003 + v876) ^ __ROR4__(v592, 25);
          v462 = v714 ^ __ROR4__(v955, 25);
          v981 = v499 + v452;
          v468 = v456 + v462;
          v956 = v449 + v1102;
          v563 = v461 + v1106;
          v532 = v562 + v1108;
          v16 = v849 + v459;
          v1004 = v531 + v457;
          v1025 = v903 + v455;
          v12 = v453 + v1110;
          v930 = v684 + v714;
          v798 = v1089 + v1104;
          v772 = v1072 + v653;
          v500 = v1099 + v458;
          v1100 = (v903 + v455) ^ __ROR4__(v452, 21);
          v904 = v771 + v1111;
          v14 = (v449 + v1102) ^ __ROR4__(v460, 21);
          v17 = v981 ^ __ROR4__(v455, 21);
          v1073 = v593 ^ __ROR4__(v1102, 21);
          v743 = (v461 + v1106) ^ __ROR4__(v462, 21);
          v850 = (v456 + v462) ^ __ROR4__(v1106, 21);
          v877 = v532 ^ __ROR4__(v684, 21);
          result = (void *)(v1004 ^ __ROR4__(v1104, 21));
          v824 = (v684 + v714) ^ __ROR4__(v1108, 21);
          v1103 = (unsigned int)result;
          v1090 = v798 ^ __ROR4__(v457, 21);
          v1101 = v16 ^ __ROR4__(v653, 21);
          v1048 = (v1072 + v653) ^ __ROR4__(v459, 21);
          v463 = __ROR4__(v458, 21);
          v15 = 0;
          v715 = v11 ^ v463;
          v654 = v500 ^ __ROR4__(v454, 21);
          v685 = v12 ^ __ROR4__(v1111, 21);
          v624 = v904 ^ __ROR4__(v1110, 21);
        }
        if ( !n )
          break;
        v4 = 32 - v15;
      }
      v9 = v16;
      v6 = v14;
      v5 = v17;
      v3 = v15;
      v10 = v956;
      v7 = v1004;
      v8 = v981;
    }
    a1[9] = v5;
    a1[11] = v6;
    a1[25] = v7;
    a1[10] = v1103;
    a1[12] = v1101;
    a1[13] = v1100;
    a1[14] = v1090;
    a1[15] = v1073;
    a1[16] = v1048;
    a1[17] = v743;
    a1[18] = v715;
    a1[19] = v877;
    a1[20] = v685;
    a1[21] = v850;
    a1[22] = v654;
    a1[23] = v824;
    a1[24] = v624;
    a1[26] = v8;
    a1[27] = v9;
    a1[28] = v10;
    a1[29] = v798;
    a1[33] = v11;
    a1[35] = v12;
    a1[30] = v1025;
    a1[8] = v3;
    a1[31] = v772;
    a1[32] = v593;
    a1[34] = v563;
    a1[36] = v532;
    a1[37] = v500;
    a1[38] = v468;
    a1[39] = v904;
    a1[40] = v930;
  }
  return result;
}
// 9A5AC: too many cbuild loops

//----- (0009D714) --------------------------------------------------------
unsigned int __fastcall sub_9D714(_DWORD *a1, char a2, char a3, _WORD *a4, int a5)
{
  int v6; // lr
  int v7; // r6
  int v8; // r11
  int v9; // r10
  int v10; // r0
  int v11; // r12
  int v12; // r9
  int v13; // r1
  int v14; // r8
  int v15; // lr
  int v16; // r7
  int v17; // r4
  int v18; // r3
  int v19; // r9
  int v20; // r10
  int v21; // r11
  int v22; // r12
  int v23; // r5
  int v24; // r8
  int v25; // r11
  int v26; // r6
  int v27; // r0
  int v28; // r1
  int v29; // lr
  int v30; // r9
  int v31; // lr
  int v32; // r5
  int v33; // r2
  int v34; // r2
  int v35; // r3
  int v36; // lr
  int v37; // lr
  int v38; // r1
  int v39; // r10
  int v40; // r7
  int v41; // r4
  int v42; // r8
  int v43; // r6
  int v44; // r5
  int v45; // r11
  int v46; // r2
  int v47; // r3
  int v48; // r12
  int v49; // r4
  int v50; // lr
  int v51; // r0
  int v52; // r4
  int v53; // r10
  int v54; // r8
  int v55; // r5
  int v56; // r6
  int v57; // r7
  int v58; // r9
  int v59; // t2
  int v60; // r2
  int v61; // r1
  int v62; // r11
  int v63; // lr
  int v64; // r3
  int v65; // r2
  int v66; // r4
  int v67; // r2
  int v68; // r8
  int v69; // r9
  int v70; // r10
  int v71; // r6
  int v72; // r1
  int v73; // r11
  int v74; // r5
  int v75; // r0
  int v76; // r2
  int v77; // lr
  int v78; // r10
  int v79; // r4
  int v80; // r12
  int v81; // r9
  int v82; // r7
  int v83; // r0
  int v84; // r12
  int v85; // r1
  int v86; // r8
  int v87; // r4
  int v88; // r11
  int v89; // r7
  int v90; // r5
  int v91; // lr
  int v92; // r3
  int v93; // r9
  int v94; // r8
  int v95; // r2
  int v96; // r1
  int v97; // r10
  int v98; // r11
  int v99; // r12
  int v100; // r6
  int v101; // lr
  int v102; // r0
  int v103; // r3
  int v104; // r0
  int v105; // r5
  int v106; // r0
  int v107; // r4
  int v108; // r2
  int v109; // r10
  int v110; // r11
  int v111; // r8
  int v112; // r7
  int v113; // r9
  int v114; // r6
  int v115; // r4
  int v116; // lr
  int v117; // r5
  int v118; // r12
  int v119; // r3
  int v120; // r9
  int v121; // r2
  int v122; // r3
  int v123; // r3
  int v124; // r6
  int v125; // r12
  int v126; // r5
  int v127; // r10
  int v128; // r1
  int v129; // r0
  int v130; // r11
  int v131; // r1
  int v132; // r0
  int v133; // r0
  int v134; // r2
  int v135; // r3
  int v136; // r4
  int v137; // r11
  int v138; // r7
  int v139; // r1
  int v140; // r0
  int v141; // r9
  int v142; // lr
  int v143; // r6
  int v144; // r6
  int v145; // r8
  int v146; // r5
  int v147; // lr
  int v148; // r10
  int v149; // r3
  int v150; // r8
  int v151; // r4
  int v152; // r3
  int v153; // r11
  int v154; // r9
  int v155; // r2
  int v156; // r6
  int v157; // r7
  int v158; // r5
  int v159; // r1
  int v160; // lr
  int v161; // r10
  int v162; // r3
  int v163; // r12
  int v164; // r9
  int v165; // r12
  int v166; // r0
  int v167; // r4
  int v168; // r2
  int v169; // r11
  int v170; // r3
  int v171; // r10
  int v172; // r8
  int v173; // r6
  int v174; // r1
  int v175; // r5
  int v176; // r3
  int v177; // r9
  int v178; // lr
  int v179; // r11
  int v180; // r12
  int v181; // r0
  int v182; // r1
  int v183; // r2
  int v184; // r4
  int v185; // r3
  int v186; // r8
  int v187; // r10
  int v188; // r7
  int v189; // lr
  int v190; // r1
  int v191; // r12
  int v192; // r1
  int v193; // r1
  int v194; // r0
  int v195; // r2
  int v196; // r5
  int v197; // r3
  int v198; // r4
  int v199; // r8
  int v200; // r4
  int v201; // r7
  int v202; // r11
  int v203; // r3
  int v204; // r9
  int v205; // r6
  int v206; // r1
  int v207; // r10
  int v208; // r0
  int v209; // r5
  int v210; // lr
  int v211; // r10
  int v212; // r3
  int v213; // r8
  int v214; // r4
  int v215; // r3
  int v216; // r11
  int v217; // r9
  int v218; // r2
  int v219; // r6
  int v220; // r7
  int v221; // r10
  int v222; // r1
  int v223; // r5
  int v224; // r1
  int v225; // lr
  int v226; // r3
  int v227; // r12
  int v228; // r9
  int v229; // r1
  int v230; // r12
  int v231; // r0
  int v232; // r4
  int v233; // r2
  int v234; // r11
  int v235; // r3
  int v236; // r10
  int v237; // r8
  int v238; // r6
  int v239; // r5
  int v240; // lr
  int v241; // r11
  int v242; // r12
  int v243; // r0
  int v244; // r9
  int v245; // r1
  int v246; // r2
  int v247; // r4
  int v248; // r3
  int v249; // r8
  int v250; // r10
  int v251; // r7
  int v252; // lr
  int v253; // r1
  int v254; // r12
  int v255; // r1
  int v256; // r1
  int v257; // r0
  int v258; // r2
  int v259; // r5
  int v260; // r7
  int v261; // r3
  int v262; // r4
  int v263; // r8
  int v264; // r4
  int v265; // r11
  int v266; // r3
  int v267; // r9
  int v268; // r6
  int v269; // r1
  int v270; // r10
  int v271; // r0
  int v272; // r5
  int v273; // lr
  int v274; // r10
  int v275; // r3
  int v276; // r8
  int v277; // r4
  int v278; // r3
  int v279; // r11
  int v280; // r9
  int v281; // r2
  int v282; // r6
  int v283; // r7
  int v284; // r10
  int v285; // r1
  int v286; // r5
  int v287; // r1
  int v288; // lr
  int v289; // r3
  int v290; // r12
  int v291; // r9
  int v292; // r1
  int v293; // r12
  int v294; // r0
  int v295; // r4
  int v296; // r2
  int v297; // r11
  int v298; // r3
  int v299; // r10
  int v300; // r8
  int v301; // r6
  int v302; // lr
  int v303; // r5
  int v304; // r11
  int v305; // r3
  int v306; // r9
  int v307; // r7
  int v308; // r12
  int v309; // r1
  int v310; // r2
  int v311; // r4
  int v312; // r3
  int v313; // r8
  int v314; // r10
  int v315; // r7
  int v316; // lr
  int v317; // r1
  int v318; // r12
  int v319; // r1
  int v320; // r1
  int v321; // r0
  int v322; // r2
  int v323; // r5
  int v324; // r7
  int v325; // r3
  int v326; // r4
  int v327; // r8
  int v328; // r4
  int v329; // r11
  int v330; // r3
  int v331; // r9
  int v332; // r6
  int v333; // r1
  int v334; // r10
  int v335; // r0
  int v336; // r5
  int v337; // lr
  int v338; // r10
  int v339; // r3
  int v340; // r8
  int v341; // r4
  int v342; // r3
  int v343; // r11
  int v344; // r9
  int v345; // r2
  int v346; // r6
  int v347; // r7
  int v348; // r10
  int v349; // r1
  int v350; // r5
  int v351; // r1
  int v352; // lr
  int v353; // r3
  int v354; // r12
  int v355; // r9
  int v356; // r1
  int v357; // r12
  int v358; // r0
  int v359; // r4
  int v360; // r2
  int v361; // r11
  int v362; // r3
  int v363; // r10
  int v364; // r8
  int v365; // r6
  int v366; // r1
  int v367; // r5
  int v368; // r3
  int v369; // r9
  int v370; // lr
  int v371; // r11
  int v372; // r7
  int v373; // r12
  int v374; // r1
  int v375; // r2
  int v376; // r4
  int v377; // r3
  int v378; // r8
  int v379; // r10
  int v380; // r7
  int v381; // lr
  int v382; // r1
  int v383; // r12
  int v384; // r1
  int v385; // r1
  int v386; // r0
  int v387; // r2
  int v388; // r5
  int v389; // r3
  int v390; // r8
  int v391; // r4
  int v392; // r7
  int v393; // r11
  int v394; // r3
  int v395; // r9
  int v396; // r6
  int v397; // r1
  int v398; // r10
  int v399; // r0
  int v400; // r5
  int v401; // lr
  int v402; // r10
  int v403; // r3
  int v404; // r8
  int v405; // r4
  int v406; // r3
  int v407; // r11
  int v408; // r9
  int v409; // r2
  int v410; // r6
  int v411; // r7
  int v412; // r10
  int v413; // r1
  int v414; // r5
  int v415; // r1
  int v416; // lr
  int v417; // r3
  int v418; // r12
  int v419; // r9
  int v420; // r1
  int v421; // r12
  int v422; // r0
  int v423; // r4
  int v424; // r2
  int v425; // r11
  int v426; // r3
  int v427; // r10
  int v428; // r8
  int v429; // r6
  int v430; // r5
  int v431; // lr
  int v432; // r11
  int v433; // r12
  int v434; // r0
  int v435; // r9
  int v436; // r1
  int v437; // r2
  int v438; // r4
  int v439; // r3
  int v440; // r8
  int v441; // r10
  int v442; // r7
  int v443; // lr
  int v444; // r1
  int v445; // r1
  int v446; // lr
  int v447; // r5
  int v448; // r0
  int v449; // r3
  int v450; // r4
  int v451; // r8
  int v452; // r4
  int v453; // r10
  int v454; // r11
  int v455; // r3
  int v456; // r9
  int v457; // r7
  int v458; // r12
  int v459; // r6
  int v460; // r1
  int v461; // r5
  int v462; // lr
  int v463; // r0
  int v464; // r12
  int v465; // r12
  int v466; // r9
  int v467; // r2
  int v468; // r4
  int v469; // r3
  int v470; // r8
  int v471; // r10
  int v472; // r11
  int v473; // r2
  int v474; // r7
  int v475; // r6
  int v476; // r1
  int v477; // lr
  int v478; // r1
  int v479; // r3
  int v480; // r0
  int v481; // r10
  int v482; // r0
  int v483; // r1
  int v484; // r0
  int v485; // r9
  int v486; // r0
  int v487; // r0
  int v488; // r4
  int v489; // r6
  int v490; // r5
  int v491; // r11
  int v492; // r8
  int v493; // r7
  int v494; // r1
  int v495; // r12
  int v496; // r2
  int v497; // lr
  int v498; // r0
  int v499; // r12
  int v500; // r3
  int v501; // r2
  _WORD *v502; // r3
  unsigned int v503; // r2
  _DWORD *i; // lr
  unsigned int v505; // t1
  unsigned int result; // r0
  int v507; // [sp+0h] [bp-84h]
  int v508; // [sp+4h] [bp-80h]
  int v509; // [sp+4h] [bp-80h]
  int v510; // [sp+4h] [bp-80h]
  int v511; // [sp+4h] [bp-80h]
  int v512; // [sp+4h] [bp-80h]
  int v513; // [sp+4h] [bp-80h]
  int v514; // [sp+4h] [bp-80h]
  int v515; // [sp+4h] [bp-80h]
  int v516; // [sp+4h] [bp-80h]
  int v517; // [sp+4h] [bp-80h]
  int v518; // [sp+4h] [bp-80h]
  int v519; // [sp+4h] [bp-80h]
  int v520; // [sp+4h] [bp-80h]
  int v521; // [sp+4h] [bp-80h]
  int v522; // [sp+4h] [bp-80h]
  int v523; // [sp+4h] [bp-80h]
  int v524; // [sp+4h] [bp-80h]
  int v525; // [sp+4h] [bp-80h]
  int v526; // [sp+4h] [bp-80h]
  int v527; // [sp+4h] [bp-80h]
  int v528; // [sp+4h] [bp-80h]
  int v529; // [sp+4h] [bp-80h]
  int v530; // [sp+4h] [bp-80h]
  int v531; // [sp+4h] [bp-80h]
  int v532; // [sp+4h] [bp-80h]
  int v533; // [sp+4h] [bp-80h]
  int v534; // [sp+4h] [bp-80h]
  int v535; // [sp+4h] [bp-80h]
  int v536; // [sp+4h] [bp-80h]
  int v537; // [sp+4h] [bp-80h]
  int v538; // [sp+4h] [bp-80h]
  int v539; // [sp+8h] [bp-7Ch]
  int v540; // [sp+8h] [bp-7Ch]
  int v541; // [sp+8h] [bp-7Ch]
  int v542; // [sp+8h] [bp-7Ch]
  int v543; // [sp+8h] [bp-7Ch]
  int v544; // [sp+8h] [bp-7Ch]
  int v545; // [sp+8h] [bp-7Ch]
  int v546; // [sp+8h] [bp-7Ch]
  int v547; // [sp+8h] [bp-7Ch]
  int v548; // [sp+8h] [bp-7Ch]
  int v549; // [sp+8h] [bp-7Ch]
  int v550; // [sp+8h] [bp-7Ch]
  int v551; // [sp+8h] [bp-7Ch]
  int v552; // [sp+8h] [bp-7Ch]
  int v553; // [sp+8h] [bp-7Ch]
  int v554; // [sp+8h] [bp-7Ch]
  int v555; // [sp+8h] [bp-7Ch]
  int v556; // [sp+8h] [bp-7Ch]
  int v557; // [sp+8h] [bp-7Ch]
  int v558; // [sp+8h] [bp-7Ch]
  int v559; // [sp+8h] [bp-7Ch]
  int v560; // [sp+8h] [bp-7Ch]
  int v561; // [sp+8h] [bp-7Ch]
  int v562; // [sp+8h] [bp-7Ch]
  int v563; // [sp+8h] [bp-7Ch]
  int v564; // [sp+8h] [bp-7Ch]
  int v565; // [sp+8h] [bp-7Ch]
  int v566; // [sp+8h] [bp-7Ch]
  int v567; // [sp+8h] [bp-7Ch]
  int v568; // [sp+8h] [bp-7Ch]
  int v569; // [sp+8h] [bp-7Ch]
  int v570; // [sp+Ch] [bp-78h]
  int v571; // [sp+Ch] [bp-78h]
  int v572; // [sp+Ch] [bp-78h]
  int v573; // [sp+Ch] [bp-78h]
  int v574; // [sp+Ch] [bp-78h]
  int v575; // [sp+Ch] [bp-78h]
  int v576; // [sp+Ch] [bp-78h]
  int v577; // [sp+Ch] [bp-78h]
  int v578; // [sp+Ch] [bp-78h]
  int v579; // [sp+Ch] [bp-78h]
  int v580; // [sp+Ch] [bp-78h]
  int v581; // [sp+Ch] [bp-78h]
  int v582; // [sp+Ch] [bp-78h]
  int v583; // [sp+Ch] [bp-78h]
  int v584; // [sp+Ch] [bp-78h]
  int v585; // [sp+Ch] [bp-78h]
  int v586; // [sp+Ch] [bp-78h]
  int v587; // [sp+Ch] [bp-78h]
  int v588; // [sp+Ch] [bp-78h]
  int v589; // [sp+Ch] [bp-78h]
  int v590; // [sp+Ch] [bp-78h]
  int v591; // [sp+Ch] [bp-78h]
  int v592; // [sp+Ch] [bp-78h]
  int v593; // [sp+Ch] [bp-78h]
  int v594; // [sp+Ch] [bp-78h]
  int v595; // [sp+Ch] [bp-78h]
  int v596; // [sp+Ch] [bp-78h]
  int v597; // [sp+Ch] [bp-78h]
  int v598; // [sp+Ch] [bp-78h]
  int v599; // [sp+Ch] [bp-78h]
  int v600; // [sp+10h] [bp-74h]
  int v601; // [sp+10h] [bp-74h]
  int v602; // [sp+10h] [bp-74h]
  int v603; // [sp+10h] [bp-74h]
  int v604; // [sp+10h] [bp-74h]
  int v605; // [sp+10h] [bp-74h]
  int v606; // [sp+10h] [bp-74h]
  int v607; // [sp+10h] [bp-74h]
  int v608; // [sp+10h] [bp-74h]
  int v609; // [sp+10h] [bp-74h]
  int v610; // [sp+10h] [bp-74h]
  int v611; // [sp+10h] [bp-74h]
  int v612; // [sp+10h] [bp-74h]
  int v613; // [sp+10h] [bp-74h]
  int v614; // [sp+10h] [bp-74h]
  int v615; // [sp+10h] [bp-74h]
  int v616; // [sp+10h] [bp-74h]
  int v617; // [sp+10h] [bp-74h]
  int v618; // [sp+10h] [bp-74h]
  int v619; // [sp+10h] [bp-74h]
  int v620; // [sp+10h] [bp-74h]
  int v621; // [sp+10h] [bp-74h]
  int v622; // [sp+10h] [bp-74h]
  int v623; // [sp+10h] [bp-74h]
  int v624; // [sp+10h] [bp-74h]
  int v625; // [sp+10h] [bp-74h]
  int v626; // [sp+10h] [bp-74h]
  int v627; // [sp+10h] [bp-74h]
  int v628; // [sp+10h] [bp-74h]
  int v629; // [sp+14h] [bp-70h]
  int v630; // [sp+14h] [bp-70h]
  int v631; // [sp+14h] [bp-70h]
  int v632; // [sp+14h] [bp-70h]
  int v633; // [sp+14h] [bp-70h]
  int v634; // [sp+14h] [bp-70h]
  int v635; // [sp+14h] [bp-70h]
  int v636; // [sp+14h] [bp-70h]
  int v637; // [sp+14h] [bp-70h]
  int v638; // [sp+14h] [bp-70h]
  int v639; // [sp+14h] [bp-70h]
  int v640; // [sp+14h] [bp-70h]
  int v641; // [sp+14h] [bp-70h]
  int v642; // [sp+14h] [bp-70h]
  int v643; // [sp+14h] [bp-70h]
  int v644; // [sp+14h] [bp-70h]
  int v645; // [sp+14h] [bp-70h]
  int v646; // [sp+14h] [bp-70h]
  int v647; // [sp+14h] [bp-70h]
  int v648; // [sp+14h] [bp-70h]
  int v649; // [sp+14h] [bp-70h]
  int v650; // [sp+14h] [bp-70h]
  int v651; // [sp+14h] [bp-70h]
  int v652; // [sp+14h] [bp-70h]
  int v653; // [sp+14h] [bp-70h]
  int v654; // [sp+14h] [bp-70h]
  int v655; // [sp+14h] [bp-70h]
  int v656; // [sp+14h] [bp-70h]
  int v657; // [sp+14h] [bp-70h]
  int v658; // [sp+14h] [bp-70h]
  int v659; // [sp+14h] [bp-70h]
  int v660; // [sp+18h] [bp-6Ch]
  int v661; // [sp+18h] [bp-6Ch]
  int v662; // [sp+18h] [bp-6Ch]
  int v663; // [sp+18h] [bp-6Ch]
  int v664; // [sp+18h] [bp-6Ch]
  int v665; // [sp+18h] [bp-6Ch]
  int v666; // [sp+18h] [bp-6Ch]
  int v667; // [sp+18h] [bp-6Ch]
  int v668; // [sp+18h] [bp-6Ch]
  int v669; // [sp+18h] [bp-6Ch]
  int v670; // [sp+18h] [bp-6Ch]
  int v671; // [sp+18h] [bp-6Ch]
  int v672; // [sp+18h] [bp-6Ch]
  int v673; // [sp+18h] [bp-6Ch]
  int v674; // [sp+18h] [bp-6Ch]
  int v675; // [sp+18h] [bp-6Ch]
  int v676; // [sp+18h] [bp-6Ch]
  int v677; // [sp+18h] [bp-6Ch]
  int v678; // [sp+18h] [bp-6Ch]
  int v679; // [sp+18h] [bp-6Ch]
  int v680; // [sp+18h] [bp-6Ch]
  int v681; // [sp+18h] [bp-6Ch]
  int v682; // [sp+18h] [bp-6Ch]
  int v683; // [sp+18h] [bp-6Ch]
  int v684; // [sp+18h] [bp-6Ch]
  int v685; // [sp+18h] [bp-6Ch]
  int v686; // [sp+18h] [bp-6Ch]
  int v687; // [sp+18h] [bp-6Ch]
  int v688; // [sp+1Ch] [bp-68h]
  int v689; // [sp+1Ch] [bp-68h]
  int v690; // [sp+1Ch] [bp-68h]
  int v691; // [sp+1Ch] [bp-68h]
  int v692; // [sp+1Ch] [bp-68h]
  int v693; // [sp+1Ch] [bp-68h]
  int v694; // [sp+1Ch] [bp-68h]
  int v695; // [sp+1Ch] [bp-68h]
  int v696; // [sp+1Ch] [bp-68h]
  int v697; // [sp+1Ch] [bp-68h]
  int v698; // [sp+1Ch] [bp-68h]
  int v699; // [sp+1Ch] [bp-68h]
  int v700; // [sp+1Ch] [bp-68h]
  int v701; // [sp+1Ch] [bp-68h]
  int v702; // [sp+1Ch] [bp-68h]
  int v703; // [sp+1Ch] [bp-68h]
  int v704; // [sp+1Ch] [bp-68h]
  int v705; // [sp+1Ch] [bp-68h]
  int v706; // [sp+1Ch] [bp-68h]
  int v707; // [sp+1Ch] [bp-68h]
  int v708; // [sp+1Ch] [bp-68h]
  int v709; // [sp+1Ch] [bp-68h]
  int v710; // [sp+1Ch] [bp-68h]
  int v711; // [sp+1Ch] [bp-68h]
  int v712; // [sp+1Ch] [bp-68h]
  int v713; // [sp+1Ch] [bp-68h]
  int v714; // [sp+1Ch] [bp-68h]
  int v715; // [sp+1Ch] [bp-68h]
  int v716; // [sp+1Ch] [bp-68h]
  int v717; // [sp+20h] [bp-64h]
  int v718; // [sp+20h] [bp-64h]
  int v719; // [sp+20h] [bp-64h]
  int v720; // [sp+20h] [bp-64h]
  int v721; // [sp+20h] [bp-64h]
  int v722; // [sp+20h] [bp-64h]
  int v723; // [sp+20h] [bp-64h]
  int v724; // [sp+20h] [bp-64h]
  int v725; // [sp+20h] [bp-64h]
  int v726; // [sp+20h] [bp-64h]
  int v727; // [sp+20h] [bp-64h]
  int v728; // [sp+20h] [bp-64h]
  int v729; // [sp+20h] [bp-64h]
  int v730; // [sp+20h] [bp-64h]
  int v731; // [sp+20h] [bp-64h]
  int v732; // [sp+20h] [bp-64h]
  int v733; // [sp+20h] [bp-64h]
  int v734; // [sp+20h] [bp-64h]
  int v735; // [sp+20h] [bp-64h]
  int v736; // [sp+20h] [bp-64h]
  int v737; // [sp+20h] [bp-64h]
  int v738; // [sp+20h] [bp-64h]
  int v739; // [sp+20h] [bp-64h]
  int v740; // [sp+20h] [bp-64h]
  int v741; // [sp+20h] [bp-64h]
  int v742; // [sp+20h] [bp-64h]
  int v743; // [sp+20h] [bp-64h]
  int v744; // [sp+20h] [bp-64h]
  int v745; // [sp+20h] [bp-64h]
  int v746; // [sp+24h] [bp-60h]
  int v747; // [sp+24h] [bp-60h]
  int v748; // [sp+24h] [bp-60h]
  int v749; // [sp+24h] [bp-60h]
  int v750; // [sp+24h] [bp-60h]
  int v751; // [sp+24h] [bp-60h]
  int v752; // [sp+24h] [bp-60h]
  int v753; // [sp+24h] [bp-60h]
  int v754; // [sp+24h] [bp-60h]
  int v755; // [sp+24h] [bp-60h]
  int v756; // [sp+24h] [bp-60h]
  int v757; // [sp+24h] [bp-60h]
  int v758; // [sp+24h] [bp-60h]
  int v759; // [sp+24h] [bp-60h]
  int v760; // [sp+24h] [bp-60h]
  int v761; // [sp+24h] [bp-60h]
  int v762; // [sp+24h] [bp-60h]
  int v763; // [sp+24h] [bp-60h]
  int v764; // [sp+24h] [bp-60h]
  int v765; // [sp+24h] [bp-60h]
  int v766; // [sp+24h] [bp-60h]
  int v767; // [sp+24h] [bp-60h]
  int v768; // [sp+24h] [bp-60h]
  int v769; // [sp+24h] [bp-60h]
  int v770; // [sp+24h] [bp-60h]
  int v771; // [sp+24h] [bp-60h]
  int v772; // [sp+24h] [bp-60h]
  int v773; // [sp+24h] [bp-60h]
  int v774; // [sp+28h] [bp-5Ch]
  int v775; // [sp+28h] [bp-5Ch]
  int v776; // [sp+28h] [bp-5Ch]
  int v777; // [sp+28h] [bp-5Ch]
  int v778; // [sp+28h] [bp-5Ch]
  int v779; // [sp+28h] [bp-5Ch]
  int v780; // [sp+28h] [bp-5Ch]
  int v781; // [sp+28h] [bp-5Ch]
  int v782; // [sp+28h] [bp-5Ch]
  int v783; // [sp+28h] [bp-5Ch]
  int v784; // [sp+28h] [bp-5Ch]
  int v785; // [sp+28h] [bp-5Ch]
  int v786; // [sp+28h] [bp-5Ch]
  int v787; // [sp+28h] [bp-5Ch]
  int v788; // [sp+28h] [bp-5Ch]
  int v789; // [sp+28h] [bp-5Ch]
  int v790; // [sp+28h] [bp-5Ch]
  int v791; // [sp+28h] [bp-5Ch]
  int v792; // [sp+28h] [bp-5Ch]
  int v793; // [sp+28h] [bp-5Ch]
  int v794; // [sp+28h] [bp-5Ch]
  int v795; // [sp+28h] [bp-5Ch]
  int v796; // [sp+28h] [bp-5Ch]
  int v797; // [sp+28h] [bp-5Ch]
  int v798; // [sp+28h] [bp-5Ch]
  int v799; // [sp+28h] [bp-5Ch]
  int v800; // [sp+28h] [bp-5Ch]
  int v801; // [sp+28h] [bp-5Ch]
  int v802; // [sp+28h] [bp-5Ch]
  int v803; // [sp+2Ch] [bp-58h]
  int v804; // [sp+2Ch] [bp-58h]
  int v805; // [sp+2Ch] [bp-58h]
  int v806; // [sp+2Ch] [bp-58h]
  int v807; // [sp+2Ch] [bp-58h]
  int v808; // [sp+2Ch] [bp-58h]
  int v809; // [sp+2Ch] [bp-58h]
  int v810; // [sp+2Ch] [bp-58h]
  int v811; // [sp+2Ch] [bp-58h]
  int v812; // [sp+2Ch] [bp-58h]
  int v813; // [sp+2Ch] [bp-58h]
  int v814; // [sp+2Ch] [bp-58h]
  int v815; // [sp+2Ch] [bp-58h]
  int v816; // [sp+2Ch] [bp-58h]
  int v817; // [sp+2Ch] [bp-58h]
  int v818; // [sp+2Ch] [bp-58h]
  int v819; // [sp+2Ch] [bp-58h]
  int v820; // [sp+2Ch] [bp-58h]
  int v821; // [sp+2Ch] [bp-58h]
  int v822; // [sp+2Ch] [bp-58h]
  int v823; // [sp+2Ch] [bp-58h]
  int v824; // [sp+2Ch] [bp-58h]
  int v825; // [sp+2Ch] [bp-58h]
  int v826; // [sp+2Ch] [bp-58h]
  int v827; // [sp+2Ch] [bp-58h]
  int v828; // [sp+30h] [bp-54h]
  int v829; // [sp+30h] [bp-54h]
  int v830; // [sp+30h] [bp-54h]
  int v831; // [sp+30h] [bp-54h]
  int v832; // [sp+30h] [bp-54h]
  int v833; // [sp+30h] [bp-54h]
  int v834; // [sp+30h] [bp-54h]
  int v835; // [sp+30h] [bp-54h]
  int v836; // [sp+30h] [bp-54h]
  int v837; // [sp+30h] [bp-54h]
  int v838; // [sp+30h] [bp-54h]
  int v839; // [sp+30h] [bp-54h]
  int v840; // [sp+30h] [bp-54h]
  int v841; // [sp+30h] [bp-54h]
  int v842; // [sp+30h] [bp-54h]
  int v843; // [sp+30h] [bp-54h]
  int v844; // [sp+30h] [bp-54h]
  int v845; // [sp+30h] [bp-54h]
  int v846; // [sp+30h] [bp-54h]
  int v847; // [sp+30h] [bp-54h]
  int v848; // [sp+30h] [bp-54h]
  int v849; // [sp+30h] [bp-54h]
  int v850; // [sp+30h] [bp-54h]
  int v851; // [sp+30h] [bp-54h]
  int v852; // [sp+30h] [bp-54h]
  int v853; // [sp+30h] [bp-54h]
  int v854; // [sp+30h] [bp-54h]
  int v855; // [sp+30h] [bp-54h]
  int v856; // [sp+34h] [bp-50h]
  int v857; // [sp+34h] [bp-50h]
  int v858; // [sp+34h] [bp-50h]
  int v859; // [sp+34h] [bp-50h]
  int v860; // [sp+34h] [bp-50h]
  int v861; // [sp+34h] [bp-50h]
  int v862; // [sp+34h] [bp-50h]
  int v863; // [sp+34h] [bp-50h]
  int v864; // [sp+34h] [bp-50h]
  int v865; // [sp+34h] [bp-50h]
  int v866; // [sp+34h] [bp-50h]
  int v867; // [sp+34h] [bp-50h]
  int v868; // [sp+34h] [bp-50h]
  int v869; // [sp+34h] [bp-50h]
  int v870; // [sp+34h] [bp-50h]
  int v871; // [sp+34h] [bp-50h]
  int v872; // [sp+34h] [bp-50h]
  int v873; // [sp+34h] [bp-50h]
  int v874; // [sp+34h] [bp-50h]
  int v875; // [sp+34h] [bp-50h]
  int v876; // [sp+34h] [bp-50h]
  int v877; // [sp+34h] [bp-50h]
  int v878; // [sp+34h] [bp-50h]
  int v879; // [sp+34h] [bp-50h]
  int v880; // [sp+34h] [bp-50h]
  int v881; // [sp+34h] [bp-50h]
  int v882; // [sp+34h] [bp-50h]
  int v883; // [sp+34h] [bp-50h]
  int v884; // [sp+38h] [bp-4Ch]
  int v885; // [sp+38h] [bp-4Ch]
  int v886; // [sp+38h] [bp-4Ch]
  int v887; // [sp+38h] [bp-4Ch]
  int v888; // [sp+38h] [bp-4Ch]
  int v889; // [sp+38h] [bp-4Ch]
  int v890; // [sp+38h] [bp-4Ch]
  int v891; // [sp+38h] [bp-4Ch]
  int v892; // [sp+38h] [bp-4Ch]
  int v893; // [sp+38h] [bp-4Ch]
  int v894; // [sp+38h] [bp-4Ch]
  int v895; // [sp+38h] [bp-4Ch]
  int v896; // [sp+38h] [bp-4Ch]
  int v897; // [sp+38h] [bp-4Ch]
  int v898; // [sp+38h] [bp-4Ch]
  int v899; // [sp+38h] [bp-4Ch]
  int v900; // [sp+38h] [bp-4Ch]
  int v901; // [sp+38h] [bp-4Ch]
  int v902; // [sp+38h] [bp-4Ch]
  int v903; // [sp+38h] [bp-4Ch]
  int v904; // [sp+38h] [bp-4Ch]
  int v905; // [sp+38h] [bp-4Ch]
  int v906; // [sp+38h] [bp-4Ch]
  int v907; // [sp+38h] [bp-4Ch]
  int v908; // [sp+38h] [bp-4Ch]
  int v909; // [sp+38h] [bp-4Ch]
  int v910; // [sp+3Ch] [bp-48h]
  int v911; // [sp+3Ch] [bp-48h]
  int v912; // [sp+3Ch] [bp-48h]
  int v913; // [sp+3Ch] [bp-48h]
  int v914; // [sp+3Ch] [bp-48h]
  int v915; // [sp+3Ch] [bp-48h]
  int v916; // [sp+3Ch] [bp-48h]
  int v917; // [sp+3Ch] [bp-48h]
  int v918; // [sp+3Ch] [bp-48h]
  int v919; // [sp+3Ch] [bp-48h]
  int v920; // [sp+3Ch] [bp-48h]
  int v921; // [sp+3Ch] [bp-48h]
  int v922; // [sp+3Ch] [bp-48h]
  int v923; // [sp+3Ch] [bp-48h]
  int v924; // [sp+3Ch] [bp-48h]
  int v925; // [sp+3Ch] [bp-48h]
  int v926; // [sp+3Ch] [bp-48h]
  int v927; // [sp+3Ch] [bp-48h]
  int v928; // [sp+3Ch] [bp-48h]
  int v929; // [sp+3Ch] [bp-48h]
  int v930; // [sp+3Ch] [bp-48h]
  int v931; // [sp+3Ch] [bp-48h]
  int v932; // [sp+3Ch] [bp-48h]
  int v933; // [sp+3Ch] [bp-48h]
  int v934; // [sp+3Ch] [bp-48h]
  int v935; // [sp+3Ch] [bp-48h]
  int v936; // [sp+3Ch] [bp-48h]
  int v937; // [sp+40h] [bp-44h]
  int v938; // [sp+40h] [bp-44h]
  int v939; // [sp+40h] [bp-44h]
  int v940; // [sp+40h] [bp-44h]
  int v941; // [sp+40h] [bp-44h]
  int v942; // [sp+40h] [bp-44h]
  int v943; // [sp+40h] [bp-44h]
  int v944; // [sp+40h] [bp-44h]
  int v945; // [sp+40h] [bp-44h]
  int v946; // [sp+40h] [bp-44h]
  int v947; // [sp+40h] [bp-44h]
  int v948; // [sp+40h] [bp-44h]
  int v949; // [sp+40h] [bp-44h]
  int v950; // [sp+40h] [bp-44h]
  int v951; // [sp+40h] [bp-44h]
  int v952; // [sp+40h] [bp-44h]
  int v953; // [sp+40h] [bp-44h]
  int v954; // [sp+40h] [bp-44h]
  int v955; // [sp+40h] [bp-44h]
  int v956; // [sp+40h] [bp-44h]
  int v957; // [sp+40h] [bp-44h]
  int v958; // [sp+40h] [bp-44h]
  int v959; // [sp+40h] [bp-44h]
  int v960; // [sp+40h] [bp-44h]
  int v961; // [sp+40h] [bp-44h]
  int v962; // [sp+40h] [bp-44h]
  int v963; // [sp+40h] [bp-44h]
  int v964; // [sp+40h] [bp-44h]
  int v965; // [sp+44h] [bp-40h]
  int v966; // [sp+44h] [bp-40h]
  int v967; // [sp+44h] [bp-40h]
  int v968; // [sp+44h] [bp-40h]
  int v969; // [sp+44h] [bp-40h]
  int v970; // [sp+44h] [bp-40h]
  int v971; // [sp+44h] [bp-40h]
  int v972; // [sp+44h] [bp-40h]
  int v973; // [sp+44h] [bp-40h]
  int v974; // [sp+44h] [bp-40h]
  int v975; // [sp+44h] [bp-40h]
  int v976; // [sp+44h] [bp-40h]
  int v977; // [sp+44h] [bp-40h]
  int v978; // [sp+44h] [bp-40h]
  int v979; // [sp+44h] [bp-40h]
  int v980; // [sp+44h] [bp-40h]
  int v981; // [sp+44h] [bp-40h]
  int v982; // [sp+44h] [bp-40h]
  int v983; // [sp+44h] [bp-40h]
  int v984; // [sp+44h] [bp-40h]
  int v985; // [sp+44h] [bp-40h]
  int v986; // [sp+44h] [bp-40h]
  int v987; // [sp+44h] [bp-40h]
  int v988; // [sp+44h] [bp-40h]
  int v989; // [sp+44h] [bp-40h]
  int v990; // [sp+44h] [bp-40h]
  int v991; // [sp+44h] [bp-40h]
  int v992; // [sp+44h] [bp-40h]
  int v993; // [sp+48h] [bp-3Ch]
  int v994; // [sp+48h] [bp-3Ch]
  int v995; // [sp+48h] [bp-3Ch]
  int v996; // [sp+48h] [bp-3Ch]
  int v997; // [sp+48h] [bp-3Ch]
  int v998; // [sp+48h] [bp-3Ch]
  int v999; // [sp+48h] [bp-3Ch]
  int v1000; // [sp+48h] [bp-3Ch]
  int v1001; // [sp+48h] [bp-3Ch]
  int v1002; // [sp+48h] [bp-3Ch]
  int v1003; // [sp+48h] [bp-3Ch]
  int v1004; // [sp+48h] [bp-3Ch]
  int v1005; // [sp+48h] [bp-3Ch]
  int v1006; // [sp+48h] [bp-3Ch]
  int v1007; // [sp+48h] [bp-3Ch]
  int v1008; // [sp+48h] [bp-3Ch]
  int v1009; // [sp+48h] [bp-3Ch]
  int v1010; // [sp+48h] [bp-3Ch]
  int v1011; // [sp+48h] [bp-3Ch]
  int v1012; // [sp+48h] [bp-3Ch]
  int v1013; // [sp+48h] [bp-3Ch]
  int v1014; // [sp+48h] [bp-3Ch]
  int v1015; // [sp+48h] [bp-3Ch]
  int v1016; // [sp+48h] [bp-3Ch]
  int v1017; // [sp+48h] [bp-3Ch]
  int v1018; // [sp+48h] [bp-3Ch]
  int v1019; // [sp+48h] [bp-3Ch]
  int v1020; // [sp+4Ch] [bp-38h]
  int v1021; // [sp+4Ch] [bp-38h]
  int v1022; // [sp+4Ch] [bp-38h]
  int v1023; // [sp+4Ch] [bp-38h]
  int v1024; // [sp+4Ch] [bp-38h]
  int v1025; // [sp+4Ch] [bp-38h]
  int v1026; // [sp+4Ch] [bp-38h]
  int v1027; // [sp+4Ch] [bp-38h]
  int v1028; // [sp+4Ch] [bp-38h]
  int v1029; // [sp+4Ch] [bp-38h]
  int v1030; // [sp+4Ch] [bp-38h]
  int v1031; // [sp+4Ch] [bp-38h]
  int v1032; // [sp+4Ch] [bp-38h]
  int v1033; // [sp+4Ch] [bp-38h]
  int v1034; // [sp+4Ch] [bp-38h]
  int v1035; // [sp+4Ch] [bp-38h]
  int v1036; // [sp+4Ch] [bp-38h]
  int v1037; // [sp+4Ch] [bp-38h]
  int v1038; // [sp+4Ch] [bp-38h]
  int v1039; // [sp+4Ch] [bp-38h]
  int v1040; // [sp+4Ch] [bp-38h]
  int v1041; // [sp+4Ch] [bp-38h]
  int v1042; // [sp+4Ch] [bp-38h]
  int v1043; // [sp+4Ch] [bp-38h]
  int v1044; // [sp+50h] [bp-34h]
  int v1045; // [sp+50h] [bp-34h]
  int v1046; // [sp+50h] [bp-34h]
  int v1047; // [sp+50h] [bp-34h]
  int v1048; // [sp+50h] [bp-34h]
  int v1049; // [sp+50h] [bp-34h]
  int v1050; // [sp+50h] [bp-34h]
  int v1051; // [sp+50h] [bp-34h]
  int v1052; // [sp+50h] [bp-34h]
  int v1053; // [sp+50h] [bp-34h]
  int v1054; // [sp+50h] [bp-34h]
  int v1055; // [sp+50h] [bp-34h]
  int v1056; // [sp+50h] [bp-34h]
  int v1057; // [sp+50h] [bp-34h]
  int v1058; // [sp+50h] [bp-34h]
  int v1059; // [sp+50h] [bp-34h]
  int v1060; // [sp+50h] [bp-34h]
  int v1061; // [sp+50h] [bp-34h]
  int v1062; // [sp+50h] [bp-34h]
  int v1063; // [sp+50h] [bp-34h]
  int v1064; // [sp+50h] [bp-34h]
  int v1065; // [sp+50h] [bp-34h]
  int v1066; // [sp+50h] [bp-34h]
  int v1067; // [sp+50h] [bp-34h]
  int v1068; // [sp+54h] [bp-30h]
  int v1069; // [sp+54h] [bp-30h]
  int v1070; // [sp+54h] [bp-30h]
  int v1071; // [sp+54h] [bp-30h]
  int v1072; // [sp+54h] [bp-30h]
  int v1073; // [sp+54h] [bp-30h]
  int v1074; // [sp+54h] [bp-30h]
  int v1075; // [sp+54h] [bp-30h]
  int v1076; // [sp+54h] [bp-30h]
  int v1077; // [sp+54h] [bp-30h]
  int v1078; // [sp+54h] [bp-30h]
  int v1079; // [sp+54h] [bp-30h]
  int v1080; // [sp+54h] [bp-30h]
  int v1081; // [sp+54h] [bp-30h]
  int v1082; // [sp+54h] [bp-30h]
  int v1083; // [sp+54h] [bp-30h]
  int v1084; // [sp+54h] [bp-30h]
  int v1085; // [sp+54h] [bp-30h]
  int v1086; // [sp+54h] [bp-30h]
  int v1087; // [sp+54h] [bp-30h]
  int v1088; // [sp+54h] [bp-30h]
  int v1089; // [sp+54h] [bp-30h]
  int v1090; // [sp+54h] [bp-30h]
  int v1091; // [sp+54h] [bp-30h]
  int v1092; // [sp+58h] [bp-2Ch]
  int v1093; // [sp+58h] [bp-2Ch]
  int v1094; // [sp+58h] [bp-2Ch]
  int v1095; // [sp+58h] [bp-2Ch]
  int v1096; // [sp+58h] [bp-2Ch]
  int v1097; // [sp+58h] [bp-2Ch]
  int v1098; // [sp+58h] [bp-2Ch]
  int v1099; // [sp+58h] [bp-2Ch]
  int v1100; // [sp+58h] [bp-2Ch]
  int v1101; // [sp+58h] [bp-2Ch]
  int v1102; // [sp+58h] [bp-2Ch]
  int v1103; // [sp+58h] [bp-2Ch]
  int v1104; // [sp+58h] [bp-2Ch]
  int v1105; // [sp+58h] [bp-2Ch]
  int v1106; // [sp+58h] [bp-2Ch]
  int v1107; // [sp+58h] [bp-2Ch]
  int v1108; // [sp+58h] [bp-2Ch]
  int v1109; // [sp+58h] [bp-2Ch]
  int v1110; // [sp+58h] [bp-2Ch]
  int v1111; // [sp+5Ch] [bp-28h]
  int v1112; // [sp+5Ch] [bp-28h]
  int v1113; // [sp+5Ch] [bp-28h]
  int v1114; // [sp+5Ch] [bp-28h]
  int v1115; // [sp+5Ch] [bp-28h]
  int v1116; // [sp+5Ch] [bp-28h]
  int v1117; // [sp+5Ch] [bp-28h]
  int v1118; // [sp+5Ch] [bp-28h]
  int v1119; // [sp+5Ch] [bp-28h]
  int v1120; // [sp+5Ch] [bp-28h]
  int v1121; // [sp+5Ch] [bp-28h]
  int v1122; // [sp+5Ch] [bp-28h]
  int v1123; // [sp+5Ch] [bp-28h]
  int v1124; // [sp+5Ch] [bp-28h]
  int v1125; // [sp+5Ch] [bp-28h]
  int v1126; // [sp+5Ch] [bp-28h]
  int v1127; // [sp+60h] [bp-24h]
  int v1128; // [sp+60h] [bp-24h]
  int v1129; // [sp+60h] [bp-24h]
  int v1130; // [sp+60h] [bp-24h]
  int v1131; // [sp+60h] [bp-24h]
  int v1132; // [sp+60h] [bp-24h]
  int v1133; // [sp+64h] [bp-20h]
  int v1134; // [sp+64h] [bp-20h]
  int v1135; // [sp+68h] [bp-1Ch]
  int v1136; // [sp+68h] [bp-1Ch]
  int v1137; // [sp+68h] [bp-1Ch]
  int v1138; // [sp+6Ch] [bp-18h]
  int v1139; // [sp+70h] [bp-14h]
  int v1140; // [sp+74h] [bp-10h]

  v6 = a1[8];
  *((_BYTE *)a1 + v6) = (128 >> a3) | a2 & -(128 >> a3);
  memset((char *)a1 + v6 + 1, 0, 31 - v6);
  v507 = 0;
  v746 = a1[20];
  v774 = a1[21];
  v803 = a1[22];
  v1068 = a1[18];
  v828 = a1[23];
  v1135 = a1[19];
  v856 = a1[24];
  v570 = a1[30];
  v600 = a1[38];
  v539 = a1[40];
  v508 = a1[9] ^ *a1;
  v629 = a1[10] ^ a1[1];
  v993 = a1[32];
  v660 = a1[13] ^ a1[4];
  v1020 = a1[31];
  v884 = a1[26];
  v7 = a1[39];
  v688 = a1[14] ^ a1[5];
  v937 = a1[27];
  v8 = a1[25];
  v9 = a1[35];
  v10 = a1[15] ^ a1[6];
  v965 = a1[29];
  v11 = a1[11] ^ a1[2];
  v717 = a1[16] ^ a1[7];
  v12 = a1[33];
  v13 = a1[37];
  v14 = a1[36];
  v15 = a1[17];
  v910 = a1[28];
  v16 = a1[34];
  v17 = a1[12] ^ a1[3];
  v18 = v1135;
  while ( 1 )
  {
    v19 = v15 + v12;
    v20 = v18 + v9;
    v1044 = v508 + v8;
    v885 = v629 + v884;
    v21 = v11 + v937;
    v22 = v20 ^ __ROR4__(v11, 25);
    v938 = v21;
    v911 = v17 + v910;
    v966 = v660 + v965;
    v571 = v688 + v570;
    v1021 = v10 + v1020;
    v994 = v717 + v993;
    v23 = v1068;
    v24 = v746 + v14;
    v1069 = v1068 + v16;
    v1092 = v774 + v13;
    v25 = v803 + v600;
    v26 = v828 + v7;
    v27 = v26 ^ __ROR4__(v10, 25);
    v28 = v856 + v539;
    v540 = v1044 ^ __ROR4__(v15, 25);
    v29 = v19 ^ __ROR4__(v508, 25);
    v30 = v19 + v22;
    v1111 = v29;
    v509 = v885 ^ __ROR4__(v23, 25);
    v31 = v746;
    v747 = v24 ^ __ROR4__(v17, 25);
    v1127 = v1069 ^ __ROR4__(v629, 25);
    v601 = v938 ^ __ROR4__(v18, 25);
    v630 = v911 ^ __ROR4__(v31, 25);
    v32 = v966 ^ __ROR4__(v774, 25);
    v33 = v660;
    v661 = v1021 ^ __ROR4__(v828, 25);
    v34 = v1092 ^ __ROR4__(v33, 25);
    v35 = v571 ^ __ROR4__(v803, 25);
    v36 = v688;
    v689 = v994 ^ __ROR4__(v856, 25);
    v718 = v28 ^ __ROR4__(v717, 25);
    v37 = v25 ^ __ROR4__(v36, 25);
    v38 = v28 + v37;
    v775 = v938 + v540;
    v829 = v1044 + v601;
    v939 = v20 + v1111;
    v804 = v911 + v509;
    v39 = v885 + v630;
    v912 = v24 + v1127;
    v40 = v1069 + v747;
    v857 = v1021 + v32;
    v41 = v966;
    v967 = v26 + v34;
    v42 = v41 + v661;
    v1022 = v1092 + v27;
    v572 = v571 + v689;
    v43 = v994 + v35;
    v44 = v775 ^ __ROR4__(v32, 21);
    v45 = v25 + v718;
    v995 = v857 ^ __ROR4__(v540, 21);
    v541 = (v1044 + v601) ^ __ROR4__(v661, 21);
    v662 = v30 ^ __ROR4__(v27, 21);
    v602 = v42 ^ __ROR4__(v601, 21);
    v46 = v939 ^ __ROR4__(v34, 21);
    v1070 = (v1092 + v27) ^ __ROR4__(v22, 21);
    v1045 = v967 ^ __ROR4__(v1111, 21);
    v47 = v804 ^ __ROR4__(v35, 21);
    v48 = v43 ^ __ROR4__(v509, 21);
    v510 = (v885 + v630) ^ __ROR4__(v689, 21);
    v49 = v718;
    v719 = v804 + v44;
    v631 = v572 ^ __ROR4__(v630, 21);
    v1093 = v775 + v47;
    v50 = v912 ^ __ROR4__(v37, 21);
    v690 = v40 ^ __ROR4__(v49, 21);
    v776 = v43 + v995;
    v51 = v38 ^ __ROR4__(v1127, 21);
    v805 = v857 + v48;
    v52 = v45 ^ __ROR4__(v747, 21);
    v53 = v39 + v541;
    v748 = v829 + v510;
    v573 = v572 + v602;
    v830 = v42 + v631;
    v54 = v912 + v46;
    v55 = (v912 + v46) ^ __ROR4__(v44, 25);
    v858 = v939 + v50;
    v56 = v38 + v1045;
    v886 = v967 + v51;
    v57 = v40 + v662;
    v58 = v30 + v690;
    v913 = v45 + v1070;
    v59 = __ROR4__(v46, 25);
    v60 = v939 + v50;
    v61 = v1022 + v52;
    v940 = v719 ^ v59;
    v62 = v1093;
    v1023 = v60 ^ __ROR4__(v47, 25);
    v63 = v1093 ^ __ROR4__(v50, 25);
    v968 = v776 ^ __ROR4__(v1045, 25);
    v1046 = v56 ^ __ROR4__(v995, 25);
    v996 = v805 ^ __ROR4__(v51, 25);
    v1094 = v886 ^ __ROR4__(v48, 25);
    v1112 = v53 ^ __ROR4__(v662, 25);
    v542 = v57 ^ __ROR4__(v541, 25);
    v64 = v748 ^ __ROR4__(v690, 25);
    v65 = v1070;
    v1071 = v57 + v55;
    v663 = v58 ^ __ROR4__(v510, 25);
    v511 = v573 ^ __ROR4__(v65, 25);
    v603 = v913 ^ __ROR4__(v602, 25);
    v66 = v830 ^ __ROR4__(v52, 25);
    v632 = v61 ^ __ROR4__(v631, 25);
    v67 = v53 + (v719 ^ v59);
    v720 = v719 + v1112;
    v68 = v54 + v542;
    v691 = v748 + v63;
    v69 = v58 + v1023;
    v749 = v62 + v64;
    v859 = v858 + v663;
    v70 = v573 + v968;
    v1128 = v776 + v511;
    v914 = v913 + v1046;
    v71 = v56 + v603;
    v574 = v830 + v996;
    v777 = v805 + v66;
    v72 = v61 + v1094;
    v73 = v886 + v632;
    v806 = v67 ^ __ROR4__(v968, 21);
    v831 = v70 ^ __ROR4__(v940, 21);
    v512 = v720 ^ __ROR4__(v511, 21);
    v887 = v1128 ^ __ROR4__(v1112, 21);
    v941 = (v57 + v55) ^ __ROR4__(v1046, 21);
    v74 = v914 ^ __ROR4__(v55, 21);
    v604 = v68 ^ __ROR4__(v603, 21);
    v1047 = v71 ^ __ROR4__(v542, 21);
    v75 = v691 ^ __ROR4__(v996, 21);
    v76 = v67 + v75;
    v77 = v574 ^ __ROR4__(v63, 21);
    v78 = v70 + v77;
    v79 = v749 ^ __ROR4__(v66, 21);
    v543 = v777 ^ __ROR4__(v64, 21);
    v80 = v69 ^ __ROR4__(v1094, 21);
    v969 = v72 ^ __ROR4__(v1023, 21);
    v633 = v859 ^ __ROR4__(v632, 21);
    v664 = v73 ^ __ROR4__(v663, 21);
    v692 = v691 + v806;
    v997 = v574 + v831;
    v1113 = v749 + v512;
    v575 = v720 + v79;
    v721 = v777 + v887;
    v750 = v1128 + v543;
    v81 = v69 + v941;
    v778 = v72 + v74;
    v82 = v1071 + v80;
    v83 = (v1071 + v80) ^ __ROR4__(v75, 25);
    v84 = v76 ^ __ROR4__(v80, 25);
    v915 = v914 + v969;
    v1072 = v83;
    v85 = v859 + v604;
    v86 = v68 + v633;
    v87 = v86 ^ __ROR4__(v79, 25);
    v88 = v73 + v1047;
    v89 = v82 + v87;
    v860 = v71 + v664;
    v942 = v692 ^ __ROR4__(v941, 25);
    v1024 = v81 ^ __ROR4__(v806, 25);
    v1095 = v778 ^ __ROR4__(v831, 25);
    v90 = v997 ^ __ROR4__(v74, 25);
    v807 = v78 ^ __ROR4__(v969, 25);
    v605 = v1113 ^ __ROR4__(v604, 25);
    v91 = v915 ^ __ROR4__(v77, 25);
    v832 = v85 ^ __ROR4__(v512, 25);
    v513 = v575 ^ __ROR4__(v633, 25);
    v634 = v721 ^ __ROR4__(v1047, 25);
    v888 = v88 ^ __ROR4__(v887, 25);
    v665 = (v1128 + v543) ^ __ROR4__(v664, 25);
    v92 = v860 ^ __ROR4__(v543, 25);
    v544 = v1113 + v942;
    v693 = v692 + v605;
    v1048 = v85 + v1024;
    v93 = v81 + v832;
    v576 = v575 + v84;
    v94 = v86 + v83;
    v970 = v76 + v513;
    v95 = v721 + v90;
    v722 = v997 + v634;
    v96 = v88 + v1095;
    v779 = v778 + v888;
    v97 = v78 + v665;
    v98 = v750 + v807;
    v99 = (v750 + v807) ^ __ROR4__(v84, 21);
    v100 = v860 + v91;
    v101 = v94 ^ __ROR4__(v91, 21);
    v102 = v915 + v92;
    v103 = v89 ^ __ROR4__(v92, 21);
    v751 = v102;
    v861 = (v1113 + v942) ^ __ROR4__(v90, 21);
    v916 = v95 ^ __ROR4__(v942, 21);
    v104 = v997 + v634;
    v635 = v693 ^ __ROR4__(v634, 21);
    v943 = v104 ^ __ROR4__(v605, 21);
    v998 = v1048 ^ __ROR4__(v1095, 21);
    v1025 = v96 ^ __ROR4__(v1024, 21);
    v889 = v93 ^ __ROR4__(v888, 21);
    v833 = v779 ^ __ROR4__(v832, 21);
    v105 = v576 ^ __ROR4__(v807, 21);
    v606 = v970 ^ __ROR4__(v665, 21);
    v514 = v97 ^ __ROR4__(v513, 21);
    v106 = v100 ^ __ROR4__(v1072, 21);
    v107 = v751 ^ __ROR4__(v87, 21);
    v577 = v576 + v861;
    v545 = v544 + v105;
    v808 = v98 + v916;
    v1073 = v95 + v99;
    v108 = v970 + v635;
    v694 = v693 + v606;
    v109 = v97 + v943;
    v110 = v722 + v514;
    v111 = v94 + v998;
    v723 = v1048 + v101;
    v971 = v100 + v1025;
    v1049 = v96 + v106;
    v112 = v89 + v889;
    v113 = v93 + v103;
    v752 = v751 + v833;
    v114 = v779 + v107;
    v115 = v110 ^ __ROR4__(v107, 25);
    v780 = v577 ^ __ROR4__(v998, 25);
    v999 = v111 ^ __ROR4__(v861, 25);
    v116 = v545 ^ __ROR4__(v101, 25);
    v117 = v723 ^ __ROR4__(v105, 25);
    v1114 = v808 ^ __ROR4__(v1025, 25);
    v917 = v971 ^ __ROR4__(v916, 25);
    v862 = v1073 ^ __ROR4__(v106, 25);
    v118 = (v96 + v106) ^ __ROR4__(v99, 25);
    v1096 = v108 ^ __ROR4__(v889, 25);
    v890 = v112 ^ __ROR4__(v635, 25);
    v636 = v694 ^ __ROR4__(v103, 25);
    v119 = v113 ^ __ROR4__(v606, 25);
    v120 = v113 + v117;
    v666 = v119;
    v607 = v109 ^ __ROR4__(v833, 25);
    v834 = v752 ^ __ROR4__(v943, 25);
    v121 = v108 + v780;
    v122 = v514;
    v515 = v577 + v1096;
    v123 = v114 ^ __ROR4__(v122, 25);
    v124 = v114 + v118;
    v125 = v120 ^ __ROR4__(v118, 21);
    v944 = v112 + v999;
    v126 = v124 ^ __ROR4__(v117, 21);
    v1026 = v111 + v890;
    v1129 = v694 + v116;
    v546 = v545 + v636;
    v724 = v723 + v666;
    v578 = v808 + v607;
    v127 = v109 + v1114;
    v753 = v752 + v917;
    v128 = v971;
    v972 = v121 ^ __ROR4__(v1114, 21);
    v129 = v1049;
    v809 = v128 + v834;
    v130 = v110 + v862;
    v1050 = v127 ^ __ROR4__(v780, 21);
    v695 = v1073 + v115;
    v131 = v129 + v123;
    v608 = v515 ^ __ROR4__(v607, 21);
    v1074 = v578 ^ __ROR4__(v1096, 21);
    v918 = (v112 + v999) ^ __ROR4__(v917, 21);
    v132 = v834;
    v1097 = v753 ^ __ROR4__(v999, 21);
    v835 = v130 ^ __ROR4__(v116, 21);
    v1000 = (v111 + v890) ^ __ROR4__(v132, 21);
    v891 = v809 ^ __ROR4__(v890, 21);
    v133 = v1129 ^ __ROR4__(v862, 21);
    v134 = v121 + v133;
    v781 = v546 ^ __ROR4__(v115, 21);
    v637 = v695 ^ __ROR4__(v636, 21);
    v135 = v724 ^ __ROR4__(v123, 21);
    v136 = v131 ^ __ROR4__(v666, 21);
    v667 = v1129 + v972;
    v863 = v130 + v1050;
    v1130 = v546 + v608;
    v1115 = v127 + v835;
    v137 = v515 + v781;
    v516 = v695 + v1074;
    v547 = v578 + v637;
    v138 = v944 + v125;
    v139 = v131 + v891;
    v140 = (v944 + v125) ^ __ROR4__(v133, 25);
    v141 = v120 + v918;
    v142 = v809 + v136;
    v810 = v134 ^ __ROR4__(v125, 25);
    v579 = v124 + v1097;
    v696 = v753 + v126;
    v143 = v724;
    v725 = v142;
    v144 = v143 + v1000;
    v145 = v1026 + v135;
    v754 = v667 ^ __ROR4__(v918, 25);
    v945 = v141 ^ __ROR4__(v972, 25);
    v919 = v863 ^ __ROR4__(v1097, 25);
    v1027 = v579 ^ __ROR4__(v1050, 25);
    v146 = (v127 + v835) ^ __ROR4__(v126, 25);
    v147 = v696 ^ __ROR4__(v835, 25);
    v836 = v1130 ^ __ROR4__(v1000, 25);
    v148 = v608;
    v609 = v137 ^ __ROR4__(v135, 25);
    v149 = v145 ^ __ROR4__(v781, 25);
    v973 = v144 ^ __ROR4__(v148, 25);
    v150 = v145 + v140;
    v1001 = v149;
    v782 = v516 ^ __ROR4__(v891, 25);
    v892 = v139 ^ __ROR4__(v1074, 25);
    v151 = v547 ^ __ROR4__(v136, 25);
    v152 = v725 ^ __ROR4__(v637, 25);
    v638 = v1130 + v754;
    v668 = v667 + v836;
    v153 = v137 + v810;
    v1051 = v144 + v945;
    v154 = v141 + v973;
    v155 = v134 + v609;
    v156 = v138 + v1001;
    v517 = v516 + v919;
    v157 = v863 + v782;
    v864 = v139 + v1027;
    v1075 = v579 + v892;
    v548 = v547 + v146;
    v158 = v153 ^ __ROR4__(v146, 21);
    v159 = v725 + v147;
    v160 = v150 ^ __ROR4__(v147, 21);
    v697 = v696 + v152;
    v161 = v1115 + v151;
    v162 = v156 ^ __ROR4__(v152, 21);
    v726 = (v1130 + v754) ^ __ROR4__(v919, 21);
    v920 = v517 ^ __ROR4__(v754, 21);
    v755 = v668 ^ __ROR4__(v782, 21);
    v837 = v157 ^ __ROR4__(v836, 21);
    v1028 = v1051 ^ __ROR4__(v1027, 21);
    v946 = v864 ^ __ROR4__(v945, 21);
    v163 = v154 ^ __ROR4__(v892, 21);
    v164 = v154 + v162;
    v893 = v163;
    v783 = v155 ^ __ROR4__(v151, 21);
    v974 = v1075 ^ __ROR4__(v973, 21);
    v610 = (v1115 + v151) ^ __ROR4__(v609, 21);
    v165 = v548 ^ __ROR4__(v810, 21);
    v166 = v159 ^ __ROR4__(v140, 21);
    v167 = v697 ^ __ROR4__(v1001, 21);
    v811 = v153 + v726;
    v639 = v638 + v158;
    v549 = v548 + v920;
    v518 = v517 + v165;
    v168 = v155 + v755;
    v169 = v668 + v783;
    v170 = (v668 + v783) ^ __ROR4__(v162, 25);
    v171 = v161 + v837;
    v669 = v157 + v610;
    v172 = v150 + v1028;
    v1002 = v1051 + v160;
    v580 = v159 + v946;
    v865 = v864 + v166;
    v173 = v156 + v893;
    v698 = v697 + v974;
    v1052 = v1075 + v167;
    v1029 = v811 ^ __ROR4__(v1028, 25);
    v174 = v726;
    v175 = v1002 ^ __ROR4__(v158, 25);
    v727 = v170;
    v1076 = v172 ^ __ROR4__(v174, 25);
    v176 = v164 ^ __ROR4__(v783, 25);
    v177 = v164 + v175;
    v784 = v176;
    v178 = v639 ^ __ROR4__(v160, 25);
    v179 = v169 + v178;
    v1116 = v549 ^ __ROR4__(v946, 25);
    v947 = v580 ^ __ROR4__(v920, 25);
    v921 = v518 ^ __ROR4__(v166, 25);
    v180 = v865 ^ __ROR4__(v165, 25);
    v181 = v168 ^ __ROR4__(v893, 25);
    v894 = v173 ^ __ROR4__(v755, 25);
    v756 = v171 ^ __ROR4__(v974, 25);
    v182 = v610;
    v838 = v698 ^ __ROR4__(v837, 25);
    v183 = v168 + v1029;
    v611 = v811 + v181;
    v184 = v669 ^ __ROR4__(v167, 25);
    v812 = v173 + v1076;
    v185 = v1052 ^ __ROR4__(v182, 25);
    v186 = v172 + v894;
    v640 = v639 + v727;
    v975 = v1002 + v784;
    v187 = v171 + v1116;
    v550 = v549 + v756;
    v699 = v698 + v947;
    v1003 = v580 + v838;
    v519 = v518 + v184;
    v188 = v669 + v921;
    v189 = (v669 + v921) ^ __ROR4__(v178, 21);
    v670 = v183 ^ __ROR4__(v1116, 21);
    v190 = v1052 + v180;
    v191 = v177 ^ __ROR4__(v180, 21);
    v581 = v190;
    v192 = v865;
    v866 = v187 ^ __ROR4__(v1029, 21);
    v193 = v192 + v185;
    v757 = v611 ^ __ROR4__(v756, 21);
    v1030 = v550 ^ __ROR4__(v181, 21);
    v948 = (v173 + v1076) ^ __ROR4__(v947, 21);
    v1077 = v699 ^ __ROR4__(v1076, 21);
    v1053 = v186 ^ __ROR4__(v838, 21);
    v1098 = v1003 ^ __ROR4__(v894, 21);
    v194 = v179 ^ __ROR4__(v921, 21);
    v195 = v183 + v194;
    v839 = v640 ^ __ROR4__(v184, 21);
    v728 = v519 ^ __ROR4__(v727, 21);
    v196 = v581 ^ __ROR4__(v175, 21);
    v197 = v975 ^ __ROR4__(v185, 21);
    v198 = v784;
    v199 = v186 + v197;
    v785 = v179 + v670;
    v200 = v193 ^ __ROR4__(v198, 21);
    v201 = v188 + v866;
    v922 = v187 + v189;
    v1117 = v640 + v757;
    v202 = v611 + v839;
    v203 = (v611 + v839) ^ __ROR4__(v197, 25);
    v520 = v519 + v1030;
    v551 = v550 + v728;
    v204 = v177 + v948;
    v612 = v812 + v191;
    v582 = v581 + v1077;
    v641 = v699 + v196;
    v205 = v975 + v1053;
    v206 = v193 + v1098;
    v700 = v1003 + v200;
    v813 = v785 ^ __ROR4__(v948, 25);
    v207 = v670;
    v671 = v195 ^ __ROR4__(v191, 25);
    v208 = v612 ^ __ROR4__(v194, 25);
    v976 = v204 ^ __ROR4__(v207, 25);
    v949 = v201 ^ __ROR4__(v1077, 25);
    v1078 = v582 ^ __ROR4__(v866, 25);
    v209 = v922 ^ __ROR4__(v196, 25);
    v210 = v641 ^ __ROR4__(v189, 25);
    v867 = v1117 ^ __ROR4__(v1053, 25);
    v211 = v757;
    v758 = v203;
    v212 = v199 ^ __ROR4__(v839, 25);
    v895 = v205 ^ __ROR4__(v211, 25);
    v213 = v199 + v208;
    v1004 = v212;
    v840 = v520 ^ __ROR4__(v1098, 25);
    v1031 = v206 ^ __ROR4__(v1030, 25);
    v214 = v551 ^ __ROR4__(v200, 25);
    v215 = v700 ^ __ROR4__(v728, 25);
    v729 = v1117 + v813;
    v786 = v785 + v867;
    v1054 = v205 + v976;
    v216 = v202 + v671;
    v217 = v204 + v895;
    v218 = v195 + v758;
    v219 = v612 + v1004;
    v521 = v520 + v949;
    v220 = v201 + v840;
    v613 = v206 + v1078;
    v221 = v922 + v214;
    v1099 = v582 + v1031;
    v222 = v551 + v209;
    v223 = v216 ^ __ROR4__(v209, 21);
    v552 = v222;
    v224 = v700 + v210;
    v225 = v213 ^ __ROR4__(v210, 21);
    v583 = v224;
    v642 = v641 + v215;
    v226 = v219 ^ __ROR4__(v215, 21);
    v701 = (v1117 + v813) ^ __ROR4__(v949, 21);
    v923 = v521 ^ __ROR4__(v813, 21);
    v814 = v786 ^ __ROR4__(v840, 21);
    v841 = v220 ^ __ROR4__(v867, 21);
    v868 = v1054 ^ __ROR4__(v1078, 21);
    v977 = v613 ^ __ROR4__(v976, 21);
    v227 = v217 ^ __ROR4__(v1031, 21);
    v228 = v217 + v226;
    v950 = v227;
    v229 = v671;
    v672 = v218 ^ __ROR4__(v214, 21);
    v896 = v1099 ^ __ROR4__(v895, 21);
    v759 = v221 ^ __ROR4__(v758, 21);
    v230 = v552 ^ __ROR4__(v229, 21);
    v231 = v583 ^ __ROR4__(v208, 21);
    v232 = v642 ^ __ROR4__(v1004, 21);
    v1005 = v216 + v701;
    v730 = v729 + v223;
    v553 = v552 + v923;
    v522 = v521 + v230;
    v233 = v218 + v814;
    v234 = v786 + v672;
    v235 = (v786 + v672) ^ __ROR4__(v226, 25);
    v236 = v221 + v841;
    v787 = v220 + v759;
    v237 = v213 + v868;
    v1032 = v1054 + v225;
    v584 = v583 + v977;
    v614 = v613 + v231;
    v238 = v219 + v950;
    v643 = v642 + v896;
    v1055 = v1099 + v232;
    v869 = v1005 ^ __ROR4__(v868, 25);
    v239 = v1032 ^ __ROR4__(v223, 25);
    v1079 = v237 ^ __ROR4__(v701, 25);
    v240 = v730 ^ __ROR4__(v225, 25);
    v241 = v234 + v240;
    v1118 = v553 ^ __ROR4__(v977, 25);
    v978 = v584 ^ __ROR4__(v923, 25);
    v924 = v522 ^ __ROR4__(v231, 25);
    v702 = v235;
    v242 = v614 ^ __ROR4__(v230, 25);
    v243 = v233 ^ __ROR4__(v950, 25);
    v951 = v228 ^ __ROR4__(v672, 25);
    v244 = v228 + v239;
    v815 = v238 ^ __ROR4__(v814, 25);
    v673 = v236 ^ __ROR4__(v896, 25);
    v245 = v759;
    v842 = v643 ^ __ROR4__(v841, 25);
    v246 = v233 + v869;
    v760 = v1005 + v243;
    v247 = v787 ^ __ROR4__(v232, 25);
    v897 = v238 + v1079;
    v248 = v1055 ^ __ROR4__(v245, 25);
    v249 = v237 + v815;
    v731 = v730 + v702;
    v1006 = v1032 + v951;
    v554 = v553 + v673;
    v250 = v236 + v1118;
    v644 = v643 + v978;
    v1033 = v584 + v842;
    v523 = v522 + v247;
    v251 = v787 + v924;
    v252 = (v787 + v924) ^ __ROR4__(v240, 21);
    v253 = v1055 + v242;
    v254 = v244 ^ __ROR4__(v242, 21);
    v585 = v253;
    v255 = v614;
    v615 = v246 ^ __ROR4__(v1118, 21);
    v870 = v250 ^ __ROR4__(v869, 21);
    v256 = v255 + v248;
    v674 = v760 ^ __ROR4__(v673, 21);
    v1056 = v554 ^ __ROR4__(v243, 21);
    v979 = (v238 + v1079) ^ __ROR4__(v978, 21);
    v1080 = v644 ^ __ROR4__(v1079, 21);
    v843 = v249 ^ __ROR4__(v842, 21);
    v1100 = v1033 ^ __ROR4__(v815, 21);
    v257 = v241 ^ __ROR4__(v924, 21);
    v788 = v731 ^ __ROR4__(v247, 21);
    v258 = v246 + v257;
    v703 = v523 ^ __ROR4__(v702, 21);
    v925 = v241 + v615;
    v259 = v585 ^ __ROR4__(v239, 21);
    v260 = v251 + v870;
    v261 = v1006 ^ __ROR4__(v248, 21);
    v262 = v951;
    v952 = v250 + v252;
    v263 = v249 + v261;
    v264 = v256 ^ __ROR4__(v262, 21);
    v1119 = v731 + v674;
    v265 = v760 + v788;
    v266 = (v760 + v788) ^ __ROR4__(v261, 25);
    v524 = v523 + v1056;
    v555 = v554 + v703;
    v267 = v244 + v979;
    v732 = v897 + v254;
    v586 = v585 + v1080;
    v645 = v644 + v259;
    v268 = v1006 + v843;
    v269 = v256 + v1100;
    v761 = v1033 + v264;
    v270 = v615;
    v616 = v258 ^ __ROR4__(v254, 25);
    v898 = v925 ^ __ROR4__(v979, 25);
    v1007 = v267 ^ __ROR4__(v270, 25);
    v271 = v732 ^ __ROR4__(v257, 25);
    v980 = v260 ^ __ROR4__(v1080, 25);
    v1034 = v586 ^ __ROR4__(v870, 25);
    v272 = v952 ^ __ROR4__(v259, 25);
    v273 = v645 ^ __ROR4__(v252, 25);
    v816 = v1119 ^ __ROR4__(v843, 25);
    v274 = v674;
    v675 = v266;
    v275 = v263 ^ __ROR4__(v788, 25);
    v844 = v268 ^ __ROR4__(v274, 25);
    v276 = v263 + v271;
    v871 = v275;
    v789 = v524 ^ __ROR4__(v1100, 25);
    v1057 = v269 ^ __ROR4__(v1056, 25);
    v277 = v555 ^ __ROR4__(v264, 25);
    v278 = v761 ^ __ROR4__(v703, 25);
    v704 = v1119 + v898;
    v926 = v925 + v816;
    v279 = v265 + v616;
    v1081 = v268 + v1007;
    v280 = v267 + v844;
    v281 = v258 + v675;
    v282 = v732 + v871;
    v525 = v524 + v980;
    v283 = v260 + v789;
    v733 = v269 + v1034;
    v284 = v952 + v277;
    v1101 = v586 + v1057;
    v285 = v555 + v272;
    v286 = v279 ^ __ROR4__(v272, 21);
    v556 = v285;
    v287 = v761 + v273;
    v288 = v276 ^ __ROR4__(v273, 21);
    v587 = v287;
    v646 = v645 + v278;
    v289 = v282 ^ __ROR4__(v278, 21);
    v762 = (v1119 + v898) ^ __ROR4__(v980, 21);
    v899 = v525 ^ __ROR4__(v898, 21);
    v790 = v926 ^ __ROR4__(v789, 21);
    v817 = v283 ^ __ROR4__(v816, 21);
    v953 = v1081 ^ __ROR4__(v1034, 21);
    v1008 = v733 ^ __ROR4__(v1007, 21);
    v290 = v280 ^ __ROR4__(v1057, 21);
    v291 = v280 + v289;
    v981 = v290;
    v292 = v616;
    v617 = v281 ^ __ROR4__(v277, 21);
    v845 = v1101 ^ __ROR4__(v844, 21);
    v676 = v284 ^ __ROR4__(v675, 21);
    v293 = v556 ^ __ROR4__(v292, 21);
    v294 = v587 ^ __ROR4__(v271, 21);
    v295 = v646 ^ __ROR4__(v871, 21);
    v872 = v279 + v762;
    v705 = v704 + v286;
    v557 = v556 + v899;
    v526 = v525 + v293;
    v296 = v281 + v790;
    v297 = v926 + v617;
    v298 = (v926 + v617) ^ __ROR4__(v289, 25);
    v299 = v284 + v817;
    v927 = v283 + v676;
    v300 = v276 + v953;
    v1035 = v1081 + v288;
    v588 = v587 + v1008;
    v734 = v733 + v294;
    v301 = v282 + v981;
    v647 = v646 + v845;
    v1058 = v1101 + v295;
    v954 = v872 ^ __ROR4__(v953, 25);
    v1082 = v300 ^ __ROR4__(v762, 25);
    v763 = v298;
    v302 = v705 ^ __ROR4__(v288, 25);
    v303 = v1035 ^ __ROR4__(v286, 25);
    v304 = v297 + v302;
    v305 = v291 ^ __ROR4__(v617, 25);
    v306 = v291 + v303;
    v1120 = v557 ^ __ROR4__(v1008, 25);
    v1009 = v588 ^ __ROR4__(v899, 25);
    v307 = v981;
    v982 = v305;
    v900 = v526 ^ __ROR4__(v294, 25);
    v308 = v734 ^ __ROR4__(v293, 25);
    v1102 = v296 ^ __ROR4__(v307, 25);
    v791 = v301 ^ __ROR4__(v790, 25);
    v618 = v299 ^ __ROR4__(v845, 25);
    v309 = v676;
    v818 = v647 ^ __ROR4__(v817, 25);
    v310 = v296 + v954;
    v677 = v872 + v1102;
    v311 = v927 ^ __ROR4__(v295, 25);
    v846 = v301 + v1082;
    v312 = v1058 ^ __ROR4__(v309, 25);
    v313 = v300 + v791;
    v706 = v705 + v763;
    v873 = v1035 + v982;
    v314 = v299 + v1120;
    v558 = v557 + v618;
    v648 = v647 + v1009;
    v1036 = v588 + v818;
    v527 = v526 + v311;
    v315 = v927 + v900;
    v316 = (v927 + v900) ^ __ROR4__(v302, 21);
    v317 = v1058 + v308;
    v318 = v306 ^ __ROR4__(v308, 21);
    v589 = v317;
    v319 = v734;
    v735 = v310 ^ __ROR4__(v1120, 21);
    v928 = v314 ^ __ROR4__(v954, 21);
    v320 = v319 + v312;
    v619 = v677 ^ __ROR4__(v618, 21);
    v955 = v558 ^ __ROR4__(v1102, 21);
    v1010 = (v301 + v1082) ^ __ROR4__(v1009, 21);
    v1083 = v648 ^ __ROR4__(v1082, 21);
    v1059 = v313 ^ __ROR4__(v818, 21);
    v1103 = v1036 ^ __ROR4__(v791, 21);
    v321 = v304 ^ __ROR4__(v900, 21);
    v322 = v310 + v321;
    v792 = v706 ^ __ROR4__(v311, 21);
    v764 = v527 ^ __ROR4__(v763, 21);
    v901 = v304 + v735;
    v323 = v589 ^ __ROR4__(v303, 21);
    v324 = v315 + v928;
    v325 = v873 ^ __ROR4__(v312, 21);
    v326 = v982;
    v983 = v314 + v316;
    v327 = v313 + v325;
    v328 = v320 ^ __ROR4__(v326, 21);
    v1121 = v706 + v619;
    v329 = v677 + v792;
    v330 = (v677 + v792) ^ __ROR4__(v325, 25);
    v528 = v527 + v955;
    v559 = v558 + v764;
    v331 = v306 + v1010;
    v678 = v846 + v318;
    v590 = v589 + v1083;
    v649 = v648 + v323;
    v332 = v873 + v1059;
    v333 = v320 + v1103;
    v707 = v1036 + v328;
    v334 = v735;
    v736 = v322 ^ __ROR4__(v318, 25);
    v847 = v901 ^ __ROR4__(v1010, 25);
    v1011 = v331 ^ __ROR4__(v334, 25);
    v335 = v678 ^ __ROR4__(v321, 25);
    v874 = v324 ^ __ROR4__(v1083, 25);
    v1084 = v590 ^ __ROR4__(v928, 25);
    v336 = v983 ^ __ROR4__(v323, 25);
    v337 = v649 ^ __ROR4__(v316, 25);
    v819 = v1121 ^ __ROR4__(v1059, 25);
    v338 = v619;
    v620 = v330;
    v339 = v327 ^ __ROR4__(v792, 25);
    v929 = v332 ^ __ROR4__(v338, 25);
    v340 = v327 + v335;
    v1037 = v339;
    v793 = v528 ^ __ROR4__(v1103, 25);
    v956 = v333 ^ __ROR4__(v955, 25);
    v341 = v559 ^ __ROR4__(v328, 25);
    v342 = v707 ^ __ROR4__(v764, 25);
    v765 = v1121 + v847;
    v902 = v901 + v819;
    v343 = v329 + v736;
    v1060 = v332 + v1011;
    v344 = v331 + v929;
    v345 = v322 + v620;
    v346 = v678 + v1037;
    v529 = v528 + v874;
    v347 = v324 + v793;
    v679 = v333 + v1084;
    v348 = v983 + v341;
    v1104 = v590 + v956;
    v349 = v559 + v336;
    v350 = v343 ^ __ROR4__(v336, 21);
    v560 = v349;
    v351 = v707 + v337;
    v352 = v340 ^ __ROR4__(v337, 21);
    v591 = v351;
    v650 = v649 + v342;
    v353 = v346 ^ __ROR4__(v342, 21);
    v708 = (v1121 + v847) ^ __ROR4__(v874, 21);
    v848 = v529 ^ __ROR4__(v847, 21);
    v794 = v902 ^ __ROR4__(v793, 21);
    v820 = v347 ^ __ROR4__(v819, 21);
    v875 = v1060 ^ __ROR4__(v1084, 21);
    v984 = v679 ^ __ROR4__(v1011, 21);
    v354 = v344 ^ __ROR4__(v956, 21);
    v355 = v344 + v353;
    v957 = v354;
    v356 = v736;
    v737 = v345 ^ __ROR4__(v341, 21);
    v930 = v1104 ^ __ROR4__(v929, 21);
    v621 = v348 ^ __ROR4__(v620, 21);
    v357 = v560 ^ __ROR4__(v356, 21);
    v358 = v591 ^ __ROR4__(v335, 21);
    v359 = v650 ^ __ROR4__(v1037, 21);
    v1012 = v343 + v708;
    v766 = v765 + v350;
    v561 = v560 + v848;
    v530 = v529 + v357;
    v360 = v345 + v794;
    v361 = v902 + v737;
    v362 = (v902 + v737) ^ __ROR4__(v353, 25);
    v363 = v348 + v820;
    v903 = v347 + v621;
    v364 = v340 + v875;
    v1038 = v1060 + v352;
    v592 = v591 + v984;
    v680 = v679 + v358;
    v365 = v346 + v957;
    v651 = v650 + v930;
    v1061 = v1104 + v359;
    v876 = v1012 ^ __ROR4__(v875, 25);
    v366 = v708;
    v367 = v1038 ^ __ROR4__(v350, 25);
    v709 = v362;
    v1085 = v364 ^ __ROR4__(v366, 25);
    v368 = v355 ^ __ROR4__(v737, 25);
    v369 = v355 + v367;
    v370 = v766 ^ __ROR4__(v352, 25);
    v371 = v361 + v370;
    v1122 = v561 ^ __ROR4__(v984, 25);
    v985 = v592 ^ __ROR4__(v848, 25);
    v372 = v957;
    v958 = v368;
    v849 = v530 ^ __ROR4__(v358, 25);
    v373 = v680 ^ __ROR4__(v357, 25);
    v795 = v365 ^ __ROR4__(v794, 25);
    v738 = v363 ^ __ROR4__(v930, 25);
    v1105 = v360 ^ __ROR4__(v372, 25);
    v374 = v621;
    v821 = v651 ^ __ROR4__(v820, 25);
    v375 = v360 + v876;
    v622 = v1012 + v1105;
    v376 = v903 ^ __ROR4__(v359, 25);
    v931 = v365 + v1085;
    v377 = v1061 ^ __ROR4__(v374, 25);
    v378 = v364 + v795;
    v767 = v766 + v709;
    v1013 = v1038 + v958;
    v379 = v363 + v1122;
    v562 = v561 + v738;
    v652 = v651 + v985;
    v1039 = v592 + v821;
    v531 = v530 + v376;
    v380 = v903 + v849;
    v381 = (v903 + v849) ^ __ROR4__(v370, 21);
    v382 = v1061 + v373;
    v383 = v369 ^ __ROR4__(v373, 21);
    v593 = v382;
    v384 = v680;
    v681 = v375 ^ __ROR4__(v1122, 21);
    v877 = v379 ^ __ROR4__(v876, 21);
    v385 = v384 + v377;
    v739 = v622 ^ __ROR4__(v738, 21);
    v904 = v562 ^ __ROR4__(v1105, 21);
    v986 = (v365 + v1085) ^ __ROR4__(v985, 21);
    v1086 = v652 ^ __ROR4__(v1085, 21);
    v1062 = v378 ^ __ROR4__(v821, 21);
    v1106 = v1039 ^ __ROR4__(v795, 21);
    v386 = v371 ^ __ROR4__(v849, 21);
    v387 = v375 + v386;
    v796 = v767 ^ __ROR4__(v376, 21);
    v710 = v531 ^ __ROR4__(v709, 21);
    v388 = v593 ^ __ROR4__(v367, 21);
    v389 = v1013 ^ __ROR4__(v377, 21);
    v390 = v378 + v389;
    v850 = v371 + v681;
    v391 = v385 ^ __ROR4__(v958, 21);
    v392 = v380 + v877;
    v959 = v379 + v381;
    v1123 = v767 + v739;
    v393 = v622 + v796;
    v394 = (v622 + v796) ^ __ROR4__(v389, 25);
    v532 = v531 + v904;
    v563 = v562 + v710;
    v395 = v369 + v986;
    v623 = v931 + v383;
    v594 = v593 + v1086;
    v653 = v652 + v388;
    v396 = v1013 + v1062;
    v397 = v385 + v1106;
    v768 = v1039 + v391;
    v932 = v850 ^ __ROR4__(v986, 25);
    v398 = v681;
    v682 = v387 ^ __ROR4__(v383, 25);
    v399 = v623 ^ __ROR4__(v386, 25);
    v1014 = v395 ^ __ROR4__(v398, 25);
    v987 = v392 ^ __ROR4__(v1086, 25);
    v1087 = v594 ^ __ROR4__(v877, 25);
    v400 = v959 ^ __ROR4__(v388, 25);
    v401 = v653 ^ __ROR4__(v381, 25);
    v822 = v1123 ^ __ROR4__(v1062, 25);
    v402 = v739;
    v740 = v394;
    v403 = v390 ^ __ROR4__(v796, 25);
    v878 = v396 ^ __ROR4__(v402, 25);
    v404 = v390 + v399;
    v1040 = v403;
    v797 = v532 ^ __ROR4__(v1106, 25);
    v905 = v397 ^ __ROR4__(v904, 25);
    v405 = v563 ^ __ROR4__(v391, 25);
    v406 = v768 ^ __ROR4__(v710, 25);
    v711 = v1123 + v932;
    v851 = v850 + v822;
    v1063 = v396 + v1014;
    v407 = v393 + v682;
    v408 = v395 + v878;
    v409 = v387 + v740;
    v410 = v623 + v1040;
    v533 = v532 + v987;
    v411 = v392 + v797;
    v624 = v397 + v1087;
    v412 = v959 + v405;
    v1107 = v594 + v905;
    v413 = v563 + v400;
    v414 = v407 ^ __ROR4__(v400, 21);
    v564 = v413;
    v415 = v768 + v401;
    v416 = v404 ^ __ROR4__(v401, 21);
    v595 = v415;
    v654 = v653 + v406;
    v417 = v410 ^ __ROR4__(v406, 21);
    v769 = (v1123 + v932) ^ __ROR4__(v987, 21);
    v933 = v533 ^ __ROR4__(v932, 21);
    v798 = v851 ^ __ROR4__(v797, 21);
    v823 = v411 ^ __ROR4__(v822, 21);
    v960 = v1063 ^ __ROR4__(v1087, 21);
    v988 = v624 ^ __ROR4__(v1014, 21);
    v418 = v408 ^ __ROR4__(v905, 21);
    v419 = v408 + v417;
    v906 = v418;
    v420 = v682;
    v683 = v409 ^ __ROR4__(v405, 21);
    v879 = v1107 ^ __ROR4__(v878, 21);
    v741 = v412 ^ __ROR4__(v740, 21);
    v421 = v564 ^ __ROR4__(v420, 21);
    v422 = v595 ^ __ROR4__(v399, 21);
    v423 = v654 ^ __ROR4__(v1040, 21);
    v1015 = v407 + v769;
    v712 = v711 + v414;
    v565 = v564 + v933;
    v534 = v533 + v421;
    v424 = v409 + v798;
    v425 = v851 + v683;
    v426 = (v851 + v683) ^ __ROR4__(v417, 25);
    v427 = v412 + v823;
    v852 = v411 + v741;
    v428 = v404 + v960;
    v1041 = v1063 + v416;
    v596 = v595 + v988;
    v625 = v624 + v422;
    v429 = v410 + v906;
    v655 = v654 + v879;
    v1064 = v1107 + v423;
    v961 = v1015 ^ __ROR4__(v960, 25);
    v430 = v1041 ^ __ROR4__(v414, 25);
    v1088 = v428 ^ __ROR4__(v769, 25);
    v431 = v712 ^ __ROR4__(v416, 25);
    v432 = v425 + v431;
    v1124 = v565 ^ __ROR4__(v988, 25);
    v989 = v596 ^ __ROR4__(v933, 25);
    v934 = v534 ^ __ROR4__(v422, 25);
    v770 = v426;
    v433 = v625 ^ __ROR4__(v421, 25);
    v434 = v424 ^ __ROR4__(v906, 25);
    v907 = v419 ^ __ROR4__(v683, 25);
    v435 = v419 + v430;
    v799 = v429 ^ __ROR4__(v798, 25);
    v684 = v427 ^ __ROR4__(v879, 25);
    v436 = v741;
    v824 = v655 ^ __ROR4__(v823, 25);
    v437 = v424 + v961;
    v742 = v1015 + v434;
    v438 = v852 ^ __ROR4__(v423, 25);
    v880 = v429 + v1088;
    v439 = v1064 ^ __ROR4__(v436, 25);
    v440 = v428 + v799;
    v713 = v712 + v770;
    v1016 = v1041 + v907;
    v566 = v565 + v684;
    v441 = v427 + v1124;
    v656 = v655 + v989;
    v1042 = v596 + v824;
    v535 = v534 + v438;
    v442 = v852 + v934;
    v443 = (v852 + v934) ^ __ROR4__(v431, 21);
    v597 = v1064 + v433;
    v444 = v625;
    v626 = v437 ^ __ROR4__(v1124, 21);
    v853 = v441 ^ __ROR4__(v961, 21);
    v445 = v444 + v439;
    v685 = v742 ^ __ROR4__(v684, 21);
    v962 = v566 ^ __ROR4__(v434, 21);
    v990 = (v429 + v1088) ^ __ROR4__(v989, 21);
    v1089 = v656 ^ __ROR4__(v1088, 21);
    v1065 = v440 ^ __ROR4__(v824, 21);
    v1108 = v1042 ^ __ROR4__(v799, 21);
    v825 = v443;
    v446 = v435 ^ __ROR4__(v433, 21);
    v800 = v713 ^ __ROR4__(v438, 21);
    v447 = v597 ^ __ROR4__(v430, 21);
    v448 = v432 ^ __ROR4__(v934, 21);
    v1125 = v437 + v448;
    v771 = v535 ^ __ROR4__(v770, 21);
    v1133 = v441 + v825;
    v449 = v1016 ^ __ROR4__(v439, 21);
    v450 = v907;
    v908 = v432 + v626;
    v451 = v440 + v449;
    v452 = v445 ^ __ROR4__(v450, 21);
    v453 = v713 + v685;
    v1131 = v442 + v853;
    v454 = v742 + v800;
    v455 = (v742 + v800) ^ __ROR4__(v449, 25);
    v536 = v535 + v962;
    v456 = v435 + v990;
    v567 = v566 + v771;
    v457 = v880 + v446;
    v458 = v1016;
    v1017 = v597 + v1089;
    v598 = v656 + v447;
    v459 = v458 + v1065;
    v460 = v445 + v1108;
    v657 = v1042 + v452;
    v714 = v908 ^ __ROR4__(v990, 25);
    v935 = (v880 + v446) ^ __ROR4__(v448, 25);
    v881 = v456 ^ __ROR4__(v626, 25);
    v627 = (v437 + v448) ^ __ROR4__(v446, 25);
    v743 = v1131 ^ __ROR4__(v1089, 25);
    v854 = v1017 ^ __ROR4__(v853, 25);
    v461 = v1133 ^ __ROR4__(v447, 25);
    v462 = v598 ^ __ROR4__(v825, 25);
    v463 = v453 ^ __ROR4__(v1065, 25);
    v464 = v685;
    v686 = v455;
    v465 = v459 ^ __ROR4__(v464, 25);
    v466 = v456 + v465;
    v826 = v451 ^ __ROR4__(v800, 25);
    v467 = v1042 + v452;
    v801 = v536 ^ __ROR4__(v1108, 25);
    v963 = v460 ^ __ROR4__(v962, 25);
    v468 = v567 ^ __ROR4__(v452, 25);
    v469 = v467 ^ __ROR4__(v771, 25);
    v772 = v453 + v714;
    v909 = v908 + v463;
    v470 = v451 + v935;
    v471 = v459 + v881;
    v472 = v454 + v627;
    v473 = v1125 + v686;
    v474 = v457 + v826;
    v537 = v536 + v743;
    v991 = v1131 + v801;
    v475 = v460 + v854;
    v1043 = v1017 + v963;
    v568 = v567 + v461;
    v1018 = v1133 + v468;
    v476 = v657 + v462;
    v477 = v470 ^ __ROR4__(v462, 21);
    v658 = v476;
    v478 = v598 + v469;
    v479 = v474 ^ __ROR4__(v469, 21);
    v599 = v478;
    v744 = v772 ^ __ROR4__(v743, 21);
    v1066 = v537 ^ __ROR4__(v714, 21);
    v715 = v909 ^ __ROR4__(v801, 21);
    v1090 = (v1131 + v801) ^ __ROR4__(v463, 21);
    v480 = v471 ^ __ROR4__(v854, 21);
    v481 = v471 + v477;
    v1109 = v480;
    v882 = v475 ^ __ROR4__(v881, 21);
    v482 = v963;
    v483 = v627;
    v628 = (v1125 + v686) ^ __ROR4__(v468, 21);
    v964 = v1043 ^ __ROR4__(v465, 21);
    v484 = v466 ^ __ROR4__(v482, 21);
    v485 = v466 + v479;
    v855 = v484;
    v486 = v935;
    v802 = v568 ^ __ROR4__(v483, 21);
    v687 = (v1133 + v468) ^ __ROR4__(v686, 21);
    v936 = v472 ^ __ROR4__(v461, 21);
    v487 = v658 ^ __ROR4__(v486, 21);
    v488 = v599 ^ __ROR4__(v826, 21);
    v489 = v475 + v487;
    v490 = v472 + v744;
    v773 = v772 + v936;
    v569 = v568 + v1066;
    v827 = v537 + v802;
    v538 = v473 + v715;
    v491 = v909 + v628;
    v1019 = v1018 + v1090;
    v492 = v470 + v1109;
    v992 = v991 + v687;
    v1126 = v490 ^ __ROR4__(v1109, 25);
    v659 = v658 + v882;
    v493 = v474 + v855;
    v1110 = v599 + v964;
    v494 = v1043 + v488;
    v1134 = v492 ^ __ROR4__(v744, 25);
    v495 = v882;
    v496 = v1066;
    v883 = (v909 + v628) ^ __ROR4__(v479, 25);
    v745 = v773 ^ __ROR4__(v477, 25);
    v1136 = v481 ^ __ROR4__(v936, 25);
    v1138 = v485 ^ __ROR4__(v628, 25);
    v1132 = v569 ^ __ROR4__(v495, 25);
    v1067 = v827 ^ __ROR4__(v487, 25);
    v497 = v659 ^ __ROR4__(v496, 25);
    v1139 = v489 ^ __ROR4__(v802, 25);
    v498 = v538 ^ __ROR4__(v855, 25);
    v716 = v493 ^ __ROR4__(v715, 25);
    v499 = v1019 ^ __ROR4__(v964, 25);
    v500 = (v599 + v964) ^ __ROR4__(v1090, 25);
    v1091 = v992 ^ __ROR4__(v488, 25);
    v1140 = (v1043 + v488) ^ __ROR4__(v687, 25);
    v884 = v538 + v1126;
    v910 = v490 + v498;
    v16 = v493 + v1134;
    v14 = v492 + v716;
    v8 = v491 + v745;
    v937 = v773 + v883;
    v12 = v485 + v1136;
    v9 = v481 + v1138;
    v570 = v1019 + v1132;
    v993 = v569 + v499;
    v600 = v1110 + v497;
    v15 = v16 ^ __ROR4__(v497, 21);
    v501 = v659 + v500;
    v18 = v14 ^ __ROR4__(v500, 21);
    v539 = v501;
    v965 = v992 + v1067;
    v1020 = v827 + v1091;
    v13 = v494 + v1139;
    v7 = v489 + v1140;
    v508 = (v538 + v1126) ^ __ROR4__(v1132, 21);
    v660 = v570 ^ __ROR4__(v1126, 21);
    v11 = (v490 + v498) ^ __ROR4__(v499, 21);
    v10 = v993 ^ __ROR4__(v498, 21);
    v774 = v600 ^ __ROR4__(v1134, 21);
    v828 = v501 ^ __ROR4__(v716, 21);
    v629 = v8 ^ __ROR4__(v1067, 21);
    v688 = v965 ^ __ROR4__(v745, 21);
    v17 = (v773 + v883) ^ __ROR4__(v1091, 21);
    v717 = (v827 + v1091) ^ __ROR4__(v883, 21);
    v1068 = v12 ^ __ROR4__(v1139, 21);
    v803 = v13 ^ __ROR4__(v1136, 21);
    v746 = v9 ^ __ROR4__(v1140, 21);
    v856 = v7 ^ __ROR4__(v1138, 21);
    if ( v507 )
      break;
    v539 = v501 ^ 1;
LABEL_2:
    ++v507;
  }
  if ( v507 != 10 )
    goto LABEL_2;
  a1[10] = v629;
  a1[11] = v11;
  a1[12] = v17;
  a1[13] = v660;
  v1137 = v18;
  a1[9] = v508;
  a1[14] = v688;
  v502 = a4;
  a1[15] = v10;
  a1[26] = v884;
  a1[29] = v965;
  a1[16] = v717;
  a1[34] = v16;
  a1[17] = v15;
  a1[18] = v1068;
  a1[30] = v570;
  a1[31] = v1020;
  a1[19] = v1137;
  a1[32] = v993;
  a1[25] = v8;
  a1[20] = v746;
  a1[27] = v937;
  a1[28] = v910;
  a1[21] = v774;
  a1[33] = v12;
  a1[35] = v9;
  a1[22] = v803;
  a1[23] = v828;
  a1[24] = v856;
  a1[36] = v14;
  a1[39] = v7;
  a1[37] = v13;
  a1[40] = v501;
  v503 = v508;
  a1[38] = v600;
  for ( i = a1 + 9; ; ++i )
  {
    result = HIWORD(v503);
    *v502 = v503;
    v502 += 2;
    *((_BYTE *)v502 - 2) = BYTE2(v503);
    *((_BYTE *)v502 - 1) = HIBYTE(v503);
    if ( &a4[2 * a5] == v502 )
      break;
    v505 = i[1];
    v503 = v505;
  }
  return result;
}

//----- (000A08B0) --------------------------------------------------------
void *__fastcall sph_cubehash224_init_0(int a1)
{
  void *result; // r0

  result = memcpy((void *)(a1 + 36), &unk_ED744, 0x80u);
  *(_DWORD *)(a1 + 32) = 0;
  return result;
}

//----- (000A08DC) --------------------------------------------------------
void *__fastcall sph_cubehash224_addbits_and_close(_DWORD *a1, char a2, char a3, _WORD *a4)
{
  void *result; // r0

  sub_9D714(a1, a2, a3, a4, 7);
  result = memcpy(a1 + 9, &unk_ED744, 0x80u);
  a1[8] = 0;
  return result;
}

//----- (000A0918) --------------------------------------------------------
void *__fastcall sph_cubehash224_close(_DWORD *a1, _WORD *a2)
{
  return sph_cubehash224_addbits_and_close(a1, 0, 0, a2);
}

//----- (000A0928) --------------------------------------------------------
void *__fastcall sph_cubehash256_init_0(int a1)
{
  void *result; // r0

  result = memcpy((void *)(a1 + 36), &unk_ED7C4, 0x80u);
  *(_DWORD *)(a1 + 32) = 0;
  return result;
}

//----- (000A0954) --------------------------------------------------------
void *__fastcall sph_cubehash256_addbits_and_close(_DWORD *a1, char a2, char a3, _WORD *a4)
{
  void *result; // r0

  sub_9D714(a1, a2, a3, a4, 8);
  result = memcpy(a1 + 9, &unk_ED7C4, 0x80u);
  a1[8] = 0;
  return result;
}

//----- (000A0990) --------------------------------------------------------
void *__fastcall sph_cubehash256_close(_DWORD *a1, _WORD *a2)
{
  return sph_cubehash256_addbits_and_close(a1, 0, 0, a2);
}

//----- (000A09A0) --------------------------------------------------------
void *__fastcall sph_cubehash384_init(int a1)
{
  void *result; // r0

  result = memcpy((void *)(a1 + 36), &unk_ED844, 0x80u);
  *(_DWORD *)(a1 + 32) = 0;
  return result;
}

//----- (000A09CC) --------------------------------------------------------
void *__fastcall sph_cubehash384_addbits_and_close(_DWORD *a1, char a2, char a3, _WORD *a4)
{
  void *result; // r0

  sub_9D714(a1, a2, a3, a4, 12);
  result = memcpy(a1 + 9, &unk_ED844, 0x80u);
  a1[8] = 0;
  return result;
}

//----- (000A0A08) --------------------------------------------------------
void *__fastcall sph_cubehash384_close(_DWORD *a1, _WORD *a2)
{
  return sph_cubehash384_addbits_and_close(a1, 0, 0, a2);
}

//----- (000A0A18) --------------------------------------------------------
void *__fastcall sph_cubehash512_init(int a1)
{
  void *result; // r0

  result = memcpy((void *)(a1 + 36), &unk_ED8C4, 0x80u);
  *(_DWORD *)(a1 + 32) = 0;
  return result;
}

//----- (000A0A44) --------------------------------------------------------
void *__fastcall sph_cubehash512_addbits_and_close(_DWORD *a1, char a2, char a3, _WORD *a4)
{
  void *result; // r0

  sub_9D714(a1, a2, a3, a4, 16);
  result = memcpy(a1 + 9, &unk_ED8C4, 0x80u);
  a1[8] = 0;
  return result;
}

//----- (000A0A80) --------------------------------------------------------
void *__fastcall sph_cubehash512_close(_DWORD *a1, _WORD *a2)
{
  return sph_cubehash512_addbits_and_close(a1, 0, 0, a2);
}

//----- (000A0A90) --------------------------------------------------------
_DWORD *__fastcall sub_A0A90(_DWORD *result, int a2)
{
  result[34] = a2;
  result[38] = a2;
  result[42] = a2;
  result[46] = a2;
  result[50] = a2;
  result[54] = a2;
  result[58] = a2;
  result[62] = a2;
  result[37] = 0;
  result[36] = 0;
  result[35] = 0;
  result[41] = 0;
  result[40] = 0;
  result[39] = 0;
  result[45] = 0;
  result[44] = 0;
  result[43] = 0;
  result[49] = 0;
  result[48] = 0;
  result[47] = 0;
  result[53] = 0;
  result[52] = 0;
  result[51] = 0;
  result[57] = 0;
  result[56] = 0;
  result[55] = 0;
  result[61] = 0;
  result[60] = 0;
  result[59] = 0;
  result[65] = 0;
  result[64] = 0;
  result[63] = 0;
  result[32] = 0;
  result[69] = 0;
  result[68] = 0;
  result[67] = 0;
  result[66] = 0;
  return result;
}

//----- (000A0B2C) --------------------------------------------------------
unsigned int *__fastcall sub_A0B2C(unsigned int *a1)
{
  unsigned int *v1; // r12
  unsigned int *v2; // r5
  unsigned int *v3; // r4
  unsigned int v4; // r0
  unsigned int v5; // r1
  unsigned int *v6; // lr
  unsigned int v7; // r2
  unsigned int v8; // r3
  unsigned int *v9; // r2
  unsigned int *v10; // r3
  unsigned int v11; // lr
  unsigned int v12; // r12
  __int64 v13; // r0
  unsigned int v14; // r3
  unsigned int v15; // r2
  unsigned int v16; // r1
  unsigned int v17; // lr
  int v18; // r6
  int v19; // r4
  int v20; // r8
  int v21; // r2
  unsigned int v22; // r0
  unsigned int v23; // r2
  unsigned int v24; // r1
  unsigned int v25; // r3
  int v26; // r12
  int v27; // r4
  int v28; // r8
  int v29; // r2
  unsigned int v30; // r2
  unsigned int v31; // r0
  unsigned int v32; // r1
  unsigned int v33; // r3
  int v34; // r7
  int v35; // r8
  int v36; // r1
  unsigned int v37; // r2
  unsigned int v38; // r0
  unsigned int v39; // r3
  unsigned int v40; // r1
  int v41; // r12
  int v42; // r8
  int v43; // r4
  int v44; // r2
  unsigned int v45; // r1
  unsigned int v46; // r3
  unsigned int v47; // r2
  unsigned int v48; // r0
  int v49; // r4
  bool v50; // zf
  unsigned int v51; // r3
  unsigned int v52; // r0
  unsigned int v53; // r1
  unsigned int v54; // r3
  unsigned int v55; // r2
  int v56; // lr
  bool v57; // zf
  unsigned int v58; // r3
  unsigned int v59; // r1
  unsigned int v60; // r3
  unsigned int v61; // r2
  unsigned int v62; // r0
  int v63; // r4
  bool v64; // zf
  unsigned int v65; // r3
  unsigned int v66; // r1
  unsigned int v67; // r2
  unsigned int v68; // r3
  unsigned int v69; // r0
  int v70; // r4
  bool v71; // zf
  unsigned int v72; // r3
  unsigned int v73; // r3
  unsigned int v74; // r1
  unsigned int v75; // r0
  unsigned int v76; // r2
  int v77; // r4
  bool v78; // zf
  unsigned int v79; // r3
  unsigned int v80; // r0
  unsigned int v81; // r3
  unsigned int v82; // r1
  unsigned int v83; // r2
  int v84; // lr
  bool v85; // zf
  unsigned int v86; // r3
  unsigned int v87; // r12
  unsigned int v88; // r0
  unsigned int v89; // lr
  unsigned int v90; // r2
  int v91; // r1
  bool v92; // zf
  unsigned int v93; // r3
  unsigned int v94; // r1
  unsigned int v95; // r3
  unsigned int v96; // r2
  unsigned int v97; // r0
  int v98; // r4
  bool v99; // zf
  unsigned int v100; // r3
  unsigned int v101; // r1
  unsigned int v102; // r3
  unsigned int v103; // r2
  unsigned int v104; // r0
  int v105; // r4
  bool v106; // zf
  unsigned int v107; // r3
  unsigned int v108; // r0
  unsigned int v109; // r3
  unsigned int v110; // r2
  unsigned int v111; // r1
  int v112; // r4
  bool v113; // zf
  unsigned int v114; // r3
  unsigned int v115; // r1
  unsigned int v116; // r3
  unsigned int v117; // r2
  unsigned int v118; // r0
  int v119; // r12
  int v120; // r4
  int v121; // lr
  int v122; // r8
  int v123; // r6
  unsigned int v124; // r0
  bool v125; // zf
  unsigned int v126; // r3
  unsigned int v127; // r8
  unsigned int v128; // r1
  unsigned int v129; // r3
  unsigned int v130; // r6
  int v131; // r12
  int v132; // r0
  int v133; // r2
  bool v134; // zf
  unsigned int v135; // r3
  int v136; // lr
  int v137; // r4
  unsigned int v138; // r5
  unsigned int v139; // r12
  unsigned int v140; // lr
  int v141; // r6
  unsigned int v142; // r7
  unsigned int v143; // r10
  unsigned int v144; // r1
  unsigned int v145; // r8
  int v146; // r5
  unsigned int v147; // r12
  int v148; // r3
  unsigned int v149; // r0
  unsigned int v150; // r7
  unsigned int v151; // r0
  int v152; // r10
  int v153; // r2
  unsigned int v154; // r6
  int v155; // r7
  int v156; // r0
  unsigned int v157; // r3
  int v158; // r4
  int v159; // r8
  unsigned int v160; // r0
  int v161; // lr
  unsigned int v162; // r12
  int v163; // r10
  unsigned int v164; // r2
  int v165; // r8
  unsigned int v166; // r1
  int v167; // r0
  unsigned int v168; // r12
  int v169; // r10
  unsigned int v170; // r12
  unsigned int v171; // r1
  unsigned int v172; // r3
  int v173; // r9
  unsigned int v174; // r2
  unsigned int v175; // r4
  int v176; // lr
  unsigned int v177; // r0
  int v178; // r8
  int v179; // r12
  int v180; // lr
  unsigned int v181; // r4
  unsigned int v182; // r5
  int v183; // r0
  unsigned int v184; // r1
  int v185; // r6
  int v186; // r4
  unsigned int v187; // r8
  unsigned int v188; // r7
  int v189; // r1
  unsigned int v190; // r0
  unsigned int v191; // r1
  int v192; // r5
  unsigned int v193; // r9
  unsigned int v194; // r8
  unsigned int v195; // r1
  int v196; // r6
  unsigned int v197; // r12
  unsigned int v198; // r2
  int v199; // r5
  unsigned int v200; // r0
  unsigned int v201; // r4
  unsigned int v202; // r3
  unsigned int v203; // r1
  int v204; // r9
  unsigned int v205; // r4
  unsigned int v206; // r3
  unsigned int v207; // r2
  int v208; // r6
  unsigned int v209; // r5
  unsigned int v210; // r3
  int v211; // lr
  unsigned int v212; // r5
  int v213; // r5
  unsigned int v214; // r6
  int v215; // lr
  unsigned int v216; // r12
  unsigned int v217; // r6
  unsigned int v218; // r9
  int v219; // lr
  unsigned int v220; // r8
  unsigned int v221; // r7
  unsigned int v222; // r2
  unsigned int v223; // r5
  unsigned int v224; // r10
  unsigned int *result; // r0
  unsigned int v226; // r6
  unsigned int *v227; // lr
  unsigned int *v228; // r3
  _DWORD *v229; // r2
  unsigned int v230; // t1
  unsigned int v231; // r12
  unsigned int v232; // t1
  int v233; // t1
  bool v234; // zf
  unsigned int v235; // r3
  bool v236; // zf
  unsigned int v237; // r3
  bool v238; // zf
  unsigned int v239; // r2
  bool v240; // zf
  unsigned int v241; // r3
  unsigned int v242; // [sp+0h] [bp-28Ch]
  unsigned int v243; // [sp+8h] [bp-284h]
  unsigned int v244; // [sp+Ch] [bp-280h]
  int v245; // [sp+10h] [bp-27Ch]
  unsigned int v246; // [sp+14h] [bp-278h]
  int v247; // [sp+14h] [bp-278h]
  unsigned int v248; // [sp+18h] [bp-274h]
  int v249; // [sp+18h] [bp-274h]
  unsigned int v250; // [sp+1Ch] [bp-270h]
  int v251; // [sp+1Ch] [bp-270h]
  unsigned int v252; // [sp+20h] [bp-26Ch]
  int v253; // [sp+20h] [bp-26Ch]
  unsigned int v254; // [sp+24h] [bp-268h]
  int v255; // [sp+24h] [bp-268h]
  unsigned int v256; // [sp+28h] [bp-264h]
  int v257; // [sp+28h] [bp-264h]
  unsigned int v258; // [sp+2Ch] [bp-260h]
  int v259; // [sp+2Ch] [bp-260h]
  unsigned int v260; // [sp+30h] [bp-25Ch]
  int v261; // [sp+30h] [bp-25Ch]
  unsigned int v262; // [sp+34h] [bp-258h]
  int v263; // [sp+34h] [bp-258h]
  unsigned int v264; // [sp+38h] [bp-254h]
  int v265; // [sp+38h] [bp-254h]
  unsigned int v266; // [sp+3Ch] [bp-250h]
  int v267; // [sp+3Ch] [bp-250h]
  unsigned int v268; // [sp+40h] [bp-24Ch]
  int v269; // [sp+40h] [bp-24Ch]
  unsigned int v270; // [sp+44h] [bp-248h]
  int v271; // [sp+44h] [bp-248h]
  unsigned int v272; // [sp+48h] [bp-244h]
  int v273; // [sp+48h] [bp-244h]
  unsigned int v274; // [sp+4Ch] [bp-240h]
  int v275; // [sp+4Ch] [bp-240h]
  unsigned int v276; // [sp+4Ch] [bp-240h]
  unsigned int v277; // [sp+50h] [bp-23Ch]
  unsigned int v278; // [sp+54h] [bp-238h]
  int v279; // [sp+58h] [bp-234h]
  unsigned int v280; // [sp+58h] [bp-234h]
  int v281; // [sp+5Ch] [bp-230h]
  unsigned int v282; // [sp+5Ch] [bp-230h]
  int v283; // [sp+64h] [bp-228h]
  int v284; // [sp+68h] [bp-224h]
  int v285; // [sp+6Ch] [bp-220h]
  int v286; // [sp+70h] [bp-21Ch]
  int v287; // [sp+74h] [bp-218h]
  int v288; // [sp+78h] [bp-214h]
  int v289; // [sp+7Ch] [bp-210h]
  int v290; // [sp+80h] [bp-20Ch]
  int v291; // [sp+84h] [bp-208h]
  int v292; // [sp+88h] [bp-204h]
  int v293; // [sp+8Ch] [bp-200h]
  int v294; // [sp+90h] [bp-1FCh]
  int v295; // [sp+94h] [bp-1F8h]
  unsigned int v296; // [sp+98h] [bp-1F4h]
  int v297; // [sp+98h] [bp-1F4h]
  unsigned int v298; // [sp+98h] [bp-1F4h]
  int v299; // [sp+9Ch] [bp-1F0h]
  unsigned int v300; // [sp+9Ch] [bp-1F0h]
  unsigned int v301; // [sp+A0h] [bp-1ECh]
  int v302; // [sp+A0h] [bp-1ECh]
  unsigned int v303; // [sp+A0h] [bp-1ECh]
  int v304; // [sp+A4h] [bp-1E8h]
  int v305; // [sp+A8h] [bp-1E4h]
  unsigned int v306; // [sp+ACh] [bp-1E0h]
  int v307; // [sp+ACh] [bp-1E0h]
  unsigned int v308; // [sp+B0h] [bp-1DCh]
  int v309; // [sp+B0h] [bp-1DCh]
  unsigned int v310; // [sp+B4h] [bp-1D8h]
  int v311; // [sp+B4h] [bp-1D8h]
  int v312; // [sp+B8h] [bp-1D4h]
  int v313; // [sp+BCh] [bp-1D0h]
  int v314; // [sp+C0h] [bp-1CCh]
  int v315; // [sp+C4h] [bp-1C8h]
  unsigned int v316; // [sp+C8h] [bp-1C4h]
  int v317; // [sp+C8h] [bp-1C4h]
  unsigned int v318; // [sp+CCh] [bp-1C0h]
  int v319; // [sp+CCh] [bp-1C0h]
  int v320; // [sp+D0h] [bp-1BCh]
  unsigned int v321; // [sp+D4h] [bp-1B8h]
  int v322; // [sp+D4h] [bp-1B8h]
  unsigned int v323; // [sp+D8h] [bp-1B4h]
  int v324; // [sp+D8h] [bp-1B4h]
  unsigned int v325; // [sp+DCh] [bp-1B0h]
  unsigned int v326; // [sp+DCh] [bp-1B0h]
  unsigned int v327; // [sp+E0h] [bp-1ACh]
  unsigned int v328; // [sp+E0h] [bp-1ACh]
  unsigned int v329; // [sp+E4h] [bp-1A8h]
  int v330; // [sp+E4h] [bp-1A8h]
  unsigned int v331; // [sp+E8h] [bp-1A4h]
  int v332; // [sp+E8h] [bp-1A4h]
  unsigned int v333; // [sp+ECh] [bp-1A0h]
  int v334; // [sp+ECh] [bp-1A0h]
  unsigned int v335; // [sp+F0h] [bp-19Ch]
  unsigned int v336; // [sp+F4h] [bp-198h]
  int v337; // [sp+F4h] [bp-198h]
  unsigned int v338; // [sp+F8h] [bp-194h]
  int v339; // [sp+F8h] [bp-194h]
  unsigned int v340; // [sp+FCh] [bp-190h]
  int v341; // [sp+FCh] [bp-190h]
  unsigned int v342; // [sp+100h] [bp-18Ch]
  int v343; // [sp+100h] [bp-18Ch]
  unsigned int v344; // [sp+104h] [bp-188h]
  unsigned int v345; // [sp+108h] [bp-184h]
  unsigned int v346; // [sp+108h] [bp-184h]
  unsigned int v347; // [sp+10Ch] [bp-180h]
  unsigned int v348; // [sp+10Ch] [bp-180h]
  unsigned int v349; // [sp+110h] [bp-17Ch]
  unsigned int v350; // [sp+110h] [bp-17Ch]
  unsigned int v351; // [sp+114h] [bp-178h]
  unsigned int v352; // [sp+114h] [bp-178h]
  unsigned int v353; // [sp+118h] [bp-174h]
  unsigned int v354; // [sp+118h] [bp-174h]
  unsigned int v355; // [sp+11Ch] [bp-170h]
  unsigned int v356; // [sp+11Ch] [bp-170h]
  unsigned int v357; // [sp+120h] [bp-16Ch]
  int v358; // [sp+120h] [bp-16Ch]
  unsigned int v359; // [sp+124h] [bp-168h]
  unsigned int v360; // [sp+128h] [bp-164h]
  unsigned int v361; // [sp+12Ch] [bp-160h]
  int v362; // [sp+12Ch] [bp-160h]
  unsigned int v363; // [sp+130h] [bp-15Ch]
  int v364; // [sp+130h] [bp-15Ch]
  unsigned int v365; // [sp+134h] [bp-158h]
  int v366; // [sp+134h] [bp-158h]
  unsigned int v367; // [sp+138h] [bp-154h]
  int v368; // [sp+138h] [bp-154h]
  unsigned int v369; // [sp+13Ch] [bp-150h]
  int v370; // [sp+13Ch] [bp-150h]
  unsigned int v371; // [sp+140h] [bp-14Ch]
  unsigned int v372; // [sp+144h] [bp-148h]
  unsigned int v373; // [sp+148h] [bp-144h]
  unsigned int v374; // [sp+14Ch] [bp-140h]
  unsigned int v375; // [sp+150h] [bp-13Ch]
  unsigned int v376; // [sp+154h] [bp-138h]
  unsigned int v377; // [sp+158h] [bp-134h]
  unsigned int v378; // [sp+158h] [bp-134h]
  unsigned int v379; // [sp+15Ch] [bp-130h]
  unsigned int v380; // [sp+160h] [bp-12Ch]
  unsigned int v381; // [sp+164h] [bp-128h]
  unsigned int v382; // [sp+168h] [bp-124h]
  unsigned int v383; // [sp+16Ch] [bp-120h]
  unsigned int v384; // [sp+170h] [bp-11Ch]
  int v385; // [sp+174h] [bp-118h]
  int v386; // [sp+178h] [bp-114h]
  int v387; // [sp+17Ch] [bp-110h]
  unsigned int v388; // [sp+180h] [bp-10Ch]
  unsigned int v390; // [sp+188h] [bp-104h] BYREF
  unsigned int v391; // [sp+18Ch] [bp-100h] BYREF
  unsigned int v392; // [sp+190h] [bp-FCh]
  unsigned int v393; // [sp+194h] [bp-F8h]
  unsigned int v394; // [sp+198h] [bp-F4h]
  unsigned int v395; // [sp+19Ch] [bp-F0h]
  unsigned int v396; // [sp+1A0h] [bp-ECh]
  unsigned int v397; // [sp+1A4h] [bp-E8h]
  unsigned int v398; // [sp+1A8h] [bp-E4h]
  unsigned int v399; // [sp+1ACh] [bp-E0h]
  unsigned int v400; // [sp+1B0h] [bp-DCh]
  unsigned int v401; // [sp+1B4h] [bp-D8h]
  unsigned int v402; // [sp+1B8h] [bp-D4h]
  unsigned int v403; // [sp+1BCh] [bp-D0h]
  unsigned int v404; // [sp+1C0h] [bp-CCh]
  unsigned int v405; // [sp+1C4h] [bp-C8h]
  unsigned int v406; // [sp+1C8h] [bp-C4h] BYREF
  unsigned int v407; // [sp+1CCh] [bp-C0h]
  unsigned int v408; // [sp+1D0h] [bp-BCh]
  unsigned int v409; // [sp+1D4h] [bp-B8h]
  unsigned int v410; // [sp+1D8h] [bp-B4h]
  unsigned int v411; // [sp+1DCh] [bp-B0h]
  unsigned int v412; // [sp+1E0h] [bp-ACh]
  unsigned int v413; // [sp+1E4h] [bp-A8h]
  unsigned int v414; // [sp+1E8h] [bp-A4h]
  unsigned int v415; // [sp+1ECh] [bp-A0h]
  unsigned int v416; // [sp+1F0h] [bp-9Ch]
  unsigned int v417; // [sp+1F4h] [bp-98h]
  unsigned int v418; // [sp+1F8h] [bp-94h]
  unsigned int v419; // [sp+1FCh] [bp-90h]
  unsigned int v420; // [sp+200h] [bp-8Ch]
  unsigned int v421; // [sp+204h] [bp-88h]
  unsigned int v422; // [sp+208h] [bp-84h]
  unsigned int v423; // [sp+20Ch] [bp-80h]
  unsigned int v424; // [sp+210h] [bp-7Ch]
  unsigned int v425; // [sp+214h] [bp-78h]
  unsigned int v426; // [sp+218h] [bp-74h]
  unsigned int v427; // [sp+21Ch] [bp-70h]
  int v428; // [sp+220h] [bp-6Ch]
  unsigned int v429; // [sp+224h] [bp-68h]
  unsigned int v430; // [sp+228h] [bp-64h]
  unsigned int v431; // [sp+22Ch] [bp-60h]
  unsigned int v432; // [sp+230h] [bp-5Ch]
  unsigned int v433; // [sp+234h] [bp-58h]
  unsigned int v434; // [sp+238h] [bp-54h]
  unsigned int v435; // [sp+23Ch] [bp-50h]
  unsigned int v436; // [sp+240h] [bp-4Ch]
  unsigned int v437; // [sp+244h] [bp-48h]
  unsigned int v438; // [sp+248h] [bp-44h] BYREF
  unsigned int v439; // [sp+24Ch] [bp-40h]
  unsigned int v440; // [sp+250h] [bp-3Ch]
  int v441; // [sp+254h] [bp-38h]
  unsigned int v442; // [sp+258h] [bp-34h]
  unsigned int v443; // [sp+25Ch] [bp-30h]
  unsigned int v444; // [sp+260h] [bp-2Ch]
  int v445; // [sp+264h] [bp-28h]
  unsigned int v446; // [sp+268h] [bp-24h]
  int v447; // [sp+26Ch] [bp-20h]
  unsigned int v448; // [sp+270h] [bp-1Ch]
  unsigned int v449; // [sp+274h] [bp-18h]
  unsigned int v450; // [sp+278h] [bp-14h]
  unsigned int v451; // [sp+27Ch] [bp-10h]
  unsigned int v452; // [sp+280h] [bp-Ch]
  unsigned int v453; // [sp+284h] [bp-8h]

  v1 = a1 + 50;
  v2 = a1 + 66;
  v3 = &v390;
  v244 = a1[66];
  v245 = a1[69];
  v242 = a1[67];
  v243 = a1[68];
  do
  {
    v4 = *v1;
    v1 += 4;
    v5 = *(v1 - 3);
    v6 = v3;
    v7 = *(v1 - 2);
    v3 += 4;
    v8 = *(v1 - 1);
    *v6 = v4;
    v6[1] = v5;
    v6[2] = v7;
    v6[3] = v8;
  }
  while ( v1 != v2 );
  v9 = a1;
  v10 = &v390;
  do
  {
    v11 = *v9;
    v10 += 4;
    v12 = v9[1];
    v9 += 4;
    v13 = *((_QWORD *)v9 - 1);
    v10[12] = v11;
    v10[13] = v12;
    *((_QWORD *)v10 + 7) = v13;
  }
  while ( &v438 != v10 );
  v246 = v390;
  v333 = v393;
  v329 = v391;
  v331 = v392;
  v248 = v394;
  v335 = v395;
  v336 = v396;
  v388 = v244 + 128;
  v338 = v397;
  v250 = v398;
  v252 = v399;
  v340 = v400;
  v342 = v401;
  v254 = v402;
  v344 = v403;
  v345 = v404;
  v301 = v405;
  v256 = v406;
  v306 = v407;
  v308 = v408;
  v310 = v409;
  v258 = v410;
  v347 = v411;
  v349 = v412;
  v351 = v413;
  v260 = v414;
  v353 = v415;
  v355 = v416;
  v357 = v417;
  v262 = v418;
  v359 = v419;
  v360 = v420;
  v361 = v421;
  v264 = v422;
  v363 = v423;
  v321 = v424;
  v323 = v425;
  v266 = v426;
  v365 = v427;
  v367 = v428;
  v369 = v429;
  v268 = v430;
  v371 = v431;
  v372 = v432;
  v373 = v433;
  v270 = v434;
  v374 = v435;
  v375 = v436;
  v376 = v437;
  v272 = v438;
  v316 = v439;
  v296 = v440;
  v318 = v441;
  v274 = v442;
  v325 = v443;
  v327 = v444;
  v377 = v445;
  v277 = v446;
  v379 = v447;
  v380 = v448;
  v381 = v449;
  v278 = v450;
  v382 = v451;
  v383 = v452;
  v384 = v453;
  do
  {
    v14 = dword_ED944[BYTE1(v329) + 512]
        ^ dword_ED944[(unsigned __int8)v246]
        ^ dword_ED944[HIBYTE(v333) + 256]
        ^ v244
        ^ dword_ED944[BYTE2(v331) + 768];
    v15 = dword_ED944[BYTE1(v331) + 512]
        ^ dword_ED944[HIBYTE(v246) + 256]
        ^ dword_ED944[(unsigned __int8)v329]
        ^ v242
        ^ dword_ED944[BYTE2(v333) + 768];
    v16 = dword_ED944[BYTE1(v333) + 512]
        ^ dword_ED944[(unsigned __int8)v331]
        ^ dword_ED944[HIBYTE(v329) + 256]
        ^ v243
        ^ dword_ED944[BYTE2(v246) + 768];
    v17 = dword_ED944[BYTE1(v246) + 512]
        ^ dword_ED944[(unsigned __int8)v333]
        ^ dword_ED944[HIBYTE(v331) + 256]
        ^ v245
        ^ dword_ED944[BYTE2(v329) + 768];
    v18 = dword_ED944[HIBYTE(v17) + 256] ^ dword_ED944[(unsigned __int8)v14] ^ dword_ED944[BYTE1(v15) + 512];
    v19 = dword_ED944[BYTE1(v16) + 512] ^ dword_ED944[HIBYTE(v14) + 256] ^ dword_ED944[(unsigned __int8)v15];
    v20 = dword_ED944[(unsigned __int8)v16] ^ dword_ED944[HIBYTE(v15) + 256] ^ dword_ED944[BYTE1(v17) + 512];
    v21 = dword_ED944[BYTE2(v15) + 768];
    v281 = v19 ^ dword_ED944[BYTE2(v17) + 768];
    v279 = v18 ^ dword_ED944[BYTE2(v16) + 768];
    v299 = v20 ^ dword_ED944[BYTE2(v14) + 768];
    v304 = dword_ED944[HIBYTE(v16) + 256] ^ dword_ED944[(unsigned __int8)v17] ^ dword_ED944[BYTE1(v14) + 512] ^ v21;
    if ( v244 == -1 && !++v242 )
    {
      v235 = v243 + 1;
      v234 = v243 == -1;
      if ( v243 == -1 )
        v21 = v245;
      ++v243;
      if ( v234 )
      {
        v242 = v235;
        v245 = v21 + 1;
      }
    }
    v22 = dword_ED944[(unsigned __int8)v335]
        ^ dword_ED944[HIBYTE(v248) + 256]
        ^ dword_ED944[BYTE1(v336) + 512]
        ^ dword_ED944[BYTE2(v338) + 768]
        ^ v242;
    v23 = dword_ED944[HIBYTE(v335) + 256]
        ^ dword_ED944[(unsigned __int8)v336]
        ^ dword_ED944[BYTE1(v338) + 512]
        ^ dword_ED944[BYTE2(v248) + 768]
        ^ v243;
    v24 = dword_ED944[BYTE1(v335) + 512]
        ^ dword_ED944[(unsigned __int8)v248]
        ^ dword_ED944[HIBYTE(v338) + 256]
        ^ (v244 + 1)
        ^ dword_ED944[BYTE2(v336) + 768];
    v25 = dword_ED944[(unsigned __int8)v338]
        ^ dword_ED944[HIBYTE(v336) + 256]
        ^ dword_ED944[BYTE1(v248) + 512]
        ^ dword_ED944[BYTE2(v335) + 768]
        ^ v245;
    v26 = dword_ED944[(unsigned __int8)v22] ^ dword_ED944[HIBYTE(v24) + 256] ^ dword_ED944[BYTE1(v23) + 512];
    v27 = dword_ED944[HIBYTE(v23) + 256] ^ dword_ED944[(unsigned __int8)v25] ^ dword_ED944[BYTE1(v24) + 512];
    v28 = dword_ED944[(unsigned __int8)v23] ^ dword_ED944[HIBYTE(v22) + 256] ^ dword_ED944[BYTE2(v24) + 768];
    v29 = dword_ED944[HIBYTE(v25) + 256]
        ^ dword_ED944[(unsigned __int8)v24]
        ^ dword_ED944[BYTE1(v22) + 512]
        ^ dword_ED944[BYTE2(v23) + 768];
    v337 = v28 ^ dword_ED944[BYTE1(v25) + 512];
    v332 = v29;
    v334 = v26 ^ dword_ED944[BYTE2(v25) + 768];
    v339 = v27 ^ dword_ED944[BYTE2(v22) + 768];
    if ( v244 == -2 && !++v242 )
    {
      v241 = v243 + 1;
      v240 = v243 == -1;
      if ( v243 == -1 )
        v29 = v245;
      ++v243;
      if ( v240 )
      {
        v242 = v241;
        v245 = v29 + 1;
      }
    }
    v30 = dword_ED944[(unsigned __int8)v340]
        ^ dword_ED944[HIBYTE(v252) + 256]
        ^ dword_ED944[BYTE1(v342) + 512]
        ^ dword_ED944[BYTE2(v250) + 768]
        ^ v243;
    v31 = dword_ED944[(unsigned __int8)v252]
        ^ dword_ED944[HIBYTE(v250) + 256]
        ^ dword_ED944[BYTE1(v340) + 512]
        ^ dword_ED944[BYTE2(v342) + 768]
        ^ v242;
    v32 = dword_ED944[(unsigned __int8)v250]
        ^ dword_ED944[HIBYTE(v342) + 256]
        ^ (v244 + 2)
        ^ dword_ED944[BYTE1(v252) + 512]
        ^ dword_ED944[BYTE2(v340) + 768];
    v33 = dword_ED944[(unsigned __int8)v342]
        ^ dword_ED944[HIBYTE(v340) + 256]
        ^ dword_ED944[BYTE1(v250) + 512]
        ^ dword_ED944[BYTE2(v252) + 768]
        ^ v245;
    v34 = dword_ED944[(unsigned __int8)v33] ^ dword_ED944[HIBYTE(v30) + 256] ^ dword_ED944[BYTE1(v32) + 512];
    v35 = dword_ED944[(unsigned __int8)v30] ^ dword_ED944[HIBYTE(v31) + 256] ^ dword_ED944[BYTE2(v32) + 768];
    v283 = dword_ED944[HIBYTE(v33) + 256]
         ^ dword_ED944[(unsigned __int8)v32]
         ^ dword_ED944[BYTE1(v31) + 512]
         ^ dword_ED944[BYTE2(v30) + 768];
    v36 = dword_ED944[(unsigned __int8)v31]
        ^ dword_ED944[HIBYTE(v32) + 256]
        ^ dword_ED944[BYTE1(v30) + 512]
        ^ dword_ED944[BYTE2(v33) + 768];
    v285 = v35 ^ dword_ED944[BYTE1(v33) + 512];
    v284 = v36;
    v286 = v34 ^ dword_ED944[BYTE2(v31) + 768];
    if ( v244 == -3 && !++v242 )
    {
      v239 = v243 + 1;
      v238 = v243 == -1;
      if ( v243 == -1 )
        v36 = v245;
      ++v243;
      if ( v238 )
      {
        v242 = v239;
        v245 = v36 + 1;
      }
    }
    v37 = dword_ED944[BYTE1(v301) + 512]
        ^ dword_ED944[HIBYTE(v344) + 256]
        ^ dword_ED944[(unsigned __int8)v345]
        ^ dword_ED944[BYTE2(v254) + 768]
        ^ v243;
    v38 = dword_ED944[HIBYTE(v254) + 256]
        ^ dword_ED944[(unsigned __int8)v344]
        ^ dword_ED944[BYTE1(v345) + 512]
        ^ dword_ED944[BYTE2(v301) + 768]
        ^ v242;
    v39 = dword_ED944[BYTE2(v344) + 768]
        ^ dword_ED944[(unsigned __int8)v301]
        ^ dword_ED944[HIBYTE(v345) + 256]
        ^ dword_ED944[BYTE1(v254) + 512]
        ^ v245;
    v40 = dword_ED944[(unsigned __int8)v254]
        ^ dword_ED944[HIBYTE(v301) + 256]
        ^ (v244 + 3)
        ^ dword_ED944[BYTE1(v344) + 512]
        ^ dword_ED944[BYTE2(v345) + 768];
    v41 = dword_ED944[(unsigned __int8)v38] ^ dword_ED944[HIBYTE(v40) + 256] ^ dword_ED944[BYTE1(v37) + 512];
    v42 = dword_ED944[(unsigned __int8)v37] ^ dword_ED944[HIBYTE(v38) + 256] ^ dword_ED944[BYTE2(v40) + 768];
    v43 = dword_ED944[HIBYTE(v37) + 256] ^ dword_ED944[(unsigned __int8)v39] ^ dword_ED944[BYTE1(v40) + 512];
    v44 = dword_ED944[HIBYTE(v39) + 256]
        ^ dword_ED944[(unsigned __int8)v40]
        ^ dword_ED944[BYTE1(v38) + 512]
        ^ dword_ED944[BYTE2(v37) + 768];
    v385 = v42 ^ dword_ED944[BYTE1(v39) + 512];
    v305 = v41 ^ dword_ED944[BYTE2(v39) + 768];
    v343 = v44;
    v287 = v43 ^ dword_ED944[BYTE2(v38) + 768];
    if ( v244 == -4 && !++v242 )
    {
      v237 = v243 + 1;
      v236 = v243 == -1;
      if ( v243 == -1 )
        v44 = v245;
      ++v243;
      if ( v236 )
      {
        v242 = v237;
        v245 = v44 + 1;
      }
    }
    v45 = dword_ED944[BYTE1(v306) + 512]
        ^ dword_ED944[(unsigned __int8)v256]
        ^ dword_ED944[HIBYTE(v310) + 256]
        ^ (v244 + 4)
        ^ dword_ED944[BYTE2(v308) + 768];
    v46 = dword_ED944[(unsigned __int8)v310]
        ^ dword_ED944[HIBYTE(v308) + 256]
        ^ dword_ED944[BYTE1(v256) + 512]
        ^ dword_ED944[BYTE2(v306) + 768]
        ^ v245;
    v47 = dword_ED944[HIBYTE(v306) + 256]
        ^ dword_ED944[(unsigned __int8)v308]
        ^ dword_ED944[BYTE1(v310) + 512]
        ^ dword_ED944[BYTE2(v256) + 768]
        ^ v243;
    v48 = dword_ED944[(unsigned __int8)v306]
        ^ dword_ED944[HIBYTE(v256) + 256]
        ^ dword_ED944[BYTE1(v308) + 512]
        ^ dword_ED944[BYTE2(v310) + 768]
        ^ v242;
    v49 = dword_ED944[HIBYTE(v47) + 256] ^ dword_ED944[(unsigned __int8)v46] ^ dword_ED944[BYTE1(v45) + 512];
    v309 = dword_ED944[(unsigned __int8)v47]
         ^ dword_ED944[HIBYTE(v48) + 256]
         ^ dword_ED944[BYTE2(v45) + 768]
         ^ dword_ED944[BYTE1(v46) + 512];
    v257 = dword_ED944[HIBYTE(v46) + 256]
         ^ dword_ED944[(unsigned __int8)v45]
         ^ dword_ED944[BYTE1(v48) + 512]
         ^ dword_ED944[BYTE2(v47) + 768];
    v307 = dword_ED944[(unsigned __int8)v48]
         ^ dword_ED944[HIBYTE(v45) + 256]
         ^ dword_ED944[BYTE1(v47) + 512]
         ^ dword_ED944[BYTE2(v46) + 768];
    v311 = v49 ^ dword_ED944[BYTE2(v48) + 768];
    if ( v244 == -5 && !++v242 )
    {
      v51 = v243 + 1;
      v50 = v243 == -1;
      if ( v243 == -1 )
        v49 = v245;
      ++v243;
      if ( v50 )
      {
        v242 = v51;
        v245 = v49 + 1;
      }
    }
    v52 = dword_ED944[BYTE1(v349) + 512]
        ^ dword_ED944[HIBYTE(v258) + 256]
        ^ dword_ED944[(unsigned __int8)v347]
        ^ dword_ED944[BYTE2(v351) + 768]
        ^ v242;
    v53 = dword_ED944[BYTE1(v347) + 512]
        ^ dword_ED944[(unsigned __int8)v258]
        ^ dword_ED944[HIBYTE(v351) + 256]
        ^ (v244 + 5)
        ^ dword_ED944[BYTE2(v349) + 768];
    v54 = dword_ED944[(unsigned __int8)v351]
        ^ dword_ED944[HIBYTE(v349) + 256]
        ^ dword_ED944[BYTE1(v258) + 512]
        ^ dword_ED944[BYTE2(v347) + 768]
        ^ v245;
    v55 = dword_ED944[(unsigned __int8)v349]
        ^ dword_ED944[HIBYTE(v347) + 256]
        ^ dword_ED944[BYTE1(v351) + 512]
        ^ dword_ED944[BYTE2(v258) + 768]
        ^ v243;
    v56 = dword_ED944[BYTE1(v55) + 512];
    v302 = dword_ED944[(unsigned __int8)v52] ^ dword_ED944[HIBYTE(v53) + 256] ^ v56 ^ dword_ED944[BYTE2(v54) + 768];
    v330 = dword_ED944[(unsigned __int8)v55]
         ^ dword_ED944[HIBYTE(v52) + 256]
         ^ dword_ED944[BYTE2(v53) + 768]
         ^ dword_ED944[BYTE1(v54) + 512];
    v255 = dword_ED944[HIBYTE(v54) + 256]
         ^ dword_ED944[(unsigned __int8)v53]
         ^ dword_ED944[BYTE1(v52) + 512]
         ^ dword_ED944[BYTE2(v55) + 768];
    v247 = dword_ED944[HIBYTE(v55) + 256]
         ^ dword_ED944[(unsigned __int8)v54]
         ^ dword_ED944[BYTE1(v53) + 512]
         ^ dword_ED944[BYTE2(v52) + 768];
    if ( v244 == -6 && !++v242 )
    {
      v58 = v243 + 1;
      v57 = v243 == -1;
      if ( v243 == -1 )
        v56 = v245;
      ++v243;
      if ( v57 )
      {
        v242 = v58;
        v245 = v56 + 1;
      }
    }
    v59 = dword_ED944[BYTE1(v353) + 512]
        ^ dword_ED944[(unsigned __int8)v260]
        ^ dword_ED944[HIBYTE(v357) + 256]
        ^ (v244 + 6)
        ^ dword_ED944[BYTE2(v355) + 768];
    v60 = dword_ED944[(unsigned __int8)v357]
        ^ dword_ED944[HIBYTE(v355) + 256]
        ^ dword_ED944[BYTE1(v260) + 512]
        ^ dword_ED944[BYTE2(v353) + 768]
        ^ v245;
    v61 = dword_ED944[HIBYTE(v353) + 256]
        ^ dword_ED944[(unsigned __int8)v355]
        ^ dword_ED944[BYTE1(v357) + 512]
        ^ dword_ED944[BYTE2(v260) + 768]
        ^ v243;
    v62 = dword_ED944[HIBYTE(v260) + 256]
        ^ dword_ED944[(unsigned __int8)v353]
        ^ dword_ED944[BYTE1(v355) + 512]
        ^ dword_ED944[BYTE2(v357) + 768]
        ^ v242;
    v63 = dword_ED944[HIBYTE(v61) + 256] ^ dword_ED944[(unsigned __int8)v60] ^ dword_ED944[BYTE1(v59) + 512];
    v290 = dword_ED944[(unsigned __int8)v61]
         ^ dword_ED944[HIBYTE(v62) + 256]
         ^ dword_ED944[BYTE2(v59) + 768]
         ^ dword_ED944[BYTE1(v60) + 512];
    v288 = dword_ED944[HIBYTE(v60) + 256]
         ^ dword_ED944[(unsigned __int8)v59]
         ^ dword_ED944[BYTE1(v62) + 512]
         ^ dword_ED944[BYTE2(v61) + 768];
    v289 = dword_ED944[(unsigned __int8)v62]
         ^ dword_ED944[HIBYTE(v59) + 256]
         ^ dword_ED944[BYTE1(v61) + 512]
         ^ dword_ED944[BYTE2(v60) + 768];
    v291 = v63 ^ dword_ED944[BYTE2(v62) + 768];
    if ( v244 == -7 && !++v242 )
    {
      v65 = v243 + 1;
      v64 = v243 == -1;
      if ( v243 == -1 )
        v63 = v245;
      ++v243;
      if ( v64 )
      {
        v242 = v65;
        v245 = v63 + 1;
      }
    }
    v66 = dword_ED944[BYTE1(v359) + 512]
        ^ dword_ED944[(unsigned __int8)v262]
        ^ dword_ED944[HIBYTE(v361) + 256]
        ^ (v244 + 7)
        ^ dword_ED944[BYTE2(v360) + 768];
    v67 = dword_ED944[(unsigned __int8)v361]
        ^ dword_ED944[HIBYTE(v360) + 256]
        ^ dword_ED944[BYTE1(v262) + 512]
        ^ dword_ED944[BYTE2(v359) + 768]
        ^ v245;
    v68 = dword_ED944[HIBYTE(v359) + 256]
        ^ dword_ED944[(unsigned __int8)v360]
        ^ dword_ED944[BYTE1(v361) + 512]
        ^ dword_ED944[BYTE2(v262) + 768]
        ^ v243;
    v69 = dword_ED944[HIBYTE(v262) + 256]
        ^ dword_ED944[(unsigned __int8)v359]
        ^ dword_ED944[BYTE1(v360) + 512]
        ^ dword_ED944[BYTE2(v361) + 768]
        ^ v242;
    v70 = dword_ED944[BYTE1(v67) + 512];
    v312 = dword_ED944[HIBYTE(v67) + 256]
         ^ dword_ED944[(unsigned __int8)v66]
         ^ dword_ED944[BYTE1(v69) + 512]
         ^ dword_ED944[BYTE2(v68) + 768];
    v314 = dword_ED944[(unsigned __int8)v68] ^ dword_ED944[HIBYTE(v69) + 256] ^ dword_ED944[BYTE2(v66) + 768] ^ v70;
    v313 = dword_ED944[(unsigned __int8)v69]
         ^ dword_ED944[HIBYTE(v66) + 256]
         ^ dword_ED944[BYTE1(v68) + 512]
         ^ dword_ED944[BYTE2(v67) + 768];
    v315 = dword_ED944[BYTE1(v66) + 512]
         ^ dword_ED944[HIBYTE(v68) + 256]
         ^ dword_ED944[(unsigned __int8)v67]
         ^ dword_ED944[BYTE2(v69) + 768];
    if ( v244 == -8 && !++v242 )
    {
      v72 = v243 + 1;
      v71 = v243 == -1;
      if ( v243 == -1 )
        v70 = v245;
      ++v243;
      if ( v71 )
      {
        v242 = v72;
        v245 = v70 + 1;
      }
    }
    v73 = dword_ED944[(unsigned __int8)v323]
        ^ dword_ED944[HIBYTE(v321) + 256]
        ^ dword_ED944[BYTE1(v264) + 512]
        ^ dword_ED944[BYTE2(v363) + 768]
        ^ v245;
    v74 = dword_ED944[BYTE1(v363) + 512]
        ^ dword_ED944[(unsigned __int8)v264]
        ^ dword_ED944[HIBYTE(v323) + 256]
        ^ (v244 + 8)
        ^ dword_ED944[BYTE2(v321) + 768];
    v75 = dword_ED944[HIBYTE(v264) + 256]
        ^ dword_ED944[(unsigned __int8)v363]
        ^ dword_ED944[BYTE1(v321) + 512]
        ^ dword_ED944[BYTE2(v323) + 768]
        ^ v242;
    v76 = dword_ED944[(unsigned __int8)v321]
        ^ dword_ED944[HIBYTE(v363) + 256]
        ^ dword_ED944[BYTE1(v323) + 512]
        ^ dword_ED944[BYTE2(v264) + 768]
        ^ v243;
    v77 = dword_ED944[BYTE1(v75) + 512];
    v386 = dword_ED944[(unsigned __int8)v76]
         ^ dword_ED944[HIBYTE(v75) + 256]
         ^ dword_ED944[BYTE2(v74) + 768]
         ^ dword_ED944[BYTE1(v73) + 512];
    v358 = dword_ED944[HIBYTE(v73) + 256] ^ dword_ED944[(unsigned __int8)v74] ^ v77 ^ dword_ED944[BYTE2(v76) + 768];
    v364 = dword_ED944[(unsigned __int8)v75]
         ^ dword_ED944[HIBYTE(v74) + 256]
         ^ dword_ED944[BYTE1(v76) + 512]
         ^ dword_ED944[BYTE2(v73) + 768];
    v387 = dword_ED944[HIBYTE(v76) + 256]
         ^ dword_ED944[(unsigned __int8)v73]
         ^ dword_ED944[BYTE1(v74) + 512]
         ^ dword_ED944[BYTE2(v75) + 768];
    if ( v244 == -9 && !++v242 )
    {
      v79 = v243 + 1;
      v78 = v243 == -1;
      if ( v243 == -1 )
        v77 = v245;
      ++v243;
      if ( v78 )
      {
        v242 = v79;
        v245 = v77 + 1;
      }
    }
    v80 = dword_ED944[(unsigned __int8)v365]
        ^ dword_ED944[HIBYTE(v266) + 256]
        ^ dword_ED944[BYTE1(v367) + 512]
        ^ dword_ED944[BYTE2(v369) + 768]
        ^ v242;
    v81 = dword_ED944[(unsigned __int8)v369]
        ^ dword_ED944[HIBYTE(v367) + 256]
        ^ dword_ED944[BYTE1(v266) + 512]
        ^ dword_ED944[BYTE2(v365) + 768]
        ^ v245;
    v82 = dword_ED944[(unsigned __int8)v266]
        ^ dword_ED944[HIBYTE(v369) + 256]
        ^ (v244 + 9)
        ^ dword_ED944[BYTE1(v365) + 512]
        ^ dword_ED944[BYTE2(v367) + 768];
    v83 = dword_ED944[(unsigned __int8)v367]
        ^ dword_ED944[HIBYTE(v365) + 256]
        ^ dword_ED944[BYTE1(v369) + 512]
        ^ dword_ED944[BYTE2(v266) + 768]
        ^ v243;
    v84 = dword_ED944[BYTE1(v83) + 512] ^ dword_ED944[(unsigned __int8)v80] ^ dword_ED944[HIBYTE(v82) + 256];
    v249 = dword_ED944[HIBYTE(v81) + 256]
         ^ dword_ED944[(unsigned __int8)v82]
         ^ dword_ED944[BYTE1(v80) + 512]
         ^ dword_ED944[BYTE2(v83) + 768];
    v322 = dword_ED944[(unsigned __int8)v83]
         ^ dword_ED944[HIBYTE(v80) + 256]
         ^ dword_ED944[BYTE2(v82) + 768]
         ^ dword_ED944[BYTE1(v81) + 512];
    v251 = v84 ^ dword_ED944[BYTE2(v81) + 768];
    v324 = dword_ED944[HIBYTE(v83) + 256]
         ^ dword_ED944[(unsigned __int8)v81]
         ^ dword_ED944[BYTE1(v82) + 512]
         ^ dword_ED944[BYTE2(v80) + 768];
    if ( v244 == -10 && !++v242 )
    {
      v86 = v243 + 1;
      v85 = v243 == -1;
      if ( v243 == -1 )
        v84 = v245;
      ++v243;
      if ( v85 )
      {
        v242 = v86;
        v245 = v84 + 1;
      }
    }
    v87 = dword_ED944[BYTE1(v371) + 512]
        ^ dword_ED944[(unsigned __int8)v268]
        ^ dword_ED944[HIBYTE(v373) + 256]
        ^ (v244 + 10)
        ^ dword_ED944[BYTE2(v372) + 768];
    v88 = dword_ED944[(unsigned __int8)v373]
        ^ dword_ED944[HIBYTE(v372) + 256]
        ^ dword_ED944[BYTE1(v268) + 512]
        ^ dword_ED944[BYTE2(v371) + 768]
        ^ v245;
    v89 = dword_ED944[HIBYTE(v268) + 256]
        ^ dword_ED944[(unsigned __int8)v371]
        ^ dword_ED944[BYTE1(v372) + 512]
        ^ dword_ED944[BYTE2(v373) + 768]
        ^ v242;
    v90 = dword_ED944[(unsigned __int8)v372]
        ^ dword_ED944[HIBYTE(v371) + 256]
        ^ dword_ED944[BYTE1(v373) + 512]
        ^ dword_ED944[BYTE2(v268) + 768]
        ^ v243;
    v91 = dword_ED944[HIBYTE(v88) + 256] ^ dword_ED944[(unsigned __int8)v87] ^ dword_ED944[BYTE1(v89) + 512];
    v259 = dword_ED944[(unsigned __int8)v89]
         ^ dword_ED944[HIBYTE(v87) + 256]
         ^ dword_ED944[BYTE1(v90) + 512]
         ^ dword_ED944[BYTE2(v88) + 768];
    v261 = dword_ED944[(unsigned __int8)v90]
         ^ dword_ED944[HIBYTE(v89) + 256]
         ^ dword_ED944[BYTE2(v87) + 768]
         ^ dword_ED944[BYTE1(v88) + 512];
    v253 = v91 ^ dword_ED944[BYTE2(v90) + 768];
    v263 = dword_ED944[HIBYTE(v90) + 256]
         ^ dword_ED944[(unsigned __int8)v88]
         ^ dword_ED944[BYTE1(v87) + 512]
         ^ dword_ED944[BYTE2(v89) + 768];
    if ( v244 == -11 && !++v242 )
    {
      v93 = v243 + 1;
      v92 = v243 == -1;
      if ( v243 == -1 )
        v91 = v245;
      ++v243;
      if ( v92 )
      {
        v242 = v93;
        v245 = v91 + 1;
      }
    }
    v94 = dword_ED944[BYTE1(v374) + 512]
        ^ dword_ED944[(unsigned __int8)v270]
        ^ dword_ED944[HIBYTE(v376) + 256]
        ^ (v244 + 11)
        ^ dword_ED944[BYTE2(v375) + 768];
    v95 = dword_ED944[(unsigned __int8)v376]
        ^ dword_ED944[HIBYTE(v375) + 256]
        ^ dword_ED944[BYTE1(v270) + 512]
        ^ dword_ED944[BYTE2(v374) + 768]
        ^ v245;
    v96 = dword_ED944[HIBYTE(v374) + 256]
        ^ dword_ED944[(unsigned __int8)v375]
        ^ dword_ED944[BYTE1(v376) + 512]
        ^ dword_ED944[BYTE2(v270) + 768]
        ^ v243;
    v97 = dword_ED944[HIBYTE(v270) + 256]
        ^ dword_ED944[(unsigned __int8)v374]
        ^ dword_ED944[BYTE1(v375) + 512]
        ^ dword_ED944[BYTE2(v376) + 768]
        ^ v242;
    v98 = dword_ED944[HIBYTE(v96) + 256] ^ dword_ED944[(unsigned __int8)v95] ^ dword_ED944[BYTE1(v94) + 512];
    v294 = dword_ED944[(unsigned __int8)v96]
         ^ dword_ED944[HIBYTE(v97) + 256]
         ^ dword_ED944[BYTE2(v94) + 768]
         ^ dword_ED944[BYTE1(v95) + 512];
    v292 = dword_ED944[HIBYTE(v95) + 256]
         ^ dword_ED944[(unsigned __int8)v94]
         ^ dword_ED944[BYTE1(v97) + 512]
         ^ dword_ED944[BYTE2(v96) + 768];
    v293 = dword_ED944[(unsigned __int8)v97]
         ^ dword_ED944[HIBYTE(v94) + 256]
         ^ dword_ED944[BYTE1(v96) + 512]
         ^ dword_ED944[BYTE2(v95) + 768];
    v295 = v98 ^ dword_ED944[BYTE2(v97) + 768];
    if ( v244 == -12 && !++v242 )
    {
      v100 = v243 + 1;
      v99 = v243 == -1;
      if ( v243 == -1 )
        v98 = v245;
      ++v243;
      if ( v99 )
      {
        v242 = v100;
        v245 = v98 + 1;
      }
    }
    v101 = dword_ED944[BYTE1(v316) + 512]
         ^ dword_ED944[(unsigned __int8)v272]
         ^ dword_ED944[HIBYTE(v318) + 256]
         ^ (v244 + 12)
         ^ dword_ED944[BYTE2(v296) + 768];
    v102 = dword_ED944[(unsigned __int8)v318]
         ^ dword_ED944[HIBYTE(v296) + 256]
         ^ dword_ED944[BYTE1(v272) + 512]
         ^ dword_ED944[BYTE2(v316) + 768]
         ^ v245;
    v103 = dword_ED944[HIBYTE(v316) + 256]
         ^ dword_ED944[(unsigned __int8)v296]
         ^ dword_ED944[BYTE1(v318) + 512]
         ^ dword_ED944[BYTE2(v272) + 768]
         ^ v243;
    v104 = dword_ED944[HIBYTE(v272) + 256]
         ^ dword_ED944[(unsigned __int8)v316]
         ^ dword_ED944[BYTE1(v296) + 512]
         ^ dword_ED944[BYTE2(v318) + 768]
         ^ v242;
    v105 = dword_ED944[HIBYTE(v103) + 256] ^ dword_ED944[(unsigned __int8)v102] ^ dword_ED944[BYTE1(v101) + 512];
    v319 = dword_ED944[(unsigned __int8)v103]
         ^ dword_ED944[HIBYTE(v104) + 256]
         ^ dword_ED944[BYTE2(v101) + 768]
         ^ dword_ED944[BYTE1(v102) + 512];
    v273 = dword_ED944[HIBYTE(v102) + 256]
         ^ dword_ED944[(unsigned __int8)v101]
         ^ dword_ED944[BYTE1(v104) + 512]
         ^ dword_ED944[BYTE2(v103) + 768];
    v317 = dword_ED944[(unsigned __int8)v104]
         ^ dword_ED944[HIBYTE(v101) + 256]
         ^ dword_ED944[BYTE1(v103) + 512]
         ^ dword_ED944[BYTE2(v102) + 768];
    v320 = v105 ^ dword_ED944[BYTE2(v104) + 768];
    if ( v244 == -13 && !++v242 )
    {
      v107 = v243 + 1;
      v106 = v243 == -1;
      if ( v243 == -1 )
        v105 = v245;
      ++v243;
      if ( v106 )
      {
        v242 = v107;
        v245 = v105 + 1;
      }
    }
    v108 = dword_ED944[BYTE1(v325) + 512]
         ^ dword_ED944[(unsigned __int8)v274]
         ^ dword_ED944[HIBYTE(v377) + 256]
         ^ (v244 + 13)
         ^ dword_ED944[BYTE2(v327) + 768];
    v109 = dword_ED944[(unsigned __int8)v377]
         ^ dword_ED944[HIBYTE(v327) + 256]
         ^ dword_ED944[BYTE1(v274) + 512]
         ^ dword_ED944[BYTE2(v325) + 768]
         ^ v245;
    v110 = dword_ED944[HIBYTE(v325) + 256]
         ^ dword_ED944[(unsigned __int8)v327]
         ^ dword_ED944[BYTE1(v377) + 512]
         ^ dword_ED944[BYTE2(v274) + 768]
         ^ v243;
    v111 = dword_ED944[HIBYTE(v274) + 256]
         ^ dword_ED944[(unsigned __int8)v325]
         ^ dword_ED944[BYTE1(v327) + 512]
         ^ dword_ED944[BYTE2(v377) + 768]
         ^ v242;
    v112 = dword_ED944[HIBYTE(v110) + 256] ^ dword_ED944[(unsigned __int8)v109] ^ dword_ED944[BYTE1(v108) + 512];
    v366 = dword_ED944[(unsigned __int8)v111]
         ^ dword_ED944[HIBYTE(v108) + 256]
         ^ dword_ED944[BYTE1(v110) + 512]
         ^ dword_ED944[BYTE2(v109) + 768];
    v362 = dword_ED944[HIBYTE(v109) + 256]
         ^ dword_ED944[(unsigned __int8)v108]
         ^ dword_ED944[BYTE1(v111) + 512]
         ^ dword_ED944[BYTE2(v110) + 768];
    v368 = dword_ED944[(unsigned __int8)v110]
         ^ dword_ED944[HIBYTE(v111) + 256]
         ^ dword_ED944[BYTE2(v108) + 768]
         ^ dword_ED944[BYTE1(v109) + 512];
    v370 = v112 ^ dword_ED944[BYTE2(v111) + 768];
    if ( v244 == -14 && !++v242 )
    {
      v114 = v243 + 1;
      v113 = v243 == -1;
      if ( v243 == -1 )
        v112 = v245;
      ++v243;
      if ( v113 )
      {
        v242 = v114;
        v245 = v112 + 1;
      }
    }
    v115 = dword_ED944[BYTE1(v379) + 512]
         ^ dword_ED944[(unsigned __int8)v277]
         ^ dword_ED944[HIBYTE(v381) + 256]
         ^ (v244 + 14)
         ^ dword_ED944[BYTE2(v380) + 768];
    v116 = dword_ED944[(unsigned __int8)v381]
         ^ dword_ED944[HIBYTE(v380) + 256]
         ^ dword_ED944[BYTE1(v277) + 512]
         ^ dword_ED944[BYTE2(v379) + 768]
         ^ v245;
    v117 = dword_ED944[HIBYTE(v379) + 256]
         ^ dword_ED944[(unsigned __int8)v380]
         ^ dword_ED944[BYTE1(v381) + 512]
         ^ dword_ED944[BYTE2(v277) + 768]
         ^ v243;
    v118 = dword_ED944[HIBYTE(v277) + 256]
         ^ dword_ED944[(unsigned __int8)v379]
         ^ dword_ED944[BYTE1(v380) + 512]
         ^ dword_ED944[BYTE2(v381) + 768]
         ^ v242;
    v119 = dword_ED944[(unsigned __int8)v118] ^ dword_ED944[HIBYTE(v115) + 256] ^ dword_ED944[BYTE1(v117) + 512];
    v120 = dword_ED944[HIBYTE(v117) + 256] ^ dword_ED944[(unsigned __int8)v116] ^ dword_ED944[BYTE1(v115) + 512];
    v121 = dword_ED944[BYTE2(v118) + 768];
    v122 = dword_ED944[(unsigned __int8)v117] ^ dword_ED944[HIBYTE(v118) + 256] ^ dword_ED944[BYTE2(v115) + 768];
    v123 = dword_ED944[HIBYTE(v116) + 256] ^ dword_ED944[(unsigned __int8)v115] ^ dword_ED944[BYTE1(v118) + 512];
    v124 = v244 + 15;
    v269 = v122 ^ dword_ED944[BYTE1(v116) + 512];
    v265 = v123 ^ dword_ED944[BYTE2(v117) + 768];
    v267 = v119 ^ dword_ED944[BYTE2(v116) + 768];
    v271 = v120 ^ v121;
    if ( v244 == -15 && !++v242 )
    {
      v126 = v243 + 1;
      v125 = v243 == -1;
      if ( v243 == -1 )
        v120 = v245;
      ++v243;
      if ( v125 )
      {
        v242 = v126;
        v245 = v120 + 1;
      }
    }
    v50 = v244 == -16;
    v244 += 16;
    v127 = dword_ED944[(unsigned __int8)v278]
         ^ dword_ED944[HIBYTE(v384) + 256]
         ^ v124
         ^ dword_ED944[BYTE1(v382) + 512]
         ^ dword_ED944[BYTE2(v383) + 768];
    v128 = dword_ED944[BYTE1(v383) + 512]
         ^ dword_ED944[HIBYTE(v278) + 256]
         ^ dword_ED944[(unsigned __int8)v382]
         ^ dword_ED944[BYTE2(v384) + 768]
         ^ v242;
    v129 = dword_ED944[HIBYTE(v383) + 256]
         ^ dword_ED944[(unsigned __int8)v384]
         ^ dword_ED944[BYTE1(v278) + 512]
         ^ dword_ED944[BYTE2(v382) + 768]
         ^ v245;
    v130 = dword_ED944[HIBYTE(v382) + 256]
         ^ dword_ED944[(unsigned __int8)v383]
         ^ dword_ED944[BYTE1(v384) + 512]
         ^ dword_ED944[BYTE2(v278) + 768]
         ^ v243;
    v131 = dword_ED944[(unsigned __int8)v129] ^ dword_ED944[HIBYTE(v130) + 256] ^ dword_ED944[BYTE1(v127) + 512];
    v132 = dword_ED944[HIBYTE(v129) + 256]
         ^ dword_ED944[(unsigned __int8)v127]
         ^ dword_ED944[BYTE1(v128) + 512]
         ^ dword_ED944[BYTE2(v130) + 768];
    v297 = dword_ED944[HIBYTE(v128) + 256]
         ^ dword_ED944[(unsigned __int8)v130]
         ^ dword_ED944[BYTE2(v127) + 768]
         ^ dword_ED944[BYTE1(v129) + 512];
    v133 = dword_ED944[BYTE1(v130) + 512]
         ^ dword_ED944[HIBYTE(v127) + 256]
         ^ dword_ED944[(unsigned __int8)v128]
         ^ dword_ED944[BYTE2(v129) + 768];
    v341 = v131 ^ dword_ED944[BYTE2(v128) + 768];
    if ( v50 && !++v242 )
    {
      v135 = v243 + 1;
      v134 = v243 == -1;
      if ( v243 == -1 )
        v131 = v245;
      ++v243;
      if ( v134 )
      {
        v242 = v135;
        v245 = v131 + 1;
      }
    }
    v136 = v302;
    v275 = v281 ^ v302;
    v137 = v299 ^ v330;
    v138 = v281 ^ v302;
    v303 = v330 ^ v261;
    v139 = v136 ^ v259;
    v346 = v304 ^ v247;
    v140 = (27 * (((v279 ^ (unsigned int)v255) >> 7) & 0x1010101)) ^ (2 * (v279 ^ v255)) & 0xFEFEFEFE;
    v348 = v247 ^ v263;
    v350 = v257 ^ v249;
    v352 = v249 ^ v265;
    v354 = v307 ^ v251;
    v356 = v251 ^ v267;
    v141 = v279 ^ v255 ^ v132;
    v246 = v140 ^ v255 ^ v253 ^ v132;
    v142 = ((v299 ^ (unsigned int)v330) >> 7) & 0x1010101;
    v143 = (2 * (v255 ^ v253)) & 0xFEFEFEFE ^ (27 * (((v255 ^ (unsigned int)v253) >> 7) & 0x1010101));
    v248 = v143 ^ v279 ^ v253 ^ v132;
    v144 = (2 * (v253 ^ v132)) & 0xFEFEFEFE ^ (27 * (((v253 ^ (unsigned int)v132) >> 7) & 0x1010101));
    v254 = v279 ^ v255 ^ v140 ^ v253 ^ v143 ^ v144;
    v250 = v141 ^ v144;
    v145 = (27 * ((v138 >> 7) & 0x1010101)) ^ (2 * v275) & 0xFEFEFEFE;
    v146 = v275 ^ v133;
    v329 = v145 ^ v139 ^ v133;
    v147 = (2 * v139) & 0xFEFEFEFE ^ (27 * ((v139 >> 7) & 0x1010101));
    v148 = v275 ^ v145 ^ v259 ^ v147;
    v276 = v332 ^ v288;
    v378 = v332 ^ v273;
    v335 = v147 ^ v281 ^ v259 ^ v133;
    v149 = (2 * (v259 ^ v133)) & 0xFEFEFEFE ^ (27 * (((v259 ^ (unsigned int)v133) >> 7) & 0x1010101));
    v344 = v148 ^ v149;
    v326 = v334 ^ v289;
    v252 = v146 ^ v149;
    v280 = v334 ^ v317;
    v150 = (27 * v142) ^ (2 * v137) & 0xFEFEFEFE;
    v151 = (2 * v303) & 0xFEFEFEFE ^ (27 * ((v303 >> 7) & 0x1010101));
    v152 = v337;
    v153 = v137 ^ v150 ^ v261 ^ v151;
    v331 = v150 ^ v303 ^ v297;
    v154 = v346;
    v155 = v337 ^ v290;
    v336 = v151 ^ v299 ^ v261 ^ v297;
    v328 = v155;
    v156 = (v346 >> 7) & 0x1010101;
    v157 = (27 * (((v261 ^ (unsigned int)v297) >> 7) & 0x1010101)) ^ (2 * (v261 ^ v297)) & 0xFEFEFEFE;
    v158 = v137 ^ v297 ^ v157;
    v298 = v152 ^ v319;
    v345 = v153 ^ v157;
    v159 = v341;
    v340 = v158;
    v160 = (27 * v156) ^ (2 * v154) & 0xFEFEFEFE;
    v161 = v159 ^ v154;
    v333 = v160 ^ v348 ^ v159;
    v162 = (2 * v348) & 0xFEFEFEFE ^ (27 * ((v348 >> 7) & 0x1010101));
    v282 = v339 ^ v320;
    v163 = v162 ^ v304 ^ v263 ^ v159;
    v300 = v339 ^ v291;
    v164 = (2 * (v263 ^ v159)) & 0xFEFEFEFE ^ (27 * (((v263 ^ (unsigned int)v159) >> 7) & 0x1010101));
    v165 = v343;
    v338 = v163;
    v166 = v343 ^ v265;
    v301 = v154 ^ v160 ^ v263 ^ v162 ^ v164;
    v167 = v257 ^ v343 ^ v265;
    v342 = v161 ^ v164;
    v168 = (27 * ((v350 >> 7) & 0x1010101)) ^ (2 * v350) & 0xFEFEFEFE;
    v169 = v350 ^ v168;
    v256 = v165 ^ v168 ^ v352;
    v170 = (2 * v352) & 0xFEFEFEFE ^ (27 * ((v352 >> 7) & 0x1010101));
    v258 = v167 ^ v170;
    v171 = (2 * v166) & 0xFEFEFEFE ^ (27 * ((v166 >> 7) & 0x1010101));
    v260 = v165 ^ v350 ^ v171;
    v262 = v169 ^ v265 ^ v170 ^ v171;
    v172 = (27 * ((v354 >> 7) & 0x1010101)) ^ (2 * v354) & 0xFEFEFEFE;
    v173 = v307 ^ v305 ^ v267;
    v306 = v305 ^ v172 ^ v356;
    v174 = (2 * v356) & 0xFEFEFEFE ^ (27 * ((v356 >> 7) & 0x1010101));
    v347 = v173 ^ v174;
    v175 = (2 * (v305 ^ v267)) & 0xFEFEFEFE ^ (27 * (((v305 ^ (unsigned int)v267) >> 7) & 0x1010101));
    v176 = v354 ^ v172 ^ v267 ^ v174 ^ v175;
    v353 = v305 ^ v354 ^ v175;
    v359 = v176;
    v177 = (27 * (((v309 ^ (unsigned int)v322) >> 7) & 0x1010101)) ^ (2 * (v309 ^ v322)) & 0xFEFEFEFE;
    v178 = v309 ^ v322 ^ v177;
    v179 = v385 ^ v309 ^ v322;
    v180 = v309 ^ v385 ^ v269;
    v308 = v177 ^ v385 ^ v322 ^ v269;
    v181 = (2 * (v322 ^ v269)) & 0xFEFEFEFE ^ (27 * (((v322 ^ (unsigned int)v269) >> 7) & 0x1010101));
    v349 = v180 ^ v181;
    v182 = (2 * (v385 ^ v269)) & 0xFEFEFEFE ^ (27 * (((v385 ^ (unsigned int)v269) >> 7) & 0x1010101));
    v360 = v178 ^ v269 ^ v181 ^ v182;
    v183 = v311 ^ v287 ^ v271;
    v355 = v179 ^ v182;
    v184 = (27 * (((v311 ^ (unsigned int)v324) >> 7) & 0x1010101)) ^ (2 * (v311 ^ v324)) & 0xFEFEFEFE;
    v185 = v311 ^ v324 ^ v184 ^ v271;
    v186 = v287 ^ v311 ^ v324;
    v310 = v184 ^ v287 ^ v324 ^ v271;
    v187 = (27 * (((v324 ^ (unsigned int)v271) >> 7) & 0x1010101)) ^ (2 * (v324 ^ v271)) & 0xFEFEFEFE;
    v351 = v183 ^ v187;
    v188 = (2 * (v287 ^ v271)) & 0xFEFEFEFE ^ (27 * (((v287 ^ (unsigned int)v271) >> 7) & 0x1010101));
    v189 = v362;
    v361 = v185 ^ v187 ^ v188;
    v190 = v358 ^ v189;
    v191 = v283 ^ v189;
    v192 = v358;
    v357 = v186 ^ v188;
    v193 = (27 * (((v283 ^ (unsigned int)v312) >> 7) & 0x1010101)) ^ (2 * (v283 ^ v312)) & 0xFEFEFEFE;
    v268 = v193 ^ v312 ^ v190;
    v194 = (27 * ((v190 >> 7) & 0x1010101)) ^ (2 * v190) & 0xFEFEFEFE;
    v264 = v312 ^ v191 ^ v194;
    v195 = (27 * ((v191 >> 7) & 0x1010101)) ^ (2 * v191) & 0xFEFEFEFE;
    v266 = v192 ^ v283 ^ v312 ^ v195;
    v270 = v283 ^ v193 ^ v190 ^ v194 ^ v195;
    v196 = v364 ^ v284 ^ v313;
    v197 = (2 * (v284 ^ v313)) & 0xFEFEFEFE ^ (27 * (((v284 ^ (unsigned int)v313) >> 7) & 0x1010101));
    v371 = v313 ^ v197 ^ v364 ^ v366;
    v198 = (2 * (v364 ^ v366)) & 0xFEFEFEFE ^ (27 * (((v364 ^ (unsigned int)v366) >> 7) & 0x1010101));
    v199 = v284 ^ v197 ^ v364 ^ v366 ^ v198;
    v363 = v313 ^ v284 ^ v366 ^ v198;
    v200 = (27 * (((v284 ^ (unsigned int)v366) >> 7) & 0x1010101)) ^ (2 * (v284 ^ v366)) & 0xFEFEFEFE;
    v365 = v196 ^ v200;
    v374 = v199 ^ v200;
    v201 = (2 * (v285 ^ v314)) & 0xFEFEFEFE ^ (27 * (((v285 ^ (unsigned int)v314) >> 7) & 0x1010101));
    v372 = v314 ^ v201 ^ v386 ^ v368;
    v202 = (2 * (v386 ^ v368)) & 0xFEFEFEFE ^ (27 * (((v386 ^ (unsigned int)v368) >> 7) & 0x1010101));
    v321 = v314 ^ v285 ^ v368 ^ v202;
    v203 = (27 * (((v285 ^ (unsigned int)v368) >> 7) & 0x1010101)) ^ (2 * (v285 ^ v368)) & 0xFEFEFEFE;
    v204 = v285 ^ v201 ^ v386 ^ v368 ^ v202 ^ v203;
    v367 = v386 ^ v285 ^ v314 ^ v203;
    v375 = v204;
    v205 = (2 * (v286 ^ v315)) & 0xFEFEFEFE ^ (27 * (((v286 ^ (unsigned int)v315) >> 7) & 0x1010101));
    v373 = v205 ^ v315 ^ v387 ^ v370;
    v206 = (2 * (v387 ^ v370)) & 0xFEFEFEFE ^ (27 * (((v387 ^ (unsigned int)v370) >> 7) & 0x1010101));
    v323 = v315 ^ v286 ^ v370 ^ v206;
    v207 = (2 * (v286 ^ v370)) & 0xFEFEFEFE ^ (27 * (((v286 ^ (unsigned int)v370) >> 7) & 0x1010101));
    v376 = v286 ^ v205 ^ v387 ^ v370 ^ v206 ^ v207;
    v369 = v387 ^ v286 ^ v315 ^ v207;
    v208 = v292 ^ v276;
    v209 = (27 * ((v276 >> 7) & 0x1010101)) ^ (2 * v276) & 0xFEFEFEFE;
    v274 = v209 ^ v288 ^ v292 ^ v273;
    v210 = (27 * (((v288 ^ (unsigned int)v292) >> 7) & 0x1010101)) ^ (2 * (v288 ^ v292)) & 0xFEFEFEFE;
    v211 = v288 ^ v209 ^ v210;
    v277 = v210 ^ v292 ^ v378;
    v212 = (27 * ((v378 >> 7) & 0x1010101)) ^ (2 * v378) & 0xFEFEFEFE;
    v272 = v208 ^ v212;
    v278 = v211 ^ v378 ^ v212;
    v213 = v293 ^ v326;
    v214 = (27 * ((v326 >> 7) & 0x1010101)) ^ (2 * v326) & 0xFEFEFEFE;
    v215 = v289 ^ v214;
    v325 = v214 ^ v289 ^ v293 ^ v317;
    v216 = (2 * (v289 ^ v293)) & 0xFEFEFEFE ^ (27 * (((v289 ^ (unsigned int)v293) >> 7) & 0x1010101));
    v379 = v216 ^ v293 ^ v280;
    v217 = (27 * ((v280 >> 7) & 0x1010101)) ^ (2 * v280) & 0xFEFEFEFE;
    v382 = v215 ^ v216 ^ v280 ^ v217;
    v316 = v213 ^ v217;
    v218 = (27 * ((v328 >> 7) & 0x1010101)) ^ (2 * v328) & 0xFEFEFEFE;
    v219 = v294 ^ v328;
    v220 = (27 * ((v300 >> 7) & 0x1010101)) ^ (2 * v300) & 0xFEFEFEFE;
    v221 = (27 * (((v290 ^ (unsigned int)v294) >> 7) & 0x1010101)) ^ (2 * (v290 ^ v294)) & 0xFEFEFEFE;
    v222 = (27 * (((v291 ^ (unsigned int)v295) >> 7) & 0x1010101)) ^ (2 * (v291 ^ v295)) & 0xFEFEFEFE;
    v327 = v218 ^ v290 ^ v294 ^ v319;
    v223 = (27 * ((v282 >> 7) & 0x1010101)) ^ (2 * v282) & 0xFEFEFEFE;
    v380 = v294 ^ v221 ^ v298;
    v224 = (27 * ((v298 >> 7) & 0x1010101)) ^ (2 * v298) & 0xFEFEFEFE;
    v383 = v290 ^ v218 ^ v221 ^ v298 ^ v224;
    v296 = v219 ^ v224;
    v377 = v220 ^ v291 ^ v295 ^ v320;
    v381 = v222 ^ v295 ^ v282;
    v384 = v291 ^ v220 ^ v222 ^ v282 ^ v223;
    v318 = v295 ^ v300 ^ v223;
  }
  while ( v244 != v388 );
  result = &v406;
  v226 = v246;
  v227 = &v391;
  v391 = v329;
  v390 = v246;
  v228 = a1 - 1;
  v229 = a1 + 49;
  v392 = v331;
  v393 = v333;
  v394 = v248;
  v395 = v335;
  v396 = v336;
  v397 = v338;
  v398 = v250;
  v399 = v252;
  v400 = v340;
  v401 = v342;
  v402 = v254;
  v403 = v344;
  v404 = v345;
  v405 = v301;
  v406 = v256;
  v407 = v306;
  v408 = v308;
  v409 = v310;
  v410 = v258;
  v411 = v347;
  v412 = v349;
  v413 = v351;
  v414 = v260;
  v415 = v353;
  v416 = v355;
  v417 = v357;
  v418 = v262;
  v419 = v359;
  v420 = v360;
  v421 = v361;
  v422 = v264;
  v423 = v363;
  v424 = v321;
  v425 = v323;
  v426 = v266;
  v427 = v365;
  v428 = v386 ^ v285 ^ v314 ^ v203;
  v429 = v369;
  v430 = v268;
  v431 = v371;
  v432 = v372;
  v433 = v373;
  v434 = v270;
  v435 = v374;
  v436 = v375;
  v437 = v376;
  v438 = v272;
  v439 = v316;
  v440 = v296;
  v441 = v295 ^ v300 ^ v223;
  v442 = v274;
  v443 = v325;
  v444 = v327;
  v445 = v220 ^ v291 ^ v295 ^ v320;
  v446 = v277;
  v447 = v216 ^ v293 ^ v280;
  v448 = v380;
  v449 = v381;
  v450 = v278;
  v451 = v382;
  v452 = v383;
  v453 = v384;
  while ( 1 )
  {
    v232 = v228[1];
    ++v228;
    v231 = v232;
    v233 = v229[1];
    *++v229 = v228[32] ^ v231 ^ v228[16] ^ v233 ^ v227[15] ^ v227[31] ^ v227[47] ^ v226;
    if ( &v406 == v227 )
      break;
    v230 = *v227++;
    v226 = v230;
  }
  return result;
}
// ED944: using guessed type _DWORD dword_ED944[1025];

//----- (000A4020) --------------------------------------------------------
unsigned int *__fastcall sph_echo224_0(unsigned int *result, char *src, size_t n)
{
  unsigned int *v3; // r7
  unsigned int v4; // r5
  size_t v5; // r6
  size_t v6; // r4
  char *v7; // r8
  char *v8; // r0
  bool v9; // cf
  int v10; // r3
  int v11; // r3

  v3 = result;
  v4 = result[48];
  v5 = n;
  v6 = 192 - v4;
  if ( 192 - v4 > n )
  {
    result = (unsigned int *)memcpy((char *)result + v4, src, n);
    v3[48] = v4 + v5;
  }
  else
  {
    v7 = src;
    if ( n )
    {
      do
      {
        while ( 1 )
        {
          if ( v6 >= v5 )
            v6 = v5;
          v8 = (char *)v3 + v4;
          v4 += v6;
          result = (unsigned int *)memcpy(v8, v7, v6);
          v5 -= v6;
          v7 += v6;
          if ( v4 == 192 )
            break;
          v6 = 192 - v4;
          if ( !v5 )
            goto LABEL_13;
        }
        v4 = 0;
        v9 = v3[66] < 0xFFFFFA00;
        v3[66] += 1536;
        if ( !v9 )
        {
          v10 = v3[67] + 1;
          v3[67] = v10;
          if ( !v10 )
          {
            v11 = v3[68] + 1;
            v3[68] = v11;
            if ( !v11 )
              ++v3[69];
          }
        }
        result = sub_A0B2C(v3);
        v6 = 192;
      }
      while ( v5 );
    }
LABEL_13:
    v3[48] = v4;
  }
  return result;
}

//----- (000A40FC) --------------------------------------------------------
_DWORD *__fastcall sub_A40FC(unsigned int *a1)
{
  unsigned int *v2; // r2
  unsigned int *v3; // r3
  unsigned int v4; // lr
  unsigned int v5; // r12
  __int64 v6; // r0
  unsigned int v7; // r3
  unsigned int v8; // r2
  unsigned int v9; // r1
  unsigned int v10; // lr
  int v11; // r6
  int v12; // r4
  int v13; // r8
  int v14; // r2
  unsigned int v15; // r0
  unsigned int v16; // r2
  unsigned int v17; // r1
  unsigned int v18; // r3
  int v19; // r12
  int v20; // r4
  int v21; // r8
  int v22; // r2
  unsigned int v23; // r2
  unsigned int v24; // r0
  unsigned int v25; // r1
  unsigned int v26; // r3
  int v27; // r7
  int v28; // r9
  int v29; // r1
  unsigned int v30; // r2
  unsigned int v31; // r0
  unsigned int v32; // r3
  unsigned int v33; // r1
  int v34; // r12
  int v35; // r8
  int v36; // r4
  int v37; // r2
  unsigned int v38; // r1
  unsigned int v39; // r3
  unsigned int v40; // r2
  unsigned int v41; // r0
  int v42; // r4
  bool v43; // zf
  unsigned int v44; // r3
  unsigned int v45; // r0
  unsigned int v46; // r1
  unsigned int v47; // r3
  unsigned int v48; // r2
  int v49; // lr
  bool v50; // zf
  unsigned int v51; // r3
  unsigned int v52; // r1
  unsigned int v53; // r3
  unsigned int v54; // r2
  unsigned int v55; // r0
  int v56; // r4
  bool v57; // zf
  unsigned int v58; // r3
  unsigned int v59; // r1
  unsigned int v60; // r2
  unsigned int v61; // r3
  unsigned int v62; // r0
  int v63; // r4
  bool v64; // zf
  unsigned int v65; // r3
  unsigned int v66; // r1
  unsigned int v67; // r3
  unsigned int v68; // r0
  unsigned int v69; // r2
  int v70; // r4
  bool v71; // zf
  unsigned int v72; // r3
  unsigned int v73; // r0
  unsigned int v74; // r3
  unsigned int v75; // r1
  unsigned int v76; // r2
  int v77; // lr
  bool v78; // zf
  unsigned int v79; // r3
  unsigned int v80; // r12
  unsigned int v81; // r0
  unsigned int v82; // lr
  unsigned int v83; // r2
  int v84; // r1
  bool v85; // zf
  unsigned int v86; // r3
  unsigned int v87; // r1
  unsigned int v88; // r3
  unsigned int v89; // r2
  unsigned int v90; // r0
  int v91; // r4
  bool v92; // zf
  unsigned int v93; // r3
  unsigned int v94; // r1
  unsigned int v95; // r3
  unsigned int v96; // r2
  unsigned int v97; // r0
  int v98; // r4
  bool v99; // zf
  unsigned int v100; // r3
  unsigned int v101; // r0
  unsigned int v102; // r3
  unsigned int v103; // r2
  unsigned int v104; // r1
  int v105; // r4
  bool v106; // zf
  unsigned int v107; // r3
  unsigned int v108; // r1
  unsigned int v109; // r3
  unsigned int v110; // r2
  unsigned int v111; // r0
  int v112; // r12
  int v113; // r4
  int v114; // lr
  int v115; // r9
  int v116; // r6
  unsigned int v117; // r0
  bool v118; // zf
  unsigned int v119; // r3
  unsigned int v120; // r8
  unsigned int v121; // r1
  unsigned int v122; // r3
  unsigned int v123; // r6
  int v124; // r12
  int v125; // r0
  bool v126; // zf
  unsigned int v127; // r3
  unsigned int v128; // r5
  int v129; // r7
  int v130; // r4
  unsigned int v131; // r12
  int v132; // r8
  unsigned int v133; // lr
  unsigned int v134; // r3
  int v135; // r9
  int v136; // r6
  int v137; // r2
  unsigned int v138; // r7
  int v139; // lr
  unsigned int v140; // r10
  unsigned int v141; // r1
  unsigned int v142; // r8
  unsigned int v143; // r12
  unsigned int v144; // r0
  unsigned int v145; // r7
  int v146; // r2
  unsigned int v147; // r1
  int v148; // r4
  unsigned int v149; // r0
  unsigned int v150; // r6
  unsigned int v151; // r3
  int v152; // r4
  int v153; // r3
  int v154; // r8
  int v155; // r4
  unsigned int v156; // r2
  unsigned int v157; // r0
  int v158; // lr
  int v159; // r10
  unsigned int v160; // r12
  int v161; // r8
  unsigned int v162; // r2
  unsigned int v163; // r1
  int v164; // r0
  unsigned int v165; // r12
  int v166; // r10
  int v167; // lr
  unsigned int v168; // r12
  int v169; // r7
  unsigned int v170; // r1
  unsigned int v171; // r3
  unsigned int v172; // r1
  unsigned int v173; // r2
  int v174; // r12
  int v175; // r2
  unsigned int v176; // r4
  int v177; // r12
  unsigned int v178; // r0
  int v179; // r9
  unsigned int v180; // r4
  unsigned int v181; // r3
  unsigned int v182; // r5
  unsigned int v183; // r1
  int v184; // r12
  int v185; // r6
  unsigned int v186; // r10
  unsigned int v187; // r1
  int v188; // r12
  unsigned int v189; // r7
  unsigned int v190; // r1
  int v191; // r5
  unsigned int v192; // r8
  int v193; // lr
  int v194; // r4
  int v195; // r8
  unsigned int v196; // r6
  unsigned int v197; // r1
  unsigned int v198; // r12
  unsigned int v199; // r2
  int v200; // r5
  unsigned int v201; // r0
  unsigned int v202; // r12
  int v203; // r6
  unsigned int v204; // r3
  unsigned int v205; // r1
  unsigned int v206; // r5
  unsigned int v207; // r3
  unsigned int v208; // r2
  unsigned int v209; // r5
  unsigned int v210; // r4
  int v211; // r10
  unsigned int v212; // r5
  unsigned int v213; // r6
  unsigned int v214; // lr
  unsigned int v215; // r3
  unsigned int v216; // r9
  unsigned int v217; // r7
  unsigned int v218; // r12
  unsigned int v219; // r2
  unsigned int v220; // r5
  unsigned int v221; // lr
  _DWORD *result; // r0
  unsigned int v223; // r5
  _DWORD *v224; // r12
  unsigned int *v225; // r2
  _DWORD *v226; // r3
  int v227; // r1
  int v228; // t1
  unsigned int v229; // r4
  unsigned int v230; // t1
  int v231; // t1
  bool v232; // zf
  unsigned int v233; // r3
  bool v234; // zf
  unsigned int v235; // r3
  bool v236; // zf
  unsigned int v237; // r2
  bool v238; // zf
  unsigned int v239; // r3
  unsigned int v240; // [sp+4h] [bp-290h]
  unsigned int v241; // [sp+8h] [bp-28Ch]
  unsigned int v242; // [sp+Ch] [bp-288h]
  int v243; // [sp+10h] [bp-284h]
  int v244; // [sp+18h] [bp-27Ch]
  int v245; // [sp+18h] [bp-27Ch]
  unsigned int v246; // [sp+1Ch] [bp-278h]
  int v247; // [sp+1Ch] [bp-278h]
  unsigned int v248; // [sp+20h] [bp-274h]
  int v249; // [sp+20h] [bp-274h]
  unsigned int v250; // [sp+24h] [bp-270h]
  int v251; // [sp+24h] [bp-270h]
  unsigned int v252; // [sp+28h] [bp-26Ch]
  int v253; // [sp+28h] [bp-26Ch]
  unsigned int v254; // [sp+2Ch] [bp-268h]
  int v255; // [sp+2Ch] [bp-268h]
  unsigned int v256; // [sp+30h] [bp-264h]
  int v257; // [sp+30h] [bp-264h]
  unsigned int v258; // [sp+34h] [bp-260h]
  int v259; // [sp+34h] [bp-260h]
  unsigned int v260; // [sp+38h] [bp-25Ch]
  int v261; // [sp+38h] [bp-25Ch]
  unsigned int v262; // [sp+3Ch] [bp-258h]
  int v263; // [sp+3Ch] [bp-258h]
  unsigned int v264; // [sp+40h] [bp-254h]
  int v265; // [sp+40h] [bp-254h]
  unsigned int v266; // [sp+44h] [bp-250h]
  int v267; // [sp+44h] [bp-250h]
  unsigned int v268; // [sp+48h] [bp-24Ch]
  int v269; // [sp+48h] [bp-24Ch]
  unsigned int v270; // [sp+4Ch] [bp-248h]
  int v271; // [sp+4Ch] [bp-248h]
  unsigned int v272; // [sp+50h] [bp-244h]
  int v273; // [sp+50h] [bp-244h]
  unsigned int v274; // [sp+54h] [bp-240h]
  int v275; // [sp+54h] [bp-240h]
  int v276; // [sp+54h] [bp-240h]
  unsigned int v277; // [sp+58h] [bp-23Ch]
  int v278; // [sp+58h] [bp-23Ch]
  unsigned int v279; // [sp+5Ch] [bp-238h]
  int v280; // [sp+60h] [bp-234h]
  unsigned int v281; // [sp+60h] [bp-234h]
  int v282; // [sp+64h] [bp-230h]
  unsigned int v283; // [sp+64h] [bp-230h]
  int v284; // [sp+68h] [bp-22Ch]
  int v285; // [sp+68h] [bp-22Ch]
  int v286; // [sp+6Ch] [bp-228h]
  int v287; // [sp+70h] [bp-224h]
  int v288; // [sp+74h] [bp-220h]
  int v289; // [sp+78h] [bp-21Ch]
  int v290; // [sp+7Ch] [bp-218h]
  int v291; // [sp+80h] [bp-214h]
  int v292; // [sp+84h] [bp-210h]
  int v293; // [sp+88h] [bp-20Ch]
  int v294; // [sp+8Ch] [bp-208h]
  int v295; // [sp+90h] [bp-204h]
  int v296; // [sp+94h] [bp-200h]
  int v297; // [sp+98h] [bp-1FCh]
  unsigned int v298; // [sp+9Ch] [bp-1F8h]
  int v299; // [sp+9Ch] [bp-1F8h]
  unsigned int v300; // [sp+9Ch] [bp-1F8h]
  int v301; // [sp+A0h] [bp-1F4h]
  unsigned int v302; // [sp+A0h] [bp-1F4h]
  unsigned int v303; // [sp+A4h] [bp-1F0h]
  int v304; // [sp+A4h] [bp-1F0h]
  unsigned int v305; // [sp+A4h] [bp-1F0h]
  int v306; // [sp+A8h] [bp-1ECh]
  unsigned int v307; // [sp+ACh] [bp-1E8h]
  int v308; // [sp+ACh] [bp-1E8h]
  unsigned int v309; // [sp+B0h] [bp-1E4h]
  int v310; // [sp+B0h] [bp-1E4h]
  unsigned int v311; // [sp+B4h] [bp-1E0h]
  int v312; // [sp+B4h] [bp-1E0h]
  int v313; // [sp+B8h] [bp-1DCh]
  int v314; // [sp+BCh] [bp-1D8h]
  int v315; // [sp+C0h] [bp-1D4h]
  int v316; // [sp+C4h] [bp-1D0h]
  unsigned int v317; // [sp+C8h] [bp-1CCh]
  int v318; // [sp+C8h] [bp-1CCh]
  unsigned int v319; // [sp+CCh] [bp-1C8h]
  int v320; // [sp+CCh] [bp-1C8h]
  int v321; // [sp+D0h] [bp-1C4h]
  unsigned int v322; // [sp+D4h] [bp-1C0h]
  int v323; // [sp+D4h] [bp-1C0h]
  unsigned int v324; // [sp+D8h] [bp-1BCh]
  int v325; // [sp+D8h] [bp-1BCh]
  unsigned int v326; // [sp+DCh] [bp-1B8h]
  unsigned int v327; // [sp+E0h] [bp-1B4h]
  unsigned int v328; // [sp+E0h] [bp-1B4h]
  unsigned int v329; // [sp+E4h] [bp-1B0h]
  unsigned int v330; // [sp+E4h] [bp-1B0h]
  unsigned int v331; // [sp+E8h] [bp-1ACh]
  int v332; // [sp+E8h] [bp-1ACh]
  unsigned int v333; // [sp+E8h] [bp-1ACh]
  unsigned int v334; // [sp+ECh] [bp-1A8h]
  int v335; // [sp+ECh] [bp-1A8h]
  unsigned int v336; // [sp+F0h] [bp-1A4h]
  int v337; // [sp+F0h] [bp-1A4h]
  unsigned int v338; // [sp+F4h] [bp-1A0h]
  int v339; // [sp+F4h] [bp-1A0h]
  unsigned int v340; // [sp+F8h] [bp-19Ch]
  unsigned int v341; // [sp+FCh] [bp-198h]
  int v342; // [sp+FCh] [bp-198h]
  unsigned int v343; // [sp+100h] [bp-194h]
  int v344; // [sp+100h] [bp-194h]
  unsigned int v345; // [sp+104h] [bp-190h]
  int v346; // [sp+104h] [bp-190h]
  unsigned int v347; // [sp+108h] [bp-18Ch]
  int v348; // [sp+108h] [bp-18Ch]
  unsigned int v349; // [sp+10Ch] [bp-188h]
  unsigned int v350; // [sp+110h] [bp-184h]
  int v351; // [sp+110h] [bp-184h]
  unsigned int v352; // [sp+114h] [bp-180h]
  unsigned int v353; // [sp+114h] [bp-180h]
  unsigned int v354; // [sp+118h] [bp-17Ch]
  unsigned int v355; // [sp+118h] [bp-17Ch]
  unsigned int v356; // [sp+11Ch] [bp-178h]
  unsigned int v357; // [sp+11Ch] [bp-178h]
  unsigned int v358; // [sp+120h] [bp-174h]
  unsigned int v359; // [sp+120h] [bp-174h]
  unsigned int v360; // [sp+124h] [bp-170h]
  unsigned int v361; // [sp+124h] [bp-170h]
  unsigned int v362; // [sp+128h] [bp-16Ch]
  int v363; // [sp+128h] [bp-16Ch]
  unsigned int v364; // [sp+12Ch] [bp-168h]
  unsigned int v365; // [sp+130h] [bp-164h]
  unsigned int v366; // [sp+134h] [bp-160h]
  unsigned int v367; // [sp+138h] [bp-15Ch]
  int v368; // [sp+138h] [bp-15Ch]
  unsigned int v369; // [sp+13Ch] [bp-158h]
  int v370; // [sp+13Ch] [bp-158h]
  unsigned int v371; // [sp+140h] [bp-154h]
  int v372; // [sp+140h] [bp-154h]
  unsigned int v373; // [sp+144h] [bp-150h]
  unsigned int v374; // [sp+148h] [bp-14Ch]
  unsigned int v375; // [sp+14Ch] [bp-148h]
  unsigned int v376; // [sp+150h] [bp-144h]
  unsigned int v377; // [sp+154h] [bp-140h]
  unsigned int v378; // [sp+158h] [bp-13Ch]
  unsigned int v379; // [sp+15Ch] [bp-138h]
  unsigned int v380; // [sp+15Ch] [bp-138h]
  unsigned int v381; // [sp+160h] [bp-134h]
  unsigned int v382; // [sp+164h] [bp-130h]
  unsigned int v383; // [sp+168h] [bp-12Ch]
  unsigned int v384; // [sp+16Ch] [bp-128h]
  unsigned int v385; // [sp+170h] [bp-124h]
  int v386; // [sp+174h] [bp-120h]
  int v387; // [sp+178h] [bp-11Ch]
  int v388; // [sp+17Ch] [bp-118h]
  int v389; // [sp+180h] [bp-114h]
  int v390; // [sp+184h] [bp-110h]
  unsigned int v391; // [sp+188h] [bp-10Ch]
  _DWORD dest[32]; // [sp+190h] [bp-104h] BYREF
  unsigned int v394; // [sp+210h] [bp-84h] BYREF
  unsigned int v395; // [sp+214h] [bp-80h]
  unsigned int v396; // [sp+218h] [bp-7Ch]
  unsigned int v397; // [sp+21Ch] [bp-78h]
  unsigned int v398; // [sp+220h] [bp-74h]
  unsigned int v399; // [sp+224h] [bp-70h]
  int v400; // [sp+228h] [bp-6Ch]
  unsigned int v401; // [sp+22Ch] [bp-68h]
  unsigned int v402; // [sp+230h] [bp-64h]
  unsigned int v403; // [sp+234h] [bp-60h]
  unsigned int v404; // [sp+238h] [bp-5Ch]
  unsigned int v405; // [sp+23Ch] [bp-58h]
  unsigned int v406; // [sp+240h] [bp-54h]
  unsigned int v407; // [sp+244h] [bp-50h]
  unsigned int v408; // [sp+248h] [bp-4Ch]
  unsigned int v409; // [sp+24Ch] [bp-48h]
  unsigned int v410; // [sp+250h] [bp-44h]
  unsigned int v411; // [sp+254h] [bp-40h]
  unsigned int v412; // [sp+258h] [bp-3Ch]
  unsigned int v413; // [sp+25Ch] [bp-38h]
  unsigned int v414; // [sp+260h] [bp-34h]
  unsigned int v415; // [sp+264h] [bp-30h]
  unsigned int v416; // [sp+268h] [bp-2Ch]
  unsigned int v417; // [sp+26Ch] [bp-28h]
  unsigned int v418; // [sp+270h] [bp-24h]
  unsigned int v419; // [sp+274h] [bp-20h]
  unsigned int v420; // [sp+278h] [bp-1Ch]
  unsigned int v421; // [sp+27Ch] [bp-18h]
  unsigned int v422; // [sp+280h] [bp-14h]
  unsigned int v423; // [sp+284h] [bp-10h]
  unsigned int v424; // [sp+288h] [bp-Ch]
  _DWORD v425[2]; // [sp+28Ch] [bp-8h] BYREF

  v242 = a1[66];
  v240 = a1[67];
  v241 = a1[68];
  v243 = a1[69];
  memcpy(dest, a1 + 34, sizeof(dest));
  v2 = a1;
  v3 = dest;
  do
  {
    v4 = *v2;
    v3 += 4;
    v5 = v2[1];
    v2 += 4;
    v6 = *((_QWORD *)v2 - 1);
    v3[28] = v4;
    v3[29] = v5;
    *((_QWORD *)v3 + 15) = v6;
  }
  while ( &v394 != v3 );
  v246 = dest[0];
  v338 = dest[3];
  v334 = dest[1];
  v336 = dest[2];
  v244 = 16843009;
  v248 = dest[4];
  v340 = dest[5];
  v341 = dest[6];
  v391 = v242 + 160;
  v343 = dest[7];
  v250 = dest[8];
  v252 = dest[9];
  v345 = dest[10];
  v347 = dest[11];
  v254 = dest[12];
  v349 = dest[13];
  v350 = dest[14];
  v303 = dest[15];
  v256 = dest[16];
  v307 = dest[17];
  v309 = dest[18];
  v311 = dest[19];
  v258 = dest[20];
  v352 = dest[21];
  v354 = dest[22];
  v356 = dest[23];
  v260 = dest[24];
  v358 = dest[25];
  v360 = dest[26];
  v362 = dest[27];
  v262 = dest[28];
  v364 = dest[29];
  v365 = dest[30];
  v366 = dest[31];
  v264 = v394;
  v322 = v395;
  v324 = v396;
  v326 = v397;
  v266 = v398;
  v367 = v399;
  v369 = v400;
  v371 = v401;
  v268 = v402;
  v373 = v403;
  v374 = v404;
  v375 = v405;
  v270 = v406;
  v376 = v407;
  v377 = v408;
  v378 = v409;
  v272 = v410;
  v317 = v411;
  v298 = v412;
  v319 = v413;
  v274 = v414;
  v327 = v415;
  v329 = v416;
  v331 = v417;
  v277 = v418;
  v379 = v419;
  v381 = v420;
  v382 = v421;
  v279 = v422;
  v383 = v423;
  v384 = v424;
  v385 = v425[0];
  do
  {
    v7 = dword_ED944[BYTE1(v334) + 512]
       ^ dword_ED944[(unsigned __int8)v246]
       ^ dword_ED944[HIBYTE(v338) + 256]
       ^ v242
       ^ dword_ED944[BYTE2(v336) + 768];
    v8 = dword_ED944[BYTE1(v336) + 512]
       ^ dword_ED944[HIBYTE(v246) + 256]
       ^ dword_ED944[(unsigned __int8)v334]
       ^ v240
       ^ dword_ED944[BYTE2(v338) + 768];
    v9 = dword_ED944[BYTE1(v338) + 512]
       ^ dword_ED944[(unsigned __int8)v336]
       ^ dword_ED944[HIBYTE(v334) + 256]
       ^ v241
       ^ dword_ED944[BYTE2(v246) + 768];
    v10 = dword_ED944[BYTE1(v246) + 512]
        ^ dword_ED944[(unsigned __int8)v338]
        ^ dword_ED944[HIBYTE(v336) + 256]
        ^ v243
        ^ dword_ED944[BYTE2(v334) + 768];
    v11 = dword_ED944[HIBYTE(v10) + 256] ^ dword_ED944[(unsigned __int8)v7] ^ dword_ED944[BYTE1(v8) + 512];
    v12 = dword_ED944[BYTE1(v9) + 512] ^ dword_ED944[HIBYTE(v7) + 256] ^ dword_ED944[(unsigned __int8)v8];
    v13 = dword_ED944[(unsigned __int8)v9] ^ dword_ED944[HIBYTE(v8) + 256] ^ dword_ED944[BYTE1(v10) + 512];
    v14 = dword_ED944[BYTE2(v8) + 768];
    v282 = v12 ^ dword_ED944[BYTE2(v10) + 768];
    v280 = v11 ^ dword_ED944[BYTE2(v9) + 768];
    v301 = v13 ^ dword_ED944[BYTE2(v7) + 768];
    v306 = dword_ED944[HIBYTE(v9) + 256] ^ dword_ED944[(unsigned __int8)v10] ^ dword_ED944[BYTE1(v7) + 512] ^ v14;
    if ( v242 == -1 && !++v240 )
    {
      v233 = v241 + 1;
      v232 = v241 == -1;
      if ( v241 == -1 )
        v14 = v243;
      ++v241;
      if ( v232 )
      {
        v240 = v233;
        v243 = v14 + 1;
      }
    }
    v15 = dword_ED944[(unsigned __int8)v340]
        ^ dword_ED944[HIBYTE(v248) + 256]
        ^ dword_ED944[BYTE1(v341) + 512]
        ^ dword_ED944[BYTE2(v343) + 768]
        ^ v240;
    v16 = dword_ED944[HIBYTE(v340) + 256]
        ^ dword_ED944[(unsigned __int8)v341]
        ^ dword_ED944[BYTE1(v343) + 512]
        ^ dword_ED944[BYTE2(v248) + 768]
        ^ v241;
    v17 = dword_ED944[BYTE1(v340) + 512]
        ^ dword_ED944[(unsigned __int8)v248]
        ^ dword_ED944[HIBYTE(v343) + 256]
        ^ (v242 + 1)
        ^ dword_ED944[BYTE2(v341) + 768];
    v18 = dword_ED944[(unsigned __int8)v343]
        ^ dword_ED944[HIBYTE(v341) + 256]
        ^ dword_ED944[BYTE1(v248) + 512]
        ^ dword_ED944[BYTE2(v340) + 768]
        ^ v243;
    v19 = dword_ED944[(unsigned __int8)v15] ^ dword_ED944[HIBYTE(v17) + 256] ^ dword_ED944[BYTE1(v16) + 512];
    v20 = dword_ED944[HIBYTE(v16) + 256] ^ dword_ED944[(unsigned __int8)v18] ^ dword_ED944[BYTE1(v17) + 512];
    v21 = dword_ED944[(unsigned __int8)v16] ^ dword_ED944[HIBYTE(v15) + 256] ^ dword_ED944[BYTE2(v17) + 768];
    v22 = dword_ED944[HIBYTE(v18) + 256]
        ^ dword_ED944[(unsigned __int8)v17]
        ^ dword_ED944[BYTE1(v15) + 512]
        ^ dword_ED944[BYTE2(v16) + 768];
    v342 = v21 ^ dword_ED944[BYTE1(v18) + 512];
    v337 = v22;
    v339 = v19 ^ dword_ED944[BYTE2(v18) + 768];
    v344 = v20 ^ dword_ED944[BYTE2(v15) + 768];
    if ( v242 == -2 && !++v240 )
    {
      v239 = v241 + 1;
      v238 = v241 == -1;
      if ( v241 == -1 )
        v22 = v243;
      ++v241;
      if ( v238 )
      {
        v240 = v239;
        v243 = v22 + 1;
      }
    }
    v23 = dword_ED944[(unsigned __int8)v345]
        ^ dword_ED944[HIBYTE(v252) + 256]
        ^ dword_ED944[BYTE1(v347) + 512]
        ^ dword_ED944[BYTE2(v250) + 768]
        ^ v241;
    v24 = dword_ED944[(unsigned __int8)v252]
        ^ dword_ED944[HIBYTE(v250) + 256]
        ^ dword_ED944[BYTE1(v345) + 512]
        ^ dword_ED944[BYTE2(v347) + 768]
        ^ v240;
    v25 = dword_ED944[(unsigned __int8)v250]
        ^ dword_ED944[HIBYTE(v347) + 256]
        ^ (v242 + 2)
        ^ dword_ED944[BYTE1(v252) + 512]
        ^ dword_ED944[BYTE2(v345) + 768];
    v26 = dword_ED944[(unsigned __int8)v347]
        ^ dword_ED944[HIBYTE(v345) + 256]
        ^ dword_ED944[BYTE1(v250) + 512]
        ^ dword_ED944[BYTE2(v252) + 768]
        ^ v243;
    v27 = dword_ED944[BYTE1(v25) + 512];
    v28 = dword_ED944[BYTE2(v25) + 768];
    v284 = dword_ED944[(unsigned __int8)v25]
         ^ dword_ED944[HIBYTE(v26) + 256]
         ^ dword_ED944[BYTE1(v24) + 512]
         ^ dword_ED944[BYTE2(v23) + 768];
    v29 = dword_ED944[(unsigned __int8)v24]
        ^ dword_ED944[HIBYTE(v25) + 256]
        ^ dword_ED944[BYTE1(v23) + 512]
        ^ dword_ED944[BYTE2(v26) + 768];
    v287 = dword_ED944[(unsigned __int8)v23] ^ dword_ED944[HIBYTE(v24) + 256] ^ v28 ^ dword_ED944[BYTE1(v26) + 512];
    v286 = v29;
    v288 = dword_ED944[HIBYTE(v23) + 256] ^ dword_ED944[(unsigned __int8)v26] ^ v27 ^ dword_ED944[BYTE2(v24) + 768];
    if ( v242 == -3 && !++v240 )
    {
      v237 = v241 + 1;
      v236 = v241 == -1;
      if ( v241 == -1 )
        v29 = v243;
      ++v241;
      if ( v236 )
      {
        v240 = v237;
        v243 = v29 + 1;
      }
    }
    v30 = dword_ED944[BYTE1(v303) + 512]
        ^ dword_ED944[HIBYTE(v349) + 256]
        ^ dword_ED944[(unsigned __int8)v350]
        ^ dword_ED944[BYTE2(v254) + 768]
        ^ v241;
    v31 = dword_ED944[HIBYTE(v254) + 256]
        ^ dword_ED944[(unsigned __int8)v349]
        ^ dword_ED944[BYTE1(v350) + 512]
        ^ dword_ED944[BYTE2(v303) + 768]
        ^ v240;
    v32 = dword_ED944[BYTE2(v349) + 768]
        ^ dword_ED944[(unsigned __int8)v303]
        ^ dword_ED944[HIBYTE(v350) + 256]
        ^ dword_ED944[BYTE1(v254) + 512]
        ^ v243;
    v33 = dword_ED944[(unsigned __int8)v254]
        ^ dword_ED944[HIBYTE(v303) + 256]
        ^ (v242 + 3)
        ^ dword_ED944[BYTE1(v349) + 512]
        ^ dword_ED944[BYTE2(v350) + 768];
    v34 = dword_ED944[(unsigned __int8)v31] ^ dword_ED944[HIBYTE(v33) + 256] ^ dword_ED944[BYTE1(v30) + 512];
    v35 = dword_ED944[(unsigned __int8)v30] ^ dword_ED944[HIBYTE(v31) + 256] ^ dword_ED944[BYTE2(v33) + 768];
    v36 = dword_ED944[HIBYTE(v30) + 256] ^ dword_ED944[(unsigned __int8)v32] ^ dword_ED944[BYTE1(v33) + 512];
    v37 = dword_ED944[BYTE2(v30) + 768];
    v386 = v34 ^ dword_ED944[BYTE2(v32) + 768];
    v348 = dword_ED944[HIBYTE(v32) + 256] ^ dword_ED944[(unsigned __int8)v33] ^ dword_ED944[BYTE1(v31) + 512] ^ v37;
    v387 = v35 ^ dword_ED944[BYTE1(v32) + 512];
    v289 = v36 ^ dword_ED944[BYTE2(v31) + 768];
    if ( v242 == -4 && !++v240 )
    {
      v235 = v241 + 1;
      v234 = v241 == -1;
      if ( v241 == -1 )
        v37 = v243;
      ++v241;
      if ( v234 )
      {
        v240 = v235;
        v243 = v37 + 1;
      }
    }
    v38 = dword_ED944[BYTE1(v307) + 512]
        ^ dword_ED944[(unsigned __int8)v256]
        ^ dword_ED944[HIBYTE(v311) + 256]
        ^ (v242 + 4)
        ^ dword_ED944[BYTE2(v309) + 768];
    v39 = dword_ED944[(unsigned __int8)v311]
        ^ dword_ED944[HIBYTE(v309) + 256]
        ^ dword_ED944[BYTE1(v256) + 512]
        ^ dword_ED944[BYTE2(v307) + 768]
        ^ v243;
    v40 = dword_ED944[HIBYTE(v307) + 256]
        ^ dword_ED944[(unsigned __int8)v309]
        ^ dword_ED944[BYTE1(v311) + 512]
        ^ dword_ED944[BYTE2(v256) + 768]
        ^ v241;
    v41 = dword_ED944[(unsigned __int8)v307]
        ^ dword_ED944[HIBYTE(v256) + 256]
        ^ dword_ED944[BYTE1(v309) + 512]
        ^ dword_ED944[BYTE2(v311) + 768]
        ^ v240;
    v42 = dword_ED944[HIBYTE(v40) + 256] ^ dword_ED944[(unsigned __int8)v39] ^ dword_ED944[BYTE1(v38) + 512];
    v310 = dword_ED944[(unsigned __int8)v40]
         ^ dword_ED944[HIBYTE(v41) + 256]
         ^ dword_ED944[BYTE2(v38) + 768]
         ^ dword_ED944[BYTE1(v39) + 512];
    v257 = dword_ED944[HIBYTE(v39) + 256]
         ^ dword_ED944[(unsigned __int8)v38]
         ^ dword_ED944[BYTE1(v41) + 512]
         ^ dword_ED944[BYTE2(v40) + 768];
    v308 = dword_ED944[(unsigned __int8)v41]
         ^ dword_ED944[HIBYTE(v38) + 256]
         ^ dword_ED944[BYTE1(v40) + 512]
         ^ dword_ED944[BYTE2(v39) + 768];
    v312 = v42 ^ dword_ED944[BYTE2(v41) + 768];
    if ( v242 == -5 && !++v240 )
    {
      v44 = v241 + 1;
      v43 = v241 == -1;
      if ( v241 == -1 )
        v42 = v243;
      ++v241;
      if ( v43 )
      {
        v240 = v44;
        v243 = v42 + 1;
      }
    }
    v45 = dword_ED944[BYTE1(v354) + 512]
        ^ dword_ED944[(unsigned __int8)v352]
        ^ dword_ED944[HIBYTE(v258) + 256]
        ^ dword_ED944[BYTE2(v356) + 768]
        ^ v240;
    v46 = dword_ED944[BYTE1(v352) + 512]
        ^ dword_ED944[(unsigned __int8)v258]
        ^ dword_ED944[HIBYTE(v356) + 256]
        ^ (v242 + 5)
        ^ dword_ED944[BYTE2(v354) + 768];
    v47 = dword_ED944[(unsigned __int8)v356]
        ^ dword_ED944[HIBYTE(v354) + 256]
        ^ dword_ED944[BYTE1(v258) + 512]
        ^ dword_ED944[BYTE2(v352) + 768]
        ^ v243;
    v48 = dword_ED944[(unsigned __int8)v354]
        ^ dword_ED944[HIBYTE(v352) + 256]
        ^ dword_ED944[BYTE1(v356) + 512]
        ^ dword_ED944[BYTE2(v258) + 768]
        ^ v241;
    v49 = dword_ED944[BYTE1(v48) + 512];
    v304 = dword_ED944[(unsigned __int8)v45] ^ dword_ED944[HIBYTE(v46) + 256] ^ v49 ^ dword_ED944[BYTE2(v47) + 768];
    v335 = dword_ED944[(unsigned __int8)v48]
         ^ dword_ED944[HIBYTE(v45) + 256]
         ^ dword_ED944[BYTE2(v46) + 768]
         ^ dword_ED944[BYTE1(v47) + 512];
    v255 = dword_ED944[HIBYTE(v47) + 256]
         ^ dword_ED944[(unsigned __int8)v46]
         ^ dword_ED944[BYTE1(v45) + 512]
         ^ dword_ED944[BYTE2(v48) + 768];
    v247 = dword_ED944[HIBYTE(v48) + 256]
         ^ dword_ED944[(unsigned __int8)v47]
         ^ dword_ED944[BYTE1(v46) + 512]
         ^ dword_ED944[BYTE2(v45) + 768];
    if ( v242 == -6 && !++v240 )
    {
      v51 = v241 + 1;
      v50 = v241 == -1;
      if ( v241 == -1 )
        v49 = v243;
      ++v241;
      if ( v50 )
      {
        v240 = v51;
        v243 = v49 + 1;
      }
    }
    v52 = dword_ED944[BYTE1(v358) + 512]
        ^ dword_ED944[(unsigned __int8)v260]
        ^ dword_ED944[HIBYTE(v362) + 256]
        ^ (v242 + 6)
        ^ dword_ED944[BYTE2(v360) + 768];
    v53 = dword_ED944[(unsigned __int8)v362]
        ^ dword_ED944[HIBYTE(v360) + 256]
        ^ dword_ED944[BYTE1(v260) + 512]
        ^ dword_ED944[BYTE2(v358) + 768]
        ^ v243;
    v54 = dword_ED944[HIBYTE(v358) + 256]
        ^ dword_ED944[(unsigned __int8)v360]
        ^ dword_ED944[BYTE1(v362) + 512]
        ^ dword_ED944[BYTE2(v260) + 768]
        ^ v241;
    v55 = dword_ED944[HIBYTE(v260) + 256]
        ^ dword_ED944[(unsigned __int8)v358]
        ^ dword_ED944[BYTE1(v360) + 512]
        ^ dword_ED944[BYTE2(v362) + 768]
        ^ v240;
    v56 = dword_ED944[HIBYTE(v54) + 256] ^ dword_ED944[(unsigned __int8)v53] ^ dword_ED944[BYTE1(v52) + 512];
    v292 = dword_ED944[(unsigned __int8)v54]
         ^ dword_ED944[HIBYTE(v55) + 256]
         ^ dword_ED944[BYTE2(v52) + 768]
         ^ dword_ED944[BYTE1(v53) + 512];
    v290 = dword_ED944[HIBYTE(v53) + 256]
         ^ dword_ED944[(unsigned __int8)v52]
         ^ dword_ED944[BYTE1(v55) + 512]
         ^ dword_ED944[BYTE2(v54) + 768];
    v291 = dword_ED944[(unsigned __int8)v55]
         ^ dword_ED944[HIBYTE(v52) + 256]
         ^ dword_ED944[BYTE1(v54) + 512]
         ^ dword_ED944[BYTE2(v53) + 768];
    v293 = v56 ^ dword_ED944[BYTE2(v55) + 768];
    if ( v242 == -7 && !++v240 )
    {
      v58 = v241 + 1;
      v57 = v241 == -1;
      if ( v241 == -1 )
        v56 = v243;
      ++v241;
      if ( v57 )
      {
        v240 = v58;
        v243 = v56 + 1;
      }
    }
    v59 = dword_ED944[BYTE1(v364) + 512]
        ^ dword_ED944[(unsigned __int8)v262]
        ^ dword_ED944[HIBYTE(v366) + 256]
        ^ (v242 + 7)
        ^ dword_ED944[BYTE2(v365) + 768];
    v60 = dword_ED944[(unsigned __int8)v366]
        ^ dword_ED944[HIBYTE(v365) + 256]
        ^ dword_ED944[BYTE1(v262) + 512]
        ^ dword_ED944[BYTE2(v364) + 768]
        ^ v243;
    v61 = dword_ED944[HIBYTE(v364) + 256]
        ^ dword_ED944[(unsigned __int8)v365]
        ^ dword_ED944[BYTE1(v366) + 512]
        ^ dword_ED944[BYTE2(v262) + 768]
        ^ v241;
    v62 = dword_ED944[HIBYTE(v262) + 256]
        ^ dword_ED944[(unsigned __int8)v364]
        ^ dword_ED944[BYTE1(v365) + 512]
        ^ dword_ED944[BYTE2(v366) + 768]
        ^ v240;
    v63 = dword_ED944[HIBYTE(v61) + 256] ^ dword_ED944[(unsigned __int8)v60] ^ dword_ED944[BYTE1(v59) + 512];
    v313 = dword_ED944[HIBYTE(v60) + 256]
         ^ dword_ED944[(unsigned __int8)v59]
         ^ dword_ED944[BYTE1(v62) + 512]
         ^ dword_ED944[BYTE2(v61) + 768];
    v315 = dword_ED944[HIBYTE(v62) + 256]
         ^ dword_ED944[(unsigned __int8)v61]
         ^ dword_ED944[BYTE2(v59) + 768]
         ^ dword_ED944[BYTE1(v60) + 512];
    v314 = dword_ED944[(unsigned __int8)v62]
         ^ dword_ED944[HIBYTE(v59) + 256]
         ^ dword_ED944[BYTE1(v61) + 512]
         ^ dword_ED944[BYTE2(v60) + 768];
    v316 = v63 ^ dword_ED944[BYTE2(v62) + 768];
    if ( v242 == -8 && !++v240 )
    {
      v65 = v241 + 1;
      v64 = v241 == -1;
      if ( v241 == -1 )
        v63 = v243;
      ++v241;
      if ( v64 )
      {
        v240 = v65;
        v243 = v63 + 1;
      }
    }
    v66 = dword_ED944[BYTE1(v322) + 512]
        ^ dword_ED944[(unsigned __int8)v264]
        ^ dword_ED944[HIBYTE(v326) + 256]
        ^ (v242 + 8)
        ^ dword_ED944[BYTE2(v324) + 768];
    v67 = dword_ED944[(unsigned __int8)v326]
        ^ dword_ED944[HIBYTE(v324) + 256]
        ^ dword_ED944[BYTE1(v264) + 512]
        ^ dword_ED944[BYTE2(v322) + 768]
        ^ v243;
    v68 = dword_ED944[HIBYTE(v264) + 256]
        ^ dword_ED944[(unsigned __int8)v322]
        ^ dword_ED944[BYTE1(v324) + 512]
        ^ dword_ED944[BYTE2(v326) + 768]
        ^ v240;
    v69 = dword_ED944[(unsigned __int8)v324]
        ^ dword_ED944[HIBYTE(v322) + 256]
        ^ dword_ED944[BYTE1(v326) + 512]
        ^ dword_ED944[BYTE2(v264) + 768]
        ^ v241;
    v70 = dword_ED944[BYTE1(v68) + 512];
    v389 = dword_ED944[(unsigned __int8)v69]
         ^ dword_ED944[HIBYTE(v68) + 256]
         ^ dword_ED944[BYTE2(v66) + 768]
         ^ dword_ED944[BYTE1(v67) + 512];
    v363 = dword_ED944[HIBYTE(v67) + 256] ^ dword_ED944[(unsigned __int8)v66] ^ v70 ^ dword_ED944[BYTE2(v69) + 768];
    v388 = dword_ED944[(unsigned __int8)v68]
         ^ dword_ED944[HIBYTE(v66) + 256]
         ^ dword_ED944[BYTE1(v69) + 512]
         ^ dword_ED944[BYTE2(v67) + 768];
    v390 = dword_ED944[BYTE1(v66) + 512]
         ^ dword_ED944[HIBYTE(v69) + 256]
         ^ dword_ED944[(unsigned __int8)v67]
         ^ dword_ED944[BYTE2(v68) + 768];
    if ( v242 == -9 && !++v240 )
    {
      v72 = v241 + 1;
      v71 = v241 == -1;
      if ( v241 == -1 )
        v70 = v243;
      ++v241;
      if ( v71 )
      {
        v240 = v72;
        v243 = v70 + 1;
      }
    }
    v73 = dword_ED944[(unsigned __int8)v367]
        ^ dword_ED944[HIBYTE(v266) + 256]
        ^ dword_ED944[BYTE1(v369) + 512]
        ^ dword_ED944[BYTE2(v371) + 768]
        ^ v240;
    v74 = dword_ED944[(unsigned __int8)v371]
        ^ dword_ED944[HIBYTE(v369) + 256]
        ^ dword_ED944[BYTE1(v266) + 512]
        ^ dword_ED944[BYTE2(v367) + 768]
        ^ v243;
    v75 = dword_ED944[(unsigned __int8)v266]
        ^ dword_ED944[HIBYTE(v371) + 256]
        ^ (v242 + 9)
        ^ dword_ED944[BYTE1(v367) + 512]
        ^ dword_ED944[BYTE2(v369) + 768];
    v76 = dword_ED944[(unsigned __int8)v369]
        ^ dword_ED944[HIBYTE(v367) + 256]
        ^ dword_ED944[BYTE1(v371) + 512]
        ^ dword_ED944[BYTE2(v266) + 768]
        ^ v241;
    v77 = dword_ED944[BYTE1(v76) + 512] ^ dword_ED944[(unsigned __int8)v73] ^ dword_ED944[HIBYTE(v75) + 256];
    v249 = dword_ED944[HIBYTE(v74) + 256]
         ^ dword_ED944[(unsigned __int8)v75]
         ^ dword_ED944[BYTE1(v73) + 512]
         ^ dword_ED944[BYTE2(v76) + 768];
    v323 = dword_ED944[(unsigned __int8)v76]
         ^ dword_ED944[HIBYTE(v73) + 256]
         ^ dword_ED944[BYTE2(v75) + 768]
         ^ dword_ED944[BYTE1(v74) + 512];
    v251 = v77 ^ dword_ED944[BYTE2(v74) + 768];
    v325 = dword_ED944[HIBYTE(v76) + 256]
         ^ dword_ED944[(unsigned __int8)v74]
         ^ dword_ED944[BYTE1(v75) + 512]
         ^ dword_ED944[BYTE2(v73) + 768];
    if ( v242 == -10 && !++v240 )
    {
      v79 = v241 + 1;
      v78 = v241 == -1;
      if ( v241 == -1 )
        v77 = v243;
      ++v241;
      if ( v78 )
      {
        v240 = v79;
        v243 = v77 + 1;
      }
    }
    v80 = dword_ED944[BYTE1(v373) + 512]
        ^ dword_ED944[(unsigned __int8)v268]
        ^ dword_ED944[HIBYTE(v375) + 256]
        ^ (v242 + 10)
        ^ dword_ED944[BYTE2(v374) + 768];
    v81 = dword_ED944[(unsigned __int8)v375]
        ^ dword_ED944[HIBYTE(v374) + 256]
        ^ dword_ED944[BYTE1(v268) + 512]
        ^ dword_ED944[BYTE2(v373) + 768]
        ^ v243;
    v82 = dword_ED944[HIBYTE(v268) + 256]
        ^ dword_ED944[(unsigned __int8)v373]
        ^ dword_ED944[BYTE1(v374) + 512]
        ^ dword_ED944[BYTE2(v375) + 768]
        ^ v240;
    v83 = dword_ED944[(unsigned __int8)v374]
        ^ dword_ED944[HIBYTE(v373) + 256]
        ^ dword_ED944[BYTE1(v375) + 512]
        ^ dword_ED944[BYTE2(v268) + 768]
        ^ v241;
    v84 = dword_ED944[HIBYTE(v81) + 256] ^ dword_ED944[(unsigned __int8)v80] ^ dword_ED944[BYTE1(v82) + 512];
    v259 = dword_ED944[(unsigned __int8)v82]
         ^ dword_ED944[HIBYTE(v80) + 256]
         ^ dword_ED944[BYTE1(v83) + 512]
         ^ dword_ED944[BYTE2(v81) + 768];
    v261 = dword_ED944[(unsigned __int8)v83]
         ^ dword_ED944[HIBYTE(v82) + 256]
         ^ dword_ED944[BYTE2(v80) + 768]
         ^ dword_ED944[BYTE1(v81) + 512];
    v253 = v84 ^ dword_ED944[BYTE2(v83) + 768];
    v263 = dword_ED944[HIBYTE(v83) + 256]
         ^ dword_ED944[(unsigned __int8)v81]
         ^ dword_ED944[BYTE1(v80) + 512]
         ^ dword_ED944[BYTE2(v82) + 768];
    if ( v242 == -11 && !++v240 )
    {
      v86 = v241 + 1;
      v85 = v241 == -1;
      if ( v241 == -1 )
        v84 = v243;
      ++v241;
      if ( v85 )
      {
        v240 = v86;
        v243 = v84 + 1;
      }
    }
    v87 = dword_ED944[BYTE1(v376) + 512]
        ^ dword_ED944[(unsigned __int8)v270]
        ^ dword_ED944[HIBYTE(v378) + 256]
        ^ (v242 + 11)
        ^ dword_ED944[BYTE2(v377) + 768];
    v88 = dword_ED944[(unsigned __int8)v378]
        ^ dword_ED944[HIBYTE(v377) + 256]
        ^ dword_ED944[BYTE1(v270) + 512]
        ^ dword_ED944[BYTE2(v376) + 768]
        ^ v243;
    v89 = dword_ED944[HIBYTE(v376) + 256]
        ^ dword_ED944[(unsigned __int8)v377]
        ^ dword_ED944[BYTE1(v378) + 512]
        ^ dword_ED944[BYTE2(v270) + 768]
        ^ v241;
    v90 = dword_ED944[HIBYTE(v270) + 256]
        ^ dword_ED944[(unsigned __int8)v376]
        ^ dword_ED944[BYTE1(v377) + 512]
        ^ dword_ED944[BYTE2(v378) + 768]
        ^ v240;
    v91 = dword_ED944[HIBYTE(v89) + 256] ^ dword_ED944[(unsigned __int8)v88] ^ dword_ED944[BYTE1(v87) + 512];
    v296 = dword_ED944[(unsigned __int8)v89]
         ^ dword_ED944[HIBYTE(v90) + 256]
         ^ dword_ED944[BYTE2(v87) + 768]
         ^ dword_ED944[BYTE1(v88) + 512];
    v294 = dword_ED944[HIBYTE(v88) + 256]
         ^ dword_ED944[(unsigned __int8)v87]
         ^ dword_ED944[BYTE1(v90) + 512]
         ^ dword_ED944[BYTE2(v89) + 768];
    v295 = dword_ED944[(unsigned __int8)v90]
         ^ dword_ED944[HIBYTE(v87) + 256]
         ^ dword_ED944[BYTE1(v89) + 512]
         ^ dword_ED944[BYTE2(v88) + 768];
    v297 = v91 ^ dword_ED944[BYTE2(v90) + 768];
    if ( v242 == -12 && !++v240 )
    {
      v93 = v241 + 1;
      v92 = v241 == -1;
      if ( v241 == -1 )
        v91 = v243;
      ++v241;
      if ( v92 )
      {
        v240 = v93;
        v243 = v91 + 1;
      }
    }
    v94 = dword_ED944[BYTE1(v317) + 512]
        ^ dword_ED944[(unsigned __int8)v272]
        ^ dword_ED944[HIBYTE(v319) + 256]
        ^ (v242 + 12)
        ^ dword_ED944[BYTE2(v298) + 768];
    v95 = dword_ED944[(unsigned __int8)v319]
        ^ dword_ED944[HIBYTE(v298) + 256]
        ^ dword_ED944[BYTE1(v272) + 512]
        ^ dword_ED944[BYTE2(v317) + 768]
        ^ v243;
    v96 = dword_ED944[HIBYTE(v317) + 256]
        ^ dword_ED944[(unsigned __int8)v298]
        ^ dword_ED944[BYTE1(v319) + 512]
        ^ dword_ED944[BYTE2(v272) + 768]
        ^ v241;
    v97 = dword_ED944[HIBYTE(v272) + 256]
        ^ dword_ED944[(unsigned __int8)v317]
        ^ dword_ED944[BYTE1(v298) + 512]
        ^ dword_ED944[BYTE2(v319) + 768]
        ^ v240;
    v98 = dword_ED944[HIBYTE(v96) + 256] ^ dword_ED944[(unsigned __int8)v95] ^ dword_ED944[BYTE1(v94) + 512];
    v320 = dword_ED944[(unsigned __int8)v96]
         ^ dword_ED944[HIBYTE(v97) + 256]
         ^ dword_ED944[BYTE2(v94) + 768]
         ^ dword_ED944[BYTE1(v95) + 512];
    v273 = dword_ED944[HIBYTE(v95) + 256]
         ^ dword_ED944[(unsigned __int8)v94]
         ^ dword_ED944[BYTE1(v97) + 512]
         ^ dword_ED944[BYTE2(v96) + 768];
    v318 = dword_ED944[(unsigned __int8)v97]
         ^ dword_ED944[HIBYTE(v94) + 256]
         ^ dword_ED944[BYTE1(v96) + 512]
         ^ dword_ED944[BYTE2(v95) + 768];
    v321 = v98 ^ dword_ED944[BYTE2(v97) + 768];
    if ( v242 == -13 && !++v240 )
    {
      v100 = v241 + 1;
      v99 = v241 == -1;
      if ( v241 == -1 )
        v98 = v243;
      ++v241;
      if ( v99 )
      {
        v240 = v100;
        v243 = v98 + 1;
      }
    }
    v101 = dword_ED944[BYTE1(v327) + 512]
         ^ dword_ED944[(unsigned __int8)v274]
         ^ dword_ED944[HIBYTE(v331) + 256]
         ^ (v242 + 13)
         ^ dword_ED944[BYTE2(v329) + 768];
    v102 = dword_ED944[(unsigned __int8)v331]
         ^ dword_ED944[HIBYTE(v329) + 256]
         ^ dword_ED944[BYTE1(v274) + 512]
         ^ dword_ED944[BYTE2(v327) + 768]
         ^ v243;
    v103 = dword_ED944[HIBYTE(v327) + 256]
         ^ dword_ED944[(unsigned __int8)v329]
         ^ dword_ED944[BYTE1(v331) + 512]
         ^ dword_ED944[BYTE2(v274) + 768]
         ^ v241;
    v104 = dword_ED944[HIBYTE(v274) + 256]
         ^ dword_ED944[(unsigned __int8)v327]
         ^ dword_ED944[BYTE1(v329) + 512]
         ^ dword_ED944[BYTE2(v331) + 768]
         ^ v240;
    v105 = dword_ED944[HIBYTE(v103) + 256] ^ dword_ED944[(unsigned __int8)v102] ^ dword_ED944[BYTE1(v101) + 512];
    v368 = dword_ED944[(unsigned __int8)v104]
         ^ dword_ED944[HIBYTE(v101) + 256]
         ^ dword_ED944[BYTE1(v103) + 512]
         ^ dword_ED944[BYTE2(v102) + 768];
    v265 = dword_ED944[HIBYTE(v102) + 256]
         ^ dword_ED944[(unsigned __int8)v101]
         ^ dword_ED944[BYTE1(v104) + 512]
         ^ dword_ED944[BYTE2(v103) + 768];
    v370 = dword_ED944[(unsigned __int8)v103]
         ^ dword_ED944[HIBYTE(v104) + 256]
         ^ dword_ED944[BYTE2(v101) + 768]
         ^ dword_ED944[BYTE1(v102) + 512];
    v372 = v105 ^ dword_ED944[BYTE2(v104) + 768];
    if ( v242 == -14 && !++v240 )
    {
      v107 = v241 + 1;
      v106 = v241 == -1;
      if ( v241 == -1 )
        v105 = v243;
      ++v241;
      if ( v106 )
      {
        v240 = v107;
        v243 = v105 + 1;
      }
    }
    v108 = dword_ED944[BYTE1(v379) + 512]
         ^ dword_ED944[(unsigned __int8)v277]
         ^ dword_ED944[HIBYTE(v382) + 256]
         ^ (v242 + 14)
         ^ dword_ED944[BYTE2(v381) + 768];
    v109 = dword_ED944[(unsigned __int8)v382]
         ^ dword_ED944[HIBYTE(v381) + 256]
         ^ dword_ED944[BYTE1(v277) + 512]
         ^ dword_ED944[BYTE2(v379) + 768]
         ^ v243;
    v110 = dword_ED944[HIBYTE(v379) + 256]
         ^ dword_ED944[(unsigned __int8)v381]
         ^ dword_ED944[BYTE1(v382) + 512]
         ^ dword_ED944[BYTE2(v277) + 768]
         ^ v241;
    v111 = dword_ED944[HIBYTE(v277) + 256]
         ^ dword_ED944[(unsigned __int8)v379]
         ^ dword_ED944[BYTE1(v381) + 512]
         ^ dword_ED944[BYTE2(v382) + 768]
         ^ v240;
    v112 = dword_ED944[(unsigned __int8)v111] ^ dword_ED944[HIBYTE(v108) + 256] ^ dword_ED944[BYTE1(v110) + 512];
    v113 = dword_ED944[HIBYTE(v110) + 256] ^ dword_ED944[(unsigned __int8)v109] ^ dword_ED944[BYTE1(v108) + 512];
    v114 = dword_ED944[BYTE2(v111) + 768];
    v115 = dword_ED944[BYTE2(v108) + 768] ^ dword_ED944[(unsigned __int8)v110] ^ dword_ED944[HIBYTE(v111) + 256];
    v116 = dword_ED944[HIBYTE(v109) + 256] ^ dword_ED944[(unsigned __int8)v108] ^ dword_ED944[BYTE1(v111) + 512];
    v117 = v242 + 15;
    v271 = v115 ^ dword_ED944[BYTE1(v109) + 512];
    v267 = v116 ^ dword_ED944[BYTE2(v110) + 768];
    v269 = v112 ^ dword_ED944[BYTE2(v109) + 768];
    v275 = v113 ^ v114;
    if ( v242 == -15 && !++v240 )
    {
      v119 = v241 + 1;
      v118 = v241 == -1;
      if ( v241 == -1 )
        v113 = v243;
      ++v241;
      if ( v118 )
      {
        v240 = v119;
        v243 = v113 + 1;
      }
    }
    v43 = v242 == -16;
    v242 += 16;
    v120 = dword_ED944[(unsigned __int8)v279]
         ^ dword_ED944[HIBYTE(v385) + 256]
         ^ v117
         ^ dword_ED944[BYTE1(v383) + 512]
         ^ dword_ED944[BYTE2(v384) + 768];
    v121 = dword_ED944[BYTE1(v384) + 512]
         ^ dword_ED944[HIBYTE(v279) + 256]
         ^ dword_ED944[(unsigned __int8)v383]
         ^ dword_ED944[BYTE2(v385) + 768]
         ^ v240;
    v122 = dword_ED944[HIBYTE(v384) + 256]
         ^ dword_ED944[(unsigned __int8)v385]
         ^ dword_ED944[BYTE1(v279) + 512]
         ^ dword_ED944[BYTE2(v383) + 768]
         ^ v243;
    v123 = dword_ED944[HIBYTE(v383) + 256]
         ^ dword_ED944[(unsigned __int8)v384]
         ^ dword_ED944[BYTE1(v385) + 512]
         ^ dword_ED944[BYTE2(v279) + 768]
         ^ v241;
    v124 = dword_ED944[(unsigned __int8)v122] ^ dword_ED944[HIBYTE(v123) + 256] ^ dword_ED944[BYTE1(v120) + 512];
    v299 = dword_ED944[BYTE1(v123) + 512]
         ^ dword_ED944[HIBYTE(v120) + 256]
         ^ dword_ED944[(unsigned __int8)v121]
         ^ dword_ED944[BYTE2(v122) + 768];
    v346 = v124 ^ dword_ED944[BYTE2(v121) + 768];
    v125 = dword_ED944[HIBYTE(v122) + 256]
         ^ dword_ED944[(unsigned __int8)v120]
         ^ dword_ED944[BYTE1(v121) + 512]
         ^ dword_ED944[BYTE2(v123) + 768];
    v332 = dword_ED944[HIBYTE(v121) + 256]
         ^ dword_ED944[(unsigned __int8)v123]
         ^ dword_ED944[BYTE2(v120) + 768]
         ^ dword_ED944[BYTE1(v122) + 512];
    if ( v43 && !++v240 )
    {
      v127 = v241 + 1;
      v126 = v241 == -1;
      if ( v241 == -1 )
        v124 = v243;
      ++v241;
      if ( v126 )
      {
        v240 = v127;
        v243 = v124 + 1;
      }
    }
    v128 = v282 ^ v304;
    v129 = v244;
    v130 = v301 ^ v335;
    v131 = v304 ^ v259;
    v305 = v335 ^ v261;
    v132 = v244 & (v128 >> 7);
    v351 = v306 ^ v247;
    v133 = (27 * (v244 & ((v280 ^ (unsigned int)v255) >> 7))) ^ (2 * (v280 ^ v255)) & 0xFEFEFEFE;
    v353 = v247 ^ v263;
    v134 = v244 & ((v255 ^ (unsigned int)v253) >> 7);
    v355 = v257 ^ v249;
    v357 = v249 ^ v267;
    v359 = v308 ^ v251;
    v361 = v251 ^ v269;
    v245 = v310 ^ v323;
    v278 = v312 ^ v325;
    v135 = v280 ^ v255 ^ v133;
    v136 = v280 ^ v255 ^ v125;
    v246 = v133 ^ v255 ^ v253 ^ v125;
    v137 = v129;
    v138 = v129 & ((v301 ^ (unsigned int)v335) >> 7);
    v139 = v137;
    v140 = (2 * (v255 ^ v253)) & 0xFEFEFEFE ^ (27 * v134);
    v248 = v140 ^ v280 ^ v253 ^ v125;
    v141 = (2 * (v253 ^ v125)) & 0xFEFEFEFE ^ (27 * (v137 & ((v253 ^ (unsigned int)v125) >> 7)));
    v254 = v135 ^ v253 ^ v140 ^ v141;
    v250 = v136 ^ v141;
    v142 = (27 * v132) ^ (2 * v128) & 0xFEFEFEFE;
    v334 = v299 ^ v142 ^ v131;
    v328 = v337 ^ v290;
    v143 = (2 * v131) & 0xFEFEFEFE ^ (27 * (v137 & (v131 >> 7)));
    v380 = v337 ^ v273;
    v340 = v143 ^ v282 ^ v259 ^ v299;
    v144 = (2 * (v259 ^ v299)) & 0xFEFEFEFE ^ (27 * (v137 & ((v259 ^ (unsigned int)v299) >> 7)));
    v330 = v339 ^ v291;
    v252 = v128 ^ v299 ^ v144;
    v145 = (27 * v138) ^ (2 * v130) & 0xFEFEFEFE;
    v349 = v128 ^ v142 ^ v259 ^ v143 ^ v144;
    v146 = v130 ^ v145 ^ v261;
    v281 = v339 ^ v318;
    v147 = v261 ^ v332;
    v148 = v130 ^ v332;
    v336 = v145 ^ v305 ^ v332;
    v149 = (2 * v305) & 0xFEFEFEFE ^ (27 * (v139 & (v305 >> 7)));
    v333 = v342 ^ v292;
    v300 = v342 ^ v320;
    v150 = v351;
    v151 = (27 * (v139 & (v147 >> 7))) ^ (2 * v147) & 0xFEFEFEFE;
    v341 = v149 ^ v301 ^ v147;
    v152 = v148 ^ v151;
    v350 = v146 ^ v149 ^ v151;
    v153 = v139 & (v353 >> 7);
    v154 = v346;
    v345 = v152;
    v155 = v139;
    v156 = v263 ^ v154;
    v157 = (27 * (v139 & (v150 >> 7))) ^ (2 * v150) & 0xFEFEFEFE;
    v158 = v154 ^ v150;
    v338 = v157 ^ v353 ^ v154;
    v159 = v344;
    v160 = (2 * v353) & 0xFEFEFEFE ^ (27 * v153);
    v302 = v344 ^ v293;
    v343 = v160 ^ v306 ^ v263 ^ v154;
    v283 = v159 ^ v321;
    v161 = v348;
    v162 = (2 * v156) & 0xFEFEFEFE ^ (27 * (v155 & (v156 >> 7)));
    v163 = v348 ^ v267;
    v303 = v150 ^ v157 ^ v263 ^ v160 ^ v162;
    v347 = v158 ^ v162;
    v164 = v257 ^ v163;
    v165 = (27 * (v155 & (v355 >> 7))) ^ (2 * v355) & 0xFEFEFEFE;
    v166 = v355 ^ v165 ^ v267;
    v256 = v161 ^ v165 ^ v357;
    v167 = v155;
    v168 = (2 * v357) & 0xFEFEFEFE ^ (27 * (v155 & (v357 >> 7)));
    v258 = v164 ^ v168;
    v169 = v308;
    v170 = (2 * v163) & 0xFEFEFEFE ^ (27 * (v155 & (v163 >> 7)));
    v260 = v161 ^ v355 ^ v170;
    v171 = (27 * (v155 & (v359 >> 7))) ^ (2 * v359) & 0xFEFEFEFE;
    v262 = v166 ^ v168 ^ v170;
    v307 = v386 ^ v171 ^ v361;
    v172 = v155 & ((v312 ^ (unsigned int)v325) >> 7);
    v173 = (2 * v361) & 0xFEFEFEFE ^ (27 * (v155 & (v361 >> 7)));
    v174 = v359 ^ v171 ^ v269 ^ v173;
    v352 = v169 ^ v386 ^ v269 ^ v173;
    v175 = v155;
    v176 = (2 * (v386 ^ v269)) & 0xFEFEFEFE ^ (27 * (v155 & ((v386 ^ (unsigned int)v269) >> 7)));
    v364 = v174 ^ v176;
    v358 = v386 ^ v359 ^ v176;
    v177 = v310 ^ v387 ^ v271;
    v178 = (27 * (v167 & ((v310 ^ (unsigned int)v323) >> 7))) ^ (2 * (v310 ^ v323)) & 0xFEFEFEFE;
    v179 = v310 ^ v323 ^ v178;
    v309 = v178 ^ v387 ^ v323 ^ v271;
    v180 = (2 * (v323 ^ v271)) & 0xFEFEFEFE ^ (27 * (v175 & ((v323 ^ (unsigned int)v271) >> 7)));
    v181 = v175 & ((v287 ^ (unsigned int)v315) >> 7);
    v182 = (2 * (v387 ^ v271)) & 0xFEFEFEFE ^ (27 * (v175 & ((v387 ^ (unsigned int)v271) >> 7)));
    v354 = v177 ^ v180;
    v365 = v179 ^ v271 ^ v180 ^ v182;
    v360 = v387 ^ v245 ^ v182;
    v183 = (27 * v172) ^ (2 * (v312 ^ v325)) & 0xFEFEFEFE;
    v184 = v312 ^ v289 ^ v275;
    v185 = v312 ^ v325 ^ v183;
    v311 = v289 ^ v183 ^ v325 ^ v275;
    v186 = v175 & ((v288 ^ (unsigned int)v316) >> 7);
    v187 = (27 * (v175 & ((v325 ^ (unsigned int)v275) >> 7))) ^ (2 * (v325 ^ v275)) & 0xFEFEFEFE;
    v356 = v184 ^ v187;
    v188 = v363;
    v189 = (2 * (v289 ^ v275)) & 0xFEFEFEFE ^ (27 * (v175 & ((v289 ^ (unsigned int)v275) >> 7)));
    v366 = v185 ^ v275 ^ v187 ^ v189;
    v276 = v175 & (v328 >> 7);
    v362 = v289 ^ v278 ^ v189;
    v190 = v284 ^ v265;
    v191 = v188 ^ v284 ^ v313;
    v192 = (27 * (v167 & ((v284 ^ (unsigned int)v313) >> 7))) ^ (2 * (v284 ^ v313)) & 0xFEFEFEFE;
    v193 = v284 ^ v192 ^ v188 ^ v265;
    v194 = v313 ^ v284 ^ v265;
    v285 = v175 & (v330 >> 7);
    v268 = v192 ^ v313 ^ v188 ^ v265;
    v195 = v175;
    v196 = (27 * (v175 & ((v188 ^ (unsigned int)v265) >> 7))) ^ (2 * (v188 ^ v265)) & 0xFEFEFEFE;
    v264 = v194 ^ v196;
    v197 = (27 * (v175 & (v190 >> 7))) ^ (2 * v190) & 0xFEFEFEFE;
    v270 = v193 ^ v196 ^ v197;
    v266 = v191 ^ v197;
    v198 = (2 * (v286 ^ v314)) & 0xFEFEFEFE ^ (27 * (v175 & ((v286 ^ (unsigned int)v314) >> 7)));
    v373 = v314 ^ v198 ^ v388 ^ v368;
    v199 = (2 * (v388 ^ v368)) & 0xFEFEFEFE ^ (27 * (v175 & ((v388 ^ (unsigned int)v368) >> 7)));
    v322 = v314 ^ v286 ^ v368 ^ v199;
    v200 = v286 ^ v198 ^ v388 ^ v368 ^ v199;
    v201 = (27 * (v195 & ((v286 ^ (unsigned int)v368) >> 7))) ^ (2 * (v286 ^ v368)) & 0xFEFEFEFE;
    v244 = v195;
    v367 = v388 ^ v286 ^ v314 ^ v201;
    v376 = v200 ^ v201;
    v202 = (2 * (v287 ^ v315)) & 0xFEFEFEFE ^ (27 * v181);
    v203 = v287 ^ v202 ^ v389 ^ v370;
    v374 = v315 ^ v202 ^ v389 ^ v370;
    v204 = (2 * (v389 ^ v370)) & 0xFEFEFEFE ^ (27 * (v195 & ((v389 ^ (unsigned int)v370) >> 7)));
    v324 = v315 ^ v287 ^ v370 ^ v204;
    v205 = (27 * (v195 & ((v287 ^ (unsigned int)v370) >> 7))) ^ (2 * (v287 ^ v370)) & 0xFEFEFEFE;
    v369 = v389 ^ v287 ^ v315 ^ v205;
    v377 = v203 ^ v204 ^ v205;
    v206 = (2 * (v288 ^ v316)) & 0xFEFEFEFE ^ (27 * v186);
    v207 = (2 * (v390 ^ v372)) & 0xFEFEFEFE ^ (27 * (v195 & ((v390 ^ (unsigned int)v372) >> 7)));
    v375 = v206 ^ v316 ^ v390 ^ v372;
    v326 = v316 ^ v288 ^ v372 ^ v207;
    v208 = (2 * (v288 ^ v372)) & 0xFEFEFEFE ^ (27 * (v195 & ((v288 ^ (unsigned int)v372) >> 7)));
    v378 = v288 ^ v206 ^ v390 ^ v372 ^ v207 ^ v208;
    v371 = v390 ^ v288 ^ v316 ^ v208;
    v209 = (27 * v276) ^ (2 * v328) & 0xFEFEFEFE;
    v274 = v209 ^ v290 ^ v294 ^ v273;
    v210 = (2 * (v290 ^ v294)) & 0xFEFEFEFE ^ (27 * (v195 & ((v290 ^ (unsigned int)v294) >> 7)));
    v211 = v290 ^ v209 ^ v210;
    v277 = v210 ^ v294 ^ v380;
    v212 = (27 * (v195 & (v380 >> 7))) ^ (2 * v380) & 0xFEFEFEFE;
    v279 = v211 ^ v380 ^ v212;
    v272 = v294 ^ v328 ^ v212;
    v213 = (27 * v285) ^ (2 * v330) & 0xFEFEFEFE;
    v327 = v213 ^ v291 ^ v295 ^ v318;
    v214 = (2 * (v291 ^ v295)) & 0xFEFEFEFE ^ (27 * (v195 & ((v291 ^ (unsigned int)v295) >> 7)));
    v379 = v214 ^ v295 ^ v281;
    v215 = (27 * (v195 & (v281 >> 7))) ^ (2 * v281) & 0xFEFEFEFE;
    v383 = v291 ^ v213 ^ v214 ^ v281 ^ v215;
    v317 = v295 ^ v330 ^ v215;
    v216 = (27 * (v195 & (v333 >> 7))) ^ (2 * v333) & 0xFEFEFEFE;
    v217 = (27 * (v195 & ((v292 ^ (unsigned int)v296) >> 7))) ^ (2 * (v292 ^ v296)) & 0xFEFEFEFE;
    v218 = (27 * (v195 & (v302 >> 7))) ^ (2 * v302) & 0xFEFEFEFE;
    v219 = (27 * (v195 & ((v293 ^ (unsigned int)v297) >> 7))) ^ (2 * (v293 ^ v297)) & 0xFEFEFEFE;
    v329 = v216 ^ v292 ^ v296 ^ v320;
    v220 = (27 * (v195 & (v283 >> 7))) ^ (2 * v283) & 0xFEFEFEFE;
    v221 = (27 * (v195 & (v300 >> 7))) ^ (2 * v300) & 0xFEFEFEFE;
    v381 = v296 ^ v217 ^ v300;
    v384 = v292 ^ v216 ^ v217 ^ v300 ^ v221;
    v298 = v296 ^ v333 ^ v221;
    v331 = v218 ^ v293 ^ v297 ^ v321;
    v382 = v219 ^ v297 ^ v283;
    v385 = v293 ^ v218 ^ v219 ^ v283 ^ v220;
    v319 = v297 ^ v302 ^ v220;
  }
  while ( v242 != v391 );
  result = v425;
  v223 = v246;
  v224 = &dest[31];
  dest[1] = v334;
  dest[0] = v246;
  v225 = a1 - 1;
  v226 = a1 + 33;
  dest[2] = v336;
  dest[3] = v338;
  dest[4] = v248;
  dest[5] = v340;
  dest[6] = v341;
  dest[7] = v343;
  dest[8] = v250;
  dest[9] = v252;
  dest[10] = v345;
  dest[11] = v347;
  dest[12] = v254;
  dest[13] = v349;
  dest[14] = v350;
  dest[15] = v303;
  dest[16] = v256;
  dest[17] = v307;
  dest[18] = v309;
  dest[19] = v311;
  dest[20] = v258;
  dest[21] = v352;
  dest[22] = v354;
  dest[23] = v356;
  dest[24] = v260;
  dest[25] = v358;
  dest[26] = v360;
  dest[27] = v362;
  dest[28] = v262;
  dest[29] = v364;
  dest[30] = v365;
  dest[31] = v366;
  v394 = v264;
  v395 = v322;
  v396 = v324;
  v397 = v326;
  v398 = v266;
  v399 = v367;
  v400 = v389 ^ v287 ^ v315 ^ v205;
  v401 = v371;
  v402 = v268;
  v403 = v373;
  v404 = v374;
  v405 = v375;
  v406 = v270;
  v407 = v376;
  v408 = v377;
  v409 = v378;
  v410 = v272;
  v411 = v317;
  v412 = v298;
  v413 = v319;
  v414 = v274;
  v415 = v327;
  v416 = v329;
  v417 = v331;
  v418 = v277;
  v419 = v379;
  v420 = v381;
  v421 = v382;
  v422 = v279;
  v423 = v383;
  v424 = v384;
  v425[0] = v385;
  while ( 1 )
  {
    v228 = v224[1];
    ++v224;
    v227 = v228;
    v230 = v225[1];
    ++v225;
    v229 = v230;
    v231 = v226[1];
    *++v226 = v227 ^ v229 ^ v231 ^ v223;
    if ( v425 == v224 )
      break;
    v223 = *(v224 - 31);
  }
  return result;
}
// ED944: using guessed type _DWORD dword_ED944[1025];

//----- (000A759C) --------------------------------------------------------
unsigned int *__fastcall sph_echo384_0(unsigned int *result, char *src, size_t n)
{
  unsigned int *v3; // r7
  unsigned int v4; // r5
  size_t v5; // r6
  size_t v6; // r4
  char *v7; // r8
  char *v8; // r0
  bool v9; // cf
  int v10; // r3
  int v11; // r3

  v3 = result;
  v4 = result[32];
  v5 = n;
  v6 = 128 - v4;
  if ( 128 - v4 > n )
  {
    result = (unsigned int *)memcpy((char *)result + v4, src, n);
    v3[32] = v4 + v5;
  }
  else
  {
    v7 = src;
    if ( n )
    {
      do
      {
        while ( 1 )
        {
          if ( v6 >= v5 )
            v6 = v5;
          v8 = (char *)v3 + v4;
          v4 += v6;
          result = (unsigned int *)memcpy(v8, v7, v6);
          v5 -= v6;
          v7 += v6;
          if ( v4 == 128 )
            break;
          v6 = 128 - v4;
          if ( !v5 )
            goto LABEL_13;
        }
        v4 = 0;
        v9 = v3[66] < 0xFFFFFC00;
        v3[66] += 1024;
        if ( !v9 )
        {
          v10 = v3[67] + 1;
          v3[67] = v10;
          if ( !v10 )
          {
            v11 = v3[68] + 1;
            v3[68] = v11;
            if ( !v11 )
              ++v3[69];
          }
        }
        result = sub_A40FC(v3);
        v6 = 128;
      }
      while ( v5 );
    }
LABEL_13:
    v3[32] = v4;
  }
  return result;
}

//----- (000A7678) --------------------------------------------------------
void *__fastcall sub_A7678(int a1, char a2, int a3, void *a4, int a5)
{
  int v5; // r12
  int v7; // r0
  int v9; // r3
  int v10; // r6
  bool v11; // cf
  int v12; // r0
  int v13; // r8
  int v14; // lr
  bool v15; // zf
  int v16; // lr
  unsigned int v17; // r6
  int v18; // r6
  int v19; // r0
  int v20; // r1
  int v21; // r2
  int v22; // r3
  int v23; // r3
  int *v24; // r1
  int v25; // t1
  void *result; // r0
  int v27; // [sp+0h] [bp-20h] BYREF
  int v28; // [sp+4h] [bp-1Ch]
  int v29; // [sp+8h] [bp-18h]
  int v30; // [sp+Ch] [bp-14h]

  v5 = *(_DWORD *)(a1 + 192);
  v7 = *(_DWORD *)(a1 + 264);
  v9 = a3 + 8 * v5;
  v10 = *(_DWORD *)(a1 + 272);
  v11 = __CFADD__(v7, v9);
  v12 = v7 + v9;
  v13 = *(_DWORD *)(a1 + 276);
  v14 = v11;
  v15 = v14 == 0;
  *(_DWORD *)(a1 + 264) = v12;
  v16 = *(_DWORD *)(a1 + 268);
  if ( v15 )
  {
    v27 = v12;
    v28 = v16;
    v29 = v10;
    v30 = v13;
    if ( !v9 )
    {
      *(_DWORD *)(a1 + 276) = 0;
      *(_DWORD *)(a1 + 272) = 0;
      *(_DWORD *)(a1 + 268) = 0;
      *(_DWORD *)(a1 + 264) = 0;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 268) = v16 + 1;
    if ( v16 == -1 )
    {
      *(_DWORD *)(a1 + 272) = ++v10;
      if ( !v10 )
        *(_DWORD *)(a1 + 276) = ++v13;
    }
    v27 = v12;
    v28 = v16 + 1;
    v29 = v10;
    v30 = v13;
  }
  v17 = v5 + 1;
  *(_BYTE *)(a1 + v5) = (128 >> a3) | a2 & -(128 >> a3);
  memset((void *)(a1 + v5 + 1), 0, 191 - v5);
  if ( v17 > 0xAE )
  {
    sub_A0B2C((unsigned int *)a1);
    *(_DWORD *)(a1 + 276) = 0;
    *(_DWORD *)(a1 + 272) = 0;
    *(_DWORD *)(a1 + 268) = 0;
    *(_DWORD *)(a1 + 264) = 0;
    memset((void *)a1, 0, 0xC0u);
  }
  v18 = 32 * a5;
  v19 = v27;
  v20 = v28;
  v21 = v29;
  v22 = v30;
  *(_WORD *)(a1 + 174) = 32 * a5;
  *(_DWORD *)(a1 + 176) = v19;
  *(_DWORD *)(a1 + 180) = v20;
  *(_DWORD *)(a1 + 184) = v21;
  *(_DWORD *)(a1 + 188) = v22;
  sub_A0B2C((unsigned int *)a1);
  v23 = a1 + 196;
  v24 = &v27 - 1;
  do
  {
    v25 = *(_DWORD *)(v23 + 4);
    v23 += 4;
    v24[1] = v25;
    ++v24;
  }
  while ( a1 + 4 * a5 + 196 != v23 );
  result = memcpy(a4, &v27, 4 * a5);
  *(_DWORD *)(a1 + 200) = v18;
  *(_DWORD *)(a1 + 216) = v18;
  *(_DWORD *)(a1 + 232) = v18;
  *(_DWORD *)(a1 + 248) = v18;
  *(_DWORD *)(a1 + 212) = 0;
  *(_DWORD *)(a1 + 208) = 0;
  *(_DWORD *)(a1 + 204) = 0;
  *(_DWORD *)(a1 + 228) = 0;
  *(_DWORD *)(a1 + 224) = 0;
  *(_DWORD *)(a1 + 220) = 0;
  *(_DWORD *)(a1 + 244) = 0;
  *(_DWORD *)(a1 + 240) = 0;
  *(_DWORD *)(a1 + 236) = 0;
  *(_DWORD *)(a1 + 260) = 0;
  *(_DWORD *)(a1 + 256) = 0;
  *(_DWORD *)(a1 + 252) = 0;
  *(_DWORD *)(a1 + 192) = 0;
  *(_DWORD *)(a1 + 276) = 0;
  *(_DWORD *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 268) = 0;
  *(_DWORD *)(a1 + 264) = 0;
  return result;
}

//----- (000A7834) --------------------------------------------------------
_DWORD *__fastcall sub_A7834(int a1, char a2, int a3, void *a4, int a5)
{
  int v5; // r12
  int v7; // r0
  int v9; // r3
  int v10; // r7
  bool v11; // cf
  int v12; // r0
  int v13; // r8
  int v14; // lr
  bool v15; // zf
  int v16; // lr
  unsigned int v17; // r8
  int v18; // r0
  int v19; // r1
  int v20; // r2
  int v21; // r3
  int *v22; // r3
  int *v23; // r1
  int v24; // t1
  int v26; // [sp+0h] [bp-40h] BYREF
  int v27; // [sp+4h] [bp-3Ch]
  int v28; // [sp+8h] [bp-38h]
  int v29; // [sp+Ch] [bp-34h]

  v5 = *(_DWORD *)(a1 + 128);
  v7 = *(_DWORD *)(a1 + 264);
  v9 = a3 + 8 * v5;
  v10 = *(_DWORD *)(a1 + 272);
  v11 = __CFADD__(v7, v9);
  v12 = v7 + v9;
  v13 = *(_DWORD *)(a1 + 276);
  v14 = v11;
  v15 = v14 == 0;
  *(_DWORD *)(a1 + 264) = v12;
  v16 = *(_DWORD *)(a1 + 268);
  if ( v15 )
  {
    v26 = v12;
    v27 = v16;
    v28 = v10;
    v29 = v13;
    if ( !v9 )
    {
      *(_DWORD *)(a1 + 276) = 0;
      *(_DWORD *)(a1 + 272) = 0;
      *(_DWORD *)(a1 + 268) = 0;
      *(_DWORD *)(a1 + 264) = 0;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 268) = v16 + 1;
    if ( v16 == -1 )
    {
      *(_DWORD *)(a1 + 272) = ++v10;
      if ( !v10 )
        *(_DWORD *)(a1 + 276) = ++v13;
    }
    v26 = v12;
    v27 = v16 + 1;
    v28 = v10;
    v29 = v13;
  }
  v17 = v5 + 1;
  *(_BYTE *)(a1 + v5) = (128 >> a3) | a2 & -(128 >> a3);
  memset((void *)(a1 + v5 + 1), 0, 127 - v5);
  if ( v17 > 0x6E )
  {
    sub_A40FC((unsigned int *)a1);
    *(_DWORD *)(a1 + 276) = 0;
    *(_DWORD *)(a1 + 272) = 0;
    *(_DWORD *)(a1 + 268) = 0;
    *(_DWORD *)(a1 + 264) = 0;
    memset((void *)a1, 0, 0x80u);
  }
  v18 = v26;
  v19 = v27;
  v20 = v28;
  v21 = v29;
  *(_WORD *)(a1 + 110) = 32 * a5;
  *(_DWORD *)(a1 + 112) = v18;
  *(_DWORD *)(a1 + 116) = v19;
  *(_DWORD *)(a1 + 120) = v20;
  *(_DWORD *)(a1 + 124) = v21;
  sub_A40FC((unsigned int *)a1);
  v22 = (int *)(a1 + 136);
  v23 = &v26;
  do
  {
    v24 = *v22++;
    *v23++ = v24;
  }
  while ( (int *)(4 * a5 + a1 + 136) != v22 );
  memcpy(a4, &v26, 4 * a5);
  return sub_A0A90((_DWORD *)a1, 32 * a5);
}

//----- (000A79A0) --------------------------------------------------------
_DWORD *__fastcall sph_echo224_init(_DWORD *result)
{
  result[50] = 224;
  result[54] = 224;
  result[58] = 224;
  result[62] = 224;
  result[53] = 0;
  result[52] = 0;
  result[51] = 0;
  result[57] = 0;
  result[56] = 0;
  result[55] = 0;
  result[61] = 0;
  result[60] = 0;
  result[59] = 0;
  result[65] = 0;
  result[64] = 0;
  result[63] = 0;
  result[48] = 0;
  result[69] = 0;
  result[68] = 0;
  result[67] = 0;
  result[66] = 0;
  return result;
}

//----- (000A7A04) --------------------------------------------------------
void *__fastcall sph_echo224_close(int a1, void *a2)
{
  return sub_A7678(a1, 0, 0, a2, 7);
}

//----- (000A7A2C) --------------------------------------------------------
void *__fastcall sph_echo224_addbits_and_close(int a1, char a2, int a3, void *a4)
{
  return sub_A7678(a1, a2, a3, a4, 7);
}

//----- (000A7A48) --------------------------------------------------------
_DWORD *__fastcall sph_echo256_init(_DWORD *result)
{
  result[50] = 256;
  result[54] = 256;
  result[58] = 256;
  result[62] = 256;
  result[53] = 0;
  result[52] = 0;
  result[51] = 0;
  result[57] = 0;
  result[56] = 0;
  result[55] = 0;
  result[61] = 0;
  result[60] = 0;
  result[59] = 0;
  result[65] = 0;
  result[64] = 0;
  result[63] = 0;
  result[48] = 0;
  result[69] = 0;
  result[68] = 0;
  result[67] = 0;
  result[66] = 0;
  return result;
}

//----- (000A7AAC) --------------------------------------------------------
void *__fastcall sph_echo256_close(int a1, void *a2)
{
  return sub_A7678(a1, 0, 0, a2, 8);
}

//----- (000A7AD4) --------------------------------------------------------
void *__fastcall sph_echo256_addbits_and_close(int a1, char a2, int a3, void *a4)
{
  return sub_A7678(a1, a2, a3, a4, 8);
}

//----- (000A7AF0) --------------------------------------------------------
_DWORD *__fastcall sph_echo384_init(_DWORD *a1)
{
  return sub_A0A90(a1, 384);
}

//----- (000A7AFC) --------------------------------------------------------
_DWORD *__fastcall sph_echo384_close(int a1, void *a2)
{
  return sub_A7834(a1, 0, 0, a2, 12);
}

//----- (000A7B24) --------------------------------------------------------
_DWORD *__fastcall sph_echo384_addbits_and_close(int a1, char a2, int a3, void *a4)
{
  return sub_A7834(a1, a2, a3, a4, 12);
}

//----- (000A7B40) --------------------------------------------------------
_DWORD *__fastcall sph_echo512_init(_DWORD *a1)
{
  return sub_A0A90(a1, 512);
}

//----- (000A7B4C) --------------------------------------------------------
_DWORD *__fastcall sph_echo512_close(int a1, void *a2)
{
  return sub_A7834(a1, 0, 0, a2, 16);
}

//----- (000A7B74) --------------------------------------------------------
_DWORD *__fastcall sph_echo512_addbits_and_close(int a1, char a2, int a3, void *a4)
{
  return sub_A7834(a1, a2, a3, a4, 16);
}

//----- (000A7B90) --------------------------------------------------------
void *__fastcall sph_groestl224_0(_DWORD *a1, char *a2, size_t a3)
{
  int v3; // r8
  _BYTE *v4; // r6
  int *v5; // r7
  int *v6; // r12
  int v7; // r0
  int v8; // r1
  _DWORD *v9; // lr
  int v10; // r2
  int v11; // r3
  size_t i; // r4
  char *v13; // r0
  int *v14; // r12
  _BYTE *v15; // r0
  int *v16; // r1
  _DWORD *v17; // r3
  int v18; // r6
  int v19; // t1
  int v20; // t1
  int v21; // r4
  int v22; // r2
  int v23; // lr
  int v24; // r11
  int v25; // r3
  unsigned int v26; // r6
  unsigned int v27; // r4
  int v28; // r0
  unsigned int v29; // r5
  int v30; // r9
  unsigned int v31; // r3
  unsigned int v32; // r2
  int v33; // r10
  char *v34; // r4
  char *v35; // lr
  int v36; // r12
  int v37; // r0
  int v38; // r9
  int v39; // r12
  int v40; // r11
  int *v41; // r10
  int v42; // r12
  int v43; // r10
  int v44; // r8
  char *v45; // r4
  int v46; // r5
  char *v47; // r12
  int v48; // r5
  int v49; // r1
  int v50; // r1
  int v51; // r3
  int v52; // r0
  __int64 v53; // r0
  int v54; // r9
  int v55; // r2
  int v56; // r11
  int v57; // r3
  char *v58; // r8
  char *v59; // r4
  int v60; // r5
  char *v61; // r6
  int v62; // r3
  int v63; // r4
  unsigned int v64; // r7
  unsigned int v65; // r9
  unsigned int v66; // r12
  char *v67; // lr
  __int64 v68; // r10
  int v69; // r8
  char *v70; // r9
  int v71; // r6
  __int64 v72; // r2
  int v73; // r12
  int v74; // r4
  int *v75; // r5
  int v76; // lr
  __int64 v77; // r2
  int v78; // r7
  int v79; // r5
  int v80; // r4
  int v81; // r5
  int v82; // r7
  int v83; // r12
  int v84; // r6
  int v85; // r12
  int v86; // r9
  int v87; // r9
  int v88; // r7
  int v89; // r8
  int v90; // r6
  int v91; // r9
  int v92; // r7
  int v93; // r2
  int v94; // r7
  int v95; // r0
  int v96; // r9
  int v97; // r6
  int v98; // r10
  int v99; // r2
  int v100; // r3
  int v101; // r12
  unsigned int v102; // lr
  char *v103; // r7
  char *v104; // r10
  char *v105; // r4
  int v106; // r2
  unsigned int v107; // r8
  int v108; // r10
  int v109; // r12
  char *v110; // r11
  int v111; // r4
  char *v112; // r5
  int v113; // lr
  int v114; // r1
  int v115; // r4
  int v116; // r5
  int v117; // r1
  int v118; // r2
  char *v119; // r5
  char *v120; // r11
  int v121; // r2
  int v122; // r1
  int v123; // lr
  int v124; // r2
  int v125; // r7
  unsigned int v126; // r3
  int v127; // r1
  int v128; // r2
  __int64 v129; // r0
  int v130; // r3
  unsigned int v131; // r2
  __int64 v132; // r0
  int v133; // r3
  unsigned int v134; // r7
  int *v135; // r3
  int v136; // r2
  __int64 v137; // r8
  char *v138; // r12
  int v139; // r4
  __int64 v140; // r10
  int v141; // r3
  int v142; // r2
  int v143; // r6
  int v144; // r7
  int v145; // r12
  int v146; // lr
  int v147; // r2
  char *v148; // r7
  int v149; // r12
  int v150; // r2
  int v151; // r12
  int v152; // r7
  int v153; // r6
  int v154; // r5
  int v155; // r3
  int v156; // r7
  int v157; // r11
  int *v158; // r12
  __int64 *v159; // r0
  int v160; // r5
  int v161; // r4
  int v162; // r3
  int v163; // r2
  int v164; // lr
  int v165; // t1
  int v166; // r4
  int v167; // r2
  _DWORD *v168; // r12
  __int64 *v169; // r5
  void *result; // r0
  int v171; // r1
  int v172; // r2
  int v173; // r3
  size_t v175; // r4
  __int64 v176; // [sp+0h] [bp-1BCh]
  __int64 v177; // [sp+0h] [bp-1BCh]
  __int64 v178; // [sp+10h] [bp-1ACh]
  int v179; // [sp+10h] [bp-1ACh]
  int v180; // [sp+10h] [bp-1ACh]
  unsigned int v181; // [sp+10h] [bp-1ACh]
  int v182; // [sp+10h] [bp-1ACh]
  int v183; // [sp+14h] [bp-1A8h]
  int v184; // [sp+14h] [bp-1A8h]
  unsigned int v185; // [sp+14h] [bp-1A8h]
  char *v186; // [sp+14h] [bp-1A8h]
  int v187; // [sp+18h] [bp-1A4h]
  unsigned int v188; // [sp+18h] [bp-1A4h]
  unsigned int v189; // [sp+18h] [bp-1A4h]
  int v190; // [sp+18h] [bp-1A4h]
  unsigned int v191; // [sp+18h] [bp-1A4h]
  char *v192; // [sp+18h] [bp-1A4h]
  unsigned int v193; // [sp+1Ch] [bp-1A0h]
  unsigned int v194; // [sp+1Ch] [bp-1A0h]
  int v195; // [sp+1Ch] [bp-1A0h]
  int v196; // [sp+1Ch] [bp-1A0h]
  unsigned int v197; // [sp+1Ch] [bp-1A0h]
  int v198; // [sp+1Ch] [bp-1A0h]
  int v199; // [sp+20h] [bp-19Ch]
  unsigned int v200; // [sp+20h] [bp-19Ch]
  int v201; // [sp+20h] [bp-19Ch]
  int v202; // [sp+20h] [bp-19Ch]
  unsigned int v203; // [sp+20h] [bp-19Ch]
  int v204; // [sp+20h] [bp-19Ch]
  unsigned int v205; // [sp+20h] [bp-19Ch]
  int v206; // [sp+20h] [bp-19Ch]
  int v207; // [sp+20h] [bp-19Ch]
  unsigned int v208; // [sp+24h] [bp-198h]
  unsigned int v209; // [sp+24h] [bp-198h]
  int v210; // [sp+24h] [bp-198h]
  unsigned int v211; // [sp+24h] [bp-198h]
  unsigned int v212; // [sp+24h] [bp-198h]
  int v213; // [sp+28h] [bp-194h]
  unsigned int v214; // [sp+28h] [bp-194h]
  unsigned int v215; // [sp+28h] [bp-194h]
  int v216; // [sp+28h] [bp-194h]
  unsigned int v217; // [sp+28h] [bp-194h]
  int v218; // [sp+28h] [bp-194h]
  unsigned int v219; // [sp+2Ch] [bp-190h]
  unsigned int v220; // [sp+2Ch] [bp-190h]
  int v221; // [sp+2Ch] [bp-190h]
  unsigned int v222; // [sp+2Ch] [bp-190h]
  unsigned int v223; // [sp+2Ch] [bp-190h]
  int v224; // [sp+2Ch] [bp-190h]
  int v225; // [sp+30h] [bp-18Ch]
  unsigned int v226; // [sp+30h] [bp-18Ch]
  char *v227; // [sp+30h] [bp-18Ch]
  unsigned int v228; // [sp+30h] [bp-18Ch]
  int v229; // [sp+30h] [bp-18Ch]
  unsigned int v230; // [sp+30h] [bp-18Ch]
  unsigned int v231; // [sp+30h] [bp-18Ch]
  int v232; // [sp+34h] [bp-188h]
  char *v233; // [sp+34h] [bp-188h]
  unsigned int v234; // [sp+34h] [bp-188h]
  unsigned int v235; // [sp+34h] [bp-188h]
  unsigned int v236; // [sp+34h] [bp-188h]
  int v237; // [sp+34h] [bp-188h]
  int v238; // [sp+38h] [bp-184h]
  unsigned int v239; // [sp+38h] [bp-184h]
  char *v240; // [sp+38h] [bp-184h]
  unsigned int v241; // [sp+38h] [bp-184h]
  unsigned int v242; // [sp+38h] [bp-184h]
  int v243; // [sp+38h] [bp-184h]
  int v244; // [sp+3Ch] [bp-180h]
  unsigned int v245; // [sp+3Ch] [bp-180h]
  unsigned int v246; // [sp+3Ch] [bp-180h]
  int v247; // [sp+3Ch] [bp-180h]
  int v248; // [sp+3Ch] [bp-180h]
  unsigned int v249; // [sp+3Ch] [bp-180h]
  char *v250; // [sp+3Ch] [bp-180h]
  int v251; // [sp+40h] [bp-17Ch]
  int v252; // [sp+40h] [bp-17Ch]
  int v253; // [sp+40h] [bp-17Ch]
  unsigned int v254; // [sp+40h] [bp-17Ch]
  __int16 v255; // [sp+40h] [bp-17Ch]
  char *v256; // [sp+40h] [bp-17Ch]
  unsigned int v257; // [sp+40h] [bp-17Ch]
  char *v258; // [sp+40h] [bp-17Ch]
  size_t n; // [sp+44h] [bp-178h]
  int v260; // [sp+48h] [bp-174h]
  int v261; // [sp+48h] [bp-174h]
  int v262; // [sp+48h] [bp-174h]
  unsigned int v263; // [sp+48h] [bp-174h]
  int v264; // [sp+48h] [bp-174h]
  unsigned int v265; // [sp+48h] [bp-174h]
  int v266; // [sp+48h] [bp-174h]
  int v267; // [sp+4Ch] [bp-170h]
  int v268; // [sp+4Ch] [bp-170h]
  int v269; // [sp+4Ch] [bp-170h]
  unsigned int v270; // [sp+4Ch] [bp-170h]
  int v271; // [sp+50h] [bp-16Ch]
  unsigned int v272; // [sp+50h] [bp-16Ch]
  int v273; // [sp+50h] [bp-16Ch]
  unsigned int v274; // [sp+50h] [bp-16Ch]
  __int64 v275; // [sp+50h] [bp-16Ch]
  int v276; // [sp+54h] [bp-168h]
  int v277; // [sp+54h] [bp-168h]
  int v278; // [sp+54h] [bp-168h]
  char *v279; // [sp+54h] [bp-168h]
  unsigned int v280; // [sp+54h] [bp-168h]
  unsigned int v281; // [sp+54h] [bp-168h]
  char *v282; // [sp+54h] [bp-168h]
  int v283; // [sp+58h] [bp-164h]
  unsigned int v284; // [sp+58h] [bp-164h]
  int v285; // [sp+58h] [bp-164h]
  char *v286; // [sp+58h] [bp-164h]
  int v287; // [sp+58h] [bp-164h]
  unsigned int v288; // [sp+58h] [bp-164h]
  _DWORD *v289; // [sp+5Ch] [bp-160h]
  int v290; // [sp+5Ch] [bp-160h]
  int v291; // [sp+5Ch] [bp-160h]
  int v292; // [sp+5Ch] [bp-160h]
  char *v293; // [sp+5Ch] [bp-160h]
  char *v294; // [sp+5Ch] [bp-160h]
  char *v295; // [sp+5Ch] [bp-160h]
  int v296; // [sp+5Ch] [bp-160h]
  unsigned int v297; // [sp+5Ch] [bp-160h]
  char *v298; // [sp+60h] [bp-15Ch]
  char *v299; // [sp+60h] [bp-15Ch]
  int v300; // [sp+60h] [bp-15Ch]
  unsigned int v301; // [sp+60h] [bp-15Ch]
  char *v302; // [sp+64h] [bp-158h]
  int v303; // [sp+64h] [bp-158h]
  int v304; // [sp+64h] [bp-158h]
  char *v305; // [sp+64h] [bp-158h]
  char *v306; // [sp+64h] [bp-158h]
  int v307; // [sp+64h] [bp-158h]
  unsigned int v308; // [sp+64h] [bp-158h]
  unsigned int v309; // [sp+68h] [bp-154h]
  char *v310; // [sp+68h] [bp-154h]
  char *v311; // [sp+68h] [bp-154h]
  int v312; // [sp+68h] [bp-154h]
  int v313; // [sp+68h] [bp-154h]
  __int64 v314; // [sp+6Ch] [bp-150h]
  unsigned int v315; // [sp+70h] [bp-14Ch]
  int v316; // [sp+74h] [bp-148h]
  int v317; // [sp+74h] [bp-148h]
  char *v318; // [sp+74h] [bp-148h]
  __int64 v319; // [sp+74h] [bp-148h]
  int v320; // [sp+78h] [bp-144h]
  char *v321; // [sp+78h] [bp-144h]
  char *v322; // [sp+7Ch] [bp-140h]
  char *v323; // [sp+7Ch] [bp-140h]
  char *v324; // [sp+7Ch] [bp-140h]
  char *v325; // [sp+7Ch] [bp-140h]
  int v326; // [sp+7Ch] [bp-140h]
  char *v327; // [sp+7Ch] [bp-140h]
  char *v328; // [sp+7Ch] [bp-140h]
  char *v329; // [sp+7Ch] [bp-140h]
  _DWORD *v330; // [sp+80h] [bp-13Ch]
  unsigned int v331; // [sp+80h] [bp-13Ch]
  int v332; // [sp+80h] [bp-13Ch]
  int v333; // [sp+80h] [bp-13Ch]
  char *v334; // [sp+80h] [bp-13Ch]
  char *v335; // [sp+80h] [bp-13Ch]
  int v336; // [sp+80h] [bp-13Ch]
  char *src; // [sp+84h] [bp-138h]
  char *v338; // [sp+88h] [bp-134h]
  char *v339; // [sp+88h] [bp-134h]
  int v340; // [sp+88h] [bp-134h]
  unsigned int v341; // [sp+88h] [bp-134h]
  int v342; // [sp+88h] [bp-134h]
  char *v343; // [sp+88h] [bp-134h]
  int v344; // [sp+8Ch] [bp-130h]
  char *v345; // [sp+8Ch] [bp-130h]
  char *v346; // [sp+8Ch] [bp-130h]
  char *v347; // [sp+8Ch] [bp-130h]
  char *v348; // [sp+90h] [bp-12Ch]
  int v349; // [sp+90h] [bp-12Ch]
  char *v350; // [sp+90h] [bp-12Ch]
  char *v351; // [sp+90h] [bp-12Ch]
  char *v352; // [sp+90h] [bp-12Ch]
  char *v353; // [sp+90h] [bp-12Ch]
  char *v354; // [sp+94h] [bp-128h]
  int v355; // [sp+94h] [bp-128h]
  unsigned int v356; // [sp+94h] [bp-128h]
  int v357; // [sp+94h] [bp-128h]
  char *v358; // [sp+98h] [bp-124h]
  int v359; // [sp+98h] [bp-124h]
  int v360; // [sp+98h] [bp-124h]
  char *v361; // [sp+98h] [bp-124h]
  char *v362; // [sp+98h] [bp-124h]
  int v363; // [sp+9Ch] [bp-120h]
  int v364; // [sp+9Ch] [bp-120h]
  int v365; // [sp+9Ch] [bp-120h]
  char *v366; // [sp+9Ch] [bp-120h]
  int v367; // [sp+9Ch] [bp-120h]
  int v368; // [sp+9Ch] [bp-120h]
  char *v369; // [sp+A0h] [bp-11Ch]
  _DWORD *v370; // [sp+A0h] [bp-11Ch]
  char *v371; // [sp+A0h] [bp-11Ch]
  char *v372; // [sp+A0h] [bp-11Ch]
  int v373; // [sp+A4h] [bp-118h]
  char *v374; // [sp+A4h] [bp-118h]
  char *v375; // [sp+A4h] [bp-118h]
  int v376; // [sp+A4h] [bp-118h]
  char *v377; // [sp+A8h] [bp-114h]
  int v378; // [sp+A8h] [bp-114h]
  int v379; // [sp+A8h] [bp-114h]
  char *v380; // [sp+A8h] [bp-114h]
  char *v381; // [sp+ACh] [bp-110h]
  char *v382; // [sp+ACh] [bp-110h]
  int v383; // [sp+ACh] [bp-110h]
  char *v384; // [sp+ACh] [bp-110h]
  char *v385; // [sp+ACh] [bp-110h]
  int v386; // [sp+B0h] [bp-10Ch]
  unsigned int v387; // [sp+B0h] [bp-10Ch]
  char *v388; // [sp+B0h] [bp-10Ch]
  char *v389; // [sp+B0h] [bp-10Ch]
  char *v390; // [sp+B0h] [bp-10Ch]
  unsigned int v391; // [sp+B4h] [bp-108h]
  int v392; // [sp+B4h] [bp-108h]
  char *v393; // [sp+B4h] [bp-108h]
  int v394; // [sp+B4h] [bp-108h]
  char *v395; // [sp+B4h] [bp-108h]
  int v396; // [sp+B8h] [bp-104h]
  char *v397; // [sp+B8h] [bp-104h]
  unsigned int v398; // [sp+B8h] [bp-104h]
  int v399; // [sp+B8h] [bp-104h]
  char *v400; // [sp+BCh] [bp-100h]
  char *v401; // [sp+BCh] [bp-100h]
  int v402; // [sp+BCh] [bp-100h]
  int v403; // [sp+BCh] [bp-100h]
  char *v404; // [sp+C0h] [bp-FCh]
  int v405; // [sp+C0h] [bp-FCh]
  int v406; // [sp+C0h] [bp-FCh]
  int v407; // [sp+C0h] [bp-FCh]
  int v408; // [sp+C4h] [bp-F8h]
  char *v409; // [sp+C4h] [bp-F8h]
  int v410; // [sp+C4h] [bp-F8h]
  int v411; // [sp+C4h] [bp-F8h]
  int v412; // [sp+C4h] [bp-F8h]
  int v413; // [sp+C4h] [bp-F8h]
  int v414; // [sp+C8h] [bp-F4h]
  char *v415; // [sp+C8h] [bp-F4h]
  int v416; // [sp+C8h] [bp-F4h]
  unsigned int v417; // [sp+C8h] [bp-F4h]
  int v418; // [sp+CCh] [bp-F0h]
  int v419; // [sp+CCh] [bp-F0h]
  int v420; // [sp+CCh] [bp-F0h]
  int v421; // [sp+CCh] [bp-F0h]
  int v422; // [sp+D0h] [bp-ECh]
  int v423; // [sp+D0h] [bp-ECh]
  int v424; // [sp+D0h] [bp-ECh]
  int v425; // [sp+D0h] [bp-ECh]
  unsigned int v426; // [sp+D0h] [bp-ECh]
  unsigned int v427; // [sp+D0h] [bp-ECh]
  unsigned int v428; // [sp+D4h] [bp-E8h]
  int v429; // [sp+D4h] [bp-E8h]
  unsigned int v430; // [sp+D8h] [bp-E4h]
  unsigned int v431; // [sp+D8h] [bp-E4h]
  int v432; // [sp+DCh] [bp-E0h]
  int v433; // [sp+E0h] [bp-DCh]
  int v434; // [sp+E4h] [bp-D8h]
  int v436; // [sp+F0h] [bp-CCh] BYREF
  _DWORD *v437; // [sp+F4h] [bp-C8h]
  _BYTE v438[56]; // [sp+F8h] [bp-C4h] BYREF
  _BYTE v439[8]; // [sp+130h] [bp-8Ch] BYREF
  __int64 v440; // [sp+138h] [bp-84h] BYREF
  int v441; // [sp+140h] [bp-7Ch] BYREF
  int v442; // [sp+144h] [bp-78h]
  int v443; // [sp+148h] [bp-74h]
  int v444; // [sp+14Ch] [bp-70h]
  int v445; // [sp+150h] [bp-6Ch]
  int v446; // [sp+154h] [bp-68h]
  int v447; // [sp+158h] [bp-64h]
  int v448; // [sp+15Ch] [bp-60h]
  int v449; // [sp+160h] [bp-5Ch]
  int v450; // [sp+164h] [bp-58h]
  int v451; // [sp+168h] [bp-54h]
  int v452; // [sp+16Ch] [bp-50h]
  int v453; // [sp+170h] [bp-4Ch] BYREF
  int v454; // [sp+174h] [bp-48h]
  int v455; // [sp+178h] [bp-44h]
  int v456; // [sp+17Ch] [bp-40h]
  __int64 v457; // [sp+180h] [bp-3Ch] BYREF
  int v458; // [sp+188h] [bp-34h]
  int v459; // [sp+18Ch] [bp-30h]
  int v460; // [sp+190h] [bp-2Ch]
  int v461; // [sp+194h] [bp-28h]
  int v462; // [sp+198h] [bp-24h]
  int v463; // [sp+19Ch] [bp-20h]
  int v464; // [sp+1A0h] [bp-1Ch]
  int v465; // [sp+1A4h] [bp-18h]
  int v466; // [sp+1A8h] [bp-14h]
  int v467; // [sp+1ACh] [bp-10h]
  int v468; // [sp+1B0h] [bp-Ch]
  int v469; // [sp+1B4h] [bp-8h]

  v3 = a1[16];
  n = a3;
  src = a2;
  if ( 64 - v3 > a3 )
  {
    v175 = v3 + a3;
    result = memcpy((char *)a1 + v3, a2, a3);
    a1[16] = v175;
  }
  else
  {
    v4 = v438;
    v5 = a1 + 34;
    v6 = a1 + 18;
    v437 = a1 + 18;
    do
    {
      v7 = *v6;
      v6 += 4;
      v8 = *(v6 - 3);
      v9 = v4;
      v10 = *(v6 - 2);
      v4 += 16;
      v11 = *(v6 - 1);
      *v9 = v7;
      v9[1] = v8;
      v9[2] = v10;
      v9[3] = v11;
    }
    while ( v6 != v5 );
    if ( n )
    {
      for ( i = 64 - v3; ; i = 64 - v3 )
      {
        if ( n < i )
          i = n;
        v13 = (char *)a1 + v3;
        v3 += i;
        memcpy(v13, src, i);
        n -= i;
        src += i;
        if ( v3 == 64 )
        {
          v436 = (int)&v436;
          v14 = &v436;
          v15 = v439;
          v16 = &v453;
          v17 = a1 - 2;
          do
          {
            v19 = v17[2];
            v17 += 2;
            v18 = v19;
            v20 = v14[2];
            v14 += 2;
            v21 = v17[1];
            v22 = v14[1];
            v16[2] = v18;
            v16 += 2;
            *((_DWORD *)v15 + 2) = v20 ^ v18;
            v15 += 8;
            v16[1] = v21;
            *((_DWORD *)v15 + 1) = v22 ^ v21;
          }
          while ( a1 + 14 != v17 );
          v176 = 0;
          v314 = v440;
          v23 = v451;
          v24 = v453;
          v260 = v454;
          v225 = v441;
          v271 = v442;
          v238 = v443;
          v251 = v444;
          v232 = v445;
          v276 = v446;
          v187 = v447;
          v199 = v448;
          v213 = v449;
          v244 = v450;
          v25 = v452;
          do
          {
            v178 = v314 ^ v176;
            v219 = v271 ^ ((unsigned __int64)(v176 + 16) >> 32);
            v193 = v251 ^ ((unsigned __int64)(v176 + 32) >> 32);
            v26 = v187 ^ (v176 + 64);
            v208 = v199 ^ ((unsigned __int64)(v176 + 64) >> 32);
            v27 = v213 ^ (v176 + 80);
            v214 = (v176 + 96) ^ v23;
            v28 = (v260 ^ ((unsigned __int64)(v176 + 112) >> 32)) >> 24;
            v252 = v260 ^ ((unsigned __int64)(v176 + 112) >> 32);
            v188 = v225 ^ (v176 + 16);
            v29 = (v176 + 32) ^ v238;
            v239 = v27;
            v30 = v244;
            v31 = v25 ^ ((unsigned __int64)(v176 + 96) >> 32);
            v200 = v276 ^ ((unsigned __int64)(v176 + 48) >> 32);
            v245 = (v176 + 112) ^ v24;
            v32 = ((unsigned __int64)(v176 + 80) >> 32) ^ v30;
            v226 = (v176 + 48) ^ v232;
            v289 = (_DWORD *)((char *)&unk_EF148 + 8 * ((unsigned int)(HIDWORD(v314) ^ HIDWORD(v176)) >> 24));
            v330 = (_DWORD *)((char *)&unk_EF148 + 8 * HIBYTE(v219));
            v344 = 8 * HIBYTE(v27) + 985408;
            HIDWORD(v314) = HIBYTE(v31);
            v363 = 8 * HIBYTE(v214) + 985408;
            v386 = 8 * HIBYTE(v245) + 985408;
            v33 = *((_DWORD *)&unk_EF148 + 2 * v28 + 1);
            v391 = 8 * (((unsigned int)v314 ^ (unsigned int)v176) >> 24) + 985408;
            v309 = HIBYTE(v32);
            v34 = (char *)&qword_EF950[BYTE1(v188)];
            v35 = (char *)&qword_F0150[BYTE2(v29)];
            v36 = 8 * (unsigned __int8)(v314 ^ v176) + 977224;
            v418 = 8 * HIBYTE(v29) + 985408;
            v432 = (unsigned __int8)v29;
            v302 = (char *)&qword_EF950[BYTE1(v29)];
            v37 = LODWORD(qword_EE948[(unsigned __int8)(v314 ^ v176)])
                ^ (v176 + 1)
                ^ *((_DWORD *)&unk_EF148 + 2 * v28)
                ^ *((_DWORD *)v34 - 2);
            v38 = 8 * HIBYTE(v226) + 985408;
            LODWORD(v314) = &qword_F0150[BYTE2(v226)];
            v39 = *(_DWORD *)(v36 + 4) ^ ((unsigned __int64)(v176 + 1) >> 32) ^ v33;
            v322 = (char *)&qword_F1150[(unsigned __int8)v32];
            v40 = BYTE1(v31);
            v316 = BYTE2(v32);
            v41 = (int *)((char *)&unk_F2148 + 8 * BYTE2(v31));
            v348 = (char *)&qword_F1150[(unsigned __int8)v31];
            v408 = *v41;
            v42 = v39 ^ *((_DWORD *)v34 - 1);
            v414 = v41[1];
            v43 = BYTE6(v178);
            v44 = (unsigned __int8)((v176 + 48) ^ v232);
            v338 = (char *)&qword_EF950[BYTE1(v226)];
            v45 = (char *)&qword_F1150[(unsigned __int8)v208];
            v46 = v289[1] ^ ((unsigned __int64)(v176 + 17) >> 32) ^ HIDWORD(qword_EE948[(unsigned __int8)v188]);
            v422 = *v289 ^ (v176 + 17) ^ LODWORD(qword_EE948[(unsigned __int8)v188]);
            v369 = (char *)&qword_F1150[(unsigned __int8)(v260 ^ ((unsigned __int64)(v176 + 112) >> 32))];
            v433 = BYTE5(v178);
            v227 = (char *)&qword_F1150[BYTE4(v178)];
            v233 = (char *)&qword_EF950[BYTE1(v26)];
            v358 = (char *)&qword_F0150[BYTE2(v239)];
            v434 = BYTE2(v219);
            v290 = (unsigned __int8)v239;
            v377 = (char *)&qword_EF950[BYTE1(v239)];
            v277 = BYTE1(v219);
            v381 = (char *)&qword_F0150[BYTE2(v214)];
            v404 = (char *)&qword_F1150[(unsigned __int8)(v271 ^ ((unsigned __int64)(v176 + 16) >> 32))];
            v220 = v42
                 ^ *((_DWORD *)v35 - 1)
                 ^ *(_DWORD *)(v38 + 12)
                 ^ *((_DWORD *)v45 - 1)
                 ^ *((_DWORD *)&unk_F1948 + 2 * BYTE1(v32) + 1)
                 ^ v414;
            v283 = BYTE2(v193);
            v47 = (char *)&unk_F2148 + 8 * BYTE6(v178);
            HIDWORD(v178) = v37
                          ^ *((_DWORD *)v35 - 2)
                          ^ *(_DWORD *)(v38 + 8)
                          ^ *((_DWORD *)v45 - 2)
                          ^ *((_DWORD *)&unk_F1948 + 2 * BYTE1(v32))
                          ^ v408;
            v48 = v46 ^ *((_DWORD *)v302 - 1) ^ *(_DWORD *)(v314 - 4);
            v49 = v422 ^ *((_DWORD *)v302 - 2) ^ *(_DWORD *)(v314 - 8) ^ LODWORD(qword_F0948[HIBYTE(v26)]);
            v303 = (unsigned __int8)v214;
            v400 = (char *)&qword_EF950[BYTE1(v214)];
            v50 = v49 ^ *((_DWORD *)v322 - 2);
            v51 = *((_DWORD *)&unk_F1948 + 2 * BYTE1(v31) + 1)
                ^ v48
                ^ HIDWORD(qword_F0948[HIBYTE(v26)])
                ^ *((_DWORD *)v322 - 1)
                ^ *((_DWORD *)&unk_F2148 + 2 * BYTE2(v252) + 1);
            v320 = *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v193));
            v423 = *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v193) + 1);
            v323 = (char *)&qword_F0150[BYTE2(v245)];
            v261 = BYTE1(v193);
            v409 = (char *)&qword_F1150[(unsigned __int8)v193];
            v52 = v178;
            LODWORD(v178) = v51;
            v354 = (char *)&qword_F0150[BYTE2(v52)];
            v415 = (char *)&qword_EF950[BYTE1(v52)];
            v240 = (char *)&qword_EF950[BYTE1(v245)];
            LODWORD(v314) = (unsigned __int8)v245;
            v246 = v50 ^ *((_DWORD *)&unk_F1948 + 2 * v40) ^ *((_DWORD *)&unk_F2148 + 2 * BYTE2(v252));
            v53 = qword_F0150[BYTE2(v26) - 1];
            v194 = *v330
                 ^ *((_DWORD *)&unk_F2148 + 2 * v43)
                 ^ LODWORD(qword_EE948[v432])
                 ^ (v176 + 33)
                 ^ *((_DWORD *)v338 - 2)
                 ^ v53
                 ^ *(_DWORD *)(v344 + 8)
                 ^ *((_DWORD *)v348 - 2)
                 ^ *((_DWORD *)&unk_F1948 + 2 * BYTE1(v252));
            v215 = v330[1]
                 ^ *((_DWORD *)v47 + 1)
                 ^ HIDWORD(qword_EE948[v432])
                 ^ ((unsigned __int64)(v176 + 33) >> 32)
                 ^ *((_DWORD *)v338 - 1)
                 ^ HIDWORD(v53)
                 ^ *(_DWORD *)(v344 + 12)
                 ^ *((_DWORD *)v348 - 1)
                 ^ *((_DWORD *)&unk_F1948 + 2 * BYTE1(v252) + 1);
            v54 = *((_DWORD *)v358 - 1);
            v55 = LODWORD(qword_EE948[v44])
                ^ *((_DWORD *)&unk_F1948 + 2 * v433)
                ^ (v176 + 49)
                ^ v320
                ^ *((_DWORD *)v233 - 2)
                ^ *((_DWORD *)v358 - 2);
            v359 = *((_DWORD *)&unk_F1948 + 2 * v277 + 1);
            v56 = *((_DWORD *)v227 - 2);
            HIDWORD(v53) = v227;
            v228 = v55 ^ *(_DWORD *)(v363 + 8) ^ *((_DWORD *)v369 - 2) ^ *((_DWORD *)&unk_F2148 + 2 * v434);
            v234 = *(_DWORD *)(v363 + 12)
                 ^ HIDWORD(qword_EE948[v44])
                 ^ *((_DWORD *)&unk_F1948 + 2 * v433 + 1)
                 ^ ((unsigned __int64)(v176 + 49) >> 32)
                 ^ v423
                 ^ *((_DWORD *)v233 - 1)
                 ^ v54
                 ^ *((_DWORD *)v369 - 1)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v434 + 1);
            v278 = *((_DWORD *)&unk_F1948 + 2 * v277);
            v364 = *((_DWORD *)&unk_F2148 + 2 * v283 + 1);
            v284 = *((_DWORD *)&unk_F2148 + 2 * v283);
            v57 = *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v200) + 1)
                ^ *(_DWORD *)(HIDWORD(v53) - 4)
                ^ HIDWORD(qword_EE948[(unsigned __int8)v26])
                ^ ((unsigned __int64)(v176 + 65) >> 32);
            v58 = v377;
            v396 = *((_DWORD *)&unk_F1948 + 2 * v261 + 1);
            HIDWORD(v53) = *((_DWORD *)v377 - 1);
            v378 = *((_DWORD *)&unk_F1948 + 2 * v261);
            v424 = *((_DWORD *)&unk_F2148 + 2 * BYTE2(v200));
            v59 = (char *)&qword_F0150[BYTE2(v188)];
            v253 = 8 * HIBYTE(v188) + 985408;
            v267 = v57 ^ HIDWORD(v53) ^ *((_DWORD *)v381 - 1) ^ *(_DWORD *)(v386 + 12);
            v262 = *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v200))
                 ^ v56
                 ^ LODWORD(qword_EE948[(unsigned __int8)v26])
                 ^ (v176 + 65)
                 ^ *((_DWORD *)v58 - 2)
                 ^ *((_DWORD *)v381 - 2)
                 ^ *(_DWORD *)(v386 + 8);
            v60 = (v176 + 81)
                ^ *(_DWORD *)(v391 + 8)
                ^ LODWORD(qword_EE948[v290])
                ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v208));
            v291 = HIDWORD(qword_EE948[v290])
                 ^ *(_DWORD *)(v391 + 12)
                 ^ ((unsigned __int64)(v176 + 81) >> 32)
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v208) + 1);
            LODWORD(v53) = *((_DWORD *)v354 - 2) ^ LODWORD(qword_EE948[v303]);
            v61 = (char *)&qword_F1150[(unsigned __int8)v200];
            v62 = HIDWORD(qword_EE948[v303])
                ^ *((_DWORD *)v354 - 1)
                ^ ((unsigned __int64)(v176 + 97) >> 32)
                ^ *((_DWORD *)&unk_EF148 + 2 * v309 + 1);
            v304 = *((_DWORD *)v59 - 1);
            HIDWORD(v53) = LODWORD(qword_EE948[v314])
                         ^ *((_DWORD *)v415 - 2)
                         ^ (v176 + 113)
                         ^ *((_DWORD *)&unk_EF148 + 2 * HIDWORD(v314))
                         ^ *((_DWORD *)v59 - 2);
            v63 = *((_DWORD *)&unk_F1948 + 2 * BYTE1(v208));
            v189 = v267 ^ v359 ^ v364;
            LODWORD(v53) = v53
                         ^ (v176 + 97)
                         ^ *((_DWORD *)&unk_EF148 + 2 * v309)
                         ^ *((_DWORD *)v240 - 2)
                         ^ *(_DWORD *)(v253 + 8)
                         ^ *((_DWORD *)v409 - 2)
                         ^ *((_DWORD *)&unk_F1948 + 2 * BYTE1(v200))
                         ^ *((_DWORD *)&unk_F2148 + 2 * BYTE2(v208));
            v64 = *((_DWORD *)&unk_F2148 + 2 * BYTE2(v208) + 1)
                ^ v62
                ^ *((_DWORD *)v240 - 1)
                ^ *(_DWORD *)(v253 + 12)
                ^ *((_DWORD *)v409 - 1)
                ^ *((_DWORD *)&unk_F1948 + 2 * BYTE1(v200) + 1);
            v209 = HIDWORD(qword_EE948[v314])
                 ^ *((_DWORD *)v415 - 1)
                 ^ ((unsigned __int64)(v176 + 113) >> 32)
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIDWORD(v314) + 1)
                 ^ v304
                 ^ *(_DWORD *)(v418 + 12)
                 ^ *((_DWORD *)v61 - 1)
                 ^ *((_DWORD *)&unk_F1948 + 2 * BYTE1(v208) + 1)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v316 + 1);
            v65 = (v262 ^ v278 ^ v284) >> 24;
            v66 = v291
                ^ *((_DWORD *)v400 - 1)
                ^ *((_DWORD *)v323 - 1)
                ^ *((_DWORD *)v404 - 1)
                ^ v396
                ^ *((_DWORD *)&unk_F2148 + 2 * BYTE2(v200) + 1);
            v201 = v262 ^ v278 ^ v284;
            v315 = v60 ^ *((_DWORD *)v400 - 2) ^ *((_DWORD *)v323 - 2) ^ *((_DWORD *)v404 - 2) ^ v378 ^ v424;
            v387 = HIDWORD(v53)
                 ^ *(_DWORD *)(v418 + 8)
                 ^ *((_DWORD *)v61 - 2)
                 ^ v63
                 ^ *((_DWORD *)&unk_F2148 + 2 * v316);
            v254 = HIBYTE(v215);
            v241 = BYTE3(v178);
            v263 = HIBYTE(v234);
            v349 = v53;
            v285 = 8 * HIBYTE(v228) + 985408;
            v292 = 8 * v65 + 985408;
            v305 = (char *)&unk_EF148 + 8 * BYTE3(v178);
            v355 = 8 * HIBYTE(v387) + 985408;
            v317 = 8 * HIBYTE(v315) + 985408;
            v331 = 8 * BYTE3(v53) + 985408;
            v345 = (char *)&unk_EF148 + 8 * HIBYTE(v234);
            v370 = (_DWORD *)((char *)&unk_EF148 + 8 * HIBYTE(v189));
            v430 = HIBYTE(v64);
            v360 = 8 * HIBYTE(HIDWORD(v178)) + 985408;
            v401 = (char *)&unk_EF148 + 8 * HIBYTE(v64);
            v379 = 8 * HIBYTE(v246) + 985408;
            v405 = 8 * HIBYTE(v194) + 985408;
            v67 = (char *)&qword_EF950[BYTE1(v246)];
            v382 = (char *)&unk_EF148 + 8 * HIBYTE(v66);
            HIDWORD(v53) = (unsigned __int8)v246;
            v428 = HIBYTE(v66);
            v298 = (char *)&qword_F1150[(unsigned __int8)v66];
            v397 = (char *)&qword_F0150[BYTE2(v246)];
            v176 += 2;
            v373 = *((_DWORD *)v67 - 1) ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v209) + 1);
            v392 = (unsigned __int8)v194;
            v279 = (char *)&qword_F0150[BYTE2(v194)];
            v68 = qword_EF950[BYTE1(v194) - 1];
            v69 = BYTE2(v64);
            v365 = *((_DWORD *)v67 - 2) ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v209));
            LODWORD(v53) = HIDWORD(qword_EE948[(unsigned __int8)v246])
                         ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v220) + 1)
                         ^ HIDWORD(v68);
            v321 = (char *)&qword_F1150[(unsigned __int8)v64];
            v70 = (char *)&qword_F1150[(unsigned __int8)v189];
            v71 = BYTE1(v66);
            v247 = BYTE2(v66);
            HIDWORD(v68) = BYTE2(v220);
            v72 = qword_F0150[BYTE2(v228) - 1];
            v73 = *((_DWORD *)&unk_F1948 + 2 * BYTE1(v64));
            LODWORD(v53) = v53 ^ HIDWORD(v72);
            v74 = *((_DWORD *)&unk_F1948 + 2 * BYTE1(v64) + 1);
            HIDWORD(v53) = LODWORD(qword_EE948[HIDWORD(v53)]) ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v220)) ^ v68 ^ v72;
            v419 = (unsigned __int8)v228;
            v75 = (int *)((char *)&unk_F2148 + 8 * BYTE2(v209));
            v76 = *v75;
            v310 = (char *)&qword_EF950[BYTE1(v228)];
            v77 = *(_QWORD *)(v292 + 8);
            v78 = v75[1];
            LODWORD(v53) = v53 ^ HIDWORD(v77);
            v410 = BYTE1(v209);
            v293 = (char *)&qword_F0150[BYTE2(v201)];
            HIDWORD(v77) = *((_DWORD *)v298 - 1);
            v339 = (char *)&qword_F1150[(unsigned __int8)v209];
            v79 = *((_DWORD *)v298 - 2);
            v416 = BYTE1(v220);
            LODWORD(v68) = &qword_F1150[(unsigned __int8)v220];
            v425 = BYTE2(v178);
            v195 = (unsigned __int8)v201;
            v299 = (char *)&qword_EF950[BYTE1(v201)];
            v271 = v53 ^ HIDWORD(v77) ^ v74 ^ v78;
            v225 = HIDWORD(v53) ^ v77 ^ v79 ^ v73 ^ v76;
            v80 = LODWORD(qword_EE948[BYTE4(v178)]) ^ v365;
            v324 = (char *)&qword_F0150[BYTE2(v315)];
            HIDWORD(v77) = (unsigned __int8)v178;
            LODWORD(v178) = BYTE1(v178);
            v366 = (char *)&qword_F1150[HIDWORD(v77)];
            v210 = (unsigned __int8)v315;
            LODWORD(v77) = *(_DWORD *)(v285 + 12);
            HIDWORD(v77) = *(_DWORD *)(v285 + 8);
            v286 = (char *)&qword_EF950[BYTE1(v315)];
            v81 = HIDWORD(qword_EE948[BYTE4(v178)]) ^ v373 ^ *((_DWORD *)v279 - 1) ^ v77;
            LODWORD(v53) = *((_DWORD *)v70 - 2);
            LODWORD(v77) = *((_DWORD *)v70 - 1);
            LOWORD(v70) = v349;
            v350 = (char *)&qword_F0150[BYTE2(v349)];
            v202 = BYTE2(v215);
            v221 = (unsigned __int8)v70;
            v374 = (char *)&qword_EF950[BYTE1(v70)];
            v82 = *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v215) + 1);
            HIDWORD(v314) = v81 ^ v77 ^ *((_DWORD *)&unk_F1948 + 2 * v71 + 1) ^ *((_DWORD *)&unk_F2148 + 2 * v69 + 1);
            v83 = v80
                ^ *((_DWORD *)v279 - 2)
                ^ HIDWORD(v77)
                ^ v53
                ^ *((_DWORD *)&unk_F1948 + 2 * v71)
                ^ *((_DWORD *)&unk_F2148 + 2 * v69);
            LOWORD(v81) = v387;
            LODWORD(v77) = *((_DWORD *)&unk_F2148 + 2 * HIDWORD(v68)) ^ LODWORD(qword_EE948[v392]);
            HIDWORD(v53) = HIDWORD(qword_EE948[v392])
                         ^ *((_DWORD *)&unk_F2148 + 2 * HIDWORD(v68) + 1)
                         ^ *((_DWORD *)v305 + 1);
            BYTE4(v77) = v215;
            v306 = (char *)&qword_F0150[BYTE2(v387)];
            v84 = *((_DWORD *)v310 - 2);
            LODWORD(v314) = v83;
            v216 = BYTE1(v215);
            v85 = *((_DWORD *)&unk_EF148 + 2 * v254);
            v388 = (char *)&qword_F1150[BYTE4(v77)];
            HIDWORD(v77) = BYTE2(v234);
            v86 = *((_DWORD *)v293 - 1) ^ HIDWORD(v53) ^ *((_DWORD *)v310 - 1);
            v311 = (char *)&qword_F0150[BYTE6(v178)];
            v393 = (char *)&qword_EF950[BYTE5(v178)];
            LODWORD(v53) = *(_DWORD *)(v317 + 8);
            v87 = v86 ^ *(_DWORD *)(v317 + 12);
            v318 = (char *)&qword_EF950[BYTE1(v81)];
            v251 = v87 ^ *((_DWORD *)v321 - 1) ^ *((_DWORD *)&unk_F1948 + 2 * v410 + 1);
            v238 = *((_DWORD *)v293 - 2)
                 ^ v77
                 ^ *((_DWORD *)&unk_EF148 + 2 * v241)
                 ^ v84
                 ^ v53
                 ^ *((_DWORD *)v321 - 2)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v410);
            v294 = (char *)&unk_F2148 + 8 * BYTE2(v234);
            v183 = BYTE1(v234);
            v88 = v82
                ^ HIDWORD(qword_EE948[v419])
                ^ *((_DWORD *)&unk_F1948 + 2 * v416 + 1)
                ^ *((_DWORD *)&unk_F2148 + 2 * v425 + 1)
                ^ *((_DWORD *)v299 - 1)
                ^ *((_DWORD *)v324 - 1);
            v89 = *((_DWORD *)&unk_F2148 + 2 * v425)
                ^ LODWORD(qword_EE948[v419])
                ^ *((_DWORD *)&unk_F1948 + 2 * v416)
                ^ v85
                ^ *((_DWORD *)v299 - 2)
                ^ *((_DWORD *)v324 - 2);
            v325 = (char *)&qword_F1150[(unsigned __int8)v234];
            v276 = v88 ^ *(_DWORD *)(v331 + 12) ^ *((_DWORD *)v339 - 1);
            v232 = v89 ^ *(_DWORD *)(v331 + 8) ^ *((_DWORD *)v339 - 2);
            HIDWORD(v53) = *(_DWORD *)(v68 - 4)
                         ^ HIDWORD(qword_EE948[v195])
                         ^ *((_DWORD *)&unk_F1948 + 2 * v178 + 1)
                         ^ *((_DWORD *)v345 + 1);
            v90 = *((_DWORD *)v286 - 2)
                ^ *(_DWORD *)(v68 - 8)
                ^ LODWORD(qword_EE948[v195])
                ^ *((_DWORD *)&unk_F1948 + 2 * v178)
                ^ *((_DWORD *)&unk_EF148 + 2 * v263);
            v332 = *((_DWORD *)&unk_F1948 + 2 * v216 + 1);
            v340 = *((_DWORD *)&unk_F2148 + 2 * HIDWORD(v77));
            v91 = BYTE1(v189);
            v179 = BYTE2(v189);
            v187 = v90 ^ *((_DWORD *)v350 - 2) ^ *(_DWORD *)(v355 + 8) ^ *((_DWORD *)&unk_F2148 + 2 * v202);
            v199 = *((_DWORD *)v286 - 1)
                 ^ HIDWORD(v53)
                 ^ *((_DWORD *)v350 - 1)
                 ^ *(_DWORD *)(v355 + 12)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v202 + 1);
            v92 = *((_DWORD *)&unk_F2148 + 2 * v247 + 1);
            v23 = *((_DWORD *)&unk_F2148 + 2 * v179)
                ^ *((_DWORD *)v311 - 2)
                ^ LODWORD(qword_EE948[v221])
                ^ *(_DWORD *)(v379 + 8)
                ^ *((_DWORD *)&unk_EF148 + 2 * v428)
                ^ *((_DWORD *)v318 - 2)
                ^ *((_DWORD *)v388 - 2)
                ^ *((_DWORD *)&unk_F1948 + 2 * v183);
            v24 = LODWORD(qword_EE948[(unsigned __int8)v81])
                ^ *((_DWORD *)v393 - 2)
                ^ *((_DWORD *)v397 - 2)
                ^ *((_DWORD *)&unk_EF148 + 2 * v430)
                ^ *(_DWORD *)(v405 + 8)
                ^ *((_DWORD *)v325 - 2)
                ^ *((_DWORD *)&unk_F1948 + 2 * v91)
                ^ *((_DWORD *)&unk_F2148 + 2 * v247);
            v25 = *((_DWORD *)&unk_F2148 + 2 * v179 + 1)
                ^ *((_DWORD *)v311 - 1)
                ^ HIDWORD(qword_EE948[v221])
                ^ *(_DWORD *)(v379 + 12)
                ^ *((_DWORD *)v382 + 1)
                ^ *((_DWORD *)v318 - 1)
                ^ *((_DWORD *)v388 - 1)
                ^ *((_DWORD *)&unk_F1948 + 2 * v183 + 1);
            v213 = *((_DWORD *)v366 - 2)
                 ^ LODWORD(qword_EE948[v210])
                 ^ *(_DWORD *)(v360 + 8)
                 ^ *v370
                 ^ *((_DWORD *)v374 - 2)
                 ^ *((_DWORD *)v306 - 2)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v216)
                 ^ v340;
            v244 = HIDWORD(qword_EE948[v210])
                 ^ *(_DWORD *)(v360 + 12)
                 ^ *((_DWORD *)v366 - 1)
                 ^ v370[1]
                 ^ *((_DWORD *)v374 - 1)
                 ^ *((_DWORD *)v306 - 1)
                 ^ v332
                 ^ *((_DWORD *)v294 + 1);
            v93 = HIDWORD(qword_EE948[(unsigned __int8)v81])
                ^ *((_DWORD *)v393 - 1)
                ^ *((_DWORD *)v397 - 1)
                ^ *((_DWORD *)v401 + 1)
                ^ *(_DWORD *)(v405 + 12)
                ^ *((_DWORD *)v325 - 1)
                ^ *((_DWORD *)&unk_F1948 + 2 * v91 + 1)
                ^ v92;
            v260 = v93;
          }
          while ( v176 != 10 );
          v94 = *((_DWORD *)&unk_F2148 + 2 * v179 + 1)
              ^ *((_DWORD *)v311 - 1)
              ^ HIDWORD(qword_EE948[v221])
              ^ *(_DWORD *)(v379 + 12)
              ^ *((_DWORD *)v382 + 1)
              ^ *((_DWORD *)v318 - 1)
              ^ *((_DWORD *)v388 - 1)
              ^ *((_DWORD *)&unk_F1948 + 2 * v183 + 1);
          v95 = v93;
          v307 = v455;
          v177 = -1;
          v312 = v456;
          v319 = v457;
          v264 = v458;
          v268 = v459;
          v287 = v460;
          v326 = v461;
          v440 = v314;
          v441 = v225;
          v442 = v271;
          v229 = v462;
          v443 = v238;
          v333 = v463;
          v444 = v251;
          v96 = v464;
          v445 = v232;
          v449 = v213;
          v97 = v465;
          v446 = v276;
          v98 = v466;
          v99 = v469;
          v447 = v187;
          v448 = v199;
          v100 = v468;
          v450 = v244;
          v451 = v23;
          v452 = v94;
          v453 = v24;
          v454 = v95;
          v180 = v467;
          do
          {
            v280 = HIDWORD(v177) ^ 0x70000000 ^ v99;
            v248 = ~v307;
            v184 = v312 ^ HIDWORD(v177);
            v190 = ~(_DWORD)v319;
            v203 = ~v264;
            v101 = ~v287;
            v272 = v180 ^ HIDWORD(v177) ^ 0x60000000;
            v211 = v268 ^ HIDWORD(v177) ^ 0x20000000;
            v222 = ~v229;
            v265 = HIDWORD(v319) ^ HIDWORD(v177) ^ 0x10000000;
            v235 = ~v98;
            v230 = HIDWORD(v177) ^ 0x50000000 ^ v97;
            v398 = ((unsigned int)v312 ^ HIDWORD(v177)) >> 24;
            v102 = 8 * ((unsigned int)~v307 >> 24) + 985408;
            v341 = 8 * ((unsigned int)~(_DWORD)v319 >> 24) + 985408;
            v356 = 8 * ((unsigned int)~v287 >> 24) + 985408;
            v431 = (v326 ^ HIDWORD(v177) ^ 0x30000000u) >> 24;
            v426 = HIBYTE(v211);
            v308 = HIBYTE(v230);
            v103 = (char *)&qword_F1150[(unsigned __int8)(BYTE4(v319) ^ BYTE4(v177))];
            v367 = 8 * HIBYTE(v222) + 985408;
            v104 = (char *)&qword_EF950[BYTE1(v222)];
            v105 = (char *)&qword_F0150[BYTE2(v235)];
            v255 = v333 ^ WORD2(v177);
            v288 = (v333 ^ HIDWORD(v177) ^ 0x40000000u) >> 24;
            v295 = (char *)&qword_EF950[BYTE1(v101)];
            v106 = *((_DWORD *)v105 - 2)
                 ^ ~LODWORD(qword_EE948[(unsigned __int8)v203])
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v280))
                 ^ *((_DWORD *)v104 - 2)
                 ^ *(_DWORD *)(v102 + 8);
            HIDWORD(v319) = &qword_F1150[(unsigned __int8)(v312 ^ BYTE4(v177))];
            v383 = (unsigned __int8)((v333 ^ HIDWORD(v177) ^ 0x40000000u) >> 16);
            v196 = 0xFFFFFF - HIDWORD(v177);
            v107 = HIDWORD(qword_EE948[(unsigned __int8)v203])
                 ^ (0xFFFFFF - HIDWORD(v177))
                 ^ 0xEFFFFFFF
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v280) + 1)
                 ^ *((_DWORD *)v104 - 1);
            v108 = (unsigned __int8)v101;
            v375 = (char *)&qword_F0150[BYTE2(v101)];
            v109 = (unsigned __int8)v222;
            v389 = (char *)&qword_F0150[BYTE2(v222)];
            v110 = (char *)&qword_EF950[BYTE1(v235)];
            v334 = (char *)&qword_F0150[BYTE2(v248)];
            v351 = (char *)&qword_F1150[(unsigned __int8)(v326 ^ BYTE4(v177))];
            v313 = (unsigned __int8)((v326 ^ HIDWORD(v177) ^ 0x30000000u) >> 16);
            v411 = (unsigned __int8)((unsigned __int16)(WORD2(v177) ^ v97) >> 8);
            v371 = (char *)&qword_F1150[(unsigned __int8)(BYTE4(v177) ^ v97)];
            v223 = *((_DWORD *)v103 - 2)
                 ^ v106
                 ^ *((_DWORD *)&unk_F1948 + 2 * (unsigned __int8)((unsigned __int16)(v326 ^ WORD2(v177)) >> 8))
                 ^ *((_DWORD *)&unk_F2148 + 2 * BYTE2(v230));
            v231 = v107
                 ^ *((_DWORD *)v105 - 1)
                 ^ *(_DWORD *)(v102 + 12)
                 ^ *((_DWORD *)v103 - 1)
                 ^ *((_DWORD *)&unk_F1948 + 2 * (unsigned __int8)((unsigned __int16)(v326 ^ WORD2(v177)) >> 8) + 1)
                 ^ *((_DWORD *)&unk_F2148 + 2 * BYTE2(v230) + 1);
            v111 = HIDWORD(qword_EE948[(unsigned __int8)~(_BYTE)v319])
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v272) + 1)
                 ^ (HIDWORD(v177) - 0xFFFFFF);
            HIDWORD(v177) -= 0x1FFFFFF;
            v112 = (char *)&qword_F0150[(unsigned __int8)((unsigned int)~v96 >> 16)];
            v327 = (char *)&qword_EF950[(unsigned __int8)((unsigned __int16)~(_WORD)v96 >> 8)];
            v113 = ~(LODWORD(qword_EE948[(unsigned __int8)~(_BYTE)v319]) ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v272)))
                 ^ *((_DWORD *)v295 - 2)
                 ^ *((_DWORD *)v112 - 2);
            v114 = HIDWORD(qword_F0948[(unsigned int)~v100 >> 24])
                 ^ v111
                 ^ *((_DWORD *)v295 - 1)
                 ^ *((_DWORD *)v112 - 1);
            LODWORD(v319) = &qword_F0150[(unsigned __int8)~BYTE2(v100)];
            v115 = *(_DWORD *)(HIDWORD(v319) - 4);
            v116 = *(_DWORD *)(HIDWORD(v319) - 8);
            v296 = BYTE2(v211);
            HIDWORD(v319) = &qword_F1150[(unsigned __int8)v211];
            v420 = (unsigned __int8)~(_BYTE)v96;
            v402 = HIBYTE(v255);
            v361 = (char *)&qword_F1150[(unsigned __int8)v255];
            v217 = v114 ^ v115 ^ *((_DWORD *)&unk_F1948 + 2 * BYTE1(v211) + 1) ^ *((_DWORD *)&unk_F2148 + 2 * v383 + 1);
            v406 = BYTE2(v272);
            v212 = LODWORD(qword_F0948[(unsigned int)~v100 >> 24])
                 ^ v113
                 ^ v116
                 ^ *((_DWORD *)&unk_F1948 + 2 * BYTE1(v211))
                 ^ *((_DWORD *)&unk_F2148 + 2 * v383);
            v117 = *((_DWORD *)v110 - 2) ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v265)) ^ ~LODWORD(qword_EE948[v109]);
            v118 = *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v265) + 1)
                 ^ HIDWORD(qword_EE948[v109])
                 ^ ~(v196 ^ 0x30000000)
                 ^ *((_DWORD *)v110 - 1);
            v269 = (unsigned __int8)~(_BYTE)v100;
            v119 = (char *)&qword_EF950[(unsigned __int8)((unsigned __int16)~(_WORD)v100 >> 8)];
            v120 = (char *)&qword_F0150[BYTE2(v190)];
            v346 = (char *)&qword_EF950[BYTE1(v190)];
            v121 = v118 ^ *((_DWORD *)v334 - 1) ^ HIDWORD(qword_F0948[HIBYTE(v203)]) ^ *((_DWORD *)v351 - 1);
            v122 = v117 ^ *((_DWORD *)v334 - 2) ^ LODWORD(qword_F0948[HIBYTE(v203)]) ^ *((_DWORD *)v351 - 2);
            v429 = BYTE1(v272);
            v123 = *((_DWORD *)&unk_F1948 + 2 * v411);
            v352 = (char *)&qword_F1150[(unsigned __int8)v272];
            v124 = v121 ^ *((_DWORD *)&unk_F1948 + 2 * v411 + 1);
            v125 = BYTE2(v184);
            v273 = BYTE1(v184);
            v412 = (unsigned __int8)v235;
            v126 = HIBYTE(v235);
            v236 = v122 ^ v123 ^ *((_DWORD *)&unk_F2148 + 2 * BYTE2(v280));
            v394 = 8 * v126 + 985408;
            v300 = (unsigned __int8)v248;
            v242 = v124 ^ *((_DWORD *)&unk_F2148 + 2 * BYTE2(v280) + 1);
            v335 = (char *)&qword_EF950[BYTE1(v248)];
            v127 = *((_DWORD *)v327 - 2);
            v128 = *((_DWORD *)v327 - 1);
            v328 = (char *)&qword_F0150[BYTE2(v203)];
            v256 = (char *)&qword_F1150[(unsigned __int8)v280];
            v384 = (char *)&qword_EF950[BYTE1(v203)];
            v204 = BYTE2(v265);
            v266 = BYTE1(v265);
            v185 = *(_DWORD *)(v319 - 8)
                 ^ ~LODWORD(qword_EE948[v108])
                 ^ *((_DWORD *)&unk_EF148 + 2 * v398)
                 ^ v127
                 ^ *(_DWORD *)(v341 + 8)
                 ^ *(_DWORD *)(HIDWORD(v319) - 8)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v402)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v406);
            v191 = *(_DWORD *)(v319 - 4)
                 ^ HIDWORD(qword_EE948[v108])
                 ^ ~(v196 ^ 0x20000000)
                 ^ *((_DWORD *)&unk_EF148 + 2 * v398 + 1)
                 ^ v128
                 ^ *(_DWORD *)(v341 + 12)
                 ^ *(_DWORD *)(HIDWORD(v319) - 4)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v402 + 1)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v406 + 1);
            v129 = *((_QWORD *)v119 - 1);
            v130 = ~LODWORD(qword_EE948[v420]) ^ *((_DWORD *)&unk_EF148 + 2 * v426) ^ v129;
            v131 = HIDWORD(qword_EE948[v420])
                 ^ v196
                 ^ 0xBFFFFFFF
                 ^ *((_DWORD *)&unk_EF148 + 2 * v426 + 1)
                 ^ HIDWORD(v129)
                 ^ *((_DWORD *)v120 - 1);
            v132 = *(_QWORD *)(v356 + 8);
            v249 = v131
                 ^ HIDWORD(v132)
                 ^ *((_DWORD *)v361 - 1)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v429 + 1)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v125 + 1);
            v342 = *((_DWORD *)&unk_F2148 + 2 * v204);
            v357 = *((_DWORD *)&unk_F2148 + 2 * v204 + 1);
            v205 = v130
                 ^ *((_DWORD *)v120 - 2)
                 ^ v132
                 ^ *((_DWORD *)v361 - 2)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v429)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v125);
            HIDWORD(v132) = v196
                          ^ 0x9FFFFFFF
                          ^ HIDWORD(qword_EE948[v269])
                          ^ *((_DWORD *)&unk_EF148 + 2 * v288 + 1)
                          ^ *((_DWORD *)v346 - 1)
                          ^ *((_DWORD *)v375 - 1)
                          ^ HIDWORD(qword_F0948[(unsigned int)~v96 >> 24])
                          ^ *((_DWORD *)v352 - 1)
                          ^ *((_DWORD *)&unk_F1948 + 2 * v273 + 1);
            v133 = ~LODWORD(qword_EE948[v269])
                 ^ *((_DWORD *)&unk_EF148 + 2 * v288)
                 ^ *((_DWORD *)v346 - 2)
                 ^ *((_DWORD *)v375 - 2)
                 ^ LODWORD(qword_F0948[(unsigned int)~v96 >> 24])
                 ^ *((_DWORD *)v352 - 2)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v273);
            v270 = ~LODWORD(qword_EE948[v300])
                 ^ *((_DWORD *)&unk_EF148 + 2 * v308)
                 ^ *((_DWORD *)v384 - 2)
                 ^ *((_DWORD *)v389 - 2)
                 ^ *(_DWORD *)(v394 + 8)
                 ^ *((_DWORD *)v256 - 2)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v266)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v313);
            v274 = ~(v196 ^ 0x70000000)
                 ^ HIDWORD(qword_EE948[v300])
                 ^ *((_DWORD *)&unk_EF148 + 2 * v308 + 1)
                 ^ *((_DWORD *)v384 - 1)
                 ^ *((_DWORD *)v389 - 1)
                 ^ *(_DWORD *)(v394 + 12)
                 ^ *((_DWORD *)v256 - 1)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v266 + 1)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v313 + 1);
            v197 = *((_DWORD *)&unk_EF148 + 2 * v431 + 1)
                 ^ HIDWORD(qword_EE948[v412])
                 ^ v196
                 ^ 0xAFFFFFFF
                 ^ *((_DWORD *)v335 - 1)
                 ^ *((_DWORD *)v328 - 1)
                 ^ *(_DWORD *)(v367 + 12)
                 ^ *((_DWORD *)v371 - 1)
                 ^ *((_DWORD *)&unk_F1948 + 2 * BYTE1(v280) + 1)
                 ^ v357;
            v181 = *((_DWORD *)v335 - 2)
                 ^ ~LODWORD(qword_EE948[v412])
                 ^ *((_DWORD *)&unk_EF148 + 2 * v431)
                 ^ *((_DWORD *)v328 - 2)
                 ^ *(_DWORD *)(v367 + 8)
                 ^ *((_DWORD *)v371 - 2)
                 ^ *((_DWORD *)&unk_F1948 + 2 * BYTE1(v280))
                 ^ v342;
            v134 = *((_DWORD *)&unk_F2148 + 2 * v296 + 1) ^ HIDWORD(v132);
            v281 = HIBYTE(v217);
            LOWORD(v266) = *((_WORD *)&unk_F2148 + 4 * v296 + 2) ^ WORD2(v132);
            v417 = HIBYTE(v191);
            v257 = v133 ^ *((_DWORD *)&unk_F2148 + 2 * v296);
            v297 = HIBYTE(v249);
            v427 = HIBYTE(v242);
            v301 = HIBYTE(v197);
            v135 = (int *)((char *)&unk_EF148 + 8 * HIBYTE(v134));
            v368 = 8 * HIBYTE(v236) + 985408;
            v329 = (char *)&unk_EF148 + 8 * HIBYTE(v217);
            v376 = 8 * HIBYTE(v205) + 985408;
            v136 = *v135;
            v137 = qword_F1150[(unsigned __int8)v217 - 1];
            v138 = (char *)&qword_EF950[BYTE1(v236)];
            LODWORD(v132) = &qword_F0150[BYTE2(v181)];
            v139 = BYTE1(v242);
            v140 = qword_F0948[HIBYTE(v270)];
            v141 = v135[1]
                 ^ HIDWORD(qword_EE948[(unsigned __int8)v223])
                 ^ *((_DWORD *)v138 - 1)
                 ^ *(_DWORD *)(v132 - 4)
                 ^ HIDWORD(v140)
                 ^ HIDWORD(v137);
            v399 = (unsigned __int8)v236;
            v385 = (char *)&qword_F0150[BYTE2(v236)];
            v142 = v136
                 ^ LODWORD(qword_EE948[(unsigned __int8)v223])
                 ^ *((_DWORD *)v138 - 2)
                 ^ *(_DWORD *)(v132 - 8)
                 ^ v140;
            LODWORD(v140) = &qword_EF950[BYTE1(v181)];
            HIDWORD(v137) = &qword_F0150[BYTE2(v270)];
            v237 = BYTE2(v191);
            v307 = v142 ^ v137 ^ *((_DWORD *)&unk_F1948 + 2 * BYTE1(v191)) ^ *((_DWORD *)&unk_F2148 + 2 * BYTE2(v249));
            v143 = BYTE1(v249);
            v312 = v141 ^ *((_DWORD *)&unk_F1948 + 2 * BYTE1(v191) + 1) ^ *((_DWORD *)&unk_F2148 + 2 * BYTE2(v249) + 1);
            v372 = (char *)&qword_F1150[(unsigned __int8)v249];
            v403 = BYTE2(v134);
            v407 = (unsigned __int8)v205;
            v395 = (char *)&qword_F0150[BYTE2(v205)];
            v250 = (char *)&qword_EF950[BYTE1(v257)];
            v353 = (char *)&qword_F0150[BYTE2(v212)];
            v362 = (char *)&qword_F1150[(unsigned __int8)v242];
            v243 = BYTE2(v242);
            LODWORD(v137) = BYTE1(v197);
            v380 = (char *)&qword_F1150[(unsigned __int8)v197];
            v144 = BYTE2(v217);
            v218 = BYTE1(v217);
            v421 = v144;
            v413 = (unsigned __int8)v181;
            v319 = qword_EE948[(unsigned __int8)v185]
                 ^ *((_QWORD *)&unk_EF148 + HIBYTE(v274))
                 ^ qword_EF950[BYTE1(v205) - 1]
                 ^ qword_F0150[BYTE2(v257) - 1]
                 ^ qword_F0948[HIBYTE(v212)]
                 ^ qword_F1150[(unsigned __int8)v231 - 1]
                 ^ *((_QWORD *)&unk_F1948 + v139)
                 ^ *((_QWORD *)&unk_F2148 + BYTE2(v197));
            v145 = *((_DWORD *)&unk_EF148 + 2 * v281) ^ LODWORD(qword_EE948[v399]);
            v182 = 8 * HIBYTE(v181) + 985408;
            v146 = *(_DWORD *)(v140 - 8);
            v206 = (unsigned __int8)v270;
            v282 = (char *)&qword_EF950[BYTE1(v270)];
            v147 = *((_DWORD *)v329 + 1)
                 ^ HIDWORD(qword_EE948[v399])
                 ^ *(_DWORD *)(v140 - 4)
                 ^ *(_DWORD *)(HIDWORD(v137) - 4)
                 ^ HIDWORD(qword_F0948[HIBYTE(v223)]);
            v148 = (char *)&qword_F1150[(unsigned __int8)v191];
            LODWORD(v140) = &qword_F0150[BYTE2(v223)];
            v347 = (char *)&qword_EF950[BYTE1(v223)];
            HIDWORD(v140) = BYTE1(v266);
            v192 = (char *)&qword_F1150[(unsigned __int8)v266];
            v336 = (unsigned __int8)v257;
            v198 = 8 * HIBYTE(v257) + 985408;
            v258 = (char *)&qword_EF950[BYTE1(v212)];
            v268 = v147
                 ^ *((_DWORD *)v148 - 1)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v143 + 1)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v403 + 1);
            v264 = v145
                 ^ v146
                 ^ *(_DWORD *)(HIDWORD(v137) - 8)
                 ^ LODWORD(qword_F0948[HIBYTE(v223)])
                 ^ *((_DWORD *)v148 - 2)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v143)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v403);
            v343 = (char *)&qword_F0150[BYTE2(v185)];
            v390 = (char *)&qword_EF950[BYTE1(v185)];
            v149 = 8 * HIBYTE(v185) + 985408;
            v186 = (char *)&qword_F1150[(unsigned __int8)v274];
            v224 = BYTE1(v231);
            v326 = HIDWORD(qword_EE948[v407])
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v231) + 1)
                 ^ *((_DWORD *)v250 - 1)
                 ^ *((_DWORD *)v353 - 1)
                 ^ *(_DWORD *)(v149 + 12)
                 ^ *((_DWORD *)v362 - 1)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v137 + 1)
                 ^ *((_DWORD *)&unk_F2148 + 2 * BYTE2(v274) + 1);
            v287 = *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v231))
                 ^ LODWORD(qword_EE948[v407])
                 ^ *((_DWORD *)v250 - 2)
                 ^ *((_DWORD *)v353 - 2)
                 ^ *(_DWORD *)(v149 + 8)
                 ^ *((_DWORD *)v362 - 2)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v137)
                 ^ *((_DWORD *)&unk_F2148 + 2 * BYTE2(v274));
            v150 = *((_DWORD *)&unk_EF148 + 2 * v427) ^ LODWORD(qword_EE948[v336]);
            HIDWORD(v132) = HIDWORD(qword_EE948[v413])
                          ^ *((_DWORD *)&unk_EF148 + 2 * v417 + 1)
                          ^ *((_DWORD *)v282 - 1)
                          ^ *(_DWORD *)(v140 - 4)
                          ^ *(_DWORD *)(v368 + 12);
            v151 = LODWORD(qword_EE948[v413])
                 ^ *((_DWORD *)&unk_EF148 + 2 * v417)
                 ^ *((_DWORD *)v282 - 2)
                 ^ *(_DWORD *)(v140 - 8)
                 ^ *(_DWORD *)(v368 + 8);
            v152 = *((_DWORD *)&unk_F1948 + 2 * BYTE1(v274));
            v153 = *((_DWORD *)&unk_F1948 + 2 * BYTE1(v274) + 1);
            v275 = *((_QWORD *)&unk_F2148 + BYTE2(v231));
            v154 = *((_DWORD *)&unk_EF148 + 2 * v427 + 1) ^ HIDWORD(qword_EE948[v336]) ^ *((_DWORD *)v258 - 1);
            v229 = *((_DWORD *)v372 - 2)
                 ^ v151
                 ^ *((_DWORD *)&unk_F1948 + 2 * HIDWORD(v140))
                 ^ *((_DWORD *)&unk_F2148 + 2 * v421);
            v333 = HIDWORD(v132)
                 ^ *((_DWORD *)v372 - 1)
                 ^ *((_DWORD *)&unk_F1948 + 2 * HIDWORD(v140) + 1)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v421 + 1);
            v155 = LODWORD(qword_EE948[v206]) ^ *((_DWORD *)&unk_EF148 + 2 * v297);
            LODWORD(v132) = *((_DWORD *)&unk_EF148 + 2 * v297 + 1) ^ HIDWORD(qword_EE948[v206]);
            v207 = *(_DWORD *)(v376 + 8)
                 ^ v150
                 ^ *((_DWORD *)v258 - 2)
                 ^ *((_DWORD *)v343 - 2)
                 ^ *((_DWORD *)v380 - 2)
                 ^ v152;
            v98 = *((_DWORD *)&unk_F2148 + 2 * v237)
                ^ v155
                ^ *((_DWORD *)v347 - 2)
                ^ *((_DWORD *)v385 - 2)
                ^ *(_DWORD *)(v182 + 8)
                ^ *((_DWORD *)v192 - 2)
                ^ *((_DWORD *)&unk_F1948 + 2 * v218);
            v156 = *((_DWORD *)&unk_F2148 + 2 * v243);
            v157 = LODWORD(qword_EE948[(unsigned __int8)v212])
                 ^ *((_DWORD *)&unk_EF148 + 2 * v301)
                 ^ *((_DWORD *)v390 - 2)
                 ^ *((_DWORD *)v395 - 2)
                 ^ *(_DWORD *)(v198 + 8)
                 ^ *((_DWORD *)v186 - 2)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v224);
            v100 = v157 ^ v156;
            v97 = v154 ^ *((_DWORD *)v343 - 1) ^ *(_DWORD *)(v376 + 12) ^ *((_DWORD *)v380 - 1) ^ v153 ^ HIDWORD(v275);
            v96 = v207 ^ v275;
            v180 = v132
                 ^ *((_DWORD *)v347 - 1)
                 ^ *((_DWORD *)v385 - 1)
                 ^ *(_DWORD *)(v182 + 12)
                 ^ *((_DWORD *)v192 - 1)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v218 + 1)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v237 + 1);
            v99 = HIDWORD(qword_EE948[(unsigned __int8)v212])
                ^ *((_DWORD *)&unk_EF148 + 2 * v301 + 1)
                ^ *((_DWORD *)v390 - 1)
                ^ *((_DWORD *)v395 - 1)
                ^ *(_DWORD *)(v198 + 12)
                ^ *((_DWORD *)v186 - 1)
                ^ *((_DWORD *)&unk_F1948 + 2 * v224 + 1)
                ^ *((_DWORD *)&unk_F2148 + 2 * v243 + 1);
          }
          while ( v177 != 0xF5FFFFFFFFFFFFFFLL );
          v158 = &v441;
          v159 = &v457;
          v160 = v307;
          v457 = v319;
          v161 = v312;
          v468 = v157 ^ v156;
          v469 = v99;
          v455 = v307;
          v458 = v264;
          v456 = v312;
          v464 = v207 ^ v275;
          v459 = v268;
          v465 = v97;
          v466 = v98;
          v460 = v287;
          v467 = v180;
          v162 = v436;
          v461 = v326;
          v163 = HIDWORD(v314);
          v462 = v229;
          v463 = v333;
          v164 = v314;
          while ( 1 )
          {
            v165 = *(_DWORD *)(v162 + 8);
            v162 += 8;
            v166 = v161 ^ v163;
            v167 = *(_DWORD *)(v162 + 4);
            *(_DWORD *)v162 = v165 ^ v164 ^ v160;
            *(_DWORD *)(v162 + 4) = v167 ^ v166;
            if ( v439 == (_BYTE *)v162 )
              break;
            v164 = *v158;
            ++v159;
            v163 = v158[1];
            v158 += 2;
            v160 = *((_DWORD *)v159 - 2);
            v161 = *((_DWORD *)v159 - 1);
          }
          v3 = 0;
          ++*((_QWORD *)a1 + 17);
          if ( !n )
            break;
        }
        else if ( !n )
        {
          break;
        }
      }
    }
    v168 = v437;
    v169 = (__int64 *)v438;
    do
    {
      v168 += 4;
      result = *(void **)v169;
      v171 = *((_DWORD *)v169 + 1);
      v172 = *((_DWORD *)v169 + 2);
      v173 = *((_DWORD *)v169 + 3);
      v169 += 2;
      *(v168 - 4) = result;
      *(v168 - 3) = v171;
      *(v168 - 2) = v172;
      *(v168 - 1) = v173;
    }
    while ( v169 != &v440 );
    a1[16] = v3;
  }
  return result;
}
// EE948: using guessed type _QWORD qword_EE948[256];
// EF950: using guessed type _QWORD qword_EF950[256];
// F0150: using guessed type _QWORD qword_F0150[254];
// F0948: using guessed type _QWORD[257];
// F1150: using guessed type _QWORD qword_F1150[255];

//----- (000AAAF0) --------------------------------------------------------
void *__fastcall sph_groestl384_0(int a1, char *a2, size_t a3)
{
  int v3; // r6
  size_t v4; // r4
  int v5; // r8
  void *v6; // r0
  _BYTE *v7; // r0
  int *v8; // r12
  int v9; // r1
  int *v10; // r3
  int v11; // r6
  int v12; // t1
  int v13; // t1
  int v14; // r4
  int v15; // r2
  int v16; // r1
  int v17; // r12
  unsigned int v18; // r10
  unsigned int v19; // lr
  unsigned int v20; // r7
  int v21; // r9
  unsigned int v22; // r6
  int v23; // r4
  unsigned int v24; // r0
  int *v25; // r11
  _QWORD *v26; // r12
  _QWORD *v27; // r0
  _QWORD *v28; // r1
  _QWORD *v29; // r11
  int v30; // r3
  int v31; // r6
  int v32; // r2
  _QWORD *v33; // r12
  int v34; // r10
  int v35; // r5
  int v36; // r3
  _DWORD *v37; // r5
  int v38; // r8
  int v39; // r1
  int v40; // r3
  int v41; // r2
  int v42; // r12
  int v43; // r3
  int v44; // r6
  int v45; // r5
  int v46; // lr
  int v47; // r11
  _QWORD *v48; // r8
  _QWORD *v49; // r6
  int v50; // r12
  int v51; // r2
  int v52; // r3
  int v53; // lr
  int v54; // r0
  int v55; // r1
  int v56; // r0
  int v57; // r2
  int v58; // r3
  int v59; // r0
  int v60; // r12
  int v61; // r0
  __int64 v62; // r2
  int v63; // r1
  int v64; // r0
  int v65; // r12
  int v66; // r11
  int v67; // r4
  unsigned int v68; // r8
  unsigned int v69; // r10
  int v70; // r11
  _QWORD *v71; // r12
  _QWORD *v72; // r11
  int v73; // r6
  _QWORD *v74; // lr
  int v75; // r9
  int v76; // r5
  _QWORD *v77; // r4
  _QWORD *v78; // r12
  _QWORD *v79; // r0
  int v80; // r9
  int v81; // lr
  int v82; // r11
  int v83; // r12
  int v84; // r10
  int v85; // r1
  int v86; // r12
  int v87; // r4
  int v88; // r5
  int v89; // r4
  int v90; // r1
  int v91; // r6
  int v92; // r8
  int v93; // lr
  int v94; // r5
  int v95; // r4
  int v96; // r12
  int v97; // r6
  int v98; // r8
  __int64 v99; // r0
  int v100; // r9
  int v101; // r12
  int v102; // lr
  _QWORD *v103; // r12
  int v104; // r6
  int v105; // r5
  int v106; // r9
  int v107; // r6
  __int64 v108; // r2
  int v109; // r5
  int v110; // r12
  __int64 v111; // r2
  int v112; // r12
  int v113; // r5
  int v114; // r7
  int v115; // r6
  int v116; // r11
  int v117; // r9
  int v118; // r4
  int v119; // r2
  int v120; // r6
  int v121; // r8
  int v122; // lr
  int v123; // r10
  int v124; // r2
  int v125; // r11
  int v126; // r3
  unsigned int v127; // r1
  unsigned int v128; // r5
  unsigned int v129; // r0
  unsigned int v130; // lr
  unsigned int v131; // r12
  int v132; // r7
  unsigned int v133; // r2
  _QWORD *v134; // r5
  _QWORD *v135; // r1
  _QWORD *v136; // r0
  int v137; // r7
  int v138; // r5
  _QWORD *v139; // r1
  int v140; // r12
  int v141; // lr
  int v142; // r3
  int v143; // r3
  int v144; // r0
  int v145; // r10
  int v146; // r3
  _QWORD *v147; // r9
  int v148; // r0
  int v149; // r12
  int v150; // r7
  _QWORD *v151; // r0
  int v152; // r6
  unsigned int v153; // r2
  int v154; // r5
  unsigned int v155; // r12
  int v156; // r5
  _QWORD *v157; // lr
  int v158; // r9
  int v159; // r7
  int v160; // r1
  _QWORD *v161; // r8
  int v162; // r1
  unsigned int v163; // r2
  _QWORD *v164; // r9
  int v165; // r3
  int v166; // r2
  _QWORD *v167; // r6
  int v168; // r12
  int v169; // r4
  int v170; // r2
  _QWORD *v171; // r6
  int v172; // r3
  int v173; // r10
  _QWORD *v174; // r5
  int v175; // r1
  unsigned int v176; // r2
  int v177; // r6
  int v178; // r7
  unsigned int v179; // r2
  int v180; // lr
  int v181; // r3
  int v182; // lr
  int v183; // r0
  int v184; // r6
  unsigned int v185; // r0
  unsigned int v186; // r2
  __int64 v187; // r6
  _QWORD *v188; // r12
  _QWORD *v189; // r1
  int v190; // r3
  _QWORD *v191; // r0
  int v192; // r2
  int v193; // r3
  int v194; // r2
  int v195; // r9
  int v196; // r10
  int v197; // r2
  int v198; // r5
  int v199; // r12
  int v200; // r9
  int v201; // r3
  _QWORD *v202; // r0
  _QWORD *v203; // r2
  int v204; // r5
  int v205; // r12
  int v206; // lr
  int v207; // r3
  int v208; // r8
  __int64 v209; // r6
  int v210; // r1
  int v211; // r8
  int v212; // r1
  int v213; // r10
  int v214; // r1
  int v215; // r3
  int v216; // r10
  int v217; // r9
  int v218; // r5
  int v219; // r0
  int v220; // r0
  int v221; // r5
  int v222; // lr
  _QWORD *v223; // r2
  int v224; // r0
  int v225; // r3
  int v226; // r4
  int v227; // r1
  int v228; // r12
  int v229; // r3
  _QWORD *v230; // r8
  int v231; // r12
  int v232; // r1
  int v233; // r3
  int v234; // lr
  __int64 v235; // r2
  int v236; // r0
  int v237; // lr
  int v238; // r12
  int v239; // r1
  int v240; // r10
  _DWORD *v241; // r1
  int v242; // lr
  int v243; // r5
  int v244; // lr
  int v245; // r12
  int v246; // r1
  int v247; // r8
  int v248; // r5
  int v249; // r0
  int v250; // r10
  int v251; // r7
  int v252; // r4
  int v253; // r6
  int v254; // r5
  int *v255; // r0
  int *v256; // r1
  int v257; // r4
  int v258; // r3
  unsigned __int64 v259; // kr48_8
  int v260; // lr
  int v261; // r2
  int v262; // t1
  int v263; // r2
  void *result; // r0
  size_t v266; // r5
  int v267; // [sp+0h] [bp-354h]
  __int64 v268; // [sp+0h] [bp-354h]
  __int64 v269; // [sp+8h] [bp-34Ch]
  int v270; // [sp+8h] [bp-34Ch]
  unsigned int v271; // [sp+8h] [bp-34Ch]
  int v272; // [sp+8h] [bp-34Ch]
  unsigned int v273; // [sp+18h] [bp-33Ch]
  unsigned int v274; // [sp+18h] [bp-33Ch]
  int v275; // [sp+18h] [bp-33Ch]
  int v276; // [sp+18h] [bp-33Ch]
  int v277; // [sp+18h] [bp-33Ch]
  int v278; // [sp+1Ch] [bp-338h]
  unsigned int v279; // [sp+1Ch] [bp-338h]
  unsigned int v280; // [sp+1Ch] [bp-338h]
  int v281; // [sp+1Ch] [bp-338h]
  _QWORD *v282; // [sp+1Ch] [bp-338h]
  int v283; // [sp+1Ch] [bp-338h]
  unsigned int v284; // [sp+1Ch] [bp-338h]
  _QWORD *v285; // [sp+1Ch] [bp-338h]
  unsigned int v286; // [sp+1Ch] [bp-338h]
  int v287; // [sp+1Ch] [bp-338h]
  unsigned __int64 v288; // [sp+20h] [bp-334h]
  unsigned int v289; // [sp+20h] [bp-334h]
  _QWORD *v290; // [sp+20h] [bp-334h]
  unsigned int v291; // [sp+20h] [bp-334h]
  _QWORD *v292; // [sp+20h] [bp-334h]
  int v293; // [sp+20h] [bp-334h]
  int v294; // [sp+20h] [bp-334h]
  unsigned int v295; // [sp+24h] [bp-330h]
  unsigned int v296; // [sp+24h] [bp-330h]
  int v297; // [sp+24h] [bp-330h]
  int v298; // [sp+24h] [bp-330h]
  int v299; // [sp+28h] [bp-32Ch]
  unsigned int v300; // [sp+28h] [bp-32Ch]
  int v301; // [sp+28h] [bp-32Ch]
  unsigned int v302; // [sp+28h] [bp-32Ch]
  int v303; // [sp+28h] [bp-32Ch]
  int v304; // [sp+28h] [bp-32Ch]
  unsigned int v305; // [sp+28h] [bp-32Ch]
  int v306; // [sp+28h] [bp-32Ch]
  unsigned int v307; // [sp+2Ch] [bp-328h]
  int v308; // [sp+2Ch] [bp-328h]
  unsigned int v309; // [sp+2Ch] [bp-328h]
  int v310; // [sp+2Ch] [bp-328h]
  int v311; // [sp+2Ch] [bp-328h]
  int v312; // [sp+2Ch] [bp-328h]
  unsigned int v313; // [sp+2Ch] [bp-328h]
  unsigned int v314; // [sp+2Ch] [bp-328h]
  _QWORD *v315; // [sp+2Ch] [bp-328h]
  int v316; // [sp+2Ch] [bp-328h]
  __int64 v317; // [sp+30h] [bp-324h]
  unsigned int v318; // [sp+30h] [bp-324h]
  unsigned int v319; // [sp+30h] [bp-324h]
  int v320; // [sp+30h] [bp-324h]
  unsigned int v321; // [sp+34h] [bp-320h]
  unsigned int v322; // [sp+34h] [bp-320h]
  unsigned int v323; // [sp+38h] [bp-31Ch]
  unsigned int v324; // [sp+38h] [bp-31Ch]
  unsigned int v325; // [sp+38h] [bp-31Ch]
  unsigned int v326; // [sp+38h] [bp-31Ch]
  int v327; // [sp+38h] [bp-31Ch]
  unsigned int v328; // [sp+3Ch] [bp-318h]
  unsigned int v329; // [sp+3Ch] [bp-318h]
  int v330; // [sp+3Ch] [bp-318h]
  int v331; // [sp+3Ch] [bp-318h]
  unsigned int v332; // [sp+3Ch] [bp-318h]
  unsigned int v333; // [sp+3Ch] [bp-318h]
  _QWORD *v334; // [sp+3Ch] [bp-318h]
  _QWORD *v335; // [sp+3Ch] [bp-318h]
  int v336; // [sp+3Ch] [bp-318h]
  unsigned int v337; // [sp+40h] [bp-314h]
  unsigned int v338; // [sp+40h] [bp-314h]
  int v339; // [sp+40h] [bp-314h]
  int v340; // [sp+40h] [bp-314h]
  _QWORD *v341; // [sp+40h] [bp-314h]
  unsigned int v342; // [sp+40h] [bp-314h]
  int v343; // [sp+40h] [bp-314h]
  unsigned int v344; // [sp+40h] [bp-314h]
  _QWORD *v345; // [sp+40h] [bp-314h]
  int v346; // [sp+44h] [bp-310h]
  unsigned int v347; // [sp+44h] [bp-310h]
  unsigned int v348; // [sp+44h] [bp-310h]
  int v349; // [sp+44h] [bp-310h]
  unsigned int v350; // [sp+44h] [bp-310h]
  int v351; // [sp+44h] [bp-310h]
  int v352; // [sp+48h] [bp-30Ch]
  unsigned int v353; // [sp+48h] [bp-30Ch]
  unsigned int v354; // [sp+48h] [bp-30Ch]
  int v355; // [sp+48h] [bp-30Ch]
  int v356; // [sp+48h] [bp-30Ch]
  int v357; // [sp+48h] [bp-30Ch]
  unsigned int v358; // [sp+48h] [bp-30Ch]
  unsigned int v359; // [sp+48h] [bp-30Ch]
  int v360; // [sp+4Ch] [bp-308h]
  unsigned int v361; // [sp+4Ch] [bp-308h]
  unsigned int v362; // [sp+4Ch] [bp-308h]
  int v363; // [sp+4Ch] [bp-308h]
  unsigned int v364; // [sp+4Ch] [bp-308h]
  unsigned int v365; // [sp+4Ch] [bp-308h]
  int v366; // [sp+4Ch] [bp-308h]
  int v367; // [sp+50h] [bp-304h]
  unsigned int v368; // [sp+50h] [bp-304h]
  __int64 v369; // [sp+50h] [bp-304h]
  int v370; // [sp+50h] [bp-304h]
  unsigned int v371; // [sp+50h] [bp-304h]
  unsigned int v372; // [sp+50h] [bp-304h]
  int v373; // [sp+54h] [bp-300h]
  unsigned int v374; // [sp+54h] [bp-300h]
  int v375; // [sp+54h] [bp-300h]
  unsigned int v376; // [sp+54h] [bp-300h]
  unsigned int v377; // [sp+54h] [bp-300h]
  unsigned int v378; // [sp+58h] [bp-2FCh]
  unsigned int v379; // [sp+58h] [bp-2FCh]
  int v380; // [sp+58h] [bp-2FCh]
  int v381; // [sp+58h] [bp-2FCh]
  unsigned int v382; // [sp+58h] [bp-2FCh]
  unsigned int v383; // [sp+58h] [bp-2FCh]
  int v384; // [sp+5Ch] [bp-2F8h]
  unsigned int v385; // [sp+5Ch] [bp-2F8h]
  int v386; // [sp+5Ch] [bp-2F8h]
  int v387; // [sp+5Ch] [bp-2F8h]
  unsigned int v388; // [sp+5Ch] [bp-2F8h]
  int v389; // [sp+5Ch] [bp-2F8h]
  int v390; // [sp+5Ch] [bp-2F8h]
  int v391; // [sp+5Ch] [bp-2F8h]
  unsigned int v392; // [sp+5Ch] [bp-2F8h]
  unsigned int v393; // [sp+5Ch] [bp-2F8h]
  int v394; // [sp+60h] [bp-2F4h]
  unsigned int v395; // [sp+60h] [bp-2F4h]
  _QWORD *v396; // [sp+60h] [bp-2F4h]
  _QWORD *v397; // [sp+60h] [bp-2F4h]
  unsigned int v398; // [sp+60h] [bp-2F4h]
  _QWORD *v399; // [sp+60h] [bp-2F4h]
  int v400; // [sp+60h] [bp-2F4h]
  unsigned int v401; // [sp+60h] [bp-2F4h]
  unsigned int v402; // [sp+60h] [bp-2F4h]
  _QWORD *v403; // [sp+64h] [bp-2F0h]
  int v404; // [sp+64h] [bp-2F0h]
  unsigned int v405; // [sp+64h] [bp-2F0h]
  int v406; // [sp+64h] [bp-2F0h]
  int v407; // [sp+64h] [bp-2F0h]
  unsigned int v408; // [sp+64h] [bp-2F0h]
  unsigned int v409; // [sp+64h] [bp-2F0h]
  int v410; // [sp+68h] [bp-2ECh]
  unsigned int v411; // [sp+68h] [bp-2ECh]
  int v412; // [sp+68h] [bp-2ECh]
  int v413; // [sp+68h] [bp-2ECh]
  unsigned int v414; // [sp+68h] [bp-2ECh]
  int v415; // [sp+68h] [bp-2ECh]
  int v416; // [sp+68h] [bp-2ECh]
  int v417; // [sp+68h] [bp-2ECh]
  unsigned int v418; // [sp+68h] [bp-2ECh]
  int v419; // [sp+68h] [bp-2ECh]
  unsigned int v420; // [sp+68h] [bp-2ECh]
  unsigned int v421; // [sp+6Ch] [bp-2E8h]
  int v422; // [sp+6Ch] [bp-2E8h]
  unsigned int v423; // [sp+6Ch] [bp-2E8h]
  int v424; // [sp+6Ch] [bp-2E8h]
  int v425; // [sp+6Ch] [bp-2E8h]
  unsigned int v426; // [sp+6Ch] [bp-2E8h]
  _QWORD *v427; // [sp+6Ch] [bp-2E8h]
  unsigned int v428; // [sp+6Ch] [bp-2E8h]
  unsigned int v429; // [sp+70h] [bp-2E4h]
  _QWORD *v430; // [sp+70h] [bp-2E4h]
  unsigned int v431; // [sp+70h] [bp-2E4h]
  int v432; // [sp+70h] [bp-2E4h]
  int v433; // [sp+70h] [bp-2E4h]
  int v434; // [sp+70h] [bp-2E4h]
  unsigned int v435; // [sp+70h] [bp-2E4h]
  int v436; // [sp+70h] [bp-2E4h]
  unsigned int v437; // [sp+70h] [bp-2E4h]
  int v438; // [sp+74h] [bp-2E0h]
  unsigned int v439; // [sp+74h] [bp-2E0h]
  int v440; // [sp+74h] [bp-2E0h]
  _QWORD *v441; // [sp+74h] [bp-2E0h]
  unsigned int v442; // [sp+74h] [bp-2E0h]
  int v443; // [sp+74h] [bp-2E0h]
  int v444; // [sp+74h] [bp-2E0h]
  int v445; // [sp+74h] [bp-2E0h]
  unsigned int v446; // [sp+74h] [bp-2E0h]
  int v447; // [sp+78h] [bp-2DCh]
  int v448; // [sp+78h] [bp-2DCh]
  unsigned int v449; // [sp+78h] [bp-2DCh]
  int v450; // [sp+78h] [bp-2DCh]
  unsigned int v451; // [sp+78h] [bp-2DCh]
  int v452; // [sp+78h] [bp-2DCh]
  unsigned int v453; // [sp+78h] [bp-2DCh]
  int v454; // [sp+7Ch] [bp-2D8h]
  unsigned int v455; // [sp+7Ch] [bp-2D8h]
  int v456; // [sp+7Ch] [bp-2D8h]
  unsigned int v457; // [sp+7Ch] [bp-2D8h]
  int v458; // [sp+7Ch] [bp-2D8h]
  unsigned int v459; // [sp+7Ch] [bp-2D8h]
  unsigned int v460; // [sp+7Ch] [bp-2D8h]
  int v461; // [sp+80h] [bp-2D4h]
  unsigned int v462; // [sp+80h] [bp-2D4h]
  unsigned int v463; // [sp+80h] [bp-2D4h]
  int v464; // [sp+80h] [bp-2D4h]
  int v465; // [sp+80h] [bp-2D4h]
  unsigned int v466; // [sp+80h] [bp-2D4h]
  int v467; // [sp+84h] [bp-2D0h]
  unsigned int v468; // [sp+84h] [bp-2D0h]
  unsigned int v469; // [sp+84h] [bp-2D0h]
  int v470; // [sp+84h] [bp-2D0h]
  _QWORD *v471; // [sp+84h] [bp-2D0h]
  unsigned int v472; // [sp+84h] [bp-2D0h]
  __int64 v473; // [sp+88h] [bp-2CCh]
  int v474; // [sp+88h] [bp-2CCh]
  int v475; // [sp+88h] [bp-2CCh]
  unsigned int v476; // [sp+88h] [bp-2CCh]
  int v477; // [sp+88h] [bp-2CCh]
  unsigned int v478; // [sp+88h] [bp-2CCh]
  int v479; // [sp+88h] [bp-2CCh]
  unsigned int v480; // [sp+88h] [bp-2CCh]
  int v481; // [sp+8Ch] [bp-2C8h]
  unsigned int v482; // [sp+8Ch] [bp-2C8h]
  int v483; // [sp+8Ch] [bp-2C8h]
  __int16 v484; // [sp+8Ch] [bp-2C8h]
  _QWORD *v485; // [sp+8Ch] [bp-2C8h]
  int v486; // [sp+8Ch] [bp-2C8h]
  unsigned int v487; // [sp+8Ch] [bp-2C8h]
  int v488; // [sp+90h] [bp-2C4h]
  int v489; // [sp+90h] [bp-2C4h]
  int v490; // [sp+90h] [bp-2C4h]
  int v491; // [sp+90h] [bp-2C4h]
  __int64 v492; // [sp+90h] [bp-2C4h]
  int v493; // [sp+90h] [bp-2C4h]
  unsigned int v494; // [sp+90h] [bp-2C4h]
  int v495; // [sp+94h] [bp-2C0h]
  int v496; // [sp+94h] [bp-2C0h]
  int v497; // [sp+94h] [bp-2C0h]
  unsigned int v498; // [sp+94h] [bp-2C0h]
  int v499; // [sp+98h] [bp-2BCh]
  char *v500; // [sp+98h] [bp-2BCh]
  int v501; // [sp+98h] [bp-2BCh]
  unsigned int v502; // [sp+98h] [bp-2BCh]
  _QWORD *v503; // [sp+98h] [bp-2BCh]
  int v504; // [sp+98h] [bp-2BCh]
  int v505; // [sp+98h] [bp-2BCh]
  int v506; // [sp+9Ch] [bp-2B8h]
  int v507; // [sp+9Ch] [bp-2B8h]
  int v508; // [sp+9Ch] [bp-2B8h]
  int v509; // [sp+9Ch] [bp-2B8h]
  _QWORD *v510; // [sp+9Ch] [bp-2B8h]
  _QWORD *v511; // [sp+9Ch] [bp-2B8h]
  int v512; // [sp+A0h] [bp-2B4h]
  unsigned int v513; // [sp+A0h] [bp-2B4h]
  int v514; // [sp+A0h] [bp-2B4h]
  unsigned int v515; // [sp+A0h] [bp-2B4h]
  int v516; // [sp+A0h] [bp-2B4h]
  unsigned int v517; // [sp+A0h] [bp-2B4h]
  int v518; // [sp+A4h] [bp-2B0h]
  unsigned int v519; // [sp+A4h] [bp-2B0h]
  unsigned int v520; // [sp+A4h] [bp-2B0h]
  unsigned int v521; // [sp+A4h] [bp-2B0h]
  int v522; // [sp+A8h] [bp-2ACh]
  _QWORD *v523; // [sp+A8h] [bp-2ACh]
  _QWORD *v524; // [sp+A8h] [bp-2ACh]
  int v525; // [sp+A8h] [bp-2ACh]
  int v526; // [sp+A8h] [bp-2ACh]
  unsigned int v527; // [sp+A8h] [bp-2ACh]
  unsigned int v528; // [sp+A8h] [bp-2ACh]
  int v529; // [sp+A8h] [bp-2ACh]
  int v530; // [sp+ACh] [bp-2A8h]
  unsigned int v531; // [sp+ACh] [bp-2A8h]
  _QWORD *v532; // [sp+ACh] [bp-2A8h]
  int v533; // [sp+ACh] [bp-2A8h]
  unsigned int v534; // [sp+ACh] [bp-2A8h]
  int v535; // [sp+B0h] [bp-2A4h]
  _QWORD *v536; // [sp+B0h] [bp-2A4h]
  int v537; // [sp+B0h] [bp-2A4h]
  unsigned int v538; // [sp+B0h] [bp-2A4h]
  unsigned int v539; // [sp+B0h] [bp-2A4h]
  _QWORD *v540; // [sp+B4h] [bp-2A0h]
  int v541; // [sp+B4h] [bp-2A0h]
  int v542; // [sp+B4h] [bp-2A0h]
  _QWORD *v543; // [sp+B4h] [bp-2A0h]
  _QWORD *v544; // [sp+B4h] [bp-2A0h]
  int v545; // [sp+B4h] [bp-2A0h]
  unsigned int v546; // [sp+B8h] [bp-29Ch]
  int v547; // [sp+B8h] [bp-29Ch]
  unsigned int v548; // [sp+B8h] [bp-29Ch]
  int v549; // [sp+B8h] [bp-29Ch]
  int v550; // [sp+B8h] [bp-29Ch]
  _QWORD *v551; // [sp+B8h] [bp-29Ch]
  _QWORD *v552; // [sp+B8h] [bp-29Ch]
  int v553; // [sp+B8h] [bp-29Ch]
  unsigned int v554; // [sp+BCh] [bp-298h]
  unsigned int v555; // [sp+BCh] [bp-298h]
  int v556; // [sp+BCh] [bp-298h]
  _QWORD *v557; // [sp+BCh] [bp-298h]
  _QWORD *v558; // [sp+BCh] [bp-298h]
  _QWORD *v559; // [sp+BCh] [bp-298h]
  _QWORD *v560; // [sp+BCh] [bp-298h]
  int v561; // [sp+BCh] [bp-298h]
  _QWORD *v562; // [sp+C0h] [bp-294h]
  int v563; // [sp+C0h] [bp-294h]
  int v564; // [sp+C0h] [bp-294h]
  int v565; // [sp+C0h] [bp-294h]
  _QWORD *v566; // [sp+C0h] [bp-294h]
  _QWORD *v567; // [sp+C0h] [bp-294h]
  _QWORD *v568; // [sp+C0h] [bp-294h]
  int v569; // [sp+C0h] [bp-294h]
  _QWORD *v570; // [sp+C0h] [bp-294h]
  int v571; // [sp+C4h] [bp-290h]
  int v572; // [sp+C4h] [bp-290h]
  unsigned int v573; // [sp+C4h] [bp-290h]
  unsigned int v574; // [sp+C4h] [bp-290h]
  _QWORD *v575; // [sp+C4h] [bp-290h]
  _QWORD *v576; // [sp+C4h] [bp-290h]
  _QWORD *v577; // [sp+C4h] [bp-290h]
  _QWORD *v578; // [sp+C4h] [bp-290h]
  _QWORD *v579; // [sp+C8h] [bp-28Ch]
  int v580; // [sp+C8h] [bp-28Ch]
  _QWORD *v581; // [sp+C8h] [bp-28Ch]
  int v582; // [sp+C8h] [bp-28Ch]
  _QWORD *v583; // [sp+C8h] [bp-28Ch]
  _QWORD *v584; // [sp+C8h] [bp-28Ch]
  _QWORD *v585; // [sp+C8h] [bp-28Ch]
  unsigned __int64 v586; // [sp+CCh] [bp-288h]
  int v587; // [sp+CCh] [bp-288h]
  unsigned int v588; // [sp+CCh] [bp-288h]
  _QWORD *v589; // [sp+D0h] [bp-284h]
  _QWORD *v590; // [sp+D0h] [bp-284h]
  int v591; // [sp+D0h] [bp-284h]
  int v592; // [sp+D4h] [bp-280h]
  int v593; // [sp+D4h] [bp-280h]
  unsigned int v594; // [sp+D4h] [bp-280h]
  _QWORD *v595; // [sp+D4h] [bp-280h]
  int v596; // [sp+D4h] [bp-280h]
  _QWORD *v597; // [sp+D4h] [bp-280h]
  int v598; // [sp+D4h] [bp-280h]
  int v599; // [sp+D4h] [bp-280h]
  _QWORD *v600; // [sp+D4h] [bp-280h]
  _QWORD *v601; // [sp+D4h] [bp-280h]
  int v602; // [sp+D8h] [bp-27Ch]
  int v603; // [sp+D8h] [bp-27Ch]
  _QWORD *v604; // [sp+D8h] [bp-27Ch]
  _QWORD *v605; // [sp+D8h] [bp-27Ch]
  _DWORD *v606; // [sp+D8h] [bp-27Ch]
  size_t n; // [sp+DCh] [bp-278h]
  int v608; // [sp+E0h] [bp-274h]
  _QWORD *v609; // [sp+E0h] [bp-274h]
  _QWORD *v610; // [sp+E0h] [bp-274h]
  unsigned int v611; // [sp+E0h] [bp-274h]
  _QWORD *v612; // [sp+E0h] [bp-274h]
  _QWORD *v613; // [sp+E0h] [bp-274h]
  int v614; // [sp+E0h] [bp-274h]
  unsigned int v615; // [sp+E0h] [bp-274h]
  _QWORD *v616; // [sp+E0h] [bp-274h]
  _QWORD *v617; // [sp+E0h] [bp-274h]
  _QWORD *v618; // [sp+E0h] [bp-274h]
  int v619; // [sp+E4h] [bp-270h]
  _QWORD *v620; // [sp+E4h] [bp-270h]
  _QWORD *v621; // [sp+E4h] [bp-270h]
  _QWORD *v622; // [sp+E4h] [bp-270h]
  _QWORD *v623; // [sp+E4h] [bp-270h]
  _QWORD *v624; // [sp+E4h] [bp-270h]
  _QWORD *v625; // [sp+E4h] [bp-270h]
  _QWORD *v626; // [sp+E4h] [bp-270h]
  _QWORD *v627; // [sp+E8h] [bp-26Ch]
  _QWORD *v628; // [sp+E8h] [bp-26Ch]
  _QWORD *v629; // [sp+E8h] [bp-26Ch]
  _QWORD *v630; // [sp+E8h] [bp-26Ch]
  _QWORD *v631; // [sp+E8h] [bp-26Ch]
  _QWORD *v632; // [sp+E8h] [bp-26Ch]
  int v633; // [sp+ECh] [bp-268h]
  _QWORD *v634; // [sp+ECh] [bp-268h]
  _QWORD *v635; // [sp+ECh] [bp-268h]
  _QWORD *v636; // [sp+ECh] [bp-268h]
  int v637; // [sp+ECh] [bp-268h]
  _QWORD *v638; // [sp+ECh] [bp-268h]
  _QWORD *v639; // [sp+ECh] [bp-268h]
  int v640; // [sp+F0h] [bp-264h]
  _QWORD *v641; // [sp+F0h] [bp-264h]
  char *v642; // [sp+F0h] [bp-264h]
  int v643; // [sp+F0h] [bp-264h]
  _QWORD *v644; // [sp+F0h] [bp-264h]
  _QWORD *v645; // [sp+F0h] [bp-264h]
  _DWORD *v646; // [sp+F0h] [bp-264h]
  _QWORD *v647; // [sp+F0h] [bp-264h]
  int v648; // [sp+F0h] [bp-264h]
  _QWORD *v649; // [sp+F0h] [bp-264h]
  int v650; // [sp+F4h] [bp-260h]
  _QWORD *v651; // [sp+F4h] [bp-260h]
  int *v652; // [sp+F4h] [bp-260h]
  _QWORD *v653; // [sp+F4h] [bp-260h]
  char *v654; // [sp+F4h] [bp-260h]
  int v655; // [sp+F4h] [bp-260h]
  _QWORD *v656; // [sp+F4h] [bp-260h]
  int v657; // [sp+F4h] [bp-260h]
  _DWORD *v658; // [sp+F4h] [bp-260h]
  _QWORD *v659; // [sp+F8h] [bp-25Ch]
  _QWORD *v660; // [sp+F8h] [bp-25Ch]
  int v661; // [sp+F8h] [bp-25Ch]
  int v662; // [sp+F8h] [bp-25Ch]
  _QWORD *v663; // [sp+F8h] [bp-25Ch]
  unsigned int v664; // [sp+FCh] [bp-258h]
  _QWORD *v665; // [sp+FCh] [bp-258h]
  _QWORD *v666; // [sp+FCh] [bp-258h]
  int v667; // [sp+FCh] [bp-258h]
  int v668; // [sp+FCh] [bp-258h]
  int v669; // [sp+100h] [bp-254h]
  _QWORD *v670; // [sp+100h] [bp-254h]
  _QWORD *v671; // [sp+100h] [bp-254h]
  int v672; // [sp+100h] [bp-254h]
  int v673; // [sp+100h] [bp-254h]
  int v674; // [sp+100h] [bp-254h]
  int v675; // [sp+104h] [bp-250h]
  char *v676; // [sp+104h] [bp-250h]
  int v677; // [sp+104h] [bp-250h]
  _QWORD *v678; // [sp+104h] [bp-250h]
  _QWORD *v679; // [sp+104h] [bp-250h]
  int v680; // [sp+104h] [bp-250h]
  int v681; // [sp+104h] [bp-250h]
  int v682; // [sp+104h] [bp-250h]
  _QWORD *v683; // [sp+104h] [bp-250h]
  int v684; // [sp+104h] [bp-250h]
  int v685; // [sp+108h] [bp-24Ch]
  char *v686; // [sp+108h] [bp-24Ch]
  _QWORD *v687; // [sp+108h] [bp-24Ch]
  int v688; // [sp+108h] [bp-24Ch]
  _QWORD *v689; // [sp+108h] [bp-24Ch]
  int v690; // [sp+10Ch] [bp-248h]
  _QWORD *v691; // [sp+10Ch] [bp-248h]
  _QWORD *v692; // [sp+10Ch] [bp-248h]
  _QWORD *v693; // [sp+10Ch] [bp-248h]
  unsigned int v694; // [sp+10Ch] [bp-248h]
  int v695; // [sp+10Ch] [bp-248h]
  int v696; // [sp+10Ch] [bp-248h]
  _QWORD *v697; // [sp+10Ch] [bp-248h]
  int v698; // [sp+110h] [bp-244h]
  _QWORD *v699; // [sp+110h] [bp-244h]
  int v700; // [sp+110h] [bp-244h]
  _QWORD *v701; // [sp+110h] [bp-244h]
  _QWORD *v702; // [sp+110h] [bp-244h]
  _QWORD *v703; // [sp+110h] [bp-244h]
  int v704; // [sp+114h] [bp-240h]
  int v705; // [sp+114h] [bp-240h]
  _QWORD *v706; // [sp+114h] [bp-240h]
  _QWORD *v707; // [sp+114h] [bp-240h]
  int v708; // [sp+114h] [bp-240h]
  int v709; // [sp+114h] [bp-240h]
  _QWORD *v710; // [sp+114h] [bp-240h]
  _QWORD *v711; // [sp+118h] [bp-23Ch]
  _QWORD *v712; // [sp+118h] [bp-23Ch]
  int v713; // [sp+118h] [bp-23Ch]
  int v714; // [sp+118h] [bp-23Ch]
  _QWORD *v715; // [sp+118h] [bp-23Ch]
  int v716; // [sp+118h] [bp-23Ch]
  int v717; // [sp+118h] [bp-23Ch]
  unsigned int v718; // [sp+11Ch] [bp-238h]
  _QWORD *v719; // [sp+11Ch] [bp-238h]
  _QWORD *v720; // [sp+11Ch] [bp-238h]
  int v721; // [sp+11Ch] [bp-238h]
  int v722; // [sp+11Ch] [bp-238h]
  int v723; // [sp+11Ch] [bp-238h]
  _QWORD *v724; // [sp+11Ch] [bp-238h]
  _QWORD *v725; // [sp+11Ch] [bp-238h]
  int v726; // [sp+120h] [bp-234h]
  _QWORD *v727; // [sp+120h] [bp-234h]
  _QWORD *v728; // [sp+120h] [bp-234h]
  _QWORD *v729; // [sp+120h] [bp-234h]
  int v730; // [sp+120h] [bp-234h]
  int v731; // [sp+120h] [bp-234h]
  _QWORD *v732; // [sp+120h] [bp-234h]
  int v733; // [sp+124h] [bp-230h]
  int v734; // [sp+124h] [bp-230h]
  _QWORD *v735; // [sp+124h] [bp-230h]
  int v736; // [sp+124h] [bp-230h]
  _QWORD *v737; // [sp+124h] [bp-230h]
  _QWORD *v738; // [sp+124h] [bp-230h]
  _QWORD *v739; // [sp+128h] [bp-22Ch]
  int v740; // [sp+128h] [bp-22Ch]
  _QWORD *v741; // [sp+128h] [bp-22Ch]
  int v742; // [sp+128h] [bp-22Ch]
  int v743; // [sp+128h] [bp-22Ch]
  int v744; // [sp+128h] [bp-22Ch]
  int v745; // [sp+12Ch] [bp-228h]
  _QWORD *v746; // [sp+12Ch] [bp-228h]
  int v747; // [sp+12Ch] [bp-228h]
  int v748; // [sp+12Ch] [bp-228h]
  int v749; // [sp+12Ch] [bp-228h]
  _QWORD *v750; // [sp+12Ch] [bp-228h]
  _QWORD *v751; // [sp+130h] [bp-224h]
  int v752; // [sp+130h] [bp-224h]
  int v753; // [sp+130h] [bp-224h]
  int v754; // [sp+130h] [bp-224h]
  int v755; // [sp+130h] [bp-224h]
  int v756; // [sp+130h] [bp-224h]
  _QWORD *v757; // [sp+134h] [bp-220h]
  int v758; // [sp+134h] [bp-220h]
  int v759; // [sp+134h] [bp-220h]
  int v760; // [sp+134h] [bp-220h]
  int v761; // [sp+138h] [bp-21Ch]
  int v762; // [sp+138h] [bp-21Ch]
  int v763; // [sp+13Ch] [bp-218h]
  _QWORD *v764; // [sp+13Ch] [bp-218h]
  int v765; // [sp+13Ch] [bp-218h]
  int v766; // [sp+13Ch] [bp-218h]
  _QWORD *v767; // [sp+13Ch] [bp-218h]
  int v768; // [sp+13Ch] [bp-218h]
  int v769; // [sp+13Ch] [bp-218h]
  int v770; // [sp+140h] [bp-214h]
  _QWORD *v771; // [sp+140h] [bp-214h]
  int v772; // [sp+140h] [bp-214h]
  int v773; // [sp+140h] [bp-214h]
  int v774; // [sp+144h] [bp-210h]
  _QWORD *v775; // [sp+144h] [bp-210h]
  int v776; // [sp+144h] [bp-210h]
  int v777; // [sp+144h] [bp-210h]
  unsigned int v778; // [sp+144h] [bp-210h]
  int v779; // [sp+148h] [bp-20Ch]
  char *v780; // [sp+148h] [bp-20Ch]
  int v781; // [sp+148h] [bp-20Ch]
  unsigned int v782; // [sp+14Ch] [bp-208h]
  int v783; // [sp+14Ch] [bp-208h]
  unsigned int v784; // [sp+14Ch] [bp-208h]
  unsigned int v785; // [sp+14Ch] [bp-208h]
  int v786; // [sp+150h] [bp-204h]
  _QWORD *v787; // [sp+150h] [bp-204h]
  char *v788; // [sp+150h] [bp-204h]
  unsigned int v789; // [sp+150h] [bp-204h]
  int v790; // [sp+150h] [bp-204h]
  int v791; // [sp+154h] [bp-200h]
  _QWORD *v792; // [sp+154h] [bp-200h]
  int v793; // [sp+154h] [bp-200h]
  int v794; // [sp+154h] [bp-200h]
  unsigned int v795; // [sp+158h] [bp-1FCh]
  _QWORD *v796; // [sp+158h] [bp-1FCh]
  char *v797; // [sp+158h] [bp-1FCh]
  unsigned int v798; // [sp+158h] [bp-1FCh]
  int v799; // [sp+158h] [bp-1FCh]
  int v800; // [sp+15Ch] [bp-1F8h]
  _QWORD *v801; // [sp+15Ch] [bp-1F8h]
  int v802; // [sp+15Ch] [bp-1F8h]
  int v803; // [sp+15Ch] [bp-1F8h]
  unsigned int v804; // [sp+15Ch] [bp-1F8h]
  int v805; // [sp+160h] [bp-1F4h]
  _QWORD *v806; // [sp+160h] [bp-1F4h]
  int v807; // [sp+160h] [bp-1F4h]
  int v808; // [sp+160h] [bp-1F4h]
  _QWORD *v809; // [sp+164h] [bp-1F0h]
  char *v810; // [sp+164h] [bp-1F0h]
  unsigned int v811; // [sp+164h] [bp-1F0h]
  unsigned int v812; // [sp+164h] [bp-1F0h]
  _QWORD *v813; // [sp+168h] [bp-1ECh]
  _DWORD *v814; // [sp+168h] [bp-1ECh]
  int v815; // [sp+16Ch] [bp-1E8h]
  int v816; // [sp+16Ch] [bp-1E8h]
  int v817; // [sp+16Ch] [bp-1E8h]
  _QWORD *v818; // [sp+16Ch] [bp-1E8h]
  unsigned int v819; // [sp+170h] [bp-1E4h]
  int v820; // [sp+170h] [bp-1E4h]
  int v821; // [sp+174h] [bp-1E0h]
  _QWORD *v822; // [sp+174h] [bp-1E0h]
  int v823; // [sp+178h] [bp-1DCh]
  _QWORD *v824; // [sp+178h] [bp-1DCh]
  int v825; // [sp+17Ch] [bp-1D8h]
  char *v826; // [sp+17Ch] [bp-1D8h]
  int v827; // [sp+180h] [bp-1D4h]
  int v828; // [sp+180h] [bp-1D4h]
  _QWORD *v829; // [sp+180h] [bp-1D4h]
  int v830; // [sp+184h] [bp-1D0h]
  int v831; // [sp+184h] [bp-1D0h]
  int v832; // [sp+188h] [bp-1CCh]
  int v833; // [sp+18Ch] [bp-1C8h]
  int v834; // [sp+18Ch] [bp-1C8h]
  int v835; // [sp+190h] [bp-1C4h]
  int v836; // [sp+194h] [bp-1C0h]
  unsigned int v837; // [sp+198h] [bp-1BCh]
  char *src; // [sp+1C0h] [bp-194h]
  int v840; // [sp+1C8h] [bp-18Ch] BYREF
  void *v841; // [sp+1CCh] [bp-188h]
  _BYTE dest[128]; // [sp+1D0h] [bp-184h] BYREF
  unsigned __int64 v843; // [sp+250h] [bp-104h]
  int v844; // [sp+258h] [bp-FCh] BYREF
  int v845; // [sp+25Ch] [bp-F8h]
  int v846; // [sp+260h] [bp-F4h]
  int v847; // [sp+264h] [bp-F0h]
  int v848; // [sp+268h] [bp-ECh]
  int v849; // [sp+26Ch] [bp-E8h]
  __int64 v850; // [sp+270h] [bp-E4h]
  int v851; // [sp+278h] [bp-DCh]
  int v852; // [sp+27Ch] [bp-D8h]
  int v853; // [sp+280h] [bp-D4h]
  int v854; // [sp+284h] [bp-D0h]
  int v855; // [sp+288h] [bp-CCh]
  int v856; // [sp+28Ch] [bp-C8h]
  int v857; // [sp+290h] [bp-C4h]
  int v858; // [sp+294h] [bp-C0h]
  int v859; // [sp+298h] [bp-BCh]
  int v860; // [sp+29Ch] [bp-B8h]
  int v861; // [sp+2A0h] [bp-B4h]
  int v862; // [sp+2A4h] [bp-B0h]
  int v863; // [sp+2A8h] [bp-ACh]
  int v864; // [sp+2ACh] [bp-A8h]
  int v865; // [sp+2B0h] [bp-A4h]
  int v866; // [sp+2B4h] [bp-A0h]
  int v867; // [sp+2B8h] [bp-9Ch]
  int v868; // [sp+2BCh] [bp-98h]
  int v869; // [sp+2C0h] [bp-94h]
  int v870; // [sp+2C4h] [bp-90h]
  int v871; // [sp+2C8h] [bp-8Ch] BYREF
  int v872; // [sp+2CCh] [bp-88h]
  int v873; // [sp+2D0h] [bp-84h]
  int v874; // [sp+2D4h] [bp-80h]
  int v875; // [sp+2D8h] [bp-7Ch] BYREF
  int v876; // [sp+2DCh] [bp-78h]
  int v877; // [sp+2E0h] [bp-74h]
  int v878; // [sp+2E4h] [bp-70h]
  int v879; // [sp+2E8h] [bp-6Ch]
  int v880; // [sp+2ECh] [bp-68h]
  int v881; // [sp+2F0h] [bp-64h]
  int v882; // [sp+2F4h] [bp-60h]
  int v883; // [sp+2F8h] [bp-5Ch]
  int v884; // [sp+2FCh] [bp-58h]
  int v885; // [sp+300h] [bp-54h]
  int v886; // [sp+304h] [bp-50h]
  int v887; // [sp+308h] [bp-4Ch]
  int v888; // [sp+30Ch] [bp-48h]
  int v889; // [sp+310h] [bp-44h]
  int v890; // [sp+314h] [bp-40h]
  int v891; // [sp+318h] [bp-3Ch]
  int v892; // [sp+31Ch] [bp-38h]
  __int64 v893; // [sp+320h] [bp-34h]
  int v894; // [sp+328h] [bp-2Ch]
  int v895; // [sp+32Ch] [bp-28h]
  int v896; // [sp+330h] [bp-24h]
  int v897; // [sp+334h] [bp-20h]
  int v898; // [sp+338h] [bp-1Ch]
  int v899; // [sp+33Ch] [bp-18h]
  int v900; // [sp+340h] [bp-14h]
  int v901; // [sp+344h] [bp-10h]
  int v902; // [sp+348h] [bp-Ch] BYREF
  int v903; // [sp+34Ch] [bp-8h]

  v3 = *(_DWORD *)(a1 + 128);
  v4 = 128 - v3;
  n = a3;
  src = a2;
  if ( 128 - v3 > a3 )
  {
    v266 = v3 + a3;
    result = memcpy((void *)(a1 + v3), a2, a3);
    *(_DWORD *)(a1 + 128) = v266;
  }
  else
  {
    v841 = (void *)(a1 + 136);
    memcpy(dest, (const void *)(a1 + 136), sizeof(dest));
    if ( n )
    {
      v5 = 977224;
      while ( 1 )
      {
        if ( n < v4 )
          v4 = n;
        v6 = (void *)(a1 + v3);
        v3 += v4;
        memcpy(v6, src, v4);
        n -= v4;
        src += v4;
        if ( v3 == 128 )
        {
          v7 = &dest[120];
          v840 = (int)&v840;
          v8 = &v840;
          v9 = a1 - 8;
          v10 = &v871;
          do
          {
            v12 = *(_DWORD *)(v9 + 8);
            v9 += 8;
            v11 = v12;
            v13 = v8[2];
            v8 += 2;
            v14 = *(_DWORD *)(v9 + 4);
            v15 = v8[1];
            v10[2] = v11;
            v10 += 2;
            *((_DWORD *)v7 + 2) = v13 ^ v11;
            v7 += 8;
            v10[1] = v14;
            *((_DWORD *)v7 + 1) = v15 ^ v14;
          }
          while ( &v902 != v10 );
          v269 = 0;
          v495 = v844;
          v467 = v845;
          v499 = v846;
          v506 = v847;
          v592 = v848;
          v602 = v849;
          v473 = v850;
          v488 = v851;
          v512 = v852;
          v438 = v853;
          v447 = v854;
          v299 = v855;
          v360 = v856;
          v454 = v857;
          v518 = v858;
          v16 = v869;
          v17 = v871;
          v267 = v5;
          v346 = v859;
          v535 = v872;
          v522 = v860;
          v278 = v861;
          v394 = v862;
          v352 = v863;
          v367 = v864;
          v373 = v865;
          v384 = v866;
          v410 = v867;
          v461 = v868;
          v530 = v870;
          v586 = v843;
          do
          {
            v288 = v586 ^ v269;
            v378 = v467 ^ ((unsigned __int64)(v269 + 16) >> 32);
            v307 = v602 ^ ((unsigned __int64)(v269 + 48) >> 32);
            v317 = v473 ^ (v269 + 64);
            v273 = ((unsigned __int64)(v269 + 80) >> 32) ^ v512;
            v18 = v438 ^ (v269 + 96);
            v19 = ((unsigned __int64)(v269 + 96) >> 32) ^ v447;
            v323 = v299 ^ (v269 + 112);
            v328 = v360 ^ ((unsigned __int64)(v269 + 112) >> 32);
            v337 = v454 ^ (v269 + 128);
            v421 = v518 ^ ((unsigned __int64)(v269 + 128) >> 32);
            v429 = v346 ^ (v269 + 144);
            v439 = v278 ^ (v269 + 160);
            v353 = v352 ^ (v269 + 176);
            v20 = v367 ^ ((unsigned __int64)(v269 + 176) >> 32);
            v21 = v373;
            v374 = (v269 + 240) ^ v17;
            v361 = v21 ^ (v269 + 192);
            v22 = v384 ^ ((unsigned __int64)(v269 + 192) >> 32);
            v368 = v410 ^ (v269 + 208);
            v23 = v461;
            v462 = (v269 + 224) ^ v16;
            v455 = v23 ^ ((unsigned __int64)(v269 + 208) >> 32);
            v24 = v530 ^ ((unsigned __int64)(v269 + 224) >> 32);
            v468 = v535 ^ ((unsigned __int64)(v269 + 240) >> 32);
            v300 = v495 ^ (v269 + 16);
            v385 = v499 ^ (v269 + 32);
            v279 = v522 ^ ((unsigned __int64)(v269 + 144) >> 32);
            v664 = v22;
            v531 = HIBYTE(v328);
            v347 = v394 ^ ((unsigned __int64)(v269 + 160) >> 32);
            v718 = v24;
            HIDWORD(v473) = HIBYTE(v24);
            v519 = HIBYTE(v19);
            v411 = v18;
            v554 = HIBYTE(v421);
            v395 = v592 ^ (v269 + 48);
            v795 = (unsigned int)(HIDWORD(v586) ^ HIDWORD(v269)) >> 24;
            v770 = v506 ^ ((unsigned __int64)(v269 + 32) >> 32);
            v513 = HIBYTE(v273);
            v619 = 8 * HIBYTE(v323) + 985408;
            v633 = 8 * HIBYTE(v337) + 985408;
            v25 = (int *)((char *)&unk_EF148 + 8 * HIBYTE(v22));
            v546 = 8 * ((v488 ^ (unsigned int)(v269 + 80)) >> 24) + 985408;
            v587 = 8 * HIBYTE(v18) + 985408;
            v745 = 8 * HIBYTE(v368) + 985408;
            v761 = 8 * HIBYTE(v462) + 985408;
            v675 = 8 * HIBYTE(v439) + 985408;
            v779 = 8 * HIBYTE(v374) + 985408;
            v704 = 8 * HIBYTE(v353) + 985408;
            v733 = 8 * HIBYTE(v361) + 985408;
            v782 = 8 * BYTE3(v288) + 985408;
            v26 = &qword_EF950[BYTE1(v300)];
            v27 = &qword_F0150[BYTE2(v385)];
            v28 = &qword_F1150[BYTE4(v317)];
            v593 = *v25;
            v608 = v25[1];
            v29 = &qword_F1150[(unsigned __int8)v273];
            v562 = &qword_F1150[(unsigned __int8)(((unsigned __int64)(v269 + 96) >> 32) ^ v447)];
            v30 = *(_DWORD *)(v267 + 8 * (unsigned __int8)v288 + 4)
                ^ ((unsigned __int64)(v269 + 1) >> 32)
                ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v20) + 1)
                ^ *((_DWORD *)v26 - 1)
                ^ *((_DWORD *)v27 - 1);
            v31 = 8 * HIBYTE(v395) + 985408;
            v32 = *(_DWORD *)(v267 + 8 * (unsigned __int8)v288)
                ^ (v269 + 1)
                ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v20))
                ^ *((_DWORD *)v26 - 2);
            v603 = BYTE2(v273);
            v33 = &qword_EF950[BYTE1(v385)];
            v523 = &qword_F0150[BYTE2(v395)];
            v34 = (unsigned __int8)(v499 ^ (v269 + 32));
            v815 = 8 * HIBYTE(v385) + 985408;
            v685 = BYTE1(v328);
            v589 = &qword_F1150[(unsigned __int8)v328];
            v386 = BYTE2(v421);
            v35 = (unsigned __int8)v421;
            v422 = BYTE1(v421);
            v627 = &qword_F1150[v35];
            v36 = v30 ^ HIDWORD(qword_F0948[HIBYTE(v395)]) ^ *((_DWORD *)v28 - 1);
            v698 = (unsigned __int8)v395;
            v396 = &qword_EF950[BYTE1(v395)];
            v37 = (_DWORD *)((char *)&unk_F2148 + 8 * BYTE2(v19));
            v38 = v32
                ^ *((_DWORD *)v27 - 2)
                ^ *(_DWORD *)(v31 + 8)
                ^ *((_DWORD *)v28 - 2)
                ^ *((_DWORD *)&unk_F1948 + 2 * BYTE1(v273))
                ^ *v37;
            v669 = *((_DWORD *)&unk_F2148 + 2 * BYTE2(v328) + 1);
            v640 = *((_DWORD *)&unk_F1948 + 2 * BYTE1(v19));
            v39 = *((_DWORD *)&unk_F1948 + 2 * BYTE1(v273) + 1);
            v274 = v38;
            v650 = *((_DWORD *)&unk_F2148 + 2 * BYTE2(v328));
            v329 = v36 ^ v39 ^ v37[1];
            v536 = &qword_F0150[BYTE2(v317)];
            v40 = *(_DWORD *)(v267 + 8 * (unsigned __int8)v300) ^ v593 ^ (v269 + 17) ^ *((_DWORD *)v33 - 2);
            v41 = *(_DWORD *)(v267 + 8 * (unsigned __int8)v300 + 4)
                ^ v608
                ^ ((unsigned __int64)(v269 + 17) >> 32)
                ^ *((_DWORD *)v33 - 1);
            v774 = (unsigned __int8)v317;
            v579 = &qword_EF950[BYTE1(v317)];
            v42 = *((_DWORD *)v523 - 1);
            v43 = v40 ^ *((_DWORD *)v523 - 2);
            v403 = &qword_F0150[(unsigned __int8)((v488 ^ (unsigned int)(v269 + 80)) >> 16)];
            v800 = (unsigned __int8)(v488 ^ (v269 + 80));
            v524 = &qword_EF950[(unsigned __int8)((unsigned __int16)(v488 ^ (v269 + 80)) >> 8)];
            v786 = BYTE1(v279);
            v609 = &qword_F0150[BYTE2(v411)];
            v791 = BYTE2(v347);
            v44 = *((_DWORD *)&unk_F1948 + 2 * BYTE1(v19) + 1)
                ^ *((_DWORD *)v29 - 1)
                ^ HIDWORD(qword_F0948[((unsigned int)v473 ^ ((_DWORD)v269 + 64)) >> 24])
                ^ v41
                ^ v42;
            v690 = *((_DWORD *)&unk_F2148 + 2 * v386 + 1);
            v571 = *((_DWORD *)&unk_F2148 + 2 * v386);
            v45 = *((_DWORD *)v562 - 2);
            v46 = *((_DWORD *)v562 - 1);
            v563 = *((_DWORD *)v589 - 2);
            LODWORD(v317) = v44 ^ v669;
            v726 = *((_DWORD *)v589 - 1);
            v819 = *((_DWORD *)v29 - 2)
                 ^ LODWORD(qword_F0948[((unsigned int)v473 ^ ((_DWORD)v269 + 64)) >> 24])
                 ^ v43
                 ^ v640
                 ^ v650;
            v763 = *((_DWORD *)&unk_F2148 + 2 * BYTE2(v279) + 1);
            v489 = *((_DWORD *)&unk_F2148 + 2 * BYTE2(v279));
            v47 = *(_DWORD *)(v587 + 8);
            LODWORD(v473) = *(_DWORD *)(v587 + 12);
            v821 = (unsigned __int8)v411;
            v48 = &qword_EF950[BYTE1(v411)];
            v540 = &qword_F0150[BYTE2(v323)];
            v590 = &qword_F1150[(unsigned __int8)v279];
            v588 = HIBYTE(v279);
            v805 = BYTE1(v347);
            v830 = (unsigned __int8)v323;
            v641 = &qword_EF950[BYTE1(v323)];
            v651 = &qword_F0150[BYTE2(v337)];
            v49 = &qword_F1150[(unsigned __int8)v347];
            v594 = HIBYTE(v347);
            LOWORD(v23) = v664;
            v827 = BYTE2(v664);
            v387 = (unsigned __int8)v337;
            v665 = &qword_EF950[BYTE1(v337)];
            v324 = *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v455) + 1)
                 ^ *(_DWORD *)(v267 + 8 * v34 + 4)
                 ^ ((unsigned __int64)(v269 + 33) >> 32)
                 ^ *((_DWORD *)v396 - 1)
                 ^ *((_DWORD *)v536 - 1)
                 ^ *(_DWORD *)(v546 + 12)
                 ^ v46
                 ^ *((_DWORD *)&unk_F1948 + 2 * v685 + 1)
                 ^ v690;
            v833 = BYTE2(v455);
            v711 = &qword_F1150[(unsigned __int8)v23];
            v691 = &qword_EF950[BYTE1(v429)];
            v280 = *(_DWORD *)(v267 + 8 * v34)
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v455))
                 ^ (v269 + 33)
                 ^ *((_DWORD *)v396 - 2)
                 ^ *((_DWORD *)v536 - 2)
                 ^ *(_DWORD *)(v546 + 8)
                 ^ v45
                 ^ *((_DWORD *)&unk_F1948 + 2 * v685)
                 ^ v571;
            v50 = *((_DWORD *)&unk_EF148 + 2 * HIDWORD(v473))
                ^ *(_DWORD *)(v267 + 8 * v698)
                ^ (v269 + 49)
                ^ *((_DWORD *)v579 - 2)
                ^ *((_DWORD *)v403 - 2)
                ^ v47;
            v51 = *((_DWORD *)&unk_EF148 + 2 * HIDWORD(v473) + 1)
                ^ *(_DWORD *)(v267 + 8 * v698 + 4)
                ^ ((unsigned __int64)(v269 + 49) >> 32)
                ^ *((_DWORD *)v579 - 1)
                ^ *((_DWORD *)v403 - 1)
                ^ v473;
            v404 = BYTE1(v455);
            v699 = &qword_F0150[BYTE2(v439)];
            LOWORD(v34) = v718;
            v739 = &qword_F1150[(unsigned __int8)v455];
            v412 = BYTE2(v718);
            v338 = v50 ^ v563 ^ *((_DWORD *)&unk_F1948 + 2 * v422) ^ v489;
            v348 = v51 ^ v726 ^ *((_DWORD *)&unk_F1948 + 2 * v422 + 1) ^ v763;
            v456 = (unsigned __int8)v439;
            v719 = &qword_EF950[BYTE1(v439)];
            v727 = &qword_F0150[BYTE2(v353)];
            v751 = &qword_F1150[(unsigned __int8)v34];
            v52 = *((_DWORD *)v609 - 1);
            v440 = BYTE2(v468);
            v53 = *(_DWORD *)(v267 + 8 * v774)
                ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v468))
                ^ (v269 + 65)
                ^ *((_DWORD *)v524 - 2)
                ^ *((_DWORD *)v609 - 2);
            v448 = BYTE6(v288);
            v490 = (unsigned __int8)v353;
            v610 = &qword_EF950[BYTE1(v353)];
            v54 = *(_DWORD *)(v619 + 12);
            v55 = *(_DWORD *)(v619 + 8);
            v620 = &qword_F0150[BYTE2(v361)];
            v474 = BYTE1(v468);
            v764 = &qword_F1150[(unsigned __int8)v468];
            v56 = *((_DWORD *)v627 - 1)
                ^ *((_DWORD *)v524 - 1)
                ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v468) + 1)
                ^ *(_DWORD *)(v267 + 8 * v774 + 4)
                ^ ((unsigned __int64)(v269 + 65) >> 32)
                ^ v52
                ^ v54
                ^ *((_DWORD *)&unk_F1948 + 2 * v786 + 1);
            v481 = BYTE5(v288);
            v397 = &qword_F1150[BYTE4(v288)];
            v469 = *((_DWORD *)v627 - 2)
                 ^ v53
                 ^ v55
                 ^ *((_DWORD *)&unk_F1948 + 2 * v786)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v791);
            v525 = (unsigned __int8)(v21 ^ (v269 - 64));
            v628 = &qword_EF950[BYTE1(v361)];
            v757 = &qword_F0150[BYTE2(v368)];
            v496 = BYTE2(v378);
            HIDWORD(v288) = v56 ^ *((_DWORD *)&unk_F2148 + 2 * v791 + 1);
            v57 = *((_DWORD *)&unk_EF148 + 2 * v795 + 1) ^ ((unsigned __int64)(v269 + 81) >> 32);
            v537 = BYTE1(v378);
            v58 = *((_DWORD *)&unk_EF148 + 2 * v795) ^ (v269 + 81) ^ *(_DWORD *)(v267 + 8 * v800) ^ *((_DWORD *)v48 - 2);
            v796 = &qword_F1150[(unsigned __int8)v378];
            v59 = *((_DWORD *)v540 - 1);
            v60 = *((_DWORD *)v540 - 2);
            v541 = BYTE2(v770);
            v564 = BYTE1(v770);
            v809 = &qword_F1150[(unsigned __int8)(v506 ^ ((unsigned __int64)(v269 + 32) >> 32))];
            v572 = BYTE2(v307);
            v771 = &qword_EF950[BYTE1(v368)];
            v547 = (unsigned __int8)v368;
            v775 = &qword_F0150[BYTE2(v462)];
            v580 = (unsigned __int8)v462;
            v61 = *((_DWORD *)&unk_F1948 + 2 * v805 + 1)
                ^ v57
                ^ *(_DWORD *)(v267 + 8 * v800 + 4)
                ^ *((_DWORD *)v48 - 1)
                ^ v59
                ^ *(_DWORD *)(v633 + 12)
                ^ *((_DWORD *)v590 - 1);
            v787 = &qword_EF950[BYTE1(v462)];
            v792 = &qword_F0150[BYTE2(v374)];
            v801 = &qword_F0150[BYTE2(v288)];
            v813 = &qword_EF950[BYTE1(v288)];
            v354 = v61 ^ *((_DWORD *)&unk_F2148 + 2 * BYTE2(v20) + 1);
            LODWORD(v288) = v58
                          ^ v60
                          ^ *(_DWORD *)(v633 + 8)
                          ^ *((_DWORD *)v590 - 2)
                          ^ *((_DWORD *)&unk_F1948 + 2 * v805)
                          ^ *((_DWORD *)&unk_F2148 + 2 * BYTE2(v20));
            v591 = (unsigned __int8)v374;
            v806 = &qword_EF950[BYTE1(v374)];
            v62 = *(v49 - 1);
            v463 = *(_DWORD *)(v267 + 8 * v821 + 4)
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v378) + 1)
                 ^ ((unsigned __int64)(v269 + 97) >> 32)
                 ^ *((_DWORD *)v641 - 1)
                 ^ *((_DWORD *)v651 - 1)
                 ^ HIDWORD(qword_F0948[HIBYTE(v429)])
                 ^ HIDWORD(v62)
                 ^ *((_DWORD *)&unk_F1948 + 2 * BYTE1(v20) + 1)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v827 + 1);
            v362 = *(_DWORD *)(v267 + 8 * v821)
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v378))
                 ^ (v269 + 97)
                 ^ *((_DWORD *)v641 - 2)
                 ^ *((_DWORD *)v651 - 2)
                 ^ LODWORD(qword_F0948[HIBYTE(v429)])
                 ^ v62
                 ^ *((_DWORD *)&unk_F1948 + 2 * BYTE1(v20))
                 ^ *((_DWORD *)&unk_F2148 + 2 * v827);
            v63 = *(_DWORD *)(v267 + 8 * v387) ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v307));
            v369 = *(_QWORD *)(v267 + 8 * v830)
                 ^ *((_QWORD *)&unk_EF148 + ((v506 ^ ((unsigned __int64)(v269 + 32) >> 32)) >> 24))
                 ^ (v269 + 113)
                 ^ *(v665 - 1)
                 ^ qword_F0150[BYTE2(v429) - 1]
                 ^ *(_QWORD *)(v675 + 8)
                 ^ qword_F1150[(unsigned __int8)v20 - 1]
                 ^ *((_QWORD *)&unk_F1948 + BYTE1(v23))
                 ^ *((_QWORD *)&unk_F2148 + v833);
            v828 = *((_DWORD *)&unk_F2148 + 2 * v440 + 1);
            v825 = *((_DWORD *)&unk_F2148 + 2 * v440);
            v500 = (char *)&unk_F2148 + 8 * BYTE2(v378);
            v642 = (char *)&unk_F1948 + 8 * BYTE1(v378);
            v676 = (char *)&unk_F2148 + 8 * BYTE2(v307);
            v388 = *((_DWORD *)&unk_F2148 + 2 * v412 + 1)
                 ^ *((_DWORD *)v699 - 1)
                 ^ *((_DWORD *)v691 - 1)
                 ^ *(_DWORD *)(v267 + 8 * v387 + 4)
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v307) + 1)
                 ^ (__CFADD__((_DWORD)v269, 129) + HIDWORD(v269))
                 ^ *(_DWORD *)(v704 + 12)
                 ^ *((_DWORD *)v711 - 1)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v404 + 1);
            v379 = v63
                 ^ (v269 + 129)
                 ^ *((_DWORD *)v691 - 2)
                 ^ *((_DWORD *)v699 - 2)
                 ^ *(_DWORD *)(v704 + 8)
                 ^ *((_DWORD *)v711 - 2)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v404)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v412);
            v64 = *((_DWORD *)&unk_EF148 + 2 * v513 + 1);
            v705 = *((_DWORD *)&unk_F1948 + 2 * v474 + 1);
            v700 = *((_DWORD *)v727 - 1)
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(HIDWORD(v317)) + 1)
                 ^ *(_DWORD *)(v267 + 8 * (unsigned __int8)v429 + 4)
                 ^ ((unsigned __int64)(v269 + 145) >> 32)
                 ^ *((_DWORD *)v719 - 1)
                 ^ *(_DWORD *)(v733 + 12)
                 ^ *((_DWORD *)v739 - 1);
            HIDWORD(v62) = *((_DWORD *)&unk_EF148 + 2 * v513);
            v514 = *((_DWORD *)&unk_F1948 + 2 * v474);
            v65 = *(_DWORD *)(v267 + 8 * v456 + 4)
                ^ *((_DWORD *)&unk_F2148 + 2 * v448 + 1)
                ^ ((unsigned __int64)(v269 + 161) >> 32)
                ^ v64;
            v475 = *((_DWORD *)&unk_EF148 + 2 * HIBYTE(HIDWORD(v317)))
                 ^ *(_DWORD *)(v267 + 8 * (unsigned __int8)v429)
                 ^ (v269 + 145)
                 ^ *((_DWORD *)v719 - 2)
                 ^ *((_DWORD *)v727 - 2)
                 ^ *(_DWORD *)(v733 + 8)
                 ^ *((_DWORD *)v739 - 2)
                 ^ *((_DWORD *)&unk_F1948 + 2 * BYTE1(v34));
            v430 = &qword_F0150[BYTE2(v300)];
            v413 = 8 * HIBYTE(v300) + 985408;
            v301 = BYTE1(v307);
            v441 = &qword_F1150[(unsigned __int8)v307];
            v308 = BYTE6(v317);
            v734 = BYTE5(v317);
            v66 = *(_DWORD *)(v413 + 8);
            v67 = *((_DWORD *)&unk_F1948 + 2 * v301);
            v68 = *(_DWORD *)(v267 + 8 * v580 + 4)
                ^ *((_DWORD *)v801 - 1)
                ^ ((unsigned __int64)(v269 + 225) >> 32)
                ^ *((_DWORD *)&unk_EF148 + 2 * v588 + 1)
                ^ *((_DWORD *)v806 - 1)
                ^ *(_DWORD *)(v413 + 12)
                ^ *((_DWORD *)v809 - 1)
                ^ *((_DWORD *)&unk_F1948 + 2 * v301 + 1)
                ^ *((_DWORD *)&unk_F2148 + 2 * BYTE6(v317) + 1);
            LODWORD(v62) = *(_DWORD *)(v267 + 8 * v591 + 4)
                         ^ *((_DWORD *)v813 - 1)
                         ^ ((unsigned __int64)(v269 + 241) >> 32)
                         ^ *((_DWORD *)&unk_EF148 + 2 * v594 + 1)
                         ^ *((_DWORD *)v430 - 1)
                         ^ *(_DWORD *)(v815 + 12)
                         ^ *((_DWORD *)v441 - 1)
                         ^ *((_DWORD *)&unk_F1948 + 2 * BYTE5(v317) + 1);
            v302 = v475 ^ v825;
            HIDWORD(v317) = *((_DWORD *)&unk_F2148 + 2 * v448)
                          ^ *(_DWORD *)(v267 + 8 * v456)
                          ^ (v269 + 161)
                          ^ HIDWORD(v62)
                          ^ *((_DWORD *)v610 - 2)
                          ^ *((_DWORD *)v620 - 2)
                          ^ *(_DWORD *)(v745 + 8)
                          ^ *((_DWORD *)v751 - 2)
                          ^ v514;
            v414 = *(_DWORD *)(v267 + 8 * v490 + 4)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v481 + 1)
                 ^ ((unsigned __int64)(v269 + 177) >> 32)
                 ^ *((_DWORD *)&unk_EF148 + 2 * v519 + 1)
                 ^ *((_DWORD *)v628 - 1)
                 ^ *((_DWORD *)v757 - 1)
                 ^ *(_DWORD *)(v761 + 12)
                 ^ *((_DWORD *)v764 - 1)
                 ^ *((_DWORD *)v500 + 1);
            v405 = *((_DWORD *)&unk_F1948 + 2 * v481)
                 ^ *(_DWORD *)(v267 + 8 * v490)
                 ^ (v269 + 177)
                 ^ *((_DWORD *)&unk_EF148 + 2 * v519)
                 ^ *((_DWORD *)v628 - 2)
                 ^ *((_DWORD *)v757 - 2)
                 ^ *(_DWORD *)(v761 + 8)
                 ^ *((_DWORD *)v764 - 2)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v496);
            v457 = *((_DWORD *)v813 - 2)
                 ^ *(_DWORD *)(v267 + 8 * v591)
                 ^ (v269 + 241)
                 ^ *((_DWORD *)&unk_EF148 + 2 * v594)
                 ^ *((_DWORD *)v430 - 2)
                 ^ *(_DWORD *)(v815 + 8)
                 ^ *((_DWORD *)v441 - 2)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v734)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v603);
            v431 = *(_DWORD *)(v267 + 8 * v525 + 4)
                 ^ *((_DWORD *)v397 - 1)
                 ^ (__CFADD__((_DWORD)v269, 193) + HIDWORD(v269))
                 ^ *((_DWORD *)&unk_EF148 + 2 * v531 + 1)
                 ^ *((_DWORD *)v771 - 1)
                 ^ *((_DWORD *)v775 - 1)
                 ^ *(_DWORD *)(v779 + 12)
                 ^ *((_DWORD *)v642 + 1)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v541 + 1);
            LODWORD(v62) = v62 ^ *((_DWORD *)&unk_F2148 + 2 * v603 + 1);
            v449 = *((_DWORD *)v801 - 2)
                 ^ *(_DWORD *)(v267 + 8 * v580)
                 ^ (v269 + 225)
                 ^ *((_DWORD *)&unk_EF148 + 2 * v588)
                 ^ *((_DWORD *)v806 - 2)
                 ^ v66
                 ^ *((_DWORD *)v809 - 2)
                 ^ v67
                 ^ *((_DWORD *)&unk_F2148 + 2 * v308);
            v423 = *((_DWORD *)&unk_EF148 + 2 * v531)
                 ^ *((_DWORD *)v397 - 2)
                 ^ *(_DWORD *)(v267 + 8 * v525)
                 ^ (v269 + 193)
                 ^ *((_DWORD *)v771 - 2)
                 ^ *((_DWORD *)v775 - 2)
                 ^ *(_DWORD *)(v779 + 8)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v537)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v541);
            v309 = v700 ^ *((_DWORD *)&unk_F1948 + 2 * BYTE1(v34) + 1) ^ v828;
            v442 = *(_DWORD *)(v267 + 8 * v547)
                 ^ *(_DWORD *)(v782 + 8)
                 ^ (v269 + 209)
                 ^ *((_DWORD *)&unk_EF148 + 2 * v554)
                 ^ *((_DWORD *)v787 - 2)
                 ^ *((_DWORD *)v792 - 2)
                 ^ *((_DWORD *)v796 - 2)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v564)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v572);
            v398 = v65
                 ^ *((_DWORD *)v610 - 1)
                 ^ *((_DWORD *)v620 - 1)
                 ^ *(_DWORD *)(v745 + 12)
                 ^ *((_DWORD *)v751 - 1)
                 ^ v705;
            v476 = *(_DWORD *)(v782 + 12)
                 ^ *(_DWORD *)(v267 + 8 * v547 + 4)
                 ^ ((unsigned __int64)(v269 + 209) >> 32)
                 ^ *((_DWORD *)&unk_EF148 + 2 * v554 + 1)
                 ^ *((_DWORD *)v787 - 1)
                 ^ *((_DWORD *)v792 - 1)
                 ^ *((_DWORD *)v796 - 1)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v564 + 1)
                 ^ *((_DWORD *)v676 + 1);
            v555 = HIBYTE(v463);
            v573 = HIBYTE(v388);
            v515 = BYTE3(v62);
            v491 = v62;
            v565 = HIBYTE(HIDWORD(v369));
            v482 = v68;
            v548 = HIBYTE(v354);
            v611 = 8 * BYTE3(v288) + 985408;
            v652 = (int *)((char *)&unk_EF148 + 8 * HIBYTE(v68));
            v686 = (char *)&unk_EF148 + 8 * BYTE3(v62);
            v783 = 8 * HIBYTE(v442) + 985408;
            v793 = 8 * HIBYTE(v449) + 985408;
            v69 = v819;
            v802 = 8 * HIBYTE(v457) + 985408;
            v837 = HIBYTE(v398);
            v740 = 8 * HIBYTE(v302) + 985408;
            v752 = 8 * HIBYTE(HIDWORD(v317)) + 985408;
            v762 = 8 * HIBYTE(v405) + 985408;
            v776 = 8 * HIBYTE(v423) + 985408;
            v797 = (char *)&unk_EF148 + 8 * HIBYTE(HIDWORD(v369));
            v780 = (char *)&unk_EF148 + 8 * HIBYTE(v354);
            v788 = (char *)&unk_EF148 + 8 * HIBYTE(v463);
            v70 = BYTE1(v819);
            v810 = (char *)&unk_EF148 + 8 * HIBYTE(v388);
            v814 = (_DWORD *)((char *)&unk_EF148 + 8 * HIBYTE(v309));
            v826 = (char *)&unk_EF148 + 8 * HIBYTE(v398);
            v820 = 8 * HIBYTE(v819) + 985408;
            v831 = 8 * HIBYTE(v280) + 985408;
            v71 = &qword_F1150[BYTE4(v288)];
            v72 = &qword_EF950[v70];
            v73 = BYTE2(v463);
            v74 = &qword_F0150[BYTE2(v280)];
            v75 = BYTE1(v463);
            v634 = &qword_F1150[(unsigned __int8)v463];
            v643 = *((_DWORD *)v71 - 2);
            v677 = *((_DWORD *)v71 - 1);
            v269 += 2;
            v829 = &qword_F0150[BYTE2(v69)];
            v464 = BYTE2(v354);
            v76 = BYTE6(v369);
            v77 = &qword_F1150[(unsigned __int8)v354];
            v78 = &qword_EF950[BYTE1(v280)];
            v79 = &qword_F0150[BYTE2(v338)];
            v595 = &qword_EF950[BYTE1(v338)];
            v765 = *((_DWORD *)&unk_F1948 + 2 * v75);
            LODWORD(v62) = *((_DWORD *)&unk_F1948 + 2 * BYTE1(v354) + 1)
                         ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v414) + 1)
                         ^ *(_DWORD *)(v267 + 8 * (unsigned __int8)v274 + 4)
                         ^ *((_DWORD *)v72 - 1)
                         ^ *((_DWORD *)v74 - 1);
            v816 = *((_DWORD *)&unk_F1948 + 2 * v75 + 1);
            HIDWORD(v62) = *((_DWORD *)&unk_F1948 + 2 * BYTE1(v354))
                         ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v414))
                         ^ *(_DWORD *)(v267 + 8 * (unsigned __int8)v274)
                         ^ *((_DWORD *)v72 - 2)
                         ^ *((_DWORD *)v74 - 2);
            v80 = BYTE4(v369);
            v629 = &qword_F0150[BYTE2(v469)];
            v81 = BYTE5(v369);
            HIDWORD(v369) = (unsigned __int8)v469;
            v670 = &qword_F1150[v80];
            v82 = BYTE2(v388);
            v659 = &qword_EF950[BYTE1(v469)];
            LODWORD(v586) = HIDWORD(v62) ^ LODWORD(qword_F0948[HIBYTE(v338)]) ^ v643 ^ *((_DWORD *)&unk_F2148 + 2 * v73);
            LODWORD(v62) = v62 ^ HIDWORD(qword_F0948[HIBYTE(v338)]) ^ v677;
            LOWORD(v80) = v388;
            HIDWORD(v62) = *((_DWORD *)v78 - 2);
            v389 = (unsigned __int8)v288;
            v644 = &qword_F0150[BYTE2(v288)];
            v678 = &qword_EF950[BYTE1(v288)];
            v83 = *((_DWORD *)v77 - 1)
                ^ *(_DWORD *)(v267 + 8 * (unsigned __int8)v69 + 4)
                ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v431) + 1)
                ^ *((_DWORD *)v78 - 1);
            HIDWORD(v62) ^= *(_DWORD *)(v267 + 8 * (unsigned __int8)v69)
                          ^ *((_DWORD *)v77 - 2)
                          ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v431))
                          ^ *((_DWORD *)v79 - 2);
            v706 = &qword_F1150[(unsigned __int8)v80];
            v692 = &qword_F0150[BYTE2(v362)];
            v84 = BYTE2(v309);
            HIDWORD(v586) = v62 ^ *((_DWORD *)&unk_F2148 + 2 * v73 + 1);
            LODWORD(v288) = BYTE1(v309);
            v728 = &qword_F1150[(unsigned __int8)v309];
            v310 = BYTE2(v398);
            v495 = HIDWORD(v62) ^ LODWORD(qword_F0948[HIBYTE(v469)]) ^ v765 ^ *((_DWORD *)&unk_F2148 + 2 * v76);
            v467 = v83
                 ^ *((_DWORD *)v79 - 1)
                 ^ HIDWORD(qword_F0948[HIBYTE(v469)])
                 ^ v816
                 ^ *((_DWORD *)&unk_F2148 + 2 * v76 + 1);
            v766 = *((_DWORD *)v634 - 1);
            v85 = *(_DWORD *)(v267 + 8 * (unsigned __int8)v280)
                ^ *(_DWORD *)(v611 + 8)
                ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v476))
                ^ *((_DWORD *)v595 - 2);
            HIDWORD(v62) = *(_DWORD *)(v267 + 8 * (unsigned __int8)v280 + 4)
                         ^ *(_DWORD *)(v611 + 12)
                         ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v476) + 1)
                         ^ *((_DWORD *)v595 - 1);
            v596 = *(_DWORD *)(v267 + 8 * (unsigned __int8)v338);
            v86 = *v652;
            v87 = *((_DWORD *)v629 - 2)
                ^ v85
                ^ *((_DWORD *)v634 - 2)
                ^ *((_DWORD *)&unk_F1948 + 2 * v81)
                ^ *((_DWORD *)&unk_F2148 + 2 * v82);
            v823 = (unsigned __int8)v362;
            v612 = &qword_EF950[BYTE1(v362)];
            v621 = &qword_F0150[BYTE2(v369)];
            v281 = BYTE1(v398);
            v635 = &qword_F1150[(unsigned __int8)v398];
            v832 = (unsigned __int8)v369;
            v399 = &qword_EF950[BYTE1(v369)];
            v506 = HIDWORD(v62)
                 ^ *((_DWORD *)v629 - 1)
                 ^ v766
                 ^ *((_DWORD *)&unk_F1948 + 2 * v81 + 1)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v82 + 1);
            v88 = qword_F0948[HIBYTE(v362)];
            v630 = &qword_F0150[BYTE2(v379)];
            v499 = v87;
            v89 = HIDWORD(qword_F0948[HIBYTE(v362)]);
            v90 = *((_DWORD *)v670 - 1);
            v91 = *((_DWORD *)v659 - 1);
            v92 = *((_DWORD *)v659 - 2);
            HIDWORD(v62) = *((_DWORD *)v644 - 2);
            v93 = *(_DWORD *)(v267 + 8 * (unsigned __int8)v338 + 4) ^ *((_DWORD *)v644 - 1) ^ v652[1];
            v339 = BYTE1(v414);
            v363 = (unsigned __int8)v379;
            v660 = &qword_F1150[(unsigned __int8)v414];
            v355 = BYTE2(v431);
            v645 = &qword_EF950[BYTE1(v379)];
            v653 = &qword_F0150[BYTE2(v302)];
            v834 = BYTE1(v431);
            v767 = &qword_F1150[(unsigned __int8)v431];
            v835 = BYTE2(v476);
            v836 = (unsigned __int8)v302;
            v666 = &qword_EF950[BYTE1(v302)];
            v592 = HIDWORD(v62)
                 ^ v596
                 ^ v86
                 ^ v92
                 ^ v88
                 ^ *((_DWORD *)v670 - 2)
                 ^ *((_DWORD *)&unk_F1948 + 2 * BYTE1(v80))
                 ^ *((_DWORD *)&unk_F2148 + 2 * v84);
            v671 = &qword_F0150[BYTE6(v317)];
            v602 = v93
                 ^ v91
                 ^ v89
                 ^ v90
                 ^ *((_DWORD *)&unk_F1948 + 2 * BYTE1(v80) + 1)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v84 + 1);
            v94 = *((_DWORD *)&unk_F1948 + 2 * v288);
            v95 = *((_DWORD *)&unk_F2148 + 2 * v310 + 1);
            HIDWORD(v62) = *((_DWORD *)v678 - 2)
                         ^ *(_DWORD *)(v267 + 8 * HIDWORD(v369))
                         ^ *((_DWORD *)&unk_EF148 + 2 * v515)
                         ^ *((_DWORD *)v692 - 2);
            v96 = *((_DWORD *)&unk_F2148 + 2 * v310);
            v97 = *((_DWORD *)&unk_F1948 + 2 * v288 + 1)
                ^ *(_DWORD *)(v267 + 8 * HIDWORD(v369) + 4)
                ^ *((_DWORD *)v678 - 1)
                ^ *((_DWORD *)v686 + 1)
                ^ *((_DWORD *)v692 - 1)
                ^ HIDWORD(qword_F0948[BYTE3(v369)])
                ^ *((_DWORD *)v706 - 1);
            v432 = *((_DWORD *)&unk_F1948 + 2 * v281 + 1);
            v98 = BYTE2(v414);
            v415 = *((_DWORD *)&unk_F1948 + 2 * v281);
            LODWORD(v288) = BYTE1(v476);
            v693 = &qword_F1150[(unsigned __int8)v476];
            v303 = BYTE2(v482);
            HIDWORD(v369) = BYTE4(v317);
            v679 = &qword_EF950[BYTE5(v317)];
            v687 = &qword_F0150[BYTE2(v405)];
            v311 = BYTE1(v482);
            v701 = &qword_F1150[(unsigned __int8)v482];
            HIDWORD(v317) = BYTE2(v491);
            LODWORD(v473) = HIDWORD(v62) ^ LODWORD(qword_F0948[BYTE3(v369)]) ^ *((_DWORD *)v706 - 2) ^ v94 ^ v96;
            LODWORD(v369) = BYTE2(v329);
            HIDWORD(v473) = v97 ^ v95;
            v99 = *(_QWORD *)(v267 + 8 * v389)
                ^ *((_QWORD *)&unk_EF148 + HIBYTE(v329))
                ^ *(v612 - 1)
                ^ *(v621 - 1)
                ^ qword_F0948[HIBYTE(v379)]
                ^ *(v728 - 1);
            v100 = *((_DWORD *)&unk_EF148 + 2 * BYTE3(v317)) ^ *(_DWORD *)(v267 + 8 * v823);
            HIDWORD(v62) = *((_DWORD *)&unk_F1948 + 2 * v339);
            v817 = *((_DWORD *)&unk_F2148 + 2 * v355 + 1);
            v101 = *((_DWORD *)&unk_F2148 + 2 * v355);
            v356 = (unsigned __int8)v405;
            v613 = &qword_EF950[BYTE1(v405)];
            v526 = v101;
            v102 = *((_DWORD *)&unk_F1948 + 2 * v339 + 1);
            v532 = &qword_F0150[BYTE2(v423)];
            v340 = BYTE1(v491);
            v712 = &qword_F1150[(unsigned __int8)v491];
            v103 = &qword_F1150[(unsigned __int8)v329];
            v330 = BYTE1(v329);
            v282 = v103;
            v390 = (unsigned __int8)v423;
            v622 = &qword_EF950[BYTE1(v423)];
            v380 = BYTE2(v317);
            v707 = &qword_F0150[BYTE2(v442)];
            v512 = *((_DWORD *)&unk_F2148 + 2 * v98 + 1) ^ HIDWORD(v99) ^ v432;
            v488 = v99 ^ v415 ^ *((_DWORD *)&unk_F2148 + 2 * v98);
            v720 = &qword_EF950[BYTE1(v442)];
            v406 = (unsigned __int8)v442;
            v729 = &qword_F0150[BYTE2(v449)];
            v104 = *((_DWORD *)&unk_EF148 + 2 * BYTE3(v317) + 1)
                 ^ *(_DWORD *)(v267 + 8 * v823 + 4)
                 ^ *((_DWORD *)v399 - 1)
                 ^ *((_DWORD *)v630 - 1);
            v105 = (unsigned __int8)v317;
            LODWORD(v317) = BYTE1(v317);
            v746 = &qword_F1150[v105];
            v735 = &qword_EF950[BYTE1(v449)];
            v424 = (unsigned __int8)v449;
            v106 = v100 ^ *((_DWORD *)v399 - 2) ^ *((_DWORD *)v630 - 2) ^ *(_DWORD *)(v740 + 8) ^ *((_DWORD *)v635 - 2);
            v107 = v104 ^ *(_DWORD *)(v740 + 12) ^ *((_DWORD *)v635 - 1) ^ v102;
            v636 = &qword_F0150[BYTE2(v457)];
            v822 = &qword_F1150[(unsigned __int8)v324];
            v416 = BYTE2(v348);
            v824 = &qword_EF950[BYTE1(v274)];
            v741 = &qword_F0150[BYTE2(v274)];
            v447 = v107 ^ v817;
            v433 = (unsigned __int8)v457;
            v438 = HIDWORD(v62) ^ v106 ^ v526;
            v818 = &qword_EF950[BYTE1(v457)];
            v108 = *(_QWORD *)(v752 + 8);
            v109 = *((_DWORD *)v645 - 1)
                 ^ *(_DWORD *)(v267 + 8 * v832 + 4)
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v324) + 1)
                 ^ *((_DWORD *)v653 - 1)
                 ^ HIDWORD(v108);
            v110 = *(_DWORD *)(v267 + 8 * v832)
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v324))
                 ^ *((_DWORD *)v645 - 2)
                 ^ *((_DWORD *)v653 - 2)
                 ^ v108;
            v111 = *(v660 - 1);
            v112 = v110 ^ v111;
            v113 = v109 ^ HIDWORD(v111) ^ *((_DWORD *)&unk_F1948 + 2 * v834 + 1);
            LODWORD(v111) = *(_DWORD *)(v267 + 8 * v363 + 4) ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v348) + 1);
            HIDWORD(v111) = *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v348)) ^ *(_DWORD *)(v267 + 8 * v363);
            v114 = *((_DWORD *)&unk_F2148 + 2 * v303 + 1);
            v115 = *((_DWORD *)&unk_F2148 + 2 * v303);
            v360 = v113 ^ *((_DWORD *)&unk_F2148 + 2 * v835 + 1);
            v299 = v112 ^ *((_DWORD *)&unk_F1948 + 2 * v834) ^ *((_DWORD *)&unk_F2148 + 2 * v835);
            v646 = (_DWORD *)((char *)&unk_F1948 + 8 * BYTE1(v324));
            v654 = (char *)&unk_F2148 + 8 * BYTE2(v348);
            v454 = HIDWORD(v111)
                 ^ *((_DWORD *)v666 - 2)
                 ^ *((_DWORD *)v671 - 2)
                 ^ *(_DWORD *)(v762 + 8)
                 ^ *((_DWORD *)v767 - 2)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v288)
                 ^ v115;
            v518 = v111
                 ^ *((_DWORD *)v666 - 1)
                 ^ *((_DWORD *)v671 - 1)
                 ^ *(_DWORD *)(v762 + 12)
                 ^ *((_DWORD *)v767 - 1)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v288 + 1)
                 ^ v114;
            v116 = *((_DWORD *)&unk_F1948 + 2 * v311)
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(HIDWORD(v288)))
                 ^ *(_DWORD *)(v267 + 8 * v836)
                 ^ *((_DWORD *)v679 - 2)
                 ^ *((_DWORD *)v687 - 2)
                 ^ *(_DWORD *)(v776 + 8)
                 ^ *((_DWORD *)v693 - 2);
            LODWORD(v99) = *((_DWORD *)&unk_EF148 + 2 * HIBYTE(HIDWORD(v288)) + 1)
                         ^ *(_DWORD *)(v267 + 8 * v836 + 4)
                         ^ *((_DWORD *)v679 - 1)
                         ^ *((_DWORD *)v687 - 1)
                         ^ *(_DWORD *)(v776 + 12)
                         ^ *((_DWORD *)v693 - 1)
                         ^ *((_DWORD *)&unk_F1948 + 2 * v311 + 1);
            v117 = *((_DWORD *)&unk_F2148 + 2 * v369)
                 ^ *(_DWORD *)(v267 + 8 * HIDWORD(v369))
                 ^ *((_DWORD *)&unk_EF148 + 2 * v548);
            v680 = *((_DWORD *)&unk_F1948 + 2 * v340 + 1);
            v549 = *((_DWORD *)&unk_F1948 + 2 * v340);
            v522 = v99 ^ *((_DWORD *)&unk_F2148 + 2 * HIDWORD(v317) + 1);
            v341 = &qword_F1150[(unsigned __int8)v348];
            LODWORD(v111) = v613;
            v614 = BYTE1(v348);
            v346 = v116 ^ *((_DWORD *)&unk_F2148 + 2 * HIDWORD(v317));
            v118 = *((_DWORD *)v282 - 1)
                 ^ *(_DWORD *)(v267 + 8 * v390 + 4)
                 ^ *((_DWORD *)v797 + 1)
                 ^ *((_DWORD *)v720 - 1)
                 ^ *((_DWORD *)v729 - 1)
                 ^ *(_DWORD *)(v802 + 12)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v317 + 1);
            HIDWORD(v99) = *((_DWORD *)v282 - 2)
                         ^ *(_DWORD *)(v267 + 8 * v390)
                         ^ *((_DWORD *)&unk_EF148 + 2 * v565)
                         ^ *((_DWORD *)v720 - 2)
                         ^ *((_DWORD *)v729 - 2)
                         ^ *(_DWORD *)(v802 + 8)
                         ^ *((_DWORD *)&unk_F1948 + 2 * v317)
                         ^ *((_DWORD *)&unk_F2148 + 2 * BYTE2(v324));
            v394 = *((_DWORD *)&unk_F2148 + 2 * v369 + 1)
                 ^ *(_DWORD *)(v267 + 8 * HIDWORD(v369) + 4)
                 ^ *((_DWORD *)v780 + 1)
                 ^ *(_DWORD *)(v111 - 4)
                 ^ *((_DWORD *)v532 - 1)
                 ^ *(_DWORD *)(v783 + 12)
                 ^ *((_DWORD *)v701 - 1)
                 ^ v680;
            v278 = v117
                 ^ *(_DWORD *)(v111 - 8)
                 ^ *((_DWORD *)v532 - 2)
                 ^ *(_DWORD *)(v783 + 8)
                 ^ *((_DWORD *)v701 - 2)
                 ^ v549;
            v367 = *((_DWORD *)&unk_F1948 + 2 * v330 + 1)
                 ^ *(_DWORD *)(v267 + 8 * v356 + 4)
                 ^ *((_DWORD *)v788 + 1)
                 ^ *((_DWORD *)v622 - 1)
                 ^ *((_DWORD *)v707 - 1)
                 ^ *(_DWORD *)(v793 + 12)
                 ^ *((_DWORD *)v712 - 1)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v380 + 1);
            v352 = *(_DWORD *)(v267 + 8 * v356)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v330)
                 ^ *((_DWORD *)&unk_EF148 + 2 * v555)
                 ^ *((_DWORD *)v622 - 2)
                 ^ *((_DWORD *)v707 - 2)
                 ^ *(_DWORD *)(v793 + 8)
                 ^ *((_DWORD *)v712 - 2)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v380);
            v373 = HIDWORD(v99);
            v384 = v118 ^ *((_DWORD *)&unk_F2148 + 2 * BYTE2(v324) + 1);
            v119 = *(_DWORD *)(v831 + 12)
                 ^ *((_DWORD *)v826 + 1)
                 ^ *(_DWORD *)(v267 + 8 * v433 + 4)
                 ^ *((_DWORD *)v824 - 1)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v464 + 1)
                 ^ *((_DWORD *)v829 - 1)
                 ^ *((_DWORD *)v341 - 1);
            v17 = *((_DWORD *)v341 - 2)
                ^ *((_DWORD *)v829 - 2)
                ^ *((_DWORD *)&unk_EF148 + 2 * v837)
                ^ *(_DWORD *)(v267 + 8 * v433)
                ^ *((_DWORD *)v824 - 2)
                ^ *((_DWORD *)&unk_F2148 + 2 * v464)
                ^ *(_DWORD *)(v831 + 8)
                ^ *((_DWORD *)&unk_F1948 + 2 * BYTE5(v288));
            v120 = *((_DWORD *)&unk_F1948 + 2 * BYTE5(v288) + 1);
            v16 = *((_DWORD *)&unk_F2148 + 2 * BYTE6(v288))
                ^ *((_DWORD *)v822 - 2)
                ^ *((_DWORD *)v818 - 2)
                ^ *((_DWORD *)v741 - 2)
                ^ *(_DWORD *)(v267 + 8 * v424)
                ^ *v814
                ^ *(_DWORD *)(v820 + 8)
                ^ *((_DWORD *)&unk_F1948 + 2 * v614);
            v410 = *(_DWORD *)(v267 + 8 * v406)
                 ^ LODWORD(qword_F0948[HIBYTE(v274)])
                 ^ *((_DWORD *)&unk_EF148 + 2 * v573)
                 ^ *((_DWORD *)v735 - 2)
                 ^ *((_DWORD *)v636 - 2)
                 ^ *((_DWORD *)v746 - 2)
                 ^ *v646
                 ^ *((_DWORD *)&unk_F2148 + 2 * v416);
            v530 = *(_DWORD *)(v267 + 8 * v424 + 4)
                 ^ *((_DWORD *)v741 - 1)
                 ^ v814[1]
                 ^ *((_DWORD *)v818 - 1)
                 ^ *(_DWORD *)(v820 + 12)
                 ^ *((_DWORD *)v822 - 1)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v614 + 1)
                 ^ *((_DWORD *)&unk_F2148 + 2 * BYTE6(v288) + 1);
            v535 = v119 ^ v120;
            v461 = v646[1]
                 ^ *(_DWORD *)(v267 + 8 * v406 + 4)
                 ^ HIDWORD(qword_F0948[HIBYTE(v274)])
                 ^ *((_DWORD *)v810 + 1)
                 ^ *((_DWORD *)v735 - 1)
                 ^ *((_DWORD *)v636 - 1)
                 ^ *((_DWORD *)v746 - 1)
                 ^ *((_DWORD *)v654 + 1);
          }
          while ( v269 != 14 );
          v121 = v267;
          v843 = v586;
          v268 = -1;
          v844 = v495;
          v845 = v467;
          v846 = v499;
          v847 = v506;
          v848 = v592;
          v849 = v602;
          v850 = v473;
          v851 = v488;
          v852 = v512;
          v853 = v438;
          v854 = v447;
          v855 = v299;
          v872 = v119 ^ v120;
          v869 = v16;
          v856 = v360;
          v871 = v17;
          v857 = v454;
          v858 = v518;
          v859 = v346;
          v860 = v522;
          v861 = v278;
          v862 = v394;
          v863 = v352;
          v864 = v367;
          v865 = v373;
          v866 = v384;
          v867 = v410;
          v868 = v461;
          v870 = v530;
          v357 = v873;
          v516 = v874;
          v370 = v875;
          v375 = v876;
          v381 = v877;
          v391 = v878;
          v400 = v879;
          v407 = v880;
          v417 = v881;
          v542 = v882;
          v425 = v883;
          v501 = v884;
          v434 = v885;
          v450 = v886;
          v443 = v887;
          v458 = v888;
          v470 = v889;
          v122 = v896;
          v477 = v890;
          v123 = v898;
          v124 = v902;
          v125 = v121;
          v465 = v891;
          v283 = v900;
          v483 = v892;
          v331 = v901;
          v492 = v893;
          v312 = v894;
          v507 = v895;
          v270 = v897;
          v275 = v899;
          v126 = v903;
          do
          {
            v318 = ~v381;
            v304 = v516 ^ HIDWORD(v268);
            v289 = ~v400;
            v342 = ~v434;
            v325 = ~v417;
            v127 = ~v370;
            v128 = ~v312;
            v129 = ~v425;
            v401 = ~v122;
            v130 = ~v443;
            v349 = ~v470;
            v426 = ~v283;
            v295 = ~v357;
            v444 = ~v124;
            v313 = v375 ^ HIDWORD(v268) ^ 0x10000000;
            v321 = v407 ^ HIDWORD(v268) ^ 0x30000000;
            v284 = v391 ^ HIDWORD(v268) ^ 0x20000000;
            v131 = v450 ^ HIDWORD(v268) ^ 0x60000000;
            v358 = v477 ^ (HIDWORD(v268) + 0x80000000);
            v371 = v483 ^ HIDWORD(v268) ^ 0x90000000;
            v382 = HIDWORD(v492) ^ HIDWORD(v268) ^ 0xA0000000;
            v392 = v507 ^ HIDWORD(v268) ^ 0xB0000000;
            v408 = v270 ^ HIDWORD(v268) ^ 0xC0000000;
            v418 = v275 ^ HIDWORD(v268) ^ 0xD0000000;
            HIDWORD(v492) = v458 ^ HIDWORD(v268) ^ 0x70000000;
            v435 = HIDWORD(v268) ^ 0xE0000000 ^ v331;
            v508 = ~v123;
            v451 = HIDWORD(v268) ^ 0xF0000000 ^ v126;
            v484 = v131;
            v459 = v129;
            v364 = ~v465;
            v376 = ~(_DWORD)v492;
            v132 = v501;
            v502 = v128;
            v332 = v132 ^ HIDWORD(v268) ^ 0x50000000;
            LOWORD(v492) = v130;
            v478 = v127;
            v784 = HIBYTE(v435);
            v789 = HIBYTE(v451);
            v798 = ((unsigned int)v516 ^ HIDWORD(v268)) >> 24;
            v811 = HIBYTE(v313);
            v517 = HIBYTE(v284);
            v667 = 8 * HIBYTE(v129) + 985408;
            v615 = 8 * ((unsigned int)~v124 >> 24) + 985408;
            v672 = 8 * HIBYTE(v342) + 985408;
            v556 = 8 * HIBYTE(v128) + 985408;
            v574 = 8 * ((unsigned int)~v123 >> 24) + 985408;
            v688 = 8 * HIBYTE(v130) + 985408;
            v661 = 8 * HIBYTE(v325) + 985408;
            v637 = 8 * HIBYTE(v127) + 985408;
            v520 = HIBYTE(v321);
            v655 = 8 * HIBYTE(v289) + 985408;
            v133 = v542 ^ HIDWORD(v268) ^ 0x40000000;
            v527 = HIBYTE(v133);
            v134 = &qword_F1150[(unsigned __int8)v313];
            v538 = HIBYTE(v332);
            v135 = &qword_F0150[BYTE2(v342)];
            v694 = 8 * ((unsigned int)~v470 >> 24) + 985408;
            v136 = &qword_EF950[BYTE1(v325)];
            v708 = *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v131) + 1);
            v681 = *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v131));
            v713 = BYTE1(v284);
            v543 = &qword_F0150[BYTE2(v459)];
            v566 = &qword_F1150[(unsigned __int8)v304];
            v137 = *((_DWORD *)v134 - 2)
                 ^ ~*(_DWORD *)(v125 + 8 * (unsigned __int8)v318)
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(HIDWORD(v492)))
                 ^ *((_DWORD *)v136 - 2)
                 ^ *((_DWORD *)v135 - 2)
                 ^ LODWORD(qword_F0948[HIBYTE(v401)]);
            v276 = 0xFFFFFF - HIDWORD(v268);
            v581 = &qword_F1150[(unsigned __int8)v284];
            v533 = BYTE2(v284);
            v721 = (unsigned __int8)v289;
            v138 = *((_DWORD *)v134 - 1)
                 ^ *((_DWORD *)v135 - 1)
                 ^ *(_DWORD *)(v125 + 8 * (unsigned __int8)v318 + 4)
                 ^ ~((0xFFFFFF - HIDWORD(v268)) ^ 0x10000000)
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(HIDWORD(v492)) + 1)
                 ^ *((_DWORD *)v136 - 1)
                 ^ HIDWORD(qword_F0948[HIBYTE(v401)])
                 ^ *((_DWORD *)&unk_F1948 + 2 * BYTE1(v321) + 1);
            v702 = &qword_F0150[BYTE2(v289)];
            v753 = (unsigned __int8)v459;
            v285 = &qword_EF950[BYTE1(v459)];
            v139 = &qword_F0150[BYTE2(v130)];
            v623 = &qword_F1150[(unsigned __int8)v133];
            v742 = BYTE2(v131);
            v466 = v138 ^ *((_DWORD *)&unk_F2148 + 2 * BYTE2(v332) + 1);
            v550 = BYTE2(v321);
            v140 = *((_DWORD *)&unk_F1948 + 2 * v713);
            v604 = &qword_F1150[(unsigned __int8)v321];
            v460 = v137 ^ *((_DWORD *)&unk_F1948 + 2 * BYTE1(v321)) ^ *((_DWORD *)&unk_F2148 + 2 * BYTE2(v332));
            v141 = *((_DWORD *)&unk_F1948 + 2 * v713 + 1);
            v142 = *(_DWORD *)(v125 + 8 * (unsigned __int8)v478 + 4) ^ v708 ^ (HIDWORD(v268) - 0xFFFFFF);
            HIDWORD(v268) -= 0x1FFFFFF;
            v143 = v142 ^ HIDWORD(qword_EF950[BYTE1(v289) - 1]);
            v144 = LODWORD(qword_EF950[BYTE1(v289) - 1]) ^ ~(*(_DWORD *)(v125 + 8 * (unsigned __int8)v478) ^ v681);
            v145 = (unsigned __int8)v325;
            v471 = &qword_F0150[BYTE2(v325)];
            v714 = (unsigned __int8)v342;
            v290 = &qword_EF950[BYTE1(v342)];
            v146 = v143 ^ *((_DWORD *)v543 - 1) ^ *(_DWORD *)(v556 + 12) ^ *((_DWORD *)v566 - 1) ^ v141;
            v147 = &qword_F0150[BYTE2(v349)];
            v148 = v144
                 ^ *((_DWORD *)v543 - 2)
                 ^ *(_DWORD *)(v556 + 8)
                 ^ *((_DWORD *)v566 - 2)
                 ^ v140
                 ^ *((_DWORD *)&unk_F2148 + 2 * BYTE2(v133));
            v544 = &qword_F1150[(unsigned __int8)v332];
            v149 = *((_DWORD *)v581 - 2);
            v322 = v148;
            v150 = *((_DWORD *)v581 - 1);
            v326 = v146 ^ *((_DWORD *)&unk_F2148 + 2 * BYTE2(v133) + 1);
            v343 = BYTE1(v332);
            v582 = BYTE6(v492);
            v682 = HIBYTE(v484);
            v567 = &qword_F1150[(unsigned __int8)v484];
            v151 = &qword_EF950[BYTE1(v492)];
            v777 = (unsigned __int8)v349;
            v485 = &qword_EF950[BYTE1(v349)];
            v333 = *((_DWORD *)v139 - 1)
                 ^ *(_DWORD *)(v125 + 8 * v721 + 4)
                 ^ v276
                 ^ 0xDFFFFFFF
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v358) + 1)
                 ^ *((_DWORD *)v285 - 1)
                 ^ *(_DWORD *)(v574 + 12)
                 ^ v150
                 ^ *((_DWORD *)&unk_F1948 + 2 * BYTE1(v133) + 1)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v742 + 1);
            v286 = ~*(_DWORD *)(v125 + 8 * v721)
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v358))
                 ^ *((_DWORD *)v285 - 2)
                 ^ *((_DWORD *)v139 - 2)
                 ^ *(_DWORD *)(v574 + 8)
                 ^ v149
                 ^ *((_DWORD *)&unk_F1948 + 2 * BYTE1(v133))
                 ^ *((_DWORD *)&unk_F2148 + 2 * v742);
            v722 = BYTE5(v492);
            v152 = *((_DWORD *)v604 - 2)
                 ^ *((_DWORD *)v147 - 2)
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v371))
                 ^ ~*(_DWORD *)(v125 + 8 * v145)
                 ^ *((_DWORD *)v290 - 2)
                 ^ LODWORD(qword_F0948[HIBYTE(v426)]);
            v597 = &qword_F1150[BYTE4(v492)];
            v153 = *((_DWORD *)v604 - 1)
                 ^ *((_DWORD *)v147 - 1)
                 ^ *((_DWORD *)v290 - 1)
                 ^ *(_DWORD *)(v125 + 8 * v145 + 4)
                 ^ v276
                 ^ 0xCFFFFFFF
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v371) + 1)
                 ^ HIDWORD(qword_F0948[HIBYTE(v426)]);
            HIDWORD(v492) = &qword_EF950[BYTE1(v364)];
            v557 = &qword_F0150[BYTE2(v502)];
            v736 = BYTE1(v358);
            v605 = &qword_F1150[(unsigned __int8)v358];
            v291 = v153 ^ *((_DWORD *)&unk_F1948 + 2 * v343 + 1) ^ *((_DWORD *)&unk_F2148 + 2 * v582 + 1);
            v344 = v152 ^ *((_DWORD *)&unk_F1948 + 2 * v343) ^ *((_DWORD *)&unk_F2148 + 2 * v582);
            v154 = *((_DWORD *)v623 - 2);
            v575 = &qword_EF950[BYTE1(v376)];
            v155 = *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v382) + 1)
                 ^ v276
                 ^ 0xBFFFFFFF
                 ^ *(_DWORD *)(v125 + 8 * v753 + 4)
                 ^ *((_DWORD *)v151 - 1)
                 ^ HIDWORD(qword_F0150[BYTE2(v364) - 1])
                 ^ *(_DWORD *)(v615 + 12)
                 ^ *((_DWORD *)v623 - 1);
            v624 = &qword_F1150[(unsigned __int8)v371];
            v743 = BYTE1(v371);
            v156 = v154
                 ^ *(_DWORD *)(v615 + 8)
                 ^ ~*(_DWORD *)(v125 + 8 * v753)
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v382))
                 ^ *((_DWORD *)v151 - 2)
                 ^ LODWORD(qword_F0150[BYTE2(v364) - 1])
                 ^ *((_DWORD *)&unk_F1948 + 2 * v682);
            v754 = (unsigned __int8)v364;
            v709 = 8 * HIBYTE(v364) + 985408;
            v350 = v156 ^ *((_DWORD *)&unk_F2148 + 2 * BYTE2(v358));
            v359 = *((_DWORD *)&unk_F1948 + 2 * v682 + 1) ^ v155 ^ *((_DWORD *)&unk_F2148 + 2 * BYTE2(v358) + 1);
            v157 = &qword_F0150[BYTE2(v376)];
            v158 = (unsigned __int8)v502;
            v503 = &qword_EF950[BYTE1(v502)];
            v794 = v158;
            v758 = BYTE1(v382);
            v631 = &qword_F1150[(unsigned __int8)v382];
            v159 = *((_DWORD *)&unk_F1948 + 2 * v722);
            v160 = *((_DWORD *)&unk_F1948 + 2 * v722 + 1);
            v723 = (unsigned __int8)v376;
            v365 = *((_DWORD *)v544 - 2)
                 ^ ~*(_DWORD *)(v125 + 8 * v714)
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v392))
                 ^ *((_DWORD *)v485 - 2)
                 ^ *((_DWORD *)v157 - 2)
                 ^ LODWORD(qword_F0948[HIBYTE(v295)])
                 ^ v159
                 ^ *((_DWORD *)&unk_F2148 + 2 * BYTE2(v371));
            v807 = (unsigned __int8)v401;
            v730 = 8 * HIBYTE(v376) + 985408;
            v372 = *((_DWORD *)v485 - 1)
                 ^ *(_DWORD *)(v125 + 8 * v714 + 4)
                 ^ v276
                 ^ 0xAFFFFFFF
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v392) + 1)
                 ^ *((_DWORD *)v157 - 1)
                 ^ HIDWORD(qword_F0948[HIBYTE(v295)])
                 ^ *((_DWORD *)v544 - 1)
                 ^ v160
                 ^ *((_DWORD *)&unk_F2148 + 2 * BYTE2(v371) + 1);
            v616 = &qword_EF950[BYTE1(v401)];
            v161 = &qword_F0150[BYTE2(v426)];
            v162 = *((_DWORD *)v557 - 2);
            v768 = BYTE1(v392);
            v163 = *(_DWORD *)(v125 + 8 * (unsigned __int8)v492 + 4)
                 ^ v276
                 ^ 0x9FFFFFFF
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v408) + 1)
                 ^ *(_DWORD *)(HIDWORD(v492) - 4)
                 ^ *((_DWORD *)v557 - 1);
            v683 = &qword_F1150[(unsigned __int8)v392];
            v772 = BYTE2(v418);
            v486 = (unsigned __int8)v508;
            v558 = &qword_EF950[BYTE1(v508)];
            v164 = &qword_F0150[BYTE2(v444)];
            v165 = ~*(_DWORD *)(v125 + 8 * (unsigned __int8)v492)
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v408))
                 ^ *(_DWORD *)(HIDWORD(v492) - 8)
                 ^ v162
                 ^ *(_DWORD *)(v637 + 8)
                 ^ *((_DWORD *)v567 - 2)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v736);
            v166 = v163 ^ *(_DWORD *)(v637 + 12) ^ *((_DWORD *)v567 - 1) ^ *((_DWORD *)&unk_F1948 + 2 * v736 + 1);
            v803 = BYTE1(v408);
            v638 = &qword_F1150[(unsigned __int8)v408];
            v377 = v165 ^ *((_DWORD *)&unk_F2148 + 2 * BYTE2(v382));
            v383 = v166 ^ *((_DWORD *)&unk_F2148 + 2 * BYTE2(v382) + 1);
            v167 = &qword_F0150[BYTE2(v401)];
            v493 = (unsigned __int8)v426;
            v168 = BYTE2(v435);
            v427 = &qword_EF950[BYTE1(v426)];
            v169 = *((_DWORD *)v575 - 1)
                 ^ *(_DWORD *)(v125 + 8 * v777 + 4)
                 ^ ~(v276 ^ 0x70000000)
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v418) + 1)
                 ^ *((_DWORD *)v167 - 1)
                 ^ HIDWORD(qword_F0948[HIBYTE(v318)])
                 ^ *((_DWORD *)v597 - 1);
            v170 = *((_DWORD *)v597 - 2)
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v418))
                 ^ ~*(_DWORD *)(v125 + 8 * v777)
                 ^ *((_DWORD *)v575 - 2)
                 ^ *((_DWORD *)v167 - 2)
                 ^ LODWORD(qword_F0948[HIBYTE(v318)]);
            v568 = &qword_F0150[BYTE2(v295)];
            v171 = &qword_F1150[(unsigned __int8)v418];
            v419 = BYTE1(v418);
            v647 = v171;
            v598 = BYTE2(v451);
            v172 = (unsigned __int8)v435;
            v436 = BYTE1(v435);
            v715 = &qword_F1150[v172];
            v173 = *((_DWORD *)&unk_F2148 + 2 * BYTE2(v392) + 1);
            v393 = v170 ^ *((_DWORD *)&unk_F1948 + 2 * v743) ^ *((_DWORD *)&unk_F2148 + 2 * BYTE2(v392));
            v402 = *((_DWORD *)&unk_F1948 + 2 * v743 + 1) ^ v169 ^ v173;
            LOBYTE(v170) = v451;
            v452 = BYTE1(v451);
            v174 = &qword_F0150[BYTE2(v508)];
            v737 = &qword_F1150[(unsigned __int8)v170];
            v497 = BYTE2(v313);
            v545 = BYTE1(v313);
            v175 = *(_DWORD *)(v655 + 8)
                 ^ *((_DWORD *)v174 - 2)
                 ^ *((_DWORD *)v503 - 2)
                 ^ ~*(_DWORD *)(v125 + 8 * v754)
                 ^ *((_DWORD *)&unk_EF148 + 2 * v784);
            v176 = *(_DWORD *)(v655 + 12)
                 ^ ~(v276 ^ 0x80000000)
                 ^ *(_DWORD *)(v125 + 8 * v754 + 4)
                 ^ *((_DWORD *)&unk_EF148 + 2 * v784 + 1)
                 ^ *((_DWORD *)v503 - 1)
                 ^ *((_DWORD *)v174 - 1)
                 ^ *((_DWORD *)v605 - 1);
            v504 = (unsigned __int8)v444;
            v576 = &qword_EF950[BYTE1(v444)];
            v583 = &qword_F0150[BYTE2(v478)];
            v656 = &qword_EF950[BYTE1(v478)];
            v177 = *((_DWORD *)&unk_F2148 + 2 * BYTE2(v408));
            v409 = v176 ^ *((_DWORD *)&unk_F1948 + 2 * v758 + 1) ^ *((_DWORD *)&unk_F2148 + 2 * BYTE2(v408) + 1);
            v314 = v175 ^ *((_DWORD *)v605 - 2) ^ *((_DWORD *)&unk_F1948 + 2 * v758) ^ v177;
            v178 = *((_DWORD *)v624 - 2);
            v445 = BYTE2(v304);
            v479 = BYTE1(v304);
            v179 = ~(v276 ^ 0x90000000)
                 ^ *(_DWORD *)(v125 + 8 * v723 + 4)
                 ^ *((_DWORD *)&unk_EF148 + 2 * v789 + 1)
                 ^ *((_DWORD *)v616 - 1);
            v180 = *((_DWORD *)v624 - 1);
            v181 = ~*(_DWORD *)(v125 + 8 * v723)
                 ^ *((_DWORD *)&unk_EF148 + 2 * v789)
                 ^ *((_DWORD *)v616 - 2)
                 ^ *((_DWORD *)v161 - 2);
            v509 = (unsigned __int8)v295;
            v617 = &qword_EF950[BYTE1(v295)];
            v625 = &qword_F0150[BYTE2(v318)];
            v724 = &qword_EF950[BYTE1(v318)];
            v296 = v181
                 ^ *(_DWORD *)(v661 + 8)
                 ^ v178
                 ^ *((_DWORD *)&unk_F1948 + 2 * v768)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v772);
            v305 = *(_DWORD *)(v661 + 12)
                 ^ v179
                 ^ *((_DWORD *)v161 - 1)
                 ^ v180
                 ^ *((_DWORD *)&unk_F1948 + 2 * v768 + 1)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v772 + 1);
            v747 = *((_DWORD *)&unk_F1948 + 2 * v419);
            v755 = *((_DWORD *)&unk_F1948 + 2 * v419 + 1);
            v420 = *(_DWORD *)(v125 + 8 * v794 + 4)
                 ^ ~(v276 ^ 0xA0000000)
                 ^ *((_DWORD *)&unk_EF148 + 2 * v798 + 1)
                 ^ *((_DWORD *)v558 - 1)
                 ^ *((_DWORD *)v164 - 1)
                 ^ *(_DWORD *)(v667 + 12)
                 ^ *((_DWORD *)v631 - 1)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v803 + 1)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v168 + 1);
            v319 = ~*(_DWORD *)(v125 + 8 * v794)
                 ^ *((_DWORD *)&unk_EF148 + 2 * v798)
                 ^ *((_DWORD *)v558 - 2)
                 ^ *((_DWORD *)v164 - 2)
                 ^ *(_DWORD *)(v667 + 8)
                 ^ *((_DWORD *)v631 - 2)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v803)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v168);
            v182 = *((_DWORD *)v427 - 1);
            v183 = *(_DWORD *)(v672 + 12);
            v428 = ~*(_DWORD *)(v125 + 8 * v807)
                 ^ *((_DWORD *)&unk_EF148 + 2 * v811)
                 ^ *((_DWORD *)v427 - 2)
                 ^ *((_DWORD *)v568 - 2)
                 ^ *(_DWORD *)(v672 + 8)
                 ^ *((_DWORD *)v683 - 2)
                 ^ v747
                 ^ *((_DWORD *)&unk_F2148 + 2 * v598);
            v673 = *((_DWORD *)&unk_F1948 + 2 * v436 + 1);
            v184 = *((_DWORD *)&unk_F1948 + 2 * v436);
            v748 = *((_DWORD *)&unk_F1948 + 2 * v452 + 1);
            v759 = *((_DWORD *)&unk_F2148 + 2 * v497 + 1);
            v437 = v183
                 ^ ~(v276 ^ 0xB0000000)
                 ^ *(_DWORD *)(v125 + 8 * v807 + 4)
                 ^ *((_DWORD *)&unk_EF148 + 2 * v811 + 1)
                 ^ v182
                 ^ *((_DWORD *)v568 - 1)
                 ^ *((_DWORD *)v683 - 1)
                 ^ v755
                 ^ *((_DWORD *)&unk_F2148 + 2 * v598 + 1);
            v599 = *((_DWORD *)&unk_F2148 + 2 * v445 + 1);
            v446 = *((_DWORD *)v638 - 2)
                 ^ *(_DWORD *)(v688 + 8)
                 ^ ~*(_DWORD *)(v125 + 8 * v486)
                 ^ *((_DWORD *)&unk_EF148 + 2 * v517)
                 ^ *((_DWORD *)v576 - 2)
                 ^ *((_DWORD *)v583 - 2)
                 ^ v184
                 ^ *((_DWORD *)&unk_F2148 + 2 * v445);
            v185 = ~(v276 ^ 0xC0000000) ^ *(_DWORD *)(v125 + 8 * v486 + 4);
            v569 = *((_DWORD *)v471 - 2);
            v186 = ~(v276 ^ 0xE0000000)
                 ^ *(_DWORD *)(v125 + 8 * v504 + 4)
                 ^ *((_DWORD *)&unk_EF148 + 2 * v527 + 1)
                 ^ *((_DWORD *)v656 - 1)
                 ^ *((_DWORD *)v702 - 1)
                 ^ *(_DWORD *)(v709 + 12)
                 ^ *((_DWORD *)v715 - 1)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v479 + 1)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v533 + 1);
            v271 = *((_DWORD *)&unk_F2148 + 2 * v550 + 1)
                 ^ ~(v276 ^ 0xF0000000)
                 ^ *(_DWORD *)(v125 + 8 * v509 + 4)
                 ^ *((_DWORD *)&unk_EF148 + 2 * v538 + 1)
                 ^ *((_DWORD *)v724 - 1)
                 ^ *((_DWORD *)v471 - 1)
                 ^ *(_DWORD *)(v730 + 12)
                 ^ *((_DWORD *)v737 - 1)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v545 + 1);
            v472 = *(_DWORD *)(v694 + 8)
                 ^ *((_DWORD *)&unk_EF148 + 2 * v520)
                 ^ ~*(_DWORD *)(v125 + 8 * v493)
                 ^ *((_DWORD *)v617 - 2)
                 ^ *((_DWORD *)v625 - 2)
                 ^ *((_DWORD *)v647 - 2)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v452)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v497);
            v487 = *((_DWORD *)&unk_F2148 + 2 * v533)
                 ^ ~*(_DWORD *)(v125 + 8 * v504)
                 ^ *((_DWORD *)&unk_EF148 + 2 * v527)
                 ^ *((_DWORD *)v656 - 2)
                 ^ *((_DWORD *)v702 - 2)
                 ^ *(_DWORD *)(v709 + 8)
                 ^ *((_DWORD *)v715 - 2)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v479);
            v498 = ~*(_DWORD *)(v125 + 8 * v509)
                 ^ *((_DWORD *)&unk_EF148 + 2 * v538)
                 ^ *((_DWORD *)v724 - 2)
                 ^ v569
                 ^ *(_DWORD *)(v730 + 8)
                 ^ *((_DWORD *)v737 - 2)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v545)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v550);
            v453 = v185
                 ^ *((_DWORD *)&unk_EF148 + 2 * v517 + 1)
                 ^ *((_DWORD *)v576 - 1)
                 ^ *((_DWORD *)v583 - 1)
                 ^ *(_DWORD *)(v688 + 12)
                 ^ *((_DWORD *)v638 - 1)
                 ^ v673
                 ^ v599;
            v534 = HIBYTE(v359);
            v539 = HIBYTE(v372);
            v480 = *(_DWORD *)(v125 + 8 * v493 + 4)
                 ^ ~(v276 ^ 0xD0000000)
                 ^ *((_DWORD *)&unk_EF148 + 2 * v520 + 1)
                 ^ *((_DWORD *)v617 - 1)
                 ^ *((_DWORD *)v625 - 1)
                 ^ *(_DWORD *)(v694 + 12)
                 ^ *((_DWORD *)v647 - 1)
                 ^ v748
                 ^ v759;
            v494 = v186;
            v778 = HIBYTE(v186);
            v785 = HIBYTE(v271);
            v804 = HIBYTE(v326);
            v812 = HIBYTE(v466);
            v521 = HIBYTE(v333);
            v528 = HIBYTE(v291);
            v674 = 8 * HIBYTE(v377) + 985408;
            v668 = 8 * HIBYTE(v365) + 985408;
            v684 = 8 * HIBYTE(v393) + 985408;
            v277 = 8 * HIBYTE(v314) + 985408;
            v648 = 8 * HIBYTE(v344) + 985408;
            v657 = 8 * HIBYTE(v350) + 985408;
            v187 = qword_F1150[(unsigned __int8)v326 - 1];
            v188 = &qword_EF950[BYTE1(v350)];
            v189 = &qword_F0150[BYTE2(v365)];
            v190 = *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v383))
                 ^ *(_DWORD *)(v125 + 8 * (unsigned __int8)v460)
                 ^ LODWORD(qword_EF950[BYTE1(v344) - 1])
                 ^ *((_DWORD *)v189 - 2);
            v191 = &qword_F0150[BYTE2(v377)];
            v192 = *(_DWORD *)(v125 + 8 * (unsigned __int8)v460 + 4)
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v383) + 1)
                 ^ HIDWORD(qword_EF950[BYTE1(v344) - 1])
                 ^ *((_DWORD *)v189 - 1)
                 ^ HIDWORD(qword_F0948[HIBYTE(v428)]);
            v695 = (unsigned __int8)v344;
            v710 = &qword_F0150[BYTE2(v344)];
            v716 = (unsigned __int8)v365;
            v345 = &qword_EF950[BYTE1(v365)];
            v193 = v190 ^ LODWORD(qword_F0948[HIBYTE(v428)]) ^ v187 ^ *((_DWORD *)&unk_F1948 + 2 * BYTE1(v333));
            v194 = v192 ^ HIDWORD(v187) ^ *((_DWORD *)&unk_F1948 + 2 * BYTE1(v333) + 1);
            LODWORD(v187) = &qword_F1150[(unsigned __int8)v333];
            v366 = BYTE2(v333);
            v195 = *((_DWORD *)&unk_F2148 + 2 * BYTE2(v359) + 1);
            WORD2(v187) = v359;
            v357 = v193 ^ *((_DWORD *)&unk_F2148 + 2 * BYTE2(v359));
            v196 = BYTE5(v187);
            v516 = v194 ^ v195;
            v551 = &qword_F1150[BYTE4(v187)];
            v197 = *((_DWORD *)v188 - 1);
            v198 = *(_DWORD *)(v125 + 8 * (unsigned __int8)v286)
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v402))
                 ^ *((_DWORD *)v188 - 2);
            v199 = *((_DWORD *)v191 - 2);
            v200 = (unsigned __int8)v350;
            v738 = &qword_F0150[BYTE2(v350)];
            v731 = (unsigned __int8)v377;
            v201 = *(_DWORD *)(v125 + 8 * (unsigned __int8)v286 + 4)
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v402) + 1)
                 ^ v197
                 ^ *((_DWORD *)v191 - 1)
                 ^ HIDWORD(qword_F0948[HIBYTE(v446)]);
            v202 = &qword_EF950[BYTE1(v377)];
            v203 = &qword_F0150[BYTE2(v314)];
            v204 = v198 ^ v199 ^ LODWORD(qword_F0948[HIBYTE(v446)]) ^ LODWORD(qword_F1150[(unsigned __int8)v466 - 1]);
            v334 = &qword_F1150[(unsigned __int8)v291];
            v205 = *((_DWORD *)&unk_F1948 + 2 * BYTE1(v291) + 1);
            v351 = BYTE2(v291);
            v662 = BYTE1(v372);
            v559 = &qword_F1150[(unsigned __int8)v372];
            v206 = *((_DWORD *)&unk_F2148 + 2 * BYTE2(v372) + 1);
            v749 = (unsigned __int8)v393;
            v370 = v204 ^ *((_DWORD *)&unk_F1948 + 2 * BYTE1(v291)) ^ *((_DWORD *)&unk_F2148 + 2 * BYTE2(v372));
            v292 = &qword_EF950[BYTE1(v393)];
            v375 = v201 ^ HIDWORD(qword_F1150[(unsigned __int8)v466 - 1]) ^ v205 ^ v206;
            HIDWORD(v187) = &qword_F0150[BYTE2(v393)];
            v207 = *(_DWORD *)(v125 + 8 * v695 + 4)
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v409) + 1)
                 ^ *((_DWORD *)v345 - 1)
                 ^ *(_DWORD *)(HIDWORD(v187) - 4);
            v208 = *(_DWORD *)(HIDWORD(v187) - 8)
                 ^ *(_DWORD *)(v125 + 8 * v695)
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v409))
                 ^ *((_DWORD *)v345 - 2);
            v505 = BYTE1(v383);
            v209 = *(_QWORD *)(v187 - 8);
            v570 = &qword_F1150[(unsigned __int8)v383];
            v210 = v208 ^ LODWORD(qword_F0948[HIBYTE(v472)]);
            v211 = BYTE2(v409);
            v760 = (unsigned __int8)v314;
            v315 = &qword_EF950[BYTE1(v314)];
            v212 = *((_DWORD *)&unk_F1948 + 2 * v196) ^ v210 ^ v209;
            HIDWORD(v209) ^= *((_DWORD *)&unk_F1948 + 2 * v196 + 1) ^ v207 ^ HIDWORD(qword_F0948[HIBYTE(v472)]);
            LODWORD(v209) = &qword_F0150[BYTE2(v319)];
            v696 = BYTE1(v402);
            v584 = &qword_F1150[(unsigned __int8)v402];
            v213 = *((_DWORD *)&unk_F2148 + 2 * BYTE2(v383) + 1);
            v381 = v212 ^ *((_DWORD *)&unk_F2148 + 2 * BYTE2(v383));
            v214 = *(_DWORD *)(v125 + 8 * v200);
            v215 = *(_DWORD *)(v125 + 8 * v200 + 4);
            v391 = HIDWORD(v209) ^ v213;
            v510 = &qword_EF950[BYTE1(v296)];
            v216 = BYTE2(v420);
            HIDWORD(v209) = &qword_F0150[BYTE2(v428)];
            v217 = BYTE1(v409);
            v600 = &qword_F1150[(unsigned __int8)v409];
            v218 = HIDWORD(qword_F0948[HIBYTE(v487)])
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v305) + 1)
                 ^ v215
                 ^ *((_DWORD *)v202 - 1)
                 ^ *((_DWORD *)v203 - 1)
                 ^ *((_DWORD *)v334 - 1);
            v219 = LODWORD(qword_F0948[HIBYTE(v487)])
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v305))
                 ^ v214
                 ^ *((_DWORD *)v202 - 2)
                 ^ *((_DWORD *)v203 - 2)
                 ^ *((_DWORD *)v334 - 2);
            v335 = &qword_EF950[BYTE1(v319)];
            v220 = v219 ^ *((_DWORD *)&unk_F1948 + 2 * v662);
            v221 = v218 ^ *((_DWORD *)&unk_F1948 + 2 * v662 + 1);
            v577 = &qword_F0150[BYTE2(v446)];
            v769 = BYTE1(v305);
            v663 = &qword_F1150[(unsigned __int8)v305];
            v222 = *((_DWORD *)&unk_F2148 + 2 * BYTE2(v402) + 1);
            v773 = BYTE2(v437);
            v400 = v220 ^ *((_DWORD *)&unk_F2148 + 2 * BYTE2(v402));
            v407 = v221 ^ v222;
            v223 = &qword_F0150[BYTE2(v296)];
            v224 = *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v420) + 1)
                 ^ *(_DWORD *)(v125 + 8 * v716 + 4)
                 ^ *((_DWORD *)v292 - 1)
                 ^ *((_DWORD *)v223 - 1);
            v225 = *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v420))
                 ^ *(_DWORD *)(v125 + 8 * v716)
                 ^ *((_DWORD *)v292 - 2)
                 ^ *((_DWORD *)v223 - 2);
            v293 = BYTE2(v453);
            v226 = (unsigned __int8)v296;
            v227 = HIDWORD(qword_F0948[HIBYTE(v498)]) ^ v224 ^ *((_DWORD *)v551 - 1);
            v228 = v225 ^ LODWORD(qword_F0948[HIBYTE(v498)]) ^ *((_DWORD *)v551 - 2);
            v717 = 8 * HIBYTE(v296) + 985408;
            v799 = (unsigned __int8)v428;
            v552 = &qword_EF950[BYTE1(v428)];
            v229 = v228 ^ *((_DWORD *)&unk_F1948 + 2 * v505) ^ *((_DWORD *)&unk_F2148 + 2 * v211);
            v542 = v227 ^ *((_DWORD *)&unk_F1948 + 2 * v505 + 1) ^ *((_DWORD *)&unk_F2148 + 2 * v211 + 1);
            v230 = &qword_F0150[BYTE2(v472)];
            LOWORD(v224) = v420;
            v417 = v229;
            v781 = BYTE1(v224);
            v618 = &qword_F1150[(unsigned __int8)v224];
            v297 = (unsigned __int8)v319;
            v744 = 8 * HIBYTE(v319) + 985408;
            v231 = *((_DWORD *)v559 - 2);
            v808 = (unsigned __int8)v446;
            v232 = *(_DWORD *)(v125 + 8 * v731 + 4)
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v437) + 1)
                 ^ *((_DWORD *)v315 - 1)
                 ^ *(_DWORD *)(v209 - 4)
                 ^ HIDWORD(qword_F0948[HIBYTE(v322)])
                 ^ *((_DWORD *)v559 - 1);
            v560 = &qword_EF950[BYTE1(v446)];
            v790 = BYTE1(v437);
            v626 = &qword_F1150[(unsigned __int8)v437];
            v425 = v231
                 ^ *(_DWORD *)(v125 + 8 * v731)
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v437))
                 ^ *((_DWORD *)v315 - 2)
                 ^ *(_DWORD *)(v209 - 8)
                 ^ LODWORD(qword_F0948[HIBYTE(v322)])
                 ^ *((_DWORD *)&unk_F1948 + 2 * v696)
                 ^ *((_DWORD *)&unk_F2148 + 2 * BYTE2(v305));
            v501 = v232 ^ *((_DWORD *)&unk_F1948 + 2 * v696 + 1) ^ *((_DWORD *)&unk_F2148 + 2 * BYTE2(v305) + 1);
            v306 = BYTE1(v453);
            v233 = *((_DWORD *)v510 - 2)
                 ^ *(_DWORD *)(v125 + 8 * v749)
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v453))
                 ^ *(_DWORD *)(HIDWORD(v209) - 8);
            v234 = *(_DWORD *)(v125 + 8 * v749 + 4)
                 ^ *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v453) + 1)
                 ^ *((_DWORD *)v510 - 1)
                 ^ *(_DWORD *)(HIDWORD(v209) - 4);
            v689 = &qword_F1150[(unsigned __int8)v453];
            v316 = (unsigned __int8)v472;
            v511 = &qword_EF950[BYTE1(v472)];
            v756 = BYTE1(v480);
            v697 = &qword_F1150[(unsigned __int8)v480];
            v434 = *((_DWORD *)v570 - 2)
                 ^ v233
                 ^ LODWORD(qword_F0948[HIBYTE(v460)])
                 ^ *((_DWORD *)&unk_F1948 + 2 * v217)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v216);
            v235 = *(v584 - 1);
            v450 = HIDWORD(qword_F0948[HIBYTE(v460)])
                 ^ v234
                 ^ *((_DWORD *)v570 - 1)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v217 + 1)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v216 + 1);
            v236 = *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v480)) ^ *(_DWORD *)(v125 + 8 * v760) ^ *((_DWORD *)v335 - 2);
            v237 = *((_DWORD *)&unk_EF148 + 2 * HIBYTE(v480) + 1)
                 ^ *(_DWORD *)(v125 + 8 * v760 + 4)
                 ^ *((_DWORD *)v335 - 1);
            v238 = *((_DWORD *)v577 - 2);
            v239 = *((_DWORD *)v577 - 1);
            v336 = (unsigned __int8)v487;
            v578 = &qword_EF950[BYTE1(v487)];
            v585 = &qword_F0150[BYTE2(v322)];
            v240 = BYTE2(v271);
            v632 = &qword_EF950[BYTE1(v498)];
            HIDWORD(v235) ^= v237 ^ v239 ^ HIDWORD(qword_F0948[HIBYTE(v286)]) ^ *((_DWORD *)&unk_F1948 + 2 * v769 + 1);
            v639 = &qword_F0150[BYTE2(v460)];
            v703 = &qword_EF950[BYTE1(v460)];
            v241 = (_DWORD *)((char *)&unk_F2148 + 8 * v293);
            v443 = v235
                 ^ v236
                 ^ v238
                 ^ LODWORD(qword_F0948[HIBYTE(v286)])
                 ^ *((_DWORD *)&unk_F1948 + 2 * v769)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v773);
            v320 = BYTE1(v494);
            v458 = HIDWORD(v235) ^ *((_DWORD *)&unk_F2148 + 2 * v773 + 1);
            v725 = &qword_F1150[(unsigned __int8)v494];
            v294 = BYTE2(v326);
            HIDWORD(v235) = *(_DWORD *)(v648 + 12);
            v327 = BYTE1(v326);
            v242 = *((_DWORD *)&unk_EF148 + 2 * v778)
                 ^ *(_DWORD *)(v125 + 8 * v226)
                 ^ *((_DWORD *)v552 - 2)
                 ^ *((_DWORD *)v230 - 2)
                 ^ *(_DWORD *)(v648 + 8);
            v649 = &qword_EF950[BYTE1(v322)];
            v243 = *(_DWORD *)(v125 + 8 * v226 + 4)
                 ^ *((_DWORD *)&unk_EF148 + 2 * v778 + 1)
                 ^ *((_DWORD *)v552 - 1)
                 ^ *((_DWORD *)v230 - 1)
                 ^ HIDWORD(v235)
                 ^ *((_DWORD *)v600 - 1);
            v244 = v242 ^ *((_DWORD *)v600 - 2);
            v601 = &qword_F0150[BYTE2(v286)];
            v732 = &qword_EF950[BYTE1(v286)];
            v470 = v244 ^ *((_DWORD *)&unk_F1948 + 2 * v781) ^ *v241;
            HIDWORD(v235) = (unsigned __int8)v271;
            v272 = BYTE1(v271);
            v750 = &qword_F1150[HIDWORD(v235)];
            LODWORD(v209) = *((_DWORD *)&unk_F2148 + 2 * BYTE2(v480));
            v245 = *((_DWORD *)&unk_F2148 + 2 * BYTE2(v480) + 1);
            v477 = v243 ^ *((_DWORD *)&unk_F1948 + 2 * v781 + 1) ^ v241[1];
            HIDWORD(v235) = *((_DWORD *)&unk_EF148 + 2 * v785 + 1) ^ *(_DWORD *)(v125 + 8 * v297 + 4);
            v246 = *(_DWORD *)(v125 + 8 * v297) ^ *((_DWORD *)&unk_EF148 + 2 * v785);
            v287 = BYTE2(v466);
            v298 = BYTE1(v466);
            LODWORD(v235) = &qword_F0150[BYTE2(v487)];
            v483 = *(_DWORD *)(v657 + 12)
                 ^ HIDWORD(v235)
                 ^ *((_DWORD *)v560 - 1)
                 ^ *(_DWORD *)(v235 - 4)
                 ^ *((_DWORD *)v663 - 1)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v790 + 1)
                 ^ v245;
            v465 = v246
                 ^ *((_DWORD *)v560 - 2)
                 ^ *(_DWORD *)(v235 - 8)
                 ^ *(_DWORD *)(v657 + 8)
                 ^ *((_DWORD *)v663 - 2)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v790)
                 ^ v209;
            LODWORD(v209) = (char *)&unk_F1948 + 8 * BYTE1(v494);
            v606 = (_DWORD *)(v125 + 8 * (unsigned __int8)v498);
            v492 = *((_QWORD *)&unk_EF148 + v804)
                 ^ *(_QWORD *)(v125 + 8 * v799)
                 ^ *(v511 - 1)
                 ^ qword_F0150[BYTE2(v498) - 1]
                 ^ *(_QWORD *)(v668 + 8)
                 ^ *(v618 - 1)
                 ^ *((_QWORD *)&unk_F1948 + v306)
                 ^ *((_QWORD *)&unk_F2148 + BYTE2(v494));
            v658 = (_DWORD *)(v125 + 8 * (unsigned __int8)v322);
            v247 = *(_DWORD *)(v125 + 8 * v316 + 4) ^ *((_DWORD *)&unk_EF148 + 2 * v521 + 1);
            v248 = *(_DWORD *)(v125 + 8 * v316) ^ *((_DWORD *)&unk_EF148 + 2 * v521);
            v507 = *((_DWORD *)&unk_EF148 + 2 * v812 + 1)
                 ^ *(_DWORD *)(v125 + 8 * v808 + 4)
                 ^ *((_DWORD *)v578 - 1)
                 ^ *((_DWORD *)v585 - 1)
                 ^ *(_DWORD *)(v674 + 12)
                 ^ *((_DWORD *)v626 - 1)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v756 + 1)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v240 + 1);
            v312 = *(_DWORD *)(v125 + 8 * v808)
                 ^ *((_DWORD *)&unk_EF148 + 2 * v812)
                 ^ *((_DWORD *)v578 - 2)
                 ^ *((_DWORD *)v585 - 2)
                 ^ *(_DWORD *)(v674 + 8)
                 ^ *((_DWORD *)v626 - 2)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v756)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v240);
            HIDWORD(v209) = *((_DWORD *)&unk_EF148 + 2 * v528) ^ *(_DWORD *)(v125 + 8 * v336);
            v553 = *((_DWORD *)&unk_F1948 + 2 * v272 + 1);
            v249 = *(_DWORD *)(v125 + 8 * v336 + 4) ^ *((_DWORD *)&unk_EF148 + 2 * v528 + 1);
            v250 = v247
                 ^ *((_DWORD *)v632 - 1)
                 ^ *((_DWORD *)v639 - 1)
                 ^ *(_DWORD *)(v684 + 12)
                 ^ *((_DWORD *)v689 - 1)
                 ^ *(_DWORD *)(v209 + 4);
            v529 = *((_DWORD *)&unk_F1948 + 2 * v272);
            v251 = HIDWORD(v209)
                 ^ *((_DWORD *)v649 - 2)
                 ^ *((_DWORD *)v601 - 2)
                 ^ *(_DWORD *)(v277 + 8)
                 ^ *((_DWORD *)v697 - 2);
            v561 = *((_DWORD *)&unk_F2148 + 2 * v287);
            v252 = *v606
                 ^ *((_DWORD *)&unk_EF148 + 2 * v534)
                 ^ *((_DWORD *)v703 - 2)
                 ^ *((_DWORD *)v710 - 2)
                 ^ *(_DWORD *)(v717 + 8)
                 ^ *((_DWORD *)v725 - 2)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v327);
            v253 = *((_DWORD *)&unk_F2148 + 2 * v366);
            v331 = v606[1]
                 ^ *((_DWORD *)&unk_EF148 + 2 * v534 + 1)
                 ^ *((_DWORD *)v703 - 1)
                 ^ *((_DWORD *)v710 - 1)
                 ^ *(_DWORD *)(v717 + 12)
                 ^ *((_DWORD *)v725 - 1)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v327 + 1)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v366 + 1);
            v124 = *((_DWORD *)&unk_EF148 + 2 * v539)
                 ^ *v658
                 ^ *((_DWORD *)v732 - 2)
                 ^ *((_DWORD *)v738 - 2)
                 ^ *(_DWORD *)(v744 + 8)
                 ^ *((_DWORD *)v750 - 2)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v298)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v351);
            v270 = v250 ^ *((_DWORD *)&unk_F2148 + 2 * v294 + 1);
            v126 = v658[1]
                 ^ *((_DWORD *)&unk_EF148 + 2 * v539 + 1)
                 ^ *((_DWORD *)v732 - 1)
                 ^ *((_DWORD *)v738 - 1)
                 ^ *(_DWORD *)(v744 + 12)
                 ^ *((_DWORD *)v750 - 1)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v298 + 1)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v351 + 1);
            v122 = *((_DWORD *)v639 - 2)
                 ^ v248
                 ^ *((_DWORD *)v632 - 2)
                 ^ *(_DWORD *)(v684 + 8)
                 ^ *((_DWORD *)v689 - 2)
                 ^ *((_DWORD *)&unk_F1948 + 2 * v320)
                 ^ *((_DWORD *)&unk_F2148 + 2 * v294);
            v275 = v249
                 ^ *((_DWORD *)v649 - 1)
                 ^ *((_DWORD *)v601 - 1)
                 ^ *(_DWORD *)(v277 + 12)
                 ^ *((_DWORD *)v697 - 1)
                 ^ v553
                 ^ *((_DWORD *)&unk_F2148 + 2 * v287 + 1);
            v283 = v252 ^ v253;
            v123 = v251 ^ v529 ^ v561;
          }
          while ( v268 != 0xF1FFFFFFFFFFFFFFLL );
          v5 = v125;
          v254 = v357;
          v255 = &v844;
          v875 = v370;
          v256 = &v875;
          v873 = v357;
          v876 = v375;
          v874 = v516;
          v877 = v381;
          v878 = v391;
          v879 = v400;
          v880 = v407;
          v881 = v417;
          v882 = v542;
          v883 = v425;
          v884 = v501;
          v885 = v434;
          v886 = v450;
          v887 = v443;
          v888 = v458;
          v896 = v122;
          v889 = v470;
          v897 = v270;
          v890 = v477;
          v899 = v275;
          v900 = v252 ^ v253;
          v257 = v516;
          v891 = v465;
          v902 = v124;
          v903 = v126;
          v892 = v483;
          v898 = v251 ^ v529 ^ v561;
          v901 = v331;
          v893 = v492;
          v258 = v840;
          v259 = v586;
          v894 = v312;
          v895 = v507;
          while ( 1 )
          {
            v262 = *(_DWORD *)(v258 + 8);
            v258 += 8;
            v263 = *(_DWORD *)(v258 + 4);
            *(_DWORD *)v258 = v262 ^ v259 ^ v254;
            *(_DWORD *)(v258 + 4) = v263 ^ v257 ^ HIDWORD(v259);
            if ( &dest[120] == (_BYTE *)v258 )
              break;
            v260 = *v255;
            v256 += 2;
            v261 = v255[1];
            v255 += 2;
            v254 = *(v256 - 2);
            v257 = *(v256 - 1);
            v259 = __PAIR64__(v261, v260);
          }
          v3 = 0;
          ++*(_QWORD *)(a1 + 264);
          if ( !n )
            break;
        }
        else if ( !n )
        {
          break;
        }
        v4 = 128 - v3;
      }
    }
    result = memcpy(v841, dest, 0x80u);
    *(_DWORD *)(a1 + 128) = v3;
  }
  return result;
}
// EF950: using guessed type _QWORD qword_EF950[256];
// F0150: using guessed type _QWORD qword_F0150[254];
// F0948: using guessed type _QWORD qword_F0948[257];
// F1150: using guessed type _QWORD qword_F1150[255];

//----- (000B0DA4) --------------------------------------------------------
_DWORD *__fastcall sub_B0DA4(_DWORD *a1, char a2, char a3, void *a4, size_t n)
{
  unsigned int v5; // r4
  unsigned int v6; // r12
  unsigned int v7; // r6
  size_t v8; // r4
  unsigned int v9; // r5
  int v10; // r6
  char *v11; // r3
  int *v12; // r12
  int *v13; // r4
  int v14; // r0
  int v15; // r1
  int *v16; // lr
  int v17; // r2
  int v18; // r3
  int v19; // r2
  int v20; // r12
  int v21; // r11
  int v22; // r3
  unsigned int v23; // r4
  unsigned int v24; // r6
  int v25; // r0
  unsigned int v26; // r2
  unsigned int v27; // r3
  unsigned int v28; // r5
  _QWORD *v29; // r4
  _QWORD *v30; // lr
  int v31; // r11
  int *v32; // r10
  int v33; // r10
  int v34; // r3
  int v35; // r5
  _QWORD *v36; // r6
  _QWORD *v37; // r2
  int v38; // r12
  int v39; // r0
  int v40; // r4
  int v41; // r0
  int v42; // r7
  _DWORD *v43; // r12
  int v44; // r1
  int v45; // r5
  int v46; // r2
  int v47; // r0
  int v48; // r9
  int v49; // r7
  __int64 v50; // r2
  int v51; // r1
  int v52; // r9
  _QWORD *v53; // r4
  int v54; // r5
  int v55; // r0
  int v56; // r5
  _QWORD *v57; // r6
  int v58; // r7
  int v59; // r0
  int v60; // r1
  int v61; // r8
  int v62; // r0
  int v63; // r4
  int v64; // r7
  unsigned int v65; // r7
  int v66; // r5
  unsigned int v67; // r12
  _QWORD *v68; // lr
  int v69; // r1
  int v70; // r6
  __int64 v71; // r10
  int v72; // r0
  _QWORD *v73; // r9
  __int64 v74; // r2
  int v75; // r1
  int v76; // r5
  int v77; // r8
  _QWORD *v78; // r12
  int v79; // r8
  int v80; // r4
  int v81; // r12
  int v82; // r7
  int v83; // r12
  int v84; // r1
  int v85; // r9
  int v86; // r4
  _DWORD *v87; // r0
  int v88; // r8
  _DWORD *v89; // r12
  int v90; // r1
  int v91; // r6
  int v92; // r7
  int v93; // r0
  _DWORD *v94; // r4
  int v95; // r1
  int v96; // lr
  int v97; // r7
  int v98; // r4
  void **p_dest; // r3
  int *v100; // r1
  unsigned int v101; // t1
  unsigned int v102; // r2
  int *v103; // r1
  char *v104; // r3
  int v105; // r2
  int v106; // r0
  _QWORD *v107; // r3
  __int64 v109; // [sp+0h] [bp-1BCh]
  unsigned int v110; // [sp+14h] [bp-1A8h]
  unsigned int v111; // [sp+14h] [bp-1A8h]
  int v112; // [sp+14h] [bp-1A8h]
  int v113; // [sp+14h] [bp-1A8h]
  unsigned int v114; // [sp+18h] [bp-1A4h]
  int v115; // [sp+18h] [bp-1A4h]
  int v116; // [sp+1Ch] [bp-1A0h]
  __int64 v117; // [sp+1Ch] [bp-1A0h]
  unsigned int v118; // [sp+24h] [bp-198h]
  unsigned int v119; // [sp+24h] [bp-198h]
  _QWORD *v120; // [sp+24h] [bp-198h]
  int v121; // [sp+24h] [bp-198h]
  int v122; // [sp+28h] [bp-194h]
  unsigned int v123; // [sp+28h] [bp-194h]
  int v124; // [sp+28h] [bp-194h]
  unsigned int v125; // [sp+28h] [bp-194h]
  int v126; // [sp+2Ch] [bp-190h]
  unsigned int v127; // [sp+2Ch] [bp-190h]
  unsigned int v128; // [sp+2Ch] [bp-190h]
  int v129; // [sp+2Ch] [bp-190h]
  int v130; // [sp+30h] [bp-18Ch]
  unsigned int v131; // [sp+30h] [bp-18Ch]
  unsigned int v132; // [sp+30h] [bp-18Ch]
  int v133; // [sp+30h] [bp-18Ch]
  unsigned int v134; // [sp+34h] [bp-188h]
  unsigned int v135; // [sp+34h] [bp-188h]
  int v136; // [sp+34h] [bp-188h]
  int v137; // [sp+38h] [bp-184h]
  unsigned int v138; // [sp+38h] [bp-184h]
  unsigned int v139; // [sp+38h] [bp-184h]
  int v140; // [sp+3Ch] [bp-180h]
  __int16 v141; // [sp+3Ch] [bp-180h]
  _QWORD *v142; // [sp+3Ch] [bp-180h]
  unsigned int v143; // [sp+3Ch] [bp-180h]
  unsigned int v144; // [sp+3Ch] [bp-180h]
  int v145; // [sp+40h] [bp-17Ch]
  unsigned int v146; // [sp+40h] [bp-17Ch]
  _QWORD *v147; // [sp+40h] [bp-17Ch]
  int v148; // [sp+40h] [bp-17Ch]
  int v149; // [sp+40h] [bp-17Ch]
  int v150; // [sp+44h] [bp-178h]
  int v151; // [sp+44h] [bp-178h]
  int v152; // [sp+44h] [bp-178h]
  char *v153; // [sp+44h] [bp-178h]
  int v154; // [sp+44h] [bp-178h]
  unsigned int v155; // [sp+44h] [bp-178h]
  int v156; // [sp+48h] [bp-174h]
  int v157; // [sp+48h] [bp-174h]
  int v158; // [sp+48h] [bp-174h]
  _QWORD *v159; // [sp+48h] [bp-174h]
  unsigned int v160; // [sp+4Ch] [bp-170h]
  _DWORD *v161; // [sp+4Ch] [bp-170h]
  unsigned int v162; // [sp+50h] [bp-16Ch]
  int v163; // [sp+50h] [bp-16Ch]
  char *v164; // [sp+54h] [bp-168h]
  int v165; // [sp+54h] [bp-168h]
  int v166; // [sp+54h] [bp-168h]
  int v167; // [sp+58h] [bp-164h]
  int v168; // [sp+58h] [bp-164h]
  char *v169; // [sp+58h] [bp-164h]
  __int64 v170; // [sp+5Ch] [bp-160h]
  _DWORD *v171; // [sp+5Ch] [bp-160h]
  int v172; // [sp+5Ch] [bp-160h]
  int v173; // [sp+5Ch] [bp-160h]
  int v174; // [sp+60h] [bp-15Ch]
  char *v175; // [sp+60h] [bp-15Ch]
  _QWORD *v176; // [sp+64h] [bp-158h]
  int v177; // [sp+64h] [bp-158h]
  _QWORD *v178; // [sp+64h] [bp-158h]
  _QWORD *v179; // [sp+64h] [bp-158h]
  unsigned int v180; // [sp+68h] [bp-154h]
  _DWORD *v181; // [sp+68h] [bp-154h]
  _QWORD *v182; // [sp+68h] [bp-154h]
  _QWORD *v183; // [sp+6Ch] [bp-150h]
  int v184; // [sp+6Ch] [bp-150h]
  unsigned int v185; // [sp+6Ch] [bp-150h]
  _QWORD *v186; // [sp+6Ch] [bp-150h]
  _QWORD *v187; // [sp+6Ch] [bp-150h]
  unsigned int v188; // [sp+70h] [bp-14Ch]
  unsigned int v189; // [sp+70h] [bp-14Ch]
  _QWORD *v190; // [sp+70h] [bp-14Ch]
  _QWORD *v191; // [sp+70h] [bp-14Ch]
  int v192; // [sp+74h] [bp-148h]
  char *v193; // [sp+74h] [bp-148h]
  char *v194; // [sp+78h] [bp-144h]
  int v195; // [sp+78h] [bp-144h]
  _QWORD *v196; // [sp+78h] [bp-144h]
  _QWORD *v197; // [sp+78h] [bp-144h]
  _QWORD *v198; // [sp+7Ch] [bp-140h]
  _QWORD *v199; // [sp+7Ch] [bp-140h]
  _QWORD *v200; // [sp+7Ch] [bp-140h]
  unsigned int v201; // [sp+80h] [bp-13Ch]
  _QWORD *v202; // [sp+80h] [bp-13Ch]
  int v203; // [sp+80h] [bp-13Ch]
  char *v204; // [sp+84h] [bp-138h]
  char *v205; // [sp+84h] [bp-138h]
  int v206; // [sp+84h] [bp-138h]
  _QWORD *v207; // [sp+88h] [bp-134h]
  _QWORD *v208; // [sp+88h] [bp-134h]
  int v209; // [sp+88h] [bp-134h]
  _QWORD *v210; // [sp+8Ch] [bp-130h]
  _QWORD *v211; // [sp+8Ch] [bp-130h]
  _QWORD *v212; // [sp+90h] [bp-12Ch]
  _DWORD *v213; // [sp+90h] [bp-12Ch]
  _QWORD *v214; // [sp+94h] [bp-128h]
  int v215; // [sp+94h] [bp-128h]
  _QWORD *v216; // [sp+94h] [bp-128h]
  char *v217; // [sp+98h] [bp-124h]
  _QWORD *v218; // [sp+98h] [bp-124h]
  _QWORD *v219; // [sp+9Ch] [bp-120h]
  char *v220; // [sp+9Ch] [bp-120h]
  _QWORD *v221; // [sp+A0h] [bp-11Ch]
  char *v222; // [sp+A0h] [bp-11Ch]
  _QWORD *v223; // [sp+A4h] [bp-118h]
  _QWORD *v224; // [sp+A8h] [bp-114h]
  int v225; // [sp+A8h] [bp-114h]
  _DWORD *v226; // [sp+A8h] [bp-114h]
  int v227; // [sp+ACh] [bp-110h]
  _QWORD *v228; // [sp+ACh] [bp-110h]
  _QWORD *v229; // [sp+ACh] [bp-110h]
  char *v230; // [sp+B0h] [bp-10Ch]
  char *v231; // [sp+B0h] [bp-10Ch]
  char *v232; // [sp+B4h] [bp-108h]
  _DWORD *v233; // [sp+B4h] [bp-108h]
  _QWORD *v234; // [sp+B8h] [bp-104h]
  int v235; // [sp+BCh] [bp-100h]
  _QWORD *v236; // [sp+BCh] [bp-100h]
  _DWORD *v237; // [sp+BCh] [bp-100h]
  _QWORD *v238; // [sp+C0h] [bp-FCh]
  char *v239; // [sp+C0h] [bp-FCh]
  int v240; // [sp+C4h] [bp-F8h]
  _QWORD *v241; // [sp+C4h] [bp-F8h]
  int v242; // [sp+C4h] [bp-F8h]
  char *v243; // [sp+C8h] [bp-F4h]
  int v244; // [sp+C8h] [bp-F4h]
  int v245; // [sp+CCh] [bp-F0h]
  unsigned int v246; // [sp+CCh] [bp-F0h]
  int v247; // [sp+CCh] [bp-F0h]
  int v248; // [sp+D0h] [bp-ECh]
  int v249; // [sp+D0h] [bp-ECh]
  int v250; // [sp+D0h] [bp-ECh]
  int v251; // [sp+D0h] [bp-ECh]
  int v252; // [sp+D4h] [bp-E8h]
  unsigned int v253; // [sp+D4h] [bp-E8h]
  int v254; // [sp+D8h] [bp-E4h]
  unsigned int v255; // [sp+D8h] [bp-E4h]
  int v256; // [sp+DCh] [bp-E0h]
  void *dest; // [sp+E8h] [bp-D4h] BYREF
  _QWORD *v259; // [sp+ECh] [bp-D0h]
  int v260; // [sp+F0h] [bp-CCh] BYREF
  int v261; // [sp+F4h] [bp-C8h]
  __int64 v262; // [sp+F8h] [bp-C4h]
  int v263; // [sp+100h] [bp-BCh]
  int v264; // [sp+104h] [bp-B8h]
  int v265; // [sp+108h] [bp-B4h]
  int v266; // [sp+10Ch] [bp-B0h]
  int v267; // [sp+110h] [bp-ACh] BYREF
  int v268; // [sp+114h] [bp-A8h]
  int v269; // [sp+118h] [bp-A4h]
  int v270; // [sp+11Ch] [bp-A0h]
  int v271; // [sp+120h] [bp-9Ch]
  int v272; // [sp+124h] [bp-98h]
  int v273; // [sp+128h] [bp-94h] BYREF
  int v274; // [sp+12Ch] [bp-90h]
  int v275; // [sp+130h] [bp-8Ch] BYREF
  int v276; // [sp+134h] [bp-88h]
  __int64 v277; // [sp+138h] [bp-84h] BYREF
  int v278; // [sp+140h] [bp-7Ch]
  int v279; // [sp+144h] [bp-78h]
  int v280; // [sp+148h] [bp-74h]
  int v281; // [sp+14Ch] [bp-70h]
  int v282; // [sp+150h] [bp-6Ch]
  int v283; // [sp+154h] [bp-68h]
  int v284; // [sp+158h] [bp-64h]
  int v285; // [sp+15Ch] [bp-60h]
  int v286; // [sp+160h] [bp-5Ch]
  int v287; // [sp+164h] [bp-58h]
  int v288; // [sp+168h] [bp-54h]
  int v289; // [sp+16Ch] [bp-50h]
  char v290[76]; // [sp+170h] [bp-4Ch] BYREF

  v5 = a1[16];
  dest = a4;
  v6 = a1[34];
  v7 = a1[35];
  v290[0] = (128 >> a3) | a2 & -(128 >> a3);
  if ( v5 > 0x37 )
  {
    v8 = 128 - v5;
    v10 = (__PAIR64__(v7, v6) + 2) >> 32;
    v9 = v6 + 2;
  }
  else
  {
    v8 = 64 - v5;
    v10 = (__PAIR64__(v7, v6) + 1) >> 32;
    v9 = v6 + 1;
  }
  memset(&v290[1], 0, v8 - 9);
  v290[v8 - 8] = HIBYTE(v10);
  v11 = &v290[v8 - 8];
  v11[7] = v9;
  v11[4] = HIBYTE(v9);
  v11[1] = BYTE2(v10);
  v11[2] = BYTE1(v10);
  v11[5] = BYTE2(v9);
  v11[6] = BYTE1(v9);
  v11[3] = v10;
  v259 = a1 + 18;
  sph_groestl224_0(a1, v290, v8);
  v12 = a1 + 18;
  v13 = &v260;
  do
  {
    v14 = *v12;
    v12 += 4;
    v15 = *(v12 - 3);
    v16 = v13;
    v17 = *(v12 - 2);
    v13 += 4;
    v18 = *(v12 - 1);
    *v16 = v14;
    v16[1] = v15;
    v16[2] = v17;
    v16[3] = v18;
  }
  while ( v12 != a1 + 34 );
  v275 = v260;
  v276 = v261;
  v277 = v262;
  v109 = 0;
  v278 = v263;
  v279 = v264;
  v280 = v265;
  v281 = v266;
  v282 = v267;
  v283 = v268;
  v284 = v269;
  v285 = v270;
  v286 = v271;
  v287 = v272;
  v288 = v273;
  v289 = v274;
  v145 = v260;
  v19 = v270;
  v20 = v271;
  v167 = v261;
  v21 = v273;
  v170 = v262;
  v140 = v263;
  v150 = v264;
  v116 = v265;
  v137 = v266;
  v122 = v267;
  v126 = v268;
  v130 = v269;
  v156 = v274;
  v22 = v272;
  do
  {
    v110 = v145 ^ v109;
    v23 = (v109 + 48) ^ v116;
    v134 = (v109 + 112) ^ v21;
    v24 = v122 ^ (v109 + 64);
    v118 = v150 ^ ((unsigned __int64)(v109 + 32) >> 32);
    v127 = v126 ^ ((unsigned __int64)(v109 + 64) >> 32);
    v131 = v130 ^ (v109 + 80);
    v25 = (v156 ^ ((unsigned __int64)(v109 + 112) >> 32)) >> 24;
    v151 = v156 ^ ((unsigned __int64)(v109 + 112) >> 32);
    v123 = v137 ^ ((unsigned __int64)(v109 + 48) >> 32);
    v117 = v170 ^ (v109 + 16);
    v26 = v19 ^ ((unsigned __int64)(v109 + 80) >> 32);
    v27 = v22 ^ ((unsigned __int64)(v109 + 96) >> 32);
    v138 = v23;
    v28 = (v109 + 32) ^ v140;
    v157 = (HIDWORD(v170) ^ ((unsigned __int64)(v109 + 16) >> 32)) >> 24;
    v141 = v24;
    v164 = (char *)&unk_F0940 + 8 * HIBYTE(v23);
    v194 = (char *)&unk_F0940 + 8 * HIBYTE(v24);
    v171 = &dword_EF148[2 * (((unsigned int)v167 ^ HIDWORD(v109)) >> 24)];
    v146 = (v109 + 96) ^ v20;
    v204 = (char *)&unk_F0940 + 8 * HIBYTE(v131);
    v188 = HIBYTE(v27);
    v217 = (char *)&unk_F0940 + 8 * HIBYTE(v146);
    v230 = (char *)&unk_F0940 + 8 * HIBYTE(v134);
    v180 = HIBYTE(v26);
    v232 = (char *)&unk_F0940 + 8 * HIBYTE(v110);
    v29 = &qword_EF950[BYTE1(v117)];
    v30 = &qword_F0150[BYTE2(v28)];
    v243 = (char *)&unk_F0940 + 8 * HIBYTE(v28);
    v235 = dword_F1948[2 * BYTE1(v26) + 1];
    v227 = dword_F1948[2 * BYTE1(v26)];
    v252 = (unsigned __int8)v28;
    v176 = &qword_EF950[BYTE1(v28)];
    v183 = &qword_F0150[BYTE2(v138)];
    v198 = &qword_F1150[(unsigned __int8)v26];
    v31 = BYTE1(v27);
    v192 = BYTE2(v26);
    v32 = &dword_F2148[2 * BYTE2(v27)];
    v240 = *v32;
    v245 = v32[1];
    v33 = (unsigned __int8)(((unsigned int)v167 ^ HIDWORD(v109)) >> 16);
    v207 = &qword_F1150[(unsigned __int8)v27];
    v34 = BYTE2(v151);
    v35 = v171[1] ^ ((unsigned __int64)(v109 + 17) >> 32) ^ HIDWORD(qword_EE948[(unsigned __int8)v117]);
    v248 = *v171 ^ (v109 + 17) ^ LODWORD(qword_EE948[(unsigned __int8)v117]);
    v36 = &qword_F0150[BYTE2(v24)];
    v37 = &qword_F1150[(unsigned __int8)v127];
    v38 = HIDWORD(qword_EE948[(unsigned __int8)v110])
        ^ ((unsigned __int64)(v109 + 1) >> 32)
        ^ dword_EF148[2 * v25 + 1]
        ^ *((_DWORD *)v29 - 1)
        ^ *((_DWORD *)v30 - 1)
        ^ *((_DWORD *)v164 + 3)
        ^ *((_DWORD *)v37 - 1);
    v39 = LODWORD(qword_EE948[(unsigned __int8)v110])
        ^ (v109 + 1)
        ^ dword_EF148[2 * v25]
        ^ *((_DWORD *)v29 - 2)
        ^ *((_DWORD *)v30 - 2)
        ^ *((_DWORD *)v164 + 2)
        ^ *((_DWORD *)v37 - 2);
    v40 = BYTE1(v151);
    v219 = &qword_F1150[(unsigned __int8)v151];
    v254 = (unsigned __int8)((unsigned __int16)(v167 ^ WORD2(v109)) >> 8);
    v221 = &qword_F1150[(unsigned __int8)(v167 ^ BYTE4(v109))];
    v152 = (unsigned __int8)v141;
    v212 = &qword_EF950[HIBYTE(v141)];
    v214 = &qword_F0150[BYTE2(v131)];
    v256 = BYTE6(v117);
    v172 = (unsigned __int8)v131;
    v224 = &qword_EF950[BYTE1(v131)];
    v41 = v39 ^ v227;
    v228 = &qword_F0150[BYTE2(v146)];
    v42 = BYTE4(v117);
    v165 = BYTE5(v117);
    HIDWORD(v117) = v38 ^ v235 ^ v245;
    v238 = &qword_F1150[v42];
    v43 = &dword_F2148[2 * v33];
    v168 = BYTE2(v118);
    v114 = v41 ^ v240;
    v44 = v248 ^ *((_DWORD *)v176 - 2) ^ *((_DWORD *)v183 - 2) ^ *((_DWORD *)v194 + 2);
    v45 = v35 ^ *((_DWORD *)v176 - 1) ^ *((_DWORD *)v183 - 1) ^ *((_DWORD *)v194 + 3);
    v46 = *((_DWORD *)v198 - 1);
    v236 = &qword_EF950[BYTE1(v146)];
    v47 = *((_DWORD *)v198 - 2);
    v177 = (unsigned __int8)v146;
    v48 = dword_EF148[2 * v157 + 1];
    v49 = dword_EF148[2 * v157];
    v195 = dword_EF148[2 * HIBYTE(v118)];
    v249 = dword_EF148[2 * HIBYTE(v118) + 1];
    v199 = &qword_F0150[BYTE2(v134)];
    v158 = BYTE1(v118);
    v246 = v44 ^ v47 ^ dword_F1948[2 * v31] ^ dword_F2148[2 * v34];
    v210 = &qword_F1150[(unsigned __int8)v118];
    v142 = &qword_F0150[BYTE2(v110)];
    v241 = &qword_EF950[BYTE1(v110)];
    v184 = (unsigned __int8)v134;
    v147 = &qword_EF950[BYTE1(v134)];
    v111 = dword_F1948[2 * v31 + 1] ^ v45 ^ v46 ^ dword_F2148[2 * v34 + 1];
    v50 = qword_EF950[BYTE1(v138) - 1];
    v119 = v49
         ^ *v43
         ^ LODWORD(qword_EE948[v252])
         ^ (v109 + 33)
         ^ v50
         ^ *((_DWORD *)v36 - 2)
         ^ *((_DWORD *)v204 + 2)
         ^ *((_DWORD *)v207 - 2)
         ^ dword_F1948[2 * v40];
    v132 = v48
         ^ v43[1]
         ^ HIDWORD(qword_EE948[v252])
         ^ (__CFADD__((_DWORD)v109, 33) + HIDWORD(v109))
         ^ HIDWORD(v50)
         ^ *((_DWORD *)v36 - 1)
         ^ *((_DWORD *)v204 + 3)
         ^ *((_DWORD *)v207 - 1)
         ^ dword_F1948[2 * v40 + 1];
    v135 = LODWORD(qword_EE948[(unsigned __int8)v138])
         ^ dword_F1948[2 * v254]
         ^ (v109 + 49)
         ^ v195
         ^ *((_DWORD *)v212 - 2)
         ^ *((_DWORD *)v214 - 2)
         ^ *((_DWORD *)v217 + 2)
         ^ *((_DWORD *)v219 - 2)
         ^ dword_F2148[2 * v256];
    v139 = *((_DWORD *)v217 + 3)
         ^ HIDWORD(qword_EE948[(unsigned __int8)v138])
         ^ dword_F1948[2 * v254 + 1]
         ^ ((unsigned __int64)(v109 + 49) >> 32)
         ^ v249
         ^ *((_DWORD *)v212 - 1)
         ^ *((_DWORD *)v214 - 1)
         ^ *((_DWORD *)v219 - 1)
         ^ dword_F2148[2 * v256 + 1];
    v51 = *((_DWORD *)v224 - 1);
    v52 = dword_EF148[2 * HIBYTE(v123)]
        ^ *((_DWORD *)v221 - 2)
        ^ LODWORD(qword_EE948[v152])
        ^ (v109 + 65)
        ^ *((_DWORD *)v224 - 2);
    v225 = dword_F2148[2 * BYTE2(v123)];
    v250 = dword_F2148[2 * BYTE2(v123) + 1];
    v53 = &qword_F0150[BYTE2(v117)];
    HIDWORD(v50) = dword_EF148[2 * HIBYTE(v123) + 1]
                 ^ *((_DWORD *)v221 - 1)
                 ^ HIDWORD(qword_EE948[v152])
                 ^ ((unsigned __int64)(v109 + 65) >> 32)
                 ^ v51
                 ^ *((_DWORD *)v228 - 1);
    v153 = (char *)&unk_F0940 + 8 * BYTE3(v117);
    v54 = (v109 + 81) ^ *((_DWORD *)v232 + 2) ^ LODWORD(qword_EE948[v172]) ^ dword_EF148[2 * HIBYTE(v127)];
    v173 = HIDWORD(qword_EE948[v172])
         ^ *((_DWORD *)v232 + 3)
         ^ ((unsigned __int64)(v109 + 81) >> 32)
         ^ dword_EF148[2 * HIBYTE(v127) + 1];
    v55 = *((_DWORD *)v142 - 2) ^ LODWORD(qword_EE948[v177]);
    v174 = v54 ^ *((_DWORD *)v236 - 2);
    LODWORD(v50) = HIDWORD(qword_EE948[v184]) ^ *((_DWORD *)v241 - 1);
    v56 = *((_DWORD *)v142 - 1);
    v143 = dword_EF148[2 * v188 + 1];
    v57 = &qword_F1150[(unsigned __int8)v123];
    v162 = *((_DWORD *)v53 - 1);
    v58 = BYTE1(v123);
    v124 = *((_DWORD *)v147 - 1);
    v59 = v55 ^ (v109 + 97) ^ dword_EF148[2 * v180] ^ *((_DWORD *)v147 - 2);
    v60 = LODWORD(qword_EE948[v184])
        ^ *((_DWORD *)v241 - 2)
        ^ (v109 + 113)
        ^ dword_EF148[2 * v188]
        ^ *((_DWORD *)v53 - 2);
    v185 = *((_DWORD *)v57 - 1);
    v148 = dword_F1948[2 * v58];
    v61 = *((_DWORD *)v153 + 3);
    v189 = dword_F1948[2 * BYTE1(v127) + 1];
    v62 = v59 ^ *((_DWORD *)v153 + 2) ^ *((_DWORD *)v210 - 2);
    v63 = dword_F1948[2 * BYTE1(v127)];
    v154 = dword_F1948[2 * v58 + 1];
    v64 = dword_F2148[2 * BYTE2(v127) + 1];
    v128 = v62 ^ v148 ^ dword_F2148[2 * BYTE2(v127)];
    v65 = v64
        ^ HIDWORD(qword_EE948[v177])
        ^ v56
        ^ ((unsigned __int64)(v109 + 97) >> 32)
        ^ dword_EF148[2 * v180 + 1]
        ^ v124
        ^ v61
        ^ *((_DWORD *)v210 - 1)
        ^ v154;
    LODWORD(v117) = v52 ^ *((_DWORD *)v228 - 2) ^ *((_DWORD *)v230 + 2) ^ dword_F1948[2 * v165] ^ dword_F2148[2 * v168];
    v66 = ((unsigned int)v50
         ^ ((unsigned __int64)(v109 + 113) >> 32)
         ^ v143
         ^ v162
         ^ *((_DWORD *)v243 + 3)
         ^ v185
         ^ v189
         ^ dword_F2148[2 * v192 + 1]) >> 24;
    v149 = v50
         ^ ((unsigned __int64)(v109 + 113) >> 32)
         ^ v143
         ^ v162
         ^ *((_DWORD *)v243 + 3)
         ^ v185
         ^ v189
         ^ dword_F2148[2 * v192 + 1];
    v67 = v173
        ^ *((_DWORD *)v236 - 1)
        ^ *((_DWORD *)v199 - 1)
        ^ *((_DWORD *)v238 - 1)
        ^ dword_F1948[2 * v158 + 1]
        ^ v250;
    v144 = v60 ^ *((_DWORD *)v243 + 2) ^ *((_DWORD *)v57 - 2) ^ v63 ^ dword_F2148[2 * v192];
    v201 = v174 ^ *((_DWORD *)v199 - 2) ^ *((_DWORD *)v238 - 2) ^ dword_F1948[2 * v158] ^ v225;
    v155 = HIBYTE(v111);
    v125 = HIDWORD(v50) ^ *((_DWORD *)v230 + 3) ^ dword_F1948[2 * v165 + 1] ^ dword_F2148[2 * v168 + 1];
    v169 = (char *)&unk_F0940 + 8 * HIBYTE(v135);
    v175 = (char *)&unk_F0940 + 8 * BYTE3(v117);
    v160 = HIBYTE(v139);
    v193 = (char *)&unk_F0940 + 8 * HIBYTE(v201);
    v205 = (char *)&unk_F0940 + 8 * HIBYTE(v128);
    v181 = &dword_EF148[2 * HIBYTE(v111)];
    v220 = (char *)&unk_F0940 + 8 * HIBYTE(v144);
    v213 = &dword_EF148[2 * HIBYTE(v139)];
    v222 = (char *)&unk_F0940 + 8 * HIBYTE(v114);
    v226 = &dword_EF148[2 * HIBYTE(v125)];
    v231 = (char *)&unk_F0940 + 8 * HIBYTE(v246);
    v237 = &dword_EF148[2 * HIBYTE(v65)];
    v233 = &dword_EF148[2 * HIBYTE(v67)];
    v253 = HIBYTE(v67);
    v68 = &qword_EF950[BYTE1(v246)];
    HIDWORD(v50) = &qword_EF950[BYTE1(v119)];
    v255 = HIBYTE(v65);
    v239 = (char *)&unk_F0940 + 8 * HIBYTE(v119);
    v178 = &qword_F1150[(unsigned __int8)v67];
    v69 = qword_EE948[(unsigned __int8)v246];
    v234 = &qword_F0150[BYTE2(v246)];
    v109 += 2;
    v70 = BYTE1(v67);
    v242 = (unsigned __int8)v119;
    v166 = BYTE2(v67);
    v120 = &qword_F0150[BYTE2(v119)];
    v71 = *(_QWORD *)(HIDWORD(v50) - 8);
    v215 = *((_DWORD *)v68 - 2) ^ dword_EF148[2 * v66];
    v72 = HIDWORD(qword_EE948[(unsigned __int8)v246]) ^ dword_EF148[2 * HIBYTE(HIDWORD(v117)) + 1] ^ HIDWORD(v71);
    v73 = &qword_F1150[(unsigned __int8)v125];
    v196 = &qword_F1150[(unsigned __int8)v65];
    HIDWORD(v71) = BYTE6(v117);
    v247 = (unsigned __int8)v135;
    v74 = qword_F0150[BYTE2(v135) - 1];
    v186 = &qword_EF950[BYTE1(v135)];
    v75 = v69 ^ dword_EF148[2 * HIBYTE(HIDWORD(v117))] ^ v71 ^ v74 ^ *((_DWORD *)v175 + 2);
    v190 = &qword_F0150[BYTE2(v117)];
    LODWORD(v71) = BYTE1(v149);
    v208 = &qword_F1150[(unsigned __int8)v149];
    v244 = BYTE5(v117);
    v211 = &qword_F1150[BYTE4(v117)];
    HIDWORD(v170) = v72
                  ^ HIDWORD(v74)
                  ^ *((_DWORD *)v175 + 3)
                  ^ *((_DWORD *)v178 - 1)
                  ^ dword_F1948[2 * BYTE1(v65) + 1]
                  ^ dword_F2148[2 * BYTE2(v149) + 1];
    v251 = BYTE2(v111);
    LODWORD(v170) = v75 ^ *((_DWORD *)v178 - 2) ^ dword_F1948[2 * BYTE1(v65)] ^ dword_F2148[2 * BYTE2(v149)];
    LOWORD(v65) = v201;
    v179 = &qword_EF950[BYTE1(v117)];
    v202 = &qword_F0150[BYTE2(v201)];
    v76 = HIDWORD(qword_EE948[(unsigned __int8)v114])
        ^ *((_DWORD *)v68 - 1)
        ^ dword_EF148[2 * v66 + 1]
        ^ *((_DWORD *)v120 - 1);
    v77 = LODWORD(qword_EE948[(unsigned __int8)v114]) ^ v215 ^ *((_DWORD *)v120 - 2);
    v78 = &qword_F1150[(unsigned __int8)v111];
    v112 = BYTE1(v111);
    v121 = (unsigned __int8)v65;
    v223 = v78;
    v216 = &qword_EF950[BYTE1(v65)];
    v218 = &qword_F0150[BYTE2(v128)];
    v79 = v77 ^ *((_DWORD *)v169 + 2) ^ *((_DWORD *)v73 - 2) ^ dword_F1948[2 * v70];
    v136 = (unsigned __int8)v128;
    HIDWORD(v117) = BYTE2(v132);
    v229 = &qword_EF950[BYTE1(v128)];
    v80 = dword_F2148[2 * BYTE2(v65)];
    LODWORD(v74) = dword_F2148[2 * HIDWORD(v71)];
    v81 = v76
        ^ *((_DWORD *)v169 + 3)
        ^ *((_DWORD *)v73 - 1)
        ^ dword_F1948[2 * v70 + 1]
        ^ dword_F2148[2 * BYTE2(v65) + 1];
    v82 = dword_EF148[2 * HIBYTE(v132) + 1];
    v167 = v81;
    v145 = v79 ^ v80;
    v83 = dword_EF148[2 * HIBYTE(v132)];
    v84 = HIDWORD(qword_EE948[v242]) ^ dword_F2148[2 * HIDWORD(v71) + 1] ^ v181[1] ^ *((_DWORD *)v186 - 1);
    v159 = &qword_F0150[BYTE2(v144)];
    HIDWORD(v71) = BYTE1(v132);
    v200 = &qword_F1150[(unsigned __int8)v132];
    v129 = BYTE2(v139);
    v85 = *((_DWORD *)v190 - 1);
    v182 = &qword_F0150[BYTE2(v114)];
    v86 = *((_DWORD *)v190 - 2) ^ v74 ^ LODWORD(qword_EE948[v242]) ^ dword_EF148[2 * v155] ^ *((_DWORD *)v186 - 2);
    v191 = &qword_EF950[BYTE1(v114)];
    v133 = (unsigned __int8)v144;
    v187 = &qword_EF950[BYTE1(v144)];
    v150 = v85 ^ v84 ^ *((_DWORD *)v193 + 3) ^ *((_DWORD *)v196 - 1) ^ dword_F1948[2 * (_DWORD)v71 + 1];
    v140 = v86 ^ *((_DWORD *)v193 + 2) ^ *((_DWORD *)v196 - 2) ^ dword_F1948[2 * (_DWORD)v71];
    v87 = &qword_EE948[(unsigned __int8)v117];
    v88 = dword_F2148[2 * v251] ^ LODWORD(qword_EE948[v247]) ^ dword_F1948[2 * v244] ^ v83 ^ *((_DWORD *)v179 - 2);
    v89 = &dword_F2148[2 * BYTE2(v139)];
    v115 = BYTE1(v139);
    v197 = &qword_F1150[(unsigned __int8)v139];
    v137 = v82
         ^ HIDWORD(qword_EE948[v247])
         ^ dword_F1948[2 * v244 + 1]
         ^ dword_F2148[2 * v251 + 1]
         ^ *((_DWORD *)v179 - 1)
         ^ *((_DWORD *)v202 - 1)
         ^ *((_DWORD *)v205 + 3)
         ^ *((_DWORD *)v208 - 1);
    v116 = v88 ^ *((_DWORD *)v202 - 2) ^ *((_DWORD *)v205 + 2) ^ *((_DWORD *)v208 - 2);
    v90 = *((_DWORD *)v211 - 1) ^ v87[1] ^ dword_F1948[2 * v112 + 1];
    v163 = dword_F1948[2 * HIDWORD(v71)];
    v91 = *((_DWORD *)v216 - 2)
        ^ *((_DWORD *)v211 - 2)
        ^ *v87
        ^ dword_F1948[2 * v112]
        ^ dword_EF148[2 * v160]
        ^ *((_DWORD *)v218 - 2);
    v203 = dword_F1948[2 * HIDWORD(v71) + 1];
    v92 = BYTE1(v125);
    v206 = dword_F2148[2 * v129];
    v113 = BYTE2(v125);
    v209 = v89[1];
    v93 = v91 ^ *((_DWORD *)v220 + 2) ^ dword_F2148[2 * HIDWORD(v117)];
    v126 = *((_DWORD *)v216 - 1)
         ^ v90
         ^ v213[1]
         ^ *((_DWORD *)v218 - 1)
         ^ *((_DWORD *)v220 + 3)
         ^ dword_F2148[2 * HIDWORD(v117) + 1];
    v161 = &dword_F1948[2 * BYTE1(v125)];
    v94 = &dword_F2148[2 * BYTE2(v125)];
    v122 = v93;
    v20 = *((_DWORD *)v182 - 2)
        ^ LODWORD(qword_EE948[v136])
        ^ *((_DWORD *)v231 + 2)
        ^ dword_EF148[2 * v253]
        ^ *((_DWORD *)v187 - 2)
        ^ *((_DWORD *)v200 - 2)
        ^ dword_F1948[2 * v115]
        ^ dword_F2148[2 * v113];
    v95 = HIDWORD(qword_EE948[v133])
        ^ *((_DWORD *)v191 - 1)
        ^ *((_DWORD *)v234 - 1)
        ^ v237[1]
        ^ *((_DWORD *)v239 + 3)
        ^ *((_DWORD *)v197 - 1)
        ^ v161[1]
        ^ dword_F2148[2 * v166 + 1];
    v21 = *((_DWORD *)v191 - 2)
        ^ LODWORD(qword_EE948[v133])
        ^ *((_DWORD *)v234 - 2)
        ^ dword_EF148[2 * v255]
        ^ *((_DWORD *)v239 + 2)
        ^ *((_DWORD *)v197 - 2)
        ^ dword_F1948[2 * v92]
        ^ dword_F2148[2 * v166];
    v130 = *((_DWORD *)v223 - 2)
         ^ LODWORD(qword_EE948[v121])
         ^ *((_DWORD *)v222 + 2)
         ^ *v226
         ^ *((_DWORD *)v229 - 2)
         ^ *((_DWORD *)v159 - 2)
         ^ v163
         ^ v206;
    v19 = HIDWORD(qword_EE948[v121])
        ^ *((_DWORD *)v222 + 3)
        ^ *((_DWORD *)v223 - 1)
        ^ v226[1]
        ^ *((_DWORD *)v229 - 1)
        ^ *((_DWORD *)v159 - 1)
        ^ v203
        ^ v209;
    v156 = v95;
    v22 = *((_DWORD *)v182 - 1)
        ^ HIDWORD(qword_EE948[v136])
        ^ *((_DWORD *)v231 + 3)
        ^ v233[1]
        ^ *((_DWORD *)v187 - 1)
        ^ *((_DWORD *)v200 - 1)
        ^ dword_F1948[2 * v115 + 1]
        ^ v94[1];
  }
  while ( v109 != 10 );
  v96 = v145;
  v97 = *((_DWORD *)v182 - 1)
      ^ HIDWORD(qword_EE948[v136])
      ^ *((_DWORD *)v231 + 3)
      ^ v233[1]
      ^ *((_DWORD *)v187 - 1)
      ^ *((_DWORD *)v200 - 1)
      ^ dword_F1948[2 * v115 + 1]
      ^ v94[1];
  v98 = v167;
  p_dest = &dest;
  v277 = v170;
  v100 = (int *)&v277;
  v275 = v145;
  v276 = v167;
  v285 = v19;
  v286 = v20;
  v278 = v140;
  v287 = v97;
  v288 = v21;
  v279 = v150;
  v280 = v116;
  v281 = v137;
  v282 = v93;
  v283 = v126;
  v284 = v130;
  v289 = v156;
  while ( 1 )
  {
    v101 = (unsigned int)p_dest[2];
    p_dest += 2;
    v102 = (unsigned int)p_dest[1];
    *p_dest = (void *)(v101 ^ v96);
    p_dest[1] = (void *)(v102 ^ v98);
    if ( &v273 == (int *)p_dest )
      break;
    v96 = *v100;
    v100 += 2;
    v98 = *(v100 - 1);
  }
  v103 = &v267;
  v104 = v290;
  do
  {
    v105 = *v103;
    v103 += 2;
    v106 = *(v103 - 1);
    v104 += 8;
    *((_DWORD *)v104 - 2) = v105;
    *((_DWORD *)v104 - 1) = v106;
  }
  while ( &v275 != v103 );
  memcpy(dest, &v290[32 - n], n);
  v107 = v259;
  a1[16] = 0;
  do
    *v107++ = 0;
  while ( a1 + 32 != (_DWORD *)v107 );
  *((_QWORD *)a1 + 17) = 0;
  a1[32] = 0;
  a1[33] = (n << 11) & 0xFF0000 | (n << 27);
  return a1;
}
// EE948: using guessed type _QWORD qword_EE948[256];
// EF148: using guessed type _DWORD dword_EF148[514];
// EF950: using guessed type _QWORD qword_EF950[256];
// F0150: using guessed type _QWORD qword_F0150[254];
// F1150: using guessed type _QWORD qword_F1150[255];
// F1948: using guessed type _DWORD dword_F1948[512];
// F2148: using guessed type _DWORD dword_F2148[512];

//----- (000B279C) --------------------------------------------------------
__int64 __fastcall sub_B279C(int a1, char a2, char a3, void *a4, size_t n)
{
  unsigned int v5; // r6
  __int64 v6; // r4
  size_t v7; // r6
  __int64 v8; // r4
  size_t v9; // r2
  char *v10; // r6
  int v11; // r6
  int v12; // r1
  int v13; // r12
  unsigned int v14; // r4
  unsigned int v15; // r7
  unsigned int v16; // r5
  unsigned int v17; // lr
  unsigned int v18; // r9
  _DWORD *v19; // r3
  _QWORD *v20; // lr
  _QWORD *v21; // r4
  _QWORD *v22; // r12
  int v23; // r2
  char *v24; // r7
  int v25; // r3
  int v26; // r1
  _QWORD *v27; // r4
  int v28; // r1
  _QWORD *v29; // lr
  int v30; // r2
  int v31; // r6
  int v32; // r7
  int v33; // r12
  int v34; // r9
  _QWORD *v35; // r1
  int v36; // r6
  int v37; // r12
  _QWORD *v38; // r11
  int v39; // r5
  int v40; // r2
  int v41; // lr
  int v42; // r3
  _QWORD *v43; // r9
  int v44; // lr
  int v45; // r6
  int v46; // r5
  int v47; // lr
  int v48; // r2
  int v49; // r5
  int v50; // lr
  int v51; // r2
  int v52; // r5
  int v53; // r12
  int v54; // r2
  int v55; // r3
  int v56; // r2
  int v57; // r1
  int v58; // r3
  int v59; // r2
  int v60; // r3
  int v61; // r2
  int v62; // r3
  int v63; // r4
  int v64; // r2
  int v65; // r3
  int v66; // r11
  int v67; // r6
  int v68; // r9
  char *v69; // r5
  int v70; // r12
  int v71; // lr
  int v72; // r1
  int v73; // lr
  int v74; // r11
  int v75; // r12
  int v76; // r11
  int v77; // r4
  int v78; // r3
  int v79; // lr
  int v80; // r3
  int v81; // r12
  int v82; // r6
  int v83; // r5
  int v84; // r12
  int v85; // r2
  int v86; // r10
  unsigned int v87; // r12
  _QWORD *v88; // r3
  _QWORD *v89; // r1
  int v90; // r10
  int *v91; // r3
  int v92; // r2
  int v93; // r3
  int v94; // r2
  bool v95; // zf
  unsigned __int8 v96; // r7
  int v97; // r3
  _QWORD *v98; // lr
  _QWORD *v99; // r12
  int v100; // r9
  int v101; // r10
  int v102; // r2
  _QWORD *v103; // r1
  int v104; // r3
  int v105; // r2
  int v106; // r4
  _QWORD *v107; // r1
  int v108; // r10
  int v109; // r2
  int v110; // r11
  int v111; // r5
  int v112; // r9
  int v113; // r6
  int v114; // r2
  int v115; // r11
  int v116; // r3
  int v117; // lr
  int v118; // r5
  int v119; // r3
  int v120; // r2
  int v121; // r2
  int v122; // r7
  int v123; // r5
  int v124; // r10
  int v125; // r4
  int v126; // r2
  int v127; // r3
  __int64 v128; // r2
  int v129; // r12
  int v130; // lr
  int v131; // r5
  int v132; // r9
  int v133; // lr
  int v134; // r12
  int v135; // lr
  int v136; // r12
  int v137; // lr
  int v138; // r12
  int v139; // lr
  int v140; // r4
  int v141; // lr
  __int64 v142; // r4
  int v143; // r1
  int v144; // r10
  int v145; // r7
  int v146; // r9
  int v147; // r6
  int v148; // r1
  int v149; // r10
  int v150; // r7
  int v151; // lr
  void **v152; // r3
  int v153; // r4
  int *v154; // r1
  unsigned int v155; // t1
  unsigned int v156; // r2
  int *v157; // r1
  char *v158; // r3
  int v159; // r2
  int v160; // r0
  __int64 result; // r0
  int v162; // r3
  int v163; // r3
  __int64 v164; // [sp+0h] [bp-344h]
  unsigned int v165; // [sp+10h] [bp-334h]
  unsigned int v166; // [sp+10h] [bp-334h]
  char *v167; // [sp+10h] [bp-334h]
  int v168; // [sp+10h] [bp-334h]
  int v169; // [sp+14h] [bp-330h]
  unsigned int v170; // [sp+14h] [bp-330h]
  unsigned int v171; // [sp+14h] [bp-330h]
  int v172; // [sp+14h] [bp-330h]
  int v173; // [sp+14h] [bp-330h]
  __int64 v174; // [sp+18h] [bp-32Ch]
  unsigned int v175; // [sp+18h] [bp-32Ch]
  int v176; // [sp+18h] [bp-32Ch]
  int v177; // [sp+18h] [bp-32Ch]
  int v178; // [sp+18h] [bp-32Ch]
  unsigned int v179; // [sp+1Ch] [bp-328h]
  int v180; // [sp+1Ch] [bp-328h]
  char *v181; // [sp+1Ch] [bp-328h]
  int v182; // [sp+20h] [bp-324h]
  unsigned int v183; // [sp+20h] [bp-324h]
  _QWORD *v184; // [sp+20h] [bp-324h]
  unsigned int v185; // [sp+20h] [bp-324h]
  unsigned int v186; // [sp+24h] [bp-320h]
  int v187; // [sp+24h] [bp-320h]
  int v188; // [sp+24h] [bp-320h]
  unsigned int v189; // [sp+24h] [bp-320h]
  int v190; // [sp+24h] [bp-320h]
  int v191; // [sp+24h] [bp-320h]
  int v192; // [sp+24h] [bp-320h]
  unsigned int v193; // [sp+28h] [bp-31Ch]
  unsigned int v194; // [sp+28h] [bp-31Ch]
  int v195; // [sp+28h] [bp-31Ch]
  char *v196; // [sp+28h] [bp-31Ch]
  unsigned int v197; // [sp+2Ch] [bp-318h]
  unsigned int v198; // [sp+2Ch] [bp-318h]
  unsigned int v199; // [sp+30h] [bp-314h]
  unsigned int v200; // [sp+30h] [bp-314h]
  int v201; // [sp+30h] [bp-314h]
  _QWORD *v202; // [sp+30h] [bp-314h]
  unsigned int v203; // [sp+34h] [bp-310h]
  unsigned int v204; // [sp+34h] [bp-310h]
  int v205; // [sp+34h] [bp-310h]
  int v206; // [sp+34h] [bp-310h]
  int v207; // [sp+34h] [bp-310h]
  unsigned int v208; // [sp+38h] [bp-30Ch]
  _QWORD *v209; // [sp+38h] [bp-30Ch]
  unsigned int v210; // [sp+38h] [bp-30Ch]
  int v211; // [sp+38h] [bp-30Ch]
  int v212; // [sp+38h] [bp-30Ch]
  int v213; // [sp+38h] [bp-30Ch]
  int v214; // [sp+38h] [bp-30Ch]
  int v215; // [sp+3Ch] [bp-308h]
  unsigned int v216; // [sp+3Ch] [bp-308h]
  unsigned int v217; // [sp+3Ch] [bp-308h]
  unsigned int v218; // [sp+40h] [bp-304h]
  unsigned int v219; // [sp+40h] [bp-304h]
  int v220; // [sp+40h] [bp-304h]
  int v221; // [sp+44h] [bp-300h]
  unsigned int v222; // [sp+44h] [bp-300h]
  unsigned int v223; // [sp+44h] [bp-300h]
  int v224; // [sp+44h] [bp-300h]
  int v225; // [sp+44h] [bp-300h]
  int v226; // [sp+44h] [bp-300h]
  int v227; // [sp+48h] [bp-2FCh]
  unsigned int v228; // [sp+48h] [bp-2FCh]
  unsigned int v229; // [sp+48h] [bp-2FCh]
  int v230; // [sp+48h] [bp-2FCh]
  __int64 v231; // [sp+4Ch] [bp-2F8h]
  unsigned int v232; // [sp+4Ch] [bp-2F8h]
  unsigned int v233; // [sp+4Ch] [bp-2F8h]
  int v234; // [sp+4Ch] [bp-2F8h]
  unsigned int v235; // [sp+50h] [bp-2F4h]
  unsigned int v236; // [sp+50h] [bp-2F4h]
  int v237; // [sp+50h] [bp-2F4h]
  __int64 v238; // [sp+54h] [bp-2F0h]
  unsigned int v239; // [sp+54h] [bp-2F0h]
  unsigned int v240; // [sp+54h] [bp-2F0h]
  int v241; // [sp+54h] [bp-2F0h]
  unsigned int v242; // [sp+58h] [bp-2ECh]
  int v243; // [sp+58h] [bp-2ECh]
  unsigned int v244; // [sp+58h] [bp-2ECh]
  _QWORD *v245; // [sp+58h] [bp-2ECh]
  __int64 v246; // [sp+5Ch] [bp-2E8h]
  unsigned int v247; // [sp+5Ch] [bp-2E8h]
  int v248; // [sp+5Ch] [bp-2E8h]
  unsigned int v249; // [sp+5Ch] [bp-2E8h]
  _QWORD *v250; // [sp+5Ch] [bp-2E8h]
  int v251; // [sp+5Ch] [bp-2E8h]
  unsigned int v252; // [sp+60h] [bp-2E4h]
  _QWORD *v253; // [sp+60h] [bp-2E4h]
  int *v254; // [sp+60h] [bp-2E4h]
  unsigned int v255; // [sp+60h] [bp-2E4h]
  int v256; // [sp+60h] [bp-2E4h]
  int v257; // [sp+64h] [bp-2E0h]
  unsigned int v258; // [sp+64h] [bp-2E0h]
  int v259; // [sp+64h] [bp-2E0h]
  unsigned int v260; // [sp+64h] [bp-2E0h]
  int v261; // [sp+64h] [bp-2E0h]
  char *v262; // [sp+68h] [bp-2DCh]
  int v263; // [sp+68h] [bp-2DCh]
  int v264; // [sp+68h] [bp-2DCh]
  unsigned int v265; // [sp+68h] [bp-2DCh]
  int v266; // [sp+6Ch] [bp-2D8h]
  unsigned int v267; // [sp+6Ch] [bp-2D8h]
  _QWORD *v268; // [sp+6Ch] [bp-2D8h]
  int v269; // [sp+6Ch] [bp-2D8h]
  unsigned int v270; // [sp+6Ch] [bp-2D8h]
  unsigned int v271; // [sp+70h] [bp-2D4h]
  int v272; // [sp+70h] [bp-2D4h]
  unsigned int v273; // [sp+70h] [bp-2D4h]
  _QWORD *v274; // [sp+70h] [bp-2D4h]
  unsigned int v275; // [sp+74h] [bp-2D0h]
  int v276; // [sp+74h] [bp-2D0h]
  int v277; // [sp+74h] [bp-2D0h]
  int v278; // [sp+74h] [bp-2D0h]
  unsigned int v279; // [sp+74h] [bp-2D0h]
  int v280; // [sp+78h] [bp-2CCh]
  unsigned int v281; // [sp+78h] [bp-2CCh]
  int v282; // [sp+78h] [bp-2CCh]
  char *v283; // [sp+78h] [bp-2CCh]
  int v284; // [sp+78h] [bp-2CCh]
  unsigned int v285; // [sp+78h] [bp-2CCh]
  int v286; // [sp+7Ch] [bp-2C8h]
  int v287; // [sp+7Ch] [bp-2C8h]
  int v288; // [sp+7Ch] [bp-2C8h]
  int v289; // [sp+7Ch] [bp-2C8h]
  unsigned int v290; // [sp+80h] [bp-2C4h]
  unsigned int v291; // [sp+80h] [bp-2C4h]
  int v292; // [sp+80h] [bp-2C4h]
  int v293; // [sp+84h] [bp-2C0h]
  unsigned int v294; // [sp+84h] [bp-2C0h]
  int v295; // [sp+84h] [bp-2C0h]
  _QWORD *v296; // [sp+84h] [bp-2C0h]
  unsigned int v297; // [sp+84h] [bp-2C0h]
  int v298; // [sp+88h] [bp-2BCh]
  unsigned int v299; // [sp+88h] [bp-2BCh]
  int v300; // [sp+88h] [bp-2BCh]
  int v301; // [sp+88h] [bp-2BCh]
  unsigned int v302; // [sp+88h] [bp-2BCh]
  int v303; // [sp+8Ch] [bp-2B8h]
  unsigned int v304; // [sp+8Ch] [bp-2B8h]
  int v305; // [sp+8Ch] [bp-2B8h]
  int v306; // [sp+8Ch] [bp-2B8h]
  unsigned int v307; // [sp+8Ch] [bp-2B8h]
  int v308; // [sp+90h] [bp-2B4h]
  int v309; // [sp+90h] [bp-2B4h]
  int v310; // [sp+90h] [bp-2B4h]
  _QWORD *v311; // [sp+90h] [bp-2B4h]
  __int64 v312; // [sp+94h] [bp-2B0h]
  int v313; // [sp+94h] [bp-2B0h]
  int v314; // [sp+94h] [bp-2B0h]
  int v315; // [sp+98h] [bp-2ACh]
  int v316; // [sp+98h] [bp-2ACh]
  unsigned int v317; // [sp+98h] [bp-2ACh]
  int v318; // [sp+9Ch] [bp-2A8h]
  int v319; // [sp+9Ch] [bp-2A8h]
  int v320; // [sp+9Ch] [bp-2A8h]
  int v321; // [sp+A0h] [bp-2A4h]
  int v322; // [sp+A0h] [bp-2A4h]
  int v323; // [sp+A0h] [bp-2A4h]
  int v324; // [sp+A4h] [bp-2A0h]
  int v325; // [sp+A4h] [bp-2A0h]
  int v326; // [sp+A8h] [bp-29Ch]
  int v327; // [sp+A8h] [bp-29Ch]
  unsigned int v328; // [sp+ACh] [bp-298h]
  unsigned int v329; // [sp+ACh] [bp-298h]
  int v330; // [sp+ACh] [bp-298h]
  unsigned int v331; // [sp+B0h] [bp-294h]
  char *v332; // [sp+B4h] [bp-290h]
  _QWORD *v333; // [sp+B4h] [bp-290h]
  int v334; // [sp+B4h] [bp-290h]
  unsigned int v335; // [sp+B4h] [bp-290h]
  unsigned int v336; // [sp+B8h] [bp-28Ch]
  unsigned int v337; // [sp+B8h] [bp-28Ch]
  int v338; // [sp+B8h] [bp-28Ch]
  _QWORD *v339; // [sp+BCh] [bp-288h]
  _QWORD *v340; // [sp+BCh] [bp-288h]
  int v341; // [sp+BCh] [bp-288h]
  unsigned int v342; // [sp+BCh] [bp-288h]
  int v343; // [sp+C0h] [bp-284h]
  unsigned int v344; // [sp+C0h] [bp-284h]
  _QWORD *v345; // [sp+C4h] [bp-280h]
  int v346; // [sp+C4h] [bp-280h]
  unsigned int v347; // [sp+C4h] [bp-280h]
  int v348; // [sp+C8h] [bp-27Ch]
  _QWORD *v349; // [sp+C8h] [bp-27Ch]
  int v350; // [sp+C8h] [bp-27Ch]
  char *v351; // [sp+C8h] [bp-27Ch]
  _QWORD *v352; // [sp+C8h] [bp-27Ch]
  __int64 v353; // [sp+CCh] [bp-278h]
  char *v354; // [sp+CCh] [bp-278h]
  _QWORD *v355; // [sp+CCh] [bp-278h]
  int v356; // [sp+CCh] [bp-278h]
  int v357; // [sp+CCh] [bp-278h]
  _QWORD *v358; // [sp+D0h] [bp-274h]
  unsigned int v359; // [sp+D0h] [bp-274h]
  int v360; // [sp+D0h] [bp-274h]
  unsigned int v361; // [sp+D4h] [bp-270h]
  char *v362; // [sp+D4h] [bp-270h]
  _QWORD *v363; // [sp+D4h] [bp-270h]
  _QWORD *v364; // [sp+D4h] [bp-270h]
  int v365; // [sp+D4h] [bp-270h]
  int v366; // [sp+D8h] [bp-26Ch]
  char *v367; // [sp+D8h] [bp-26Ch]
  _QWORD *v368; // [sp+D8h] [bp-26Ch]
  _QWORD *v369; // [sp+D8h] [bp-26Ch]
  char *v370; // [sp+DCh] [bp-268h]
  _QWORD *v371; // [sp+DCh] [bp-268h]
  _QWORD *v372; // [sp+DCh] [bp-268h]
  unsigned int v373; // [sp+E0h] [bp-264h]
  _QWORD *v374; // [sp+E0h] [bp-264h]
  _QWORD *v375; // [sp+E0h] [bp-264h]
  int v376; // [sp+E0h] [bp-264h]
  _QWORD *v377; // [sp+E0h] [bp-264h]
  _QWORD *v378; // [sp+E0h] [bp-264h]
  _QWORD *v379; // [sp+E0h] [bp-264h]
  _QWORD *v380; // [sp+E4h] [bp-260h]
  _QWORD *v381; // [sp+E4h] [bp-260h]
  int v382; // [sp+E4h] [bp-260h]
  _QWORD *v383; // [sp+E4h] [bp-260h]
  _QWORD *v384; // [sp+E4h] [bp-260h]
  _DWORD *v385; // [sp+E4h] [bp-260h]
  char *v386; // [sp+E8h] [bp-25Ch]
  _QWORD *v387; // [sp+E8h] [bp-25Ch]
  _QWORD *v388; // [sp+E8h] [bp-25Ch]
  _QWORD *v389; // [sp+E8h] [bp-25Ch]
  char *v390; // [sp+E8h] [bp-25Ch]
  _QWORD *v391; // [sp+ECh] [bp-258h]
  _QWORD *v392; // [sp+ECh] [bp-258h]
  char *v393; // [sp+ECh] [bp-258h]
  _QWORD *v394; // [sp+ECh] [bp-258h]
  _QWORD *v395; // [sp+F0h] [bp-254h]
  _QWORD *v396; // [sp+F0h] [bp-254h]
  char *v397; // [sp+F4h] [bp-250h]
  char *v398; // [sp+F4h] [bp-250h]
  _QWORD *v399; // [sp+F4h] [bp-250h]
  _QWORD *v400; // [sp+F8h] [bp-24Ch]
  _QWORD *v401; // [sp+F8h] [bp-24Ch]
  _QWORD *v402; // [sp+F8h] [bp-24Ch]
  int v403; // [sp+FCh] [bp-248h]
  _QWORD *v404; // [sp+FCh] [bp-248h]
  _QWORD *v405; // [sp+FCh] [bp-248h]
  char *v406; // [sp+100h] [bp-244h]
  int v407; // [sp+100h] [bp-244h]
  _QWORD *v408; // [sp+100h] [bp-244h]
  _QWORD *v409; // [sp+100h] [bp-244h]
  _QWORD *v410; // [sp+104h] [bp-240h]
  char *v411; // [sp+104h] [bp-240h]
  _QWORD *v412; // [sp+104h] [bp-240h]
  _QWORD *v413; // [sp+108h] [bp-23Ch]
  char *v414; // [sp+108h] [bp-23Ch]
  _QWORD *v415; // [sp+108h] [bp-23Ch]
  _QWORD *v416; // [sp+108h] [bp-23Ch]
  int v417; // [sp+10Ch] [bp-238h]
  _QWORD *v418; // [sp+10Ch] [bp-238h]
  _QWORD *v419; // [sp+10Ch] [bp-238h]
  char *v420; // [sp+110h] [bp-234h]
  char *v421; // [sp+110h] [bp-234h]
  _QWORD *v422; // [sp+110h] [bp-234h]
  int v423; // [sp+114h] [bp-230h]
  _QWORD *v424; // [sp+114h] [bp-230h]
  _QWORD *v425; // [sp+114h] [bp-230h]
  _QWORD *v426; // [sp+114h] [bp-230h]
  int v427; // [sp+118h] [bp-22Ch]
  _QWORD *v428; // [sp+118h] [bp-22Ch]
  _QWORD *v429; // [sp+118h] [bp-22Ch]
  char *v430; // [sp+11Ch] [bp-228h]
  char *v431; // [sp+11Ch] [bp-228h]
  _QWORD *v432; // [sp+11Ch] [bp-228h]
  _QWORD *v433; // [sp+120h] [bp-224h]
  int v434; // [sp+120h] [bp-224h]
  char *v435; // [sp+124h] [bp-220h]
  char *v436; // [sp+124h] [bp-220h]
  int v437; // [sp+128h] [bp-21Ch]
  _QWORD *v438; // [sp+128h] [bp-21Ch]
  _QWORD *v439; // [sp+12Ch] [bp-218h]
  char *v440; // [sp+12Ch] [bp-218h]
  char *v441; // [sp+130h] [bp-214h]
  _QWORD *v442; // [sp+134h] [bp-210h]
  char *v443; // [sp+134h] [bp-210h]
  int v444; // [sp+138h] [bp-20Ch]
  _QWORD *v445; // [sp+138h] [bp-20Ch]
  char *v446; // [sp+138h] [bp-20Ch]
  int v447; // [sp+13Ch] [bp-208h]
  _QWORD *v448; // [sp+13Ch] [bp-208h]
  char *v449; // [sp+13Ch] [bp-208h]
  char *v450; // [sp+140h] [bp-204h]
  char *v451; // [sp+140h] [bp-204h]
  char *v452; // [sp+144h] [bp-200h]
  char *v453; // [sp+144h] [bp-200h]
  int v454; // [sp+148h] [bp-1FCh]
  _QWORD *v455; // [sp+148h] [bp-1FCh]
  char *v456; // [sp+148h] [bp-1FCh]
  int v457; // [sp+14Ch] [bp-1F8h]
  _QWORD *v458; // [sp+14Ch] [bp-1F8h]
  char *v459; // [sp+14Ch] [bp-1F8h]
  _QWORD *v460; // [sp+150h] [bp-1F4h]
  char *v461; // [sp+150h] [bp-1F4h]
  unsigned int v462; // [sp+154h] [bp-1F0h]
  _QWORD *v463; // [sp+154h] [bp-1F0h]
  char *v464; // [sp+154h] [bp-1F0h]
  int v465; // [sp+158h] [bp-1ECh]
  _QWORD *v466; // [sp+158h] [bp-1ECh]
  unsigned int v467; // [sp+158h] [bp-1ECh]
  int v468; // [sp+158h] [bp-1ECh]
  _QWORD *v469; // [sp+158h] [bp-1ECh]
  int v470; // [sp+15Ch] [bp-1E8h]
  _QWORD *v471; // [sp+15Ch] [bp-1E8h]
  char *v472; // [sp+15Ch] [bp-1E8h]
  char *v473; // [sp+160h] [bp-1E4h]
  int v474; // [sp+160h] [bp-1E4h]
  int v475; // [sp+160h] [bp-1E4h]
  _QWORD *v476; // [sp+160h] [bp-1E4h]
  int v477; // [sp+164h] [bp-1E0h]
  char *v478; // [sp+164h] [bp-1E0h]
  unsigned int v479; // [sp+168h] [bp-1DCh]
  int v480; // [sp+168h] [bp-1DCh]
  int v481; // [sp+168h] [bp-1DCh]
  _QWORD *v482; // [sp+168h] [bp-1DCh]
  int v483; // [sp+16Ch] [bp-1D8h]
  int v484; // [sp+16Ch] [bp-1D8h]
  _QWORD *v485; // [sp+16Ch] [bp-1D8h]
  unsigned int v486; // [sp+170h] [bp-1D4h]
  int v487; // [sp+170h] [bp-1D4h]
  char *v488; // [sp+170h] [bp-1D4h]
  int v489; // [sp+174h] [bp-1D0h]
  int v490; // [sp+174h] [bp-1D0h]
  _QWORD *v491; // [sp+174h] [bp-1D0h]
  int v492; // [sp+178h] [bp-1CCh]
  int v493; // [sp+178h] [bp-1CCh]
  char *v494; // [sp+178h] [bp-1CCh]
  int v495; // [sp+17Ch] [bp-1C8h]
  int v496; // [sp+180h] [bp-1C4h]
  int v497; // [sp+180h] [bp-1C4h]
  int v498; // [sp+184h] [bp-1C0h]
  int v499; // [sp+188h] [bp-1BCh]
  int v500; // [sp+18Ch] [bp-1B8h]
  int v501; // [sp+190h] [bp-1B4h]
  unsigned int v502; // [sp+194h] [bp-1B0h]
  void *v504; // [sp+1B0h] [bp-194h] BYREF
  int v505; // [sp+1B4h] [bp-190h]
  _BYTE dest[128]; // [sp+1B8h] [bp-18Ch] BYREF
  _QWORD v507[16]; // [sp+238h] [bp-10Ch] BYREF
  char v508[140]; // [sp+2B8h] [bp-8Ch] BYREF

  v5 = *(_DWORD *)(a1 + 128);
  v504 = a4;
  v505 = a1 + 272;
  v6 = *(_QWORD *)(a1 + 264);
  v508[0] = (128 >> a3) | a2 & -(128 >> a3);
  if ( v5 > 0x77 )
  {
    v7 = 256 - v5;
    v8 = v6 + 2;
  }
  else
  {
    v7 = 128 - v5;
    v8 = v6 + 1;
  }
  memset(&v508[1], 0, v7 - 9);
  v508[v7 - 8] = HIBYTE(v8);
  v9 = v7;
  v10 = &v508[v7 - 8];
  v10[5] = BYTE2(v8);
  v10[6] = BYTE1(v8);
  v10[4] = BYTE3(v8);
  v10[1] = BYTE6(v8);
  v10[2] = BYTE5(v8);
  v10[3] = BYTE4(v8);
  v10[7] = v8;
  sph_groestl384_0(a1, v508, v9);
  memcpy(dest, (const void *)(a1 + 136), sizeof(dest));
  memcpy(v507, dest, sizeof(v507));
  v353 = v507[0];
  v286 = HIDWORD(v507[1]);
  v312 = v507[2];
  v348 = HIDWORD(v507[3]);
  v293 = v507[3];
  v303 = v507[4];
  v164 = 0;
  v318 = HIDWORD(v507[4]);
  v321 = HIDWORD(v507[5]);
  v280 = v507[5];
  v298 = HIDWORD(v507[6]);
  v266 = v507[6];
  v324 = HIDWORD(v507[7]);
  v227 = v507[7];
  v182 = v507[8];
  v11 = v507[14];
  v12 = v507[15];
  v326 = HIDWORD(v507[8]);
  v13 = HIDWORD(v507[15]);
  v328 = HIDWORD(v507[9]);
  v215 = v507[9];
  v221 = HIDWORD(v507[10]);
  v169 = v507[10];
  v231 = v507[11];
  v238 = v507[12];
  v246 = v507[13];
  v257 = HIDWORD(v507[14]);
  v308 = v507[1];
  do
  {
    v174 = v353 ^ v164;
    v271 = HIDWORD(v312) ^ ((unsigned __int64)(v164 + 32) >> 32);
    v186 = v348 ^ ((unsigned __int64)(v164 + 48) >> 32);
    v14 = v303 ^ (v164 + 64);
    v193 = v318 ^ ((unsigned __int64)(v164 + 64) >> 32);
    v275 = v280 ^ (v164 + 80);
    v165 = v321 ^ ((unsigned __int64)(v164 + 80) >> 32);
    v197 = v266 ^ (v164 + 96);
    v199 = ((unsigned __int64)(v164 + 96) >> 32) ^ v298;
    v203 = v227 ^ (v164 + 112);
    v208 = v324 ^ ((unsigned __int64)(v164 + 112) >> 32);
    v281 = v182 ^ (v164 + 128);
    v216 = v215 ^ (v164 + 144);
    v218 = v169 ^ (v164 + 160);
    v228 = v231 ^ (v164 + 176);
    v15 = HIDWORD(v231) ^ ((unsigned __int64)(v164 + 176) >> 32);
    v232 = v238 ^ (v164 + 192);
    v16 = HIDWORD(v238) ^ ((unsigned __int64)(v164 + 192) >> 32);
    v235 = v246 ^ (v164 + 208);
    v17 = HIDWORD(v246) ^ ((unsigned __int64)(v164 + 208) >> 32);
    v239 = (v164 + 224) ^ v11;
    v252 = ((unsigned __int64)(v164 + 240) >> 32) ^ v13;
    v242 = v257 ^ ((unsigned __int64)(v164 + 224) >> 32);
    v247 = (v164 + 240) ^ v12;
    v183 = v308 ^ (v164 + 16);
    v18 = (v164 + 32) ^ v312;
    v258 = v293 ^ (v164 + 48);
    v170 = v328 ^ ((unsigned __int64)(v164 + 144) >> 32);
    v222 = v221 ^ ((unsigned __int64)(v164 + 160) >> 32);
    v304 = HIBYTE(v17);
    v373 = v14;
    v299 = v17;
    v290 = v15;
    v331 = HIBYTE(v199);
    v336 = HIBYTE(v208);
    v462 = (unsigned int)(HIDWORD(v353) ^ HIDWORD(v164)) >> 24;
    v294 = v16;
    v343 = (v326 ^ ((unsigned __int64)(v164 + 128) >> 32)) >> 24;
    v16 >>= 24;
    v267 = v286 ^ ((unsigned __int64)(v164 + 16) >> 32);
    v479 = HIBYTE(v267);
    v486 = HIBYTE(v271);
    v329 = HIBYTE(v165);
    v19 = &dword_EF148[2 * HIBYTE(v15)];
    v332 = (char *)&unk_F0940 + 8 * HIBYTE(v14);
    v354 = (char *)&unk_F0940 + 8 * HIBYTE(v275);
    HIDWORD(v312) = *v19;
    v370 = (char *)&unk_F0940 + 8 * HIBYTE(v197);
    v386 = (char *)&unk_F0940 + 8 * HIBYTE(v203);
    v397 = (char *)&unk_F0940 + 8 * HIBYTE(v216);
    v262 = (char *)&unk_F0940 + 8 * HIBYTE(v281);
    v406 = (char *)&unk_F0940 + 8 * HIBYTE(v218);
    v420 = (char *)&unk_F0940 + 8 * HIBYTE(v228);
    v430 = (char *)&unk_F0940 + 8 * HIBYTE(v232);
    v450 = (char *)&unk_F0940 + 8 * HIBYTE(v247);
    v441 = (char *)&unk_F0940 + 8 * HIBYTE(v239);
    v435 = (char *)&unk_F0940 + 8 * HIBYTE(v235);
    v452 = (char *)&unk_F0940 + 8 * BYTE3(v174);
    v20 = &qword_F0150[BYTE2(v18)];
    v21 = &qword_EF950[BYTE1(v183)];
    v22 = &qword_F1150[(unsigned __int8)v193];
    v339 = &qword_F1150[(unsigned __int8)v165];
    v358 = &qword_F1150[(unsigned __int8)v199];
    v23 = HIDWORD(qword_EE948[(unsigned __int8)v174])
        ^ ((unsigned __int64)(v164 + 1) >> 32)
        ^ v19[1]
        ^ *((_DWORD *)v21 - 1)
        ^ *((_DWORD *)v20 - 1);
    v24 = (char *)&unk_F0940 + 8 * HIBYTE(v258);
    v25 = BYTE2(v208);
    v26 = LODWORD(qword_EE948[(unsigned __int8)v174]) ^ (v164 + 1) ^ HIDWORD(v312) ^ *((_DWORD *)v21 - 2);
    v366 = BYTE2(v165);
    v27 = &qword_EF950[BYTE1(v18)];
    v28 = v26 ^ *((_DWORD *)v20 - 2);
    v29 = &qword_F0150[BYTE2(v258)];
    v417 = (unsigned __int8)((v164 + 32) ^ v312);
    v473 = (char *)&unk_F0940 + 8 * HIBYTE(v18);
    v309 = BYTE1(v208);
    v209 = &qword_F1150[(unsigned __int8)(v324 ^ ((unsigned __int64)(v164 + 112) >> 32))];
    v287 = (unsigned __int8)((v326 ^ ((unsigned __int64)(v164 + 128) >> 32)) >> 16);
    v315 = (unsigned __int8)((unsigned __int16)(v326 ^ ((unsigned __int64)(v164 + 128) >> 32)) >> 8);
    v391 = &qword_F1150[(unsigned __int8)(v326 ^ ((unsigned __int64)(v164 + 128) >> 32))];
    v423 = (unsigned __int8)v258;
    v403 = dword_F1948[2 * BYTE1(v199) + 1];
    v349 = &qword_EF950[BYTE1(v258)];
    v259 = dword_F1948[2 * BYTE1(v199)];
    v30 = v23
        ^ *((_DWORD *)v24 + 3)
        ^ *((_DWORD *)v22 - 1)
        ^ dword_F1948[2 * BYTE1(v165) + 1]
        ^ dword_F2148[2 * BYTE2(v199) + 1];
    v166 = v28
         ^ *((_DWORD *)v24 + 2)
         ^ *((_DWORD *)v22 - 2)
         ^ dword_F1948[2 * BYTE1(v165)]
         ^ dword_F2148[2 * BYTE2(v199)];
    v31 = *((_DWORD *)v339 - 2);
    v200 = v30;
    v32 = *((_DWORD *)v339 - 1);
    v33 = *((_DWORD *)v332 + 2);
    v34 = *((_DWORD *)v332 + 3);
    v35 = &qword_F0150[BYTE2(v373)];
    v454 = (unsigned __int8)v373;
    v333 = &qword_EF950[BYTE1(v373)];
    v340 = &qword_F0150[BYTE2(v275)];
    v465 = (unsigned __int8)v275;
    v374 = &qword_EF950[BYTE1(v275)];
    v380 = &qword_F0150[BYTE2(v197)];
    v457 = BYTE1(v170);
    v276 = *((_DWORD *)v358 - 2);
    v36 = v31
        ^ v33
        ^ LODWORD(qword_EE948[(unsigned __int8)v183])
        ^ dword_EF148[2 * v16]
        ^ (v164 + 17)
        ^ *((_DWORD *)v27 - 2)
        ^ *((_DWORD *)v29 - 2)
        ^ v259;
    v427 = *((_DWORD *)v209 - 2);
    v260 = v403
         ^ v32
         ^ v34
         ^ HIDWORD(qword_EE948[(unsigned __int8)v183])
         ^ dword_EF148[2 * v16 + 1]
         ^ ((unsigned __int64)(v164 + 17) >> 32)
         ^ *((_DWORD *)v27 - 1)
         ^ *((_DWORD *)v29 - 1)
         ^ dword_F2148[2 * v25 + 1];
    v437 = *((_DWORD *)v209 - 1);
    v210 = v36 ^ dword_F2148[2 * v25];
    v447 = dword_F2148[2 * BYTE2(v170) + 1];
    v319 = *((_DWORD *)v370 + 3);
    v37 = *((_DWORD *)v370 + 2);
    v477 = (unsigned __int8)v197;
    v444 = dword_F2148[2 * BYTE2(v170)];
    v38 = &qword_EF950[BYTE1(v197)];
    v39 = LODWORD(qword_EE948[v423]) ^ dword_EF148[2 * HIBYTE(v242)];
    v40 = dword_EF148[2 * HIBYTE(v242) + 1] ^ HIDWORD(qword_EE948[v423]) ^ ((unsigned __int64)(v164 + 49) >> 32);
    v41 = LODWORD(qword_EE948[v417])
        ^ dword_EF148[2 * v304]
        ^ (v164 + 33)
        ^ *((_DWORD *)v349 - 2)
        ^ *((_DWORD *)v35 - 2)
        ^ *((_DWORD *)v354 + 2);
    v345 = &qword_F0150[BYTE2(v203)];
    v42 = HIDWORD(qword_EE948[v417])
        ^ dword_EF148[2 * v304 + 1]
        ^ ((unsigned __int64)(v164 + 33) >> 32)
        ^ *((_DWORD *)v349 - 1)
        ^ *((_DWORD *)v35 - 1)
        ^ *((_DWORD *)v354 + 3)
        ^ *((_DWORD *)v358 - 1);
    v355 = &qword_F1150[(unsigned __int8)v170];
    v359 = HIBYTE(v170);
    v470 = BYTE1(v222);
    v483 = (unsigned __int8)v203;
    v371 = &qword_EF950[BYTE1(v203)];
    v395 = &qword_F0150[BYTE2(v281)];
    v361 = HIBYTE(v222);
    v43 = &qword_F1150[(unsigned __int8)v222];
    v44 = v41 ^ v276;
    v277 = (unsigned __int8)v281;
    v400 = &qword_EF950[BYTE1(v281)];
    v410 = &qword_F1150[(unsigned __int8)v290];
    v404 = &qword_F0150[BYTE2(v216)];
    v45 = BYTE2(v294);
    v489 = BYTE1(v294);
    v198 = v42 ^ dword_F1948[2 * v309 + 1] ^ dword_F2148[2 * v287 + 1];
    v424 = &qword_F1150[(unsigned __int8)v294];
    v492 = BYTE2(v299);
    v295 = (unsigned __int8)v216;
    v413 = &qword_EF950[BYTE1(v216)];
    v171 = v44 ^ dword_F1948[2 * v309] ^ dword_F2148[2 * v287];
    v418 = &qword_F0150[BYTE2(v218)];
    v282 = BYTE1(v299);
    v433 = &qword_F1150[(unsigned __int8)v299];
    v288 = BYTE2(v242);
    v204 = v39 ^ (v164 + 49) ^ *((_DWORD *)v333 - 2) ^ *((_DWORD *)v340 - 2) ^ v37 ^ v427 ^ dword_F1948[2 * v315] ^ v444;
    v217 = v40 ^ *((_DWORD *)v333 - 1) ^ *((_DWORD *)v340 - 1) ^ v319 ^ v437 ^ dword_F1948[2 * v315 + 1] ^ v447;
    v310 = (unsigned __int8)v218;
    v428 = &qword_EF950[BYTE1(v218)];
    v46 = *((_DWORD *)v374 - 1)
        ^ dword_EF148[2 * HIBYTE(v252) + 1]
        ^ HIDWORD(qword_EE948[v454])
        ^ ((unsigned __int64)(v164 + 65) >> 32);
    v47 = LODWORD(qword_EE948[v454]) ^ dword_EF148[2 * HIBYTE(v252)] ^ (v164 + 65) ^ *((_DWORD *)v374 - 2);
    v375 = &qword_F0150[BYTE2(v228)];
    v48 = (unsigned __int8)v242;
    v243 = BYTE1(v242);
    v438 = &qword_F1150[v48];
    v49 = v46 ^ *((_DWORD *)v380 - 1);
    v300 = BYTE2(v252);
    v50 = v47 ^ *((_DWORD *)v380 - 2);
    v305 = BYTE6(v174);
    v320 = (unsigned __int8)v228;
    v381 = &qword_EF950[BYTE1(v228)];
    v51 = *((_DWORD *)v386 + 2);
    v52 = v49 ^ *((_DWORD *)v386 + 3);
    v387 = &qword_F0150[BYTE2(v232)];
    v313 = BYTE1(v252);
    v442 = &qword_F1150[(unsigned __int8)v252];
    v53 = *((_DWORD *)v391 - 1) ^ v52 ^ dword_F1948[2 * v457 + 1];
    v316 = BYTE5(v174);
    v54 = *((_DWORD *)v391 - 2) ^ v50 ^ v51 ^ dword_F1948[2 * v457] ^ dword_F2148[2 * BYTE2(v222)];
    v253 = &qword_F1150[BYTE4(v174)];
    v334 = (unsigned __int8)v232;
    v392 = &qword_EF950[BYTE1(v232)];
    v219 = v53 ^ dword_F2148[2 * BYTE2(v222) + 1];
    v439 = &qword_F0150[BYTE2(v235)];
    v322 = BYTE2(v267);
    v179 = v54;
    v55 = dword_EF148[2 * v462] ^ (v164 + 81) ^ LODWORD(qword_EE948[v465]) ^ *((_DWORD *)v38 - 2);
    v56 = dword_EF148[2 * v462 + 1]
        ^ ((unsigned __int64)(v164 + 81) >> 32)
        ^ HIDWORD(qword_EE948[v465])
        ^ *((_DWORD *)v38 - 1);
    v341 = BYTE1(v267);
    v57 = *((_DWORD *)v345 - 1);
    v460 = &qword_F1150[(unsigned __int8)v267];
    LOWORD(v38) = v271;
    v58 = v55 ^ *((_DWORD *)v345 - 2);
    v272 = BYTE2(v271);
    v346 = BYTE1(v38);
    v268 = &qword_F1150[(unsigned __int8)v38];
    v59 = v56 ^ v57 ^ *((_DWORD *)v262 + 3);
    v60 = v58 ^ *((_DWORD *)v262 + 2);
    v350 = BYTE2(v186);
    v263 = (unsigned __int8)v235;
    v445 = &qword_EF950[BYTE1(v235)];
    v61 = v59 ^ *((_DWORD *)v355 - 1);
    v62 = v60 ^ *((_DWORD *)v355 - 2);
    v448 = &qword_F0150[BYTE2(v239)];
    v356 = (unsigned __int8)v239;
    v455 = &qword_EF950[BYTE1(v239)];
    v223 = dword_F1948[2 * BYTE1(v222) + 1] ^ v61 ^ dword_F2148[2 * BYTE2(v290) + 1];
    v458 = &qword_F0150[BYTE2(v247)];
    v463 = &qword_F0150[BYTE2(v174)];
    v63 = v62 ^ dword_F1948[2 * v470] ^ dword_F2148[2 * BYTE2(v290)];
    v471 = &qword_EF950[BYTE1(v174)];
    v175 = v63;
    v466 = &qword_EF950[BYTE1(v247)];
    v229 = LODWORD(qword_EE948[v477])
         ^ dword_EF148[2 * v479]
         ^ (v164 + 97)
         ^ *((_DWORD *)v371 - 2)
         ^ *((_DWORD *)v395 - 2)
         ^ *((_DWORD *)v397 + 2)
         ^ *((_DWORD *)v43 - 2)
         ^ dword_F1948[2 * BYTE1(v290)]
         ^ dword_F2148[2 * v45];
    v64 = LODWORD(qword_EE948[v483]) ^ dword_EF148[2 * v486];
    v291 = HIDWORD(qword_EE948[v477])
         ^ dword_EF148[2 * v479 + 1]
         ^ ((unsigned __int64)(v164 + 97) >> 32)
         ^ *((_DWORD *)v371 - 1)
         ^ *((_DWORD *)v395 - 1)
         ^ *((_DWORD *)v397 + 3)
         ^ *((_DWORD *)v43 - 1)
         ^ dword_F1948[2 * BYTE1(v290) + 1]
         ^ dword_F2148[2 * v45 + 1];
    v236 = HIDWORD(qword_EE948[v483])
         ^ dword_EF148[2 * v486 + 1]
         ^ ((unsigned __int64)(v164 + 113) >> 32)
         ^ *((_DWORD *)v400 - 1)
         ^ *((_DWORD *)v404 - 1)
         ^ *((_DWORD *)v406 + 3)
         ^ *((_DWORD *)v410 - 1)
         ^ dword_F1948[2 * v489 + 1]
         ^ dword_F2148[2 * v492 + 1];
    v487 = dword_F1948[2 * v243 + 1];
    v233 = v64
         ^ (v164 + 113)
         ^ *((_DWORD *)v400 - 2)
         ^ *((_DWORD *)v404 - 2)
         ^ *((_DWORD *)v406 + 2)
         ^ *((_DWORD *)v410 - 2)
         ^ dword_F1948[2 * v489]
         ^ dword_F2148[2 * v492];
    v484 = dword_F1948[2 * v243];
    v490 = dword_F2148[2 * v300];
    v493 = dword_F2148[2 * v300 + 1];
    v65 = *((_DWORD *)v420 + 3)
        ^ HIDWORD(qword_EE948[v277])
        ^ dword_EF148[2 * HIBYTE(v186) + 1]
        ^ ((unsigned __int64)(v164 + 129) >> 32)
        ^ *((_DWORD *)v413 - 1)
        ^ *((_DWORD *)v418 - 1);
    v66 = *((_DWORD *)v418 - 2)
        ^ LODWORD(qword_EE948[v277])
        ^ dword_EF148[2 * HIBYTE(v186)]
        ^ (v164 + 129)
        ^ *((_DWORD *)v413 - 2)
        ^ *((_DWORD *)v420 + 2);
    v414 = (char *)&dword_F2148[2 * BYTE2(v186)];
    v240 = v66 ^ *((_DWORD *)v424 - 2) ^ dword_F1948[2 * v282] ^ dword_F2148[2 * v288];
    v244 = v65 ^ *((_DWORD *)v424 - 1) ^ dword_F1948[2 * v282 + 1] ^ dword_F2148[2 * v288 + 1];
    v67 = dword_F2148[2 * v305];
    v68 = *((_DWORD *)v375 - 2)
        ^ dword_EF148[2 * HIBYTE(v193)]
        ^ LODWORD(qword_EE948[v295])
        ^ (v164 + 145)
        ^ *((_DWORD *)v428 - 2)
        ^ *((_DWORD *)v430 + 2)
        ^ *((_DWORD *)v433 - 2);
    v69 = (char *)&dword_F2148[2 * v305];
    v306 = *((_DWORD *)v375 - 1)
         ^ dword_EF148[2 * HIBYTE(v193) + 1]
         ^ HIDWORD(qword_EE948[v295])
         ^ ((unsigned __int64)(v164 + 145) >> 32)
         ^ *((_DWORD *)v428 - 1)
         ^ *((_DWORD *)v430 + 3)
         ^ *((_DWORD *)v433 - 1);
    v70 = dword_EF148[2 * v329 + 1];
    v71 = dword_EF148[2 * v329];
    v330 = dword_F1948[2 * v313];
    v376 = dword_F1948[2 * v313 + 1];
    v72 = v67 ^ LODWORD(qword_EE948[v310]) ^ (v164 + 161) ^ v71;
    v301 = *((_DWORD *)v69 + 1) ^ HIDWORD(qword_EE948[v310]) ^ (__CFADD__((_DWORD)v164, 161) + HIDWORD(v164)) ^ v70;
    v296 = &qword_F0150[BYTE2(v183)];
    v283 = (char *)&unk_F0940 + 8 * HIBYTE(v183);
    v73 = *((_DWORD *)v253 - 2);
    v74 = (unsigned __int8)v186;
    v187 = BYTE1(v186);
    v75 = *((_DWORD *)v253 - 1);
    v184 = &qword_F1150[v74];
    v76 = dword_F2148[2 * v272];
    v314 = v301 ^ *((_DWORD *)v381 - 1) ^ *((_DWORD *)v387 - 1) ^ *((_DWORD *)v435 + 3);
    v254 = &dword_F2148[2 * BYTE2(v193)];
    v77 = qword_EE948[v263];
    v78 = HIDWORD(qword_EE948[v263]);
    v327 = HIDWORD(qword_EE948[v334])
         ^ v75
         ^ ((unsigned __int64)(v164 + 193) >> 32)
         ^ dword_EF148[2 * v336 + 1]
         ^ *((_DWORD *)v445 - 1)
         ^ *((_DWORD *)v448 - 1)
         ^ *((_DWORD *)v450 + 3);
    v264 = LODWORD(qword_EE948[v334])
         ^ v73
         ^ (v164 + 193)
         ^ dword_EF148[2 * v336]
         ^ *((_DWORD *)v445 - 2)
         ^ *((_DWORD *)v448 - 2);
    v79 = *((_DWORD *)v452 + 3) ^ v78;
    v80 = HIDWORD(qword_EE948[(unsigned __int8)v247]) ^ *((_DWORD *)v471 - 1) ^ ((unsigned __int64)(v164 + 241) >> 32);
    v278 = *((_DWORD *)v283 + 3);
    v81 = *((_DWORD *)v463 - 2)
        ^ LODWORD(qword_EE948[v356])
        ^ (v164 + 225)
        ^ dword_EF148[2 * v359]
        ^ *((_DWORD *)v466 - 2)
        ^ *((_DWORD *)v283 + 2);
    v82 = *((_DWORD *)v184 - 1);
    v83 = dword_F1948[2 * v187 + 1];
    v284 = *((_DWORD *)v268 - 1);
    v84 = v81 ^ *((_DWORD *)v268 - 2) ^ dword_F1948[2 * v187];
    v188 = dword_F1948[2 * BYTE1(v193) + 1];
    v85 = *((_DWORD *)v471 - 2)
        ^ LODWORD(qword_EE948[(unsigned __int8)v247])
        ^ (v164 + 241)
        ^ dword_EF148[2 * v361]
        ^ *((_DWORD *)v296 - 2)
        ^ *((_DWORD *)v473 + 2)
        ^ *((_DWORD *)v184 - 2)
        ^ dword_F1948[2 * BYTE1(v193)];
    v269 = v254[1];
    v86 = *v254;
    v248 = HIDWORD(qword_EE948[v356])
         ^ *((_DWORD *)v463 - 1)
         ^ ((unsigned __int64)(v164 + 225) >> 32)
         ^ dword_EF148[2 * v359 + 1]
         ^ *((_DWORD *)v466 - 1)
         ^ v278
         ^ v284
         ^ v83;
    v185 = v68 ^ v484 ^ v490;
    v194 = v72 ^ *((_DWORD *)v381 - 2) ^ *((_DWORD *)v387 - 2) ^ *((_DWORD *)v435 + 2) ^ *((_DWORD *)v438 - 2) ^ v330;
    v255 = LODWORD(qword_EE948[v320])
         ^ dword_F1948[2 * v316]
         ^ (v164 + 177)
         ^ dword_EF148[2 * v331]
         ^ *((_DWORD *)v392 - 2)
         ^ *((_DWORD *)v439 - 2)
         ^ *((_DWORD *)v441 + 2)
         ^ *((_DWORD *)v442 - 2)
         ^ dword_F2148[2 * v322];
    v467 = v327 ^ dword_F1948[2 * v341 + 1] ^ dword_F2148[2 * v272 + 1];
    v273 = v79
         ^ ((unsigned __int64)(v164 + 209) >> 32)
         ^ dword_EF148[2 * v343 + 1]
         ^ *((_DWORD *)v455 - 1)
         ^ *((_DWORD *)v458 - 1)
         ^ *((_DWORD *)v460 - 1)
         ^ dword_F1948[2 * v346 + 1]
         ^ *((_DWORD *)v414 + 1);
    v302 = v84 ^ v86;
    v285 = v80
         ^ dword_EF148[2 * v361 + 1]
         ^ *((_DWORD *)v296 - 1)
         ^ *((_DWORD *)v473 + 3)
         ^ v82
         ^ v188
         ^ dword_F2148[2 * v366 + 1];
    v87 = v248 ^ v269;
    v265 = v264 ^ *((_DWORD *)v450 + 2) ^ dword_F1948[2 * v341] ^ v76;
    v270 = v77
         ^ *((_DWORD *)v452 + 2)
         ^ (v164 + 209)
         ^ dword_EF148[2 * v343]
         ^ *((_DWORD *)v455 - 2)
         ^ *((_DWORD *)v458 - 2)
         ^ *((_DWORD *)v460 - 2)
         ^ dword_F1948[2 * v346]
         ^ dword_F2148[2 * v350];
    v279 = v85 ^ dword_F2148[2 * v366];
    v189 = v306 ^ v487 ^ v493;
    v249 = v314 ^ *((_DWORD *)v438 - 1) ^ v376;
    v297 = dword_F1948[2 * v316 + 1]
         ^ HIDWORD(qword_EE948[v320])
         ^ ((unsigned __int64)(v164 + 177) >> 32)
         ^ dword_EF148[2 * v331 + 1]
         ^ *((_DWORD *)v392 - 1)
         ^ *((_DWORD *)v439 - 1)
         ^ *((_DWORD *)v441 + 3)
         ^ *((_DWORD *)v442 - 1)
         ^ dword_F2148[2 * v322 + 1];
    v337 = HIBYTE(v291);
    v317 = HIBYTE(v87);
    v307 = v87;
    v342 = HIBYTE(v236);
    v344 = HIBYTE(v244);
    v335 = HIBYTE(v223);
    v347 = HIBYTE(v189);
    v362 = (char *)&unk_F0940 + 8 * HIBYTE(v179);
    v398 = (char *)&unk_F0940 + 8 * HIBYTE(v229);
    v351 = (char *)&unk_F0940 + 8 * HIBYTE(v204);
    v421 = (char *)&unk_F0940 + 8 * HIBYTE(v240);
    v367 = (char *)&unk_F0940 + 8 * HIBYTE(v175);
    v393 = (char *)&dword_EF148[2 * HIBYTE(v87)];
    v431 = (char *)&unk_F0940 + 8 * HIBYTE(v185);
    v411 = (char *)&unk_F0940 + 8 * HIBYTE(v233);
    v436 = (char *)&unk_F0940 + 8 * HIBYTE(v194);
    v443 = (char *)&unk_F0940 + 8 * HIBYTE(v265);
    v440 = (char *)&unk_F0940 + 8 * HIBYTE(v255);
    v502 = HIBYTE(v249);
    v449 = (char *)&unk_F0940 + 8 * HIBYTE(v270);
    v459 = (char *)&unk_F0940 + 8 * HIBYTE(v279);
    v456 = (char *)&dword_EF148[2 * HIBYTE(v236)];
    v451 = (char *)&dword_EF148[2 * HIBYTE(v291)];
    v453 = (char *)&unk_F0940 + 8 * HIBYTE(v302);
    v464 = (char *)&dword_EF148[2 * HIBYTE(v244)];
    v472 = (char *)&dword_EF148[2 * HIBYTE(v189)];
    v488 = (char *)&dword_EF148[2 * HIBYTE(v249)];
    v446 = (char *)&dword_EF148[2 * HIBYTE(v223)];
    v461 = (char *)&unk_F0940 + 8 * HIBYTE(v166);
    v494 = (char *)&unk_F0940 + 8 * HIBYTE(v171);
    v478 = (char *)&unk_F0940 + 8 * HIBYTE(v210);
    v88 = &qword_F1150[(unsigned __int8)v219];
    v89 = &qword_EF950[BYTE1(v210)];
    v90 = BYTE2(v291);
    v382 = BYTE1(v291);
    v388 = &qword_F1150[(unsigned __int8)v291];
    v360 = *((_DWORD *)v88 - 2);
    v407 = *((_DWORD *)v88 - 1);
    v164 += 2;
    v91 = &dword_EF148[2 * HIBYTE(v297)];
    v92 = *v91;
    v93 = v91[1];
    v94 = v92 ^ dword_F1948[2 * BYTE1(v223)];
    v95 = HIDWORD(v164) == 0;
    v96 = v210;
    if ( !HIDWORD(v164) )
      v95 = (_DWORD)v164 == 14;
    v97 = v93 ^ dword_F1948[2 * BYTE1(v223) + 1] ^ HIDWORD(qword_EE948[(unsigned __int8)v166]);
    v491 = &qword_F0150[BYTE2(v210)];
    v292 = BYTE2(v223);
    v98 = &qword_F1150[(unsigned __int8)v223];
    v99 = &qword_EF950[BYTE1(v171)];
    v311 = &qword_F0150[BYTE2(v204)];
    v100 = dword_F2148[2 * v90 + 1];
    v357 = dword_F2148[2 * v90];
    v224 = (unsigned __int8)v204;
    v101 = *((_DWORD *)v89 - 1);
    v377 = &qword_EF950[BYTE1(v204)];
    v102 = v94 ^ LODWORD(qword_EE948[(unsigned __int8)v166]) ^ *((_DWORD *)v89 - 2);
    v103 = &qword_F0150[BYTE2(v171)];
    v480 = dword_F1948[2 * v382];
    v289 = dword_F1948[2 * v382 + 1];
    v383 = &qword_F0150[BYTE2(v179)];
    v104 = v97 ^ v101 ^ *((_DWORD *)v103 - 1) ^ *((_DWORD *)v351 + 3);
    v105 = *((_DWORD *)v351 + 2) ^ *((_DWORD *)v103 - 2) ^ v102;
    v205 = BYTE1(v236);
    v401 = &qword_F1150[(unsigned __int8)v236];
    v106 = qword_EE948[(unsigned __int8)v210];
    v211 = BYTE2(v244);
    v107 = &qword_EF950[BYTE1(v179)];
    v108 = dword_F2148[2 * BYTE2(v236)];
    v109 = v105 ^ v360;
    v110 = dword_F2148[2 * BYTE2(v236) + 1];
    HIDWORD(v353) = v104 ^ v407 ^ v100;
    v352 = &qword_F0150[BYTE2(v175)];
    v111 = BYTE1(v244);
    v415 = &qword_F1150[(unsigned __int8)v244];
    v112 = BYTE2(v189);
    LODWORD(v353) = v109 ^ v357;
    v237 = (unsigned __int8)v175;
    v245 = &qword_EF950[BYTE1(v175)];
    v408 = &qword_F0150[BYTE2(v229)];
    v176 = BYTE1(v189);
    v425 = &qword_F1150[(unsigned __int8)v189];
    v190 = BYTE2(v249);
    v286 = *((_DWORD *)v99 - 1)
         ^ HIDWORD(qword_EE948[v96])
         ^ *((_DWORD *)v98 - 1)
         ^ dword_EF148[2 * HIBYTE(v467) + 1]
         ^ *((_DWORD *)v311 - 1)
         ^ *((_DWORD *)v362 + 3)
         ^ v289
         ^ v110;
    v308 = *((_DWORD *)v99 - 2)
         ^ v106
         ^ *((_DWORD *)v98 - 2)
         ^ dword_EF148[2 * HIBYTE(v467)]
         ^ *((_DWORD *)v311 - 2)
         ^ *((_DWORD *)v362 + 2)
         ^ v480
         ^ v108;
    v113 = dword_F1948[2 * v205];
    v114 = *((_DWORD *)v383 - 2)
         ^ LODWORD(qword_EE948[(unsigned __int8)v171])
         ^ *((_DWORD *)v367 + 2)
         ^ dword_EF148[2 * HIBYTE(v273)]
         ^ *((_DWORD *)v377 - 2);
    v115 = dword_F1948[2 * v111 + 1];
    v116 = HIDWORD(qword_EE948[(unsigned __int8)v171])
         ^ *((_DWORD *)v367 + 3)
         ^ dword_EF148[2 * HIBYTE(v273) + 1]
         ^ *((_DWORD *)v377 - 1)
         ^ *((_DWORD *)v383 - 1)
         ^ *((_DWORD *)v388 - 1)
         ^ dword_F1948[2 * v205 + 1];
    v474 = dword_F1948[2 * v111];
    v206 = (unsigned __int8)v229;
    v117 = dword_EF148[2 * v317];
    v363 = &qword_EF950[BYTE1(v229)];
    v368 = &qword_F0150[BYTE2(v233)];
    v172 = BYTE1(v249);
    v378 = &qword_F1150[(unsigned __int8)v249];
    LODWORD(v312) = v114 ^ *((_DWORD *)v388 - 2) ^ v113 ^ dword_F2148[2 * v211];
    v496 = BYTE2(v297);
    HIDWORD(v312) = v116 ^ dword_F2148[2 * v211 + 1];
    v118 = *((_DWORD *)v401 - 2);
    v498 = (unsigned __int8)v233;
    v250 = &qword_EF950[BYTE1(v233)];
    v372 = &qword_F0150[BYTE2(v240)];
    v119 = *((_DWORD *)v352 - 2) ^ LODWORD(qword_EE948[v224]) ^ v117 ^ *((_DWORD *)v107 - 2) ^ *((_DWORD *)v398 + 2);
    v120 = *((_DWORD *)v352 - 1) ^ HIDWORD(qword_EE948[v224]) ^ *((_DWORD *)v393 + 1);
    v212 = BYTE1(v297);
    v225 = BYTE2(v467);
    v121 = v120 ^ *((_DWORD *)v107 - 1) ^ *((_DWORD *)v398 + 3) ^ *((_DWORD *)v401 - 1);
    v394 = &qword_F1150[(unsigned __int8)v297];
    v230 = (unsigned __int8)v240;
    v384 = &qword_EF950[BYTE1(v240)];
    v402 = &qword_F1150[(unsigned __int8)v467];
    v389 = &qword_F0150[BYTE2(v185)];
    v499 = BYTE1(v467);
    v500 = BYTE2(v273);
    v396 = &qword_EF950[BYTE1(v185)];
    v399 = &qword_F0150[BYTE2(v194)];
    v348 = v121 ^ v115 ^ dword_F2148[2 * v112 + 1];
    v293 = v119 ^ v118 ^ v474 ^ dword_F2148[2 * v112];
    v122 = dword_F2148[2 * v190 + 1];
    v123 = dword_F1948[2 * v176 + 1];
    v124 = dword_F1948[2 * v176];
    v125 = dword_F2148[2 * v190];
    v126 = *((_DWORD *)v411 + 3)
         ^ HIDWORD(qword_EE948[(unsigned __int8)v179])
         ^ *((_DWORD *)v245 - 1)
         ^ dword_EF148[2 * HIBYTE(v285) + 1]
         ^ *((_DWORD *)v408 - 1);
    v127 = LODWORD(qword_EE948[(unsigned __int8)v179])
         ^ *((_DWORD *)v245 - 2)
         ^ dword_EF148[2 * HIBYTE(v285)]
         ^ *((_DWORD *)v408 - 2)
         ^ *((_DWORD *)v411 + 2);
    v468 = dword_F1948[2 * v172 + 1];
    v323 = dword_F1948[2 * v172];
    v177 = BYTE1(v273);
    v409 = &qword_F1150[(unsigned __int8)v273];
    v180 = BYTE2(v307);
    v475 = dword_F2148[2 * v496];
    v234 = (unsigned __int8)v194;
    v481 = dword_F2148[2 * v496 + 1];
    v274 = &qword_EF950[BYTE1(v194)];
    v405 = &qword_F0150[BYTE2(v255)];
    v191 = BYTE1(v307);
    v412 = &qword_F1150[(unsigned __int8)v307];
    v501 = BYTE2(v285);
    v195 = BYTE2(v200);
    v303 = v127 ^ *((_DWORD *)v415 - 2) ^ v124 ^ v125;
    v318 = v123 ^ v126 ^ *((_DWORD *)v415 - 1) ^ v122;
    v128 = *(v363 - 1);
    v129 = HIDWORD(qword_EE948[v237])
         ^ dword_EF148[2 * HIBYTE(v200) + 1]
         ^ HIDWORD(v128)
         ^ *((_DWORD *)v368 - 1)
         ^ *((_DWORD *)v421 + 3);
    v130 = LODWORD(qword_EE948[v237])
         ^ dword_EF148[2 * HIBYTE(v200)]
         ^ v128
         ^ *((_DWORD *)v368 - 2)
         ^ *((_DWORD *)v421 + 2)
         ^ *((_DWORD *)v425 - 2);
    v131 = dword_F1948[2 * v212 + 1];
    LODWORD(v128) = LODWORD(qword_EE948[v206]) ^ dword_EF148[2 * HIBYTE(v260)];
    v325 = dword_F1948[2 * v212];
    v132 = HIDWORD(qword_EE948[v206]) ^ dword_EF148[2 * HIBYTE(v260) + 1];
    v497 = dword_F2148[2 * v225 + 1];
    v495 = dword_F2148[2 * v225];
    v213 = (unsigned __int8)v255;
    v364 = &qword_EF950[BYTE1(v255)];
    v369 = &qword_F0150[BYTE2(v265)];
    v207 = BYTE1(v285);
    v422 = &qword_F1150[(unsigned __int8)v285];
    HIDWORD(v128) = &qword_F1150[(unsigned __int8)v200];
    v201 = BYTE1(v200);
    v173 = HIDWORD(v128);
    v416 = &qword_EF950[BYTE1(v265)];
    v419 = &qword_F0150[BYTE2(v270)];
    v226 = BYTE2(v260);
    v133 = v130 ^ v323;
    v321 = v129 ^ *((_DWORD *)v425 - 1) ^ v468 ^ v481;
    v134 = *((_DWORD *)v250 - 2);
    v280 = v133 ^ v475;
    v426 = &qword_EF950[BYTE1(v270)];
    v135 = *((_DWORD *)v250 - 1) ^ v132;
    v251 = (unsigned __int8)v270;
    v429 = &qword_F0150[BYTE2(v302)];
    v241 = BYTE1(v260);
    v136 = v134 ^ v128 ^ *((_DWORD *)v372 - 2);
    LODWORD(v128) = &qword_F1150[(unsigned __int8)v260];
    v261 = (unsigned __int8)v302;
    v434 = v128;
    LODWORD(v128) = *((_DWORD *)v431 + 2);
    v137 = v135 ^ *((_DWORD *)v372 - 1) ^ *((_DWORD *)v431 + 3);
    v432 = &qword_EF950[BYTE1(v302)];
    v138 = v136 ^ v128 ^ *((_DWORD *)v378 - 2);
    v139 = v137 ^ *((_DWORD *)v378 - 1) ^ v131;
    v379 = &qword_F0150[BYTE2(v279)];
    v482 = &qword_F1150[(unsigned __int8)v198];
    v256 = BYTE2(v217);
    v469 = &qword_F0150[BYTE2(v166)];
    v485 = &qword_EF950[BYTE1(v166)];
    v298 = v139 ^ v497;
    v266 = v138 ^ v325 ^ v495;
    v476 = &qword_EF950[BYTE1(v279)];
    v140 = HIDWORD(qword_EE948[v230]) ^ dword_EF148[2 * HIBYTE(v217) + 1];
    v141 = LODWORD(qword_EE948[v230]) ^ dword_EF148[2 * HIBYTE(v217)];
    v324 = HIDWORD(qword_EE948[v498])
         ^ dword_EF148[2 * HIBYTE(v198) + 1]
         ^ *((_DWORD *)v384 - 1)
         ^ *((_DWORD *)v389 - 1)
         ^ *((_DWORD *)v436 + 3)
         ^ *((_DWORD *)v394 - 1)
         ^ dword_F1948[2 * v499 + 1]
         ^ dword_F2148[2 * v500 + 1];
    v227 = *((_DWORD *)v384 - 2)
         ^ LODWORD(qword_EE948[v498])
         ^ dword_EF148[2 * HIBYTE(v198)]
         ^ *((_DWORD *)v389 - 2)
         ^ *((_DWORD *)v436 + 2)
         ^ *((_DWORD *)v394 - 2)
         ^ dword_F1948[2 * v499]
         ^ dword_F2148[2 * v500];
    LODWORD(v128) = HIDWORD(qword_EE948[(unsigned __int8)v185]) ^ dword_EF148[2 * HIBYTE(v219) + 1];
    HIDWORD(v128) = qword_EE948[(unsigned __int8)v185];
    v167 = (char *)&dword_F1948[2 * v201];
    v385 = &dword_F1948[2 * BYTE1(v198)];
    v326 = *((_DWORD *)v399 - 1)
         ^ *((_DWORD *)v396 - 1)
         ^ v140
         ^ *((_DWORD *)v440 + 3)
         ^ *((_DWORD *)v402 - 1)
         ^ dword_F1948[2 * v177 + 1]
         ^ dword_F2148[2 * v180 + 1];
    v390 = (char *)&dword_F2148[2 * BYTE2(v217)];
    v182 = *((_DWORD *)v396 - 2)
         ^ v141
         ^ *((_DWORD *)v399 - 2)
         ^ *((_DWORD *)v440 + 2)
         ^ *((_DWORD *)v402 - 2)
         ^ dword_F1948[2 * v177]
         ^ dword_F2148[2 * v180];
    v142 = *(v409 - 1);
    v143 = *((_DWORD *)v405 - 2)
         ^ HIDWORD(v128)
         ^ dword_EF148[2 * HIBYTE(v219)]
         ^ *((_DWORD *)v274 - 2)
         ^ *((_DWORD *)v443 + 2)
         ^ v142;
    v144 = dword_EF148[2 * v337];
    v328 = v128
         ^ *((_DWORD *)v274 - 1)
         ^ *((_DWORD *)v405 - 1)
         ^ *((_DWORD *)v443 + 3)
         ^ HIDWORD(v142)
         ^ dword_F1948[2 * v191 + 1]
         ^ dword_F2148[2 * v501 + 1];
    LODWORD(v142) = BYTE1(v217);
    v145 = v201;
    v202 = &qword_F1150[(unsigned __int8)v217];
    v215 = v143 ^ dword_F1948[2 * v191] ^ dword_F2148[2 * v501];
    HIDWORD(v128) = dword_F2148[2 * v195 + 1]
                  ^ HIDWORD(qword_EE948[v234])
                  ^ *((_DWORD *)v446 + 1)
                  ^ *((_DWORD *)v364 - 1);
    v146 = dword_F2148[2 * v195] ^ LODWORD(qword_EE948[v234]) ^ dword_EF148[2 * v335] ^ *((_DWORD *)v364 - 2);
    v365 = v142;
    v196 = (char *)&dword_F1948[2 * v142];
    v338 = dword_F2148[2 * v226 + 1];
    v147 = *((_DWORD *)v167 + 1) ^ HIDWORD(qword_EE948[v213]) ^ *((_DWORD *)v451 + 1);
    v168 = BYTE2(v219);
    v178 = BYTE1(v219);
    v148 = BYTE2(v219);
    v220 = dword_F2148[2 * v226];
    v181 = (char *)&dword_F2148[2 * v148];
    LODWORD(v142) = *(_DWORD *)(v173 - 4)
                  ^ HIDWORD(qword_EE948[(unsigned __int8)v265])
                  ^ *((_DWORD *)v456 + 1)
                  ^ *((_DWORD *)v426 - 1)
                  ^ *((_DWORD *)v429 - 1)
                  ^ *((_DWORD *)v459 + 3)
                  ^ dword_F1948[2 * v241 + 1];
    v192 = *(_DWORD *)(v173 - 8)
         ^ LODWORD(qword_EE948[(unsigned __int8)v265])
         ^ dword_EF148[2 * v342]
         ^ *((_DWORD *)v426 - 2)
         ^ *((_DWORD *)v429 - 2)
         ^ *((_DWORD *)v459 + 2)
         ^ dword_F1948[2 * v241];
    v221 = HIDWORD(v128)
         ^ *((_DWORD *)v369 - 1)
         ^ *((_DWORD *)v449 + 3)
         ^ *((_DWORD *)v412 - 1)
         ^ dword_F1948[2 * v207 + 1];
    v169 = v146 ^ *((_DWORD *)v369 - 2) ^ *((_DWORD *)v449 + 2) ^ *((_DWORD *)v412 - 2) ^ dword_F1948[2 * v207];
    HIDWORD(v231) = v147
                  ^ *((_DWORD *)v416 - 1)
                  ^ *((_DWORD *)v419 - 1)
                  ^ *((_DWORD *)v453 + 3)
                  ^ *((_DWORD *)v422 - 1)
                  ^ v338;
    LODWORD(v231) = dword_F1948[2 * v145]
                  ^ LODWORD(qword_EE948[v213])
                  ^ v144
                  ^ *((_DWORD *)v416 - 2)
                  ^ *((_DWORD *)v419 - 2)
                  ^ *((_DWORD *)v453 + 2)
                  ^ *((_DWORD *)v422 - 2)
                  ^ v220;
    v149 = *((_DWORD *)v461 + 3)
         ^ HIDWORD(qword_EE948[v251])
         ^ *((_DWORD *)v464 + 1)
         ^ *((_DWORD *)v432 - 1)
         ^ *((_DWORD *)v379 - 1)
         ^ *(_DWORD *)(v434 - 4)
         ^ v385[1];
    v214 = *((_DWORD *)v390 + 1);
    LODWORD(v238) = v192 ^ dword_F2148[2 * BYTE2(v198)];
    HIDWORD(v238) = v142 ^ dword_F2148[2 * BYTE2(v198) + 1];
    v11 = *((_DWORD *)v469 - 2)
        ^ LODWORD(qword_EE948[v261])
        ^ dword_EF148[2 * v347]
        ^ *((_DWORD *)v476 - 2)
        ^ *((_DWORD *)v478 + 2)
        ^ *((_DWORD *)v482 - 2)
        ^ dword_F1948[2 * v365]
        ^ dword_F2148[2 * v168];
    LODWORD(v142) = dword_F2148[2 * v256];
    HIDWORD(v246) = v149 ^ v214;
    v12 = LODWORD(qword_EE948[(unsigned __int8)v279])
        ^ *((_DWORD *)v485 - 2)
        ^ dword_F2148[2 * v292]
        ^ dword_EF148[2 * v502]
        ^ *((_DWORD *)v491 - 2)
        ^ *((_DWORD *)v494 + 2)
        ^ *((_DWORD *)v202 - 2)
        ^ dword_F1948[2 * v178];
    LODWORD(v246) = LODWORD(qword_EE948[v251])
                  ^ *((_DWORD *)v461 + 2)
                  ^ dword_EF148[2 * v344]
                  ^ *((_DWORD *)v432 - 2)
                  ^ *((_DWORD *)v379 - 2)
                  ^ *(_DWORD *)(v434 - 8)
                  ^ *v385
                  ^ v142;
    v257 = HIDWORD(qword_EE948[v261])
         ^ *((_DWORD *)v469 - 1)
         ^ *((_DWORD *)v472 + 1)
         ^ *((_DWORD *)v476 - 1)
         ^ *((_DWORD *)v478 + 3)
         ^ *((_DWORD *)v482 - 1)
         ^ *((_DWORD *)v196 + 1)
         ^ *((_DWORD *)v181 + 1);
    v13 = *((_DWORD *)v494 + 3)
        ^ *((_DWORD *)v488 + 1)
        ^ HIDWORD(qword_EE948[(unsigned __int8)v279])
        ^ *((_DWORD *)v485 - 1)
        ^ dword_F2148[2 * v292 + 1]
        ^ *((_DWORD *)v491 - 1)
        ^ *((_DWORD *)v202 - 1)
        ^ dword_F1948[2 * v178 + 1];
  }
  while ( !v95 );
  v150 = LODWORD(qword_EE948[(unsigned __int8)v279])
       ^ *((_DWORD *)v485 - 2)
       ^ dword_F2148[2 * v292]
       ^ dword_EF148[2 * v502]
       ^ *((_DWORD *)v491 - 2)
       ^ *((_DWORD *)v494 + 2)
       ^ *((_DWORD *)v202 - 2)
       ^ dword_F1948[2 * v178];
  v151 = v353;
  v152 = &v504;
  v153 = HIDWORD(v353);
  v154 = (int *)&v507[1];
  v507[1] = __PAIR64__(v286, v308);
  v507[0] = v353;
  v507[2] = v312;
  v507[3] = __PAIR64__(v348, v293);
  v507[4] = __PAIR64__(v318, v303);
  v507[5] = __PAIR64__(v321, v280);
  v507[6] = __PAIR64__(v298, v266);
  v507[7] = __PAIR64__(v324, v227);
  HIDWORD(v507[13]) = v149 ^ v214;
  v507[14] = __PAIR64__(v257, v11);
  v507[8] = __PAIR64__(v326, v182);
  v507[15] = __PAIR64__(v13, v150);
  v507[9] = __PAIR64__(v328, v215);
  v507[10] = __PAIR64__(v221, v169);
  v507[11] = v231;
  v507[12] = v238;
  LODWORD(v507[13]) = v246;
  while ( 1 )
  {
    v155 = (unsigned int)v152[2];
    v152 += 2;
    v156 = (unsigned int)v152[1];
    *v152 = (void *)(v155 ^ v151);
    v152[1] = (void *)(v156 ^ v153);
    if ( &dest[120] == (_BYTE *)v152 )
      break;
    v151 = *v154;
    v154 += 2;
    v153 = *(v154 - 1);
  }
  v157 = (int *)&dest[64];
  v158 = v508;
  do
  {
    v159 = *v157;
    v157 += 2;
    v160 = *(v157 - 1);
    v158 += 8;
    *((_DWORD *)v158 - 2) = v159;
    *((_DWORD *)v158 - 1) = v160;
  }
  while ( v507 != (_QWORD *)v157 );
  memcpy(v504, &v508[64 - n], n);
  result = 0;
  *(_DWORD *)(a1 + 128) = 0;
  v162 = a1 + 128;
  do
  {
    *(_QWORD *)(v162 + 8) = 0;
    v162 += 8;
  }
  while ( a1 + 248 != v162 );
  v163 = v505;
  *(_DWORD *)(a1 + 256) = 0;
  *(_DWORD *)(a1 + 260) = (n << 11) & 0xFF0000 | (n << 27);
  *(_QWORD *)(v163 - 8) = 0;
  return result;
}
// EE948: using guessed type _QWORD qword_EE948[256];
// EF148: using guessed type _DWORD dword_EF148[514];
// EF950: using guessed type _QWORD qword_EF950[256];
// F0150: using guessed type _QWORD qword_F0150[254];
// F1150: using guessed type _QWORD qword_F1150[255];
// F1948: using guessed type _DWORD dword_F1948[512];
// F2148: using guessed type _DWORD dword_F2148[512];

//----- (000B5D30) --------------------------------------------------------
int __fastcall sph_groestl224_init(int result)
{
  _QWORD *v1; // r3

  v1 = (_QWORD *)(result + 72);
  *(_DWORD *)(result + 64) = 0;
  do
    *v1++ = 0;
  while ( v1 != (_QWORD *)(result + 128) );
  *(_QWORD *)(result + 136) = 0;
  *(_QWORD *)(result + 128) = 0xE000000000000000LL;
  return result;
}

//----- (000B5D74) --------------------------------------------------------
_DWORD *__fastcall sph_groestl224_close(_DWORD *a1, void *a2)
{
  return sub_B0DA4(a1, 0, 0, a2, 0x1Cu);
}

//----- (000B5D9C) --------------------------------------------------------
_DWORD *__fastcall sph_groestl224_addbits_and_close(_DWORD *a1, char a2, char a3, void *a4)
{
  return sub_B0DA4(a1, a2, a3, a4, 0x1Cu);
}

//----- (000B5DB8) --------------------------------------------------------
int __fastcall sph_groestl256_init(int result)
{
  _QWORD *v1; // r3

  v1 = (_QWORD *)(result + 72);
  *(_DWORD *)(result + 64) = 0;
  do
    *v1++ = 0;
  while ( v1 != (_QWORD *)(result + 128) );
  *(_QWORD *)(result + 136) = 0;
  *(_QWORD *)(result + 128) = 0x1000000000000LL;
  return result;
}

//----- (000B5DFC) --------------------------------------------------------
_DWORD *__fastcall sph_groestl256_close(_DWORD *a1, void *a2)
{
  return sub_B0DA4(a1, 0, 0, a2, 0x20u);
}

//----- (000B5E24) --------------------------------------------------------
_DWORD *__fastcall sph_groestl256_addbits_and_close(_DWORD *a1, char a2, char a3, void *a4)
{
  return sub_B0DA4(a1, a2, a3, a4, 0x20u);
}

//----- (000B5E40) --------------------------------------------------------
int __fastcall sph_groestl384_init(int a1)
{
  int v1; // r3
  _QWORD *v2; // r3
  int result; // r0

  *(_DWORD *)(a1 + 128) = 0;
  v1 = a1 + 128;
  do
  {
    *(_QWORD *)(v1 + 8) = 0;
    v1 += 8;
  }
  while ( v1 != a1 + 248 );
  v2 = (_QWORD *)(a1 + 256);
  result = a1 + 272;
  *v2 = 0x8001000000000000LL;
  *(_QWORD *)(result - 8) = 0;
  return result;
}

//----- (000B5E90) --------------------------------------------------------
__int64 __fastcall sph_groestl384_close(int a1, void *a2)
{
  return sub_B279C(a1, 0, 0, a2, 0x30u);
}

//----- (000B5EB8) --------------------------------------------------------
__int64 __fastcall sph_groestl384_addbits_and_close(int a1, char a2, char a3, void *a4)
{
  return sub_B279C(a1, a2, a3, a4, 0x30u);
}

//----- (000B5ED4) --------------------------------------------------------
int __fastcall sph_groestl512_init(int a1)
{
  int v1; // r3
  _QWORD *v2; // r3
  int result; // r0

  *(_DWORD *)(a1 + 128) = 0;
  v1 = a1 + 128;
  do
  {
    *(_QWORD *)(v1 + 8) = 0;
    v1 += 8;
  }
  while ( v1 != a1 + 248 );
  v2 = (_QWORD *)(a1 + 256);
  result = a1 + 272;
  *v2 = 0x2000000000000LL;
  *(_QWORD *)(result - 8) = 0;
  return result;
}

//----- (000B5F20) --------------------------------------------------------
__int64 __fastcall sph_groestl512_close(int a1, void *a2)
{
  return sub_B279C(a1, 0, 0, a2, 0x40u);
}

//----- (000B5F48) --------------------------------------------------------
__int64 __fastcall sph_groestl512_addbits_and_close(int a1, char a2, char a3, void *a4)
{
  return sub_B279C(a1, a2, a3, a4, 0x40u);
}

//----- (000B5F64) --------------------------------------------------------
void *__fastcall sph_jh224_0(int a1, char *a2, size_t a3)
{
  int v3; // r5
  size_t v4; // r4
  int v5; // r6
  int v6; // r7
  int v7; // r12
  int v8; // r8
  int v9; // r11
  void *v10; // r2
  void *result; // r0
  int v12; // r10
  int v13; // r9
  int v14; // r11
  void *v15; // r8
  void *v16; // r0
  int v17; // r0
  int v18; // r5
  int v19; // r7
  int v20; // r11
  int v21; // r6
  int v22; // lr
  int v23; // r7
  int v24; // r4
  int v25; // r1
  int v26; // r2
  int v27; // lr
  int v28; // r10
  int v29; // r0
  int v30; // r11
  int v31; // r6
  int v32; // r11
  int v33; // r9
  int v34; // r7
  int v35; // r5
  int v36; // r4
  int v37; // r11
  int v38; // r4
  int v39; // r6
  int v40; // r9
  int v41; // r10
  int v42; // r3
  int v43; // r6
  int v44; // r8
  int v45; // r2
  int v46; // r0
  int v47; // r3
  int v48; // lr
  int v49; // r8
  int v50; // r6
  int v51; // lr
  int v52; // r2
  int v53; // r7
  int v54; // r3
  int v55; // r8
  int v56; // r2
  int v57; // r3
  int v58; // r7
  int v59; // r9
  int v60; // r5
  int v61; // r0
  int v62; // r1
  int v63; // r3
  int v64; // r10
  int v65; // r5
  int v66; // lr
  int v67; // r4
  unsigned int v68; // lr
  unsigned int v69; // r12
  unsigned int v70; // r0
  unsigned int v71; // r4
  int v72; // r2
  int v73; // r6
  int v74; // r5
  unsigned int v75; // r3
  int v76; // r5
  unsigned int v77; // r9
  unsigned int v78; // r5
  unsigned int v79; // r12
  unsigned int v80; // r8
  int v81; // r10
  int v82; // r2
  int v83; // r0
  unsigned int v84; // r7
  int v85; // r7
  unsigned int v86; // r8
  unsigned int v87; // r3
  int v88; // lr
  int v89; // r11
  int v90; // r1
  unsigned int v91; // r2
  int v92; // lr
  int v93; // r0
  int v94; // r6
  int v95; // r7
  int v96; // r11
  int v97; // r9
  int v98; // r0
  int v99; // r7
  int v100; // r1
  int v101; // r6
  int v102; // r10
  int v103; // r12
  int v104; // r0
  int v105; // r4
  int v106; // r9
  int v107; // r11
  int v108; // r7
  int v109; // r0
  int v110; // r11
  int v111; // r3
  int v112; // r8
  int v113; // r9
  int v114; // r12
  int v115; // r7
  int v116; // r10
  int v117; // r6
  int v118; // r0
  unsigned int v119; // r1
  unsigned int v120; // r9
  int v121; // lr
  unsigned int v122; // r10
  int v123; // r5
  unsigned int v124; // r2
  unsigned int v125; // r4
  unsigned int v126; // r11
  int v127; // r9
  unsigned int v128; // lr
  int v129; // r0
  unsigned int v130; // r12
  unsigned int v131; // r5
  unsigned int v132; // r6
  unsigned int v133; // r8
  int v134; // r4
  int v135; // r7
  int v136; // r9
  int v137; // r1
  int v138; // r8
  int v139; // r9
  unsigned int v140; // lr
  int v141; // r2
  int v142; // r4
  int v143; // r5
  int v144; // r7
  int v145; // r0
  int v146; // r1
  int v147; // r12
  int v148; // r10
  int v149; // r3
  int v150; // r11
  int v151; // r9
  int v152; // r4
  int v153; // r10
  int v154; // r7
  int v155; // r8
  int v156; // r4
  int v157; // r11
  int v158; // r5
  int v159; // r6
  int v160; // r3
  int v161; // r4
  int v162; // r12
  int v163; // r2
  int v164; // r5
  int v165; // lr
  int v166; // r6
  int v167; // r9
  int v168; // r2
  int v169; // r11
  unsigned int v170; // r3
  unsigned int v171; // r4
  unsigned int v172; // r7
  int v173; // r0
  unsigned int v174; // r6
  unsigned int v175; // r9
  unsigned int v176; // r5
  unsigned int v177; // r0
  int v178; // r7
  int v179; // r11
  unsigned int v180; // r12
  int v181; // r5
  unsigned int v182; // lr
  int v183; // r10
  unsigned int v184; // r3
  int v185; // r9
  int v186; // r1
  int v187; // r5
  int v188; // r8
  int v189; // r0
  int v190; // r12
  int v191; // lr
  unsigned int v192; // r10
  int v193; // r7
  int v194; // r5
  int v195; // r0
  int v196; // r10
  int v197; // r1
  int v198; // r7
  int v199; // r6
  int v200; // r11
  int v201; // r10
  int v202; // r0
  int v203; // r9
  int v204; // r2
  int v205; // r6
  int v206; // r1
  int v207; // r10
  int v208; // r9
  unsigned int v209; // r3
  int v210; // lr
  int v211; // r8
  int v212; // r12
  int v213; // r2
  int v214; // r4
  int v215; // lr
  int v216; // r7
  int v217; // r5
  int v218; // r12
  int v219; // r6
  int v220; // r2
  int v221; // r1
  int v222; // r9
  int v223; // r1
  unsigned int v224; // r7
  unsigned int v225; // r10
  unsigned int v226; // r6
  unsigned int v227; // r9
  unsigned int v228; // r4
  int v229; // r2
  int v230; // r5
  unsigned int v231; // r1
  unsigned int v232; // r0
  int v233; // r6
  unsigned int v234; // r12
  unsigned int v235; // lr
  int v236; // r11
  int v237; // r1
  int v238; // r8
  int v239; // r0
  int v240; // r12
  unsigned int v241; // r3
  int v242; // r0
  int v243; // r10
  int v244; // r12
  int v245; // r9
  int v246; // r2
  int v247; // r8
  int v248; // r3
  int v249; // r7
  int v250; // r0
  int v251; // r9
  int v252; // r4
  int v253; // r1
  int v254; // r2
  int v255; // r12
  int v256; // r3
  int v257; // r9
  int v258; // r0
  int v259; // r5
  int v260; // r6
  int v261; // r11
  int v262; // r9
  int v263; // r8
  int v264; // r1
  int v265; // r3
  int v266; // r12
  int v267; // r3
  int v268; // r4
  int v269; // r1
  int v270; // r6
  int v271; // lr
  int v272; // r0
  int v273; // r5
  int v274; // r12
  int v275; // r3
  int v276; // r9
  int v277; // r8
  int v278; // r7
  int v279; // r10
  int v280; // r0
  int v281; // r1
  int v282; // r12
  int v283; // r5
  int v284; // r7
  int v285; // r4
  int v286; // lr
  int v287; // r3
  int v288; // r9
  int v289; // r3
  int v290; // r11
  int v291; // r6
  int v292; // r10
  int v293; // r5
  int v294; // r1
  int v295; // r7
  int v296; // r8
  int v297; // lr
  int v298; // r12
  int v299; // r0
  int v300; // r5
  int v301; // r2
  int v302; // r1
  int v303; // r3
  int v304; // r11
  int v305; // r4
  int v306; // lr
  int v307; // r12
  int v308; // r0
  int v309; // r6
  int v310; // r7
  int v311; // r1
  int v312; // r2
  int v313; // r0
  int v314; // r8
  int v315; // r5
  int v316; // r2
  int v317; // r6
  int v318; // r10
  int v319; // r2
  int v320; // lr
  int v321; // r9
  int v322; // r5
  int v323; // r3
  int v324; // r7
  int v325; // r1
  int v326; // r12
  int v327; // r10
  int v328; // r11
  int v329; // r2
  int v330; // lr
  int v331; // r3
  int v332; // r1
  int v333; // r12
  int v334; // r6
  int v335; // r8
  int v336; // r5
  int v337; // r4
  int v338; // r3
  int v339; // r4
  int v340; // r6
  int v341; // lr
  int v342; // r3
  int v343; // r6
  int v344; // r7
  int v345; // r4
  int v346; // r12
  int v347; // r0
  int v348; // r2
  int v349; // r1
  int v350; // r12
  int v351; // r4
  int v352; // r0
  int v353; // r2
  int v354; // r10
  int v355; // lr
  int v356; // r4
  int v357; // r2
  int v358; // r9
  int v359; // r11
  int v360; // r12
  int v361; // lr
  int v362; // r8
  int v363; // r0
  int v364; // r4
  int v365; // r5
  int v366; // r2
  int v367; // r1
  int v368; // lr
  int v369; // r3
  int v370; // r6
  int v371; // r12
  int v372; // r9
  int v373; // r7
  int v374; // r8
  int v375; // r6
  int v376; // r0
  int v377; // r2
  int v378; // lr
  int v379; // r4
  int v380; // r5
  int v382; // [sp+0h] [bp-1F4h]
  int v383; // [sp+4h] [bp-1F0h]
  int v384; // [sp+Ch] [bp-1E8h]
  int v385; // [sp+Ch] [bp-1E8h]
  int v386; // [sp+Ch] [bp-1E8h]
  unsigned int v387; // [sp+Ch] [bp-1E8h]
  int v388; // [sp+Ch] [bp-1E8h]
  int v389; // [sp+Ch] [bp-1E8h]
  int v390; // [sp+Ch] [bp-1E8h]
  int v391; // [sp+Ch] [bp-1E8h]
  int v392; // [sp+Ch] [bp-1E8h]
  unsigned int v393; // [sp+Ch] [bp-1E8h]
  int v394; // [sp+Ch] [bp-1E8h]
  int v395; // [sp+Ch] [bp-1E8h]
  int v396; // [sp+Ch] [bp-1E8h]
  int v397; // [sp+Ch] [bp-1E8h]
  int v398; // [sp+Ch] [bp-1E8h]
  int v399; // [sp+Ch] [bp-1E8h]
  int v400; // [sp+Ch] [bp-1E8h]
  int v401; // [sp+Ch] [bp-1E8h]
  int v402; // [sp+10h] [bp-1E4h]
  int v403; // [sp+10h] [bp-1E4h]
  unsigned int v404; // [sp+10h] [bp-1E4h]
  int v405; // [sp+10h] [bp-1E4h]
  int v406; // [sp+10h] [bp-1E4h]
  int v407; // [sp+10h] [bp-1E4h]
  unsigned int v408; // [sp+10h] [bp-1E4h]
  int v409; // [sp+10h] [bp-1E4h]
  int v410; // [sp+10h] [bp-1E4h]
  int v411; // [sp+10h] [bp-1E4h]
  int v412; // [sp+10h] [bp-1E4h]
  int v413; // [sp+10h] [bp-1E4h]
  int v414; // [sp+10h] [bp-1E4h]
  int v415; // [sp+10h] [bp-1E4h]
  int v416; // [sp+10h] [bp-1E4h]
  int v417; // [sp+14h] [bp-1E0h]
  int v418; // [sp+14h] [bp-1E0h]
  unsigned int v419; // [sp+14h] [bp-1E0h]
  int v420; // [sp+14h] [bp-1E0h]
  unsigned int v421; // [sp+14h] [bp-1E0h]
  int v422; // [sp+14h] [bp-1E0h]
  unsigned int v423; // [sp+14h] [bp-1E0h]
  int v424; // [sp+14h] [bp-1E0h]
  int v425; // [sp+14h] [bp-1E0h]
  int v426; // [sp+14h] [bp-1E0h]
  int v427; // [sp+14h] [bp-1E0h]
  int v428; // [sp+14h] [bp-1E0h]
  int v429; // [sp+14h] [bp-1E0h]
  int v430; // [sp+14h] [bp-1E0h]
  int v431; // [sp+14h] [bp-1E0h]
  int v432; // [sp+18h] [bp-1DCh]
  int v433; // [sp+18h] [bp-1DCh]
  int v434; // [sp+18h] [bp-1DCh]
  int v435; // [sp+18h] [bp-1DCh]
  unsigned int v436; // [sp+18h] [bp-1DCh]
  int v437; // [sp+18h] [bp-1DCh]
  unsigned int v438; // [sp+18h] [bp-1DCh]
  int v439; // [sp+18h] [bp-1DCh]
  unsigned int v440; // [sp+18h] [bp-1DCh]
  int v441; // [sp+18h] [bp-1DCh]
  int v442; // [sp+18h] [bp-1DCh]
  int v443; // [sp+18h] [bp-1DCh]
  int v444; // [sp+18h] [bp-1DCh]
  int v445; // [sp+18h] [bp-1DCh]
  int v446; // [sp+1Ch] [bp-1D8h]
  int v447; // [sp+1Ch] [bp-1D8h]
  unsigned int v448; // [sp+1Ch] [bp-1D8h]
  int v449; // [sp+1Ch] [bp-1D8h]
  unsigned int v450; // [sp+1Ch] [bp-1D8h]
  int v451; // [sp+1Ch] [bp-1D8h]
  int v452; // [sp+1Ch] [bp-1D8h]
  int v453; // [sp+1Ch] [bp-1D8h]
  unsigned int v454; // [sp+1Ch] [bp-1D8h]
  int v455; // [sp+1Ch] [bp-1D8h]
  int v456; // [sp+1Ch] [bp-1D8h]
  int v457; // [sp+1Ch] [bp-1D8h]
  int v458; // [sp+1Ch] [bp-1D8h]
  int v459; // [sp+1Ch] [bp-1D8h]
  int v460; // [sp+20h] [bp-1D4h]
  int v461; // [sp+20h] [bp-1D4h]
  int v462; // [sp+20h] [bp-1D4h]
  int v463; // [sp+20h] [bp-1D4h]
  int v464; // [sp+20h] [bp-1D4h]
  int v465; // [sp+20h] [bp-1D4h]
  int v466; // [sp+20h] [bp-1D4h]
  int v467; // [sp+20h] [bp-1D4h]
  int v468; // [sp+20h] [bp-1D4h]
  unsigned int v469; // [sp+20h] [bp-1D4h]
  int v470; // [sp+20h] [bp-1D4h]
  int v471; // [sp+20h] [bp-1D4h]
  int v472; // [sp+20h] [bp-1D4h]
  int v473; // [sp+20h] [bp-1D4h]
  int v474; // [sp+20h] [bp-1D4h]
  int v475; // [sp+24h] [bp-1D0h]
  unsigned int v476; // [sp+24h] [bp-1D0h]
  unsigned int v477; // [sp+24h] [bp-1D0h]
  int v478; // [sp+24h] [bp-1D0h]
  unsigned int v479; // [sp+24h] [bp-1D0h]
  int v480; // [sp+24h] [bp-1D0h]
  int v481; // [sp+24h] [bp-1D0h]
  int v482; // [sp+24h] [bp-1D0h]
  unsigned int v483; // [sp+24h] [bp-1D0h]
  int v484; // [sp+24h] [bp-1D0h]
  int v485; // [sp+24h] [bp-1D0h]
  int v486; // [sp+24h] [bp-1D0h]
  int v487; // [sp+24h] [bp-1D0h]
  int v488; // [sp+24h] [bp-1D0h]
  int v489; // [sp+24h] [bp-1D0h]
  int v490; // [sp+28h] [bp-1CCh]
  int v491; // [sp+28h] [bp-1CCh]
  unsigned int v492; // [sp+28h] [bp-1CCh]
  int v493; // [sp+28h] [bp-1CCh]
  int v494; // [sp+28h] [bp-1CCh]
  int v495; // [sp+28h] [bp-1CCh]
  int v496; // [sp+28h] [bp-1CCh]
  int v497; // [sp+28h] [bp-1CCh]
  int v498; // [sp+28h] [bp-1CCh]
  int v499; // [sp+28h] [bp-1CCh]
  int v500; // [sp+28h] [bp-1CCh]
  int v501; // [sp+28h] [bp-1CCh]
  int v502; // [sp+28h] [bp-1CCh]
  int v503; // [sp+28h] [bp-1CCh]
  int v504; // [sp+28h] [bp-1CCh]
  int v505; // [sp+28h] [bp-1CCh]
  int v506; // [sp+2Ch] [bp-1C8h]
  int v507; // [sp+2Ch] [bp-1C8h]
  int v508; // [sp+2Ch] [bp-1C8h]
  unsigned int v509; // [sp+2Ch] [bp-1C8h]
  int v510; // [sp+2Ch] [bp-1C8h]
  int v511; // [sp+2Ch] [bp-1C8h]
  unsigned int v512; // [sp+2Ch] [bp-1C8h]
  int v513; // [sp+2Ch] [bp-1C8h]
  int v514; // [sp+2Ch] [bp-1C8h]
  int v515; // [sp+2Ch] [bp-1C8h]
  int v516; // [sp+2Ch] [bp-1C8h]
  int v517; // [sp+2Ch] [bp-1C8h]
  int v518; // [sp+2Ch] [bp-1C8h]
  int v519; // [sp+2Ch] [bp-1C8h]
  int v520; // [sp+2Ch] [bp-1C8h]
  int v521; // [sp+2Ch] [bp-1C8h]
  int v522; // [sp+30h] [bp-1C4h]
  int v523; // [sp+30h] [bp-1C4h]
  int v524; // [sp+30h] [bp-1C4h]
  unsigned int v525; // [sp+30h] [bp-1C4h]
  int v526; // [sp+30h] [bp-1C4h]
  unsigned int v527; // [sp+30h] [bp-1C4h]
  int v528; // [sp+30h] [bp-1C4h]
  int v529; // [sp+30h] [bp-1C4h]
  unsigned int v530; // [sp+30h] [bp-1C4h]
  int v531; // [sp+30h] [bp-1C4h]
  int v532; // [sp+30h] [bp-1C4h]
  unsigned int v533; // [sp+30h] [bp-1C4h]
  int v534; // [sp+30h] [bp-1C4h]
  int v535; // [sp+30h] [bp-1C4h]
  int v536; // [sp+30h] [bp-1C4h]
  int v537; // [sp+30h] [bp-1C4h]
  int v538; // [sp+30h] [bp-1C4h]
  int v539; // [sp+30h] [bp-1C4h]
  int v540; // [sp+34h] [bp-1C0h]
  int v541; // [sp+34h] [bp-1C0h]
  unsigned int v542; // [sp+34h] [bp-1C0h]
  int v543; // [sp+34h] [bp-1C0h]
  int v544; // [sp+34h] [bp-1C0h]
  unsigned int v545; // [sp+34h] [bp-1C0h]
  int v546; // [sp+34h] [bp-1C0h]
  int v547; // [sp+34h] [bp-1C0h]
  int v548; // [sp+34h] [bp-1C0h]
  int v549; // [sp+34h] [bp-1C0h]
  int v550; // [sp+34h] [bp-1C0h]
  int v551; // [sp+34h] [bp-1C0h]
  int v552; // [sp+34h] [bp-1C0h]
  int v553; // [sp+34h] [bp-1C0h]
  int v554; // [sp+34h] [bp-1C0h]
  int v555; // [sp+34h] [bp-1C0h]
  int v556; // [sp+34h] [bp-1C0h]
  int v557; // [sp+34h] [bp-1C0h]
  int v558; // [sp+38h] [bp-1BCh]
  unsigned int v559; // [sp+38h] [bp-1BCh]
  int v560; // [sp+38h] [bp-1BCh]
  int v561; // [sp+38h] [bp-1BCh]
  int v562; // [sp+38h] [bp-1BCh]
  unsigned int v563; // [sp+38h] [bp-1BCh]
  unsigned int v564; // [sp+38h] [bp-1BCh]
  int v565; // [sp+38h] [bp-1BCh]
  int v566; // [sp+38h] [bp-1BCh]
  unsigned int v567; // [sp+38h] [bp-1BCh]
  int v568; // [sp+38h] [bp-1BCh]
  unsigned int v569; // [sp+38h] [bp-1BCh]
  int v570; // [sp+38h] [bp-1BCh]
  int v571; // [sp+38h] [bp-1BCh]
  int v572; // [sp+38h] [bp-1BCh]
  int v573; // [sp+38h] [bp-1BCh]
  int v574; // [sp+38h] [bp-1BCh]
  int v575; // [sp+38h] [bp-1BCh]
  int v576; // [sp+38h] [bp-1BCh]
  int v577; // [sp+3Ch] [bp-1B8h]
  int v578; // [sp+3Ch] [bp-1B8h]
  int v579; // [sp+3Ch] [bp-1B8h]
  unsigned int v580; // [sp+3Ch] [bp-1B8h]
  unsigned int v581; // [sp+3Ch] [bp-1B8h]
  int v582; // [sp+3Ch] [bp-1B8h]
  int v583; // [sp+3Ch] [bp-1B8h]
  int v584; // [sp+3Ch] [bp-1B8h]
  unsigned int v585; // [sp+3Ch] [bp-1B8h]
  int v586; // [sp+3Ch] [bp-1B8h]
  int v587; // [sp+3Ch] [bp-1B8h]
  int v588; // [sp+3Ch] [bp-1B8h]
  int v589; // [sp+3Ch] [bp-1B8h]
  int v590; // [sp+3Ch] [bp-1B8h]
  int v591; // [sp+40h] [bp-1B4h]
  int v592; // [sp+40h] [bp-1B4h]
  int v593; // [sp+40h] [bp-1B4h]
  int v594; // [sp+40h] [bp-1B4h]
  int v595; // [sp+40h] [bp-1B4h]
  int v596; // [sp+40h] [bp-1B4h]
  int v597; // [sp+40h] [bp-1B4h]
  int v598; // [sp+40h] [bp-1B4h]
  int v599; // [sp+40h] [bp-1B4h]
  int v600; // [sp+40h] [bp-1B4h]
  int v601; // [sp+40h] [bp-1B4h]
  int v602; // [sp+40h] [bp-1B4h]
  int v603; // [sp+40h] [bp-1B4h]
  int v604; // [sp+40h] [bp-1B4h]
  size_t v605; // [sp+44h] [bp-1B0h]
  size_t v606; // [sp+44h] [bp-1B0h]
  size_t v607; // [sp+44h] [bp-1B0h]
  size_t v608; // [sp+44h] [bp-1B0h]
  size_t v609; // [sp+44h] [bp-1B0h]
  size_t v610; // [sp+44h] [bp-1B0h]
  size_t v611; // [sp+44h] [bp-1B0h]
  size_t v612; // [sp+44h] [bp-1B0h]
  size_t v613; // [sp+44h] [bp-1B0h]
  size_t v614; // [sp+44h] [bp-1B0h]
  size_t v615; // [sp+44h] [bp-1B0h]
  size_t v616; // [sp+44h] [bp-1B0h]
  size_t v617; // [sp+44h] [bp-1B0h]
  size_t v618; // [sp+44h] [bp-1B0h]
  size_t v619; // [sp+44h] [bp-1B0h]
  int v620; // [sp+48h] [bp-1ACh]
  int v621; // [sp+48h] [bp-1ACh]
  int v622; // [sp+48h] [bp-1ACh]
  unsigned int v623; // [sp+48h] [bp-1ACh]
  int v624; // [sp+48h] [bp-1ACh]
  int v625; // [sp+48h] [bp-1ACh]
  int v626; // [sp+48h] [bp-1ACh]
  int v627; // [sp+48h] [bp-1ACh]
  int v628; // [sp+48h] [bp-1ACh]
  int v629; // [sp+48h] [bp-1ACh]
  int v630; // [sp+48h] [bp-1ACh]
  unsigned int v631; // [sp+48h] [bp-1ACh]
  int v632; // [sp+48h] [bp-1ACh]
  int v633; // [sp+48h] [bp-1ACh]
  int v634; // [sp+48h] [bp-1ACh]
  int v635; // [sp+48h] [bp-1ACh]
  int v636; // [sp+48h] [bp-1ACh]
  int v637; // [sp+48h] [bp-1ACh]
  int v638; // [sp+50h] [bp-1A4h]
  int v639; // [sp+50h] [bp-1A4h]
  int v640; // [sp+50h] [bp-1A4h]
  int v641; // [sp+50h] [bp-1A4h]
  int v642; // [sp+50h] [bp-1A4h]
  int v643; // [sp+50h] [bp-1A4h]
  int v644; // [sp+50h] [bp-1A4h]
  int v645; // [sp+50h] [bp-1A4h]
  unsigned int v646; // [sp+50h] [bp-1A4h]
  int v647; // [sp+50h] [bp-1A4h]
  int v648; // [sp+50h] [bp-1A4h]
  int v649; // [sp+50h] [bp-1A4h]
  int v650; // [sp+50h] [bp-1A4h]
  int v651; // [sp+50h] [bp-1A4h]
  int v652; // [sp+50h] [bp-1A4h]
  int v653; // [sp+50h] [bp-1A4h]
  int v654; // [sp+50h] [bp-1A4h]
  int v655; // [sp+54h] [bp-1A0h]
  int v656; // [sp+54h] [bp-1A0h]
  int v657; // [sp+54h] [bp-1A0h]
  int v658; // [sp+54h] [bp-1A0h]
  int v659; // [sp+54h] [bp-1A0h]
  int v660; // [sp+54h] [bp-1A0h]
  int v661; // [sp+54h] [bp-1A0h]
  int v662; // [sp+54h] [bp-1A0h]
  int v663; // [sp+54h] [bp-1A0h]
  int v664; // [sp+54h] [bp-1A0h]
  int v665; // [sp+54h] [bp-1A0h]
  int v666; // [sp+54h] [bp-1A0h]
  int v667; // [sp+54h] [bp-1A0h]
  int v668; // [sp+54h] [bp-1A0h]
  int v669; // [sp+54h] [bp-1A0h]
  int v670; // [sp+54h] [bp-1A0h]
  int v671; // [sp+58h] [bp-19Ch]
  int v672; // [sp+58h] [bp-19Ch]
  int v673; // [sp+58h] [bp-19Ch]
  int v674; // [sp+58h] [bp-19Ch]
  int v675; // [sp+58h] [bp-19Ch]
  int v676; // [sp+58h] [bp-19Ch]
  int v677; // [sp+58h] [bp-19Ch]
  unsigned int v678; // [sp+58h] [bp-19Ch]
  int v679; // [sp+58h] [bp-19Ch]
  int v680; // [sp+58h] [bp-19Ch]
  unsigned int v681; // [sp+58h] [bp-19Ch]
  int v682; // [sp+58h] [bp-19Ch]
  int v683; // [sp+58h] [bp-19Ch]
  int v684; // [sp+58h] [bp-19Ch]
  int v685; // [sp+58h] [bp-19Ch]
  int v686; // [sp+58h] [bp-19Ch]
  int v687; // [sp+5Ch] [bp-198h]
  int v688; // [sp+5Ch] [bp-198h]
  int v689; // [sp+5Ch] [bp-198h]
  int v690; // [sp+5Ch] [bp-198h]
  int v691; // [sp+5Ch] [bp-198h]
  int v692; // [sp+5Ch] [bp-198h]
  unsigned int v693; // [sp+5Ch] [bp-198h]
  int v694; // [sp+5Ch] [bp-198h]
  int v695; // [sp+5Ch] [bp-198h]
  int v696; // [sp+5Ch] [bp-198h]
  int v697; // [sp+5Ch] [bp-198h]
  unsigned int v698; // [sp+5Ch] [bp-198h]
  int v699; // [sp+5Ch] [bp-198h]
  int v700; // [sp+5Ch] [bp-198h]
  int v701; // [sp+5Ch] [bp-198h]
  int v702; // [sp+5Ch] [bp-198h]
  int v703; // [sp+5Ch] [bp-198h]
  int v704; // [sp+5Ch] [bp-198h]
  int v705; // [sp+5Ch] [bp-198h]
  int v706; // [sp+5Ch] [bp-198h]
  int v707; // [sp+60h] [bp-194h]
  int v708; // [sp+60h] [bp-194h]
  int v709; // [sp+60h] [bp-194h]
  int v710; // [sp+60h] [bp-194h]
  int v711; // [sp+60h] [bp-194h]
  int v712; // [sp+60h] [bp-194h]
  int v713; // [sp+60h] [bp-194h]
  int v714; // [sp+60h] [bp-194h]
  int v715; // [sp+60h] [bp-194h]
  int v716; // [sp+60h] [bp-194h]
  int v717; // [sp+60h] [bp-194h]
  int v718; // [sp+60h] [bp-194h]
  int v719; // [sp+60h] [bp-194h]
  int v720; // [sp+60h] [bp-194h]
  int v721; // [sp+60h] [bp-194h]
  int v722; // [sp+64h] [bp-190h]
  int v723; // [sp+64h] [bp-190h]
  int v724; // [sp+64h] [bp-190h]
  int v725; // [sp+64h] [bp-190h]
  int v726; // [sp+64h] [bp-190h]
  int v727; // [sp+64h] [bp-190h]
  int v728; // [sp+64h] [bp-190h]
  int v729; // [sp+64h] [bp-190h]
  int v730; // [sp+64h] [bp-190h]
  int v731; // [sp+64h] [bp-190h]
  int v732; // [sp+64h] [bp-190h]
  int v733; // [sp+64h] [bp-190h]
  int v734; // [sp+64h] [bp-190h]
  int v735; // [sp+64h] [bp-190h]
  int v736; // [sp+64h] [bp-190h]
  int v737; // [sp+64h] [bp-190h]
  int v738; // [sp+64h] [bp-190h]
  int v739; // [sp+68h] [bp-18Ch]
  int v740; // [sp+68h] [bp-18Ch]
  int v741; // [sp+68h] [bp-18Ch]
  int v742; // [sp+68h] [bp-18Ch]
  int v743; // [sp+68h] [bp-18Ch]
  int v744; // [sp+68h] [bp-18Ch]
  int v745; // [sp+68h] [bp-18Ch]
  int v746; // [sp+68h] [bp-18Ch]
  int v747; // [sp+68h] [bp-18Ch]
  int v748; // [sp+68h] [bp-18Ch]
  int v749; // [sp+68h] [bp-18Ch]
  int v750; // [sp+68h] [bp-18Ch]
  int v751; // [sp+68h] [bp-18Ch]
  int v752; // [sp+68h] [bp-18Ch]
  int v753; // [sp+68h] [bp-18Ch]
  int v754; // [sp+68h] [bp-18Ch]
  int v755; // [sp+6Ch] [bp-188h]
  int v756; // [sp+6Ch] [bp-188h]
  unsigned int v757; // [sp+6Ch] [bp-188h]
  int v758; // [sp+6Ch] [bp-188h]
  int v759; // [sp+6Ch] [bp-188h]
  int v760; // [sp+6Ch] [bp-188h]
  int v761; // [sp+6Ch] [bp-188h]
  int v762; // [sp+6Ch] [bp-188h]
  int v763; // [sp+6Ch] [bp-188h]
  int v764; // [sp+6Ch] [bp-188h]
  int v765; // [sp+6Ch] [bp-188h]
  int v766; // [sp+6Ch] [bp-188h]
  int v767; // [sp+6Ch] [bp-188h]
  int v768; // [sp+6Ch] [bp-188h]
  int v769; // [sp+6Ch] [bp-188h]
  int v770; // [sp+6Ch] [bp-188h]
  int v771; // [sp+6Ch] [bp-188h]
  int v772; // [sp+70h] [bp-184h]
  int v773; // [sp+70h] [bp-184h]
  int v774; // [sp+70h] [bp-184h]
  int v775; // [sp+70h] [bp-184h]
  int v776; // [sp+70h] [bp-184h]
  int v777; // [sp+70h] [bp-184h]
  int v778; // [sp+70h] [bp-184h]
  int v779; // [sp+70h] [bp-184h]
  int v780; // [sp+70h] [bp-184h]
  int v781; // [sp+70h] [bp-184h]
  int v782; // [sp+70h] [bp-184h]
  int v783; // [sp+70h] [bp-184h]
  int v784; // [sp+70h] [bp-184h]
  int v785; // [sp+70h] [bp-184h]
  int v786; // [sp+70h] [bp-184h]
  int v787; // [sp+70h] [bp-184h]
  int v788; // [sp+74h] [bp-180h]
  int v789; // [sp+74h] [bp-180h]
  unsigned int v790; // [sp+74h] [bp-180h]
  int v791; // [sp+74h] [bp-180h]
  int v792; // [sp+74h] [bp-180h]
  int v793; // [sp+74h] [bp-180h]
  int v794; // [sp+74h] [bp-180h]
  int v795; // [sp+74h] [bp-180h]
  int v796; // [sp+74h] [bp-180h]
  int v797; // [sp+74h] [bp-180h]
  int v798; // [sp+74h] [bp-180h]
  int v799; // [sp+74h] [bp-180h]
  int v800; // [sp+74h] [bp-180h]
  int v801; // [sp+74h] [bp-180h]
  int v802; // [sp+74h] [bp-180h]
  int v803; // [sp+74h] [bp-180h]
  int v804; // [sp+74h] [bp-180h]
  int v805; // [sp+74h] [bp-180h]
  int v806; // [sp+78h] [bp-17Ch]
  int v807; // [sp+78h] [bp-17Ch]
  unsigned int v808; // [sp+78h] [bp-17Ch]
  int v809; // [sp+78h] [bp-17Ch]
  unsigned int v810; // [sp+78h] [bp-17Ch]
  int v811; // [sp+78h] [bp-17Ch]
  int v812; // [sp+78h] [bp-17Ch]
  int v813; // [sp+78h] [bp-17Ch]
  int v814; // [sp+78h] [bp-17Ch]
  int v815; // [sp+78h] [bp-17Ch]
  unsigned int v816; // [sp+78h] [bp-17Ch]
  int v817; // [sp+78h] [bp-17Ch]
  int v818; // [sp+78h] [bp-17Ch]
  int v819; // [sp+78h] [bp-17Ch]
  int v820; // [sp+78h] [bp-17Ch]
  int v821; // [sp+78h] [bp-17Ch]
  int v822; // [sp+78h] [bp-17Ch]
  int v823; // [sp+78h] [bp-17Ch]
  int v824; // [sp+7Ch] [bp-178h]
  int v825; // [sp+7Ch] [bp-178h]
  int v826; // [sp+7Ch] [bp-178h]
  int v827; // [sp+7Ch] [bp-178h]
  int v828; // [sp+7Ch] [bp-178h]
  int v829; // [sp+7Ch] [bp-178h]
  int v830; // [sp+7Ch] [bp-178h]
  int v831; // [sp+7Ch] [bp-178h]
  int v832; // [sp+7Ch] [bp-178h]
  int v833; // [sp+7Ch] [bp-178h]
  int v834; // [sp+7Ch] [bp-178h]
  int v835; // [sp+7Ch] [bp-178h]
  int v836; // [sp+7Ch] [bp-178h]
  int v837; // [sp+7Ch] [bp-178h]
  int v838; // [sp+7Ch] [bp-178h]
  int v839; // [sp+7Ch] [bp-178h]
  int v840; // [sp+7Ch] [bp-178h]
  int v841; // [sp+7Ch] [bp-178h]
  int v842; // [sp+8Ch] [bp-168h]
  int v843; // [sp+8Ch] [bp-168h]
  int v844; // [sp+8Ch] [bp-168h]
  int v845; // [sp+8Ch] [bp-168h]
  int v846; // [sp+8Ch] [bp-168h]
  int v847; // [sp+8Ch] [bp-168h]
  int v848; // [sp+8Ch] [bp-168h]
  int v849; // [sp+8Ch] [bp-168h]
  int v850; // [sp+8Ch] [bp-168h]
  int v851; // [sp+8Ch] [bp-168h]
  int v852; // [sp+8Ch] [bp-168h]
  int v853; // [sp+90h] [bp-164h]
  int v854; // [sp+90h] [bp-164h]
  int v855; // [sp+90h] [bp-164h]
  int v856; // [sp+90h] [bp-164h]
  int v857; // [sp+90h] [bp-164h]
  unsigned int v858; // [sp+90h] [bp-164h]
  unsigned int v859; // [sp+90h] [bp-164h]
  unsigned int v860; // [sp+90h] [bp-164h]
  int v861; // [sp+90h] [bp-164h]
  int v862; // [sp+90h] [bp-164h]
  int v863; // [sp+90h] [bp-164h]
  int v864; // [sp+90h] [bp-164h]
  int v865; // [sp+90h] [bp-164h]
  int v866; // [sp+90h] [bp-164h]
  int v867; // [sp+94h] [bp-160h]
  int v868; // [sp+94h] [bp-160h]
  int v869; // [sp+94h] [bp-160h]
  int v870; // [sp+94h] [bp-160h]
  int v871; // [sp+94h] [bp-160h]
  int v872; // [sp+94h] [bp-160h]
  int v873; // [sp+94h] [bp-160h]
  int v874; // [sp+94h] [bp-160h]
  int v875; // [sp+94h] [bp-160h]
  int v876; // [sp+94h] [bp-160h]
  int v877; // [sp+94h] [bp-160h]
  int v878; // [sp+94h] [bp-160h]
  int v879; // [sp+98h] [bp-15Ch]
  unsigned int v880; // [sp+98h] [bp-15Ch]
  int v881; // [sp+98h] [bp-15Ch]
  int v882; // [sp+98h] [bp-15Ch]
  int v883; // [sp+98h] [bp-15Ch]
  int v884; // [sp+98h] [bp-15Ch]
  int v885; // [sp+98h] [bp-15Ch]
  int v886; // [sp+98h] [bp-15Ch]
  int v887; // [sp+98h] [bp-15Ch]
  int v888; // [sp+98h] [bp-15Ch]
  int v889; // [sp+98h] [bp-15Ch]
  int v890; // [sp+98h] [bp-15Ch]
  int v891; // [sp+98h] [bp-15Ch]
  int v892; // [sp+98h] [bp-15Ch]
  int v893; // [sp+98h] [bp-15Ch]
  int v894; // [sp+98h] [bp-15Ch]
  int v895; // [sp+9Ch] [bp-158h]
  int v896; // [sp+9Ch] [bp-158h]
  int v897; // [sp+9Ch] [bp-158h]
  int v898; // [sp+9Ch] [bp-158h]
  int v899; // [sp+9Ch] [bp-158h]
  int v900; // [sp+9Ch] [bp-158h]
  int v901; // [sp+9Ch] [bp-158h]
  int v902; // [sp+9Ch] [bp-158h]
  int v903; // [sp+9Ch] [bp-158h]
  int v904; // [sp+9Ch] [bp-158h]
  int v905; // [sp+9Ch] [bp-158h]
  int v906; // [sp+9Ch] [bp-158h]
  int v907; // [sp+A0h] [bp-154h]
  int v908; // [sp+A0h] [bp-154h]
  int v909; // [sp+A0h] [bp-154h]
  int v910; // [sp+A0h] [bp-154h]
  int v911; // [sp+A0h] [bp-154h]
  int v912; // [sp+A0h] [bp-154h]
  unsigned int v913; // [sp+A0h] [bp-154h]
  int v914; // [sp+A0h] [bp-154h]
  int v915; // [sp+A0h] [bp-154h]
  int v916; // [sp+A0h] [bp-154h]
  int v917; // [sp+A0h] [bp-154h]
  int v918; // [sp+A0h] [bp-154h]
  int v919; // [sp+A0h] [bp-154h]
  int v920; // [sp+A4h] [bp-150h]
  int v921; // [sp+A4h] [bp-150h]
  int v922; // [sp+A4h] [bp-150h]
  int v923; // [sp+A4h] [bp-150h]
  int v924; // [sp+A4h] [bp-150h]
  unsigned int v925; // [sp+A4h] [bp-150h]
  int v926; // [sp+A4h] [bp-150h]
  int v927; // [sp+A4h] [bp-150h]
  int v928; // [sp+A4h] [bp-150h]
  int v929; // [sp+A4h] [bp-150h]
  int v930; // [sp+A4h] [bp-150h]
  int v931; // [sp+A8h] [bp-14Ch]
  int v932; // [sp+A8h] [bp-14Ch]
  int v933; // [sp+A8h] [bp-14Ch]
  int v934; // [sp+A8h] [bp-14Ch]
  int v935; // [sp+A8h] [bp-14Ch]
  int v936; // [sp+A8h] [bp-14Ch]
  int v937; // [sp+A8h] [bp-14Ch]
  int v938; // [sp+A8h] [bp-14Ch]
  int v939; // [sp+A8h] [bp-14Ch]
  int v940; // [sp+A8h] [bp-14Ch]
  int v941; // [sp+A8h] [bp-14Ch]
  int v942; // [sp+ACh] [bp-148h]
  int v943; // [sp+ACh] [bp-148h]
  int v944; // [sp+ACh] [bp-148h]
  int v945; // [sp+ACh] [bp-148h]
  unsigned int v946; // [sp+ACh] [bp-148h]
  int v947; // [sp+ACh] [bp-148h]
  int v948; // [sp+ACh] [bp-148h]
  int v949; // [sp+ACh] [bp-148h]
  int v950; // [sp+ACh] [bp-148h]
  int v951; // [sp+ACh] [bp-148h]
  int v952; // [sp+B0h] [bp-144h]
  int v953; // [sp+B0h] [bp-144h]
  unsigned int v954; // [sp+B0h] [bp-144h]
  int v955; // [sp+B0h] [bp-144h]
  int v956; // [sp+B0h] [bp-144h]
  int v957; // [sp+B0h] [bp-144h]
  int v958; // [sp+B0h] [bp-144h]
  int v959; // [sp+B0h] [bp-144h]
  int v960; // [sp+B0h] [bp-144h]
  int v961; // [sp+B4h] [bp-140h]
  int v962; // [sp+B4h] [bp-140h]
  unsigned int v963; // [sp+B4h] [bp-140h]
  int v964; // [sp+B4h] [bp-140h]
  int v965; // [sp+B4h] [bp-140h]
  unsigned int v966; // [sp+B4h] [bp-140h]
  int v967; // [sp+B4h] [bp-140h]
  int v968; // [sp+B4h] [bp-140h]
  int v969; // [sp+B4h] [bp-140h]
  int v970; // [sp+B4h] [bp-140h]
  int v971; // [sp+B4h] [bp-140h]
  int v972; // [sp+B4h] [bp-140h]
  int v973; // [sp+B4h] [bp-140h]
  int v974; // [sp+B4h] [bp-140h]
  int v975; // [sp+B8h] [bp-13Ch]
  int v976; // [sp+B8h] [bp-13Ch]
  unsigned int v977; // [sp+B8h] [bp-13Ch]
  int v978; // [sp+B8h] [bp-13Ch]
  unsigned int v979; // [sp+B8h] [bp-13Ch]
  int v980; // [sp+B8h] [bp-13Ch]
  int v981; // [sp+B8h] [bp-13Ch]
  int v982; // [sp+B8h] [bp-13Ch]
  int v983; // [sp+B8h] [bp-13Ch]
  int v984; // [sp+BCh] [bp-138h]
  unsigned int v985; // [sp+BCh] [bp-138h]
  int v986; // [sp+BCh] [bp-138h]
  unsigned int v987; // [sp+BCh] [bp-138h]
  int v988; // [sp+BCh] [bp-138h]
  int v989; // [sp+BCh] [bp-138h]
  int v990; // [sp+BCh] [bp-138h]
  int v991; // [sp+BCh] [bp-138h]
  int v992; // [sp+C0h] [bp-134h]
  unsigned int v993; // [sp+C0h] [bp-134h]
  int v994; // [sp+C0h] [bp-134h]
  int v995; // [sp+C0h] [bp-134h]
  int v996; // [sp+C0h] [bp-134h]
  int v997; // [sp+C0h] [bp-134h]
  int v998; // [sp+C0h] [bp-134h]
  int v999; // [sp+C0h] [bp-134h]
  int v1000; // [sp+C0h] [bp-134h]
  int v1001; // [sp+C4h] [bp-130h]
  int v1002; // [sp+C4h] [bp-130h]
  int v1003; // [sp+C4h] [bp-130h]
  int v1004; // [sp+C4h] [bp-130h]
  int v1005; // [sp+C4h] [bp-130h]
  int v1006; // [sp+C4h] [bp-130h]
  int v1007; // [sp+C4h] [bp-130h]
  int v1008; // [sp+C4h] [bp-130h]
  int v1009; // [sp+C8h] [bp-12Ch]
  unsigned int v1010; // [sp+C8h] [bp-12Ch]
  int v1011; // [sp+C8h] [bp-12Ch]
  unsigned int v1012; // [sp+C8h] [bp-12Ch]
  int v1013; // [sp+C8h] [bp-12Ch]
  int v1014; // [sp+C8h] [bp-12Ch]
  int v1015; // [sp+C8h] [bp-12Ch]
  int v1016; // [sp+CCh] [bp-128h]
  int v1017; // [sp+CCh] [bp-128h]
  unsigned int v1018; // [sp+CCh] [bp-128h]
  int v1019; // [sp+CCh] [bp-128h]
  int v1020; // [sp+CCh] [bp-128h]
  int v1021; // [sp+CCh] [bp-128h]
  int v1022; // [sp+CCh] [bp-128h]
  int v1023; // [sp+D0h] [bp-124h]
  unsigned int v1024; // [sp+D0h] [bp-124h]
  int v1025; // [sp+D0h] [bp-124h]
  unsigned int v1026; // [sp+D0h] [bp-124h]
  int v1027; // [sp+D0h] [bp-124h]
  int v1028; // [sp+D0h] [bp-124h]
  int v1029; // [sp+D0h] [bp-124h]
  int v1030; // [sp+D4h] [bp-120h]
  unsigned int v1031; // [sp+D4h] [bp-120h]
  int v1032; // [sp+D4h] [bp-120h]
  unsigned int v1033; // [sp+D4h] [bp-120h]
  unsigned int v1034; // [sp+D4h] [bp-120h]
  int v1035; // [sp+D4h] [bp-120h]
  int v1036; // [sp+D4h] [bp-120h]
  int v1037; // [sp+D4h] [bp-120h]
  int v1038; // [sp+D8h] [bp-11Ch]
  unsigned int v1039; // [sp+D8h] [bp-11Ch]
  int v1040; // [sp+D8h] [bp-11Ch]
  int v1041; // [sp+D8h] [bp-11Ch]
  int v1042; // [sp+D8h] [bp-11Ch]
  int v1043; // [sp+DCh] [bp-118h]
  unsigned int v1044; // [sp+DCh] [bp-118h]
  int v1045; // [sp+DCh] [bp-118h]
  int v1046; // [sp+DCh] [bp-118h]
  int v1047; // [sp+E0h] [bp-114h]
  unsigned int v1048; // [sp+E0h] [bp-114h]
  int v1049; // [sp+E0h] [bp-114h]
  int v1050; // [sp+E0h] [bp-114h]
  int v1051; // [sp+E4h] [bp-110h]
  int v1052; // [sp+E4h] [bp-110h]
  int v1053; // [sp+E4h] [bp-110h]
  int v1054; // [sp+E8h] [bp-10Ch]
  unsigned int v1055; // [sp+E8h] [bp-10Ch]
  int v1056; // [sp+E8h] [bp-10Ch]
  int v1057; // [sp+E8h] [bp-10Ch]
  int v1058; // [sp+ECh] [bp-108h]
  int v1059; // [sp+ECh] [bp-108h]
  int v1060; // [sp+ECh] [bp-108h]
  int v1061; // [sp+F0h] [bp-104h]
  int v1062; // [sp+F4h] [bp-100h]
  int v1063; // [sp+F4h] [bp-100h]
  int v1064; // [sp+F8h] [bp-FCh]
  int v1065; // [sp+FCh] [bp-F8h]
  int v1066; // [sp+100h] [bp-F4h]
  int v1067; // [sp+104h] [bp-F0h]
  int v1068; // [sp+108h] [bp-ECh]
  int v1069; // [sp+10Ch] [bp-E8h]
  int v1070; // [sp+110h] [bp-E4h]
  int v1071; // [sp+114h] [bp-E0h]
  int v1072; // [sp+118h] [bp-DCh]
  int v1073; // [sp+11Ch] [bp-D8h]
  int v1074; // [sp+120h] [bp-D4h]
  int v1075; // [sp+124h] [bp-D0h]
  int v1076; // [sp+128h] [bp-CCh]
  int v1077; // [sp+12Ch] [bp-C8h]
  int v1078; // [sp+130h] [bp-C4h]
  int v1079; // [sp+134h] [bp-C0h]
  int v1080; // [sp+138h] [bp-BCh]
  int v1081; // [sp+13Ch] [bp-B8h]
  int v1082; // [sp+140h] [bp-B4h]
  int v1083; // [sp+144h] [bp-B0h]
  int v1084; // [sp+148h] [bp-ACh]
  int v1085; // [sp+14Ch] [bp-A8h]
  int v1086; // [sp+150h] [bp-A4h]
  int v1087; // [sp+154h] [bp-A0h]
  int v1088; // [sp+158h] [bp-9Ch]
  int v1089; // [sp+15Ch] [bp-98h]
  int v1090; // [sp+160h] [bp-94h]
  int v1091; // [sp+160h] [bp-94h]
  int v1092; // [sp+160h] [bp-94h]
  int v1093; // [sp+160h] [bp-94h]
  unsigned int v1094; // [sp+160h] [bp-94h]
  int v1095; // [sp+164h] [bp-90h]
  int v1096; // [sp+164h] [bp-90h]
  unsigned int v1097; // [sp+164h] [bp-90h]
  int v1098; // [sp+164h] [bp-90h]
  int v1099; // [sp+168h] [bp-8Ch]
  int v1100; // [sp+168h] [bp-8Ch]
  unsigned int v1101; // [sp+168h] [bp-8Ch]
  int v1102; // [sp+168h] [bp-8Ch]
  unsigned int v1103; // [sp+16Ch] [bp-88h]
  int v1104; // [sp+16Ch] [bp-88h]
  _DWORD *v1105; // [sp+170h] [bp-84h]
  size_t n; // [sp+174h] [bp-80h]
  char *src; // [sp+178h] [bp-7Ch]
  int v1108; // [sp+17Ch] [bp-78h]
  unsigned int v1109; // [sp+17Ch] [bp-78h]
  int v1110; // [sp+17Ch] [bp-78h]
  int v1111; // [sp+17Ch] [bp-78h]
  int v1112; // [sp+17Ch] [bp-78h]
  int v1113; // [sp+180h] [bp-74h]
  int v1114; // [sp+180h] [bp-74h]
  int v1115; // [sp+180h] [bp-74h]
  int v1116; // [sp+184h] [bp-70h]
  int v1117; // [sp+184h] [bp-70h]
  unsigned int v1118; // [sp+184h] [bp-70h]
  int v1119; // [sp+188h] [bp-6Ch]
  unsigned int v1120; // [sp+188h] [bp-6Ch]
  int v1121; // [sp+18Ch] [bp-68h]
  int v1123; // [sp+198h] [bp-5Ch]
  int v1124; // [sp+19Ch] [bp-58h]
  int v1125; // [sp+1A0h] [bp-54h]
  int v1126; // [sp+1A4h] [bp-50h]
  int v1127; // [sp+1A8h] [bp-4Ch]
  int v1128; // [sp+1ACh] [bp-48h]
  int v1129; // [sp+1B0h] [bp-44h]
  int v1130; // [sp+1B4h] [bp-40h]
  int v1131; // [sp+1B8h] [bp-3Ch]
  int v1132; // [sp+1BCh] [bp-38h]
  int v1133; // [sp+1C0h] [bp-34h]
  int v1134; // [sp+1C4h] [bp-30h]
  int v1135; // [sp+1D0h] [bp-24h]
  int v1136; // [sp+1D4h] [bp-20h]

  v3 = *(_DWORD *)(a1 + 64);
  v4 = 64 - v3;
  n = a3;
  src = a2;
  if ( 64 - v3 > a3 )
  {
    result = memcpy((void *)(a1 + v3), a2, a3);
    *(_DWORD *)(a1 + 64) = v3 + n;
    return result;
  }
  v5 = *(_DWORD *)(a1 + 104);
  v6 = *(_DWORD *)(a1 + 72);
  v383 = *(_DWORD *)(a1 + 80);
  v7 = v5;
  v8 = *(_DWORD *)(a1 + 76);
  v9 = *(_DWORD *)(a1 + 136);
  v382 = *(_DWORD *)(a1 + 84);
  v788 = *(_DWORD *)(a1 + 88);
  v722 = *(_DWORD *)(a1 + 92);
  v638 = *(_DWORD *)(a1 + 96);
  v739 = *(_DWORD *)(a1 + 100);
  v707 = *(_DWORD *)(a1 + 108);
  v687 = *(_DWORD *)(a1 + 112);
  v432 = *(_DWORD *)(a1 + 116);
  v671 = *(_DWORD *)(a1 + 120);
  v655 = *(_DWORD *)(a1 + 124);
  v417 = *(_DWORD *)(a1 + 128);
  v402 = *(_DWORD *)(a1 + 132);
  v591 = *(_DWORD *)(a1 + 140);
  v558 = *(_DWORD *)(a1 + 160);
  v540 = *(_DWORD *)(a1 + 164);
  v577 = *(_DWORD *)(a1 + 144);
  v824 = *(_DWORD *)(a1 + 168);
  v446 = *(_DWORD *)(a1 + 148);
  v806 = *(_DWORD *)(a1 + 172);
  v384 = *(_DWORD *)(a1 + 152);
  v10 = *(void **)(a1 + 156);
  v772 = *(_DWORD *)(a1 + 176);
  result = v10;
  v755 = *(_DWORD *)(a1 + 180);
  v522 = *(_DWORD *)(a1 + 184);
  v506 = *(_DWORD *)(a1 + 188);
  v490 = *(_DWORD *)(a1 + 192);
  v605 = *(_DWORD *)(a1 + 196);
  if ( !n )
    goto LABEL_14;
  v12 = v6;
  v13 = v9;
  v14 = v8;
  v15 = v10;
  while ( 1 )
  {
    if ( v4 >= n )
      v4 = n;
    v16 = (void *)(a1 + v3);
    v3 += v4;
    memcpy(v16, src, v4);
    n -= v4;
    src += v4;
    if ( v3 == 64 )
      break;
    if ( !n )
      goto LABEL_13;
LABEL_5:
    v4 = 64 - v3;
  }
  v1105 = &unk_F2948;
  v1123 = *(_DWORD *)(a1 + 16);
  v12 ^= *(_DWORD *)a1;
  v1124 = *(_DWORD *)(a1 + 20);
  v1125 = *(_DWORD *)(a1 + 24);
  v1135 = *(_DWORD *)(a1 + 8);
  v1136 = *(_DWORD *)(a1 + 12);
  v1126 = *(_DWORD *)(a1 + 28);
  v1127 = *(_DWORD *)(a1 + 32);
  v1128 = *(_DWORD *)(a1 + 36);
  v1129 = *(_DWORD *)(a1 + 40);
  v1130 = *(_DWORD *)(a1 + 44);
  v1131 = *(_DWORD *)(a1 + 48);
  v1132 = *(_DWORD *)(a1 + 52);
  v1133 = *(_DWORD *)(a1 + 56);
  v1134 = *(_DWORD *)(a1 + 60);
  v17 = -1562454670;
  v18 = v382 ^ v1136;
  v788 ^= v1123;
  v722 ^= v1124;
  v638 ^= v1125;
  v739 ^= v1126;
  v707 ^= v1128;
  v687 ^= v1129;
  v432 ^= v1130;
  v671 ^= v1131;
  v655 ^= v1132;
  v1085 = -1788174341;
  v1083 = 791675867;
  v1086 = -2123104630;
  v1080 = -1298688259;
  v1078 = -1157369362;
  v417 ^= v1133;
  v1077 = -1460900796;
  v1076 = 2118452513;
  v1075 = 448323742;
  v1089 = 339902400;
  v1074 = 57437847;
  v1073 = 603768419;
  v402 ^= v1134;
  v1072 = -697966639;
  v19 = v14 ^ *(_DWORD *)(a1 + 4);
  v1071 = -1404818489;
  v20 = v5 ^ v1127;
  v1070 = 195517464;
  v21 = v383 ^ v1135;
  v1069 = -828915566;
  v1068 = -1667276067;
  v1067 = -1870738186;
  v1066 = 224013634;
  v1065 = -745471935;
  v1064 = -759227841;
  v1062 = 1350085175;
  v1061 = 964766730;
  v1058 = -802702345;
  v1054 = 358971612;
  v1051 = 1097580290;
  v1047 = -1844200944;
  v1043 = -590485666;
  v1038 = -1377094801;
  v1030 = 496344708;
  v1023 = -2145843940;
  v1016 = 272941447;
  v1009 = 179453760;
  v1001 = -619832934;
  v992 = 1549443843;
  v984 = 832756616;
  v975 = 437540533;
  v961 = -1974223886;
  v952 = -1265237402;
  v942 = -1701203354;
  v931 = -1714240253;
  v920 = -1661319844;
  v907 = -533030678;
  v895 = 1076613571;
  v879 = -984637618;
  v867 = -158901683;
  v853 = -1864979583;
  v842 = 1461003191;
  v460 = 169182331;
  v1088 = 1181927306;
  v1087 = 1818867960;
  v620 = (int)v15;
  v1090 = 1744311775;
  v1084 = 764241706;
  v1082 = 931499594;
  v1081 = -1753119852;
  v1079 = -94269859;
  while ( 1 )
  {
    v22 = v17 & ~v13 ^ v12;
    v23 = v19 ^ v1090 & ~v591;
    v24 = v460 & ~v577 ^ v21;
    v25 = ~v824 & v13 ^ v22;
    v26 = v842 & ~v446 ^ v18;
    v27 = v22 & v20 ^ v17;
    v28 = v853 & ~v384 ^ v788;
    v29 = v25 & v13 ^ v20;
    v30 = v13 & ~v20;
    v31 = v30 ^ v824;
    v32 = v30 ^ ~v824;
    v33 = v13 ^ v31 & v25;
    v475 = ~v806 & v591 ^ v23;
    v1108 = v23 & v707 ^ v1090;
    v789 = v29 & v33 ^ v32;
    v34 = v867 & ~v620 ^ v722;
    v35 = v879 & ~v558 ^ v638;
    v723 = v27 ^ v33;
    v639 = ~v772 & v577 ^ v24;
    v36 = v24 & v687 ^ v460;
    v461 = (v32 | v29) ^ v25;
    v1113 = v36;
    v37 = v895 & ~v540 ^ v739;
    v38 = ~v755 & v446 ^ v26;
    v39 = v671;
    v1116 = v26 & v432 ^ v842;
    v672 = v27 & v461 ^ v29;
    v40 = ~v522 & v384 ^ v28;
    v41 = v28 & v39 ^ v853;
    v42 = v39;
    v43 = v384 & ~v39;
    v44 = ~v522 ^ v43;
    v854 = v40 & v384 ^ v42;
    v45 = (v43 ^ v522) & v40 ^ v384;
    v46 = v41 ^ v45;
    v47 = (v44 | v854) ^ v40;
    v1119 = v45 & v854 ^ v44;
    v48 = v591 & ~v707;
    v385 = v48 ^ ~v806;
    v1095 = v47;
    v49 = v475 & v591;
    v592 = (v48 ^ v806) & v475 ^ v591;
    v523 = v49 ^ v707;
    v1121 = v41 & v47;
    v50 = ~v506 & v620 ^ v34;
    v51 = v558;
    v52 = v620 & ~v655;
    v708 = v34 & v655 ^ v867;
    v53 = v655;
    v656 = v52 ^ ~v506;
    v740 = ~v490 & v558 ^ v35;
    v54 = v558 & ~v417;
    v807 = v35 & v417 ^ v879;
    v55 = (v52 ^ v506) & v50 ^ v620;
    v507 = v620 & v50 ^ v53;
    v559 = v46 ^ v461 ^ v789;
    v825 = v54 ^ ~v490;
    v56 = (v54 ^ v490) & v740 ^ v51;
    v57 = v577 & ~v687;
    v58 = (v57 ^ v772) & v639 ^ v577;
    v621 = v57 ^ ~v772;
    v59 = ~v605 & v540 ^ v37;
    v491 = v740 & v51 ^ v417;
    v418 = v639 & v577 ^ v687;
    v60 = v540 & ~v402;
    v61 = v446 & ~v432;
    v62 = (v61 ^ v755) & v38 ^ v446;
    v63 = (v60 ^ v605) & v59 ^ v540;
    v688 = v61 ^ ~v755;
    v64 = v385;
    v843 = v37 & v402 ^ v895;
    v433 = v38 & v446 ^ v432;
    v541 = v59 & v540 ^ v402;
    v65 = v60 ^ ~v605;
    v447 = (v688 | v433) ^ v38;
    v386 = (v385 | v523) ^ v475;
    v403 = (v621 | v418) ^ v639;
    v578 = v523 & v592 ^ v64;
    v756 = (v656 | v507) ^ v50;
    v606 = v1108 ^ v592;
    v773 = (v825 | v491) ^ v740;
    v66 = v825;
    v826 = (v65 | v541) ^ v59;
    v67 = v491 & v56 ^ v66;
    v622 = v418 & v58 ^ v621;
    v689 = v433 & v62 ^ v688;
    v68 = v541 & v63 ^ v65 ^ v447;
    v593 = v1108 & v386 ^ v523;
    v524 = v708 & v756;
    v476 = v708 ^ v55 ^ v386 ^ v578;
    v69 = v507 & v55 ^ v656 ^ v386;
    v70 = v807 & v773 ^ v1113 ^ v58 ^ v491;
    v640 = v1113 & v403 ^ v418;
    v71 = v67 ^ v403;
    v492 = v56 ^ v807 ^ v403 ^ v622;
    v72 = v541 ^ v1116 ^ v62 ^ v843 & v826;
    v709 = v1116 & v447 ^ v433;
    v542 = v63 ^ v843 ^ v447 ^ v689;
    v880 = v723 ^ v854 ^ v1121;
    v73 = v723 ^ v461 ^ v1119 ^ v672 ^ v1095;
    v1109 = (2 * v69) & 0xAAAAAAAA;
    v868 = (v69 >> 1) & 0x55555555;
    v74 = v756;
    v757 = v72;
    v75 = v593 ^ v74;
    v76 = v524;
    v525 = v709 ^ v826;
    v77 = v606 ^ v507 ^ v76;
    v78 = v640 ^ v773;
    v434 = v69 ^ v606 ^ v75;
    v508 = v1113 ^ v58 ^ v71 ^ v640 ^ v773;
    v724 = v622 ^ v640 ^ v773;
    v607 = v789 ^ v672 ^ v1095;
    v741 = v689 ^ v709 ^ v826;
    v657 = v578 ^ v75;
    v579 = v1116 ^ v62 ^ v68 ^ v709 ^ v826;
    v690 = v461 ^ v880;
    v79 = (v559 >> 1) & 0x55555555 | (2 * v559) & 0xAAAAAAAA;
    v80 = (2 * v880) & 0xAAAAAAAA;
    v623 = ((v461 ^ (unsigned int)v1119) >> 1) & 0x55555555 | (2 * (v461 ^ v1119)) & 0xAAAAAAAA;
    v81 = (v880 >> 1) & 0x55555555;
    v855 = v386 ^ v77;
    v387 = (v476 >> 1) & 0x55555555 | (2 * v476) & 0xAAAAAAAA;
    v774 = v868 | v1109;
    v881 = v403 ^ v70;
    v1091 = v447 ^ v72;
    v404 = (v492 >> 1) & 0x55555555 | (2 * v492) & 0xAAAAAAAA;
    v790 = (v71 >> 1) & 0x55555555 | (2 * v71) & 0xAAAAAAAA;
    v419 = (v542 >> 1) & 0x55555555 | (2 * v542) & 0xAAAAAAAA;
    v1103 = (2 * v70) & 0xAAAAAAAA;
    v82 = (v70 >> 1) & 0x55555555;
    v808 = (v68 >> 1) & 0x55555555 | (2 * v68) & 0xAAAAAAAA;
    v83 = v672 ^ v559;
    v560 = v907 & ~v73 ^ v690;
    v84 = ((v672 ^ (unsigned int)v1095) >> 1) & 0x55555555 | (2 * (v672 ^ v1095)) & 0xAAAAAAAA;
    v1110 = v81 | v80;
    v673 = v593 ^ v476;
    v856 = v920 & ~v434 ^ v855;
    v448 = (v77 >> 1) & 0x55555555 | (2 * v77) & 0xAAAAAAAA;
    v691 = v640 ^ v492;
    v882 = v931 & ~v508 ^ v881;
    v710 = v709 ^ v542;
    v641 = ~v774;
    v477 = (v757 >> 1) & 0x55555555 | (2 * v757) & 0xAAAAAAAA;
    v85 = v84 ^ v952 & ~v79;
    v1092 = v942 & ~v579 ^ v1091;
    v86 = ((v78 >> 1) & 0x55555555 | (2 * v78) & 0xAAAAAAAA) ^ v975 & ~v404;
    v462 = v82 | v1103;
    v493 = v73 & ~v607 ^ v560;
    v543 = v434 & ~v657 ^ v856;
    v87 = ((v75 >> 1) & 0x55555555 | (2 * v75) & 0xAAAAAAAA) ^ v961 & ~v387;
    v594 = v579 & ~v741 ^ v1092;
    v88 = v83 & v560;
    v561 = v508 & ~v724 ^ v882;
    v1114 = v88;
    v89 = v73 & ~v83;
    v90 = v89 ^ v607;
    v758 = v89 ^ ~v607;
    v91 = v984 & ~v419 ^ ((v525 >> 1) & 0x55555555 | (2 * v525) & 0xAAAAAAAA);
    v608 = v79 & ~v623 ^ v85;
    v92 = v90 & v493 ^ v73;
    v526 = v73 & v493 ^ v83;
    v93 = v79 & ~v1110;
    v94 = v1110;
    v95 = v85 & v1110;
    v1096 = v93 ^ ~v623;
    v96 = v434 & ~v673;
    v844 = v96 ^ ~v657;
    v97 = (v96 ^ v657) & v543;
    v1111 = (v93 ^ v623) & v608 ^ v79;
    v624 = v79 & v608 ^ v94;
    v98 = v387 & ~v448;
    v1099 = ~v774 & v387 ^ v87;
    v953 = v95 ^ v952;
    v99 = v508 & ~v691;
    v100 = (v98 ^ v774) & v1099;
    v775 = v99 ^ ~v724;
    v101 = (v99 ^ v724) & v561 ^ v508;
    v658 = v404 & ~v790 ^ v86;
    v1117 = v673 & v856;
    v725 = v97 ^ v434;
    v869 = v98 ^ v641;
    v435 = v434 & v543 ^ v673;
    v102 = v404 & ~v462;
    v674 = v419 & ~v808 ^ v91;
    v103 = v100 ^ v387;
    v104 = (v102 ^ v790) & v658;
    v105 = v419 & ~v477;
    v857 = v87 & v448 ^ v961;
    v642 = v387 & v1099 ^ v448;
    v106 = v579 & ~v710;
    v107 = ~v790;
    v791 = v106 ^ ~v741;
    v896 = v102 ^ v107;
    v388 = v508 & v561 ^ v691;
    v108 = v691 & v882;
    v109 = v104 ^ v404;
    v110 = v579 & v594 ^ v710;
    v883 = v86 & v462 ^ v975;
    v111 = (v105 ^ v808) & v674 ^ v419;
    v405 = v404 & v658 ^ v462;
    v463 = v419 & v674 ^ v477;
    v962 = v91 & v477 ^ v984;
    v976 = v105 ^ ~v808;
    v809 = (v106 ^ v741) & v594 ^ v579;
    v420 = (v758 | v526) ^ v493;
    v449 = (v844 | v435) ^ v543;
    v112 = v857 ^ v103;
    v113 = v642 & v103;
    v114 = v108 ^ v931;
    v494 = (v775 | v388) ^ v561;
    v115 = v883 ^ v109;
    v562 = v710 & v1092 ^ v942;
    v544 = (v791 | v110) ^ v594;
    v478 = v526 & v92 ^ v758;
    v692 = v1114 ^ v907 ^ v92;
    v827 = (v1096 | v624) ^ v608;
    v609 = v435 & v725 ^ v844;
    v711 = v1117 ^ v920 ^ v725;
    v845 = (v869 | v642) ^ v1099;
    v726 = v388 & v101 ^ v775;
    v742 = v114 ^ v101;
    v116 = v405 & v109 ^ v494;
    v117 = (v976 | v463) ^ v674;
    v776 = (v896 | v405) ^ v658;
    v759 = v809 ^ v562;
    v118 = v562 & v544;
    v659 = v110 & v809 ^ v791;
    v595 = (v1114 ^ v907) & v420 ^ v526;
    v527 = v953 ^ v1111 ^ v420 ^ v478;
    v119 = v624 & v1111 ^ v420 ^ v1096;
    v792 = v692 ^ v624;
    v625 = (v1117 ^ v920) & v449 ^ v435;
    v563 = v112 ^ v449 ^ v609;
    v120 = v113 ^ v449 ^ v869;
    v121 = v711 ^ v642;
    v643 = v114 & v494 ^ v388;
    v580 = v115 ^ v494 ^ v726;
    v122 = v116 ^ v896;
    v123 = v962 & v117;
    v124 = v463 & v111 ^ v544 ^ v976;
    v389 = v759 ^ v463;
    v675 = v118 ^ v110;
    v509 = v111 ^ v962 ^ v544 ^ v659;
    v125 = v953 & v827 ^ v792;
    v126 = v827 ^ v595;
    v1118 = (4 * v120) & 0xCCCCCCCC;
    v870 = (v120 >> 2) & 0x33333333;
    v1120 = (4 * v122) & 0xCCCCCCCC;
    v897 = (v122 >> 2) & 0x33333333;
    v963 = (4 * (v827 ^ v595)) & 0xCCCCCCCC;
    v127 = v120 ^ v711 ^ v625 ^ v845;
    v128 = v121 ^ v857 & v845;
    v129 = v643 ^ v776;
    v464 = v692 ^ v119 ^ v827 ^ v595;
    v130 = v742 ^ v405 ^ v883 & v776;
    v977 = (4 * v125) & 0xCCCCCCCC;
    v131 = v123 ^ v389;
    v132 = v117 ^ v675;
    v406 = v124 ^ v759 ^ v132;
    v712 = v478 ^ v827 ^ v595;
    v693 = ((v625 ^ (unsigned int)v845) >> 2) & 0x33333333;
    v760 = (v125 >> 2) & 0x33333333;
    v133 = (4 * (v625 ^ v845)) & 0xCCCCCCCC;
    v985 = (4 * (v643 ^ v776)) & 0xCCCCCCCC;
    v954 = ((v643 ^ (unsigned int)v776) >> 2) & 0x33333333;
    v777 = v609 ^ v625 ^ v845;
    v727 = v726 ^ v129;
    v390 = v122 ^ v742 ^ v129;
    v793 = v659 ^ v132;
    v134 = v992 & ~v464 ^ v125 ^ v420;
    v479 = (v527 >> 2) & 0x33333333 | (4 * v527) & 0xCCCCCCCC;
    v135 = v127;
    v810 = (v119 >> 2) & 0x33333333 | (4 * v119) & 0xCCCCCCCC;
    v421 = (v563 >> 2) & 0x33333333 | (4 * v563) & 0xCCCCCCCC;
    v828 = v870 | v1118;
    v871 = ~v712;
    v436 = (v580 >> 2) & 0x33333333 | (4 * v580) & 0xCCCCCCCC;
    v136 = v1001 & ~v127 ^ v128 ^ v449;
    v1093 = v544 ^ v131;
    v884 = v134;
    v450 = (v509 >> 2) & 0x33333333 | (4 * v509) & 0xCCCCCCCC;
    v921 = ~v727;
    v858 = (v124 >> 2) & 0x33333333 | (4 * v124) & 0xCCCCCCCC;
    v943 = ~(v659 ^ v132);
    v137 = v1023 & ~v479 ^ ((v126 >> 2) & 0x33333333 | v963);
    v743 = v595 ^ v527;
    v528 = v760 | v977;
    v964 = ~v810;
    v908 = v136;
    v761 = v135;
    v626 = v625 ^ v563;
    v138 = (v693 | v133) ^ v1030 & ~v421;
    v978 = ~v828;
    v932 = v1009 & ~v390 ^ v130 ^ v494;
    v545 = (v128 >> 2) & 0x33333333 | (4 * v128) & 0xCCCCCCCC;
    v495 = v643 ^ v580;
    v139 = v954 | v985;
    v986 = ~(v897 | v1120);
    v510 = v675 ^ v509;
    v564 = (v130 >> 2) & 0x33333333 | (4 * v130) & 0xCCCCCCCC;
    v955 = v1016 & ~v406 ^ v1093;
    v140 = v1043 & ~v450 ^ ((v132 >> 2) & 0x33333333 | (4 * v132) & 0xCCCCCCCC);
    v581 = (v131 >> 2) & 0x33333333 | (4 * v131) & 0xCCCCCCCC;
    v596 = v464 & ~v712 ^ v134;
    v141 = v464 & ~v743;
    v610 = v135 & ~v777 ^ v908;
    v142 = v135 & ~v626;
    v644 = v390 & ~v727 ^ v932;
    v143 = v1038 & ~v436 ^ v139;
    v660 = v406 & v943 ^ v955;
    v676 = v479 & ~v810 ^ v137;
    v144 = v390 & ~v495;
    v145 = v141 ^ v712;
    v713 = v421 & ~v828 ^ v138;
    v146 = v137 & v528;
    v147 = v421 & ~v545 ^ v828;
    v148 = v727;
    v149 = (v479 & ~v528 ^ v810) & v676;
    v728 = v436 & v986 ^ v143;
    v829 = (v142 ^ v777) & v610;
    v1104 = v545 & v138;
    v811 = v142 ^ ~v777;
    v778 = v141 ^ v871;
    v150 = v406 & ~v510;
    v151 = v436 & ~v564;
    v152 = v150 ^ v793;
    v153 = (v144 ^ v148) & v644;
    v794 = v144 ^ v921;
    v1112 = v564 & v143;
    v154 = (v151 ^ (v897 | v1120)) & v728;
    v155 = v450 & ~v858 ^ v140;
    v1100 = v152 & v660;
    v156 = v150 ^ v943;
    v157 = v743;
    v846 = v156;
    v158 = v450 & ~v581;
    v1115 = v581 & v140;
    v159 = v626;
    v944 = v743 & v884;
    v744 = v145 & v596 ^ v464;
    v465 = v464 & v596 ^ v157;
    v627 = v761 & v610 ^ v626;
    v872 = v479 & ~v528 ^ v964;
    v160 = v149 ^ v479;
    v161 = v479 & v676;
    v480 = v390 & v644 ^ v495;
    v694 = v161 ^ v528;
    v529 = v406 & v660 ^ v510;
    v898 = v421 & ~v545 ^ v978;
    v762 = v829 ^ v761;
    v162 = v147 & v713 ^ v421;
    v546 = v421 & v713 ^ v545;
    v965 = v495 & v932;
    v830 = v153 ^ v390;
    v391 = v436 & v728 ^ v564;
    v163 = v154 ^ v436;
    v922 = v151 ^ v986;
    v565 = v510 & v955;
    v511 = v1100 ^ v406;
    v496 = v450 & v155 ^ v581;
    v933 = v158 ^ ~v858;
    v164 = (v158 ^ v858) & v155 ^ v450;
    v407 = (v778 | v465) ^ v596;
    v437 = (v794 | v480) ^ v644;
    v165 = v159 & v908 ^ v1001;
    v422 = (v811 | v627) ^ v610;
    v1002 = v391 & v163;
    v166 = v1112 ^ v1038 ^ v163;
    v451 = (v846 | v529) ^ v660;
    v566 = v565 ^ v1016;
    v597 = v465 & v744 ^ v778;
    v645 = v944 ^ v992 ^ v744;
    v779 = (v872 | v694) ^ v676;
    v661 = v627 & v762 ^ v811;
    v812 = (v898 | v546) ^ v713;
    v677 = v165 ^ v762;
    v714 = v480 & v830 ^ v794;
    v167 = v830;
    v831 = v155 ^ (v933 | v496);
    v745 = v965 ^ v1009 ^ v167;
    v795 = (v922 | v391) ^ v728;
    v729 = v529 & v511 ^ v846;
    v763 = v511 ^ v566;
    v168 = v566 & v451;
    v169 = v1115 ^ v1043 ^ v164 ^ v451;
    v611 = (v944 ^ v992) & v407 ^ v465;
    v512 = v146 ^ v1023 ^ v160 ^ v407 ^ v597;
    v170 = v160 & v694 ^ v407 ^ v872;
    v171 = v645 ^ v694 ^ (v146 ^ v1023) & v779;
    v628 = v165 & v422 ^ v627;
    v567 = v1104 ^ v1030 ^ v162 ^ v422 ^ v661;
    v172 = v546 & v162 ^ v422 ^ v898;
    v173 = v677 ^ v546;
    v547 = (v965 ^ v1009) & v437 ^ v480;
    v174 = v166 ^ v437 ^ v714;
    v175 = v1002 ^ v437 ^ v922;
    v695 = v168 ^ v529;
    v176 = v164 & v496 ^ v451 ^ v933;
    v966 = (16 * v170) & 0xF0F0F0F0;
    v873 = (v170 >> 4) & 0xF0F0F0F;
    v885 = (v172 >> 4) & 0xF0F0F0F;
    v987 = (16 * v172) & 0xF0F0F0F0;
    v899 = (v175 >> 4) & 0xF0F0F0F;
    v1097 = (16 * v175) & 0xF0F0F0F0;
    v582 = v169 ^ v729;
    v859 = ((v169 ^ (unsigned int)v729) >> 4) & 0xF0F0F0F;
    v1094 = (16 * (v169 ^ v729)) & 0xF0F0F0F0;
    v1101 = (16 * v176) & 0xF0F0F0F0;
    v934 = (v176 >> 4) & 0xF0F0F0F;
    v979 = (16 * (v779 ^ v611)) & 0xF0F0F0F0;
    v530 = ((v779 ^ v611) >> 4) & 0xF0F0F0F;
    v177 = v173 ^ (v1104 ^ v1030) & v812;
    v178 = v172 ^ v677 ^ v628 ^ v812;
    v179 = v547 ^ v795;
    v909 = v175 ^ v745;
    v180 = v745 ^ v391 ^ (v1112 ^ v1038) & v795;
    v181 = v176 ^ v763;
    v182 = (v1115 ^ v1043) & v831 ^ v763 ^ v496;
    v183 = v645 ^ v170 ^ v779 ^ v611;
    v780 = v597 ^ v779 ^ v611;
    v993 = (16 * (v628 ^ v812)) & 0xF0F0F0F0;
    v392 = v183;
    v662 = v661 ^ v628 ^ v812;
    v1024 = (16 * v177) & 0xF0F0F0F0;
    v184 = ((v628 ^ (unsigned int)v812) >> 4) & 0xF0F0F0F;
    v1010 = (16 * (v547 ^ v795)) & 0xF0F0F0F0;
    v746 = (v177 >> 4) & 0xF0F0F0F;
    v646 = ((v547 ^ (unsigned int)v795) >> 4) & 0xF0F0F0F;
    v678 = ((v831 ^ (unsigned int)v695) >> 4) & 0xF0F0F0F;
    v1039 = (16 * v180) & 0xF0F0F0F0;
    v764 = (v180 >> 4) & 0xF0F0F0F;
    v1031 = (16 * (v831 ^ v695)) & 0xF0F0F0F0;
    v1044 = (16 * v182) & 0xF0F0F0F0;
    v796 = (v182 >> 4) & 0xF0F0F0F;
    v813 = v714 ^ v179;
    v185 = v181 ^ v831 ^ v695;
    v945 = ~v780;
    v832 = v729 ^ v831 ^ v695;
    v186 = v407;
    v408 = (v512 >> 4) & 0xF0F0F0F | (16 * v512) & 0xF0F0F0F0;
    v187 = v183;
    v188 = v873 | v966;
    v466 = v178;
    v481 = v909 ^ v179;
    v189 = v1051 & ~v178 ^ v177 ^ v422;
    v967 = ~v662;
    v423 = (v567 >> 4) & 0xF0F0F0F | (16 * v567) & 0xF0F0F0F0;
    v910 = v885 | v987;
    v190 = v180 ^ v437;
    v988 = ~(v714 ^ v179);
    v497 = v185;
    v438 = (v174 >> 4) & 0xF0F0F0F | (16 * v174) & 0xF0F0F0F0;
    v923 = v899 | v1097;
    v1003 = ~v832;
    v191 = v1058 & ~v185 ^ v182 ^ v451;
    v452 = v859 | v1094;
    v956 = v1047 & ~v183 ^ v171 ^ v186;
    v935 = v934 | v1101;
    v192 = v979;
    v980 = v189;
    v513 = v611 ^ v512;
    v193 = v187 & ~v780;
    v194 = (v530 | v192) ^ v1061 & ~v408;
    v531 = v628 ^ v567;
    v195 = v184 | v993;
    v1017 = ~v910;
    v612 = v746 | v1024;
    v548 = v547 ^ v174;
    v994 = v1054 & ~v481 ^ v190;
    v196 = v646 | v1010;
    v1011 = v191;
    v1025 = ~(v899 | v1097);
    v629 = v764 | v1039;
    v568 = v695 ^ v582;
    v197 = v1065 & ~(v859 | v1094) ^ (v678 | v1031);
    v1032 = ~v935;
    v583 = v796 | v1044;
    v647 = v193 ^ v956;
    v198 = v392 & ~v513;
    v679 = v466 & ~v662 ^ v980;
    v199 = v1062 & ~v423 ^ v195;
    v715 = v481 & v988 ^ v994;
    v200 = v1064 & ~v438 ^ v196;
    v765 = v481 & ~v548;
    v747 = v185 & ~v832 ^ v191;
    v900 = (v859 | v1094) & ~(v796 | v1044);
    v201 = v780;
    v781 = v408 & ~v188 ^ v194;
    v797 = v423 & ~v910 ^ v199;
    v202 = v423 & ~v612 ^ v910;
    v1040 = v466 & ~v531 ^ v662;
    v203 = v813;
    v814 = v438 & v1025 ^ v200;
    v204 = v438 & ~v629 ^ v923;
    v1098 = v497 & ~v568 ^ v832;
    v833 = (v859 | v1094) & ~v935 ^ v197;
    v1102 = v900 ^ v935;
    v663 = v392 & v647 ^ v513;
    v911 = v198 ^ v945;
    v696 = v466 & v679 ^ v531;
    v924 = v466 & ~v531 ^ v967;
    v968 = v612 & v199;
    v730 = v481 & v715 ^ v548;
    v205 = (v765 ^ v203) & v715;
    v936 = v765 ^ v988;
    v766 = v497 & v747 ^ v568;
    v847 = v497 & ~v568 ^ v1003;
    v1004 = v583 & v197;
    v206 = v513 & v956;
    v207 = (v198 ^ v201) & v647 ^ v392;
    v208 = v198 ^ v945 | v663;
    v393 = v408 & v781 ^ ((v171 >> 4) & 0xF0F0F0F | (16 * v171) & 0xF0F0F0F0);
    v946 = v408 & ~((v171 >> 4) & 0xF0F0F0F | (16 * v171) & 0xF0F0F0F0) ^ ~v188;
    v209 = (v408 & ~((v171 >> 4) & 0xF0F0F0F | (16 * v171) & 0xF0F0F0F0) ^ v188) & v781 ^ v408;
    v860 = v194 & ((v171 >> 4) & 0xF0F0F0F | (16 * v171) & 0xF0F0F0F0) ^ v1061;
    v210 = v531 & v980;
    v211 = v1040 & v679 ^ v466;
    v409 = v423 & v797 ^ v612;
    v957 = v423 & ~v612 ^ v1017;
    v212 = v202 & v797 ^ v423;
    v874 = v968 ^ v1062;
    v467 = v548 & v994;
    v424 = v438 & v814 ^ v629;
    v532 = v205 ^ v481;
    v969 = v438 & ~v629 ^ v1025;
    v213 = v204 & v814 ^ v438;
    v886 = v629 & v200 ^ v1064;
    v549 = v1098 & v747 ^ v497;
    v498 = v452 & v833 ^ v583;
    v901 = v900 ^ v1032;
    v214 = v1102 & v833 ^ v452;
    v439 = v208 ^ v647;
    v215 = v210 ^ v1051;
    v453 = (v924 | v696) ^ v679;
    v216 = v409 & v212;
    v217 = v874 ^ v212;
    v218 = v467 ^ v1054;
    v468 = (v936 | v730) ^ v715;
    v219 = v424 & v213;
    v995 = v886 ^ v213;
    v220 = v568 & v1011 ^ v1058;
    v482 = (v847 | v766) ^ v747;
    v221 = v206 ^ v1047;
    v630 = v215 ^ v211;
    v514 = v663 & v207 ^ v911;
    v584 = v207 ^ v221;
    v912 = v209 & v393 ^ v208 ^ v647;
    v222 = (v946 | v393) ^ v781;
    v598 = v696 & v211 ^ v924;
    v782 = (v957 | v409) ^ v797;
    v648 = v730 & v532 ^ v936;
    v680 = v218 ^ v532;
    v798 = (v969 | v424) ^ v814;
    v716 = v766 & v549 ^ v847;
    v748 = v220 ^ v549;
    v815 = (v901 | v498) ^ v833;
    v550 = v221 & v439 ^ v663;
    v834 = v860 & v222;
    v223 = v207 ^ v221 ^ v393;
    v613 = v215 & v453 ^ v696;
    v664 = v218 & v468 ^ v730;
    v533 = v217 ^ v453 ^ v598;
    v224 = v216 ^ v453 ^ v957;
    v225 = v995 ^ v468 ^ v648;
    v226 = v219 ^ v468 ^ v969;
    v697 = v220 & v482 ^ v766;
    v227 = v222 ^ v550;
    v569 = v1004 ^ v1065 ^ v214 ^ v482 ^ v716;
    v228 = v214 & v498 ^ v482 ^ v901;
    v229 = v584;
    v585 = v860 ^ v209 ^ v439 ^ v514;
    v230 = v229 ^ v912 ^ v946;
    v231 = v223 ^ v834;
    v1048 = ((v912 ^ v946) << 8) & 0xFF00FF00;
    v913 = ((v912 ^ v946) >> 8) & 0xFF00FF;
    v947 = (v226 >> 8) & 0xFF00FF;
    v1055 = (v226 << 8) & 0xFF00FF00;
    v1012 = (v231 << 8) & 0xFF00FF00;
    v861 = (v231 >> 8) & 0xFF00FF;
    v232 = v215 ^ v211 ^ v409 ^ v874 & v782;
    v233 = v226 ^ v680;
    v394 = v230 ^ v227;
    v234 = v680 ^ v424 ^ v886 & v798;
    v731 = v598 ^ v613 ^ v782;
    v235 = v748 ^ v498 ^ (v1004 ^ v1065) & v815;
    v425 = v228 ^ v748;
    v410 = v224 ^ v630 ^ v613 ^ v782;
    v236 = v514 ^ v227;
    v1026 = (v232 << 8) & 0xFF00FF00;
    v599 = (v232 >> 8) & 0xFF00FF;
    v1033 = (v234 << 8) & 0xFF00FF00;
    v749 = (v234 >> 8) & 0xFF00FF;
    v1018 = ((v815 ^ v697) << 8) & 0xFF00FF00;
    v681 = ((v815 ^ (unsigned int)v697) >> 8) & 0xFF00FF;
    v767 = v648 ^ v664 ^ v798;
    v835 = v716 ^ v815 ^ v697;
    v426 = v425 ^ v815 ^ v697;
    v937 = ~(v514 ^ v227);
    v237 = v1066 & ~(v230 ^ v227) ^ v231 ^ v439;
    v499 = v233 ^ v664 ^ v798;
    v440 = (v585 >> 8) & 0xFF00FF | (v585 << 8) & 0xFF00FF00;
    v238 = v913 | v1048;
    v239 = v1067 & ~v410 ^ v232 ^ v453;
    v454 = (v533 >> 8) & 0xFF00FF | (v533 << 8) & 0xFF00FF00;
    v816 = (v224 >> 8) & 0xFF00FF | (v224 << 8) & 0xFF00FF00;
    v240 = v234 ^ v468;
    v469 = (v225 >> 8) & 0xFF00FF | (v225 << 8) & 0xFF00FF00;
    v914 = v947 | v1055;
    v649 = v482 ^ v235;
    v996 = ~v835;
    v483 = (v569 >> 8) & 0xFF00FF | (v569 << 8) & 0xFF00FF00;
    v925 = (v228 >> 8) & 0xFF00FF | (v228 << 8) & 0xFF00FF00;
    v970 = v239;
    v515 = v550 ^ v585;
    v1049 = ~v238;
    v586 = v861 | v1012;
    v534 = v613 ^ v533;
    v241 = ((v613 ^ v782) >> 8) & 0xFF00FF | ((v613 ^ v782) << 8) & 0xFF00FF00;
    v1013 = ~v816;
    v600 = v599 | v1026;
    v551 = v664 ^ v225;
    v989 = v1068 & ~v499 ^ v240;
    v1027 = ~v914;
    v614 = v749 | v1033;
    v570 = v697 ^ v569;
    v1005 = v1069 & ~v426 ^ v649;
    v242 = v1073 & ~v483 ^ (v681 | v1018);
    v1041 = ~v925;
    v631 = (v235 >> 8) & 0xFF00FF | (v235 << 8) & 0xFF00FF00;
    v698 = ((v227 >> 8) & 0xFF00FF | (v227 << 8) & 0xFF00FF00) ^ v1070 & ~v440;
    v650 = (v230 ^ v227) & v937 ^ v237;
    v243 = (v230 ^ v227) & ~v515;
    v862 = v440 & ~v586;
    v682 = v410 & ~v731 ^ v970;
    v244 = v410 & ~v534;
    v1019 = v1071 & ~v454 ^ v241;
    v717 = v499 & ~v767 ^ v989;
    v245 = v499 & ~v551;
    v1034 = (((v664 ^ (unsigned int)v798) >> 8) & 0xFF00FF | ((v664 ^ v798) << 8) & 0xFF00FF00) ^ v1072 & ~v469;
    v887 = v469 & ~v614;
    v750 = v426 & ~v835 ^ v1005;
    v1045 = v242;
    v902 = v483 & ~v631;
    v783 = v440 & ~v238 ^ v698;
    v799 = v454 & ~v816 ^ v1019;
    v246 = v454 & ~v600 ^ v816;
    v1056 = v862 ^ v238;
    v247 = v731;
    v817 = v469 & ~v914 ^ v1034;
    v248 = v887 ^ v914;
    v249 = v426 & ~v570 ^ v835;
    v836 = v483 & ~v925 ^ v242;
    v250 = v902 ^ v925;
    v665 = v394 & v650 ^ v515;
    v915 = v243 ^ v937;
    v938 = v698 & v586;
    v699 = v410 & v682 ^ v534;
    v926 = v244 ^ ~v731;
    v1020 = v600 & v1019;
    v732 = v499 & v717 ^ v551;
    v958 = v245 ^ ~v767;
    v251 = (v245 ^ v767) & v717;
    v1035 = v1034 & v614;
    v768 = v426 & v750 ^ v570;
    v981 = v426 & ~v570 ^ v996;
    v252 = v515 & v237;
    v848 = (v243 ^ v236) & v650 ^ v394;
    v395 = v440 & v783 ^ v586;
    v253 = v1056 & v783 ^ v440;
    v948 = v938 ^ v1070;
    v939 = (v244 ^ v247) & v682 ^ v410;
    v411 = v454 & v799 ^ v600;
    v254 = v246 & v799 ^ v454;
    v255 = v551 & v989;
    v552 = v251 ^ v499;
    v500 = v469 & v817 ^ v614;
    v256 = v248 & v817 ^ v469;
    v257 = v570 & v1005;
    v571 = v249 & v750 ^ v426;
    v427 = v483 & v836 ^ v631;
    v258 = v250 & v836 ^ v483;
    v997 = v631 & v1045 ^ v1073;
    v484 = (v915 | v665) ^ v650;
    v259 = v454 & ~v600;
    v455 = v534 & v970 ^ v1067;
    v260 = v948 ^ v253;
    v261 = (v926 | v699) ^ v682;
    v470 = v255 ^ v1068;
    v516 = (v958 | v732) ^ v717;
    v718 = v887 ^ v1027;
    v262 = v257 ^ v1069;
    v535 = (v981 | v768) ^ v750;
    v875 = v997 ^ v258;
    v587 = v665 & v848 ^ v915;
    v916 = v253 & v395 ^ v484;
    v601 = v699 & v939 ^ v926;
    v615 = v732 & v552 ^ v958;
    v263 = v1035 ^ v1072 ^ v256 ^ v516;
    v264 = v256 & v500 ^ v516;
    v265 = v887 ^ v1027;
    v888 = (v255 ^ v1068) & v516;
    v683 = v768 & v571 ^ v981;
    v266 = v265 | v500;
    v267 = v264;
    v927 = v258 & v427 ^ v535;
    v441 = v252 ^ v1066 ^ v848;
    v632 = (v252 ^ v1066) & v484 ^ v665;
    v268 = (v862 ^ v1049 | v395) ^ v783;
    v269 = v916 ^ v862 ^ v1049;
    v784 = v260 ^ v484 ^ v587;
    v270 = v455 ^ v939;
    v651 = v455 & v261 ^ v699;
    v271 = (v259 ^ v1013 | v411) ^ v799;
    v700 = v254 & v411 ^ v261 ^ v259 ^ v1013;
    v800 = v1020 ^ v1071 ^ v254 ^ v261 ^ v601;
    v272 = v262 & v535;
    v666 = v888 ^ v732;
    v273 = v470 ^ v552;
    v274 = v266 ^ v817;
    v275 = v267 ^ v718;
    v733 = v263 ^ v615;
    v276 = v262 ^ v571;
    v751 = v272 ^ v768;
    v277 = v927 ^ v902 ^ v1041;
    v278 = (v902 ^ v1041 | v427) ^ v836;
    v849 = v875 ^ v535 ^ v683;
    v279 = v632 ^ v268;
    v396 = v441 ^ v395;
    v280 = v441 ^ v269;
    v442 = __ROR4__(v784, 16);
    v553 = v651 ^ v271;
    v456 = __ROR4__(v733, 16);
    v889 = __ROR4__(v269, 16);
    v572 = v666 ^ v274;
    v471 = __ROR4__(v849, 16);
    v903 = __ROR4__(v700, 16);
    v928 = __ROR4__(v277, 16);
    v917 = __ROR4__(v275, 16);
    v281 = v500;
    v501 = v275 ^ v273;
    v282 = v274 & (v1035 ^ v1072) ^ v273 ^ v281;
    v283 = v751 ^ v278;
    v284 = v278 & v997 ^ v276 ^ v427;
    v769 = v587 ^ v632 ^ v268;
    v285 = v268 & v948 ^ v396;
    v818 = v601 ^ v651 ^ v271;
    v397 = v270 ^ v700 ^ v651 ^ v271;
    v286 = v271 & (v1020 ^ v1071) ^ v270 ^ v411;
    v837 = v615 ^ v572;
    v412 = v501 ^ v572;
    v863 = v683 ^ v283;
    v428 = v276 ^ v277 ^ v283;
    v602 = __ROR4__(v286, 16);
    v287 = v484 ^ v285;
    v588 = __ROR4__(v285, 16);
    v485 = v280 ^ v279;
    v616 = __ROR4__(v282, 16);
    v502 = __ROR4__(v800, 16);
    v876 = __ROR4__(v284, 16);
    v1021 = v1078 & ~v442 ^ __ROR4__(v279, 16);
    v949 = v1074 & ~(v280 ^ v279) ^ v287;
    v971 = v1075 & ~v397 ^ v286 ^ v261;
    v1050 = v1081 & ~v471 ^ __ROR4__(v283, 16);
    v288 = v1076 & ~v412 ^ v282 ^ v516;
    v1014 = ~v889;
    v1042 = v1080 & ~v456 ^ __ROR4__(v572, 16);
    v1028 = v1079 & ~v502 ^ __ROR4__(v553, 16);
    v998 = v1077 & ~v428 ^ v284 ^ v535;
    v289 = v632 ^ v784;
    v1057 = ~(v683 ^ v283);
    v1036 = ~v917;
    v1046 = ~v928;
    v701 = v442 & ~v588;
    v290 = (v280 ^ v279) & ~v769 ^ v949;
    v291 = v651 ^ v800;
    v990 = v412 & ~v837 ^ v288;
    v1059 = ~v903;
    v292 = v666 ^ v733;
    v517 = v751 ^ v849;
    v1052 = v397 & ~v818 ^ v971;
    v734 = v456 & ~v616;
    v1006 = v428 & v1057 ^ v998;
    v752 = v471 & ~v876;
    v554 = v485 & ~(v632 ^ v784);
    v536 = v442 & ~v889 ^ v1021;
    v633 = v397 & ~(v651 ^ v800);
    v573 = v502 & ~v903 ^ v1028;
    v652 = v456 & ~v917 ^ v1042;
    v293 = v412 & ~v292;
    v294 = v734 ^ v917;
    v295 = v428 & ~v517;
    v684 = v471 & ~v928 ^ v1050;
    v296 = v752 ^ v928;
    v801 = v485 & v290 ^ v289;
    v785 = ~v769 ^ v554;
    v297 = (v701 ^ v889) & v536;
    v890 = v397 & v1052 ^ v291;
    v850 = v633 ^ ~v818;
    v298 = (v502 & ~v602 ^ v903) & v573;
    v904 = v293 ^ ~v837;
    v940 = v428 & v1006 ^ v517;
    v929 = v295 ^ v1057;
    v982 = v289 & v949;
    v299 = (v554 ^ v769) & v290;
    v950 = v297 ^ v442;
    v555 = v442 & v536 ^ v588;
    v819 = v633 ^ v818;
    v959 = v298 ^ v502;
    v634 = v502 & v573 ^ v602;
    v918 = v412 & v990 ^ v292;
    v300 = v293 ^ v837;
    v838 = v294 & v652 ^ v456;
    v667 = v456 & v652 ^ v616;
    v301 = v517 & v998;
    v302 = v863;
    v864 = v296 & v684 ^ v471;
    v518 = v471 & v684 ^ v876;
    v443 = (v785 | v801) ^ v290;
    v303 = v701 ^ v1014;
    v304 = v291 & v971 ^ v1075;
    v457 = (v850 | v890) ^ v1052;
    v702 = v819 & v1052;
    v305 = v502 & ~v602 ^ v1059;
    v820 = v292 & v288 ^ v1076;
    v472 = (v904 | v918) ^ v990;
    v306 = v616 & v1042;
    v307 = v734 ^ v1036;
    v617 = v301 ^ v1077;
    v503 = (v295 ^ v1057 | v940) ^ v1006;
    v308 = v299 ^ v485;
    v486 = v588 & v1021 ^ v1078;
    v309 = v702 ^ v397;
    v398 = v602 & v1028 ^ v1079;
    v735 = v300 & v990 ^ v412;
    v413 = v306 ^ v1080;
    v310 = (v295 ^ v302) & v1006 ^ v428;
    v429 = v876 & v1050 ^ v1081;
    v311 = v752 ^ v1046 | v518;
    v877 = v518 & v864 ^ v752 ^ v1046;
    v312 = v801;
    v802 = v801 & v308;
    v313 = v308 ^ v982 ^ v1074;
    v703 = (v982 ^ v1074) & v443 ^ v312;
    v314 = (v303 | v555) ^ v536;
    v589 = v443 ^ v303 ^ v555 & v950;
    v315 = v304 & v457 ^ v890;
    v316 = v890 & v309;
    v317 = v309 ^ v304;
    v891 = v316;
    v318 = (v305 | v634) ^ v573;
    v603 = v457 ^ v305 ^ v634 & v959;
    v753 = v820 & v472 ^ v918;
    v319 = v918 & v735;
    v719 = v315;
    v320 = (v307 | v667) ^ v652;
    v321 = v413 ^ v838;
    v322 = v735 ^ v820;
    v653 = v472 ^ v307 ^ v667 & v838;
    v323 = v940 & v310;
    v324 = v310 ^ v617;
    v770 = v617 & v503 ^ v940;
    v325 = v311 ^ v684;
    v685 = v503 ^ v877;
    v326 = v802 ^ v785;
    v839 = v314 & v486;
    v736 = v313 ^ v555;
    v556 = v719 ^ v318;
    v327 = v318 & v398;
    v328 = v398 ^ v959 ^ v457 ^ v891 ^ v850;
    v399 = v317 ^ v634;
    v329 = v319 ^ v904;
    v618 = v753 ^ v320;
    v330 = v320 & v413;
    v786 = v322 ^ v667;
    v331 = v323 ^ v929;
    v635 = v770 ^ v325;
    v332 = v325 & v429;
    v668 = v429 ^ v864 ^ v503;
    v803 = v324 ^ v518;
    v487 = v486 ^ v950 ^ v443 ^ v326;
    v537 = v703 ^ v314;
    v821 = v326 ^ v703 ^ v314;
    v333 = v313 ^ v589 ^ v703 ^ v314;
    v430 = v839 ^ v736;
    v334 = v556 ^ v317 ^ v603;
    v840 = v891 ^ v850 ^ v556;
    v574 = v327 ^ v399;
    v414 = v322 ^ v653 ^ v618;
    v335 = v668 ^ v331;
    v519 = v330 ^ v786;
    v336 = v332 ^ v803;
    v851 = v329 ^ v618;
    v337 = v331 ^ v635;
    v338 = v443;
    v865 = v337;
    v444 = v333;
    v737 = v457 ^ v327 ^ v399;
    v339 = v1083 & ~v334;
    v458 = v334;
    v999 = ~v589;
    v340 = v472 ^ v330 ^ v786;
    v400 = v321 ^ v472 ^ v329;
    v473 = v635 ^ v324 ^ v503 ^ v877;
    v1015 = ~(v503 ^ v877);
    v1029 = ~v653;
    v1007 = v1087 & ~v487 ^ v537;
    v892 = v1082 & ~v333 ^ v338 ^ v430;
    v991 = v1086 & ~v328 ^ v556;
    v930 = v339 ^ v737;
    v951 = v1084 & ~v414 ^ v340;
    v972 = v1085 & ~v473 ^ v503 ^ v332 ^ v803;
    v1037 = v1089 & ~v400 ^ v618;
    v1022 = v1088 & ~v335 ^ v635;
    v341 = v703 ^ v487;
    v504 = v719 ^ v328;
    v704 = v328 & ~v603 ^ v991;
    v619 = v458 & ~v840 ^ v339 ^ v737;
    v720 = v487 & ~v589 ^ v1007;
    v636 = ~v851 & v414 ^ v951;
    v342 = v487 & ~v430;
    v538 = v770 ^ v335;
    v343 = v753 ^ v400;
    v669 = v473 & ~v865 ^ v972;
    v344 = v400 & ~v653 ^ v1037;
    v754 = v335 & ~v685 ^ v1022;
    v905 = v333 & ~v821 ^ v892;
    v345 = v333 & v905;
    v346 = v333 & ~v341;
    v347 = v458 & ~v504;
    v1053 = v342 ^ v589;
    v348 = v414 & ~v343;
    v1060 = v335 & ~(v332 ^ v803) ^ v685;
    v349 = v473 & ~(v770 ^ v335);
    v1063 = v400 & ~v519 ^ v653;
    v557 = v345 ^ v341;
    v878 = v346 ^ ~v821;
    v350 = v346 ^ v821;
    v686 = v328 & v704 ^ v574;
    v983 = v328 & ~v574 ^ ~v603;
    v351 = (v328 & ~v574 ^ v603) & v704 ^ v328;
    v590 = v458 & (v458 & ~v840 ^ v930) ^ v504;
    v822 = v347 ^ ~v840;
    v352 = v347 ^ v840;
    v919 = v342 ^ v999;
    v738 = v487 & v720 ^ v430;
    v604 = v414 & v636 ^ v343;
    v841 = v348 ^ ~v851;
    v353 = v348 ^ v851;
    v771 = v335 & v754 ^ v336;
    v941 = v335 & ~v336 ^ v1015;
    v354 = v1060 & v754 ^ v335;
    v654 = v473 & v669 ^ v538;
    v852 = v349 ^ ~v865;
    v960 = v400 & ~v519 ^ v1029;
    v787 = v400 & v344 ^ v519;
    v804 = v341 & v892;
    v355 = v574;
    v575 = v351;
    v893 = v504 & v930;
    v356 = v430 & v1007;
    v505 = v1053 & v720 ^ v487;
    v1008 = v342 ^ v999 | v738;
    v488 = v353 & v636;
    v1000 = v336 & v1022;
    v357 = v538 & v972;
    v973 = v519 & v1037;
    v358 = v400 ^ v1063 & v344;
    v359 = v804 ^ v1082;
    v360 = v350 & v905 ^ v444;
    v445 = (v878 | v557) ^ v905;
    v361 = v355 & v991 ^ v1086;
    v431 = (v983 | v686) ^ v704;
    v362 = v893 ^ v1083;
    v363 = v352 & v619 ^ v458;
    v459 = (v822 | v590) ^ v619;
    v364 = v356 ^ v1087;
    v805 = v1008 ^ v720;
    v520 = v343 & v951 ^ v1084;
    v365 = v414 ^ v488;
    v489 = (v841 | v604) ^ v636;
    v894 = (v941 | v771) ^ v754;
    v366 = v357 ^ v1085;
    v367 = (v349 ^ v865) & v669 ^ v473;
    v474 = (v852 | v654) ^ v669;
    v415 = v973 ^ v1089;
    v906 = (v960 | v787) ^ v344;
    v401 = v359 ^ v360;
    v705 = v557 & v360;
    v974 = v361 & v431;
    v368 = v361 ^ v575;
    v539 = v686 & v575 ^ v983;
    v369 = v505 ^ v364;
    v637 = v362 ^ v363;
    v576 = v738 & v505 ^ v919;
    v370 = v520 & v489;
    v670 = v520 ^ v365;
    v866 = v367 ^ v366;
    v371 = v415 & v906;
    v521 = v787 & v358 ^ v960;
    v372 = v358 ^ v415;
    v706 = v705 ^ v878;
    v721 = v359 & v445 ^ v557;
    v416 = v368 ^ v445;
    v490 = v445 ^ v539;
    v823 = v590 & v363 ^ v822;
    v373 = v362 & v459 ^ v590;
    v605 = v459 ^ v576;
    v374 = v604 & v365 ^ v841;
    v375 = v370 ^ v604;
    v522 = v489 ^ v771 & v354 ^ v941;
    v376 = v654 & v367 ^ v852;
    v377 = v366 & v474 ^ v654;
    v506 = v474 ^ v521;
    v638 = v721 ^ v431;
    v417 = v974 ^ v401 ^ v686;
    v378 = v401 ^ v490;
    v558 = v706 ^ v416;
    v739 = v373 ^ v805;
    v402 = v364 & v805 ^ v637 ^ v738;
    v379 = v637 ^ v605;
    v540 = v823 ^ v369 ^ v459;
    v788 = v375 ^ v894;
    v671 = (v1000 ^ v1088) & v894 ^ v670 ^ v771;
    v384 = v374 ^ v354 ^ v1000 ^ v1088 ^ v489;
    v722 = v377 ^ v906;
    v380 = v670 ^ v522;
    v655 = v371 ^ v866 ^ v787;
    v620 = v376 ^ v372 ^ v474;
    v13 = v638 ^ v378;
    v824 = v706 ^ v638;
    v20 = v721 ^ v558;
    v12 = v445 ^ v417;
    v591 = v739 ^ v379;
    v806 = v823 ^ v739;
    v707 = v373 ^ v540;
    v19 = v459 ^ v402;
    v577 = v375 ^ v894 ^ v380;
    v772 = v374 ^ v375 ^ v894;
    v687 = v375 ^ v384;
    v446 = v377 ^ v906 ^ v866 ^ v506;
    v755 = v376 ^ v377 ^ v906;
    v21 = v489 ^ v671;
    v18 = v474 ^ v655;
    v432 = v377 ^ v620;
    if ( v1105 == (_DWORD *)&unk_F2DA8 )
      break;
    v17 = v1105[56];
    v1090 = v1105[57];
    v460 = v1105[58];
    v842 = v1105[59];
    v853 = v1105[60];
    v867 = v1105[61];
    v879 = v1105[62];
    v895 = v1105[63];
    v907 = v1105[64];
    v920 = v1105[65];
    v931 = v1105[66];
    v942 = v1105[67];
    v952 = v1105[68];
    v961 = v1105[69];
    v975 = v1105[70];
    v984 = v1105[71];
    v992 = v1105[72];
    v1001 = v1105[73];
    v1009 = v1105[74];
    v1016 = v1105[75];
    v1023 = v1105[76];
    v1030 = v1105[77];
    v1038 = v1105[78];
    v1043 = v1105[79];
    v1047 = v1105[80];
    v1051 = v1105[81];
    v1054 = v1105[82];
    v1058 = v1105[83];
    v1061 = v1105[84];
    v1062 = v1105[85];
    v1064 = v1105[86];
    v1065 = v1105[87];
    v1066 = v1105[88];
    v1067 = v1105[89];
    v1068 = v1105[90];
    v1069 = v1105[91];
    v1070 = v1105[92];
    v1071 = v1105[93];
    v1072 = v1105[94];
    v1073 = v1105[95];
    v1074 = v1105[96];
    v1075 = v1105[97];
    v1076 = v1105[98];
    v1077 = v1105[99];
    v1078 = v1105[100];
    v1079 = v1105[101];
    v1080 = v1105[102];
    v1081 = v1105[103];
    v1082 = v1105[104];
    v1083 = v1105[105];
    v1084 = v1105[106];
    v1085 = v1105[107];
    v1086 = v1105[108];
    v1087 = v1105[109];
    v1088 = v1105[110];
    v1089 = v1105[111];
    v1105 += 56;
  }
  v591 ^= *(_DWORD *)(a1 + 4);
  v382 = v474 ^ v655;
  v383 = v489 ^ v671;
  v3 = 0;
  v577 ^= v1135;
  v13 ^= *(_DWORD *)a1;
  v5 = v20;
  v14 = v19;
  v446 ^= v1136;
  v384 ^= v1123;
  v15 = (void *)(v620 ^ v1124);
  v558 ^= v1125;
  v540 ^= v1126;
  v824 ^= v1127;
  v806 ^= v1128;
  ++*(_QWORD *)(a1 + 200);
  v772 ^= v1129;
  v755 ^= v1130;
  v522 ^= v1131;
  v506 ^= v1132;
  v490 ^= v1133;
  v605 ^= v1134;
  if ( n )
    goto LABEL_5;
LABEL_13:
  result = v15;
  v7 = v5;
  v8 = v14;
  v6 = v12;
  v9 = v13;
LABEL_14:
  *(_DWORD *)(a1 + 72) = v6;
  *(_DWORD *)(a1 + 80) = v383;
  *(_DWORD *)(a1 + 76) = v8;
  *(_DWORD *)(a1 + 104) = v7;
  *(_DWORD *)(a1 + 84) = v382;
  *(_DWORD *)(a1 + 136) = v9;
  *(_DWORD *)(a1 + 88) = v788;
  *(_DWORD *)(a1 + 92) = v722;
  *(_DWORD *)(a1 + 96) = v638;
  *(_DWORD *)(a1 + 100) = v739;
  *(_DWORD *)(a1 + 108) = v707;
  *(_DWORD *)(a1 + 112) = v687;
  *(_DWORD *)(a1 + 116) = v432;
  *(_DWORD *)(a1 + 120) = v671;
  *(_DWORD *)(a1 + 124) = v655;
  *(_DWORD *)(a1 + 128) = v417;
  *(_DWORD *)(a1 + 132) = v402;
  *(_DWORD *)(a1 + 140) = v591;
  *(_DWORD *)(a1 + 156) = result;
  *(_DWORD *)(a1 + 64) = v3;
  *(_DWORD *)(a1 + 144) = v577;
  *(_DWORD *)(a1 + 148) = v446;
  *(_DWORD *)(a1 + 152) = v384;
  *(_DWORD *)(a1 + 160) = v558;
  *(_DWORD *)(a1 + 164) = v540;
  *(_DWORD *)(a1 + 168) = v824;
  *(_DWORD *)(a1 + 172) = v806;
  *(_DWORD *)(a1 + 176) = v772;
  *(_DWORD *)(a1 + 180) = v755;
  *(_DWORD *)(a1 + 184) = v522;
  *(_DWORD *)(a1 + 188) = v506;
  *(_DWORD *)(a1 + 192) = v490;
  *(_DWORD *)(a1 + 196) = v605;
  return result;
}

//----- (000BAF94) --------------------------------------------------------
void *__fastcall sub_BAF94(_DWORD *a1, int a2, unsigned int a3, void *a4, int a5, void *src)
{
  int v8; // r11
  int v10; // r3
  size_t v11; // r2
  int v12; // r3
  int v13; // r8
  int v14; // r10
  int v15; // lr
  unsigned int v16; // r1
  char *v17; // r0
  char *v18; // r3
  unsigned __int64 v19; // r4
  char *v20; // r3
  _DWORD *v21; // r1
  int v22; // t1
  void *result; // r0
  size_t v24; // [sp+Ch] [bp-88h]
  char v25[64]; // [sp+10h] [bp-84h] BYREF
  char v26; // [sp+50h] [bp-44h] BYREF

  v8 = a1[16];
  v10 = (unsigned __int8)(128 >> a3);
  v11 = -v10;
  v12 = v10 | a2 & -v10;
  if ( v8 | a3 )
    v11 = 111 - v8;
  v25[0] = v12;
  if ( v8 | a3 )
    v12 = 128 - v8;
  else
    v11 = 47;
  if ( v8 | a3 )
  {
    v14 = 112 - v8;
    v13 = 120 - v8;
  }
  else
  {
    v12 = 64;
    v13 = 56;
    v14 = 48;
  }
  v24 = v12;
  memset(&v25[1], 0, v11);
  v15 = a1[51];
  v16 = a1[50];
  v17 = &v25[v14];
  v25[v14] = 0;
  v17[1] = 0;
  v17[6] = v15 < 0;
  v18 = &v25[v13];
  v17[2] = 0;
  v17[3] = 0;
  v17[4] = 0;
  v19 = __PAIR64__((v15 << 9) | (v16 >> 23), v16 << 9) + (unsigned int)(8 * v8) + a3;
  v17[5] = 0;
  v17[7] = (unsigned int)v15 >> 23;
  v25[v13] = HIBYTE(v19);
  v18[5] = BYTE2(v19);
  v18[3] = BYTE4(v19);
  v18[7] = 8 * v8 + a3;
  v18[1] = BYTE6(v19);
  v18[2] = BYTE5(v19);
  v18[4] = ((v16 << 9) + 8 * v8 + a3) >> 24;
  v18[6] = BYTE1(v19);
  sph_jh224_0((int)a1, v25, v24);
  v20 = v25;
  v21 = a1 + 33;
  do
  {
    v22 = v21[1];
    ++v21;
    v20 += 4;
    *((_DWORD *)v20 - 1) = v22;
  }
  while ( &v26 != v20 );
  memcpy(a4, &v25[4 * (16 - a5)], 4 * a5);
  a1[16] = 0;
  result = memcpy(a1 + 18, src, 0x80u);
  *((_QWORD *)a1 + 25) = 0;
  return result;
}

//----- (000BB15C) --------------------------------------------------------
void *__fastcall sph_jh224_init_0(int a1)
{
  void *result; // r0

  *(_DWORD *)(a1 + 64) = 0;
  result = memcpy((void *)(a1 + 72), &unk_F2E88, 0x80u);
  *(_QWORD *)(a1 + 200) = 0;
  return result;
}

//----- (000BB194) --------------------------------------------------------
void *__fastcall sph_jh224_close(_DWORD *a1, void *a2)
{
  return sub_BAF94(a1, 0, 0, a2, 7, &unk_F2E88);
}

//----- (000BB1C8) --------------------------------------------------------
void *__fastcall sph_jh224_addbits_and_close(_DWORD *a1, int a2, unsigned int a3, void *a4)
{
  return sub_BAF94(a1, a2, a3, a4, 7, &unk_F2E88);
}

//----- (000BB1F0) --------------------------------------------------------
void *__fastcall sph_jh256_init(int a1)
{
  void *result; // r0

  *(_DWORD *)(a1 + 64) = 0;
  result = memcpy((void *)(a1 + 72), &unk_F2F08, 0x80u);
  *(_QWORD *)(a1 + 200) = 0;
  return result;
}

//----- (000BB228) --------------------------------------------------------
void *__fastcall sph_jh256_close(_DWORD *a1, void *a2)
{
  return sub_BAF94(a1, 0, 0, a2, 8, &unk_F2F08);
}

//----- (000BB25C) --------------------------------------------------------
void *__fastcall sph_jh256_addbits_and_close(_DWORD *a1, int a2, unsigned int a3, void *a4)
{
  return sub_BAF94(a1, a2, a3, a4, 8, &unk_F2F08);
}

//----- (000BB284) --------------------------------------------------------
void *__fastcall sph_jh384_init(int a1)
{
  void *result; // r0

  *(_DWORD *)(a1 + 64) = 0;
  result = memcpy((void *)(a1 + 72), &unk_F2F88, 0x80u);
  *(_QWORD *)(a1 + 200) = 0;
  return result;
}

//----- (000BB2BC) --------------------------------------------------------
void *__fastcall sph_jh384_close(_DWORD *a1, void *a2)
{
  return sub_BAF94(a1, 0, 0, a2, 12, &unk_F2F88);
}

//----- (000BB2F0) --------------------------------------------------------
void *__fastcall sph_jh384_addbits_and_close(_DWORD *a1, int a2, unsigned int a3, void *a4)
{
  return sub_BAF94(a1, a2, a3, a4, 12, &unk_F2F88);
}

//----- (000BB318) --------------------------------------------------------
void *__fastcall sph_jh512_init(int a1)
{
  void *result; // r0

  *(_DWORD *)(a1 + 64) = 0;
  result = memcpy((void *)(a1 + 72), &unk_F3008, 0x80u);
  *(_QWORD *)(a1 + 200) = 0;
  return result;
}

//----- (000BB350) --------------------------------------------------------
void *__fastcall sph_jh512_close(_DWORD *a1, void *a2)
{
  return sub_BAF94(a1, 0, 0, a2, 16, &unk_F3008);
}

//----- (000BB384) --------------------------------------------------------
void *__fastcall sph_jh512_addbits_and_close(_DWORD *a1, int a2, unsigned int a3, void *a4)
{
  return sub_BAF94(a1, a2, a3, a4, 16, &unk_F3008);
}

//----- (000BB3AC) --------------------------------------------------------
unsigned int __fastcall sph_luffa224_0(unsigned int result, char *a2, size_t a3)
{
  unsigned int v3; // r5
  unsigned int *v4; // r9
  size_t v5; // r4
  char *v6; // r0
  int v7; // r6
  int v8; // r7
  int v9; // r3
  int v10; // r5
  unsigned int v11; // lr
  unsigned int v12; // r9
  unsigned int v13; // r10
  int v14; // r1
  int v15; // r12
  unsigned int v16; // r2
  int v17; // r8
  int v18; // r5
  int v19; // r6
  unsigned int v20; // r1
  int v21; // lr
  int v22; // r6
  int v23; // r1
  int v24; // r2
  int v25; // r0
  int v26; // r11
  int v27; // r8
  int v28; // lr
  int v29; // r10
  int v30; // r4
  int v31; // r12
  int v32; // r1
  int v33; // r3
  int v34; // r9
  int v35; // r1
  int v36; // r9
  int v37; // r7
  int v38; // r5
  int v39; // r6
  int v40; // r0
  int v41; // r11
  int v42; // r3
  int v43; // r2
  int v44; // lr
  int v45; // r4
  int v46; // r0
  int v47; // r1
  int v48; // r6
  int v49; // r0
  int v50; // r7
  int v51; // r2
  int v52; // r1
  int v53; // lr
  int v54; // r12
  int v55; // r3
  int v56; // r9
  int v57; // r2
  int v58; // r1
  int v59; // r0
  int v60; // r4
  int v61; // r12
  int v62; // r3
  int v63; // lr
  int v64; // r9
  int v65; // r8
  int v66; // r10
  int v67; // r0
  unsigned int v68; // lr
  int v69; // r2
  unsigned int v70; // r3
  int v71; // r12
  unsigned int v72; // r11
  int v73; // r4
  int v74; // r1
  int v75; // r2
  int v76; // r11
  int v77; // r9
  int v78; // r5
  int v79; // r6
  int v80; // r1
  int v81; // r7
  int v82; // r3
  int v83; // r0
  int v84; // r4
  int v85; // r12
  int v86; // r1
  int v87; // r2
  int v88; // r6
  int v89; // r1
  int v90; // r9
  int v91; // r0
  int v92; // r2
  int v93; // r4
  int v94; // lr
  int v95; // r3
  int v96; // r11
  int v97; // r0
  int v98; // r2
  int v99; // r1
  int v100; // r12
  int v101; // lr
  int v102; // r3
  int v103; // r4
  int v104; // r11
  int v105; // r8
  int v106; // r10
  unsigned int v107; // lr
  int v108; // r2
  unsigned int v109; // r3
  int v110; // r12
  unsigned int v111; // r11
  int v112; // r4
  int v113; // r1
  int v114; // r2
  int v115; // r11
  int v116; // r9
  int v117; // r5
  unsigned int v118; // r6
  int v119; // r1
  int v120; // r7
  int v121; // r3
  unsigned int v122; // r0
  int v123; // r4
  int v124; // r12
  int v125; // r1
  int v126; // r2
  int v127; // r6
  int v128; // r1
  int v129; // r9
  int v130; // r0
  int v131; // r2
  int v132; // r4
  int v133; // lr
  int v134; // r3
  int v135; // r11
  int v136; // r0
  int v137; // r2
  int v138; // r1
  int v139; // r12
  int v140; // lr
  int v141; // r3
  int v142; // r4
  int v143; // r11
  size_t n; // [sp+0h] [bp-A4h]
  unsigned int v145; // [sp+4h] [bp-A0h]
  int v146; // [sp+4h] [bp-A0h]
  int v147; // [sp+4h] [bp-A0h]
  int v148; // [sp+4h] [bp-A0h]
  char *src; // [sp+8h] [bp-9Ch]
  int v150; // [sp+Ch] [bp-98h]
  unsigned int *v151; // [sp+10h] [bp-94h]
  int v152; // [sp+14h] [bp-90h]
  int v153; // [sp+14h] [bp-90h]
  int v154; // [sp+18h] [bp-8Ch]
  int v155; // [sp+18h] [bp-8Ch]
  int v156; // [sp+18h] [bp-8Ch]
  unsigned int v157; // [sp+1Ch] [bp-88h]
  unsigned int v158; // [sp+1Ch] [bp-88h]
  int v159; // [sp+20h] [bp-84h]
  int v160; // [sp+20h] [bp-84h]
  int v161; // [sp+24h] [bp-80h]
  int v162; // [sp+24h] [bp-80h]
  int v163; // [sp+28h] [bp-7Ch]
  int v164; // [sp+28h] [bp-7Ch]
  unsigned int v165; // [sp+2Ch] [bp-78h]
  unsigned int v166; // [sp+2Ch] [bp-78h]
  int v167; // [sp+30h] [bp-74h]
  int v168; // [sp+30h] [bp-74h]
  int v169; // [sp+30h] [bp-74h]
  int v170; // [sp+34h] [bp-70h]
  int v171; // [sp+38h] [bp-6Ch]
  unsigned int v172; // [sp+38h] [bp-6Ch]
  unsigned int v173; // [sp+3Ch] [bp-68h]
  int v174; // [sp+3Ch] [bp-68h]
  unsigned int v175; // [sp+40h] [bp-64h]
  unsigned int v176; // [sp+40h] [bp-64h]
  unsigned int v177; // [sp+44h] [bp-60h]
  unsigned int v178; // [sp+44h] [bp-60h]
  int v179; // [sp+48h] [bp-5Ch]
  int v180; // [sp+48h] [bp-5Ch]
  unsigned int v181; // [sp+4Ch] [bp-58h]
  unsigned int v182; // [sp+4Ch] [bp-58h]
  unsigned int v183; // [sp+50h] [bp-54h]
  unsigned int v184; // [sp+50h] [bp-54h]
  int v185; // [sp+54h] [bp-50h]
  int v186; // [sp+54h] [bp-50h]
  int v187; // [sp+58h] [bp-4Ch]
  int v188; // [sp+58h] [bp-4Ch]
  int v189; // [sp+5Ch] [bp-48h]
  int v190; // [sp+60h] [bp-44h]
  int v191; // [sp+64h] [bp-40h]
  unsigned int v192; // [sp+64h] [bp-40h]
  int v193; // [sp+68h] [bp-3Ch]
  unsigned int v194; // [sp+68h] [bp-3Ch]
  int v195; // [sp+6Ch] [bp-38h]
  unsigned int v196; // [sp+70h] [bp-34h]
  int v197; // [sp+74h] [bp-30h]
  int v198; // [sp+78h] [bp-2Ch]
  int v199; // [sp+7Ch] [bp-28h]
  int v200; // [sp+84h] [bp-20h]

  v3 = *(_DWORD *)(result + 32);
  v4 = (unsigned int *)result;
  n = a3;
  v5 = 32 - v3;
  src = a2;
  if ( 32 - v3 > a3 )
  {
    result = (unsigned int)memcpy((void *)(result + v3), a2, a3);
    v4[8] = v3 + n;
    return result;
  }
  v195 = *(_DWORD *)(result + 36);
  v189 = *(_DWORD *)(result + 40);
  v170 = *(_DWORD *)(result + 44);
  v171 = *(_DWORD *)(result + 48);
  v191 = *(_DWORD *)(result + 52);
  v193 = *(_DWORD *)(result + 56);
  v190 = *(_DWORD *)(result + 60);
  v150 = *(_DWORD *)(result + 64);
  v187 = *(_DWORD *)(result + 68);
  v161 = *(_DWORD *)(result + 72);
  v163 = *(_DWORD *)(result + 76);
  v185 = *(_DWORD *)(result + 80);
  v167 = *(_DWORD *)(result + 84);
  v181 = *(_DWORD *)(result + 88);
  v183 = *(_DWORD *)(result + 92);
  v165 = *(_DWORD *)(result + 96);
  v179 = *(_DWORD *)(result + 100);
  v173 = *(_DWORD *)(result + 104);
  v152 = *(_DWORD *)(result + 108);
  v154 = *(_DWORD *)(result + 112);
  v159 = *(_DWORD *)(result + 116);
  v175 = *(_DWORD *)(result + 120);
  v177 = *(_DWORD *)(result + 124);
  v157 = *(_DWORD *)(result + 128);
  if ( !a3 )
    goto LABEL_20;
  v151 = (unsigned int *)result;
  while ( 1 )
  {
    if ( v5 >= n )
      v5 = n;
    v6 = (char *)v151 + v3;
    v3 += v5;
    result = (unsigned int)memcpy(v6, src, v5);
    n -= v5;
    src += v5;
    if ( v3 == 32 )
      break;
    if ( !n )
      goto LABEL_19;
LABEL_5:
    v5 = 32 - v3;
  }
  v7 = v171;
  v8 = v157 ^ v165 ^ v150;
  v9 = v171 ^ v185 ^ v154 ^ v8;
  v10 = v170 ^ v163 ^ v152 ^ v8;
  v172 = bswap32(v151[3]);
  v11 = bswap32(v151[4]);
  v12 = bswap32(v151[7]);
  v196 = bswap32(v151[2]);
  v145 = bswap32(v151[5]);
  v13 = bswap32(v151[6]);
  v197 = v10 ^ v7;
  v14 = v191 ^ v167 ^ v159;
  v15 = v167;
  v168 = v10 ^ v185;
  v160 = __ROR4__(v9 ^ v159 ^ v13 ^ v12 ^ v196, 30);
  v198 = v191 ^ v9;
  v16 = bswap32(v151[1]);
  v200 = v10 ^ v154 ^ v16;
  v17 = v179 ^ v187 ^ v195 ^ v8;
  v155 = v14 ^ v175;
  v18 = v181 ^ v14 ^ v11;
  v19 = v193 ^ v181 ^ v175;
  v199 = v193 ^ v14;
  v20 = v11;
  v192 = bswap32(*v151);
  v21 = v183 ^ v190 ^ v177;
  v194 = v20;
  v166 = __ROR4__(v165 ^ v21 ^ v13, 31);
  v184 = __ROR4__(v183 ^ v19 ^ v145, 31);
  v178 = __ROR4__(v177 ^ v19 ^ v20, 30);
  v158 = __ROR4__(v157 ^ v21 ^ v145, 30);
  v22 = v13 ^ v19 ^ v190;
  v182 = __ROR4__(v18, 31);
  v186 = v12 ^ v196 ^ v168;
  v23 = v173 ^ v189 ^ v161;
  v169 = __ROR4__(v12 ^ v172 ^ v9 ^ v15, 31);
  v176 = __ROR4__(v12 ^ v172 ^ v155, 30);
  v156 = v13 ^ v200;
  v164 = v16 ^ v23 ^ v163;
  v24 = v16 ^ v17 ^ v189;
  v174 = v12 ^ v173 ^ v17 ^ v13;
  v180 = v13 ^ v8 ^ v179;
  v25 = v194 ^ v198;
  v188 = v12 ^ v187 ^ v8;
  v26 = v12 ^ v150 ^ v21;
  v162 = v12 ^ v192 ^ v17 ^ v161;
  v27 = 0;
  v153 = v12 ^ v192 ^ v23 ^ v152;
  v28 = v192 ^ v8 ^ v195;
  v29 = -533497832;
  v30 = v172 ^ v197;
  v31 = v145 ^ v199;
  v146 = 809079974;
  v32 = v196 ^ v23 ^ v170;
  v33 = v22;
  v34 = v26;
  while ( 1 )
  {
    v35 = v32 ^ v30;
    v36 = v34 ^ v25;
    v37 = v35 ^ v28 & v30;
    v38 = (v31 | v33) ^ v25;
    v39 = v28 & v30 ^ ~v24;
    v40 = v25 & v31;
    v41 = v39 | v37;
    v42 = ~v33 ^ v40;
    v43 = (v28 | v24) ^ v30;
    v44 = v28 ^ (v39 | v37);
    v45 = v36 & v38 ^ v42;
    v46 = v40 ^ v36;
    v47 = v35 & v43 ^ v39;
    v48 = v42 | v46;
    v49 = v46 ^ v44 ^ v45;
    v50 = v37 ^ v47;
    v51 = ~v43 ^ v41;
    v52 = v47 & v41;
    v53 = v49 ^ __ROR4__(v44, 30);
    v54 = v31 ^ v48 ^ v51;
    v55 = ~v38 ^ v48 ^ v52;
    v56 = v50 ^ v45 & v48;
    v57 = v54 ^ __ROR4__(v51, 30);
    v58 = v55 ^ __ROR4__(v52, 30);
    v59 = v53 ^ __ROR4__(v49, 18);
    v60 = v56 ^ __ROR4__(v50, 30);
    v61 = v57 ^ __ROR4__(v54, 18);
    v62 = v58 ^ __ROR4__(v55, 18);
    v63 = v59 ^ __ROR4__(v53, 22);
    v64 = v60 ^ __ROR4__(v56, 18);
    v24 = v61 ^ __ROR4__(v57, 22);
    v32 = v62 ^ __ROR4__(v58, 22);
    v30 = v64 ^ __ROR4__(v60, 22);
    v31 = __ROR4__(v61, 31);
    v33 = __ROR4__(v62, 31);
    v25 = v29 ^ __ROR4__(v59, 31);
    v34 = __ROR4__(v64, 31);
    ++v27;
    v28 = v63 ^ v146;
    if ( v27 == 8 )
      break;
    v146 = dword_F3088[v27];
    v29 = dword_F30A8[v27];
  }
  v150 = v34;
  v65 = 0;
  v193 = v31;
  v171 = v30;
  v189 = v24;
  v170 = v32;
  v190 = v33;
  v195 = v28;
  v191 = v25;
  v66 = 23617341;
  v67 = v162;
  v68 = v182;
  v69 = v164;
  v70 = v184;
  v71 = v186;
  v72 = v166;
  v73 = v188;
  v74 = v169;
  v147 = -1226960659;
  while ( 1 )
  {
    v75 = v69 ^ v71;
    v76 = v72 ^ v74;
    v77 = v75 ^ v73 & v71;
    v78 = (v68 | v70) ^ v74;
    v79 = v73 & v71 ^ ~v67;
    v80 = v74 & v68;
    v81 = v79 | v77;
    v82 = ~v70 ^ v80;
    v83 = (v73 | v67) ^ v71;
    v84 = v73 ^ (v79 | v77);
    v85 = v76 & v78 ^ v82;
    v86 = v80 ^ v76;
    v87 = v75 & v83 ^ v79;
    v88 = v82 | v86;
    v89 = v86 ^ v84 ^ v85;
    v90 = v77 ^ v87;
    v91 = ~v83 ^ v81;
    v92 = v87 & v81;
    v93 = v89 ^ __ROR4__(v84, 30);
    v94 = v68 ^ v88 ^ v91;
    v95 = ~v78 ^ v88 ^ v92;
    v96 = v85 & v88 ^ v90;
    v97 = v94 ^ __ROR4__(v91, 30);
    v98 = v95 ^ __ROR4__(v92, 30);
    v99 = v93 ^ __ROR4__(v89, 18);
    v100 = v96 ^ __ROR4__(v90, 30);
    v101 = v97 ^ __ROR4__(v94, 18);
    v102 = v98 ^ __ROR4__(v95, 18);
    v103 = v99 ^ __ROR4__(v93, 22);
    v104 = v100 ^ __ROR4__(v96, 18);
    v67 = v101 ^ __ROR4__(v97, 22);
    v69 = v102 ^ __ROR4__(v98, 22);
    v71 = v104 ^ __ROR4__(v100, 22);
    v68 = __ROR4__(v101, 31);
    v70 = __ROR4__(v102, 31);
    v74 = v66 ^ __ROR4__(v99, 31);
    v72 = __ROR4__(v104, 31);
    ++v65;
    v73 = v103 ^ v147;
    if ( v65 == 8 )
      break;
    v147 = dword_F30C8[v65];
    v66 = dword_F30E8[v65];
  }
  v105 = 0;
  v161 = v67;
  v181 = v68;
  v163 = v69;
  v183 = v70;
  v185 = v71;
  v165 = v72;
  v187 = v73;
  v167 = v74;
  v106 = -497126719;
  result = v174;
  v107 = v176;
  v108 = v153;
  v109 = v178;
  v110 = v156;
  v111 = v158;
  v112 = v180;
  v113 = v160;
  v148 = -64955950;
  while ( 1 )
  {
    v114 = v108 ^ v110;
    v115 = v111 ^ v113;
    v116 = v114 ^ v112 & v110;
    v117 = (v107 | v109) ^ v113;
    v118 = v112 & v110 ^ ~result;
    v119 = v113 & v107;
    v120 = v118 | v116;
    v121 = ~v109 ^ v119;
    v122 = (v112 | result) ^ v110;
    v123 = v112 ^ (v118 | v116);
    v124 = v115 & v117 ^ v121;
    v125 = v119 ^ v115;
    v126 = v114 & v122 ^ v118;
    v127 = v121 | v125;
    v128 = v125 ^ v123 ^ v124;
    v129 = v116 ^ v126;
    v130 = ~v122 ^ v120;
    v131 = v126 & v120;
    v132 = v128 ^ __ROR4__(v123, 30);
    v133 = v107 ^ v127 ^ v130;
    v134 = ~v117 ^ v127 ^ v131;
    v135 = v124 & v127 ^ v129;
    v136 = v133 ^ __ROR4__(v130, 30);
    v137 = v134 ^ __ROR4__(v131, 30);
    v138 = v132 ^ __ROR4__(v128, 18);
    v139 = v135 ^ __ROR4__(v129, 30);
    v140 = v136 ^ __ROR4__(v133, 18);
    v141 = v137 ^ __ROR4__(v134, 18);
    v142 = v138 ^ __ROR4__(v132, 22);
    v143 = v139 ^ __ROR4__(v135, 18);
    result = v140 ^ __ROR4__(v136, 22);
    v108 = v141 ^ __ROR4__(v137, 22);
    v110 = v143 ^ __ROR4__(v139, 22);
    v107 = __ROR4__(v140, 31);
    v109 = __ROR4__(v141, 31);
    v113 = v106 ^ __ROR4__(v138, 31);
    v111 = __ROR4__(v143, 31);
    ++v105;
    v112 = v142 ^ v148;
    if ( v105 == 8 )
      break;
    v148 = dword_F3108[v105];
    v106 = dword_F3128[v105];
  }
  v177 = v109;
  v3 = 0;
  v173 = result;
  v175 = v107;
  v152 = v108;
  v154 = v110;
  v157 = v111;
  v179 = v112;
  v159 = v113;
  if ( n )
    goto LABEL_5;
LABEL_19:
  v4 = v151;
LABEL_20:
  v4[9] = v195;
  v4[10] = v189;
  v4[11] = v170;
  v4[12] = v171;
  v4[13] = v191;
  v4[14] = v193;
  v4[15] = v190;
  v4[16] = v150;
  v4[17] = v187;
  v4[18] = v161;
  v4[19] = v163;
  v4[20] = v185;
  v4[21] = v167;
  v4[22] = v181;
  v4[23] = v183;
  v4[24] = v165;
  v4[8] = v3;
  v4[25] = v179;
  v4[26] = v173;
  v4[27] = v152;
  v4[28] = v154;
  v4[29] = v159;
  v4[30] = v175;
  v4[31] = v177;
  v4[32] = v157;
  return result;
}
// F3088: using guessed type _DWORD dword_F3088[8];
// F30A8: using guessed type _DWORD dword_F30A8[8];
// F30C8: using guessed type _DWORD dword_F30C8[8];
// F30E8: using guessed type _DWORD dword_F30E8[8];
// F3108: using guessed type _DWORD dword_F3108[8];
// F3128: using guessed type _DWORD dword_F3128[8];

//----- (000BBD10) --------------------------------------------------------
unsigned int __fastcall sub_BBD10(unsigned int *a1, char a2, char a3, _BYTE *a4, int a5)
{
  unsigned int v5; // r4
  unsigned int v7; // r8
  unsigned int v8; // r9
  int v9; // r10
  unsigned int v10; // r7
  unsigned int v11; // r2
  unsigned int v12; // r3
  int v13; // r5
  unsigned int v14; // r0
  int v15; // r3
  int v16; // r4
  int v17; // r2
  int v18; // r3
  int v19; // r1
  int v20; // r8
  int v21; // r4
  int v22; // r0
  int v23; // r10
  int v24; // r2
  int v25; // lr
  int v26; // r3
  int v27; // r12
  int v28; // r11
  int v29; // r1
  int v30; // r2
  int v31; // r11
  int v32; // r9
  int v33; // r5
  int v34; // r6
  int v35; // r1
  int v36; // r7
  int v37; // r3
  int v38; // r0
  int v39; // r4
  int v40; // r12
  int v41; // r1
  int v42; // r2
  int v43; // r6
  int v44; // r1
  int v45; // r9
  int v46; // r0
  int v47; // r2
  int v48; // r4
  int v49; // lr
  int v50; // r3
  int v51; // r11
  int v52; // r0
  int v53; // r2
  int v54; // r1
  int v55; // r12
  int v56; // lr
  int v57; // r3
  int v58; // r4
  int v59; // r11
  int v60; // r8
  int v61; // r10
  int v62; // r0
  unsigned int v63; // lr
  int v64; // r2
  unsigned int v65; // r3
  int v66; // r12
  unsigned int v67; // r11
  int v68; // r4
  int v69; // r1
  int v70; // r2
  int v71; // r11
  int v72; // r9
  int v73; // r5
  int v74; // r6
  int v75; // r1
  int v76; // r7
  int v77; // r3
  int v78; // r0
  int v79; // r4
  int v80; // r12
  int v81; // r1
  int v82; // r2
  int v83; // r6
  int v84; // r1
  int v85; // r9
  int v86; // r0
  int v87; // r2
  int v88; // r4
  int v89; // lr
  int v90; // r3
  int v91; // r11
  int v92; // r0
  int v93; // r2
  int v94; // r1
  int v95; // r12
  int v96; // lr
  int v97; // r3
  int v98; // r4
  int v99; // r11
  int v100; // r8
  int v101; // r10
  int v102; // r0
  unsigned int v103; // lr
  int v104; // r2
  unsigned int v105; // r3
  int v106; // r12
  unsigned int v107; // r11
  int v108; // r4
  int v109; // r1
  int v110; // r2
  int v111; // r11
  int v112; // r9
  int v113; // r5
  int v114; // r6
  int v115; // r1
  int v116; // r7
  int v117; // r3
  int v118; // r0
  int v119; // r4
  int v120; // r12
  int v121; // r1
  int v122; // r2
  int v123; // r6
  int v124; // r1
  int v125; // r9
  int v126; // r0
  int v127; // r2
  int v128; // r4
  int v129; // lr
  int v130; // r3
  int v131; // r11
  int v132; // r0
  int v133; // r2
  int v134; // r1
  int v135; // r12
  int v136; // lr
  int v137; // r3
  int v138; // r4
  int v139; // r11
  int v140; // r5
  int v141; // r7
  int v142; // r4
  int v143; // r1
  int v144; // r6
  unsigned int v145; // r0
  unsigned int v146; // r2
  unsigned int v147; // r12
  unsigned int v148; // r8
  unsigned int result; // r0
  unsigned int v150; // r2
  int v151; // [sp+4h] [bp-A0h]
  int v152; // [sp+4h] [bp-A0h]
  int v153; // [sp+4h] [bp-A0h]
  int v154; // [sp+4h] [bp-A0h]
  int v155; // [sp+8h] [bp-9Ch]
  int v156; // [sp+Ch] [bp-98h]
  int v157; // [sp+Ch] [bp-98h]
  int v158; // [sp+Ch] [bp-98h]
  int v159; // [sp+10h] [bp-94h]
  int v160; // [sp+10h] [bp-94h]
  int v161; // [sp+14h] [bp-90h]
  int v162; // [sp+14h] [bp-90h]
  int v163; // [sp+18h] [bp-8Ch]
  int v164; // [sp+18h] [bp-8Ch]
  int v165; // [sp+1Ch] [bp-88h]
  unsigned int v166; // [sp+20h] [bp-84h]
  int v167; // [sp+20h] [bp-84h]
  int v168; // [sp+24h] [bp-80h]
  int v169; // [sp+24h] [bp-80h]
  unsigned int v170; // [sp+24h] [bp-80h]
  int v171; // [sp+28h] [bp-7Ch]
  int v172; // [sp+28h] [bp-7Ch]
  unsigned int v173; // [sp+2Ch] [bp-78h]
  unsigned int v174; // [sp+2Ch] [bp-78h]
  unsigned int v175; // [sp+30h] [bp-74h]
  int v176; // [sp+30h] [bp-74h]
  int v177; // [sp+30h] [bp-74h]
  int v178; // [sp+34h] [bp-70h]
  int v179; // [sp+34h] [bp-70h]
  unsigned int v180; // [sp+38h] [bp-6Ch]
  unsigned int v181; // [sp+38h] [bp-6Ch]
  int v182; // [sp+3Ch] [bp-68h]
  int v183; // [sp+3Ch] [bp-68h]
  unsigned int v184; // [sp+40h] [bp-64h]
  unsigned int v185; // [sp+40h] [bp-64h]
  int v186; // [sp+44h] [bp-60h]
  int v187; // [sp+44h] [bp-60h]
  int v188; // [sp+48h] [bp-5Ch]
  int v189; // [sp+48h] [bp-5Ch]
  int v190; // [sp+4Ch] [bp-58h]
  int v191; // [sp+4Ch] [bp-58h]
  unsigned int v192; // [sp+50h] [bp-54h]
  unsigned int v193; // [sp+50h] [bp-54h]
  int v194; // [sp+54h] [bp-50h]
  int v195; // [sp+54h] [bp-50h]
  unsigned int v196; // [sp+58h] [bp-4Ch]
  unsigned int v197; // [sp+58h] [bp-4Ch]
  unsigned int v198; // [sp+5Ch] [bp-48h]
  unsigned int v199; // [sp+5Ch] [bp-48h]
  int v201; // [sp+64h] [bp-40h]
  int v202; // [sp+68h] [bp-3Ch]
  int v203; // [sp+6Ch] [bp-38h]
  int v204; // [sp+70h] [bp-34h]
  unsigned int v205; // [sp+74h] [bp-30h]
  unsigned int v206; // [sp+78h] [bp-2Ch]
  int v207; // [sp+7Ch] [bp-28h]
  int v208; // [sp+7Ch] [bp-28h]
  int v209; // [sp+80h] [bp-24h]

  v5 = a1[8];
  *((_BYTE *)a1 + v5) = (128 >> a3) | a2 & -(128 >> a3);
  memset((char *)a1 + v5 + 1, 0, 31 - v5);
  v165 = a1[14];
  v202 = a1[9];
  v166 = a1[15];
  v155 = a1[10];
  v175 = a1[16];
  v201 = a1[11];
  v161 = a1[17];
  v168 = a1[12];
  v190 = a1[18];
  v171 = a1[13];
  v203 = 2;
  v194 = a1[19];
  v159 = a1[20];
  v163 = a1[21];
  v192 = a1[22];
  v196 = a1[23];
  v173 = a1[32];
  v198 = a1[24];
  v186 = a1[25];
  v178 = a1[26];
  v182 = a1[27];
  v156 = a1[28];
  v188 = a1[29];
  v180 = a1[30];
  v184 = a1[31];
  while ( 1 )
  {
    v7 = bswap32(a1[6]);
    v8 = bswap32(a1[5]);
    v9 = v175 ^ v173 ^ v198;
    v10 = bswap32(a1[7]);
    v11 = bswap32(a1[4]);
    v12 = bswap32(a1[2]);
    v13 = v168 ^ v156 ^ v159 ^ v9;
    v151 = v171 ^ v188 ^ v163;
    v14 = bswap32(a1[3]);
    v205 = bswap32(a1[1]);
    v207 = v156 ^ v205;
    v157 = v10 ^ v12 ^ v159;
    v204 = v12 ^ v201;
    v209 = v175 ^ v10;
    v206 = bswap32(*a1);
    v189 = __ROR4__(v188 ^ v7 ^ v10 ^ v12 ^ v13, 30);
    v15 = v165 ^ v180 ^ v192;
    v181 = __ROR4__(v10 ^ v14 ^ v180 ^ v151, 30);
    v176 = v15;
    v16 = v166 ^ v184 ^ v196;
    v193 = __ROR4__(v11 ^ v192 ^ v151, 31);
    v185 = __ROR4__(v15 ^ v11 ^ v184, 30);
    v164 = __ROR4__(v10 ^ v14 ^ v163 ^ v13, 31);
    v199 = __ROR4__(v7 ^ v198 ^ v16, 31);
    v197 = __ROR4__(v8 ^ v196 ^ v15, 31);
    v172 = v171 ^ v11 ^ v13;
    v174 = __ROR4__(v16 ^ v173 ^ v8, 30);
    v208 = v207 ^ v7;
    v17 = v182 ^ v194 ^ v201 ^ v9;
    v18 = v186 ^ v161 ^ v202 ^ v9;
    v19 = v190 ^ v178 ^ v155;
    v167 = v176 ^ v166 ^ v7;
    v162 = v10 ^ v161 ^ v9;
    v187 = v9 ^ v186 ^ v7;
    v191 = v10 ^ v206 ^ v190 ^ v18;
    v179 = v18 ^ v178 ^ v7 ^ v10;
    v177 = v16 ^ v209;
    v160 = v157 ^ v17;
    v20 = 0;
    v183 = v19 ^ v182 ^ v10 ^ v206;
    v169 = v168 ^ v14 ^ v17;
    v21 = v206 ^ v202 ^ v9;
    v158 = v17 ^ v208;
    v22 = v205 ^ v155 ^ v18;
    v23 = -533497832;
    v24 = v204 ^ v19;
    v195 = v205 ^ v194 ^ v19;
    v25 = v8 ^ v165 ^ v151;
    v26 = v167;
    v27 = v169;
    v28 = v177;
    v29 = v172;
    v152 = 809079974;
    while ( 1 )
    {
      v30 = v24 ^ v27;
      v31 = v28 ^ v29;
      v32 = v30 ^ v21 & v27;
      v33 = (v25 | v26) ^ v29;
      v34 = v21 & v27 ^ ~v22;
      v35 = v29 & v25;
      v36 = v34 | v32;
      v37 = ~v26 ^ v35;
      v38 = (v21 | v22) ^ v27;
      v39 = v21 ^ (v34 | v32);
      v40 = v31 & v33 ^ v37;
      v41 = v35 ^ v31;
      v42 = v30 & v38 ^ v34;
      v43 = v37 | v41;
      v44 = v41 ^ v39 ^ v40;
      v45 = v32 ^ v42;
      v46 = ~v38 ^ v36;
      v47 = v42 & v36;
      v48 = v44 ^ __ROR4__(v39, 30);
      v49 = v25 ^ v43 ^ v46;
      v50 = ~v33 ^ v43 ^ v47;
      v51 = v40 & v43 ^ v45;
      v52 = v49 ^ __ROR4__(v46, 30);
      v53 = v50 ^ __ROR4__(v47, 30);
      v54 = v48 ^ __ROR4__(v44, 18);
      v55 = v51 ^ __ROR4__(v45, 30);
      v56 = v52 ^ __ROR4__(v49, 18);
      v57 = v53 ^ __ROR4__(v50, 18);
      v58 = v54 ^ __ROR4__(v48, 22);
      v59 = v55 ^ __ROR4__(v51, 18);
      v22 = v56 ^ __ROR4__(v52, 22);
      v24 = v57 ^ __ROR4__(v53, 22);
      v27 = v59 ^ __ROR4__(v55, 22);
      v25 = __ROR4__(v56, 31);
      v26 = __ROR4__(v57, 31);
      v29 = v23 ^ __ROR4__(v54, 31);
      v28 = __ROR4__(v59, 31);
      ++v20;
      v21 = v58 ^ v152;
      if ( v20 == 8 )
        break;
      v152 = dword_F3088[v20];
      v23 = dword_F30A8[v20];
    }
    v60 = 0;
    v155 = v22;
    v165 = v25;
    v201 = v24;
    v166 = v26;
    v168 = v27;
    v175 = v28;
    v202 = v21;
    v171 = v29;
    v61 = 23617341;
    v62 = v191;
    v63 = v193;
    v64 = v195;
    v65 = v197;
    v66 = v160;
    v67 = v199;
    v68 = v162;
    v69 = v164;
    v153 = -1226960659;
    while ( 1 )
    {
      v70 = v64 ^ v66;
      v71 = v67 ^ v69;
      v72 = v70 ^ v68 & v66;
      v73 = (v63 | v65) ^ v69;
      v74 = v68 & v66 ^ ~v62;
      v75 = v69 & v63;
      v76 = v74 | v72;
      v77 = ~v65 ^ v75;
      v78 = (v68 | v62) ^ v66;
      v79 = v68 ^ (v74 | v72);
      v80 = v71 & v73 ^ v77;
      v81 = v75 ^ v71;
      v82 = v70 & v78 ^ v74;
      v83 = v77 | v81;
      v84 = v81 ^ v79 ^ v80;
      v85 = v72 ^ v82;
      v86 = ~v78 ^ v76;
      v87 = v82 & v76;
      v88 = v84 ^ __ROR4__(v79, 30);
      v89 = v63 ^ v83 ^ v86;
      v90 = ~v73 ^ v83 ^ v87;
      v91 = v80 & v83 ^ v85;
      v92 = v89 ^ __ROR4__(v86, 30);
      v93 = v90 ^ __ROR4__(v87, 30);
      v94 = v88 ^ __ROR4__(v84, 18);
      v95 = v91 ^ __ROR4__(v85, 30);
      v96 = v92 ^ __ROR4__(v89, 18);
      v97 = v93 ^ __ROR4__(v90, 18);
      v98 = v94 ^ __ROR4__(v88, 22);
      v99 = v95 ^ __ROR4__(v91, 18);
      v62 = v96 ^ __ROR4__(v92, 22);
      v64 = v97 ^ __ROR4__(v93, 22);
      v66 = v99 ^ __ROR4__(v95, 22);
      v63 = __ROR4__(v96, 31);
      v65 = __ROR4__(v97, 31);
      v69 = v61 ^ __ROR4__(v94, 31);
      v67 = __ROR4__(v99, 31);
      ++v60;
      v68 = v98 ^ v153;
      if ( v60 == 8 )
        break;
      v153 = dword_F30C8[v60];
      v61 = dword_F30E8[v60];
    }
    v100 = 0;
    v190 = v62;
    v192 = v63;
    v194 = v64;
    v196 = v65;
    v159 = v66;
    v198 = v67;
    v161 = v68;
    v163 = v69;
    v101 = -497126719;
    v102 = v179;
    v103 = v181;
    v104 = v183;
    v105 = v185;
    v106 = v158;
    v107 = v174;
    v108 = v187;
    v109 = v189;
    v154 = -64955950;
    while ( 1 )
    {
      v110 = v104 ^ v106;
      v111 = v107 ^ v109;
      v112 = v110 ^ v108 & v106;
      v113 = (v103 | v105) ^ v109;
      v114 = v108 & v106 ^ ~v102;
      v115 = v109 & v103;
      v116 = v114 | v112;
      v117 = ~v105 ^ v115;
      v118 = (v108 | v102) ^ v106;
      v119 = v108 ^ (v114 | v112);
      v120 = v111 & v113 ^ v117;
      v121 = v115 ^ v111;
      v122 = v110 & v118 ^ v114;
      v123 = v117 | v121;
      v124 = v121 ^ v119 ^ v120;
      v125 = v112 ^ v122;
      v126 = ~v118 ^ v116;
      v127 = v122 & v116;
      v128 = v124 ^ __ROR4__(v119, 30);
      v129 = v103 ^ v123 ^ v126;
      v130 = ~v113 ^ v123 ^ v127;
      v131 = v120 & v123 ^ v125;
      v132 = v129 ^ __ROR4__(v126, 30);
      v133 = v130 ^ __ROR4__(v127, 30);
      v134 = v128 ^ __ROR4__(v124, 18);
      v135 = v131 ^ __ROR4__(v125, 30);
      v136 = v132 ^ __ROR4__(v129, 18);
      v137 = v133 ^ __ROR4__(v130, 18);
      v138 = v134 ^ __ROR4__(v128, 22);
      v139 = v135 ^ __ROR4__(v131, 18);
      v102 = v136 ^ __ROR4__(v132, 22);
      v104 = v137 ^ __ROR4__(v133, 22);
      v106 = v139 ^ __ROR4__(v135, 22);
      v103 = __ROR4__(v136, 31);
      v105 = __ROR4__(v137, 31);
      v109 = v101 ^ __ROR4__(v134, 31);
      v107 = __ROR4__(v139, 31);
      ++v100;
      v108 = v138 ^ v154;
      if ( v100 == 8 )
        break;
      v154 = dword_F3108[v100];
      v101 = dword_F3128[v100];
    }
    v182 = v104;
    v184 = v105;
    v178 = v102;
    v188 = v109;
    v180 = v103;
    v156 = v106;
    v173 = v107;
    v186 = v108;
    memset(a1, 0, 0x20u);
    if ( v203 == 1 )
      break;
    v203 = 1;
  }
  v140 = v180 ^ v192 ^ v165;
  v141 = v108 ^ v161 ^ v202;
  v142 = v190 ^ v155 ^ v178;
  v143 = v194 ^ v201 ^ v182;
  v144 = v156 ^ v159 ^ v168;
  v145 = v188 ^ v163 ^ v171;
  v146 = v145 >> 8;
  v147 = v196 ^ v166 ^ v184;
  v148 = HIWORD(v145);
  v170 = HIBYTE(v145);
  *a4 = HIBYTE(v141);
  a4[3] = v141;
  a4[7] = v142;
  a4[4] = HIBYTE(v142);
  a4[11] = v143;
  a4[15] = v144;
  a4[5] = BYTE2(v142);
  a4[19] = v145;
  result = v147 >> 8;
  a4[27] = v147;
  a4[6] = BYTE1(v142);
  a4[23] = v140;
  a4[1] = BYTE2(v141);
  a4[8] = HIBYTE(v143);
  a4[2] = BYTE1(v141);
  a4[14] = BYTE1(v144);
  a4[9] = BYTE2(v143);
  a4[10] = BYTE1(v143);
  a4[12] = HIBYTE(v144);
  a4[13] = BYTE2(v144);
  a4[17] = v148;
  a4[18] = v146;
  a4[16] = v170;
  a4[21] = BYTE2(v140);
  a4[22] = BYTE1(v140);
  a4[20] = HIBYTE(v140);
  a4[24] = HIBYTE(v147);
  a4[25] = BYTE2(v147);
  a4[26] = BYTE1(v147);
  if ( a5 == 8 )
  {
    v150 = v107 ^ v198 ^ v175;
    a4[31] = v150;
    a4[28] = HIBYTE(v150);
    a4[29] = BYTE2(v150);
    a4[30] = BYTE1(v150);
    return HIBYTE(v150);
  }
  return result;
}
// F3088: using guessed type _DWORD dword_F3088[8];
// F30A8: using guessed type _DWORD dword_F30A8[8];
// F30C8: using guessed type _DWORD dword_F30C8[8];
// F30E8: using guessed type _DWORD dword_F30E8[8];
// F3108: using guessed type _DWORD dword_F3108[8];
// F3128: using guessed type _DWORD dword_F3128[8];

//----- (000BC74C) --------------------------------------------------------
void *__fastcall sph_luffa224_init_0(int a1)
{
  void *result; // r0

  result = memcpy((void *)(a1 + 36), &unk_F3148, 0x60u);
  *(_DWORD *)(a1 + 32) = 0;
  return result;
}

//----- (000BC778) --------------------------------------------------------
void *__fastcall sph_luffa224_addbits_and_close(unsigned int *a1, char a2, char a3, _BYTE *a4)
{
  void *result; // r0

  sub_BBD10(a1, a2, a3, a4, 7);
  result = memcpy(a1 + 9, &unk_F3148, 0x60u);
  a1[8] = 0;
  return result;
}

//----- (000BC7B4) --------------------------------------------------------
void *__fastcall sph_luffa224_close(unsigned int *a1, _BYTE *a2)
{
  return sph_luffa224_addbits_and_close(a1, 0, 0, a2);
}

//----- (000BC7CC) --------------------------------------------------------
void *__fastcall sph_luffa256_addbits_and_close(unsigned int *a1, char a2, char a3, _BYTE *a4)
{
  void *result; // r0

  sub_BBD10(a1, a2, a3, a4, 8);
  result = memcpy(a1 + 9, &unk_F3148, 0x60u);
  a1[8] = 0;
  return result;
}

//----- (000BC808) --------------------------------------------------------
void *__fastcall sph_luffa256_close(unsigned int *a1, _BYTE *a2)
{
  return sph_luffa256_addbits_and_close(a1, 0, 0, a2);
}

//----- (000BC818) --------------------------------------------------------
void *__fastcall sph_luffa384_init(int a1)
{
  void *result; // r0

  result = memcpy((void *)(a1 + 36), &unk_F3148, 0x80u);
  *(_DWORD *)(a1 + 32) = 0;
  return result;
}

//----- (000BC840) --------------------------------------------------------
unsigned int __fastcall sph_luffa384(unsigned int result, char *a2, size_t a3)
{
  unsigned int v3; // r5
  unsigned int *v4; // r10
  size_t v5; // r4
  char *v6; // r0
  int v7; // r2
  int v8; // r6
  int v9; // r3
  int v10; // r11
  unsigned int v11; // r10
  int v12; // r4
  unsigned int v13; // r9
  int v14; // r12
  int v15; // r0
  int v16; // r1
  int v17; // r8
  int v18; // r2
  int v19; // r11
  int v20; // r0
  int v21; // r4
  int v22; // r5
  int v23; // r8
  int v24; // r0
  int v25; // lr
  int v26; // r2
  int v27; // r3
  int v28; // r11
  int v29; // r6
  int v30; // r5
  int v31; // r4
  unsigned int v32; // r11
  int v33; // r1
  int v34; // r2
  int v35; // lr
  int v36; // r7
  int v37; // r12
  int v38; // r2
  int v39; // r3
  int v40; // r6
  int v41; // lr
  int v42; // r12
  int v43; // r8
  int v44; // r2
  int v45; // r3
  int v46; // r5
  int v47; // r8
  int v48; // r10
  int v49; // lr
  int v50; // r4
  int v51; // r0
  int v52; // r12
  int v53; // r3
  int v54; // r1
  int v55; // r11
  int v56; // r2
  int v57; // r11
  int v58; // r9
  int v59; // r5
  int v60; // r6
  int v61; // r1
  int v62; // r7
  int v63; // r3
  int v64; // r0
  int v65; // r4
  int v66; // r12
  int v67; // r1
  int v68; // r2
  int v69; // r6
  int v70; // r1
  int v71; // r9
  int v72; // r0
  int v73; // r2
  int v74; // r4
  int v75; // lr
  int v76; // r3
  int v77; // r11
  int v78; // r0
  int v79; // r2
  int v80; // r1
  int v81; // r12
  int v82; // lr
  int v83; // r3
  int v84; // r4
  int v85; // r11
  int v86; // r9
  int v87; // r8
  int v88; // r0
  unsigned int v89; // lr
  int v90; // r2
  unsigned int v91; // r3
  int v92; // r12
  unsigned int v93; // r11
  int v94; // r4
  int v95; // r1
  int v96; // r2
  int v97; // r11
  int v98; // r10
  int v99; // r5
  int v100; // r6
  int v101; // r1
  int v102; // r7
  int v103; // r3
  int v104; // r0
  int v105; // r4
  int v106; // r12
  int v107; // r1
  int v108; // r2
  int v109; // r6
  int v110; // r1
  int v111; // r10
  int v112; // r0
  int v113; // r2
  int v114; // r4
  int v115; // lr
  int v116; // r3
  int v117; // r11
  int v118; // r0
  int v119; // r2
  int v120; // r1
  int v121; // r12
  int v122; // lr
  int v123; // r3
  int v124; // r4
  int v125; // r11
  int v126; // r8
  int v127; // r10
  int v128; // r0
  unsigned int v129; // lr
  int v130; // r2
  unsigned int v131; // r3
  int v132; // r12
  unsigned int v133; // r11
  int v134; // r4
  int v135; // r1
  int v136; // r2
  int v137; // r11
  int v138; // r9
  int v139; // r5
  int v140; // r6
  int v141; // r1
  int v142; // r7
  int v143; // r3
  int v144; // r0
  int v145; // r4
  int v146; // r12
  int v147; // r1
  int v148; // r2
  int v149; // r6
  int v150; // r1
  int v151; // r9
  int v152; // r0
  int v153; // r2
  int v154; // r4
  int v155; // lr
  int v156; // r3
  int v157; // r11
  int v158; // r0
  int v159; // r2
  int v160; // r1
  int v161; // r12
  int v162; // lr
  int v163; // r3
  int v164; // r4
  int v165; // r11
  int v166; // r9
  int v167; // r8
  unsigned int v168; // lr
  int v169; // r2
  unsigned int v170; // r3
  int v171; // r12
  unsigned int v172; // r11
  int v173; // r4
  int v174; // r1
  int v175; // r2
  int v176; // r11
  int v177; // r10
  int v178; // r5
  unsigned int v179; // r6
  int v180; // r1
  int v181; // r7
  int v182; // r3
  unsigned int v183; // r0
  int v184; // r4
  int v185; // r12
  int v186; // r1
  int v187; // r2
  int v188; // r6
  int v189; // r1
  int v190; // r10
  int v191; // r0
  int v192; // r2
  int v193; // r4
  int v194; // lr
  int v195; // r3
  int v196; // r11
  int v197; // r0
  int v198; // r2
  int v199; // r1
  int v200; // r12
  int v201; // lr
  int v202; // r3
  int v203; // r4
  int v204; // r11
  size_t n; // [sp+4h] [bp-D8h]
  unsigned int v206; // [sp+8h] [bp-D4h]
  int v207; // [sp+8h] [bp-D4h]
  int v208; // [sp+8h] [bp-D4h]
  int v209; // [sp+8h] [bp-D4h]
  int v210; // [sp+8h] [bp-D4h]
  char *src; // [sp+Ch] [bp-D0h]
  unsigned int *v212; // [sp+10h] [bp-CCh]
  int v213; // [sp+14h] [bp-C8h]
  int v214; // [sp+14h] [bp-C8h]
  int v215; // [sp+18h] [bp-C4h]
  int v216; // [sp+18h] [bp-C4h]
  int v217; // [sp+18h] [bp-C4h]
  int v218; // [sp+1Ch] [bp-C0h]
  int v219; // [sp+1Ch] [bp-C0h]
  int v220; // [sp+20h] [bp-BCh]
  int v221; // [sp+20h] [bp-BCh]
  int v222; // [sp+24h] [bp-B8h]
  int v223; // [sp+24h] [bp-B8h]
  int v224; // [sp+28h] [bp-B4h]
  int v225; // [sp+28h] [bp-B4h]
  int v226; // [sp+28h] [bp-B4h]
  int v227; // [sp+28h] [bp-B4h]
  unsigned int v228; // [sp+2Ch] [bp-B0h]
  int v229; // [sp+2Ch] [bp-B0h]
  unsigned int v230; // [sp+2Ch] [bp-B0h]
  int v231; // [sp+30h] [bp-ACh]
  int v232; // [sp+30h] [bp-ACh]
  int v233; // [sp+30h] [bp-ACh]
  unsigned int v234; // [sp+34h] [bp-A8h]
  int v235; // [sp+34h] [bp-A8h]
  unsigned int v236; // [sp+34h] [bp-A8h]
  unsigned int v237; // [sp+38h] [bp-A4h]
  int v238; // [sp+38h] [bp-A4h]
  unsigned int v239; // [sp+38h] [bp-A4h]
  int v240; // [sp+3Ch] [bp-A0h]
  int v241; // [sp+3Ch] [bp-A0h]
  int v242; // [sp+40h] [bp-9Ch]
  int v243; // [sp+40h] [bp-9Ch]
  int v244; // [sp+40h] [bp-9Ch]
  int v245; // [sp+40h] [bp-9Ch]
  int v246; // [sp+44h] [bp-98h]
  int v247; // [sp+44h] [bp-98h]
  int v248; // [sp+44h] [bp-98h]
  unsigned int v249; // [sp+48h] [bp-94h]
  int v250; // [sp+48h] [bp-94h]
  unsigned int v251; // [sp+48h] [bp-94h]
  int v252; // [sp+4Ch] [bp-90h]
  unsigned int v253; // [sp+4Ch] [bp-90h]
  int v254; // [sp+4Ch] [bp-90h]
  unsigned int v255; // [sp+50h] [bp-8Ch]
  int v256; // [sp+50h] [bp-8Ch]
  unsigned int v257; // [sp+50h] [bp-8Ch]
  int v258; // [sp+54h] [bp-88h]
  int v259; // [sp+54h] [bp-88h]
  int v260; // [sp+54h] [bp-88h]
  unsigned int v261; // [sp+58h] [bp-84h]
  int v262; // [sp+58h] [bp-84h]
  unsigned int v263; // [sp+58h] [bp-84h]
  int v264; // [sp+5Ch] [bp-80h]
  int v265; // [sp+5Ch] [bp-80h]
  int v266; // [sp+5Ch] [bp-80h]
  int v267; // [sp+60h] [bp-7Ch]
  int v268; // [sp+60h] [bp-7Ch]
  unsigned int v269; // [sp+64h] [bp-78h]
  int v270; // [sp+64h] [bp-78h]
  unsigned int v271; // [sp+64h] [bp-78h]
  unsigned int v272; // [sp+68h] [bp-74h]
  int v273; // [sp+68h] [bp-74h]
  unsigned int v274; // [sp+68h] [bp-74h]
  int v275; // [sp+6Ch] [bp-70h]
  unsigned int v276; // [sp+6Ch] [bp-70h]
  int v277; // [sp+6Ch] [bp-70h]
  unsigned int v278; // [sp+70h] [bp-6Ch]
  unsigned int v279; // [sp+70h] [bp-6Ch]
  int v280; // [sp+74h] [bp-68h]
  unsigned int v281; // [sp+74h] [bp-68h]
  int v282; // [sp+74h] [bp-68h]
  unsigned int v283; // [sp+78h] [bp-64h]
  unsigned int v284; // [sp+78h] [bp-64h]
  int v285; // [sp+7Ch] [bp-60h]
  int v286; // [sp+7Ch] [bp-60h]
  int v287; // [sp+7Ch] [bp-60h]
  int v288; // [sp+80h] [bp-5Ch]
  int v289; // [sp+80h] [bp-5Ch]
  int v290; // [sp+84h] [bp-58h]
  int v291; // [sp+84h] [bp-58h]
  int v292; // [sp+84h] [bp-58h]
  int v293; // [sp+84h] [bp-58h]
  int v294; // [sp+88h] [bp-54h]
  int v295; // [sp+88h] [bp-54h]
  int v296; // [sp+8Ch] [bp-50h]
  int v297; // [sp+90h] [bp-4Ch]
  unsigned int v298; // [sp+94h] [bp-48h]
  int v299; // [sp+98h] [bp-44h]
  int v300; // [sp+98h] [bp-44h]
  int v301; // [sp+9Ch] [bp-40h]
  int v302; // [sp+9Ch] [bp-40h]
  int v303; // [sp+A0h] [bp-3Ch]
  int v304; // [sp+A0h] [bp-3Ch]
  int v305; // [sp+A4h] [bp-38h]
  int v306; // [sp+A8h] [bp-34h]
  int v307; // [sp+A8h] [bp-34h]
  int v308; // [sp+ACh] [bp-30h]
  int v309; // [sp+ACh] [bp-30h]
  int v310; // [sp+B0h] [bp-2Ch]
  int v311; // [sp+B0h] [bp-2Ch]
  int v312; // [sp+B4h] [bp-28h]
  int v313; // [sp+B8h] [bp-24h]
  int v314; // [sp+BCh] [bp-20h]

  v3 = *(_DWORD *)(result + 32);
  v4 = (unsigned int *)result;
  n = a3;
  v5 = 32 - v3;
  src = a2;
  if ( a3 < 32 - v3 )
  {
    result = (unsigned int)memcpy((void *)(result + v3), a2, a3);
    v4[8] = n + v3;
    return result;
  }
  v297 = *(_DWORD *)(result + 36);
  v294 = *(_DWORD *)(result + 40);
  v296 = *(_DWORD *)(result + 44);
  v220 = *(_DWORD *)(result + 48);
  v213 = *(_DWORD *)(result + 52);
  v215 = *(_DWORD *)(result + 56);
  v218 = *(_DWORD *)(result + 60);
  v222 = *(_DWORD *)(result + 64);
  v240 = *(_DWORD *)(result + 68);
  v224 = *(_DWORD *)(result + 72);
  v231 = *(_DWORD *)(result + 76);
  v290 = *(_DWORD *)(result + 80);
  v242 = *(_DWORD *)(result + 84);
  v228 = *(_DWORD *)(result + 88);
  v234 = *(_DWORD *)(result + 92);
  v237 = *(_DWORD *)(result + 96);
  v264 = *(_DWORD *)(result + 100);
  v246 = *(_DWORD *)(result + 104);
  v252 = *(_DWORD *)(result + 108);
  v258 = *(_DWORD *)(result + 112);
  v267 = *(_DWORD *)(result + 116);
  v249 = *(_DWORD *)(result + 120);
  v255 = *(_DWORD *)(result + 124);
  v261 = *(_DWORD *)(result + 128);
  v285 = *(_DWORD *)(result + 132);
  v269 = *(_DWORD *)(result + 136);
  v275 = *(_DWORD *)(result + 140);
  v280 = *(_DWORD *)(result + 144);
  v288 = *(_DWORD *)(result + 148);
  v272 = *(_DWORD *)(result + 152);
  v278 = *(_DWORD *)(result + 156);
  v283 = *(_DWORD *)(result + 160);
  if ( !a3 )
    goto LABEL_23;
  v212 = (unsigned int *)result;
  while ( 1 )
  {
    if ( v5 >= n )
      v5 = n;
    v6 = (char *)v212 + v3;
    v3 += v5;
    result = (unsigned int)memcpy(v6, src, v5);
    n -= v5;
    src += v5;
    if ( v3 == 32 )
      break;
    if ( !n )
      goto LABEL_22;
LABEL_5:
    v5 = 32 - v3;
  }
  v7 = v261 ^ v237 ^ v222 ^ v283;
  v8 = v275 ^ v252 ^ v296 ^ v231 ^ v7;
  v9 = v220 ^ v290 ^ v280 ^ v258 ^ v7;
  v10 = v8 ^ v290;
  v291 = v7;
  v11 = bswap32(v212[5]);
  v12 = v280;
  v206 = bswap32(v212[7]);
  v281 = bswap32(v212[2]);
  v13 = bswap32(v212[6]);
  v308 = v8 ^ v12;
  v301 = v10;
  v14 = v278 ^ v255 ^ v218 ^ v234;
  v303 = v8 ^ v258;
  v15 = v242 ^ v213 ^ v288;
  v16 = v272 ^ v249 ^ v228 ^ v215;
  v259 = v14 ^ v283;
  v17 = v14 ^ v222;
  v243 = v9 ^ v242;
  v223 = v14 ^ v237;
  v18 = v246 ^ v269 ^ v294 ^ v224;
  v19 = v213;
  v214 = v17;
  v238 = v14 ^ v261;
  v20 = v15 ^ v267;
  v21 = v9 ^ v267 ^ v8 ^ v12 ^ v14 ^ v283 ^ v11;
  v262 = v9 ^ v19;
  v306 = v18 ^ v275;
  v276 = bswap32(v212[1]);
  v313 = v9 ^ v288;
  v298 = bswap32(v212[3]);
  v312 = v20 ^ v249;
  v250 = v20 ^ v272;
  v22 = v20 ^ v228;
  v273 = v20 ^ v215;
  v299 = v16 ^ v218;
  v23 = v16 ^ v255;
  v24 = v16 ^ v234;
  v229 = v16 ^ v278;
  v25 = v285 ^ v297 ^ v240 ^ v264 ^ v291;
  v305 = v285 ^ v291;
  v221 = v8 ^ v220;
  v219 = v18 ^ v296;
  v310 = v18 ^ v231;
  v286 = v18 ^ v252;
  v26 = v22 ^ v9 ^ v267;
  v27 = v303 ^ v243 ^ v238;
  v28 = v243 ^ v273;
  v29 = v291;
  v232 = v25 ^ v246;
  v235 = v11 ^ v22 ^ v299;
  v247 = v291 ^ v297;
  v292 = v240 ^ v291;
  v265 = v29 ^ v264;
  v253 = bswap32(v212[4]);
  v244 = v21 ^ v276 ^ v13;
  v216 = v25 ^ v294;
  v30 = v25 ^ v269;
  v31 = v25 ^ v224;
  v256 = v26 ^ v298 ^ v206;
  v225 = v28 ^ v253;
  v295 = v219 ^ v214 ^ v308;
  v32 = bswap32(*v212);
  v309 = v286 ^ v238 ^ v301;
  v33 = v298 ^ v206 ^ v23 ^ v250;
  v34 = v244;
  v35 = v13 ^ v281 ^ v206;
  v245 = __ROR4__(v262 ^ v301 ^ v223 ^ v298 ^ v206, 31);
  v36 = v238;
  v268 = __ROR4__(v27 ^ v35, 30);
  v289 = __ROR4__(v34, 29);
  v314 = v306 ^ v14 ^ v283 ^ v303 ^ v11;
  v37 = v229;
  v302 = v262 ^ v250;
  v251 = __ROR4__(v256, 30);
  v38 = v238 ^ v229 ^ v253;
  v236 = __ROR4__(v235, 31);
  v263 = __ROR4__(v23 ^ v223 ^ v11, 30);
  v279 = __ROR4__(v33, 29);
  v230 = __ROR4__(v225, 31);
  v284 = __ROR4__(v38, 29);
  v304 = v273 ^ v37;
  v239 = __ROR4__(v24 ^ v214 ^ v13, 31);
  v39 = v305 ^ v259 ^ v232 ^ v11 ^ v13;
  v257 = __ROR4__(v24 ^ v312 ^ v253, 30);
  v300 = v299 ^ v259;
  v274 = __ROR4__(v35 ^ v312 ^ v313, 29);
  v270 = v216 ^ v306;
  v307 = v310 ^ v232;
  v40 = v310 ^ v223 ^ v221;
  v311 = v286 ^ v30;
  v41 = v265 ^ v36 ^ v31;
  v226 = v265 ^ v259;
  v42 = v292 ^ v36;
  v43 = v292 ^ v223 ^ v216;
  v260 = v309 ^ v276 ^ v13;
  v217 = v302 ^ v11;
  v293 = v40 ^ v281 ^ v206;
  v44 = v270 ^ v281;
  v233 = v219 ^ v31 ^ v276;
  v271 = v39;
  v45 = v247 ^ v214 ^ v30 ^ v276;
  v287 = v11 ^ v226;
  v266 = v13 ^ v42;
  v241 = v206 ^ v247 ^ v223;
  v248 = v41 ^ v13 ^ v206;
  v277 = v311 ^ v13 ^ v206;
  v282 = v314 ^ v32 ^ v206;
  v46 = v253 ^ v221 ^ v313 ^ v214;
  v227 = v43 ^ v32 ^ v206;
  v47 = 0;
  v48 = -533497832;
  v49 = v217;
  v50 = v214 ^ v305 ^ v32;
  v254 = v307 ^ v32 ^ v206;
  v51 = v45;
  v52 = v295 ^ v298;
  v53 = v304 ^ v13;
  v54 = v46;
  v55 = v300 ^ v206;
  v207 = 809079974;
  while ( 1 )
  {
    v56 = v44 ^ v52;
    v57 = v55 ^ v54;
    v58 = v56 ^ v50 & v52;
    v59 = (v49 | v53) ^ v54;
    v60 = v50 & v52 ^ ~v51;
    v61 = v54 & v49;
    v62 = v60 | v58;
    v63 = ~v53 ^ v61;
    v64 = (v50 | v51) ^ v52;
    v65 = v50 ^ (v60 | v58);
    v66 = v57 & v59 ^ v63;
    v67 = v61 ^ v57;
    v68 = v56 & v64 ^ v60;
    v69 = v63 | v67;
    v70 = v67 ^ v65 ^ v66;
    v71 = v58 ^ v68;
    v72 = ~v64 ^ v62;
    v73 = v68 & v62;
    v74 = v70 ^ __ROR4__(v65, 30);
    v75 = v49 ^ v69 ^ v72;
    v76 = ~v59 ^ v69 ^ v73;
    v77 = v66 & v69 ^ v71;
    v78 = v75 ^ __ROR4__(v72, 30);
    v79 = v76 ^ __ROR4__(v73, 30);
    v80 = v74 ^ __ROR4__(v70, 18);
    v81 = v77 ^ __ROR4__(v71, 30);
    v82 = v78 ^ __ROR4__(v75, 18);
    v83 = v79 ^ __ROR4__(v76, 18);
    v84 = v80 ^ __ROR4__(v74, 22);
    v85 = v81 ^ __ROR4__(v77, 18);
    v51 = v82 ^ __ROR4__(v78, 22);
    v44 = v83 ^ __ROR4__(v79, 22);
    v52 = v85 ^ __ROR4__(v81, 22);
    v49 = __ROR4__(v82, 31);
    v53 = __ROR4__(v83, 31);
    v54 = v48 ^ __ROR4__(v80, 31);
    v55 = __ROR4__(v85, 31);
    ++v47;
    v50 = v84 ^ v207;
    if ( v47 == 8 )
      break;
    v207 = dword_F3088[v47];
    v48 = dword_F30A8[v47];
  }
  v86 = 23617341;
  v294 = v51;
  v215 = v49;
  v87 = 0;
  v296 = v44;
  v218 = v53;
  v220 = v52;
  v222 = v55;
  v297 = v50;
  v213 = v54;
  v88 = v227;
  v89 = v230;
  v90 = v233;
  v91 = v236;
  v92 = v293;
  v93 = v239;
  v94 = v241;
  v95 = v245;
  v208 = -1226960659;
  while ( 1 )
  {
    v96 = v90 ^ v92;
    v97 = v93 ^ v95;
    v98 = v96 ^ v94 & v92;
    v99 = (v89 | v91) ^ v95;
    v100 = v94 & v92 ^ ~v88;
    v101 = v95 & v89;
    v102 = v100 | v98;
    v103 = ~v91 ^ v101;
    v104 = (v94 | v88) ^ v92;
    v105 = v94 ^ (v100 | v98);
    v106 = v97 & v99 ^ v103;
    v107 = v101 ^ v97;
    v108 = v96 & v104 ^ v100;
    v109 = v103 | v107;
    v110 = v107 ^ v105 ^ v106;
    v111 = v98 ^ v108;
    v112 = ~v104 ^ v102;
    v113 = v108 & v102;
    v114 = v110 ^ __ROR4__(v105, 30);
    v115 = v89 ^ v109 ^ v112;
    v116 = ~v99 ^ v109 ^ v113;
    v117 = v106 & v109 ^ v111;
    v118 = v115 ^ __ROR4__(v112, 30);
    v119 = v116 ^ __ROR4__(v113, 30);
    v120 = v114 ^ __ROR4__(v110, 18);
    v121 = v117 ^ __ROR4__(v111, 30);
    v122 = v118 ^ __ROR4__(v115, 18);
    v123 = v119 ^ __ROR4__(v116, 18);
    v124 = v120 ^ __ROR4__(v114, 22);
    v125 = v121 ^ __ROR4__(v117, 18);
    v88 = v122 ^ __ROR4__(v118, 22);
    v90 = v123 ^ __ROR4__(v119, 22);
    v92 = v125 ^ __ROR4__(v121, 22);
    v89 = __ROR4__(v122, 31);
    v91 = __ROR4__(v123, 31);
    v95 = v86 ^ __ROR4__(v120, 31);
    v93 = __ROR4__(v125, 31);
    ++v87;
    v94 = v124 ^ v208;
    if ( v87 == 8 )
      break;
    v208 = dword_F30C8[v87];
    v86 = dword_F30E8[v87];
  }
  v126 = 0;
  v224 = v88;
  v228 = v89;
  v231 = v90;
  v234 = v91;
  v290 = v92;
  v237 = v93;
  v240 = v94;
  v242 = v95;
  v127 = -497126719;
  v128 = v248;
  v129 = v251;
  v130 = v254;
  v131 = v257;
  v132 = v260;
  v133 = v263;
  v134 = v266;
  v135 = v268;
  v209 = -64955950;
  while ( 1 )
  {
    v136 = v130 ^ v132;
    v137 = v133 ^ v135;
    v138 = v136 ^ v134 & v132;
    v139 = (v129 | v131) ^ v135;
    v140 = v134 & v132 ^ ~v128;
    v141 = v135 & v129;
    v142 = v140 | v138;
    v143 = ~v131 ^ v141;
    v144 = (v134 | v128) ^ v132;
    v145 = v134 ^ (v140 | v138);
    v146 = v137 & v139 ^ v143;
    v147 = v141 ^ v137;
    v148 = v136 & v144 ^ v140;
    v149 = v143 | v147;
    v150 = v147 ^ v145 ^ v146;
    v151 = v138 ^ v148;
    v152 = ~v144 ^ v142;
    v153 = v148 & v142;
    v154 = v150 ^ __ROR4__(v145, 30);
    v155 = v129 ^ v149 ^ v152;
    v156 = ~v139 ^ v149 ^ v153;
    v157 = v146 & v149 ^ v151;
    v158 = v155 ^ __ROR4__(v152, 30);
    v159 = v156 ^ __ROR4__(v153, 30);
    v160 = v154 ^ __ROR4__(v150, 18);
    v161 = v157 ^ __ROR4__(v151, 30);
    v162 = v158 ^ __ROR4__(v155, 18);
    v163 = v159 ^ __ROR4__(v156, 18);
    v164 = v160 ^ __ROR4__(v154, 22);
    v165 = v161 ^ __ROR4__(v157, 18);
    v128 = v162 ^ __ROR4__(v158, 22);
    v130 = v163 ^ __ROR4__(v159, 22);
    v132 = v165 ^ __ROR4__(v161, 22);
    v129 = __ROR4__(v162, 31);
    v131 = __ROR4__(v163, 31);
    v135 = v127 ^ __ROR4__(v160, 31);
    v133 = __ROR4__(v165, 31);
    ++v126;
    v134 = v164 ^ v209;
    if ( v126 == 8 )
      break;
    v209 = dword_F3108[v126];
    v127 = dword_F3128[v126];
  }
  v166 = -534197825;
  v246 = v128;
  v249 = v129;
  v167 = 0;
  v252 = v130;
  v255 = v131;
  v258 = v132;
  v261 = v133;
  v264 = v134;
  v267 = v135;
  result = v271;
  v168 = v274;
  v169 = v277;
  v170 = v279;
  v171 = v282;
  v172 = v284;
  v173 = v287;
  v174 = v289;
  v210 = -1307332699;
  while ( 1 )
  {
    v175 = v169 ^ v171;
    v176 = v172 ^ v174;
    v177 = v175 ^ v173 & v171;
    v178 = (v168 | v170) ^ v174;
    v179 = v173 & v171 ^ ~result;
    v180 = v174 & v168;
    v181 = v179 | v177;
    v182 = ~v170 ^ v180;
    v183 = (v173 | result) ^ v171;
    v184 = v173 ^ (v179 | v177);
    v185 = v176 & v178 ^ v182;
    v186 = v180 ^ v176;
    v187 = v175 & v183 ^ v179;
    v188 = v182 | v186;
    v189 = v186 ^ v184 ^ v185;
    v190 = v177 ^ v187;
    v191 = ~v183 ^ v181;
    v192 = v187 & v181;
    v193 = v189 ^ __ROR4__(v184, 30);
    v194 = v168 ^ v188 ^ v191;
    v195 = ~v178 ^ v188 ^ v192;
    v196 = v185 & v188 ^ v190;
    v197 = v194 ^ __ROR4__(v191, 30);
    v198 = v195 ^ __ROR4__(v192, 30);
    v199 = v193 ^ __ROR4__(v189, 18);
    v200 = v196 ^ __ROR4__(v190, 30);
    v201 = v197 ^ __ROR4__(v194, 18);
    v202 = v198 ^ __ROR4__(v195, 18);
    v203 = v199 ^ __ROR4__(v193, 22);
    v204 = v200 ^ __ROR4__(v196, 18);
    result = v201 ^ __ROR4__(v197, 22);
    v169 = v202 ^ __ROR4__(v198, 22);
    v171 = v204 ^ __ROR4__(v200, 22);
    v168 = __ROR4__(v201, 31);
    v170 = __ROR4__(v202, 31);
    v174 = v166 ^ __ROR4__(v199, 31);
    v172 = __ROR4__(v204, 31);
    ++v167;
    v173 = v203 ^ v210;
    if ( v167 == 8 )
      break;
    v210 = dword_F31E8[v167];
    v166 = dword_F3208[v167];
  }
  v275 = v169;
  v278 = v170;
  v3 = 0;
  v269 = result;
  v272 = v168;
  v280 = v171;
  v283 = v172;
  v285 = v173;
  v288 = v174;
  if ( n )
    goto LABEL_5;
LABEL_22:
  v4 = v212;
LABEL_23:
  v4[9] = v297;
  v4[10] = v294;
  v4[11] = v296;
  v4[12] = v220;
  v4[13] = v213;
  v4[14] = v215;
  v4[15] = v218;
  v4[16] = v222;
  v4[17] = v240;
  v4[18] = v224;
  v4[19] = v231;
  v4[20] = v290;
  v4[21] = v242;
  v4[22] = v228;
  v4[23] = v234;
  v4[24] = v237;
  v4[25] = v264;
  v4[26] = v246;
  v4[27] = v252;
  v4[28] = v258;
  v4[29] = v267;
  v4[30] = v249;
  v4[31] = v255;
  v4[32] = v261;
  v4[33] = v285;
  v4[34] = v269;
  v4[35] = v275;
  v4[36] = v280;
  v4[37] = v288;
  v4[38] = v272;
  v4[39] = v278;
  v4[40] = v283;
  v4[8] = v3;
  return result;
}
// F3088: using guessed type _DWORD dword_F3088[8];
// F30A8: using guessed type _DWORD dword_F30A8[8];
// F30C8: using guessed type _DWORD dword_F30C8[8];
// F30E8: using guessed type _DWORD dword_F30E8[8];
// F3108: using guessed type _DWORD dword_F3108[8];
// F3128: using guessed type _DWORD dword_F3128[8];
// F31E8: using guessed type _DWORD dword_F31E8[8];
// F3208: using guessed type _DWORD dword_F3208[8];

//----- (000BD6E8) --------------------------------------------------------
void *__fastcall sph_luffa384_addbits_and_close(unsigned int *a1, char a2, char a3, _BYTE *a4)
{
  unsigned int v5; // lr
  unsigned int *v6; // r3
  unsigned int v7; // r11
  int v8; // r5
  unsigned int v9; // r8
  int v10; // r6
  int v11; // r4
  int v12; // r11
  int v13; // r3
  int v14; // r2
  int v15; // lr
  int v16; // r1
  int v17; // r6
  int v18; // r0
  int v19; // r12
  int v20; // r4
  int v21; // r8
  int v22; // r4
  int v23; // r11
  int v24; // r5
  unsigned int v25; // lr
  int v26; // r12
  unsigned int v27; // r10
  int v28; // r2
  int v29; // r3
  int v30; // r9
  int v31; // r10
  int v32; // r12
  int v33; // r2
  int v34; // r10
  int v35; // r2
  int v36; // r8
  int v37; // r1
  int v38; // r5
  int v39; // r1
  int v40; // lr
  int v41; // r11
  int v42; // r0
  int v43; // r7
  int v44; // r2
  int v45; // r3
  int v46; // r4
  int v47; // r1
  int v48; // r7
  unsigned int v49; // lr
  int v50; // r8
  int v51; // r2
  int v52; // r6
  int v53; // r5
  int v54; // r4
  int v55; // r4
  int v56; // r0
  int v57; // r10
  unsigned int v58; // r3
  int v59; // r12
  int v60; // r11
  int v61; // r1
  int v62; // r2
  int v63; // r11
  int v64; // r9
  int v65; // r5
  int v66; // r6
  int v67; // r1
  int v68; // r7
  int v69; // r3
  int v70; // r0
  int v71; // r4
  int v72; // r12
  int v73; // r1
  int v74; // r2
  int v75; // r6
  int v76; // r1
  int v77; // r9
  int v78; // r0
  int v79; // r2
  int v80; // r4
  int v81; // lr
  int v82; // r3
  int v83; // r11
  int v84; // r0
  int v85; // r2
  int v86; // r1
  int v87; // r12
  int v88; // lr
  int v89; // r3
  int v90; // r4
  int v91; // r11
  int v92; // r9
  int v93; // r8
  int v94; // r0
  unsigned int v95; // lr
  int v96; // r2
  unsigned int v97; // r3
  int v98; // r12
  int v99; // r1
  int v100; // r4
  unsigned int v101; // r11
  int v102; // r2
  int v103; // r11
  int v104; // r10
  int v105; // r5
  int v106; // r6
  int v107; // r1
  int v108; // r7
  int v109; // r3
  int v110; // r0
  int v111; // r4
  int v112; // r12
  int v113; // r1
  int v114; // r2
  int v115; // r6
  int v116; // r1
  int v117; // r10
  int v118; // r0
  int v119; // r2
  int v120; // r4
  int v121; // lr
  int v122; // r3
  int v123; // r11
  int v124; // r0
  int v125; // r2
  int v126; // r1
  int v127; // r12
  int v128; // lr
  int v129; // r3
  int v130; // r4
  int v131; // r11
  int v132; // r8
  int v133; // r10
  int v134; // r0
  unsigned int v135; // lr
  int v136; // r2
  unsigned int v137; // r3
  int v138; // r12
  unsigned int v139; // r11
  int v140; // r4
  int v141; // r1
  int v142; // r2
  int v143; // r11
  int v144; // r9
  int v145; // r5
  int v146; // r6
  int v147; // r1
  int v148; // r7
  int v149; // r3
  int v150; // r0
  int v151; // r4
  int v152; // r12
  int v153; // r1
  int v154; // r2
  int v155; // r6
  int v156; // r1
  int v157; // r9
  int v158; // r0
  int v159; // r2
  int v160; // r4
  int v161; // lr
  int v162; // r3
  int v163; // r11
  int v164; // r0
  int v165; // r2
  int v166; // r1
  int v167; // r12
  int v168; // lr
  int v169; // r3
  int v170; // r4
  int v171; // r11
  int v172; // r9
  int v173; // r8
  int v174; // r0
  unsigned int v175; // lr
  int v176; // r2
  unsigned int v177; // r3
  int v178; // r12
  unsigned int v179; // r11
  int v180; // r4
  int v181; // r1
  int v182; // r2
  int v183; // r11
  int v184; // r10
  int v185; // r5
  int v186; // r6
  int v187; // r1
  int v188; // r7
  int v189; // r3
  int v190; // r0
  int v191; // r4
  int v192; // r12
  int v193; // r1
  int v194; // r2
  int v195; // r6
  int v196; // r1
  int v197; // r10
  int v198; // r0
  int v199; // r2
  int v200; // r4
  int v201; // lr
  int v202; // r3
  int v203; // r11
  int v204; // r0
  int v205; // r2
  int v206; // r1
  int v207; // r12
  int v208; // lr
  int v209; // r3
  int v210; // r4
  int v211; // r11
  int v212; // r2
  int v213; // r0
  int v214; // r5
  int v215; // r3
  void *result; // r0
  int v217; // r12
  int v218; // lr
  int v219; // r7
  int v220; // r3
  int v221; // r2
  int v222; // r1
  int v223; // r3
  unsigned int v224; // [sp+0h] [bp-DCh]
  int v225; // [sp+0h] [bp-DCh]
  int v226; // [sp+0h] [bp-DCh]
  int v227; // [sp+0h] [bp-DCh]
  int v228; // [sp+0h] [bp-DCh]
  int v229; // [sp+4h] [bp-D8h]
  unsigned int v230; // [sp+8h] [bp-D4h]
  unsigned int v231; // [sp+Ch] [bp-D0h]
  int v232; // [sp+10h] [bp-CCh]
  int v233; // [sp+10h] [bp-CCh]
  int v234; // [sp+10h] [bp-CCh]
  int v235; // [sp+14h] [bp-C8h]
  int v236; // [sp+14h] [bp-C8h]
  int v237; // [sp+14h] [bp-C8h]
  int v238; // [sp+18h] [bp-C4h]
  int v239; // [sp+18h] [bp-C4h]
  int v240; // [sp+1Ch] [bp-C0h]
  int v241; // [sp+1Ch] [bp-C0h]
  int v242; // [sp+1Ch] [bp-C0h]
  int v243; // [sp+20h] [bp-BCh]
  int v244; // [sp+20h] [bp-BCh]
  int v245; // [sp+20h] [bp-BCh]
  int v246; // [sp+24h] [bp-B8h]
  int v247; // [sp+24h] [bp-B8h]
  int v248; // [sp+24h] [bp-B8h]
  int v249; // [sp+24h] [bp-B8h]
  int v250; // [sp+28h] [bp-B4h]
  int v251; // [sp+28h] [bp-B4h]
  int v252; // [sp+28h] [bp-B4h]
  int v253; // [sp+2Ch] [bp-B0h]
  int v254; // [sp+2Ch] [bp-B0h]
  int v255; // [sp+2Ch] [bp-B0h]
  unsigned int v256; // [sp+30h] [bp-ACh]
  int v257; // [sp+30h] [bp-ACh]
  int v258; // [sp+30h] [bp-ACh]
  int v259; // [sp+30h] [bp-ACh]
  unsigned int v260; // [sp+34h] [bp-A8h]
  int v261; // [sp+34h] [bp-A8h]
  int v262; // [sp+34h] [bp-A8h]
  int v263; // [sp+38h] [bp-A4h]
  int v264; // [sp+38h] [bp-A4h]
  unsigned int v265; // [sp+3Ch] [bp-A0h]
  int v266; // [sp+3Ch] [bp-A0h]
  unsigned int v267; // [sp+3Ch] [bp-A0h]
  unsigned int v268; // [sp+40h] [bp-9Ch]
  int v269; // [sp+40h] [bp-9Ch]
  unsigned int v270; // [sp+40h] [bp-9Ch]
  unsigned int v271; // [sp+44h] [bp-98h]
  unsigned int v272; // [sp+44h] [bp-98h]
  unsigned int v273; // [sp+48h] [bp-94h]
  unsigned int v274; // [sp+48h] [bp-94h]
  unsigned int v275; // [sp+4Ch] [bp-90h]
  int v276; // [sp+4Ch] [bp-90h]
  unsigned int v277; // [sp+4Ch] [bp-90h]
  int v278; // [sp+50h] [bp-8Ch]
  int v279; // [sp+50h] [bp-8Ch]
  int v280; // [sp+50h] [bp-8Ch]
  unsigned int v281; // [sp+54h] [bp-88h]
  unsigned int v282; // [sp+54h] [bp-88h]
  unsigned int v283; // [sp+58h] [bp-84h]
  unsigned int v284; // [sp+58h] [bp-84h]
  unsigned int v285; // [sp+5Ch] [bp-80h]
  int v286; // [sp+5Ch] [bp-80h]
  unsigned int v287; // [sp+5Ch] [bp-80h]
  int v288; // [sp+60h] [bp-7Ch]
  int v289; // [sp+60h] [bp-7Ch]
  unsigned int v290; // [sp+64h] [bp-78h]
  int v291; // [sp+64h] [bp-78h]
  int v292; // [sp+64h] [bp-78h]
  unsigned int v293; // [sp+68h] [bp-74h]
  int v294; // [sp+68h] [bp-74h]
  int v295; // [sp+6Ch] [bp-70h]
  int v296; // [sp+6Ch] [bp-70h]
  int v297; // [sp+6Ch] [bp-70h]
  unsigned int v298; // [sp+70h] [bp-6Ch]
  int v299; // [sp+70h] [bp-6Ch]
  int v300; // [sp+70h] [bp-6Ch]
  int v301; // [sp+74h] [bp-68h]
  int v302; // [sp+74h] [bp-68h]
  int v303; // [sp+74h] [bp-68h]
  int v304; // [sp+78h] [bp-64h]
  int v305; // [sp+78h] [bp-64h]
  int v306; // [sp+7Ch] [bp-60h]
  int v307; // [sp+7Ch] [bp-60h]
  int v308; // [sp+7Ch] [bp-60h]
  unsigned int v309; // [sp+80h] [bp-5Ch]
  unsigned int v310; // [sp+80h] [bp-5Ch]
  unsigned int v311; // [sp+84h] [bp-58h]
  int v312; // [sp+84h] [bp-58h]
  int v313; // [sp+88h] [bp-54h]
  unsigned int v315; // [sp+90h] [bp-4Ch]
  int v316; // [sp+90h] [bp-4Ch]
  unsigned int v317; // [sp+94h] [bp-48h]
  int v318; // [sp+94h] [bp-48h]
  unsigned int v319; // [sp+98h] [bp-44h]
  unsigned int v320; // [sp+9Ch] [bp-40h]
  unsigned int v321; // [sp+A0h] [bp-3Ch]
  int v322; // [sp+A0h] [bp-3Ch]
  int v323; // [sp+A4h] [bp-38h]
  int v324; // [sp+ACh] [bp-30h]
  unsigned int v325; // [sp+B0h] [bp-2Ch]
  int v326; // [sp+B0h] [bp-2Ch]
  int v327; // [sp+B4h] [bp-28h]
  int v328; // [sp+B8h] [bp-24h]

  v5 = a1[8];
  *((_BYTE *)a1 + v5) = (128 >> a3) | a2 & -(128 >> a3);
  memset((char *)a1 + v5 + 1, 0, 31 - v5);
  v6 = a1;
  v7 = a1[12];
  v315 = a1[10];
  v298 = a1[20];
  v8 = v7 ^ v298;
  v293 = a1[18];
  v325 = a1[9];
  v9 = a1[11] ^ a1[19];
  v317 = a1[11];
  v256 = a1[14];
  v260 = a1[15];
  v10 = v6[13] ^ v6[21];
  v11 = v315 ^ v293;
  v295 = v6[19];
  v263 = v6[16];
  v290 = v7;
  v301 = v6[13];
  v306 = v6[17];
  v304 = v6[21];
  v265 = v6[22];
  v268 = v6[23];
  v324 = 0;
  v309 = v6[24];
  v240 = v6[25];
  v232 = v6[26];
  v235 = v6[27];
  v238 = v6[28];
  v278 = v6[29];
  v271 = v6[30];
  v273 = v6[31];
  v275 = v6[32];
  v253 = v6[33];
  v243 = v6[34];
  v246 = v6[35];
  v250 = v6[36];
  v288 = v6[37];
  v281 = v6[38];
  v283 = v6[39];
  v285 = v6[40];
  while ( 1 )
  {
    v311 = bswap32(a1[1]);
    v231 = bswap32(a1[6]);
    v230 = bswap32(a1[7]);
    v12 = v273 ^ v283 ^ v260 ^ v268;
    v320 = bswap32(a1[2]);
    v321 = bswap32(a1[3]);
    v224 = bswap32(a1[5]);
    v13 = v275 ^ v285 ^ v263 ^ v309;
    v14 = v8 ^ v238 ^ v250 ^ v13;
    v15 = v10 ^ v278 ^ v288;
    v16 = v9 ^ v235 ^ v246 ^ v13;
    v17 = v12 ^ v309;
    v313 = v12 ^ v285;
    v229 = v12 ^ v275;
    v286 = v15 ^ v256;
    v18 = v281 ^ v256 ^ v265 ^ v271;
    v319 = bswap32(*a1);
    v302 = v301 ^ v14;
    v257 = v18 ^ v260;
    v19 = v11 ^ v232 ^ v243;
    v276 = v304 ^ v14;
    v20 = v278;
    v279 = v18 ^ v268;
    v21 = v14 ^ v20;
    v22 = v12 ^ v263;
    v328 = v18 ^ v273;
    v323 = v18 ^ v283;
    v23 = v15 ^ v265;
    v24 = v15 ^ v271;
    v266 = v15 ^ v281;
    v25 = bswap32(a1[4]);
    v269 = v317 ^ v19;
    v327 = v295 ^ v19;
    v261 = v19 ^ v235;
    v264 = v19 ^ v246;
    v318 = v14 ^ v288;
    v26 = v231 ^ v320 ^ v230;
    v27 = v298;
    v299 = v13 ^ v306;
    v247 = v27 ^ v16;
    v28 = v306 ^ v240 ^ v253;
    v296 = v16 ^ v238;
    v251 = v16 ^ v250;
    v307 = v13 ^ v240;
    v254 = v13 ^ v253;
    v241 = v13 ^ v325;
    v29 = v13 ^ v28 ^ v325;
    v289 = __ROR4__(v224 ^ v311 ^ v231 ^ v313 ^ v21 ^ v251, 29);
    v236 = v290 ^ v16;
    v30 = v24 ^ v26;
    v31 = v229 ^ v26 ^ v276;
    v32 = v279 ^ v24;
    v305 = __ROR4__(v17 ^ v321 ^ v230 ^ v302 ^ v247, 31);
    v33 = v22 ^ v279 ^ v231;
    v280 = __ROR4__(v31 ^ v16 ^ v238, 30);
    v282 = __ROR4__(v30 ^ v318, 29);
    v310 = __ROR4__(v33, 31);
    v274 = __ROR4__(v32 ^ v25, 30);
    v34 = v293 ^ v29;
    v316 = v315 ^ v29;
    v233 = v29 ^ v232;
    v244 = v29 ^ v243;
    v35 = v21;
    v36 = v286;
    v239 = v261 ^ v229 ^ v311 ^ v231 ^ v247;
    v37 = v269;
    v291 = v269 ^ v22 ^ v321;
    v270 = __ROR4__(v257 ^ v23 ^ v224, 31);
    v38 = v25 ^ v286 ^ v276;
    v284 = __ROR4__(v321 ^ v230 ^ v328 ^ v266, 29);
    v272 = __ROR4__(v23 ^ v321 ^ v230 ^ v35, 30);
    v277 = __ROR4__(v17 ^ v328 ^ v224, 30);
    v326 = v311 ^ v37;
    v322 = v257 ^ v313;
    v39 = v266;
    v267 = __ROR4__(v38, 31);
    v287 = __ROR4__(v229 ^ v323 ^ v25, 29);
    v258 = v224 ^ v39;
    v40 = v25 ^ v22 ^ v236;
    v41 = v224 ^ v231 ^ v254 ^ v313;
    v248 = v22 ^ v254;
    v42 = v241 ^ v17;
    v312 = v22 ^ v241 ^ v311;
    v43 = v307 ^ v313;
    v44 = v299 ^ v229;
    v45 = v299 ^ v17;
    v46 = v307 ^ v229 ^ v231 ^ v230 ^ v34;
    v47 = v231 ^ v230 ^ v261;
    v292 = v291 ^ v251;
    v259 = v258 ^ v302;
    v303 = v40 ^ v318;
    v262 = v36 ^ v323 ^ v231;
    v300 = v17 ^ v327 ^ v320 ^ v230 ^ v236;
    v252 = v224 ^ v319 ^ v230 ^ v264 ^ v313 ^ v296;
    v242 = v231 ^ v44;
    v308 = v230 ^ v42;
    v255 = v224 ^ v43;
    v48 = v248 ^ v319;
    v49 = v259;
    v50 = 0;
    v51 = v320 ^ v264 ^ v316;
    v294 = v45 ^ v319 ^ v230 ^ v316;
    v52 = v233;
    v234 = v46;
    v297 = v326 ^ v34;
    v53 = v244;
    v237 = v327 ^ v319 ^ v230 ^ v52;
    v54 = v47 ^ v244;
    v245 = v41 ^ v52;
    v249 = v54;
    v55 = v48;
    v56 = v312 ^ v53;
    v57 = -533497832;
    v58 = v262;
    v59 = v292;
    v60 = v322 ^ v230;
    v61 = v303;
    v225 = 809079974;
    while ( 1 )
    {
      v62 = v51 ^ v59;
      v63 = v60 ^ v61;
      v64 = v62 ^ v55 & v59;
      v65 = (v49 | v58) ^ v61;
      v66 = v55 & v59 ^ ~v56;
      v67 = v61 & v49;
      v68 = v66 | v64;
      v69 = ~v58 ^ v67;
      v70 = (v55 | v56) ^ v59;
      v71 = v55 ^ (v66 | v64);
      v72 = v63 & v65 ^ v69;
      v73 = v67 ^ v63;
      v74 = v62 & v70 ^ v66;
      v75 = v69 | v73;
      v76 = v73 ^ v71 ^ v72;
      v77 = v64 ^ v74;
      v78 = ~v70 ^ v68;
      v79 = v74 & v68;
      v80 = v76 ^ __ROR4__(v71, 30);
      v81 = v49 ^ v75 ^ v78;
      v82 = ~v65 ^ v75 ^ v79;
      v83 = v72 & v75 ^ v77;
      v84 = v81 ^ __ROR4__(v78, 30);
      v85 = v82 ^ __ROR4__(v79, 30);
      v86 = v80 ^ __ROR4__(v76, 18);
      v87 = v83 ^ __ROR4__(v77, 30);
      v88 = v84 ^ __ROR4__(v81, 18);
      v89 = v85 ^ __ROR4__(v82, 18);
      v90 = v86 ^ __ROR4__(v80, 22);
      v91 = v87 ^ __ROR4__(v83, 18);
      v56 = v88 ^ __ROR4__(v84, 22);
      v51 = v89 ^ __ROR4__(v85, 22);
      v59 = v91 ^ __ROR4__(v87, 22);
      v49 = __ROR4__(v88, 31);
      v58 = __ROR4__(v89, 31);
      v61 = v57 ^ __ROR4__(v86, 31);
      v60 = __ROR4__(v91, 31);
      ++v50;
      v55 = v90 ^ v225;
      if ( v50 == 8 )
        break;
      v225 = dword_F3088[v50];
      v57 = dword_F30A8[v50];
    }
    v92 = 23617341;
    v301 = v61;
    v315 = v56;
    v256 = v49;
    v93 = 0;
    v317 = v51;
    v260 = v58;
    v290 = v59;
    v263 = v60;
    v325 = v55;
    v94 = v294;
    v95 = v267;
    v96 = v297;
    v97 = v270;
    v98 = v300;
    v99 = v305;
    v100 = v308;
    v101 = v310;
    v226 = -1226960659;
    while ( 1 )
    {
      v102 = v96 ^ v98;
      v103 = v101 ^ v99;
      v104 = v102 ^ v100 & v98;
      v105 = (v95 | v97) ^ v99;
      v106 = v100 & v98 ^ ~v94;
      v107 = v99 & v95;
      v108 = v106 | v104;
      v109 = ~v97 ^ v107;
      v110 = (v100 | v94) ^ v98;
      v111 = v100 ^ (v106 | v104);
      v112 = v103 & v105 ^ v109;
      v113 = v107 ^ v103;
      v114 = v102 & v110 ^ v106;
      v115 = v109 | v113;
      v116 = v113 ^ v111 ^ v112;
      v117 = v104 ^ v114;
      v118 = ~v110 ^ v108;
      v119 = v114 & v108;
      v120 = v116 ^ __ROR4__(v111, 30);
      v121 = v95 ^ v115 ^ v118;
      v122 = ~v105 ^ v115 ^ v119;
      v123 = v112 & v115 ^ v117;
      v124 = v121 ^ __ROR4__(v118, 30);
      v125 = v122 ^ __ROR4__(v119, 30);
      v126 = v120 ^ __ROR4__(v116, 18);
      v127 = v123 ^ __ROR4__(v117, 30);
      v128 = v124 ^ __ROR4__(v121, 18);
      v129 = v125 ^ __ROR4__(v122, 18);
      v130 = v126 ^ __ROR4__(v120, 22);
      v131 = v127 ^ __ROR4__(v123, 18);
      v94 = v128 ^ __ROR4__(v124, 22);
      v96 = v129 ^ __ROR4__(v125, 22);
      v98 = v131 ^ __ROR4__(v127, 22);
      v95 = __ROR4__(v128, 31);
      v97 = __ROR4__(v129, 31);
      v99 = v92 ^ __ROR4__(v126, 31);
      v101 = __ROR4__(v131, 31);
      ++v93;
      v100 = v130 ^ v226;
      if ( v93 == 8 )
        break;
      v226 = dword_F30C8[v93];
      v92 = dword_F30E8[v93];
    }
    v132 = 0;
    v293 = v94;
    v265 = v95;
    v295 = v96;
    v268 = v97;
    v298 = v98;
    v309 = v101;
    v306 = v100;
    v304 = v99;
    v133 = -497126719;
    v134 = v234;
    v135 = v272;
    v136 = v237;
    v137 = v274;
    v138 = v239;
    v139 = v277;
    v140 = v242;
    v141 = v280;
    v227 = -64955950;
    while ( 1 )
    {
      v142 = v136 ^ v138;
      v143 = v139 ^ v141;
      v144 = v142 ^ v140 & v138;
      v145 = (v135 | v137) ^ v141;
      v146 = v140 & v138 ^ ~v134;
      v147 = v141 & v135;
      v148 = v146 | v144;
      v149 = ~v137 ^ v147;
      v150 = (v140 | v134) ^ v138;
      v151 = v140 ^ (v146 | v144);
      v152 = v143 & v145 ^ v149;
      v153 = v147 ^ v143;
      v154 = v142 & v150 ^ v146;
      v155 = v149 | v153;
      v156 = v153 ^ v151 ^ v152;
      v157 = v144 ^ v154;
      v158 = ~v150 ^ v148;
      v159 = v154 & v148;
      v160 = v156 ^ __ROR4__(v151, 30);
      v161 = v135 ^ v155 ^ v158;
      v162 = ~v145 ^ v155 ^ v159;
      v163 = v152 & v155 ^ v157;
      v164 = v161 ^ __ROR4__(v158, 30);
      v165 = v162 ^ __ROR4__(v159, 30);
      v166 = v160 ^ __ROR4__(v156, 18);
      v167 = v163 ^ __ROR4__(v157, 30);
      v168 = v164 ^ __ROR4__(v161, 18);
      v169 = v165 ^ __ROR4__(v162, 18);
      v170 = v166 ^ __ROR4__(v160, 22);
      v171 = v167 ^ __ROR4__(v163, 18);
      v134 = v168 ^ __ROR4__(v164, 22);
      v136 = v169 ^ __ROR4__(v165, 22);
      v138 = v171 ^ __ROR4__(v167, 22);
      v135 = __ROR4__(v168, 31);
      v137 = __ROR4__(v169, 31);
      v141 = v133 ^ __ROR4__(v166, 31);
      v139 = __ROR4__(v171, 31);
      ++v132;
      v140 = v170 ^ v227;
      if ( v132 == 8 )
        break;
      v227 = dword_F3108[v132];
      v133 = dword_F3128[v132];
    }
    v172 = -534197825;
    v232 = v134;
    v271 = v135;
    v173 = 0;
    v235 = v136;
    v273 = v137;
    v238 = v138;
    v275 = v139;
    v240 = v140;
    v278 = v141;
    v174 = v245;
    v175 = v282;
    v176 = v249;
    v177 = v284;
    v178 = v252;
    v179 = v287;
    v180 = v255;
    v181 = v289;
    v228 = -1307332699;
    while ( 1 )
    {
      v182 = v176 ^ v178;
      v183 = v179 ^ v181;
      v184 = v182 ^ v180 & v178;
      v185 = (v175 | v177) ^ v181;
      v186 = v180 & v178 ^ ~v174;
      v187 = v181 & v175;
      v188 = v186 | v184;
      v189 = ~v177 ^ v187;
      v190 = (v180 | v174) ^ v178;
      v191 = v180 ^ (v186 | v184);
      v192 = v183 & v185 ^ v189;
      v193 = v187 ^ v183;
      v194 = v182 & v190 ^ v186;
      v195 = v189 | v193;
      v196 = v193 ^ v191 ^ v192;
      v197 = v184 ^ v194;
      v198 = ~v190 ^ v188;
      v199 = v194 & v188;
      v200 = v196 ^ __ROR4__(v191, 30);
      v201 = v175 ^ v195 ^ v198;
      v202 = ~v185 ^ v195 ^ v199;
      v203 = v192 & v195 ^ v197;
      v204 = v201 ^ __ROR4__(v198, 30);
      v205 = v202 ^ __ROR4__(v199, 30);
      v206 = v200 ^ __ROR4__(v196, 18);
      v207 = v203 ^ __ROR4__(v197, 30);
      v208 = v204 ^ __ROR4__(v201, 18);
      v209 = v205 ^ __ROR4__(v202, 18);
      v210 = v206 ^ __ROR4__(v200, 22);
      v211 = v207 ^ __ROR4__(v203, 18);
      v174 = v208 ^ __ROR4__(v204, 22);
      v176 = v209 ^ __ROR4__(v205, 22);
      v178 = v211 ^ __ROR4__(v207, 22);
      v175 = __ROR4__(v208, 31);
      v177 = __ROR4__(v209, 31);
      v181 = v172 ^ __ROR4__(v206, 31);
      v179 = __ROR4__(v211, 31);
      ++v173;
      v180 = v210 ^ v228;
      if ( v173 == 8 )
        break;
      v228 = dword_F31E8[v173];
      v172 = dword_F3208[v173];
    }
    v283 = v177;
    v243 = v174;
    v281 = v175;
    v246 = v176;
    v250 = v178;
    v285 = v179;
    v253 = v180;
    v288 = v181;
    if ( v324 != 1 )
      break;
    v11 = v315 ^ v293;
    v9 = v317 ^ v295;
    v8 = v290 ^ v298;
    v10 = v301 ^ v304;
    v217 = v256 ^ v265 ^ v271 ^ v175;
    v218 = v260 ^ v268 ^ v273 ^ v177;
    v219 = v263 ^ v309 ^ v275 ^ v179;
    a4[3] = v325 ^ v306 ^ v240 ^ v253;
    *a4 = (v325 ^ v306 ^ v240 ^ v253) >> 24;
    a4[2] = (unsigned __int16)(v325 ^ v306 ^ v240 ^ v253) >> 8;
    a4[1] = (v325 ^ v306 ^ v240 ^ v253) >> 16;
    v220 = v315 ^ v293 ^ v232 ^ v174;
    a4[7] = v220;
    a4[4] = HIBYTE(v220);
    a4[5] = BYTE2(v220);
    v221 = v317 ^ v295 ^ v235 ^ v176;
    a4[11] = v221;
    a4[6] = BYTE1(v220);
    v222 = v290 ^ v298 ^ v238 ^ v250;
    a4[8] = HIBYTE(v221);
    a4[15] = v222;
    a4[23] = v217;
    a4[10] = BYTE1(v221);
    v223 = v301 ^ v304 ^ v278 ^ v288;
    a4[9] = BYTE2(v221);
    a4[12] = HIBYTE(v222);
    a4[19] = v223;
    a4[13] = BYTE2(v222);
    a4[14] = BYTE1(v222);
    a4[16] = HIBYTE(v223);
    a4[21] = BYTE2(v217);
    a4[17] = BYTE2(v223);
    a4[18] = BYTE1(v223);
    a4[20] = HIBYTE(v217);
    a4[22] = BYTE1(v217);
    a4[24] = HIBYTE(v218);
    a4[26] = BYTE1(v218);
    a4[25] = BYTE2(v218);
    a4[27] = v218;
    a4[31] = v219;
    a4[28] = HIBYTE(v219);
    a4[29] = BYTE2(v219);
    a4[30] = BYTE1(v219);
LABEL_18:
    ++v324;
  }
  if ( v324 != 2 )
  {
    memset(a1, 0, 0x20u);
    v11 = v315 ^ v293;
    v10 = v304 ^ v301;
    v8 = v290 ^ v298;
    v9 = v317 ^ v295;
    goto LABEL_18;
  }
  v212 = v180 ^ v325 ^ v306 ^ v240;
  v213 = v174 ^ v232 ^ v315 ^ v293;
  v214 = v235 ^ v317 ^ v295 ^ v246;
  v215 = v178 ^ v290 ^ v298 ^ v238;
  a4[35] = v212;
  a4[39] = v213;
  a4[43] = v214;
  a4[47] = v215;
  a4[32] = HIBYTE(v212);
  a4[33] = BYTE2(v212);
  a4[34] = BYTE1(v212);
  a4[36] = HIBYTE(v213);
  a4[37] = BYTE2(v213);
  a4[38] = BYTE1(v213);
  a4[40] = HIBYTE(v214);
  a4[41] = BYTE2(v214);
  a4[44] = HIBYTE(v215);
  a4[42] = BYTE1(v214);
  a4[45] = BYTE2(v215);
  a4[46] = BYTE1(v215);
  result = memcpy(a1 + 9, &unk_F3148, 0x80u);
  a1[8] = 0;
  return result;
}
// F3088: using guessed type _DWORD dword_F3088[8];
// F30A8: using guessed type _DWORD dword_F30A8[8];
// F30C8: using guessed type _DWORD dword_F30C8[8];
// F30E8: using guessed type _DWORD dword_F30E8[8];
// F3108: using guessed type _DWORD dword_F3108[8];
// F3128: using guessed type _DWORD dword_F3128[8];
// F31E8: using guessed type _DWORD dword_F31E8[8];
// F3208: using guessed type _DWORD dword_F3208[8];

//----- (000BE710) --------------------------------------------------------
void *__fastcall sph_luffa384_close(unsigned int *a1, _BYTE *a2)
{
  return sph_luffa384_addbits_and_close(a1, 0, 0, a2);
}

//----- (000BE720) --------------------------------------------------------
void *__fastcall sph_luffa512_init(int a1)
{
  void *result; // r0

  result = memcpy((void *)(a1 + 36), &unk_F3148, 0xA0u);
  *(_DWORD *)(a1 + 32) = 0;
  return result;
}

//----- (000BE748) --------------------------------------------------------
unsigned int __fastcall sph_luffa512(unsigned int result, char *a2, size_t a3)
{
  unsigned int v3; // r5
  size_t v4; // r4
  char *v5; // r0
  int v6; // r9
  int v7; // r2
  int v8; // r12
  int v9; // r11
  int v10; // r7
  int v11; // r6
  int v12; // lr
  int v13; // r4
  int v14; // r10
  unsigned int v15; // r0
  int v16; // r0
  int v17; // r11
  int v18; // r8
  int v19; // r1
  int v20; // r3
  int v21; // r10
  int v22; // r12
  int v23; // r4
  int v24; // lr
  int v25; // r4
  int v26; // r5
  int v27; // r8
  int v28; // r9
  int v29; // r3
  int v30; // r7
  int v31; // r2
  int v32; // r6
  int v33; // r9
  int v34; // r1
  int v35; // lr
  int v36; // r8
  int v37; // r9
  int v38; // lr
  int v39; // r10
  int v40; // r12
  int v41; // r5
  int v42; // r3
  int v43; // r8
  int v44; // r6
  int v45; // r7
  int v46; // r6
  int v47; // r4
  int v48; // r12
  int v49; // r7
  int v50; // r8
  int v51; // r1
  int v52; // r2
  int v53; // r11
  int v54; // r12
  int v55; // r10
  int v56; // r6
  int v57; // r0
  int v58; // lr
  int v59; // r0
  int v60; // r3
  int v61; // r2
  int v62; // r6
  int v63; // r4
  int v64; // r3
  int v65; // r7
  int v66; // r4
  int v67; // r11
  int v68; // r12
  int v69; // r3
  int v70; // r2
  int v71; // r1
  int v72; // r8
  int v73; // r0
  int v74; // r2
  int v75; // r10
  int v76; // r3
  int v77; // lr
  int v78; // r4
  int v79; // r2
  int v80; // r11
  int v81; // r9
  int v82; // r5
  int v83; // r6
  int v84; // r1
  int v85; // r7
  int v86; // r3
  int v87; // r0
  int v88; // r4
  int v89; // r12
  int v90; // r1
  int v91; // r2
  int v92; // r6
  int v93; // r1
  int v94; // r9
  int v95; // r0
  int v96; // r2
  int v97; // r4
  int v98; // lr
  int v99; // r3
  int v100; // r11
  int v101; // r0
  int v102; // r2
  int v103; // r1
  int v104; // r12
  int v105; // lr
  int v106; // r3
  int v107; // r4
  int v108; // r11
  int v109; // r9
  int v110; // r8
  int v111; // r0
  unsigned int v112; // lr
  int v113; // r2
  unsigned int v114; // r3
  int v115; // r12
  unsigned int v116; // r11
  int v117; // r4
  int v118; // r1
  int v119; // r2
  int v120; // r11
  int v121; // r10
  int v122; // r5
  int v123; // r6
  int v124; // r1
  int v125; // r7
  int v126; // r3
  int v127; // r0
  int v128; // r4
  int v129; // r12
  int v130; // r1
  int v131; // r2
  int v132; // r6
  int v133; // r1
  int v134; // r10
  int v135; // r0
  int v136; // r2
  int v137; // r4
  int v138; // lr
  int v139; // r3
  int v140; // r11
  int v141; // r0
  int v142; // r2
  int v143; // r1
  int v144; // r12
  int v145; // lr
  int v146; // r3
  int v147; // r4
  int v148; // r11
  int v149; // r8
  int v150; // r10
  int v151; // r0
  unsigned int v152; // lr
  int v153; // r2
  unsigned int v154; // r3
  int v155; // r12
  unsigned int v156; // r11
  int v157; // r4
  int v158; // r1
  int v159; // r2
  int v160; // r11
  int v161; // r9
  int v162; // r5
  int v163; // r6
  int v164; // r1
  int v165; // r7
  int v166; // r3
  int v167; // r0
  int v168; // r4
  int v169; // r12
  int v170; // r1
  int v171; // r2
  int v172; // r6
  int v173; // r1
  int v174; // r9
  int v175; // r0
  int v176; // r2
  int v177; // r4
  int v178; // lr
  int v179; // r3
  int v180; // r11
  int v181; // r0
  int v182; // r2
  int v183; // r1
  int v184; // r12
  int v185; // lr
  int v186; // r3
  int v187; // r4
  int v188; // r11
  int v189; // r9
  int v190; // r8
  int v191; // r0
  unsigned int v192; // lr
  int v193; // r2
  unsigned int v194; // r3
  int v195; // r12
  unsigned int v196; // r11
  int v197; // r4
  int v198; // r1
  int v199; // r2
  int v200; // r11
  int v201; // r10
  int v202; // r5
  int v203; // r6
  int v204; // r1
  int v205; // r7
  int v206; // r3
  int v207; // r0
  int v208; // r4
  int v209; // r12
  int v210; // r1
  int v211; // r2
  int v212; // r6
  int v213; // r1
  int v214; // r10
  int v215; // r0
  int v216; // r2
  int v217; // r4
  int v218; // lr
  int v219; // r3
  int v220; // r11
  int v221; // r0
  int v222; // r2
  int v223; // r1
  int v224; // r12
  int v225; // lr
  int v226; // r3
  int v227; // r4
  int v228; // r11
  int v229; // r10
  int v230; // r8
  unsigned int v231; // lr
  int v232; // r2
  unsigned int v233; // r3
  int v234; // r12
  size_t v235; // r11
  int v236; // r4
  int v237; // r1
  int v238; // r2
  int v239; // r11
  int v240; // r9
  int v241; // r5
  unsigned int v242; // r6
  int v243; // r1
  int v244; // r7
  int v245; // r3
  unsigned int v246; // r0
  int v247; // r4
  int v248; // r12
  int v249; // r1
  int v250; // r2
  int v251; // r6
  int v252; // r1
  int v253; // r9
  int v254; // r0
  int v255; // r2
  int v256; // r4
  int v257; // lr
  int v258; // r3
  int v259; // r11
  int v260; // r0
  int v261; // r2
  int v262; // r1
  int v263; // r12
  int v264; // lr
  int v265; // r3
  int v266; // r4
  int v267; // r11
  unsigned int v268; // r4
  size_t n; // [sp+0h] [bp-10Ch]
  int v270; // [sp+4h] [bp-108h]
  unsigned int v271; // [sp+4h] [bp-108h]
  int v272; // [sp+4h] [bp-108h]
  int v273; // [sp+4h] [bp-108h]
  int v274; // [sp+4h] [bp-108h]
  int v275; // [sp+4h] [bp-108h]
  int v276; // [sp+4h] [bp-108h]
  unsigned int *v277; // [sp+8h] [bp-104h]
  char *src; // [sp+Ch] [bp-100h]
  int v279; // [sp+10h] [bp-FCh]
  unsigned int v280; // [sp+10h] [bp-FCh]
  int v281; // [sp+14h] [bp-F8h]
  int v282; // [sp+14h] [bp-F8h]
  int v283; // [sp+18h] [bp-F4h]
  int v284; // [sp+18h] [bp-F4h]
  int v285; // [sp+18h] [bp-F4h]
  int v286; // [sp+1Ch] [bp-F0h]
  unsigned int v287; // [sp+1Ch] [bp-F0h]
  int v288; // [sp+20h] [bp-ECh]
  int v289; // [sp+20h] [bp-ECh]
  int v290; // [sp+20h] [bp-ECh]
  unsigned int v291; // [sp+24h] [bp-E8h]
  int v292; // [sp+24h] [bp-E8h]
  unsigned int v293; // [sp+24h] [bp-E8h]
  int v294; // [sp+28h] [bp-E4h]
  unsigned int v295; // [sp+28h] [bp-E4h]
  int v296; // [sp+28h] [bp-E4h]
  unsigned int v297; // [sp+2Ch] [bp-E0h]
  int v298; // [sp+2Ch] [bp-E0h]
  int v299; // [sp+2Ch] [bp-E0h]
  unsigned int v300; // [sp+2Ch] [bp-E0h]
  int v301; // [sp+30h] [bp-DCh]
  int v302; // [sp+30h] [bp-DCh]
  int v303; // [sp+30h] [bp-DCh]
  int v304; // [sp+30h] [bp-DCh]
  int v305; // [sp+30h] [bp-DCh]
  unsigned int v306; // [sp+34h] [bp-D8h]
  int v307; // [sp+34h] [bp-D8h]
  int v308; // [sp+34h] [bp-D8h]
  unsigned int v309; // [sp+34h] [bp-D8h]
  int v310; // [sp+38h] [bp-D4h]
  int v311; // [sp+38h] [bp-D4h]
  int v312; // [sp+38h] [bp-D4h]
  int v313; // [sp+38h] [bp-D4h]
  int v314; // [sp+3Ch] [bp-D0h]
  int v315; // [sp+3Ch] [bp-D0h]
  int v316; // [sp+3Ch] [bp-D0h]
  int v317; // [sp+40h] [bp-CCh]
  int v318; // [sp+40h] [bp-CCh]
  int v319; // [sp+40h] [bp-CCh]
  int v320; // [sp+40h] [bp-CCh]
  unsigned int v321; // [sp+44h] [bp-C8h]
  int v322; // [sp+44h] [bp-C8h]
  int v323; // [sp+44h] [bp-C8h]
  unsigned int v324; // [sp+44h] [bp-C8h]
  int v325; // [sp+48h] [bp-C4h]
  unsigned int v326; // [sp+48h] [bp-C4h]
  int v327; // [sp+48h] [bp-C4h]
  unsigned int v328; // [sp+4Ch] [bp-C0h]
  int v329; // [sp+4Ch] [bp-C0h]
  int v330; // [sp+4Ch] [bp-C0h]
  unsigned int v331; // [sp+4Ch] [bp-C0h]
  int v332; // [sp+50h] [bp-BCh]
  unsigned int v333; // [sp+50h] [bp-BCh]
  int v334; // [sp+50h] [bp-BCh]
  unsigned int v335; // [sp+54h] [bp-B8h]
  int v336; // [sp+54h] [bp-B8h]
  unsigned int v337; // [sp+54h] [bp-B8h]
  int v338; // [sp+58h] [bp-B4h]
  int v339; // [sp+58h] [bp-B4h]
  int v340; // [sp+58h] [bp-B4h]
  int v341; // [sp+58h] [bp-B4h]
  int v342; // [sp+5Ch] [bp-B0h]
  int v343; // [sp+5Ch] [bp-B0h]
  int v344; // [sp+5Ch] [bp-B0h]
  int v345; // [sp+5Ch] [bp-B0h]
  int v346; // [sp+60h] [bp-ACh]
  unsigned int v347; // [sp+60h] [bp-ACh]
  int v348; // [sp+60h] [bp-ACh]
  unsigned int v349; // [sp+64h] [bp-A8h]
  int v350; // [sp+64h] [bp-A8h]
  unsigned int v351; // [sp+64h] [bp-A8h]
  int v352; // [sp+68h] [bp-A4h]
  int v353; // [sp+68h] [bp-A4h]
  int v354; // [sp+68h] [bp-A4h]
  int v355; // [sp+68h] [bp-A4h]
  int v356; // [sp+68h] [bp-A4h]
  unsigned int v357; // [sp+6Ch] [bp-A0h]
  int v358; // [sp+6Ch] [bp-A0h]
  int v359; // [sp+6Ch] [bp-A0h]
  unsigned int v360; // [sp+6Ch] [bp-A0h]
  unsigned int v361; // [sp+70h] [bp-9Ch]
  int v362; // [sp+70h] [bp-9Ch]
  unsigned int v363; // [sp+70h] [bp-9Ch]
  int v364; // [sp+74h] [bp-98h]
  int v365; // [sp+74h] [bp-98h]
  int v366; // [sp+74h] [bp-98h]
  int v367; // [sp+74h] [bp-98h]
  int v368; // [sp+78h] [bp-94h]
  int v369; // [sp+78h] [bp-94h]
  int v370; // [sp+78h] [bp-94h]
  int v371; // [sp+78h] [bp-94h]
  unsigned int v372; // [sp+7Ch] [bp-90h]
  int v373; // [sp+7Ch] [bp-90h]
  int v374; // [sp+7Ch] [bp-90h]
  int v375; // [sp+7Ch] [bp-90h]
  unsigned int v376; // [sp+80h] [bp-8Ch]
  int v377; // [sp+80h] [bp-8Ch]
  int v378; // [sp+80h] [bp-8Ch]
  unsigned int v379; // [sp+80h] [bp-8Ch]
  unsigned int v380; // [sp+84h] [bp-88h]
  int v381; // [sp+84h] [bp-88h]
  int v382; // [sp+84h] [bp-88h]
  unsigned int v383; // [sp+84h] [bp-88h]
  int v384; // [sp+88h] [bp-84h]
  int v385; // [sp+88h] [bp-84h]
  int v386; // [sp+88h] [bp-84h]
  int v387; // [sp+88h] [bp-84h]
  int v388; // [sp+8Ch] [bp-80h]
  int v389; // [sp+8Ch] [bp-80h]
  int v390; // [sp+90h] [bp-7Ch]
  int v391; // [sp+90h] [bp-7Ch]
  int v392; // [sp+90h] [bp-7Ch]
  int v393; // [sp+94h] [bp-78h]
  int v394; // [sp+94h] [bp-78h]
  int v395; // [sp+94h] [bp-78h]
  int v396; // [sp+94h] [bp-78h]
  int v397; // [sp+98h] [bp-74h]
  unsigned int v398; // [sp+98h] [bp-74h]
  int v399; // [sp+98h] [bp-74h]
  size_t v400; // [sp+9Ch] [bp-70h]
  size_t v401; // [sp+9Ch] [bp-70h]
  size_t v402; // [sp+9Ch] [bp-70h]
  size_t v403; // [sp+9Ch] [bp-70h]
  int v404; // [sp+A0h] [bp-6Ch]
  int v405; // [sp+A0h] [bp-6Ch]
  int v406; // [sp+A4h] [bp-68h]
  int v407; // [sp+A8h] [bp-64h]
  int v408; // [sp+A8h] [bp-64h]
  int v409; // [sp+A8h] [bp-64h]
  int v410; // [sp+ACh] [bp-60h]
  int v411; // [sp+ACh] [bp-60h]
  int v412; // [sp+ACh] [bp-60h]
  int v413; // [sp+B0h] [bp-5Ch]
  int v414; // [sp+B0h] [bp-5Ch]
  int v415; // [sp+B0h] [bp-5Ch]
  int v416; // [sp+B4h] [bp-58h]
  int v417; // [sp+B4h] [bp-58h]
  int v418; // [sp+B4h] [bp-58h]
  int v419; // [sp+B8h] [bp-54h]
  int v420; // [sp+B8h] [bp-54h]
  int v421; // [sp+B8h] [bp-54h]
  int v422; // [sp+BCh] [bp-50h]
  int v423; // [sp+BCh] [bp-50h]
  int v424; // [sp+BCh] [bp-50h]
  int v425; // [sp+C0h] [bp-4Ch]
  int v426; // [sp+C0h] [bp-4Ch]
  int v427; // [sp+C0h] [bp-4Ch]
  int v428; // [sp+C4h] [bp-48h]
  int v429; // [sp+C4h] [bp-48h]
  int v430; // [sp+C8h] [bp-44h]
  int v431; // [sp+C8h] [bp-44h]
  int v432; // [sp+CCh] [bp-40h]
  int v433; // [sp+CCh] [bp-40h]
  int v434; // [sp+D0h] [bp-3Ch]
  int v435; // [sp+D4h] [bp-38h]
  int v436; // [sp+D4h] [bp-38h]
  int v437; // [sp+D8h] [bp-34h]
  int v438; // [sp+DCh] [bp-30h]
  int v439; // [sp+E4h] [bp-28h]
  int v440; // [sp+E8h] [bp-24h]
  int v441; // [sp+ECh] [bp-20h]

  v3 = *(_DWORD *)(result + 32);
  v277 = (unsigned int *)result;
  v4 = 32 - v3;
  n = a3;
  src = a2;
  if ( a3 < 32 - v3 )
  {
    v268 = result;
    result = (unsigned int)memcpy((void *)(result + v3), a2, a3);
    *(_DWORD *)(v268 + 32) = n + v3;
  }
  else
  {
    v283 = *(_DWORD *)(result + 36);
    v404 = *(_DWORD *)(result + 40);
    v279 = *(_DWORD *)(result + 44);
    v410 = *(_DWORD *)(result + 48);
    v286 = *(_DWORD *)(result + 52);
    v281 = *(_DWORD *)(result + 56);
    v406 = *(_DWORD *)(result + 60);
    v407 = *(_DWORD *)(result + 64);
    v310 = *(_DWORD *)(result + 68);
    v288 = *(_DWORD *)(result + 72);
    v294 = *(_DWORD *)(result + 76);
    v301 = *(_DWORD *)(result + 80);
    v314 = *(_DWORD *)(result + 84);
    v291 = *(_DWORD *)(result + 88);
    v297 = *(_DWORD *)(result + 92);
    v306 = *(_DWORD *)(result + 96);
    v338 = *(_DWORD *)(result + 100);
    v317 = *(_DWORD *)(result + 104);
    v325 = *(_DWORD *)(result + 108);
    v332 = *(_DWORD *)(result + 112);
    v342 = *(_DWORD *)(result + 116);
    v321 = *(_DWORD *)(result + 120);
    v328 = *(_DWORD *)(result + 124);
    v335 = *(_DWORD *)(result + 128);
    v364 = *(_DWORD *)(result + 132);
    v346 = *(_DWORD *)(result + 136);
    v352 = *(_DWORD *)(result + 140);
    v393 = *(_DWORD *)(result + 144);
    v368 = *(_DWORD *)(result + 148);
    v349 = *(_DWORD *)(result + 152);
    v357 = *(_DWORD *)(result + 156);
    v361 = *(_DWORD *)(result + 160);
    v388 = *(_DWORD *)(result + 164);
    v372 = *(_DWORD *)(result + 168);
    v397 = *(_DWORD *)(result + 172);
    v384 = *(_DWORD *)(result + 176);
    v390 = *(_DWORD *)(result + 180);
    v376 = *(_DWORD *)(result + 184);
    v380 = *(_DWORD *)(result + 188);
    v400 = *(_DWORD *)(result + 192);
    if ( a3 )
    {
      while ( 1 )
      {
        if ( v4 >= n )
          v4 = n;
        v5 = (char *)v277 + v3;
        v3 += v4;
        result = (unsigned int)memcpy(v5, src, v4);
        n -= v4;
        src += v4;
        if ( v3 == 32 )
        {
          v6 = v410;
          v7 = v400 ^ v361 ^ v335 ^ v306 ^ v407;
          v8 = v332 ^ v393 ^ v410 ^ v301 ^ v384 ^ v7;
          v9 = v297 ^ v406 ^ v357 ^ v328 ^ v380;
          v10 = v372 ^ v404 ^ v288 ^ v346 ^ v317;
          v411 = v10 ^ v397;
          v11 = v397 ^ v352 ^ v279 ^ v294 ^ v325 ^ v7;
          v12 = v281 ^ v291 ^ v349 ^ v321 ^ v376;
          v413 = v8 ^ v390;
          v13 = v11 ^ v393;
          v270 = v11 ^ v6;
          v14 = v9 ^ v335;
          v336 = v9 ^ v407;
          v15 = v306;
          v307 = v9 ^ v400;
          v16 = v9 ^ v15;
          v17 = v9 ^ v361;
          v394 = v10 ^ v325;
          v362 = v10 ^ v294;
          v401 = v10 ^ v352;
          v381 = v12 ^ v380;
          v18 = v301;
          v19 = v388 ^ v338 ^ v283 ^ v310 ^ v364 ^ v7;
          v302 = v14;
          v353 = v11 ^ v18;
          v432 = v11 ^ v384;
          v419 = v11 ^ v332;
          v408 = v11 ^ v6 ^ v10 ^ v397 ^ v307;
          v416 = v12 ^ v297;
          v425 = v12 ^ v328;
          v358 = v12 ^ v357;
          v20 = v368 ^ v342 ^ v286 ^ v314 ^ v390;
          v298 = v8 ^ v286;
          v329 = v8 ^ v314;
          v422 = v8 ^ v342;
          v385 = v13 ^ v8 ^ v390 ^ v17;
          v434 = v13 ^ v10 ^ v325 ^ v14;
          v21 = v12 ^ v406;
          v326 = bswap32(*v277);
          v22 = v8 ^ v368;
          v315 = v336 ^ v381;
          v295 = bswap32(v277[7]);
          v430 = v19 ^ v372;
          v391 = v10 ^ v279;
          v23 = v283;
          v284 = v307 ^ v358;
          v24 = v20 ^ v281;
          v25 = v7 ^ v23;
          v343 = v11 ^ v6 ^ v329;
          v26 = v20 ^ v291;
          v27 = v20 ^ v349;
          v428 = v7 ^ v364;
          v28 = v20 ^ v321;
          v29 = v20 ^ v376;
          v280 = bswap32(v277[6]);
          v398 = bswap32(v277[2]);
          v333 = bswap32(v277[1]);
          v369 = v270 ^ v411 ^ v307 ^ v336 ^ v381 ^ v385;
          v287 = bswap32(v277[4]);
          v271 = bswap32(v277[5]);
          v30 = v19 ^ v346;
          v292 = v19 ^ v404;
          v322 = v19 ^ v288;
          v318 = v19 ^ v317;
          v311 = v7 ^ v310;
          v377 = v7 ^ v338;
          v31 = v7 ^ v388;
          v373 = v25 ^ v307;
          v344 = v343 ^ v336;
          v435 = v24 ^ v413;
          v365 = v24 ^ v416;
          v289 = v416 ^ v302;
          v405 = v329 ^ v28;
          v414 = v28 ^ v358;
          v32 = v419 ^ v22;
          v417 = v22 ^ v29;
          v33 = v422;
          v34 = v362 ^ v16 ^ v419;
          v423 = v21 ^ v29;
          v35 = v27 ^ v381;
          v36 = v27 ^ v33;
          v420 = v35;
          v37 = v353 ^ v33 ^ v16;
          v38 = v21 ^ v16;
          v39 = v32 ^ v302;
          v347 = bswap32(v277[3]);
          v40 = v401 ^ v17 ^ v432;
          v382 = v298 ^ v432 ^ v307;
          v350 = v298 ^ v26;
          v41 = v26 ^ v425;
          v282 = v425 ^ v17;
          v330 = v30;
          v426 = v369 ^ v287;
          v370 = v30 ^ v411;
          v395 = v322 ^ v394;
          v439 = v36 ^ v385;
          v339 = v292 ^ v362;
          v299 = v318 ^ v401;
          v42 = v41 ^ v36;
          v43 = v31 ^ v307;
          v402 = v17 ^ v31;
          v386 = v302 ^ v428;
          v44 = v377 ^ v302;
          v359 = v16 ^ v377;
          v308 = v430 ^ v17 ^ v428;
          v378 = v391 ^ v430;
          v303 = v336 ^ v311;
          v45 = v311 ^ v16;
          v354 = v353 ^ v391 ^ v336;
          v433 = v34 ^ v289 ^ v344;
          v312 = v322 ^ v25 ^ v336;
          v46 = v44 ^ v330;
          v47 = v40 ^ v284 ^ v39;
          v48 = v40 ^ v391 ^ v430;
          v437 = v405 ^ v39;
          v49 = v45 ^ v318;
          v323 = v34 ^ v299;
          v392 = __ROR4__(v426 ^ v271 ^ v326 ^ v295, 28);
          v50 = v43 ^ v292;
          v441 = v48 ^ v315;
          v440 = v373 ^ v315 ^ v308 ^ v287;
          v331 = __ROR4__(v42 ^ v287, 30);
          v429 = v292 ^ v362 ^ v408 ^ v38;
          v293 = __ROR4__(v37 ^ v350 ^ v287, 31);
          v438 = v434 ^ v370 ^ v284;
          v427 = v299 ^ v308;
          v300 = __ROR4__(v365 ^ v405 ^ v271, 31);
          v51 = v420 ^ v435;
          v309 = __ROR4__(v280 ^ v38 ^ v41, 31);
          v319 = v38 ^ v373;
          v431 = v344 ^ v435;
          v52 = v282 ^ v420 ^ v287;
          v53 = v284 ^ v423;
          v424 = v350 ^ v423;
          v421 = v339 ^ v49;
          v54 = v414 ^ v417;
          v55 = v323 ^ v282;
          v363 = __ROR4__(v52, 29);
          v412 = v370 ^ v50;
          v337 = __ROR4__(v289 ^ v414 ^ v271, 30);
          v409 = v312 ^ v378;
          v340 = v365 ^ v315;
          v366 = v402 ^ v315;
          v436 = v402 ^ v284 ^ v46;
          v415 = v395 ^ v46;
          v56 = v354 ^ v395;
          v57 = v354 ^ v38;
          v58 = v38 ^ v303 ^ v50;
          v59 = v57 ^ v382;
          v60 = v271 ^ v333 ^ v280;
          v61 = v280 ^ v398 ^ v295;
          v355 = v47 ^ v60;
          v374 = v417 ^ v382 ^ v60;
          v62 = v56 ^ v289;
          v63 = v359 ^ v289 ^ v312;
          v304 = v303 ^ v289;
          v64 = v386 ^ v284;
          v418 = v386 ^ v282 ^ v49;
          v65 = v359 ^ v282;
          v316 = __ROR4__(v433 ^ v347 ^ v295, 31);
          v324 = __ROR4__(v437 ^ v347 ^ v295, 30);
          v360 = __ROR4__(v54 ^ v347 ^ v295, 29);
          v403 = __ROR4__(v53 ^ v347 ^ v295, 28);
          v345 = __ROR4__(v434 ^ v282 ^ v37 ^ v61, 30);
          v351 = __ROR4__(v439 ^ v61, 29);
          v371 = __ROR4__(v355, 29);
          v383 = __ROR4__(v61 ^ v51, 28);
          v396 = v438 ^ v271 ^ v326 ^ v295;
          v379 = __ROR4__(v374, 28);
          v285 = v326 ^ v319;
          v375 = v440 ^ v271;
          v66 = v63 ^ v326 ^ v295;
          v327 = v415 ^ v326 ^ v295;
          v290 = v66;
          v313 = v295 ^ v304;
          v67 = v295 ^ v340;
          v389 = v287 ^ v366;
          v367 = v271 ^ v64;
          v341 = v280 ^ v65;
          v387 = v441 ^ v287 ^ v280 ^ v295;
          v320 = v418 ^ v280 ^ v295;
          v356 = v427 ^ v280 ^ v295;
          v68 = v429 ^ v347;
          v305 = v62 ^ v398 ^ v295;
          v69 = v398 ^ v409;
          v70 = v58 ^ v333;
          v71 = v59 ^ v287;
          v296 = v333 ^ v421;
          v334 = v55 ^ v333 ^ v280;
          v399 = v412 ^ v271 ^ v280;
          v72 = 0;
          v73 = v70;
          v348 = v436 ^ v271 ^ v280;
          v74 = v69;
          v75 = -533497832;
          v76 = v424 ^ v280;
          v77 = v431 ^ v271;
          v78 = v285;
          v272 = 809079974;
          while ( 1 )
          {
            v79 = v74 ^ v68;
            v80 = v67 ^ v71;
            v81 = v79 ^ v78 & v68;
            v82 = (v77 | v76) ^ v71;
            v83 = v78 & v68 ^ ~v73;
            v84 = v71 & v77;
            v85 = v83 | v81;
            v86 = ~v76 ^ v84;
            v87 = (v78 | v73) ^ v68;
            v88 = v78 ^ (v83 | v81);
            v89 = v80 & v82 ^ v86;
            v90 = v84 ^ v80;
            v91 = v79 & v87 ^ v83;
            v92 = v86 | v90;
            v93 = v90 ^ v88 ^ v89;
            v94 = v81 ^ v91;
            v95 = ~v87 ^ v85;
            v96 = v91 & v85;
            v97 = v93 ^ __ROR4__(v88, 30);
            v98 = v77 ^ v92 ^ v95;
            v99 = ~v82 ^ v92 ^ v96;
            v100 = v89 & v92 ^ v94;
            v101 = v98 ^ __ROR4__(v95, 30);
            v102 = v99 ^ __ROR4__(v96, 30);
            v103 = v97 ^ __ROR4__(v93, 18);
            v104 = v100 ^ __ROR4__(v94, 30);
            v105 = v101 ^ __ROR4__(v98, 18);
            v106 = v102 ^ __ROR4__(v99, 18);
            v107 = v103 ^ __ROR4__(v97, 22);
            v108 = v104 ^ __ROR4__(v100, 18);
            v73 = v105 ^ __ROR4__(v101, 22);
            v74 = v106 ^ __ROR4__(v102, 22);
            v68 = v108 ^ __ROR4__(v104, 22);
            v77 = __ROR4__(v105, 31);
            v76 = __ROR4__(v106, 31);
            v71 = v75 ^ __ROR4__(v103, 31);
            v67 = __ROR4__(v108, 31);
            ++v72;
            v78 = v107 ^ v272;
            if ( v72 == 8 )
              break;
            v272 = dword_F3088[v72];
            v75 = dword_F30A8[v72];
          }
          v109 = 23617341;
          v404 = v73;
          v281 = v77;
          v110 = 0;
          v279 = v74;
          v406 = v76;
          v410 = v68;
          v407 = v67;
          v283 = v78;
          v286 = v71;
          v111 = v290;
          v112 = v293;
          v113 = v296;
          v114 = v300;
          v115 = v305;
          v116 = v309;
          v117 = v313;
          v118 = v316;
          v273 = -1226960659;
          while ( 1 )
          {
            v119 = v113 ^ v115;
            v120 = v116 ^ v118;
            v121 = v119 ^ v117 & v115;
            v122 = (v112 | v114) ^ v118;
            v123 = v117 & v115 ^ ~v111;
            v124 = v118 & v112;
            v125 = v123 | v121;
            v126 = ~v114 ^ v124;
            v127 = (v117 | v111) ^ v115;
            v128 = v117 ^ (v123 | v121);
            v129 = v120 & v122 ^ v126;
            v130 = v124 ^ v120;
            v131 = v119 & v127 ^ v123;
            v132 = v126 | v130;
            v133 = v130 ^ v128 ^ v129;
            v134 = v121 ^ v131;
            v135 = ~v127 ^ v125;
            v136 = v131 & v125;
            v137 = v133 ^ __ROR4__(v128, 30);
            v138 = v112 ^ v132 ^ v135;
            v139 = ~v122 ^ v132 ^ v136;
            v140 = v129 & v132 ^ v134;
            v141 = v138 ^ __ROR4__(v135, 30);
            v142 = v139 ^ __ROR4__(v136, 30);
            v143 = v137 ^ __ROR4__(v133, 18);
            v144 = v140 ^ __ROR4__(v134, 30);
            v145 = v141 ^ __ROR4__(v138, 18);
            v146 = v142 ^ __ROR4__(v139, 18);
            v147 = v143 ^ __ROR4__(v137, 22);
            v148 = v144 ^ __ROR4__(v140, 18);
            v111 = v145 ^ __ROR4__(v141, 22);
            v113 = v146 ^ __ROR4__(v142, 22);
            v115 = v148 ^ __ROR4__(v144, 22);
            v112 = __ROR4__(v145, 31);
            v114 = __ROR4__(v146, 31);
            v118 = v109 ^ __ROR4__(v143, 31);
            v116 = __ROR4__(v148, 31);
            ++v110;
            v117 = v147 ^ v273;
            if ( v110 == 8 )
              break;
            v273 = dword_F30C8[v110];
            v109 = dword_F30E8[v110];
          }
          v149 = 0;
          v288 = v111;
          v291 = v112;
          v294 = v113;
          v297 = v114;
          v301 = v115;
          v306 = v116;
          v310 = v117;
          v314 = v118;
          v150 = -497126719;
          v151 = v320;
          v152 = v324;
          v153 = v327;
          v154 = v331;
          v155 = v334;
          v156 = v337;
          v157 = v341;
          v158 = v345;
          v274 = -64955950;
          while ( 1 )
          {
            v159 = v153 ^ v155;
            v160 = v156 ^ v158;
            v161 = v159 ^ v157 & v155;
            v162 = (v152 | v154) ^ v158;
            v163 = v157 & v155 ^ ~v151;
            v164 = v158 & v152;
            v165 = v163 | v161;
            v166 = ~v154 ^ v164;
            v167 = (v157 | v151) ^ v155;
            v168 = v157 ^ (v163 | v161);
            v169 = v160 & v162 ^ v166;
            v170 = v164 ^ v160;
            v171 = v159 & v167 ^ v163;
            v172 = v166 | v170;
            v173 = v170 ^ v168 ^ v169;
            v174 = v161 ^ v171;
            v175 = ~v167 ^ v165;
            v176 = v171 & v165;
            v177 = v173 ^ __ROR4__(v168, 30);
            v178 = v152 ^ v172 ^ v175;
            v179 = ~v162 ^ v172 ^ v176;
            v180 = v169 & v172 ^ v174;
            v181 = v178 ^ __ROR4__(v175, 30);
            v182 = v179 ^ __ROR4__(v176, 30);
            v183 = v177 ^ __ROR4__(v173, 18);
            v184 = v180 ^ __ROR4__(v174, 30);
            v185 = v181 ^ __ROR4__(v178, 18);
            v186 = v182 ^ __ROR4__(v179, 18);
            v187 = v183 ^ __ROR4__(v177, 22);
            v188 = v184 ^ __ROR4__(v180, 18);
            v151 = v185 ^ __ROR4__(v181, 22);
            v153 = v186 ^ __ROR4__(v182, 22);
            v155 = v188 ^ __ROR4__(v184, 22);
            v152 = __ROR4__(v185, 31);
            v154 = __ROR4__(v186, 31);
            v158 = v150 ^ __ROR4__(v183, 31);
            v156 = __ROR4__(v188, 31);
            ++v149;
            v157 = v187 ^ v274;
            if ( v149 == 8 )
              break;
            v274 = dword_F3108[v149];
            v150 = dword_F3128[v149];
          }
          v189 = -534197825;
          v317 = v151;
          v321 = v152;
          v190 = 0;
          v325 = v153;
          v328 = v154;
          v332 = v155;
          v335 = v156;
          v338 = v157;
          v342 = v158;
          v191 = v348;
          v192 = v351;
          v193 = v356;
          v194 = v360;
          v195 = v396;
          v196 = v363;
          v197 = v367;
          v198 = v371;
          v275 = -1307332699;
          while ( 1 )
          {
            v199 = v193 ^ v195;
            v200 = v196 ^ v198;
            v201 = v199 ^ v197 & v195;
            v202 = (v192 | v194) ^ v198;
            v203 = v197 & v195 ^ ~v191;
            v204 = v198 & v192;
            v205 = v203 | v201;
            v206 = ~v194 ^ v204;
            v207 = (v197 | v191) ^ v195;
            v208 = v197 ^ (v203 | v201);
            v209 = v200 & v202 ^ v206;
            v210 = v204 ^ v200;
            v211 = v199 & v207 ^ v203;
            v212 = v206 | v210;
            v213 = v210 ^ v208 ^ v209;
            v214 = v201 ^ v211;
            v215 = ~v207 ^ v205;
            v216 = v211 & v205;
            v217 = v213 ^ __ROR4__(v208, 30);
            v218 = v192 ^ v212 ^ v215;
            v219 = ~v202 ^ v212 ^ v216;
            v220 = v209 & v212 ^ v214;
            v221 = v218 ^ __ROR4__(v215, 30);
            v222 = v219 ^ __ROR4__(v216, 30);
            v223 = v217 ^ __ROR4__(v213, 18);
            v224 = v220 ^ __ROR4__(v214, 30);
            v225 = v221 ^ __ROR4__(v218, 18);
            v226 = v222 ^ __ROR4__(v219, 18);
            v227 = v223 ^ __ROR4__(v217, 22);
            v228 = v224 ^ __ROR4__(v220, 18);
            v191 = v225 ^ __ROR4__(v221, 22);
            v193 = v226 ^ __ROR4__(v222, 22);
            v195 = v228 ^ __ROR4__(v224, 22);
            v192 = __ROR4__(v225, 31);
            v194 = __ROR4__(v226, 31);
            v198 = v189 ^ __ROR4__(v223, 31);
            v196 = __ROR4__(v228, 31);
            ++v190;
            v197 = v227 ^ v275;
            if ( v190 == 8 )
              break;
            v275 = dword_F31E8[v190];
            v189 = dword_F3208[v190];
          }
          v229 = 1351669111;
          v352 = v193;
          v357 = v194;
          v346 = v191;
          v349 = v192;
          v230 = 0;
          v393 = v195;
          v361 = v196;
          v364 = v197;
          v368 = v198;
          result = v375;
          v231 = v379;
          v232 = v399;
          v233 = v383;
          v234 = v387;
          v235 = v403;
          v236 = v389;
          v237 = v392;
          v276 = -254613021;
          while ( 1 )
          {
            v238 = v232 ^ v234;
            v239 = v235 ^ v237;
            v240 = v238 ^ v236 & v234;
            v241 = (v231 | v233) ^ v237;
            v242 = v236 & v234 ^ ~result;
            v243 = v237 & v231;
            v244 = v242 | v240;
            v245 = ~v233 ^ v243;
            v246 = (v236 | result) ^ v234;
            v247 = v236 ^ (v242 | v240);
            v248 = v239 & v241 ^ v245;
            v249 = v243 ^ v239;
            v250 = v238 & v246 ^ v242;
            v251 = v245 | v249;
            v252 = v249 ^ v247 ^ v248;
            v253 = v240 ^ v250;
            v254 = ~v246 ^ v244;
            v255 = v250 & v244;
            v256 = v252 ^ __ROR4__(v247, 30);
            v257 = v231 ^ v251 ^ v254;
            v258 = ~v241 ^ v251 ^ v255;
            v259 = v248 & v251 ^ v253;
            v260 = v257 ^ __ROR4__(v254, 30);
            v261 = v258 ^ __ROR4__(v255, 30);
            v262 = v256 ^ __ROR4__(v252, 18);
            v263 = v259 ^ __ROR4__(v253, 30);
            v264 = v260 ^ __ROR4__(v257, 18);
            v265 = v261 ^ __ROR4__(v258, 18);
            v266 = v262 ^ __ROR4__(v256, 22);
            v267 = v263 ^ __ROR4__(v259, 18);
            result = v264 ^ __ROR4__(v260, 22);
            v232 = v265 ^ __ROR4__(v261, 22);
            v234 = v267 ^ __ROR4__(v263, 22);
            v231 = __ROR4__(v264, 31);
            v233 = __ROR4__(v265, 31);
            v237 = v229 ^ __ROR4__(v262, 31);
            v235 = __ROR4__(v267, 31);
            ++v230;
            v236 = v266 ^ v276;
            if ( v230 == 8 )
              break;
            v276 = dword_F3228[v230];
            v229 = dword_F3248[v230];
          }
          v380 = v233;
          v3 = 0;
          v372 = result;
          v376 = v231;
          v397 = v232;
          v384 = v234;
          v400 = v235;
          v388 = v236;
          v390 = v237;
          if ( !n )
            break;
        }
        else if ( !n )
        {
          break;
        }
        v4 = 32 - v3;
      }
    }
    v277[9] = v283;
    v277[10] = v404;
    v277[11] = v279;
    v277[12] = v410;
    v277[13] = v286;
    v277[14] = v281;
    v277[15] = v406;
    v277[16] = v407;
    v277[17] = v310;
    v277[18] = v288;
    v277[19] = v294;
    v277[20] = v301;
    v277[21] = v314;
    v277[22] = v291;
    v277[23] = v297;
    v277[24] = v306;
    v277[25] = v338;
    v277[26] = v317;
    v277[27] = v325;
    v277[28] = v332;
    v277[29] = v342;
    v277[30] = v321;
    v277[31] = v328;
    v277[32] = v335;
    v277[33] = v364;
    v277[34] = v346;
    v277[35] = v352;
    v277[36] = v393;
    v277[37] = v368;
    v277[38] = v349;
    v277[39] = v357;
    v277[40] = v361;
    v277[8] = v3;
    v277[41] = v388;
    v277[42] = v372;
    v277[43] = v397;
    v277[44] = v384;
    v277[45] = v390;
    v277[46] = v376;
    v277[47] = v380;
    v277[48] = v400;
  }
  return result;
}
// F3088: using guessed type _DWORD dword_F3088[8];
// F30A8: using guessed type _DWORD dword_F30A8[8];
// F30C8: using guessed type _DWORD dword_F30C8[8];
// F30E8: using guessed type _DWORD dword_F30E8[8];
// F3108: using guessed type _DWORD dword_F3108[8];
// F3128: using guessed type _DWORD dword_F3128[8];
// F31E8: using guessed type _DWORD dword_F31E8[8];
// F3208: using guessed type _DWORD dword_F3208[8];
// F3228: using guessed type _DWORD dword_F3228[8];
// F3248: using guessed type _DWORD dword_F3248[8];

//----- (000BFBF8) --------------------------------------------------------
unsigned int *__fastcall sph_luffa512_addbits_and_close(unsigned int *a1, char a2, char a3, _BYTE *a4)
{
  unsigned int v5; // lr
  unsigned int v6; // r6
  unsigned int v7; // r9
  int v8; // r12
  int v9; // lr
  int v10; // r0
  int v11; // r5
  int v12; // r11
  int v13; // r2
  int v14; // r10
  int v15; // r7
  int v16; // r11
  int v17; // r4
  int v18; // r1
  int v19; // r3
  int v20; // r2
  int v21; // lr
  int v22; // r6
  int v23; // r8
  int v24; // r1
  int v25; // r12
  int v26; // r8
  int v27; // r6
  int v28; // r8
  int v29; // r1
  int v30; // r4
  int v31; // lr
  int v32; // r5
  int v33; // r3
  int v34; // r10
  int v35; // r8
  unsigned int v36; // r4
  int v37; // r12
  int v38; // r6
  int v39; // lr
  int v40; // r11
  int v41; // r1
  int v42; // r2
  int v43; // r8
  int v44; // r0
  int v45; // r5
  int v46; // r10
  int v47; // r2
  int v48; // r7
  int v49; // lr
  int v50; // r11
  int v51; // r8
  int v52; // r3
  int v53; // lr
  int v54; // r12
  int v55; // r8
  int v56; // r5
  int v57; // r0
  int v58; // r2
  unsigned int v59; // lr
  int v60; // r11
  int v61; // r3
  int v62; // r10
  int v63; // r12
  int v64; // r4
  int v65; // r8
  int v66; // r1
  int v67; // r2
  int v68; // r11
  int v69; // r9
  int v70; // r5
  int v71; // r6
  int v72; // r1
  int v73; // r7
  int v74; // r3
  int v75; // r0
  int v76; // r4
  int v77; // r12
  int v78; // r1
  int v79; // r2
  int v80; // r6
  int v81; // r1
  int v82; // r9
  int v83; // r0
  int v84; // r2
  int v85; // r4
  int v86; // lr
  int v87; // r3
  int v88; // r11
  int v89; // r0
  int v90; // r2
  int v91; // r1
  int v92; // r12
  int v93; // lr
  int v94; // r3
  int v95; // r4
  int v96; // r11
  int v97; // r9
  int v98; // r8
  int v99; // r0
  unsigned int v100; // lr
  int v101; // r2
  unsigned int v102; // r3
  int v103; // r12
  unsigned int v104; // r11
  int v105; // r4
  int v106; // r1
  int v107; // r2
  int v108; // r11
  int v109; // r10
  int v110; // r5
  int v111; // r6
  int v112; // r1
  int v113; // r7
  int v114; // r3
  int v115; // r0
  int v116; // r4
  int v117; // r12
  int v118; // r1
  int v119; // r2
  int v120; // r6
  int v121; // r1
  int v122; // r10
  int v123; // r0
  int v124; // r2
  int v125; // r4
  int v126; // lr
  int v127; // r3
  int v128; // r11
  int v129; // r0
  int v130; // r2
  int v131; // r1
  int v132; // r12
  int v133; // lr
  int v134; // r3
  int v135; // r4
  int v136; // r11
  int v137; // r8
  int v138; // r10
  int v139; // r0
  unsigned int v140; // lr
  int v141; // r2
  unsigned int v142; // r3
  int v143; // r12
  unsigned int v144; // r11
  int v145; // r4
  int v146; // r1
  int v147; // r2
  int v148; // r11
  int v149; // r9
  int v150; // r5
  int v151; // r6
  int v152; // r1
  int v153; // r7
  int v154; // r3
  int v155; // r0
  int v156; // r4
  int v157; // r12
  int v158; // r1
  int v159; // r2
  int v160; // r6
  int v161; // r1
  int v162; // r9
  int v163; // r0
  int v164; // r2
  int v165; // r4
  int v166; // lr
  int v167; // r3
  int v168; // r11
  int v169; // r0
  int v170; // r2
  int v171; // r1
  int v172; // r12
  int v173; // lr
  int v174; // r3
  int v175; // r4
  int v176; // r11
  int v177; // r9
  int v178; // r8
  int v179; // r0
  unsigned int v180; // lr
  int v181; // r2
  unsigned int v182; // r3
  int v183; // r12
  unsigned int v184; // r11
  int v185; // r4
  int v186; // r1
  int v187; // r2
  int v188; // r11
  int v189; // r10
  int v190; // r5
  int v191; // r6
  int v192; // r1
  int v193; // r7
  int v194; // r3
  int v195; // r0
  int v196; // r4
  int v197; // r12
  int v198; // r1
  int v199; // r2
  int v200; // r6
  int v201; // r1
  int v202; // r10
  int v203; // r0
  int v204; // r2
  int v205; // r4
  int v206; // lr
  int v207; // r3
  int v208; // r11
  int v209; // r0
  int v210; // r2
  int v211; // r1
  int v212; // r12
  int v213; // lr
  int v214; // r3
  int v215; // r4
  int v216; // r11
  int v217; // r10
  int v218; // r8
  int v219; // r0
  unsigned int v220; // lr
  int v221; // r2
  unsigned int v222; // r3
  int v223; // r12
  unsigned int v224; // r11
  int v225; // r4
  int v226; // r1
  int v227; // r2
  int v228; // r11
  int v229; // r9
  int v230; // r5
  int v231; // r6
  int v232; // r1
  int v233; // r7
  int v234; // r3
  int v235; // r0
  int v236; // r4
  int v237; // r12
  int v238; // r1
  int v239; // r2
  int v240; // r6
  int v241; // r1
  int v242; // r9
  int v243; // r0
  int v244; // r2
  int v245; // r4
  int v246; // lr
  int v247; // r3
  int v248; // r11
  int v249; // r0
  int v250; // r2
  int v251; // r1
  int v252; // r12
  int v253; // lr
  int v254; // r3
  int v255; // r4
  int v256; // r11
  int v257; // r11
  int v258; // r2
  int v259; // lr
  int v260; // r4
  int v261; // r1
  int v262; // r6
  int v263; // r5
  int v264; // r12
  int v266; // r3
  int v267; // r1
  int v268; // r2
  int v269; // r4
  int v270; // r5
  int v271; // r0
  int v272; // r3
  int v273; // r1
  unsigned int v274; // [sp+4h] [bp-120h]
  int v275; // [sp+4h] [bp-120h]
  int v276; // [sp+4h] [bp-120h]
  int v277; // [sp+4h] [bp-120h]
  int v278; // [sp+4h] [bp-120h]
  int v279; // [sp+4h] [bp-120h]
  int v280; // [sp+4h] [bp-120h]
  int v281; // [sp+8h] [bp-11Ch]
  int v282; // [sp+8h] [bp-11Ch]
  unsigned int v283; // [sp+Ch] [bp-118h]
  unsigned int v284; // [sp+Ch] [bp-118h]
  int v285; // [sp+Ch] [bp-118h]
  unsigned int v286; // [sp+10h] [bp-114h]
  unsigned int v287; // [sp+14h] [bp-110h]
  int v288; // [sp+14h] [bp-110h]
  int v289; // [sp+14h] [bp-110h]
  int v290; // [sp+14h] [bp-110h]
  unsigned int v291; // [sp+18h] [bp-10Ch]
  int v292; // [sp+18h] [bp-10Ch]
  unsigned int v293; // [sp+1Ch] [bp-108h]
  int v294; // [sp+1Ch] [bp-108h]
  unsigned int v295; // [sp+20h] [bp-104h]
  int v296; // [sp+20h] [bp-104h]
  int v297; // [sp+20h] [bp-104h]
  int v298; // [sp+20h] [bp-104h]
  unsigned int v299; // [sp+24h] [bp-100h]
  int v300; // [sp+24h] [bp-100h]
  int v301; // [sp+24h] [bp-100h]
  unsigned int v302; // [sp+28h] [bp-FCh]
  int v303; // [sp+28h] [bp-FCh]
  unsigned int v304; // [sp+28h] [bp-FCh]
  unsigned int v305; // [sp+2Ch] [bp-F8h]
  int v306; // [sp+2Ch] [bp-F8h]
  int v307; // [sp+2Ch] [bp-F8h]
  unsigned int v308; // [sp+30h] [bp-F4h]
  unsigned int v309; // [sp+30h] [bp-F4h]
  unsigned int v310; // [sp+30h] [bp-F4h]
  unsigned int v311; // [sp+34h] [bp-F0h]
  int v312; // [sp+34h] [bp-F0h]
  int v313; // [sp+34h] [bp-F0h]
  unsigned int v314; // [sp+38h] [bp-ECh]
  int v315; // [sp+38h] [bp-ECh]
  int v316; // [sp+38h] [bp-ECh]
  unsigned int v317; // [sp+38h] [bp-ECh]
  unsigned int v318; // [sp+3Ch] [bp-E8h]
  int v319; // [sp+3Ch] [bp-E8h]
  int v320; // [sp+3Ch] [bp-E8h]
  int v321; // [sp+3Ch] [bp-E8h]
  unsigned int v322; // [sp+40h] [bp-E4h]
  int v323; // [sp+40h] [bp-E4h]
  int v324; // [sp+40h] [bp-E4h]
  unsigned int v325; // [sp+44h] [bp-E0h]
  int v326; // [sp+44h] [bp-E0h]
  unsigned int v327; // [sp+44h] [bp-E0h]
  unsigned int v328; // [sp+48h] [bp-DCh]
  int v329; // [sp+48h] [bp-DCh]
  int v330; // [sp+48h] [bp-DCh]
  unsigned int v331; // [sp+4Ch] [bp-D8h]
  int v332; // [sp+4Ch] [bp-D8h]
  unsigned int v333; // [sp+4Ch] [bp-D8h]
  unsigned int v334; // [sp+50h] [bp-D4h]
  int v335; // [sp+50h] [bp-D4h]
  int v336; // [sp+50h] [bp-D4h]
  int v337; // [sp+50h] [bp-D4h]
  unsigned int v338; // [sp+54h] [bp-D0h]
  int v339; // [sp+54h] [bp-D0h]
  int v340; // [sp+54h] [bp-D0h]
  unsigned int v341; // [sp+54h] [bp-D0h]
  unsigned int v342; // [sp+58h] [bp-CCh]
  int v343; // [sp+58h] [bp-CCh]
  int v344; // [sp+58h] [bp-CCh]
  int v345; // [sp+58h] [bp-CCh]
  unsigned int v346; // [sp+5Ch] [bp-C8h]
  int v347; // [sp+5Ch] [bp-C8h]
  int v348; // [sp+5Ch] [bp-C8h]
  unsigned int v349; // [sp+60h] [bp-C4h]
  int v350; // [sp+60h] [bp-C4h]
  int v351; // [sp+60h] [bp-C4h]
  unsigned int v352; // [sp+64h] [bp-C0h]
  int v353; // [sp+64h] [bp-C0h]
  unsigned int v354; // [sp+64h] [bp-C0h]
  unsigned int v355; // [sp+68h] [bp-BCh]
  int v356; // [sp+68h] [bp-BCh]
  int v357; // [sp+68h] [bp-BCh]
  int v358; // [sp+68h] [bp-BCh]
  unsigned int v359; // [sp+6Ch] [bp-B8h]
  int v360; // [sp+6Ch] [bp-B8h]
  unsigned int v361; // [sp+6Ch] [bp-B8h]
  unsigned int v362; // [sp+70h] [bp-B4h]
  int v363; // [sp+70h] [bp-B4h]
  unsigned int v364; // [sp+74h] [bp-B0h]
  int v365; // [sp+74h] [bp-B0h]
  int v366; // [sp+74h] [bp-B0h]
  unsigned int v367; // [sp+74h] [bp-B0h]
  unsigned int v368; // [sp+78h] [bp-ACh]
  int v369; // [sp+78h] [bp-ACh]
  int v370; // [sp+78h] [bp-ACh]
  int v371; // [sp+78h] [bp-ACh]
  unsigned int v372; // [sp+7Ch] [bp-A8h]
  int v373; // [sp+7Ch] [bp-A8h]
  int v374; // [sp+7Ch] [bp-A8h]
  unsigned int v375; // [sp+80h] [bp-A4h]
  int v376; // [sp+80h] [bp-A4h]
  int v377; // [sp+80h] [bp-A4h]
  unsigned int v378; // [sp+84h] [bp-A0h]
  int v379; // [sp+84h] [bp-A0h]
  unsigned int v380; // [sp+84h] [bp-A0h]
  unsigned int v381; // [sp+88h] [bp-9Ch]
  int v382; // [sp+88h] [bp-9Ch]
  int v383; // [sp+88h] [bp-9Ch]
  unsigned int v384; // [sp+88h] [bp-9Ch]
  unsigned int v385; // [sp+8Ch] [bp-98h]
  int v386; // [sp+8Ch] [bp-98h]
  unsigned int v387; // [sp+90h] [bp-94h]
  unsigned int v388; // [sp+90h] [bp-94h]
  unsigned int v389; // [sp+94h] [bp-90h]
  int v390; // [sp+94h] [bp-90h]
  int v391; // [sp+94h] [bp-90h]
  int v392; // [sp+94h] [bp-90h]
  unsigned int v393; // [sp+98h] [bp-8Ch]
  int v394; // [sp+98h] [bp-8Ch]
  int v395; // [sp+98h] [bp-8Ch]
  unsigned int v396; // [sp+9Ch] [bp-88h]
  int v397; // [sp+9Ch] [bp-88h]
  int v398; // [sp+9Ch] [bp-88h]
  unsigned int v399; // [sp+A0h] [bp-84h]
  int v400; // [sp+A0h] [bp-84h]
  int v401; // [sp+A0h] [bp-84h]
  int v402; // [sp+A0h] [bp-84h]
  unsigned int v403; // [sp+A4h] [bp-80h]
  unsigned int v404; // [sp+A8h] [bp-7Ch]
  int v405; // [sp+A8h] [bp-7Ch]
  unsigned int v406; // [sp+ACh] [bp-78h]
  int v407; // [sp+ACh] [bp-78h]
  unsigned int v408; // [sp+B0h] [bp-74h]
  int v409; // [sp+B0h] [bp-74h]
  int v410; // [sp+B0h] [bp-74h]
  unsigned int v411; // [sp+B4h] [bp-70h]
  int v412; // [sp+B8h] [bp-6Ch]
  int v413; // [sp+B8h] [bp-6Ch]
  int v414; // [sp+B8h] [bp-6Ch]
  int v415; // [sp+BCh] [bp-68h]
  int v416; // [sp+BCh] [bp-68h]
  int v417; // [sp+C0h] [bp-64h]
  int v418; // [sp+C0h] [bp-64h]
  int v419; // [sp+C0h] [bp-64h]
  int v420; // [sp+C8h] [bp-5Ch]
  int v421; // [sp+C8h] [bp-5Ch]
  int v422; // [sp+CCh] [bp-58h]
  unsigned int v424; // [sp+D4h] [bp-50h]
  int v425; // [sp+D8h] [bp-4Ch]
  int v426; // [sp+D8h] [bp-4Ch]
  int v427; // [sp+DCh] [bp-48h]
  int v428; // [sp+DCh] [bp-48h]
  int v429; // [sp+E0h] [bp-44h]
  int v430; // [sp+E0h] [bp-44h]
  int v431; // [sp+E4h] [bp-40h]
  int v432; // [sp+E4h] [bp-40h]
  int v433; // [sp+E8h] [bp-3Ch]
  int v434; // [sp+E8h] [bp-3Ch]
  int v435; // [sp+ECh] [bp-38h]
  int v436; // [sp+ECh] [bp-38h]
  int v437; // [sp+F0h] [bp-34h]
  int v438; // [sp+F4h] [bp-30h]
  int v439; // [sp+F4h] [bp-30h]
  int v440; // [sp+FCh] [bp-28h]
  int v441; // [sp+100h] [bp-24h]

  v5 = a1[8];
  *((_BYTE *)a1 + v5) = (128 >> a3) | a2 & -(128 >> a3);
  memset((char *)a1 + v5 + 1, 0, 31 - v5);
  v396 = a1[9];
  v404 = a1[10];
  v6 = v396 ^ a1[17];
  v291 = a1[12];
  v399 = a1[17];
  v406 = a1[11];
  v295 = a1[13];
  v287 = a1[14];
  v408 = a1[15];
  v293 = a1[16];
  v299 = a1[18];
  v422 = 0;
  v305 = a1[19];
  v311 = a1[20];
  v318 = a1[21];
  v302 = a1[22];
  v308 = a1[23];
  v314 = a1[24];
  v342 = a1[25];
  v322 = a1[26];
  v328 = a1[27];
  v334 = a1[28];
  v346 = a1[29];
  v325 = a1[30];
  v331 = a1[31];
  v338 = a1[32];
  v368 = a1[33];
  v349 = a1[34];
  v355 = a1[35];
  v362 = a1[36];
  v372 = a1[37];
  v352 = a1[38];
  v359 = a1[39];
  v364 = a1[40];
  v389 = a1[41];
  v375 = a1[42];
  v283 = a1[43];
  v385 = a1[44];
  v393 = a1[45];
  v378 = a1[46];
  v381 = a1[47];
  v387 = a1[48];
  while ( 1 )
  {
    v424 = bswap32(*a1);
    v7 = bswap32(a1[4]);
    v403 = bswap32(a1[1]);
    v286 = bswap32(a1[7]);
    v8 = v338 ^ v364 ^ v387 ^ v293 ^ v314;
    v9 = v328 ^ v355 ^ v406 ^ v305 ^ v283 ^ v8;
    v10 = v334 ^ v362 ^ v291 ^ v311 ^ v385 ^ v8;
    v11 = v349 ^ v404 ^ v299 ^ v375 ^ v322;
    v12 = v331 ^ v359 ^ v381 ^ v408 ^ v308;
    v13 = v325 ^ v352 ^ v378 ^ v287 ^ v302;
    v411 = bswap32(a1[2]);
    v274 = bswap32(a1[6]);
    v417 = v11 ^ v283;
    v412 = v11 ^ v305;
    v415 = v11 ^ v328;
    v356 = v11 ^ v355;
    v284 = bswap32(a1[5]);
    v306 = v12 ^ v387;
    v281 = v12 ^ v338;
    v14 = v12 ^ v314;
    v15 = v12 ^ v293;
    v16 = v12 ^ v364;
    v339 = v13 ^ v308;
    v17 = v13 ^ v331;
    v365 = v13 ^ v359;
    v382 = v13 ^ v381;
    v309 = bswap32(a1[3]);
    v18 = v346 ^ v372 ^ v295 ^ v318 ^ v393;
    v420 = v284 ^ v424 ^ v286;
    v19 = v6 ^ v389 ^ v342 ^ v368 ^ v8;
    v315 = v9 ^ v291;
    v332 = v9 ^ v311;
    v425 = v9 ^ v334;
    v360 = v9 ^ v362;
    v427 = v9 ^ v385;
    v335 = v10 ^ v318;
    v20 = v13 ^ v408;
    v292 = v339 ^ v281;
    v429 = v10 ^ v393;
    v319 = v18 ^ v287;
    v394 = v10 ^ v295;
    v21 = v10 ^ v346;
    v288 = v10 ^ v372;
    v294 = v309 ^ v286;
    v296 = v18 ^ v325;
    v22 = v18 ^ v302;
    v23 = v18 ^ v352;
    v24 = v18 ^ v378;
    v312 = v365 ^ v306;
    v373 = v396 ^ v8;
    v379 = v399 ^ v8;
    v400 = v8 ^ v342;
    v409 = v8 ^ v389;
    v369 = v8 ^ v368;
    v347 = v403 ^ v274;
    v390 = v315 ^ v335;
    v25 = v315;
    v316 = v11 ^ v406;
    v329 = v15 ^ v382;
    v386 = v25 ^ v417 ^ v306;
    v326 = v425 ^ v412 ^ v14;
    v438 = v425 ^ v288;
    v343 = v319 ^ v339;
    v431 = v335 ^ v296;
    v435 = v296 ^ v365;
    v353 = v288 ^ v24;
    v397 = v20 ^ v24;
    v297 = v20 ^ v14;
    v437 = v23 ^ v382;
    v433 = v21 ^ v23;
    v363 = v427 ^ v356 ^ v16;
    v26 = v22 ^ v17;
    v407 = v394 ^ v22;
    v289 = v17 ^ v16;
    v27 = v19 ^ v322;
    v383 = v26;
    v28 = v19 ^ v349;
    v303 = v19 ^ v404;
    v29 = v19 ^ v299;
    v300 = v19 ^ v375;
    v336 = v390 ^ v15;
    v30 = v14;
    v426 = v14 ^ v400;
    v31 = v21 ^ v332 ^ v14;
    v405 = v19 ^ v349 ^ v400 ^ v281;
    v32 = v339 ^ v281 ^ v309 ^ v286 ^ v326;
    v33 = v319;
    v34 = v438 ^ v281;
    v320 = v31;
    v366 = v33 ^ v429;
    v340 = v360 ^ v429 ^ v16;
    v391 = v394 ^ v427 ^ v306;
    v401 = v15 ^ v379;
    v350 = v27 ^ v379 ^ v30;
    v428 = v28 ^ v417;
    v357 = v27 ^ v356;
    v35 = v303 ^ v412;
    v36 = v274;
    v37 = v274 ^ v411 ^ v286;
    v38 = v415 ^ v281 ^ v360;
    v413 = v281 ^ v369;
    v275 = v369 ^ v16;
    v418 = v16 ^ v409;
    v39 = v409 ^ v306;
    v307 = v373 ^ v306;
    v323 = v29 ^ v373 ^ v15;
    v370 = v303 ^ v39;
    v410 = v29 ^ v415;
    v376 = v275 ^ v300;
    v416 = v316 ^ v300;
    v282 = v332 ^ v316 ^ v15;
    v395 = __ROR4__(v7 ^ v420 ^ v329 ^ v386 ^ v340, 28);
    v40 = v312 ^ v284 ^ v347 ^ v363 ^ v34;
    v41 = v320;
    v42 = v289 ^ v347;
    v321 = __ROR4__(v32 ^ v336, 31);
    v441 = v312 ^ v420 ^ v38;
    v380 = __ROR4__(v353 ^ v284 ^ v347 ^ v391, 28);
    v430 = v35 ^ v350;
    v348 = __ROR4__(v289 ^ v37 ^ v38 ^ v41, 30);
    v440 = v42 ^ v326;
    v374 = __ROR4__(v40, 29);
    v439 = v309 ^ v297 ^ v35;
    v43 = v7 ^ v383 ^ v433;
    v44 = v297 ^ v383 ^ v36;
    v45 = v431 ^ v309 ^ v286 ^ v34;
    v46 = v284 ^ v343 ^ v431;
    v384 = __ROR4__(v37 ^ v437 ^ v366, 28);
    v47 = v292 ^ v435 ^ v284;
    v48 = v435 ^ v309 ^ v286 ^ v353;
    v49 = v366;
    v367 = __ROR4__(v437 ^ v289 ^ v7, 29);
    v436 = v7 ^ v36 ^ v286 ^ v329 ^ v363;
    v432 = v284 ^ v49;
    v304 = __ROR4__(v7 ^ v407 ^ v41, 31);
    v333 = __ROR4__(v43, 30);
    v317 = __ROR4__(v44, 31);
    v354 = __ROR4__(v433 ^ v37 ^ v340, 29);
    v327 = __ROR4__(v45, 30);
    v310 = __ROR4__(v46, 31);
    v361 = __ROR4__(v48, 29);
    v341 = __ROR4__(v47, 30);
    v50 = v343 ^ v329;
    v344 = v297 ^ v307;
    v434 = v7 ^ v284 ^ v307 ^ v329;
    v51 = v418 ^ v312;
    v419 = v418 ^ v329;
    v421 = v289 ^ v426;
    v52 = v413 ^ v289 ^ v36 ^ v286;
    v414 = v413 ^ v312;
    v388 = __ROR4__(v312 ^ v397 ^ v294, 28);
    v53 = v401 ^ v297 ^ v403;
    v290 = v432 ^ v336;
    v54 = v36 ^ v397;
    v55 = v51 ^ v284 ^ v36;
    v56 = v428 ^ v370;
    v313 = v292 ^ v411 ^ v286 ^ v282 ^ v410;
    v330 = v410 ^ v405 ^ v424 ^ v286;
    v298 = v7 ^ v297 ^ v282 ^ v391;
    v337 = v440 ^ v357;
    v358 = v357 ^ v275 ^ v300 ^ v36 ^ v286;
    v57 = v370 ^ v53;
    v301 = v426 ^ v292 ^ v424 ^ v286 ^ v323;
    v398 = v424 ^ v344;
    v58 = v411 ^ v323 ^ v416;
    v402 = v286 ^ v401 ^ v292;
    v324 = v52 ^ v350;
    v345 = v421 ^ v36;
    v59 = v290;
    v60 = v286 ^ v50;
    v371 = v284 ^ v414;
    v61 = v54 ^ v407;
    v377 = v434 ^ v376;
    v62 = -533497832;
    v392 = v7 ^ v419;
    v285 = v56 ^ v284 ^ v36;
    v63 = v439 ^ v386;
    v64 = v398;
    v351 = v55 ^ v405;
    v65 = 0;
    v66 = v298;
    v276 = 809079974;
    while ( 1 )
    {
      v67 = v58 ^ v63;
      v68 = v60 ^ v66;
      v69 = v67 ^ v64 & v63;
      v70 = (v59 | v61) ^ v66;
      v71 = v64 & v63 ^ ~v57;
      v72 = v66 & v59;
      v73 = v71 | v69;
      v74 = ~v61 ^ v72;
      v75 = (v64 | v57) ^ v63;
      v76 = v64 ^ (v71 | v69);
      v77 = v68 & v70 ^ v74;
      v78 = v72 ^ v68;
      v79 = v67 & v75 ^ v71;
      v80 = v74 | v78;
      v81 = v78 ^ v76 ^ v77;
      v82 = v69 ^ v79;
      v83 = ~v75 ^ v73;
      v84 = v79 & v73;
      v85 = v81 ^ __ROR4__(v76, 30);
      v86 = v59 ^ v80 ^ v83;
      v87 = ~v70 ^ v80 ^ v84;
      v88 = v77 & v80 ^ v82;
      v89 = v86 ^ __ROR4__(v83, 30);
      v90 = v87 ^ __ROR4__(v84, 30);
      v91 = v85 ^ __ROR4__(v81, 18);
      v92 = v88 ^ __ROR4__(v82, 30);
      v93 = v89 ^ __ROR4__(v86, 18);
      v94 = v90 ^ __ROR4__(v87, 18);
      v95 = v91 ^ __ROR4__(v85, 22);
      v96 = v92 ^ __ROR4__(v88, 18);
      v57 = v93 ^ __ROR4__(v89, 22);
      v58 = v94 ^ __ROR4__(v90, 22);
      v63 = v96 ^ __ROR4__(v92, 22);
      v59 = __ROR4__(v93, 31);
      v61 = __ROR4__(v94, 31);
      v66 = v62 ^ __ROR4__(v91, 31);
      v60 = __ROR4__(v96, 31);
      ++v65;
      v64 = v95 ^ v276;
      if ( v65 == 8 )
        break;
      v276 = dword_F3088[v65];
      v62 = dword_F30A8[v65];
    }
    v97 = 23617341;
    v404 = v57;
    v287 = v59;
    v98 = 0;
    v406 = v58;
    v408 = v61;
    v291 = v63;
    v293 = v60;
    v396 = v64;
    v295 = v66;
    v99 = v301;
    v100 = v304;
    v101 = v403 ^ v430;
    v102 = v310;
    v103 = v313;
    v104 = v317;
    v105 = v402;
    v106 = v321;
    v277 = -1226960659;
    while ( 1 )
    {
      v107 = v101 ^ v103;
      v108 = v104 ^ v106;
      v109 = v107 ^ v105 & v103;
      v110 = (v100 | v102) ^ v106;
      v111 = v105 & v103 ^ ~v99;
      v112 = v106 & v100;
      v113 = v111 | v109;
      v114 = ~v102 ^ v112;
      v115 = (v105 | v99) ^ v103;
      v116 = v105 ^ (v111 | v109);
      v117 = v108 & v110 ^ v114;
      v118 = v112 ^ v108;
      v119 = v107 & v115 ^ v111;
      v120 = v114 | v118;
      v121 = v118 ^ v116 ^ v117;
      v122 = v109 ^ v119;
      v123 = ~v115 ^ v113;
      v124 = v119 & v113;
      v125 = v121 ^ __ROR4__(v116, 30);
      v126 = v100 ^ v120 ^ v123;
      v127 = ~v110 ^ v120 ^ v124;
      v128 = v117 & v120 ^ v122;
      v129 = v126 ^ __ROR4__(v123, 30);
      v130 = v127 ^ __ROR4__(v124, 30);
      v131 = v125 ^ __ROR4__(v121, 18);
      v132 = v128 ^ __ROR4__(v122, 30);
      v133 = v129 ^ __ROR4__(v126, 18);
      v134 = v130 ^ __ROR4__(v127, 18);
      v135 = v131 ^ __ROR4__(v125, 22);
      v136 = v132 ^ __ROR4__(v128, 18);
      v99 = v133 ^ __ROR4__(v129, 22);
      v101 = v134 ^ __ROR4__(v130, 22);
      v103 = v136 ^ __ROR4__(v132, 22);
      v100 = __ROR4__(v133, 31);
      v102 = __ROR4__(v134, 31);
      v106 = v97 ^ __ROR4__(v131, 31);
      v104 = __ROR4__(v136, 31);
      ++v98;
      v105 = v135 ^ v277;
      if ( v98 == 8 )
        break;
      v277 = dword_F30C8[v98];
      v97 = dword_F30E8[v98];
    }
    v137 = 0;
    v299 = v99;
    v302 = v100;
    v305 = v101;
    v308 = v102;
    v311 = v103;
    v314 = v104;
    v399 = v105;
    v318 = v106;
    v138 = -497126719;
    v139 = v324;
    v140 = v327;
    v141 = v330;
    v142 = v333;
    v143 = v337;
    v144 = v341;
    v145 = v345;
    v146 = v348;
    v278 = -64955950;
    while ( 1 )
    {
      v147 = v141 ^ v143;
      v148 = v144 ^ v146;
      v149 = v147 ^ v145 & v143;
      v150 = (v140 | v142) ^ v146;
      v151 = v145 & v143 ^ ~v139;
      v152 = v146 & v140;
      v153 = v151 | v149;
      v154 = ~v142 ^ v152;
      v155 = (v145 | v139) ^ v143;
      v156 = v145 ^ (v151 | v149);
      v157 = v148 & v150 ^ v154;
      v158 = v152 ^ v148;
      v159 = v147 & v155 ^ v151;
      v160 = v154 | v158;
      v161 = v158 ^ v156 ^ v157;
      v162 = v149 ^ v159;
      v163 = ~v155 ^ v153;
      v164 = v159 & v153;
      v165 = v161 ^ __ROR4__(v156, 30);
      v166 = v140 ^ v160 ^ v163;
      v167 = ~v150 ^ v160 ^ v164;
      v168 = v157 & v160 ^ v162;
      v169 = v166 ^ __ROR4__(v163, 30);
      v170 = v167 ^ __ROR4__(v164, 30);
      v171 = v165 ^ __ROR4__(v161, 18);
      v172 = v168 ^ __ROR4__(v162, 30);
      v173 = v169 ^ __ROR4__(v166, 18);
      v174 = v170 ^ __ROR4__(v167, 18);
      v175 = v171 ^ __ROR4__(v165, 22);
      v176 = v172 ^ __ROR4__(v168, 18);
      v139 = v173 ^ __ROR4__(v169, 22);
      v141 = v174 ^ __ROR4__(v170, 22);
      v143 = v176 ^ __ROR4__(v172, 22);
      v140 = __ROR4__(v173, 31);
      v142 = __ROR4__(v174, 31);
      v146 = v138 ^ __ROR4__(v171, 31);
      v144 = __ROR4__(v176, 31);
      ++v137;
      v145 = v175 ^ v278;
      if ( v137 == 8 )
        break;
      v278 = dword_F3108[v137];
      v138 = dword_F3128[v137];
    }
    v177 = -534197825;
    v322 = v139;
    v325 = v140;
    v178 = 0;
    v328 = v141;
    v331 = v142;
    v334 = v143;
    v338 = v144;
    v342 = v145;
    v346 = v146;
    v179 = v351;
    v180 = v354;
    v181 = v358;
    v182 = v361;
    v183 = v441 ^ v428;
    v184 = v367;
    v185 = v371;
    v186 = v374;
    v279 = -1307332699;
    while ( 1 )
    {
      v187 = v181 ^ v183;
      v188 = v184 ^ v186;
      v189 = v187 ^ v185 & v183;
      v190 = (v180 | v182) ^ v186;
      v191 = v185 & v183 ^ ~v179;
      v192 = v186 & v180;
      v193 = v191 | v189;
      v194 = ~v182 ^ v192;
      v195 = (v185 | v179) ^ v183;
      v196 = v185 ^ (v191 | v189);
      v197 = v188 & v190 ^ v194;
      v198 = v192 ^ v188;
      v199 = v187 & v195 ^ v191;
      v200 = v194 | v198;
      v201 = v198 ^ v196 ^ v197;
      v202 = v189 ^ v199;
      v203 = ~v195 ^ v193;
      v204 = v199 & v193;
      v205 = v201 ^ __ROR4__(v196, 30);
      v206 = v180 ^ v200 ^ v203;
      v207 = ~v190 ^ v200 ^ v204;
      v208 = v197 & v200 ^ v202;
      v209 = v206 ^ __ROR4__(v203, 30);
      v210 = v207 ^ __ROR4__(v204, 30);
      v211 = v205 ^ __ROR4__(v201, 18);
      v212 = v208 ^ __ROR4__(v202, 30);
      v213 = v209 ^ __ROR4__(v206, 18);
      v214 = v210 ^ __ROR4__(v207, 18);
      v215 = v211 ^ __ROR4__(v205, 22);
      v216 = v212 ^ __ROR4__(v208, 18);
      v179 = v213 ^ __ROR4__(v209, 22);
      v181 = v214 ^ __ROR4__(v210, 22);
      v183 = v216 ^ __ROR4__(v212, 22);
      v180 = __ROR4__(v213, 31);
      v182 = __ROR4__(v214, 31);
      v186 = v177 ^ __ROR4__(v211, 31);
      v184 = __ROR4__(v216, 31);
      ++v178;
      v185 = v215 ^ v279;
      if ( v178 == 8 )
        break;
      v279 = dword_F31E8[v178];
      v177 = dword_F3208[v178];
    }
    v217 = 1351669111;
    v355 = v181;
    v359 = v182;
    v349 = v179;
    v352 = v180;
    v218 = 0;
    v362 = v183;
    v364 = v184;
    v368 = v185;
    v372 = v186;
    v219 = v377;
    v220 = v380;
    v221 = v285;
    v222 = v384;
    v223 = v436 ^ v416;
    v224 = v388;
    v225 = v392;
    v226 = v395;
    v280 = -254613021;
    while ( 1 )
    {
      v227 = v221 ^ v223;
      v228 = v224 ^ v226;
      v229 = v227 ^ v225 & v223;
      v230 = (v220 | v222) ^ v226;
      v231 = v225 & v223 ^ ~v219;
      v232 = v226 & v220;
      v233 = v231 | v229;
      v234 = ~v222 ^ v232;
      v235 = (v225 | v219) ^ v223;
      v236 = v225 ^ (v231 | v229);
      v237 = v228 & v230 ^ v234;
      v238 = v232 ^ v228;
      v239 = v227 & v235 ^ v231;
      v240 = v234 | v238;
      v241 = v238 ^ v236 ^ v237;
      v242 = v229 ^ v239;
      v243 = ~v235 ^ v233;
      v244 = v239 & v233;
      v245 = v241 ^ __ROR4__(v236, 30);
      v246 = v220 ^ v240 ^ v243;
      v247 = ~v230 ^ v240 ^ v244;
      v248 = v237 & v240 ^ v242;
      v249 = v246 ^ __ROR4__(v243, 30);
      v250 = v247 ^ __ROR4__(v244, 30);
      v251 = v245 ^ __ROR4__(v241, 18);
      v252 = v248 ^ __ROR4__(v242, 30);
      v253 = v249 ^ __ROR4__(v246, 18);
      v254 = v250 ^ __ROR4__(v247, 18);
      v255 = v251 ^ __ROR4__(v245, 22);
      v256 = v252 ^ __ROR4__(v248, 18);
      v219 = v253 ^ __ROR4__(v249, 22);
      v221 = v254 ^ __ROR4__(v250, 22);
      v223 = v256 ^ __ROR4__(v252, 22);
      v220 = __ROR4__(v253, 31);
      v222 = __ROR4__(v254, 31);
      v226 = v217 ^ __ROR4__(v251, 31);
      v224 = __ROR4__(v256, 31);
      ++v218;
      v225 = v255 ^ v280;
      if ( v218 == 8 )
        break;
      v280 = dword_F3228[v218];
      v217 = dword_F3248[v218];
    }
    v381 = v222;
    v375 = v219;
    v378 = v220;
    v283 = v221;
    v385 = v223;
    v387 = v224;
    v389 = v225;
    v393 = v226;
    if ( v422 != 1 )
      break;
    v6 = v399 ^ v396;
    v266 = v399 ^ v396 ^ v342 ^ v368 ^ v225;
    v267 = v404 ^ v299 ^ v322 ^ v349 ^ v219;
    v268 = v406 ^ v305 ^ v328 ^ v355 ^ v221;
    v269 = v291 ^ v311 ^ v334 ^ v362 ^ v223;
    *a4 = (v399 ^ v396 ^ v342 ^ v368 ^ v389) >> 24;
    a4[3] = v266;
    v270 = v295 ^ v318 ^ v346 ^ v372 ^ v393;
    a4[1] = BYTE2(v266);
    a4[2] = BYTE1(v266);
    a4[7] = v267;
    v271 = v287 ^ v302 ^ v325 ^ v352 ^ v220;
    a4[4] = HIBYTE(v267);
    a4[11] = v268;
    a4[15] = v269;
    v272 = v408 ^ v308 ^ v331 ^ v359 ^ v381;
    a4[5] = BYTE2(v267);
    a4[6] = (unsigned __int16)(v404 ^ v299 ^ v322 ^ v349 ^ v375) >> 8;
    a4[19] = v270;
    a4[23] = v271;
    a4[27] = v272;
    v273 = v293 ^ v314 ^ v338 ^ v364 ^ v224;
    a4[8] = HIBYTE(v268);
    a4[31] = v273;
    a4[9] = BYTE2(v268);
    a4[10] = BYTE1(v268);
    a4[21] = BYTE2(v271);
    a4[12] = HIBYTE(v269);
    a4[13] = BYTE2(v269);
    a4[14] = BYTE1(v269);
    a4[16] = HIBYTE(v270);
    a4[17] = BYTE2(v270);
    a4[18] = BYTE1(v270);
    a4[20] = HIBYTE(v271);
    a4[22] = BYTE1(v271);
    a4[24] = HIBYTE(v272);
    a4[25] = BYTE2(v272);
    a4[26] = BYTE1(v272);
    a4[28] = HIBYTE(v273);
    a4[29] = BYTE2(v273);
    a4[30] = BYTE1(v273);
LABEL_21:
    ++v422;
  }
  if ( v422 != 2 )
  {
    memset(a1, 0, 0x20u);
    v6 = v399 ^ v396;
    goto LABEL_21;
  }
  v257 = v293 ^ v314 ^ v224 ^ v364;
  v258 = v342 ^ v368 ^ v396 ^ v399 ^ v225;
  v259 = v355 ^ v406 ^ v305 ^ v328 ^ v283;
  v260 = v404 ^ v299 ^ v322 ^ v219 ^ v349;
  v261 = v346 ^ v295 ^ v318 ^ v226 ^ v372;
  v262 = v291 ^ v311 ^ v223 ^ v362 ^ v334;
  v263 = v287 ^ v302 ^ v325 ^ v378 ^ v352;
  v264 = v408 ^ v308 ^ v331 ^ v222 ^ v359;
  a4[39] = v260;
  a4[43] = v259;
  a4[35] = v258;
  a4[47] = v262;
  a4[51] = v261;
  a4[63] = v338 ^ v257;
  a4[59] = v264;
  a4[37] = BYTE2(v260);
  a4[55] = v263;
  a4[32] = HIBYTE(v258);
  a4[38] = BYTE1(v260);
  a4[33] = BYTE2(v258);
  a4[34] = BYTE1(v258);
  a4[40] = HIBYTE(v259);
  a4[36] = HIBYTE(v260);
  a4[50] = BYTE1(v261);
  a4[41] = BYTE2(v259);
  a4[42] = BYTE1(v259);
  a4[44] = HIBYTE(v262);
  a4[45] = BYTE2(v262);
  a4[46] = BYTE1(v262);
  a4[48] = HIBYTE(v261);
  a4[49] = BYTE2(v261);
  a4[52] = HIBYTE(v263);
  a4[53] = BYTE2(v263);
  a4[54] = BYTE1(v263);
  a4[56] = HIBYTE(v264);
  a4[57] = BYTE2(v264);
  a4[58] = BYTE1(v264);
  a4[60] = (v338 ^ v257) >> 24;
  a4[61] = (v338 ^ v257) >> 16;
  a4[62] = (unsigned __int16)(v338 ^ v257) >> 8;
  memcpy(a1 + 9, &unk_F3148, 0xA0u);
  a1[8] = 0;
  return a1;
}
// F3088: using guessed type _DWORD dword_F3088[8];
// F30A8: using guessed type _DWORD dword_F30A8[8];
// F30C8: using guessed type _DWORD dword_F30C8[8];
// F30E8: using guessed type _DWORD dword_F30E8[8];
// F3108: using guessed type _DWORD dword_F3108[8];
// F3128: using guessed type _DWORD dword_F3128[8];
// F31E8: using guessed type _DWORD dword_F31E8[8];
// F3208: using guessed type _DWORD dword_F3208[8];
// F3228: using guessed type _DWORD dword_F3228[8];
// F3248: using guessed type _DWORD dword_F3248[8];

//----- (000C13D8) --------------------------------------------------------
unsigned int *__fastcall sph_luffa512_close(unsigned int *a1, _BYTE *a2)
{
  return sph_luffa512_addbits_and_close(a1, 0, 0, a2);
}

//----- (000C13E8) --------------------------------------------------------
int __fastcall sub_C13E8(_DWORD *a1, _DWORD *a2)
{
  unsigned int v2; // r10
  unsigned int v3; // r6
  unsigned int v4; // r8
  unsigned int v5; // r4
  unsigned int v6; // lr
  unsigned int v7; // r5
  int v8; // r2
  int v9; // r9
  unsigned int v10; // r10
  int v11; // r8
  unsigned int v12; // r5
  unsigned int v13; // lr
  unsigned int v14; // r0
  unsigned int v15; // r7
  char *v16; // r8
  int v17; // r2
  int v18; // r5
  unsigned int v19; // r2
  unsigned int v20; // r9
  unsigned int v21; // r1
  char *v22; // lr
  int v23; // r6
  int v24; // r10
  int v25; // r1
  unsigned int v26; // r12
  unsigned int v27; // r9
  unsigned int v28; // r1
  char *v29; // r5
  unsigned int v30; // lr
  int v31; // r7
  char *v32; // r2
  char *v33; // r2
  char *v34; // r0
  char *v35; // r6
  int v36; // r4
  int v37; // r12
  int v38; // r9
  char *v39; // r5
  char *v40; // r7
  int v41; // r1
  int v42; // r5
  int v43; // r2
  int v44; // r12
  int v45; // r6
  int v46; // r7
  unsigned int v47; // r0
  int v48; // r7
  int v49; // lr
  int v50; // r9
  int v51; // r2
  int v52; // r6
  int v53; // r5
  char *v54; // r1
  int v55; // r2
  int v56; // r12
  unsigned int v57; // r6
  unsigned int v58; // r2
  int v59; // r4
  int v60; // r5
  unsigned int v61; // r12
  unsigned int v62; // r0
  unsigned int v63; // r1
  unsigned int v64; // r7
  unsigned int v65; // r10
  int v66; // r8
  int v67; // r12
  int v68; // r9
  unsigned int v69; // r1
  unsigned int v70; // r2
  unsigned int v71; // r12
  unsigned int v72; // r0
  int v73; // r5
  unsigned int v74; // r0
  unsigned int v75; // lr
  unsigned int v76; // r4
  unsigned int v77; // r5
  int v78; // r2
  int v79; // r9
  int v80; // r1
  int v81; // r10
  unsigned int v82; // lr
  unsigned int v83; // r5
  unsigned int v84; // r0
  unsigned int v85; // r2
  int v86; // r9
  char *v87; // r4
  int v88; // r7
  char *v89; // r6
  int v90; // r10
  char *v91; // r12
  int v92; // r5
  int v93; // lr
  char *v94; // r0
  int v95; // r10
  int v96; // r4
  unsigned int v97; // r1
  int v98; // r12
  int v99; // r5
  int v100; // r9
  int v101; // r2
  int v102; // r10
  unsigned int v103; // r7
  int v104; // r1
  unsigned int v105; // r4
  int v106; // r2
  int v107; // r6
  int v108; // lr
  int v109; // r10
  unsigned int v110; // r6
  int v111; // r0
  char *v112; // r12
  unsigned int v113; // r7
  int v114; // lr
  int v115; // r4
  int v116; // r0
  int v117; // r0
  unsigned int v118; // r2
  unsigned int v119; // r12
  char *v120; // r6
  char *v121; // r7
  int v122; // r1
  char *v123; // r0
  int v124; // r4
  char *v125; // r6
  int v126; // r5
  unsigned int v127; // r10
  int v128; // r6
  int v129; // r3
  char *v130; // r10
  int v131; // lr
  int v132; // r1
  unsigned int v133; // r1
  unsigned int v134; // lr
  unsigned int v135; // r5
  unsigned int v136; // r7
  int v137; // r8
  char *v138; // r2
  char *v139; // r10
  char *v140; // r7
  int v141; // r0
  int v142; // lr
  int v143; // r0
  int v144; // r9
  int v145; // r1
  int v146; // r6
  int v147; // r8
  int v148; // r9
  unsigned int v149; // r0
  unsigned int v150; // r5
  unsigned int v151; // r4
  unsigned int v152; // lr
  unsigned int v153; // r12
  unsigned int v154; // r3
  unsigned int v155; // r2
  unsigned int v156; // r0
  unsigned int v157; // r1
  int v158; // r9
  int v159; // r5
  int v160; // r6
  int v161; // lr
  unsigned int v162; // r2
  unsigned int v163; // r0
  unsigned int v164; // r3
  int v165; // r8
  int v166; // r7
  int v167; // r12
  int v168; // r3
  unsigned int v169; // r0
  unsigned int v170; // r7
  char *v171; // r2
  unsigned int v172; // r3
  int v173; // r6
  int v174; // r1
  int v175; // r2
  int v176; // r8
  unsigned int v177; // r7
  unsigned int v178; // r3
  unsigned int v179; // r1
  unsigned int v180; // lr
  int v181; // r2
  int v182; // r12
  int v183; // r10
  int v184; // lr
  int v185; // r7
  int v186; // r6
  unsigned int v187; // r5
  int v188; // r0
  int v189; // r1
  int v190; // r11
  int v191; // r4
  int v192; // r3
  unsigned int v193; // r12
  unsigned int v194; // r7
  unsigned int v195; // r0
  unsigned int v196; // lr
  int v197; // r4
  unsigned int v198; // r7
  unsigned int v199; // r9
  unsigned int v200; // r1
  int v201; // r4
  int v202; // r5
  int v203; // r6
  int v204; // r12
  int v205; // r7
  int v206; // r4
  unsigned int v207; // r10
  unsigned int v208; // lr
  int v209; // r0
  unsigned int v210; // r12
  int v211; // r7
  int v212; // r6
  int v213; // r1
  int v214; // r10
  unsigned int v215; // r3
  unsigned int v216; // r1
  unsigned int v217; // r0
  unsigned int v218; // r12
  int v219; // r4
  int v220; // r7
  int v221; // r6
  unsigned int v222; // r3
  unsigned int v223; // r0
  int v224; // r10
  unsigned int v225; // r1
  unsigned int v226; // r12
  unsigned int v227; // r6
  int v228; // lr
  int v229; // r10
  int v230; // r12
  unsigned int v231; // lr
  unsigned int v232; // r12
  unsigned int v233; // r0
  unsigned int v234; // r5
  int v235; // r11
  unsigned int v236; // r7
  unsigned int v237; // r6
  unsigned int v238; // r3
  unsigned int v239; // r8
  int v240; // r12
  unsigned int v241; // r4
  unsigned int v242; // r10
  unsigned int v243; // r9
  int v244; // r11
  int v245; // r12
  unsigned int v246; // r1
  int v247; // r0
  int v248; // r12
  int v249; // r7
  unsigned int v250; // r2
  unsigned int v251; // r9
  unsigned int v252; // r8
  unsigned int v253; // r7
  int v254; // lr
  int v255; // r12
  unsigned int v256; // r0
  unsigned int v257; // r1
  unsigned int v258; // r2
  unsigned int v259; // r6
  int v260; // r11
  int v261; // r4
  int v262; // r8
  char *v263; // r7
  char *v264; // r6
  int v265; // r8
  int v266; // r5
  unsigned int v267; // r12
  int v268; // r0
  unsigned int v269; // r0
  unsigned int v270; // r2
  unsigned int v271; // r1
  unsigned int v272; // r12
  int v273; // r9
  int v274; // r6
  int v275; // r8
  unsigned int v276; // r1
  unsigned int v277; // r11
  unsigned int v278; // r12
  unsigned int v279; // r4
  int v280; // r2
  int v281; // lr
  int v282; // r10
  int v283; // r9
  int v284; // r1
  int v285; // r12
  int v286; // r9
  unsigned int v287; // r2
  int v288; // r4
  int v289; // lr
  int v290; // r6
  int v291; // r5
  int v292; // r1
  int v293; // r7
  int v294; // r10
  unsigned int v295; // r0
  unsigned int v296; // r12
  unsigned int v297; // lr
  unsigned int v298; // r1
  int v299; // r9
  unsigned int v300; // r7
  unsigned int v301; // r12
  unsigned int v302; // r11
  unsigned int v303; // r1
  int v304; // r3
  int result; // r0
  int v306; // r4
  int v307; // lr
  int v308; // r5
  __int64 v309; // r6
  unsigned int v310; // [sp+0h] [bp-DCh]
  int v311; // [sp+0h] [bp-DCh]
  unsigned int v312; // [sp+0h] [bp-DCh]
  unsigned int v313; // [sp+0h] [bp-DCh]
  int v314; // [sp+0h] [bp-DCh]
  unsigned int v315; // [sp+0h] [bp-DCh]
  int v316; // [sp+0h] [bp-DCh]
  unsigned int v317; // [sp+0h] [bp-DCh]
  int v318; // [sp+0h] [bp-DCh]
  int v319; // [sp+0h] [bp-DCh]
  int v320; // [sp+0h] [bp-DCh]
  unsigned int v321; // [sp+4h] [bp-D8h]
  int v322; // [sp+4h] [bp-D8h]
  unsigned int v323; // [sp+4h] [bp-D8h]
  unsigned int v324; // [sp+4h] [bp-D8h]
  int v325; // [sp+4h] [bp-D8h]
  unsigned int v326; // [sp+4h] [bp-D8h]
  int v327; // [sp+4h] [bp-D8h]
  int v328; // [sp+4h] [bp-D8h]
  int v329; // [sp+4h] [bp-D8h]
  unsigned int v330; // [sp+8h] [bp-D4h]
  int v331; // [sp+8h] [bp-D4h]
  unsigned int v332; // [sp+8h] [bp-D4h]
  unsigned int v333; // [sp+8h] [bp-D4h]
  int v334; // [sp+8h] [bp-D4h]
  int v335; // [sp+8h] [bp-D4h]
  int v336; // [sp+8h] [bp-D4h]
  unsigned int v337; // [sp+8h] [bp-D4h]
  int v338; // [sp+8h] [bp-D4h]
  int v339; // [sp+8h] [bp-D4h]
  int v340; // [sp+Ch] [bp-D0h]
  unsigned int v341; // [sp+Ch] [bp-D0h]
  unsigned int v342; // [sp+Ch] [bp-D0h]
  int v343; // [sp+Ch] [bp-D0h]
  int v344; // [sp+Ch] [bp-D0h]
  unsigned int v345; // [sp+Ch] [bp-D0h]
  int v346; // [sp+Ch] [bp-D0h]
  unsigned int v347; // [sp+Ch] [bp-D0h]
  int v348; // [sp+Ch] [bp-D0h]
  int v349; // [sp+Ch] [bp-D0h]
  unsigned int v350; // [sp+10h] [bp-CCh]
  int v351; // [sp+10h] [bp-CCh]
  int v352; // [sp+10h] [bp-CCh]
  unsigned int v353; // [sp+10h] [bp-CCh]
  int v354; // [sp+10h] [bp-CCh]
  unsigned int v355; // [sp+10h] [bp-CCh]
  int v356; // [sp+10h] [bp-CCh]
  int v357; // [sp+10h] [bp-CCh]
  unsigned int v358; // [sp+10h] [bp-CCh]
  int v359; // [sp+10h] [bp-CCh]
  int v360; // [sp+10h] [bp-CCh]
  unsigned int v361; // [sp+10h] [bp-CCh]
  int v362; // [sp+10h] [bp-CCh]
  unsigned int v363; // [sp+14h] [bp-C8h]
  int v364; // [sp+14h] [bp-C8h]
  unsigned int v365; // [sp+14h] [bp-C8h]
  unsigned int v366; // [sp+14h] [bp-C8h]
  int v367; // [sp+14h] [bp-C8h]
  int v368; // [sp+14h] [bp-C8h]
  unsigned int v369; // [sp+14h] [bp-C8h]
  int v370; // [sp+14h] [bp-C8h]
  unsigned int v371; // [sp+14h] [bp-C8h]
  int v372; // [sp+14h] [bp-C8h]
  int v373; // [sp+14h] [bp-C8h]
  unsigned int v374; // [sp+18h] [bp-C4h]
  int v375; // [sp+18h] [bp-C4h]
  int v376; // [sp+18h] [bp-C4h]
  unsigned int v377; // [sp+18h] [bp-C4h]
  int v378; // [sp+18h] [bp-C4h]
  unsigned int v379; // [sp+18h] [bp-C4h]
  int v380; // [sp+18h] [bp-C4h]
  unsigned int v381; // [sp+18h] [bp-C4h]
  int v382; // [sp+18h] [bp-C4h]
  unsigned int v383; // [sp+1Ch] [bp-C0h]
  int v384; // [sp+1Ch] [bp-C0h]
  int v385; // [sp+1Ch] [bp-C0h]
  unsigned int v386; // [sp+1Ch] [bp-C0h]
  int v387; // [sp+1Ch] [bp-C0h]
  unsigned int v388; // [sp+1Ch] [bp-C0h]
  int v389; // [sp+1Ch] [bp-C0h]
  int v390; // [sp+1Ch] [bp-C0h]
  int v391; // [sp+1Ch] [bp-C0h]
  int v392; // [sp+1Ch] [bp-C0h]
  unsigned int v393; // [sp+1Ch] [bp-C0h]
  int v394; // [sp+1Ch] [bp-C0h]
  unsigned int v395; // [sp+20h] [bp-BCh]
  int v396; // [sp+20h] [bp-BCh]
  int v397; // [sp+20h] [bp-BCh]
  int v398; // [sp+20h] [bp-BCh]
  unsigned int v399; // [sp+20h] [bp-BCh]
  int v400; // [sp+20h] [bp-BCh]
  int v401; // [sp+20h] [bp-BCh]
  unsigned int v402; // [sp+20h] [bp-BCh]
  int v403; // [sp+20h] [bp-BCh]
  unsigned int v404; // [sp+20h] [bp-BCh]
  unsigned int v405; // [sp+20h] [bp-BCh]
  int v406; // [sp+20h] [bp-BCh]
  unsigned int v407; // [sp+24h] [bp-B8h]
  int v408; // [sp+24h] [bp-B8h]
  unsigned int v409; // [sp+24h] [bp-B8h]
  int v410; // [sp+24h] [bp-B8h]
  unsigned int v411; // [sp+24h] [bp-B8h]
  int v412; // [sp+24h] [bp-B8h]
  unsigned int v413; // [sp+24h] [bp-B8h]
  int v414; // [sp+24h] [bp-B8h]
  int v415; // [sp+24h] [bp-B8h]
  unsigned int v416; // [sp+28h] [bp-B4h]
  int v417; // [sp+28h] [bp-B4h]
  int v418; // [sp+28h] [bp-B4h]
  unsigned int v419; // [sp+28h] [bp-B4h]
  int v420; // [sp+28h] [bp-B4h]
  int v421; // [sp+28h] [bp-B4h]
  unsigned int v422; // [sp+28h] [bp-B4h]
  unsigned int v423; // [sp+28h] [bp-B4h]
  int v424; // [sp+28h] [bp-B4h]
  int v425; // [sp+28h] [bp-B4h]
  int v426; // [sp+28h] [bp-B4h]
  unsigned int v428; // [sp+30h] [bp-ACh]
  int v429; // [sp+30h] [bp-ACh]
  unsigned int v430; // [sp+30h] [bp-ACh]
  int v431; // [sp+30h] [bp-ACh]
  unsigned int v432; // [sp+30h] [bp-ACh]
  unsigned int v433; // [sp+30h] [bp-ACh]
  int v434; // [sp+30h] [bp-ACh]
  int v435; // [sp+30h] [bp-ACh]
  int v436; // [sp+34h] [bp-A8h]
  int v437; // [sp+34h] [bp-A8h]
  unsigned int v438; // [sp+34h] [bp-A8h]
  unsigned int v439; // [sp+34h] [bp-A8h]
  int v440; // [sp+34h] [bp-A8h]
  int v441; // [sp+34h] [bp-A8h]
  int v442; // [sp+38h] [bp-A4h]
  unsigned int v443; // [sp+3Ch] [bp-A0h]
  int v444; // [sp+3Ch] [bp-A0h]
  int v445; // [sp+3Ch] [bp-A0h]
  int v446; // [sp+3Ch] [bp-A0h]
  int v447; // [sp+3Ch] [bp-A0h]
  int v448; // [sp+3Ch] [bp-A0h]
  unsigned int v449; // [sp+3Ch] [bp-A0h]
  int v450; // [sp+3Ch] [bp-A0h]
  unsigned int v451; // [sp+40h] [bp-9Ch]
  int v452; // [sp+40h] [bp-9Ch]
  unsigned int v453; // [sp+40h] [bp-9Ch]
  unsigned int v454; // [sp+40h] [bp-9Ch]
  int v455; // [sp+40h] [bp-9Ch]
  int v456; // [sp+40h] [bp-9Ch]
  int v457; // [sp+40h] [bp-9Ch]
  char *v458; // [sp+44h] [bp-98h]
  int v459; // [sp+44h] [bp-98h]
  unsigned int v460; // [sp+44h] [bp-98h]
  int v461; // [sp+44h] [bp-98h]
  int v462; // [sp+44h] [bp-98h]
  int v463; // [sp+44h] [bp-98h]
  int v464; // [sp+44h] [bp-98h]
  unsigned int v465; // [sp+44h] [bp-98h]
  char *v466; // [sp+44h] [bp-98h]
  int v467; // [sp+44h] [bp-98h]
  int v468; // [sp+44h] [bp-98h]
  int v469; // [sp+44h] [bp-98h]
  int v470; // [sp+44h] [bp-98h]
  int v471; // [sp+48h] [bp-94h]
  int v472; // [sp+48h] [bp-94h]
  int v473; // [sp+4Ch] [bp-90h]
  int v474; // [sp+50h] [bp-8Ch]
  int v475; // [sp+54h] [bp-88h]
  int v476; // [sp+58h] [bp-84h]
  int v477; // [sp+5Ch] [bp-80h]
  int v478; // [sp+60h] [bp-7Ch]
  int v479; // [sp+64h] [bp-78h]
  int v480; // [sp+68h] [bp-74h]
  unsigned int v481; // [sp+68h] [bp-74h]
  int v482; // [sp+68h] [bp-74h]
  int v483; // [sp+68h] [bp-74h]
  char *v484; // [sp+68h] [bp-74h]
  int v485; // [sp+68h] [bp-74h]
  unsigned int v486; // [sp+68h] [bp-74h]
  int v487; // [sp+68h] [bp-74h]
  int v488; // [sp+68h] [bp-74h]
  int v489; // [sp+68h] [bp-74h]
  int v490; // [sp+68h] [bp-74h]
  int v491; // [sp+6Ch] [bp-70h]
  unsigned int v492; // [sp+6Ch] [bp-70h]
  int v493; // [sp+6Ch] [bp-70h]
  int v494; // [sp+6Ch] [bp-70h]
  unsigned int v495; // [sp+6Ch] [bp-70h]
  int v496; // [sp+6Ch] [bp-70h]
  int v497; // [sp+6Ch] [bp-70h]
  char *v498; // [sp+6Ch] [bp-70h]
  int v499; // [sp+6Ch] [bp-70h]
  int v500; // [sp+70h] [bp-6Ch]
  int v501; // [sp+70h] [bp-6Ch]
  int v502; // [sp+70h] [bp-6Ch]
  int v503; // [sp+70h] [bp-6Ch]
  int v504; // [sp+70h] [bp-6Ch]
  int v505; // [sp+70h] [bp-6Ch]
  int v506; // [sp+70h] [bp-6Ch]
  int v507; // [sp+70h] [bp-6Ch]
  int v508; // [sp+74h] [bp-68h]
  int v509; // [sp+74h] [bp-68h]
  int v510; // [sp+74h] [bp-68h]
  int v511; // [sp+74h] [bp-68h]
  int v512; // [sp+74h] [bp-68h]
  int v513; // [sp+74h] [bp-68h]
  int v514; // [sp+74h] [bp-68h]
  int v515; // [sp+74h] [bp-68h]
  char *v516; // [sp+74h] [bp-68h]
  int v517; // [sp+74h] [bp-68h]
  int v518; // [sp+78h] [bp-64h]
  unsigned int v519; // [sp+78h] [bp-64h]
  int v520; // [sp+78h] [bp-64h]
  unsigned int v521; // [sp+78h] [bp-64h]
  char *v522; // [sp+78h] [bp-64h]
  int v523; // [sp+78h] [bp-64h]
  int v524; // [sp+78h] [bp-64h]
  int v525; // [sp+78h] [bp-64h]
  int v526; // [sp+7Ch] [bp-60h]
  int v527; // [sp+7Ch] [bp-60h]
  int v528; // [sp+7Ch] [bp-60h]
  int v529; // [sp+7Ch] [bp-60h]
  int v530; // [sp+7Ch] [bp-60h]
  int v531; // [sp+7Ch] [bp-60h]
  int v532; // [sp+7Ch] [bp-60h]
  int v533; // [sp+7Ch] [bp-60h]
  int v534; // [sp+80h] [bp-5Ch]
  int v535; // [sp+80h] [bp-5Ch]
  int v536; // [sp+80h] [bp-5Ch]
  int v537; // [sp+80h] [bp-5Ch]
  int v538; // [sp+80h] [bp-5Ch]
  int v539; // [sp+80h] [bp-5Ch]
  int v540; // [sp+84h] [bp-58h]
  int v541; // [sp+84h] [bp-58h]
  unsigned int v542; // [sp+84h] [bp-58h]
  int v543; // [sp+84h] [bp-58h]
  int v544; // [sp+84h] [bp-58h]
  int v545; // [sp+84h] [bp-58h]
  int v546; // [sp+84h] [bp-58h]
  int v547; // [sp+84h] [bp-58h]
  int v548; // [sp+88h] [bp-54h]
  int v549; // [sp+88h] [bp-54h]
  int v550; // [sp+88h] [bp-54h]
  int v551; // [sp+88h] [bp-54h]
  int v552; // [sp+88h] [bp-54h]
  int v553; // [sp+88h] [bp-54h]
  int v554; // [sp+88h] [bp-54h]
  unsigned int v555; // [sp+88h] [bp-54h]
  char *v556; // [sp+88h] [bp-54h]
  int v557; // [sp+88h] [bp-54h]
  int v558; // [sp+8Ch] [bp-50h]
  int v559; // [sp+8Ch] [bp-50h]
  int v560; // [sp+90h] [bp-4Ch]
  int v561; // [sp+90h] [bp-4Ch]
  int v562; // [sp+90h] [bp-4Ch]
  int v563; // [sp+90h] [bp-4Ch]
  int v564; // [sp+90h] [bp-4Ch]
  int v565; // [sp+94h] [bp-48h]
  int v566; // [sp+94h] [bp-48h]
  int v567; // [sp+94h] [bp-48h]
  int v568; // [sp+94h] [bp-48h]
  int v569; // [sp+94h] [bp-48h]
  int v570; // [sp+94h] [bp-48h]
  int v571; // [sp+94h] [bp-48h]
  int v572; // [sp+94h] [bp-48h]
  int v573; // [sp+98h] [bp-44h]
  int v574; // [sp+98h] [bp-44h]
  int v575; // [sp+98h] [bp-44h]
  int v576; // [sp+98h] [bp-44h]
  char *v577; // [sp+98h] [bp-44h]
  int v578; // [sp+98h] [bp-44h]
  int v579; // [sp+98h] [bp-44h]
  int v580; // [sp+9Ch] [bp-40h]
  int v581; // [sp+9Ch] [bp-40h]
  int v582; // [sp+9Ch] [bp-40h]
  int v583; // [sp+9Ch] [bp-40h]
  char *v584; // [sp+9Ch] [bp-40h]
  int v585; // [sp+9Ch] [bp-40h]
  int v586; // [sp+9Ch] [bp-40h]
  int v587; // [sp+9Ch] [bp-40h]
  int v588; // [sp+9Ch] [bp-40h]
  int v589; // [sp+A0h] [bp-3Ch]
  int v590; // [sp+A0h] [bp-3Ch]
  unsigned int v591; // [sp+A0h] [bp-3Ch]
  int v592; // [sp+A0h] [bp-3Ch]
  char *v593; // [sp+A0h] [bp-3Ch]
  int v594; // [sp+A0h] [bp-3Ch]
  int v595; // [sp+A4h] [bp-38h]
  int v596; // [sp+A4h] [bp-38h]
  int v597; // [sp+A4h] [bp-38h]
  int v598; // [sp+A4h] [bp-38h]
  int v599; // [sp+A4h] [bp-38h]
  int v600; // [sp+A4h] [bp-38h]
  char *v601; // [sp+A8h] [bp-34h]
  int v602; // [sp+A8h] [bp-34h]
  int v603; // [sp+A8h] [bp-34h]
  int v604; // [sp+A8h] [bp-34h]
  int v605; // [sp+A8h] [bp-34h]
  int v606; // [sp+A8h] [bp-34h]
  int v607; // [sp+A8h] [bp-34h]
  int v608; // [sp+A8h] [bp-34h]
  int v609; // [sp+ACh] [bp-30h]
  int v610; // [sp+ACh] [bp-30h]
  int v611; // [sp+ACh] [bp-30h]
  int v612; // [sp+ACh] [bp-30h]
  char *v613; // [sp+ACh] [bp-30h]
  int v614; // [sp+B0h] [bp-2Ch]
  int v615; // [sp+B4h] [bp-28h]
  int v616; // [sp+B4h] [bp-28h]
  int v617; // [sp+B4h] [bp-28h]
  int v618; // [sp+B4h] [bp-28h]
  char *v619; // [sp+B8h] [bp-24h]
  int v620; // [sp+B8h] [bp-24h]
  int v621; // [sp+B8h] [bp-24h]
  unsigned int v622; // [sp+B8h] [bp-24h]
  int v623; // [sp+B8h] [bp-24h]
  int v624; // [sp+B8h] [bp-24h]
  int v625; // [sp+BCh] [bp-20h]
  int v626; // [sp+BCh] [bp-20h]
  char *v627; // [sp+BCh] [bp-20h]
  int v628; // [sp+BCh] [bp-20h]
  int v629; // [sp+BCh] [bp-20h]
  char *v630; // [sp+C0h] [bp-1Ch]
  char *v631; // [sp+C0h] [bp-1Ch]
  int v632; // [sp+C0h] [bp-1Ch]
  char *v633; // [sp+C0h] [bp-1Ch]
  char *v634; // [sp+C0h] [bp-1Ch]
  char *v635; // [sp+C0h] [bp-1Ch]
  char *v636; // [sp+C0h] [bp-1Ch]
  char *v637; // [sp+C4h] [bp-18h]
  int v638; // [sp+C4h] [bp-18h]
  char *v639; // [sp+C4h] [bp-18h]
  char *v640; // [sp+C4h] [bp-18h]
  char *v641; // [sp+C4h] [bp-18h]
  int v642; // [sp+C8h] [bp-14h]
  char *v643; // [sp+C8h] [bp-14h]
  int v644; // [sp+C8h] [bp-14h]
  char *v645; // [sp+C8h] [bp-14h]
  int v646; // [sp+C8h] [bp-14h]
  char *v647; // [sp+CCh] [bp-10h]
  char *v648; // [sp+CCh] [bp-10h]
  int v649; // [sp+CCh] [bp-10h]
  char *v650; // [sp+D0h] [bp-Ch]
  char *v651; // [sp+D0h] [bp-Ch]
  char *v652; // [sp+D0h] [bp-Ch]
  char *v653; // [sp+D4h] [bp-8h]

  v2 = a1[21] ^ *a2;
  v477 = a1[21];
  v3 = a1[22] ^ a2[1];
  v442 = a1[24];
  v407 = a2[1];
  v479 = a1[23];
  v478 = a1[22];
  v350 = a2[2];
  v451 = a2[3];
  v321 = a2[5];
  v330 = a2[6];
  v428 = a2[7];
  v4 = dword_F3268[(unsigned __int8)(BYTE2(v442) ^ BYTE2(v451)) + 768]
     ^ dword_F3268[HIBYTE(v2) + 256]
     ^ dword_F3268[(unsigned __int8)v3]
     ^ v321
     ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v479 ^ v350) >> 8) + 512];
  v416 = a2[4];
  v5 = dword_F3268[(unsigned __int8)((unsigned __int16)(v442 ^ v451) >> 8) + 512]
     ^ dword_F3268[(unsigned __int8)(v479 ^ v350)]
     ^ dword_F3268[HIBYTE(v3) + 256]
     ^ v330
     ^ dword_F3268[BYTE2(v2) + 768];
  v6 = dword_F3268[BYTE1(v2) + 512]
     ^ dword_F3268[(unsigned __int8)(v442 ^ v451)]
     ^ dword_F3268[((v479 ^ v350) >> 24) + 256]
     ^ v428
     ^ dword_F3268[BYTE2(v3) + 768];
  v7 = dword_F3268[((v442 ^ v451) >> 24) + 256]
     ^ dword_F3268[(unsigned __int8)v2]
     ^ v416
     ^ dword_F3268[BYTE1(v3) + 512]
     ^ dword_F3268[(unsigned __int8)((v479 ^ v350) >> 16) + 768];
  v458 = (char *)&dword_F3268[HIBYTE(v7)];
  v480 = dword_F3268[HIBYTE(v4) + 256];
  v473 = a1[17];
  v476 = a1[20];
  v474 = a1[18];
  v475 = a1[19];
  v363 = a2[8];
  v8 = dword_F3268[(unsigned __int8)v7] ^ dword_F3268[HIBYTE(v6) + 256];
  v383 = a2[10];
  v395 = a2[11];
  v9 = dword_F3268[(unsigned __int8)v4];
  v374 = a2[9];
  v340 = dword_F3268[BYTE1(v4) + 512];
  v10 = dword_F3268[BYTE2(v4) + 768]
      ^ dword_F3268[(unsigned __int8)v6]
      ^ dword_F3268[HIBYTE(v5) + 256]
      ^ v395
      ^ dword_F3268[BYTE1(v7) + 512];
  v11 = dword_F3268[BYTE2(v6) + 768];
  v12 = dword_F3268[BYTE2(v7) + 768] ^ dword_F3268[(unsigned __int8)v5] ^ v480 ^ v383 ^ dword_F3268[BYTE1(v6) + 512];
  v13 = v8 ^ v363 ^ v340 ^ dword_F3268[BYTE2(v5) + 768];
  v14 = v9 ^ *((_DWORD *)v458 + 256) ^ v374 ^ dword_F3268[BYTE1(v5) + 512] ^ v11;
  v526 = dword_F3268[(unsigned __int8)v14]
       ^ dword_F3268[HIBYTE(v13) + 256]
       ^ v474
       ^ dword_F3268[BYTE1(v12) + 512]
       ^ dword_F3268[BYTE2(v10) + 768];
  v341 = a2[13];
  v481 = a2[12];
  v443 = a2[15];
  v310 = a2[14];
  v518 = dword_F3268[(unsigned __int8)v13]
       ^ dword_F3268[HIBYTE(v10) + 256]
       ^ v473
       ^ dword_F3268[BYTE1(v14) + 512]
       ^ dword_F3268[BYTE2(v12) + 768];
  v15 = dword_F3268[BYTE2(v14) + 768]
      ^ dword_F3268[(unsigned __int8)v10]
      ^ dword_F3268[HIBYTE(v12) + 256]
      ^ v476
      ^ dword_F3268[BYTE1(v13) + 512]
      ^ v443;
  v540 = dword_F3268[BYTE2(v14) + 768]
       ^ dword_F3268[(unsigned __int8)v10]
       ^ dword_F3268[HIBYTE(v12) + 256]
       ^ v476
       ^ dword_F3268[BYTE1(v13) + 512];
  v534 = dword_F3268[(unsigned __int8)v12]
       ^ dword_F3268[HIBYTE(v14) + 256]
       ^ v475
       ^ dword_F3268[BYTE1(v10) + 512]
       ^ dword_F3268[BYTE2(v13) + 768];
  v601 = (char *)&dword_F3268[HIBYTE(v350)];
  v558 = dword_F3268[(unsigned __int8)v350];
  v436 = a1[26];
  v637 = (char *)&dword_F3268[BYTE1(v407)];
  v459 = dword_F3268[BYTE1(v350) + 512];
  v16 = (char *)&dword_F3268[BYTE2(v350)];
  v351 = dword_F3268[(unsigned __int8)v407];
  v17 = v558 ^ dword_F3268[HIBYTE(v407) + 256] ^ v341;
  v559 = ~v436;
  v609 = dword_F3268[BYTE2(v407) + 768];
  v408 = v17 ^ ~v436 ^ dword_F3268[BYTE1(v451) + 512] ^ dword_F3268[(unsigned __int8)BYTE2(*a2) + 768];
  v471 = a1[25];
  v18 = *((_DWORD *)v601 + 256) ^ dword_F3268[(unsigned __int8)v451];
  v352 = v471 ^ v481 ^ v351 ^ dword_F3268[HIBYTE(*a2) + 256] ^ v459 ^ dword_F3268[BYTE2(v451) + 768];
  v452 = *((_DWORD *)v16 + 768)
       ^ dword_F3268[HIBYTE(v451) + 256]
       ^ dword_F3268[(unsigned __int8)*a2]
       ^ v443
       ^ *((_DWORD *)v637 + 512);
  v491 = v18 ^ v310 ^ dword_F3268[(unsigned __int8)BYTE1(*a2) + 512] ^ v609;
  v19 = dword_F3268[(unsigned __int8)(v534 ^ v310)]
      ^ dword_F3268[((v526 ^ v341) >> 24) + 256]
      ^ v491
      ^ dword_F3268[BYTE1(v15) + 512]
      ^ dword_F3268[(unsigned __int8)((v518 ^ v481) >> 16) + 768];
  v460 = dword_F3268[(unsigned __int8)(v518 ^ v481)]
       ^ dword_F3268[HIBYTE(v15) + 256]
       ^ v352
       ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v526 ^ v341) >> 8) + 512]
       ^ dword_F3268[(unsigned __int8)((v534 ^ v310) >> 16) + 768];
  v20 = dword_F3268[(unsigned __int8)v15]
      ^ dword_F3268[((v534 ^ v310) >> 24) + 256]
      ^ v452
      ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v518 ^ v481) >> 8) + 512]
      ^ dword_F3268[(unsigned __int8)((v526 ^ v341) >> 16) + 768];
  v21 = dword_F3268[(unsigned __int8)(v526 ^ v341)]
      ^ dword_F3268[((v518 ^ v481) >> 24) + 256]
      ^ v408
      ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v534 ^ v310) >> 8) + 512]
      ^ dword_F3268[BYTE2(v15) + 768];
  v500 = (unsigned __int8)v321;
  v580 = (unsigned __int8)v21;
  v630 = (char *)&dword_F3268[BYTE1(v321)];
  v650 = (char *)&dword_F3268[BYTE2(v21)];
  v508 = dword_F3268[BYTE1(v21) + 512];
  v595 = dword_F3268[BYTE2(v321) + 768];
  v610 = dword_F3268[HIBYTE(v21) + 256];
  v322 = dword_F3268[BYTE1(v428) + 512]
       ^ dword_F3268[(unsigned __int8)v330]
       ^ dword_F3268[HIBYTE(v321) + 256]
       ^ dword_F3268[BYTE2(v416) + 768]
       ^ v408;
  v22 = (char *)&dword_F3268[BYTE2(v20)];
  v23 = dword_F3268[v500]
      ^ dword_F3268[HIBYTE(v416) + 256]
      ^ dword_F3268[BYTE1(v330) + 512]
      ^ dword_F3268[BYTE2(v428) + 768]
      ^ v352;
  v24 = dword_F3268[HIBYTE(v330) + 256]
      ^ dword_F3268[(unsigned __int8)v428]
      ^ dword_F3268[BYTE1(v416) + 512]
      ^ v595
      ^ v491;
  v25 = dword_F3268[(unsigned __int8)v460] ^ dword_F3268[HIBYTE(v20) + 256] ^ v23;
  v417 = dword_F3268[HIBYTE(v428) + 256]
       ^ dword_F3268[(unsigned __int8)v416]
       ^ *((_DWORD *)v630 + 512)
       ^ dword_F3268[BYTE2(v330) + 768]
       ^ v452;
  v429 = v23;
  v26 = dword_F3268[(unsigned __int8)v19] ^ v610 ^ v24 ^ dword_F3268[BYTE1(v20) + 512] ^ dword_F3268[BYTE2(v460) + 768];
  v501 = v24;
  v27 = dword_F3268[BYTE1(v460) + 512]
      ^ dword_F3268[(unsigned __int8)v20]
      ^ dword_F3268[HIBYTE(v19) + 256]
      ^ v417
      ^ *((_DWORD *)v650 + 768);
  v28 = v25 ^ v508 ^ dword_F3268[BYTE2(v19) + 768];
  v29 = (char *)&dword_F3268[HIBYTE(v26)];
  v30 = dword_F3268[v580]
      ^ dword_F3268[HIBYTE(v460) + 256]
      ^ v322
      ^ dword_F3268[BYTE1(v19) + 512]
      ^ *((_DWORD *)v22 + 768);
  v619 = (char *)&dword_F3268[HIBYTE(v374)];
  v615 = (unsigned __int8)v383;
  v647 = (char *)&dword_F3268[HIBYTE(v395)];
  v642 = (unsigned __int8)v363;
  v631 = (char *)&dword_F3268[HIBYTE(v383)];
  v560 = dword_F3268[HIBYTE(v28) + 256];
  v573 = dword_F3268[BYTE1(v27) + 512];
  v596 = dword_F3268[BYTE1(v28) + 512];
  v625 = (unsigned __int8)v395;
  v31 = BYTE1(v383);
  v32 = (char *)&dword_F3268[BYTE2(v383)];
  v384 = dword_F3268[BYTE1(v26) + 512];
  v651 = v32;
  v602 = dword_F3268[BYTE2(v26) + 768];
  v33 = (char *)&dword_F3268[BYTE1(v395)];
  v565 = dword_F3268[BYTE2(v27) + 768];
  v581 = dword_F3268[BYTE2(v28) + 768];
  v548 = dword_F3268[BYTE2(v395) + 768];
  v34 = (char *)&dword_F3268[BYTE2(v374)];
  v35 = (char *)&dword_F3268[BYTE1(v374)];
  v331 = dword_F3268[HIBYTE(v30) + 256] ^ dword_F3268[(unsigned __int8)v26] ^ v479;
  v36 = dword_F3268[(unsigned __int8)v28] ^ dword_F3268[HIBYTE(v27) + 256];
  v37 = dword_F3268[HIBYTE(v363) + 256];
  v396 = dword_F3268[(unsigned __int8)v27] ^ *((_DWORD *)v29 + 256);
  v38 = dword_F3268[(unsigned __int8)v374];
  v375 = dword_F3268[v31 + 512];
  v39 = (char *)&dword_F3268[BYTE2(v363)];
  v40 = (char *)&dword_F3268[BYTE1(v363)];
  v364 = *((_DWORD *)v33 + 512);
  v461 = *((_DWORD *)v39 + 768);
  v41 = *((_DWORD *)v647 + 256) ^ dword_F3268[v642] ^ *((_DWORD *)v35 + 512) ^ *((_DWORD *)v651 + 768);
  v42 = v396 ^ v442 ^ v596;
  v43 = dword_F3268[v625] ^ *((_DWORD *)v631 + 256) ^ *((_DWORD *)v40 + 512);
  v397 = *((_DWORD *)v34 + 768);
  v44 = v37 ^ v38 ^ v375 ^ v548;
  v45 = v331 ^ v573;
  v574 = v42 ^ dword_F3268[BYTE2(v30) + 768];
  v549 = v36 ^ v477 ^ dword_F3268[BYTE1(v30) + 512] ^ v602;
  v46 = dword_F3268[(unsigned __int8)v30] ^ v560 ^ v478 ^ v384 ^ v565;
  v376 = v44 ^ v429;
  v385 = *((_DWORD *)v619 + 256) ^ dword_F3268[v615] ^ v364 ^ v461 ^ v322;
  v47 = v46 ^ v385;
  v561 = v46;
  v566 = v45 ^ v581;
  v332 = v574 ^ v41 ^ v417;
  v365 = v45 ^ v581 ^ v43 ^ v397 ^ v24;
  v398 = v43 ^ v397 ^ v24;
  v632 = (unsigned __int8)v481;
  v509 = v41 ^ v417;
  v48 = dword_F3268[BYTE2(v481) + 768];
  v49 = dword_F3268[BYTE1(v481) + 512];
  v50 = dword_F3268[HIBYTE(v481) + 256];
  v597 = dword_F3268[BYTE2(v443) + 768];
  v603 = dword_F3268[HIBYTE(v332) + 256];
  v643 = (char *)&dword_F3268[BYTE2(v310)];
  v482 = dword_F3268[BYTE1(v310) + 512];
  v51 = dword_F3268[(unsigned __int8)v310] ^ dword_F3268[HIBYTE(v341) + 256] ^ dword_F3268[BYTE1(v443) + 512] ^ v48;
  v52 = dword_F3268[HIBYTE(v310) + 256];
  v626 = dword_F3268[BYTE1(v332) + 512];
  v53 = (unsigned __int8)v332;
  v311 = dword_F3268[((v549 ^ v44 ^ (unsigned int)v429) >> 24) + 256]
       ^ dword_F3268[(unsigned __int8)v47]
       ^ v51
       ^ v385
       ^ dword_F3268[BYTE1(v365) + 512];
  v582 = v51 ^ v385;
  v54 = (char *)&dword_F3268[BYTE2(v332)];
  v55 = dword_F3268[(unsigned __int8)(v549 ^ v44 ^ v429)];
  v333 = v352 ^ v582;
  v56 = dword_F3268[HIBYTE(v443) + 256] ^ dword_F3268[v632];
  v444 = v52 ^ dword_F3268[(unsigned __int8)v443] ^ v49 ^ dword_F3268[BYTE2(v341) + 768] ^ v398;
  v483 = v50 ^ dword_F3268[(unsigned __int8)v341] ^ v482 ^ v597 ^ v376;
  v57 = dword_F3268[BYTE2(v47) + 768];
  v462 = v56 ^ dword_F3268[BYTE1(v341) + 512] ^ *((_DWORD *)v643 + 768) ^ v509;
  v58 = v55 ^ v603 ^ v483 ^ dword_F3268[BYTE1(v47) + 512] ^ dword_F3268[BYTE2(v365) + 768];
  v59 = dword_F3268[v53]
      ^ dword_F3268[HIBYTE(v365) + 256]
      ^ v462
      ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v549 ^ v376) >> 8) + 512];
  v60 = v311;
  v312 = dword_F3268[(unsigned __int8)v365]
       ^ dword_F3268[HIBYTE(v47) + 256]
       ^ v444
       ^ v626
       ^ dword_F3268[(unsigned __int8)((v549 ^ (unsigned int)v376) >> 16) + 768];
  v61 = *((_DWORD *)v54 + 768) ^ v60;
  v366 = v452 ^ v352 ^ v582;
  v342 = v408 ^ v444;
  v353 = v491 ^ v462;
  v62 = dword_F3268[BYTE2(v312) + 768]
      ^ dword_F3268[(unsigned __int8)v58]
      ^ dword_F3268[((v59 ^ v57) >> 24) + 256]
      ^ v333
      ^ dword_F3268[BYTE1(v61) + 512];
  v63 = dword_F3268[(unsigned __int8)((v59 ^ v57) >> 16) + 768]
      ^ dword_F3268[(unsigned __int8)v61]
      ^ dword_F3268[HIBYTE(v58) + 256]
      ^ v408
      ^ v444
      ^ dword_F3268[BYTE1(v312) + 512];
  v64 = dword_F3268[(unsigned __int8)(v59 ^ v57)]
      ^ dword_F3268[HIBYTE(v312) + 256]
      ^ v452
      ^ v333
      ^ dword_F3268[BYTE1(v58) + 512]
      ^ dword_F3268[BYTE2(v61) + 768];
  v65 = dword_F3268[(unsigned __int8)((unsigned __int16)(v59 ^ v57) >> 8) + 512]
      ^ dword_F3268[(unsigned __int8)v312]
      ^ dword_F3268[HIBYTE(v61) + 256]
      ^ v491
      ^ v462
      ^ dword_F3268[BYTE2(v58) + 768];
  v66 = dword_F3268[(unsigned __int8)v63];
  v67 = v429 ^ v408 ^ v444;
  v611 = dword_F3268[HIBYTE(v65) + 256]
       ^ dword_F3268[(unsigned __int8)v64]
       ^ v540
       ^ dword_F3268[BYTE1(v62) + 512]
       ^ dword_F3268[BYTE2(v63) + 768];
  v589 = dword_F3268[(unsigned __int8)v62]
       ^ dword_F3268[HIBYTE(v64) + 256]
       ^ v518
       ^ dword_F3268[BYTE1(v63) + 512]
       ^ dword_F3268[BYTE2(v65) + 768];
  v68 = dword_F3268[(unsigned __int8)v65]
      ^ dword_F3268[HIBYTE(v63) + 256]
      ^ v534
      ^ dword_F3268[BYTE1(v64) + 512]
      ^ dword_F3268[BYTE2(v62) + 768];
  v69 = v611 ^ v417 ^ v67;
  v430 = v417 ^ v67;
  v519 = v67;
  v70 = v589 ^ v67;
  v598 = dword_F3268[HIBYTE(v62) + 256] ^ v66 ^ v526 ^ dword_F3268[BYTE1(v65) + 512] ^ dword_F3268[BYTE2(v64) + 768];
  v71 = v598 ^ v322 ^ v491 ^ v462;
  v72 = v68 ^ v501 ^ v366;
  v604 = v68;
  v492 = v322 ^ v353;
  v418 = dword_F3268[(unsigned __int8)v72];
  v502 = v501 ^ v366;
  v453 = v376 ^ v322 ^ v353;
  v377 = v385 ^ v502;
  v535 = dword_F3268[HIBYTE(v72) + 256];
  v73 = dword_F3268[BYTE1(v72) + 512];
  v386 = v398 ^ v430;
  v399 = v509 ^ v453;
  v74 = dword_F3268[BYTE2(v72) + 768]
      ^ dword_F3268[(unsigned __int8)v70]
      ^ dword_F3268[HIBYTE(v69) + 256]
      ^ v453
      ^ dword_F3268[BYTE1(v71) + 512];
  v75 = dword_F3268[BYTE1(v70) + 512]
      ^ dword_F3268[(unsigned __int8)v69]
      ^ v535
      ^ v509
      ^ v453
      ^ dword_F3268[BYTE2(v71) + 768];
  v76 = dword_F3268[BYTE1(v69) + 512] ^ dword_F3268[HIBYTE(v71) + 256] ^ v418 ^ v386 ^ dword_F3268[BYTE2(v70) + 768];
  v77 = v73 ^ dword_F3268[(unsigned __int8)v71] ^ dword_F3268[HIBYTE(v70) + 256] ^ v377 ^ dword_F3268[BYTE2(v69) + 768];
  v510 = dword_F3268[HIBYTE(v75) + 256];
  v78 = dword_F3268[(unsigned __int8)v74];
  v79 = dword_F3268[(unsigned __int8)v75];
  v527 = dword_F3268[BYTE1(v77) + 512];
  v80 = BYTE1(v75);
  v81 = dword_F3268[HIBYTE(v77) + 256];
  v313 = v483 ^ v377;
  v409 = v582 ^ v386;
  v419 = v444 ^ v399;
  v323 = v462 ^ v483 ^ v377;
  v82 = dword_F3268[BYTE2(v75) + 768]
      ^ dword_F3268[(unsigned __int8)v77]
      ^ dword_F3268[HIBYTE(v74) + 256]
      ^ v582
      ^ v386
      ^ dword_F3268[BYTE1(v76) + 512];
  v83 = dword_F3268[BYTE2(v77) + 768] ^ dword_F3268[HIBYTE(v76) + 256] ^ v79 ^ v323 ^ dword_F3268[BYTE1(v74) + 512];
  v84 = dword_F3268[BYTE2(v74) + 768] ^ dword_F3268[(unsigned __int8)v76] ^ v81 ^ v444 ^ v399 ^ dword_F3268[v80 + 512];
  v85 = v78 ^ v510 ^ v483 ^ v377 ^ v527 ^ dword_F3268[BYTE2(v76) + 768];
  v511 = (unsigned __int8)v83;
  v484 = (char *)&dword_F3268[HIBYTE(v82)];
  v633 = (char *)&dword_F3268[HIBYTE(v353)];
  v86 = (unsigned __int8)v84;
  v627 = (char *)&dword_F3268[HIBYTE(v342)];
  v87 = (char *)&dword_F3268[HIBYTE(v84)];
  v616 = (unsigned __int8)v342;
  v620 = (unsigned __int8)v353;
  v644 = (unsigned __int8)v333;
  v88 = dword_F3268[(unsigned __int8)v85] ^ dword_F3268[HIBYTE(v83) + 256];
  v638 = (unsigned __int8)v366;
  v89 = (char *)&dword_F3268[BYTE2(v82)];
  v445 = dword_F3268[BYTE1(v82) + 512];
  v528 = dword_F3268[BYTE2(v84) + 768];
  v648 = (char *)&dword_F3268[HIBYTE(v366)];
  v90 = dword_F3268[BYTE2(v83) + 768];
  v91 = (char *)&dword_F3268[BYTE1(v83)];
  v92 = dword_F3268[BYTE1(v84) + 512];
  v536 = v90;
  v93 = dword_F3268[(unsigned __int8)v82] ^ dword_F3268[HIBYTE(v85) + 256];
  v94 = (char *)&dword_F3268[BYTE2(v85)];
  v463 = v92;
  v95 = *((_DWORD *)v87 + 256);
  v96 = dword_F3268[v86];
  v97 = v353;
  v354 = *((_DWORD *)v91 + 512);
  v98 = dword_F3268[BYTE1(v85) + 512];
  v99 = dword_F3268[v511] ^ v95;
  v100 = BYTE1(v97);
  v101 = BYTE2(v97);
  v541 = *((_DWORD *)v94 + 768);
  v102 = v88 ^ v549;
  v103 = v342;
  v583 = *((_DWORD *)v89 + 768);
  v343 = dword_F3268[BYTE2(v333) + 768];
  v652 = (char *)&dword_F3268[BYTE1(v333)];
  v104 = *((_DWORD *)v484 + 256) ^ v96;
  v105 = v366;
  v367 = dword_F3268[v101 + 768];
  v106 = *((_DWORD *)v633 + 256) ^ dword_F3268[BYTE2(v103) + 768];
  v107 = v93 ^ v561 ^ v463;
  v334 = dword_F3268[v100 + 512]
       ^ dword_F3268[HIBYTE(v333) + 256]
       ^ dword_F3268[v616]
       ^ v313
       ^ dword_F3268[BYTE2(v105) + 768];
  v108 = dword_F3268[v644] ^ dword_F3268[BYTE1(v103) + 512] ^ v367 ^ *((_DWORD *)v648 + 256);
  v368 = dword_F3268[v620] ^ *((_DWORD *)v627 + 256) ^ v409 ^ v343 ^ dword_F3268[BYTE1(v105) + 512];
  v464 = v102 ^ v445 ^ v528;
  v109 = v107 ^ v536;
  v110 = v492;
  v485 = v109;
  v111 = (unsigned __int8)v492;
  v512 = v99 ^ v574 ^ v98 ^ v583;
  v112 = (char *)&dword_F3268[HIBYTE(v492)];
  v113 = v502;
  v503 = v323 ^ v108;
  v493 = v104 ^ v566 ^ v354 ^ v541;
  v344 = v106 ^ v419 ^ dword_F3268[v638] ^ *((_DWORD *)v652 + 512);
  v114 = dword_F3268[v111] ^ dword_F3268[HIBYTE(v519) + 256];
  v562 = dword_F3268[BYTE1(v430) + 512];
  v115 = dword_F3268[HIBYTE(v430) + 256] ^ dword_F3268[BYTE1(v110) + 512] ^ dword_F3268[(unsigned __int8)v519];
  v116 = dword_F3268[(unsigned __int8)v430] ^ dword_F3268[BYTE1(v519) + 512];
  v431 = v114 ^ dword_F3268[BYTE2(v430) + 768] ^ dword_F3268[BYTE1(v113) + 512] ^ v334;
  v117 = v116 ^ dword_F3268[BYTE2(v110) + 768] ^ dword_F3268[HIBYTE(v113) + 256];
  v446 = dword_F3268[BYTE2(v519) + 768] ^ *((_DWORD *)v112 + 256) ^ dword_F3268[(unsigned __int8)v113] ^ v562 ^ v368;
  v529 = v115 ^ dword_F3268[BYTE2(v113) + 768] ^ v503;
  v520 = v344 ^ v117;
  v118 = dword_F3268[(unsigned __int8)(v493 ^ v344)]
       ^ dword_F3268[((v109 ^ (unsigned int)v368) >> 24) + 256]
       ^ v344
       ^ v117
       ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v512 ^ v503) >> 8) + 512]
       ^ dword_F3268[(unsigned __int8)((v464 ^ (unsigned int)v334) >> 16) + 768];
  v355 = dword_F3268[(unsigned __int8)(v464 ^ v334)]
       ^ dword_F3268[((v512 ^ (unsigned int)v503) >> 24) + 256]
       ^ v431
       ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v109 ^ v368) >> 8) + 512]
       ^ dword_F3268[(unsigned __int8)((v493 ^ (unsigned int)v344) >> 16) + 768];
  v119 = dword_F3268[(unsigned __int8)((v512 ^ (unsigned int)v503) >> 16) + 768]
       ^ dword_F3268[(unsigned __int8)(v109 ^ v368)]
       ^ dword_F3268[((v464 ^ (unsigned int)v334) >> 24) + 256]
       ^ v446
       ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v493 ^ v344) >> 8) + 512];
  v120 = (char *)&dword_F3268[BYTE1(v453)];
  v121 = (char *)&dword_F3268[BYTE2(v453)];
  v542 = HIBYTE(v453);
  v122 = (unsigned __int8)v453;
  v454 = dword_F3268[(unsigned __int8)((unsigned __int16)(v464 ^ v334) >> 8) + 512]
       ^ dword_F3268[(unsigned __int8)(v512 ^ v503)]
       ^ dword_F3268[((v493 ^ (unsigned int)v344) >> 24) + 256]
       ^ v529
       ^ dword_F3268[(unsigned __int8)((v109 ^ (unsigned int)v368) >> 16) + 768];
  v123 = (char *)&dword_F3268[HIBYTE(v377)];
  v617 = *((_DWORD *)v120 + 512);
  v124 = dword_F3268[HIBYTE(v399) + 256];
  v584 = (char *)&dword_F3268[BYTE1(v399)];
  v621 = dword_F3268[(unsigned __int8)v399];
  v125 = (char *)&dword_F3268[BYTE2(v399)];
  v126 = dword_F3268[(unsigned __int8)v377];
  v400 = dword_F3268[v542 + 256];
  v127 = v377;
  v378 = *((_DWORD *)v125 + 768);
  v645 = (char *)&dword_F3268[BYTE1(v127)];
  v543 = dword_F3268[HIBYTE(v454) + 256];
  v128 = dword_F3268[BYTE2(v127) + 768];
  v129 = dword_F3268[(unsigned __int8)v454];
  v130 = (char *)&dword_F3268[BYTE2(v454)];
  v131 = dword_F3268[BYTE1(v454) + 512];
  v401 = v126 ^ dword_F3268[BYTE1(v386) + 512] ^ v400 ^ v378 ^ v431;
  v455 = v124 ^ dword_F3268[v122] ^ dword_F3268[BYTE2(v386) + 768] ^ *((_DWORD *)v645 + 512) ^ v529;
  v537 = v446
       ^ *((_DWORD *)v121 + 768)
       ^ dword_F3268[(unsigned __int8)v386]
       ^ v436
       ^ *((_DWORD *)v584 + 512)
       ^ *((_DWORD *)v123 + 256);
  v132 = dword_F3268[(unsigned __int8)v355] ^ v543 ^ v401 ^ dword_F3268[BYTE1(v119) + 512];
  v544 = v520 ^ v617 ^ v621 ^ ~v471 ^ dword_F3268[HIBYTE(v386) + 256] ^ v128;
  v133 = v132 ^ dword_F3268[BYTE2(v118) + 768];
  v134 = v131
       ^ dword_F3268[HIBYTE(v119) + 256]
       ^ dword_F3268[(unsigned __int8)v118]
       ^ v544
       ^ dword_F3268[BYTE2(v355) + 768];
  v135 = dword_F3268[(unsigned __int8)v119]
       ^ dword_F3268[HIBYTE(v355) + 256]
       ^ v537
       ^ dword_F3268[BYTE1(v118) + 512]
       ^ *((_DWORD *)v130 + 768);
  v136 = dword_F3268[BYTE1(v355) + 512] ^ v129 ^ dword_F3268[HIBYTE(v118) + 256] ^ v455 ^ dword_F3268[BYTE2(v119) + 768];
  v550 = (unsigned __int8)v136;
  v634 = (char *)&dword_F3268[HIBYTE(v419)];
  v628 = (unsigned __int8)v419;
  v646 = (unsigned __int8)v313;
  v387 = dword_F3268[BYTE1(v134) + 512];
  v575 = dword_F3268[BYTE2(v134) + 768];
  v356 = dword_F3268[(unsigned __int8)v133] ^ dword_F3268[HIBYTE(v136) + 256];
  v585 = dword_F3268[BYTE2(v136) + 768];
  v137 = dword_F3268[(unsigned __int8)v134] ^ dword_F3268[HIBYTE(v135) + 256];
  v138 = (char *)&dword_F3268[BYTE1(v419)];
  v139 = (char *)&dword_F3268[BYTE2(v419)];
  v567 = dword_F3268[BYTE2(v133) + 768];
  v420 = dword_F3268[BYTE1(v136) + 512];
  v140 = (char *)&dword_F3268[BYTE1(v313)];
  v141 = v550;
  v551 = dword_F3268[BYTE1(v133) + 512];
  v142 = dword_F3268[HIBYTE(v134) + 256] ^ dword_F3268[v141];
  v143 = *((_DWORD *)v138 + 512) ^ dword_F3268[HIBYTE(v313) + 256];
  v144 = dword_F3268[BYTE2(v313) + 768];
  v314 = v356 ^ v589;
  v357 = dword_F3268[(unsigned __int8)v135] ^ dword_F3268[HIBYTE(v133) + 256] ^ v598;
  v145 = dword_F3268[HIBYTE(v409) + 256] ^ dword_F3268[v628] ^ v144 ^ dword_F3268[BYTE1(v323) + 512];
  v146 = v357 ^ v387 ^ v585;
  v147 = v137 ^ v604 ^ v420 ^ v567;
  v590 = v142 ^ v611 ^ v551 ^ dword_F3268[BYTE2(v135) + 768];
  v148 = v143 ^ dword_F3268[(unsigned __int8)v409] ^ dword_F3268[BYTE2(v323) + 768] ^ v401;
  v552 = v455
       ^ dword_F3268[v646]
       ^ dword_F3268[BYTE1(v409) + 512]
       ^ *((_DWORD *)v139 + 768)
       ^ dword_F3268[HIBYTE(v323) + 256];
  v568 = v314 ^ dword_F3268[BYTE1(v135) + 512] ^ v575;
  v149 = v146 ^ v145 ^ v537;
  v586 = v147;
  v421 = *((_DWORD *)v634 + 256)
       ^ dword_F3268[BYTE2(v409) + 768]
       ^ dword_F3268[(unsigned __int8)v323]
       ^ *((_DWORD *)v140 + 512)
       ^ v544;
  v410 = v145 ^ v537;
  v576 = v146;
  v599 = v148;
  v324 = v334 ^ v145 ^ v537;
  v345 = v344 ^ v552;
  v358 = v503 ^ v324;
  v335 = v368 ^ v421;
  v150 = dword_F3268[BYTE1(v149) + 512]
       ^ dword_F3268[(unsigned __int8)(v568 ^ v148)]
       ^ dword_F3268[((v590 ^ (unsigned int)v552) >> 24) + 256]
       ^ v324
       ^ dword_F3268[(unsigned __int8)((v147 ^ (unsigned int)v421) >> 16) + 768];
  v151 = dword_F3268[(unsigned __int8)((unsigned __int16)(v147 ^ v421) >> 8) + 512]
       ^ dword_F3268[(unsigned __int8)v149]
       ^ dword_F3268[((v568 ^ (unsigned int)v148) >> 24) + 256]
       ^ v368
       ^ v421
       ^ dword_F3268[(unsigned __int8)(BYTE2(v590) ^ BYTE2(v552)) + 768];
  v152 = dword_F3268[(unsigned __int8)((unsigned __int16)(v590 ^ v552) >> 8) + 512]
       ^ dword_F3268[HIBYTE(v149) + 256]
       ^ dword_F3268[(unsigned __int8)(v147 ^ v421)]
       ^ v345
       ^ dword_F3268[(unsigned __int8)((v568 ^ (unsigned int)v148) >> 16) + 768];
  v153 = dword_F3268[(unsigned __int8)((unsigned __int16)(v568 ^ v148) >> 8) + 512]
       ^ dword_F3268[((v147 ^ (unsigned int)v421) >> 24) + 256]
       ^ dword_F3268[(unsigned __int8)(v590 ^ v552)]
       ^ v503
       ^ v324
       ^ dword_F3268[BYTE2(v149) + 768];
  v622 = (v368 ^ (unsigned int)v421) >> 24;
  v315 = v431 ^ v368 ^ v421;
  v369 = v446 ^ v345;
  v379 = v520 ^ v503 ^ v324;
  v388 = v529 ^ v315;
  v154 = dword_F3268[BYTE1(v150) + 512]
       ^ dword_F3268[(unsigned __int8)v153]
       ^ dword_F3268[HIBYTE(v152) + 256]
       ^ v529
       ^ v315
       ^ dword_F3268[BYTE2(v151) + 768];
  v155 = dword_F3268[BYTE1(v152) + 512]
       ^ dword_F3268[HIBYTE(v150) + 256]
       ^ dword_F3268[(unsigned __int8)v151]
       ^ v446
       ^ v345
       ^ dword_F3268[BYTE2(v153) + 768];
  v156 = dword_F3268[(unsigned __int8)v150]
       ^ dword_F3268[HIBYTE(v153) + 256]
       ^ v315
       ^ dword_F3268[BYTE1(v151) + 512]
       ^ dword_F3268[BYTE2(v152) + 768];
  v157 = dword_F3268[(unsigned __int8)v152]
       ^ dword_F3268[HIBYTE(v151) + 256]
       ^ v379
       ^ dword_F3268[BYTE1(v153) + 512]
       ^ dword_F3268[BYTE2(v150) + 768];
  v158 = dword_F3268[BYTE1(v155) + 512];
  v159 = dword_F3268[BYTE2(v157) + 768];
  v160 = dword_F3268[(unsigned __int8)v156] ^ dword_F3268[HIBYTE(v154) + 256];
  v521 = v401 ^ v446 ^ v345;
  v612 = dword_F3268[(unsigned __int8)v155]
       ^ dword_F3268[HIBYTE(v156) + 256]
       ^ v485
       ^ dword_F3268[BYTE1(v157) + 512]
       ^ dword_F3268[BYTE2(v154) + 768];
  v486 = v455 ^ v521;
  v161 = dword_F3268[(unsigned __int8)v154]
       ^ dword_F3268[HIBYTE(v157) + 256]
       ^ v512
       ^ dword_F3268[BYTE1(v156) + 512]
       ^ dword_F3268[BYTE2(v155) + 768];
  v614 = dword_F3268[(unsigned __int8)v157]
       ^ dword_F3268[HIBYTE(v155) + 256]
       ^ v493
       ^ dword_F3268[BYTE1(v154) + 512]
       ^ dword_F3268[BYTE2(v156) + 768];
  v162 = v160 ^ v464 ^ v158 ^ v159 ^ v521;
  v605 = v160 ^ v464 ^ v158 ^ v159;
  v163 = v614 ^ v544 ^ v529 ^ v315;
  v164 = v612 ^ v537 ^ v379;
  v465 = v544 ^ v529 ^ v315;
  v618 = v161;
  v494 = dword_F3268[BYTE1(v164) + 512];
  v165 = dword_F3268[BYTE1(v163) + 512];
  v504 = dword_F3268[BYTE2(v163) + 768];
  v402 = v599 ^ v537 ^ v379;
  v432 = v552 ^ v402;
  v166 = dword_F3268[BYTE2(v164) + 768];
  v411 = v410 ^ v465;
  v513 = dword_F3268[BYTE2(v162) + 768];
  v167 = dword_F3268[(unsigned __int8)v164] ^ dword_F3268[HIBYTE(v162) + 256] ^ v411;
  v168 = dword_F3268[HIBYTE(v164) + 256] ^ dword_F3268[(unsigned __int8)v163] ^ v421 ^ v455 ^ v521;
  v169 = dword_F3268[(unsigned __int8)(v161 ^ v455 ^ v521)]
       ^ dword_F3268[HIBYTE(v163) + 256]
       ^ v552
       ^ v402
       ^ dword_F3268[BYTE1(v162) + 512]
       ^ v166;
  v170 = v167 ^ v165 ^ dword_F3268[(unsigned __int8)(BYTE2(v161) ^ ((v455 ^ v521) >> 16)) + 768];
  v422 = v421 ^ v455 ^ v521;
  v495 = dword_F3268[(unsigned __int8)v162] ^ dword_F3268[((v161 ^ v455 ^ v521) >> 24) + 256] ^ v402 ^ v494 ^ v504;
  v171 = (char *)&dword_F3268[v622];
  v172 = v168 ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v161 ^ v455 ^ v521) >> 8) + 512] ^ v513;
  v639 = (char *)&dword_F3268[BYTE1(v335)];
  v545 = dword_F3268[BYTE1(v170) + 512];
  v623 = dword_F3268[BYTE1(v172) + 512];
  v553 = dword_F3268[(unsigned __int8)v170];
  v173 = dword_F3268[HIBYTE(v170) + 256];
  v174 = dword_F3268[BYTE2(v345) + 768] ^ dword_F3268[HIBYTE(v358) + 256] ^ dword_F3268[(unsigned __int8)v324];
  v530 = dword_F3268[(unsigned __int8)v172];
  v175 = *((_DWORD *)v171 + 256) ^ dword_F3268[BYTE2(v324) + 768] ^ dword_F3268[(unsigned __int8)v345];
  v176 = dword_F3268[(unsigned __int8)v335] ^ dword_F3268[BYTE1(v345) + 512] ^ dword_F3268[HIBYTE(v324) + 256] ^ v402;
  v336 = dword_F3268[(unsigned __int8)v358]
       ^ dword_F3268[BYTE1(v324) + 512]
       ^ dword_F3268[HIBYTE(v345) + 256]
       ^ v422
       ^ dword_F3268[BYTE2(v335) + 768];
  v325 = v176 ^ dword_F3268[BYTE2(v358) + 768];
  v447 = v175 ^ dword_F3268[BYTE1(v358) + 512] ^ v411;
  v346 = v174 ^ *((_DWORD *)v639 + 512) ^ v432;
  v177 = dword_F3268[BYTE1(v495) + 512]
       ^ dword_F3268[(unsigned __int8)v169]
       ^ dword_F3268[HIBYTE(v172) + 256]
       ^ v346
       ^ dword_F3268[BYTE2(v170) + 768];
  v178 = dword_F3268[(unsigned __int8)v495]
       ^ dword_F3268[HIBYTE(v169) + 256]
       ^ v325
       ^ v545
       ^ dword_F3268[BYTE2(v172) + 768];
  v179 = v553 ^ dword_F3268[HIBYTE(v495) + 256] ^ v447 ^ v623 ^ dword_F3268[BYTE2(v169) + 768];
  v180 = dword_F3268[BYTE1(v169) + 512] ^ v173 ^ v530 ^ v336 ^ dword_F3268[BYTE2(v495) + 768];
  v181 = dword_F3268[HIBYTE(v177) + 256];
  v649 = (unsigned __int8)v388;
  v653 = (char *)&dword_F3268[HIBYTE(v388)];
  v514 = dword_F3268[(unsigned __int8)v180];
  v182 = dword_F3268[HIBYTE(v178) + 256] ^ dword_F3268[(unsigned __int8)v179];
  v183 = dword_F3268[BYTE2(v180) + 768];
  v505 = dword_F3268[BYTE1(v179) + 512];
  v496 = dword_F3268[BYTE1(v180) + 512];
  v531 = dword_F3268[BYTE1(v177) + 512];
  v554 = dword_F3268[BYTE2(v177) + 768];
  v184 = dword_F3268[HIBYTE(v180) + 256] ^ dword_F3268[(unsigned __int8)v177];
  v185 = dword_F3268[BYTE1(v178) + 512];
  v186 = dword_F3268[(unsigned __int8)v178] ^ v181 ^ v568;
  v600 = dword_F3268[BYTE2(v179) + 768];
  v187 = v388;
  v389 = dword_F3268[HIBYTE(v179) + 256];
  v569 = dword_F3268[BYTE2(v178) + 768];
  v188 = dword_F3268[(unsigned __int8)v379] ^ dword_F3268[HIBYTE(v369) + 256] ^ dword_F3268[BYTE2(v315) + 768];
  v189 = dword_F3268[BYTE1(v369) + 512]
       ^ dword_F3268[(unsigned __int8)v315]
       ^ ~v471
       ^ dword_F3268[BYTE2(v379) + 768]
       ^ *((_DWORD *)v653 + 256);
  v190 = v182 ^ v576 ^ v496 ^ v554;
  v497 = v186 ^ v505 ^ v183;
  v191 = v514 ^ v389 ^ v586;
  v506 = v190;
  v192 = dword_F3268[HIBYTE(v379) + 256]
       ^ dword_F3268[BYTE2(v369) + 768]
       ^ v436
       ^ dword_F3268[v649]
       ^ dword_F3268[BYTE1(v315) + 512];
  v515 = v184 ^ v590 ^ v185 ^ v600;
  v456 = v191 ^ v531 ^ v569;
  v193 = v521;
  v316 = dword_F3268[HIBYTE(v315) + 256]
       ^ dword_F3268[(unsigned __int8)v369]
       ^ dword_F3268[BYTE1(v379) + 512]
       ^ dword_F3268[BYTE2(v187) + 768]
       ^ v325;
  v370 = v188 ^ dword_F3268[BYTE1(v187) + 512] ^ v447;
  v194 = v486;
  v195 = HIBYTE(v521);
  v522 = (char *)&dword_F3268[(v537 ^ v379) >> 24];
  v196 = HIBYTE(v486);
  v487 = v346 ^ v189;
  v591 = (v515 ^ v346 ^ (unsigned int)v189) >> 24;
  LOWORD(v183) = v194;
  v197 = BYTE2(v194);
  v198 = v465;
  v390 = (unsigned __int8)(v537 ^ v379);
  v359 = v515 ^ v346 ^ v189;
  BYTE2(v186) = (v537 ^ v379) >> 16;
  v577 = (char *)&dword_F3268[(unsigned __int8)((unsigned __int16)(v537 ^ v379) >> 8)];
  v199 = HIBYTE(v465);
  v466 = (char *)&dword_F3268[v197];
  v380 = v336 ^ v192;
  v200 = v456 ^ v336 ^ v192;
  v635 = (char *)&dword_F3268[BYTE2(v198)];
  v437 = dword_F3268[BYTE1(v193) + 512];
  v201 = *((_DWORD *)v522 + 256)
       ^ dword_F3268[BYTE2(v193) + 768]
       ^ dword_F3268[(unsigned __int8)v198]
       ^ dword_F3268[BYTE1(v183) + 512];
  v202 = dword_F3268[v195 + 256] ^ dword_F3268[v390] ^ *((_DWORD *)v466 + 768);
  v391 = dword_F3268[BYTE2(v186) + 768];
  v203 = dword_F3268[(unsigned __int8)v193] ^ dword_F3268[v196 + 256] ^ *((_DWORD *)v577 + 512);
  v204 = dword_F3268[(unsigned __int8)v359] ^ dword_F3268[HIBYTE(v200) + 256];
  v467 = v202 ^ dword_F3268[BYTE1(v198) + 512] ^ v316;
  v205 = dword_F3268[BYTE1(v359) + 512];
  v523 = v201 ^ v370;
  v206 = dword_F3268[BYTE2(v359) + 768];
  v360 = v203 ^ *((_DWORD *)v635 + 768) ^ v487;
  v532 = v336 ^ v192 ^ dword_F3268[(unsigned __int8)v183] ^ v437 ^ v391 ^ dword_F3268[v199 + 256];
  v207 = dword_F3268[(unsigned __int8)(v190 ^ v370)]
       ^ dword_F3268[((v497 ^ (unsigned int)v316) >> 24) + 256]
       ^ v523
       ^ dword_F3268[BYTE1(v200) + 512]
       ^ v206;
  v208 = dword_F3268[(unsigned __int8)v200]
       ^ dword_F3268[((v190 ^ (unsigned int)v370) >> 24) + 256]
       ^ v532
       ^ v205
       ^ dword_F3268[(unsigned __int8)((v497 ^ (unsigned int)v316) >> 16) + 768];
  v209 = v204 ^ v360 ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v497 ^ v316) >> 8) + 512];
  v210 = dword_F3268[(unsigned __int8)(v497 ^ v316)]
       ^ dword_F3268[v591 + 256]
       ^ v467
       ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v190 ^ v370) >> 8) + 512]
       ^ dword_F3268[BYTE2(v200) + 768];
  v438 = v209 ^ dword_F3268[(unsigned __int8)((v190 ^ (unsigned int)v370) >> 16) + 768];
  v636 = (char *)&dword_F3268[BYTE1(v411)];
  v211 = dword_F3268[HIBYTE(v411) + 256] ^ dword_F3268[BYTE2(v402) + 768];
  v578 = dword_F3268[(unsigned __int8)v207];
  v570 = dword_F3268[BYTE1(v207) + 512];
  v212 = BYTE2(v207);
  v213 = dword_F3268[(unsigned __int8)v432]
       ^ dword_F3268[BYTE1(v402) + 512]
       ^ dword_F3268[HIBYTE(v422) + 256]
       ^ dword_F3268[BYTE2(v411) + 768];
  v412 = dword_F3268[(unsigned __int8)v411]
       ^ dword_F3268[BYTE1(v422) + 512]
       ^ dword_F3268[HIBYTE(v402) + 256]
       ^ dword_F3268[BYTE2(v432) + 768]
       ^ v467;
  v392 = dword_F3268[HIBYTE(v432) + 256]
       ^ dword_F3268[BYTE2(v422) + 768]
       ^ dword_F3268[(unsigned __int8)v402]
       ^ *((_DWORD *)v636 + 512)
       ^ v360;
  v546 = v213 ^ v532;
  v214 = dword_F3268[HIBYTE(v207) + 256]
       ^ dword_F3268[(unsigned __int8)v208]
       ^ v213
       ^ v532
       ^ dword_F3268[BYTE1(v438) + 512];
  v538 = v211 ^ dword_F3268[(unsigned __int8)v422] ^ dword_F3268[BYTE1(v432) + 512] ^ v523;
  v215 = dword_F3268[BYTE2(v208) + 768]
       ^ dword_F3268[(unsigned __int8)v210]
       ^ dword_F3268[HIBYTE(v438) + 256]
       ^ v412
       ^ v570;
  v216 = v578 ^ dword_F3268[HIBYTE(v210) + 256] ^ v538 ^ dword_F3268[BYTE1(v208) + 512] ^ dword_F3268[BYTE2(v438) + 768];
  v217 = dword_F3268[(unsigned __int8)v438]
       ^ dword_F3268[HIBYTE(v208) + 256]
       ^ v392
       ^ dword_F3268[BYTE1(v210) + 512]
       ^ dword_F3268[v212 + 768];
  v218 = v214 ^ dword_F3268[BYTE2(v210) + 768];
  v219 = dword_F3268[HIBYTE(v217) + 256];
  v403 = dword_F3268[(unsigned __int8)v215];
  v220 = dword_F3268[(unsigned __int8)v218]
       ^ dword_F3268[HIBYTE(v216) + 256]
       ^ v614
       ^ dword_F3268[BYTE1(v217) + 512]
       ^ dword_F3268[BYTE2(v215) + 768];
  v571 = dword_F3268[(unsigned __int8)v216]
       ^ dword_F3268[HIBYTE(v215) + 256]
       ^ v612
       ^ dword_F3268[BYTE1(v218) + 512]
       ^ dword_F3268[BYTE2(v217) + 768];
  v221 = dword_F3268[(unsigned __int8)v217]
       ^ dword_F3268[HIBYTE(v218) + 256]
       ^ v618
       ^ dword_F3268[BYTE1(v215) + 512]
       ^ dword_F3268[BYTE2(v216) + 768];
  v222 = v221 ^ v346 ^ v325 ^ v538;
  v555 = v325 ^ v538;
  v223 = v571 ^ v447 ^ v546;
  v439 = v346 ^ v325 ^ v538;
  v224 = v403 ^ v219 ^ v605 ^ dword_F3268[BYTE1(v216) + 512] ^ dword_F3268[BYTE2(v218) + 768];
  v225 = v224 ^ v325 ^ v538;
  v579 = v220;
  v226 = v220 ^ v336 ^ v392;
  v404 = v447 ^ v546;
  v587 = v221;
  v423 = v336 ^ v392;
  v227 = HIBYTE(v226);
  v563 = v224;
  v592 = dword_F3268[BYTE2(v226) + 768];
  v228 = dword_F3268[BYTE1(v226) + 512];
  v229 = dword_F3268[(unsigned __int8)v226];
  v230 = v447 ^ v546;
  v448 = dword_F3268[BYTE1(v223) + 512];
  v317 = v316 ^ v230;
  v433 = v380 ^ v439;
  v337 = v487 ^ v317;
  v231 = v228
       ^ dword_F3268[HIBYTE(v225) + 256]
       ^ dword_F3268[(unsigned __int8)v223]
       ^ v370
       ^ v423
       ^ dword_F3268[BYTE2(v222) + 768];
  v326 = v370 ^ v423;
  v232 = dword_F3268[HIBYTE(v223) + 256]
       ^ v229
       ^ v380
       ^ v439
       ^ dword_F3268[BYTE1(v222) + 512]
       ^ dword_F3268[BYTE2(v225) + 768];
  v233 = dword_F3268[BYTE2(v223) + 768]
       ^ dword_F3268[v227 + 256]
       ^ dword_F3268[(unsigned __int8)v222]
       ^ v487
       ^ v317
       ^ dword_F3268[BYTE1(v225) + 512];
  v234 = dword_F3268[(unsigned __int8)v225] ^ dword_F3268[HIBYTE(v222) + 256] ^ v317 ^ v448 ^ v592;
  v347 = v467 ^ v370 ^ v423;
  v371 = v532 ^ v487 ^ v317;
  v235 = v380 ^ v439;
  v381 = v360 ^ v347;
  v361 = v523 ^ v235;
  v236 = dword_F3268[BYTE2(v231) + 768]
       ^ dword_F3268[(unsigned __int8)v233]
       ^ dword_F3268[HIBYTE(v232) + 256]
       ^ v381
       ^ dword_F3268[BYTE1(v234) + 512];
  v237 = dword_F3268[BYTE2(v232) + 768]
       ^ dword_F3268[(unsigned __int8)v234]
       ^ dword_F3268[HIBYTE(v233) + 256]
       ^ v347
       ^ dword_F3268[BYTE1(v231) + 512];
  v238 = dword_F3268[(unsigned __int8)v231]
       ^ dword_F3268[HIBYTE(v234) + 256]
       ^ v523
       ^ v235
       ^ dword_F3268[BYTE1(v232) + 512]
       ^ dword_F3268[BYTE2(v233) + 768];
  v239 = dword_F3268[BYTE1(v233) + 512]
       ^ dword_F3268[(unsigned __int8)v232]
       ^ dword_F3268[HIBYTE(v231) + 256]
       ^ v371
       ^ dword_F3268[BYTE2(v234) + 768];
  v524 = dword_F3268[HIBYTE(v236) + 256]
       ^ dword_F3268[(unsigned __int8)v237]
       ^ v497
       ^ dword_F3268[BYTE1(v238) + 512]
       ^ dword_F3268[BYTE2(v239) + 768];
  v240 = v392 ^ v412 ^ v361;
  v449 = v412 ^ v361;
  v241 = dword_F3268[HIBYTE(v237) + 256]
       ^ dword_F3268[(unsigned __int8)v238]
       ^ v506
       ^ dword_F3268[BYTE1(v239) + 512]
       ^ dword_F3268[BYTE2(v236) + 768]
       ^ v538
       ^ v371;
  v457 = dword_F3268[(unsigned __int8)v239]
       ^ dword_F3268[HIBYTE(v238) + 256]
       ^ v456
       ^ dword_F3268[BYTE1(v236) + 512]
       ^ dword_F3268[BYTE2(v237) + 768];
  v533 = dword_F3268[HIBYTE(v237) + 256]
       ^ dword_F3268[(unsigned __int8)v238]
       ^ v506
       ^ dword_F3268[BYTE1(v239) + 512]
       ^ dword_F3268[BYTE2(v236) + 768];
  v242 = dword_F3268[HIBYTE(v239) + 256]
       ^ dword_F3268[(unsigned __int8)v236]
       ^ v515
       ^ dword_F3268[BYTE1(v237) + 512]
       ^ dword_F3268[BYTE2(v238) + 768]
       ^ v240;
  v393 = v538 ^ v371;
  v539 = dword_F3268[HIBYTE(v239) + 256]
       ^ dword_F3268[(unsigned __int8)v236]
       ^ v515
       ^ dword_F3268[BYTE1(v237) + 512]
       ^ dword_F3268[BYTE2(v238) + 768];
  v243 = v524 ^ v412 ^ v361;
  v413 = v240;
  BYTE1(v234) = BYTE1(v404);
  v516 = (char *)&dword_F3268[HIBYTE(v404)];
  v244 = (unsigned __int8)v404;
  v245 = BYTE2(v404);
  v405 = v546 ^ v381;
  v246 = v457 ^ v546 ^ v381;
  v593 = (char *)&dword_F3268[v245];
  v640 = (char *)&dword_F3268[BYTE2(v423)];
  v247 = dword_F3268[(unsigned __int8)v555] ^ dword_F3268[HIBYTE(v439) + 256];
  v606 = dword_F3268[HIBYTE(v243) + 256];
  v248 = dword_F3268[(unsigned __int8)v439] ^ dword_F3268[BYTE1(v555) + 512] ^ dword_F3268[HIBYTE(v423) + 256];
  v249 = dword_F3268[BYTE1(v243) + 512];
  v468 = dword_F3268[v244]
       ^ dword_F3268[HIBYTE(v555) + 256]
       ^ v449
       ^ dword_F3268[BYTE1(v423) + 512]
       ^ dword_F3268[BYTE2(v439) + 768];
  v424 = dword_F3268[(unsigned __int8)v423]
       ^ dword_F3268[BYTE2(v555) + 768]
       ^ *((_DWORD *)v516 + 256)
       ^ dword_F3268[BYTE1(v439) + 512]
       ^ v393;
  v440 = v248 ^ *((_DWORD *)v593 + 768) ^ v546 ^ v381;
  v488 = v247 ^ dword_F3268[BYTE1(v234) + 512] ^ *((_DWORD *)v640 + 768) ^ v413;
  v250 = dword_F3268[BYTE1(v242) + 512]
       ^ dword_F3268[HIBYTE(v241) + 256]
       ^ dword_F3268[(unsigned __int8)v246]
       ^ v440
       ^ dword_F3268[BYTE2(v243) + 768];
  v251 = dword_F3268[(unsigned __int8)v243]
       ^ dword_F3268[HIBYTE(v242) + 256]
       ^ v468
       ^ dword_F3268[BYTE1(v241) + 512]
       ^ dword_F3268[BYTE2(v246) + 768];
  v556 = (char *)&dword_F3268[BYTE1(v317)];
  v252 = dword_F3268[BYTE2(v242) + 768]
       ^ dword_F3268[(unsigned __int8)v241]
       ^ v606
       ^ v424
       ^ dword_F3268[BYTE1(v246) + 512];
  v253 = v249
       ^ dword_F3268[(unsigned __int8)v242]
       ^ dword_F3268[HIBYTE(v246) + 256]
       ^ v488
       ^ dword_F3268[BYTE2(v241) + 768];
  v607 = (unsigned __int8)v317;
  v498 = (char *)&dword_F3268[BYTE2(v317)];
  BYTE1(v246) = BYTE1(v337);
  v254 = dword_F3268[BYTE1(v326) + 512];
  v255 = dword_F3268[(unsigned __int8)v433] ^ dword_F3268[HIBYTE(v326) + 256];
  v629 = dword_F3268[(unsigned __int8)v250];
  v318 = dword_F3268[BYTE1(v433) + 512]
       ^ dword_F3268[HIBYTE(v317) + 256]
       ^ dword_F3268[(unsigned __int8)v326]
       ^ dword_F3268[BYTE2(v337) + 768]
       ^ v468;
  v327 = dword_F3268[(unsigned __int8)v337]
       ^ *((_DWORD *)v556 + 512)
       ^ dword_F3268[HIBYTE(v433) + 256]
       ^ dword_F3268[BYTE2(v326) + 768]
       ^ v440;
  v338 = v488 ^ v254 ^ dword_F3268[BYTE2(v433) + 768] ^ dword_F3268[v607] ^ dword_F3268[HIBYTE(v337) + 256];
  v434 = v255 ^ *((_DWORD *)v498 + 768) ^ dword_F3268[BYTE1(v246) + 512] ^ v424;
  v256 = dword_F3268[(unsigned __int8)v251]
       ^ dword_F3268[HIBYTE(v253) + 256]
       ^ v318
       ^ dword_F3268[BYTE1(v252) + 512]
       ^ dword_F3268[BYTE2(v250) + 768];
  v257 = dword_F3268[BYTE1(v251) + 512]
       ^ dword_F3268[(unsigned __int8)v253]
       ^ dword_F3268[HIBYTE(v250) + 256]
       ^ v338
       ^ dword_F3268[BYTE2(v252) + 768];
  v258 = dword_F3268[(unsigned __int8)v252]
       ^ dword_F3268[HIBYTE(v251) + 256]
       ^ v434
       ^ dword_F3268[BYTE1(v250) + 512]
       ^ dword_F3268[BYTE2(v253) + 768];
  v259 = dword_F3268[BYTE1(v253) + 512] ^ dword_F3268[HIBYTE(v252) + 256] ^ v629 ^ v327 ^ dword_F3268[BYTE2(v251) + 768];
  v624 = (unsigned __int8)v371;
  v594 = dword_F3268[BYTE2(v259) + 768];
  v641 = (char *)&dword_F3268[HIBYTE(v371)];
  v260 = dword_F3268[BYTE1(v259) + 512];
  v261 = dword_F3268[HIBYTE(v259) + 256];
  v262 = (unsigned __int8)v259;
  v263 = (char *)&dword_F3268[BYTE2(v371)];
  v264 = (char *)&dword_F3268[BYTE1(v371)];
  v372 = dword_F3268[v262];
  v608 = dword_F3268[BYTE2(v256) + 768];
  v265 = dword_F3268[BYTE1(v361) + 512]
       ^ dword_F3268[HIBYTE(v381) + 256]
       ^ dword_F3268[(unsigned __int8)v347]
       ^ *((_DWORD *)v263 + 768);
  v266 = dword_F3268[BYTE1(v347) + 512]
       ^ dword_F3268[(unsigned __int8)v381]
       ^ dword_F3268[BYTE2(v361) + 768]
       ^ *((_DWORD *)v641 + 256);
  v547 = dword_F3268[(unsigned __int8)v256]
       ^ dword_F3268[HIBYTE(v257) + 256]
       ^ v563
       ^ dword_F3268[BYTE1(v258) + 512]
       ^ v594;
  v557 = dword_F3268[(unsigned __int8)v258]
       ^ dword_F3268[HIBYTE(v256) + 256]
       ^ v571
       ^ v260
       ^ dword_F3268[BYTE2(v257) + 768];
  v267 = dword_F3268[(unsigned __int8)v257]
       ^ v261
       ^ v587
       ^ dword_F3268[BYTE1(v256) + 512]
       ^ dword_F3268[BYTE2(v258) + 768]
       ^ v265
       ^ v338;
  v564 = dword_F3268[(unsigned __int8)v257]
       ^ v261
       ^ v587
       ^ dword_F3268[BYTE1(v256) + 512]
       ^ dword_F3268[BYTE2(v258) + 768];
  v499 = dword_F3268[(unsigned __int8)v361]
       ^ dword_F3268[HIBYTE(v347) + 256]
       ^ *((_DWORD *)v264 + 512)
       ^ dword_F3268[BYTE2(v381) + 768]
       ^ v318;
  v268 = dword_F3268[v624]
       ^ dword_F3268[BYTE2(v347) + 768]
       ^ dword_F3268[HIBYTE(v361) + 256]
       ^ dword_F3268[BYTE1(v381) + 512]
       ^ v434;
  v382 = dword_F3268[HIBYTE(v258) + 256] ^ v372 ^ v579 ^ dword_F3268[BYTE1(v257) + 512] ^ v608;
  v517 = v265 ^ v338;
  BYTE1(v263) = BYTE1(v557) ^ BYTE1(v268);
  v507 = v268;
  v348 = v327 ^ v266;
  v613 = (char *)&dword_F3268[(v557 ^ (unsigned int)v268) >> 24];
  v588 = (unsigned __int8)(v557 ^ v268);
  BYTE1(v258) = BYTE1(v393);
  v373 = dword_F3268[HIBYTE(v405) + 256]
       ^ dword_F3268[BYTE1(v449) + 512]
       ^ dword_F3268[(unsigned __int8)v413]
       ^ dword_F3268[BYTE2(v393) + 768]
       ^ v327
       ^ v266;
  v362 = dword_F3268[BYTE2(v449) + 768]
       ^ dword_F3268[(unsigned __int8)v405]
       ^ dword_F3268[HIBYTE(v393) + 256]
       ^ dword_F3268[BYTE1(v413) + 512]
       ^ v268;
  v394 = v499
       ^ v471
       ^ dword_F3268[HIBYTE(v449) + 256]
       ^ dword_F3268[(unsigned __int8)v393]
       ^ dword_F3268[BYTE1(v405) + 512]
       ^ dword_F3268[BYTE2(v413) + 768];
  v406 = v265
       ^ v338
       ^ v559
       ^ dword_F3268[(unsigned __int8)v449]
       ^ dword_F3268[HIBYTE(v413) + 256]
       ^ dword_F3268[BYTE1(v258) + 512]
       ^ dword_F3268[BYTE2(v405) + 768];
  v269 = dword_F3268[(unsigned __int8)v267]
       ^ dword_F3268[((v382 ^ v327 ^ (unsigned int)v266) >> 24) + 256]
       ^ v406
       ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v547 ^ v499) >> 8) + 512]
       ^ dword_F3268[(unsigned __int8)((v557 ^ (unsigned int)v268) >> 16) + 768];
  v270 = dword_F3268[v588]
       ^ dword_F3268[((v547 ^ (unsigned int)v499) >> 24) + 256]
       ^ v362
       ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v382 ^ v327 ^ v266) >> 8) + 512]
       ^ dword_F3268[BYTE2(v267) + 768];
  v271 = dword_F3268[(unsigned __int8)(v382 ^ v327 ^ v266)]
       ^ *((_DWORD *)v613 + 256)
       ^ v373
       ^ dword_F3268[BYTE1(v267) + 512]
       ^ dword_F3268[(unsigned __int8)((v547 ^ (unsigned int)v499) >> 16) + 768];
  v272 = dword_F3268[(unsigned __int8)(v547 ^ v499)]
       ^ dword_F3268[HIBYTE(v267) + 256]
       ^ v394
       ^ dword_F3268[BYTE1(v263) + 512]
       ^ dword_F3268[(unsigned __int8)((v382 ^ v327 ^ (unsigned int)v266) >> 16) + 768];
  v572 = dword_F3268[(unsigned __int8)v271];
  v273 = dword_F3268[BYTE1(v271) + 512];
  v274 = dword_F3268[HIBYTE(v271) + 256];
  v275 = v468 ^ v362;
  v469 = dword_F3268[BYTE1(v272) + 512];
  v414 = v424 ^ v373;
  v450 = v488 ^ v275;
  v425 = v440 ^ v406;
  v276 = dword_F3268[BYTE2(v271) + 768]
       ^ dword_F3268[(unsigned __int8)v272]
       ^ dword_F3268[HIBYTE(v269) + 256]
       ^ v275
       ^ dword_F3268[BYTE1(v270) + 512];
  v277 = dword_F3268[BYTE2(v269) + 768]
       ^ dword_F3268[(unsigned __int8)v270]
       ^ dword_F3268[HIBYTE(v272) + 256]
       ^ v414
       ^ v273;
  v278 = dword_F3268[BYTE2(v272) + 768]
       ^ v572
       ^ dword_F3268[HIBYTE(v270) + 256]
       ^ v440
       ^ v406
       ^ dword_F3268[BYTE1(v269) + 512];
  v279 = v469 ^ v274 ^ dword_F3268[(unsigned __int8)v269] ^ v488 ^ v275 ^ dword_F3268[BYTE2(v270) + 768];
  v472 = dword_F3268[HIBYTE(v276) + 256];
  v489 = dword_F3268[BYTE1(v278) + 512];
  v280 = v318 ^ v414;
  v281 = dword_F3268[(unsigned __int8)v276] ^ dword_F3268[HIBYTE(v279) + 256] ^ v524;
  v282 = v434;
  v283 = v327;
  v328 = v338 ^ v318 ^ v414;
  v441 = dword_F3268[HIBYTE(v278) + 256]
       ^ dword_F3268[(unsigned __int8)v279]
       ^ v539
       ^ dword_F3268[BYTE1(v276) + 512]
       ^ dword_F3268[BYTE2(v277) + 768];
  v319 = v283 ^ v450;
  v435 = dword_F3268[(unsigned __int8)v278]
       ^ dword_F3268[HIBYTE(v277) + 256]
       ^ v457
       ^ dword_F3268[BYTE1(v279) + 512]
       ^ dword_F3268[BYTE2(v276) + 768];
  v284 = v282 ^ v425;
  v285 = v281 ^ dword_F3268[BYTE1(v277) + 512] ^ dword_F3268[BYTE2(v278) + 768];
  v286 = dword_F3268[(unsigned __int8)v277] ^ v472 ^ v533 ^ v489 ^ dword_F3268[BYTE2(v279) + 768];
  v287 = v280 ^ v285;
  v288 = v441 ^ v328;
  v415 = v285;
  v426 = v286;
  v289 = v286 ^ v284;
  v290 = (unsigned __int8)(v286 ^ v284);
  v525 = dword_F3268[((v435 ^ (unsigned int)v319) >> 24) + 256];
  v470 = dword_F3268[((v286 ^ (unsigned int)v284) >> 24) + 256];
  v291 = dword_F3268[(unsigned __int8)(v435 ^ v319)];
  v292 = v284 ^ v499;
  v490 = dword_F3268[(unsigned __int8)(v441 ^ v328)];
  v339 = v517 ^ v292;
  v293 = dword_F3268[(unsigned __int8)v287] ^ dword_F3268[((v441 ^ (unsigned int)v328) >> 24) + 256] ^ v292;
  v294 = dword_F3268[(unsigned __int8)((unsigned __int16)(v435 ^ v319) >> 8) + 512];
  v329 = v348 ^ v328;
  v295 = dword_F3268[BYTE1(v289) + 512] ^ v293 ^ dword_F3268[(unsigned __int8)((v435 ^ (unsigned int)v319) >> 16) + 768];
  v320 = v507 ^ v319;
  v296 = dword_F3268[BYTE1(v287) + 512] ^ v490 ^ v525 ^ v517 ^ v292 ^ dword_F3268[BYTE2(v289) + 768];
  v297 = v291 ^ v470 ^ v329 ^ dword_F3268[BYTE1(v288) + 512] ^ dword_F3268[BYTE2(v287) + 768];
  v298 = dword_F3268[v290] ^ dword_F3268[HIBYTE(v287) + 256] ^ v320 ^ v294 ^ dword_F3268[BYTE2(v288) + 768];
  v349 = dword_F3268[HIBYTE(v296) + 256];
  v299 = dword_F3268[(unsigned __int8)v296];
  v300 = dword_F3268[BYTE1(v296) + 512]
       ^ v373
       ^ v339
       ^ dword_F3268[(unsigned __int8)v297]
       ^ dword_F3268[HIBYTE(v298) + 256]
       ^ dword_F3268[BYTE2(v295) + 768];
  v301 = dword_F3268[BYTE2(v296) + 768]
       ^ v362
       ^ v329
       ^ dword_F3268[(unsigned __int8)v298]
       ^ dword_F3268[HIBYTE(v295) + 256]
       ^ dword_F3268[BYTE1(v297) + 512];
  v302 = dword_F3268[BYTE1(v295) + 512]
       ^ v406
       ^ v394
       ^ v320
       ^ v299
       ^ dword_F3268[HIBYTE(v297) + 256]
       ^ dword_F3268[BYTE2(v298) + 768];
  v303 = dword_F3268[(unsigned __int8)v295]
       ^ v349
       ^ v394
       ^ v320
       ^ dword_F3268[BYTE1(v298) + 512]
       ^ dword_F3268[BYTE2(v297) + 768];
  v304 = v478
       ^ v557
       ^ dword_F3268[(unsigned __int8)v301]
       ^ dword_F3268[HIBYTE(v303) + 256]
       ^ dword_F3268[BYTE1(v300) + 512]
       ^ dword_F3268[BYTE2(v302) + 768];
  result = v479
         ^ v382
         ^ dword_F3268[(unsigned __int8)v300]
         ^ dword_F3268[HIBYTE(v301) + 256]
         ^ dword_F3268[BYTE1(v302) + 512]
         ^ dword_F3268[BYTE2(v303) + 768];
  v306 = v477
       ^ v547
       ^ dword_F3268[(unsigned __int8)v303]
       ^ dword_F3268[HIBYTE(v302) + 256]
       ^ dword_F3268[BYTE1(v301) + 512]
       ^ dword_F3268[BYTE2(v300) + 768];
  v307 = v442
       ^ v564
       ^ dword_F3268[(unsigned __int8)v302]
       ^ dword_F3268[HIBYTE(v300) + 256]
       ^ dword_F3268[BYTE1(v303) + 512]
       ^ dword_F3268[BYTE2(v301) + 768];
  v308 = a1[18];
  a1[17] = v473 ^ v415;
  a1[22] = v304;
  LODWORD(v309) = v308 ^ v426;
  a1[21] = v306;
  HIDWORD(v309) = v475 ^ v435;
  *((_QWORD *)a1 + 9) = v309;
  a1[23] = result;
  a1[24] = v307;
  a1[20] = v476 ^ v441;
  return result;
}
// F3268: using guessed type _DWORD dword_F3268[1014];

//----- (000C6880) --------------------------------------------------------
int __fastcall sub_C6880(_DWORD *a1, unsigned int *a2)
{
  int v4; // r3
  unsigned int v5; // lr
  int v6; // r0
  int v7; // r12
  unsigned int v8; // r8
  int v9; // r6
  unsigned int v10; // r9
  int v11; // r2
  unsigned int v12; // r7
  int v13; // r5
  unsigned int v14; // r3
  int v15; // r1
  int v16; // r0
  unsigned int v17; // r12
  unsigned int v18; // r6
  _DWORD *v19; // r8
  int v20; // r9
  int v21; // r7
  _DWORD *v22; // r11
  int v23; // r0
  int v24; // r6
  int v25; // r3
  int v26; // r9
  unsigned int v27; // r6
  unsigned int v28; // r7
  _DWORD *v29; // r3
  unsigned int v30; // r12
  unsigned int v31; // r0
  int v32; // lr
  int v33; // r1
  unsigned int v34; // r7
  int v35; // r5
  unsigned int v36; // r4
  int v37; // r2
  unsigned int v38; // lr
  unsigned int v39; // r5
  int v40; // r12
  int v41; // r8
  int v42; // r1
  int v43; // r3
  unsigned int v44; // r4
  unsigned int v45; // r7
  unsigned int v46; // r3
  unsigned int v47; // r12
  unsigned int v48; // r11
  unsigned int v49; // r5
  unsigned int v50; // r12
  unsigned int v51; // r2
  unsigned int v52; // lr
  unsigned int v53; // r0
  unsigned int v54; // r1
  unsigned int v55; // r3
  unsigned int v56; // r2
  int v57; // r4
  int v58; // r6
  int v59; // lr
  unsigned int v60; // r7
  unsigned int v61; // r5
  int v62; // r11
  unsigned int v63; // r0
  unsigned int v64; // r2
  unsigned int v65; // r1
  unsigned int v66; // r3
  int v67; // r1
  int v68; // r3
  int v69; // r4
  int v70; // r12
  int v71; // lr
  int v72; // r0
  int v73; // r0
  int v74; // r1
  int v75; // r12
  int v76; // lr
  int v77; // r0
  int v78; // r8
  int v79; // r11
  int v80; // r1
  int v81; // r5
  int v82; // r7
  int v83; // r4
  int v84; // r3
  unsigned __int8 v85; // r9^2
  unsigned int v86; // r3
  int v87; // r0
  int v88; // r7
  int v89; // r8
  unsigned int v90; // r2
  unsigned int v91; // r3
  _DWORD *v92; // r5
  int v93; // r7
  int v94; // r4
  int v95; // r8
  int v96; // r4
  int v97; // r7
  int v98; // r5
  int v99; // r3
  int v100; // r1
  int v101; // r0
  int v102; // r8
  int v103; // r2
  unsigned int v104; // r3
  unsigned int v105; // r1
  unsigned int v106; // r2
  int v107; // r8
  int v108; // r9
  int v109; // lr
  _DWORD *v110; // r6
  int v111; // r1
  int v112; // r2
  int v113; // r4
  unsigned int v114; // r2
  unsigned int v115; // r3
  int v116; // r1
  int v117; // r8
  int v118; // r0
  unsigned int v119; // r5
  unsigned int v120; // r11
  unsigned int v121; // r9
  int v122; // r7
  int v123; // r8
  int v124; // r12
  unsigned int v125; // lr
  unsigned int v126; // r1
  int v127; // r7
  unsigned int v128; // r2
  unsigned int v129; // r3
  unsigned int v130; // r11
  unsigned int v131; // r9
  unsigned int v132; // r8
  int v133; // r5
  int v134; // r2
  int v135; // r6
  int v136; // r4
  int v137; // r3
  unsigned int v138; // r0
  unsigned int v139; // r2
  unsigned int v140; // r3
  unsigned int v141; // r1
  int v142; // r7
  int v143; // r6
  int v144; // lr
  int v145; // r9
  int v146; // r7
  int v147; // lr
  int v148; // r1
  unsigned int v149; // r0
  unsigned int v150; // r1
  unsigned int v151; // r12
  unsigned int v152; // r11
  _DWORD *v153; // lr
  unsigned int v154; // r3
  unsigned int v155; // r2
  unsigned int v156; // r0
  unsigned int v157; // r9
  unsigned int v158; // r4
  unsigned int v159; // r3
  unsigned int v160; // r8
  int v161; // r11
  int v162; // lr
  int v163; // r12
  int v164; // r4
  int v165; // lr
  int v166; // r2
  int v167; // r5
  int v168; // r9
  int v169; // r2
  int v170; // r4
  _DWORD *v171; // r1
  int v172; // r0
  int v173; // lr
  unsigned int v174; // r12
  int v175; // r7
  int v176; // r5
  int v177; // r6
  int v178; // r7
  _DWORD *v179; // r3
  int v180; // r1
  int v181; // r4
  int v182; // r12
  int v183; // r7
  unsigned int v184; // r1
  unsigned int v185; // r3
  int v186; // r7
  int v187; // r12
  int v188; // r6
  int v189; // r4
  int v190; // lr
  _DWORD *v191; // r5
  int v192; // r9
  int v193; // r8
  int v194; // r3
  int v195; // r1
  int v196; // r0
  _DWORD *v197; // r2
  int v198; // lr
  int v199; // r7
  int v200; // r0
  unsigned int v201; // r3
  unsigned int v202; // r5
  unsigned int v203; // r2
  unsigned int v204; // r0
  int v205; // r12
  int v206; // lr
  int v207; // r6
  unsigned int v208; // r3
  unsigned int v209; // r11
  int v210; // r0
  _DWORD *v211; // r7
  int v212; // r2
  int v213; // r4
  int v214; // r1
  int v215; // r0
  int v216; // r2
  int v217; // r9
  int v218; // r8
  int v219; // r7
  int v220; // r2
  int v221; // r6
  unsigned int v222; // r6
  unsigned int v223; // r4
  unsigned int v224; // lr
  unsigned int v225; // r2
  int v226; // r0
  int v227; // r7
  unsigned int v228; // r3
  unsigned int v229; // r0
  int v230; // lr
  int v231; // r7
  int v232; // r1
  int v233; // r2
  int v234; // r12
  int v235; // r9
  int v236; // r11
  int v237; // r4
  int v238; // r3
  unsigned int v239; // r5
  unsigned int v240; // r3
  unsigned int v241; // r4
  unsigned int v242; // r1
  int v243; // lr
  int v244; // r2
  unsigned int v245; // r11
  int v246; // r7
  int v247; // r9
  int v248; // r12
  int v249; // r4
  int v250; // lr
  unsigned int v251; // r3
  unsigned int v252; // r2
  unsigned int v253; // r1
  int v254; // r8
  int v255; // r0
  unsigned int v256; // r8
  int v257; // lr
  _DWORD *v258; // r4
  int v259; // r1
  int v260; // lr
  unsigned int v261; // r6
  unsigned int v262; // r5
  unsigned int v263; // r7
  unsigned int v264; // r1
  int v265; // r11
  unsigned int v266; // r3
  int v267; // r11
  int v268; // r12
  int v269; // r3
  _DWORD *v270; // r1
  _DWORD *v271; // r0
  int v272; // r12
  int v273; // r3
  _DWORD *v274; // r0
  unsigned int v275; // r10
  unsigned int v276; // r6
  unsigned int v277; // r7
  unsigned int v278; // r9
  unsigned int v279; // r4
  unsigned int v280; // r12
  unsigned int v281; // lr
  unsigned int v282; // r5
  int v283; // r8
  int v284; // r3
  int v285; // r0
  int v286; // r9
  int v287; // r11
  int v288; // r2
  int v289; // r6
  int v290; // r5
  int v291; // r12
  int v292; // lr
  int v293; // r3
  int v294; // r4
  int v295; // lr
  int v296; // r1
  int v297; // r0
  int v298; // r2
  int v299; // r5
  unsigned __int8 v300; // r8^2
  int v301; // r11
  int v302; // r3
  int v303; // r7
  int v304; // r2
  unsigned int v305; // r0
  int v306; // r10
  int v307; // r0
  int v308; // r12
  int v309; // r7
  int v310; // r0
  int v311; // r10
  _DWORD *v312; // lr
  unsigned int v313; // r3
  int v314; // r2
  int v315; // r11
  _DWORD *v316; // r9
  int v317; // r6
  _DWORD *v318; // r8
  int v319; // r7
  int v320; // r0
  int v321; // r8
  unsigned int v322; // lr
  int v323; // r1
  int v324; // r4
  unsigned int v325; // r1
  _DWORD *v326; // r9
  int v327; // r5
  int v328; // r3
  unsigned int v329; // r3
  int v330; // r4
  int v331; // lr
  int v332; // r6
  int v333; // r2
  int v334; // r12
  int v335; // r9
  unsigned int v336; // lr
  unsigned int v337; // r0
  unsigned int v338; // r3
  unsigned int v339; // r12
  int v340; // r11
  int v341; // r4
  int v342; // r9
  int v343; // r12
  int v344; // r3
  int v345; // r5
  int v346; // r6
  unsigned int v347; // r3
  int v348; // r0
  _DWORD *v349; // r8
  int v350; // r10
  int v351; // r12
  int v352; // r12
  int v353; // r6
  _DWORD *v354; // r9
  int v355; // r8
  int v356; // lr
  unsigned int v357; // r10
  unsigned int v358; // r12
  unsigned int v359; // r0
  unsigned int v360; // r2
  int v361; // r7
  unsigned int v362; // r0
  unsigned int v363; // r3
  int v364; // r12
  int v365; // r4
  int v366; // lr
  int v367; // r5
  _DWORD *v369; // [sp+4h] [bp-178h]
  unsigned int v370; // [sp+4h] [bp-178h]
  unsigned int v371; // [sp+4h] [bp-178h]
  unsigned int v372; // [sp+4h] [bp-178h]
  unsigned int v373; // [sp+4h] [bp-178h]
  unsigned int v374; // [sp+4h] [bp-178h]
  int v375; // [sp+4h] [bp-178h]
  int v376; // [sp+4h] [bp-178h]
  int v377; // [sp+4h] [bp-178h]
  unsigned int v378; // [sp+4h] [bp-178h]
  int v379; // [sp+4h] [bp-178h]
  int v380; // [sp+4h] [bp-178h]
  unsigned int v381; // [sp+4h] [bp-178h]
  unsigned int v382; // [sp+4h] [bp-178h]
  unsigned int v383; // [sp+4h] [bp-178h]
  unsigned int *v384; // [sp+8h] [bp-174h]
  unsigned int v385; // [sp+8h] [bp-174h]
  int v386; // [sp+8h] [bp-174h]
  unsigned int v387; // [sp+8h] [bp-174h]
  int v388; // [sp+8h] [bp-174h]
  unsigned int v389; // [sp+8h] [bp-174h]
  int v390; // [sp+8h] [bp-174h]
  int v391; // [sp+8h] [bp-174h]
  _DWORD *v392; // [sp+Ch] [bp-170h]
  unsigned int v393; // [sp+Ch] [bp-170h]
  int v394; // [sp+Ch] [bp-170h]
  unsigned int v395; // [sp+Ch] [bp-170h]
  int v396; // [sp+Ch] [bp-170h]
  int v397; // [sp+Ch] [bp-170h]
  unsigned int v398; // [sp+Ch] [bp-170h]
  int v399; // [sp+Ch] [bp-170h]
  unsigned int v400; // [sp+Ch] [bp-170h]
  int v401; // [sp+Ch] [bp-170h]
  unsigned int v402; // [sp+10h] [bp-16Ch]
  int v403; // [sp+10h] [bp-16Ch]
  unsigned int v404; // [sp+10h] [bp-16Ch]
  int v405; // [sp+10h] [bp-16Ch]
  unsigned int v406; // [sp+10h] [bp-16Ch]
  unsigned int v407; // [sp+10h] [bp-16Ch]
  int v408; // [sp+10h] [bp-16Ch]
  int v409; // [sp+10h] [bp-16Ch]
  int v410; // [sp+10h] [bp-16Ch]
  unsigned int v411; // [sp+14h] [bp-168h]
  int v412; // [sp+14h] [bp-168h]
  unsigned int v413; // [sp+14h] [bp-168h]
  unsigned int v414; // [sp+14h] [bp-168h]
  int v415; // [sp+14h] [bp-168h]
  int v416; // [sp+14h] [bp-168h]
  int v417; // [sp+14h] [bp-168h]
  int v418; // [sp+14h] [bp-168h]
  int v419; // [sp+14h] [bp-168h]
  _DWORD *v420; // [sp+18h] [bp-164h]
  _DWORD *v421; // [sp+18h] [bp-164h]
  unsigned int v422; // [sp+18h] [bp-164h]
  int v423; // [sp+18h] [bp-164h]
  int v424; // [sp+18h] [bp-164h]
  unsigned int v425; // [sp+18h] [bp-164h]
  int v426; // [sp+18h] [bp-164h]
  int v427; // [sp+18h] [bp-164h]
  int v428; // [sp+18h] [bp-164h]
  int v429; // [sp+1Ch] [bp-160h]
  unsigned int v430; // [sp+1Ch] [bp-160h]
  int v431; // [sp+1Ch] [bp-160h]
  unsigned int v432; // [sp+1Ch] [bp-160h]
  int v433; // [sp+1Ch] [bp-160h]
  unsigned int v434; // [sp+1Ch] [bp-160h]
  _DWORD *v435; // [sp+1Ch] [bp-160h]
  unsigned int v436; // [sp+1Ch] [bp-160h]
  unsigned int v437; // [sp+20h] [bp-15Ch]
  int v438; // [sp+20h] [bp-15Ch]
  unsigned int v439; // [sp+20h] [bp-15Ch]
  unsigned int v440; // [sp+20h] [bp-15Ch]
  int v441; // [sp+20h] [bp-15Ch]
  int v442; // [sp+20h] [bp-15Ch]
  unsigned int v443; // [sp+24h] [bp-158h]
  int v444; // [sp+24h] [bp-158h]
  unsigned int v445; // [sp+24h] [bp-158h]
  unsigned int v446; // [sp+24h] [bp-158h]
  int v447; // [sp+24h] [bp-158h]
  unsigned int v448; // [sp+24h] [bp-158h]
  unsigned int v449; // [sp+24h] [bp-158h]
  int v450; // [sp+24h] [bp-158h]
  int v451; // [sp+24h] [bp-158h]
  unsigned int v452; // [sp+28h] [bp-154h]
  int v453; // [sp+28h] [bp-154h]
  unsigned int v454; // [sp+28h] [bp-154h]
  unsigned int v455; // [sp+28h] [bp-154h]
  unsigned int v456; // [sp+28h] [bp-154h]
  unsigned int v457; // [sp+28h] [bp-154h]
  int v458; // [sp+28h] [bp-154h]
  unsigned int v459; // [sp+28h] [bp-154h]
  int v460; // [sp+28h] [bp-154h]
  unsigned int v461; // [sp+2Ch] [bp-150h]
  unsigned int v462; // [sp+2Ch] [bp-150h]
  _DWORD *v463; // [sp+2Ch] [bp-150h]
  int v464; // [sp+2Ch] [bp-150h]
  unsigned int v465; // [sp+2Ch] [bp-150h]
  int v466; // [sp+2Ch] [bp-150h]
  int v467; // [sp+2Ch] [bp-150h]
  int v468; // [sp+2Ch] [bp-150h]
  unsigned int v469; // [sp+30h] [bp-14Ch]
  int v470; // [sp+30h] [bp-14Ch]
  int v471; // [sp+30h] [bp-14Ch]
  int v472; // [sp+30h] [bp-14Ch]
  unsigned int v473; // [sp+30h] [bp-14Ch]
  int v474; // [sp+30h] [bp-14Ch]
  unsigned int v475; // [sp+30h] [bp-14Ch]
  int v476; // [sp+30h] [bp-14Ch]
  unsigned int v477; // [sp+34h] [bp-148h]
  int v478; // [sp+34h] [bp-148h]
  int v479; // [sp+34h] [bp-148h]
  int v480; // [sp+34h] [bp-148h]
  int v481; // [sp+34h] [bp-148h]
  unsigned int v482; // [sp+34h] [bp-148h]
  int v483; // [sp+34h] [bp-148h]
  int v484; // [sp+34h] [bp-148h]
  int v485; // [sp+34h] [bp-148h]
  int v486; // [sp+34h] [bp-148h]
  int v487; // [sp+34h] [bp-148h]
  unsigned int v488; // [sp+38h] [bp-144h]
  int v489; // [sp+38h] [bp-144h]
  unsigned int v490; // [sp+38h] [bp-144h]
  int v491; // [sp+38h] [bp-144h]
  int v492; // [sp+38h] [bp-144h]
  int v493; // [sp+38h] [bp-144h]
  unsigned int v494; // [sp+3Ch] [bp-140h]
  int v495; // [sp+3Ch] [bp-140h]
  int v496; // [sp+3Ch] [bp-140h]
  int v497; // [sp+3Ch] [bp-140h]
  unsigned int v498; // [sp+3Ch] [bp-140h]
  int v499; // [sp+3Ch] [bp-140h]
  int v500; // [sp+3Ch] [bp-140h]
  int v501; // [sp+3Ch] [bp-140h]
  unsigned int v502; // [sp+40h] [bp-13Ch]
  int v503; // [sp+40h] [bp-13Ch]
  int v504; // [sp+40h] [bp-13Ch]
  unsigned int v505; // [sp+40h] [bp-13Ch]
  int v506; // [sp+40h] [bp-13Ch]
  int v507; // [sp+40h] [bp-13Ch]
  unsigned int v508; // [sp+44h] [bp-138h]
  int v509; // [sp+44h] [bp-138h]
  unsigned int v510; // [sp+44h] [bp-138h]
  int v511; // [sp+44h] [bp-138h]
  int v512; // [sp+44h] [bp-138h]
  unsigned int v513; // [sp+48h] [bp-134h]
  unsigned int v514; // [sp+48h] [bp-134h]
  int v515; // [sp+48h] [bp-134h]
  unsigned int v516; // [sp+4Ch] [bp-130h]
  unsigned int v517; // [sp+4Ch] [bp-130h]
  int v518; // [sp+4Ch] [bp-130h]
  int v519; // [sp+4Ch] [bp-130h]
  unsigned int v520; // [sp+4Ch] [bp-130h]
  int v521; // [sp+4Ch] [bp-130h]
  unsigned int v522; // [sp+50h] [bp-12Ch]
  int v523; // [sp+50h] [bp-12Ch]
  unsigned int v524; // [sp+50h] [bp-12Ch]
  int v525; // [sp+50h] [bp-12Ch]
  unsigned int v526; // [sp+54h] [bp-128h]
  int v527; // [sp+54h] [bp-128h]
  int v528; // [sp+54h] [bp-128h]
  int v529; // [sp+54h] [bp-128h]
  unsigned int v530; // [sp+54h] [bp-128h]
  unsigned int v531; // [sp+54h] [bp-128h]
  unsigned int v532; // [sp+54h] [bp-128h]
  int v533; // [sp+54h] [bp-128h]
  unsigned int v534; // [sp+58h] [bp-124h]
  int v535; // [sp+58h] [bp-124h]
  int v536; // [sp+58h] [bp-124h]
  unsigned int v537; // [sp+58h] [bp-124h]
  int v538; // [sp+58h] [bp-124h]
  unsigned int v539; // [sp+5Ch] [bp-120h]
  int v540; // [sp+5Ch] [bp-120h]
  unsigned int v541; // [sp+5Ch] [bp-120h]
  int v542; // [sp+5Ch] [bp-120h]
  int v543; // [sp+5Ch] [bp-120h]
  unsigned int v544; // [sp+60h] [bp-11Ch]
  int v545; // [sp+60h] [bp-11Ch]
  unsigned int v546; // [sp+60h] [bp-11Ch]
  int v547; // [sp+60h] [bp-11Ch]
  unsigned int v548; // [sp+60h] [bp-11Ch]
  int v549; // [sp+64h] [bp-118h]
  int v550; // [sp+64h] [bp-118h]
  int v551; // [sp+64h] [bp-118h]
  int v552; // [sp+64h] [bp-118h]
  int v553; // [sp+64h] [bp-118h]
  int v554; // [sp+64h] [bp-118h]
  int v555; // [sp+64h] [bp-118h]
  _DWORD *v556; // [sp+64h] [bp-118h]
  int v557; // [sp+64h] [bp-118h]
  unsigned int v558; // [sp+68h] [bp-114h]
  int v559; // [sp+68h] [bp-114h]
  unsigned int v560; // [sp+68h] [bp-114h]
  int v561; // [sp+68h] [bp-114h]
  int v562; // [sp+68h] [bp-114h]
  int v563; // [sp+68h] [bp-114h]
  int v564; // [sp+68h] [bp-114h]
  int v565; // [sp+68h] [bp-114h]
  unsigned int v566; // [sp+6Ch] [bp-110h]
  int v567; // [sp+6Ch] [bp-110h]
  unsigned int v568; // [sp+6Ch] [bp-110h]
  int v569; // [sp+6Ch] [bp-110h]
  int v570; // [sp+6Ch] [bp-110h]
  int v571; // [sp+6Ch] [bp-110h]
  int v572; // [sp+6Ch] [bp-110h]
  unsigned int v573; // [sp+70h] [bp-10Ch]
  int v574; // [sp+70h] [bp-10Ch]
  int v575; // [sp+70h] [bp-10Ch]
  unsigned int v576; // [sp+70h] [bp-10Ch]
  int v577; // [sp+70h] [bp-10Ch]
  int v578; // [sp+70h] [bp-10Ch]
  unsigned int v579; // [sp+74h] [bp-108h]
  int v580; // [sp+74h] [bp-108h]
  unsigned int v581; // [sp+74h] [bp-108h]
  int v582; // [sp+74h] [bp-108h]
  int v583; // [sp+74h] [bp-108h]
  _DWORD *v584; // [sp+74h] [bp-108h]
  unsigned int v585; // [sp+78h] [bp-104h]
  int v586; // [sp+78h] [bp-104h]
  int v587; // [sp+78h] [bp-104h]
  unsigned int v588; // [sp+78h] [bp-104h]
  int v589; // [sp+78h] [bp-104h]
  int v590; // [sp+78h] [bp-104h]
  _DWORD *v591; // [sp+78h] [bp-104h]
  int v592; // [sp+78h] [bp-104h]
  int v593; // [sp+78h] [bp-104h]
  unsigned int v594; // [sp+7Ch] [bp-100h]
  int v595; // [sp+7Ch] [bp-100h]
  unsigned int v596; // [sp+7Ch] [bp-100h]
  unsigned int v597; // [sp+7Ch] [bp-100h]
  int v598; // [sp+7Ch] [bp-100h]
  unsigned int v599; // [sp+80h] [bp-FCh]
  int v600; // [sp+80h] [bp-FCh]
  unsigned int v601; // [sp+80h] [bp-FCh]
  int v602; // [sp+80h] [bp-FCh]
  int v603; // [sp+80h] [bp-FCh]
  int v604; // [sp+80h] [bp-FCh]
  int v605; // [sp+80h] [bp-FCh]
  unsigned int v606; // [sp+84h] [bp-F8h]
  int v607; // [sp+84h] [bp-F8h]
  int v608; // [sp+84h] [bp-F8h]
  int v609; // [sp+84h] [bp-F8h]
  int v610; // [sp+84h] [bp-F8h]
  int v611; // [sp+84h] [bp-F8h]
  int v612; // [sp+84h] [bp-F8h]
  int v613; // [sp+88h] [bp-F4h]
  int v614; // [sp+88h] [bp-F4h]
  unsigned int v615; // [sp+88h] [bp-F4h]
  int v616; // [sp+88h] [bp-F4h]
  int v617; // [sp+88h] [bp-F4h]
  int v618; // [sp+88h] [bp-F4h]
  unsigned int v619; // [sp+88h] [bp-F4h]
  int v620; // [sp+88h] [bp-F4h]
  int v621; // [sp+88h] [bp-F4h]
  int v622; // [sp+88h] [bp-F4h]
  int v623; // [sp+88h] [bp-F4h]
  int v624; // [sp+88h] [bp-F4h]
  int v625; // [sp+8Ch] [bp-F0h]
  unsigned int v626; // [sp+8Ch] [bp-F0h]
  int v627; // [sp+8Ch] [bp-F0h]
  unsigned int v628; // [sp+8Ch] [bp-F0h]
  int v629; // [sp+8Ch] [bp-F0h]
  unsigned int v630; // [sp+8Ch] [bp-F0h]
  int v631; // [sp+8Ch] [bp-F0h]
  unsigned int v632; // [sp+8Ch] [bp-F0h]
  int v633; // [sp+8Ch] [bp-F0h]
  int v634; // [sp+8Ch] [bp-F0h]
  int v635; // [sp+90h] [bp-ECh]
  int v636; // [sp+90h] [bp-ECh]
  int v637; // [sp+90h] [bp-ECh]
  int v638; // [sp+90h] [bp-ECh]
  int v639; // [sp+90h] [bp-ECh]
  int v640; // [sp+90h] [bp-ECh]
  int v641; // [sp+90h] [bp-ECh]
  _DWORD *v642; // [sp+90h] [bp-ECh]
  int v643; // [sp+90h] [bp-ECh]
  int v644; // [sp+94h] [bp-E8h]
  int v645; // [sp+94h] [bp-E8h]
  int v646; // [sp+94h] [bp-E8h]
  unsigned int v647; // [sp+94h] [bp-E8h]
  int v648; // [sp+94h] [bp-E8h]
  int v649; // [sp+94h] [bp-E8h]
  int v650; // [sp+94h] [bp-E8h]
  _DWORD *v651; // [sp+94h] [bp-E8h]
  int v652; // [sp+98h] [bp-E4h]
  int v653; // [sp+98h] [bp-E4h]
  int v654; // [sp+98h] [bp-E4h]
  int v655; // [sp+98h] [bp-E4h]
  int v656; // [sp+98h] [bp-E4h]
  int v657; // [sp+98h] [bp-E4h]
  int v658; // [sp+98h] [bp-E4h]
  int v659; // [sp+98h] [bp-E4h]
  int v660; // [sp+98h] [bp-E4h]
  int v661; // [sp+98h] [bp-E4h]
  int v662; // [sp+98h] [bp-E4h]
  int v663; // [sp+9Ch] [bp-E0h]
  int v664; // [sp+9Ch] [bp-E0h]
  int v665; // [sp+9Ch] [bp-E0h]
  int v666; // [sp+9Ch] [bp-E0h]
  int v667; // [sp+9Ch] [bp-E0h]
  _DWORD *v668; // [sp+9Ch] [bp-E0h]
  int v669; // [sp+A0h] [bp-DCh]
  int v670; // [sp+A0h] [bp-DCh]
  int v671; // [sp+A0h] [bp-DCh]
  int v672; // [sp+A0h] [bp-DCh]
  int v673; // [sp+A0h] [bp-DCh]
  int v674; // [sp+A0h] [bp-DCh]
  _DWORD *v675; // [sp+A0h] [bp-DCh]
  int v676; // [sp+A4h] [bp-D8h]
  int v677; // [sp+A4h] [bp-D8h]
  int v678; // [sp+A4h] [bp-D8h]
  int v679; // [sp+A4h] [bp-D8h]
  int v680; // [sp+A4h] [bp-D8h]
  int v681; // [sp+A4h] [bp-D8h]
  _DWORD *v682; // [sp+A4h] [bp-D8h]
  int v683; // [sp+A8h] [bp-D4h]
  int v684; // [sp+A8h] [bp-D4h]
  int v685; // [sp+A8h] [bp-D4h]
  int v686; // [sp+A8h] [bp-D4h]
  int v687; // [sp+A8h] [bp-D4h]
  int v688; // [sp+A8h] [bp-D4h]
  int v689; // [sp+ACh] [bp-D0h]
  int v690; // [sp+ACh] [bp-D0h]
  int v691; // [sp+ACh] [bp-D0h]
  int v692; // [sp+ACh] [bp-D0h]
  int v693; // [sp+ACh] [bp-D0h]
  int v694; // [sp+B0h] [bp-CCh]
  int v695; // [sp+B0h] [bp-CCh]
  int v696; // [sp+B0h] [bp-CCh]
  int v697; // [sp+B4h] [bp-C8h]
  int v698; // [sp+B4h] [bp-C8h]
  int v699; // [sp+B4h] [bp-C8h]
  int v700; // [sp+B8h] [bp-C4h]
  int v701; // [sp+B8h] [bp-C4h]
  int v702; // [sp+B8h] [bp-C4h]
  int v703; // [sp+B8h] [bp-C4h]
  int v704; // [sp+BCh] [bp-C0h]
  int v705; // [sp+BCh] [bp-C0h]
  int v706; // [sp+C0h] [bp-BCh]
  int v707; // [sp+C0h] [bp-BCh]
  int v708; // [sp+C0h] [bp-BCh]
  int v709; // [sp+C4h] [bp-B8h]
  int v710; // [sp+C4h] [bp-B8h]
  int v711; // [sp+C4h] [bp-B8h]
  int v712; // [sp+C8h] [bp-B4h]
  int v713; // [sp+C8h] [bp-B4h]
  int v714; // [sp+C8h] [bp-B4h]
  int v715; // [sp+C8h] [bp-B4h]
  int v716; // [sp+C8h] [bp-B4h]
  int v717; // [sp+C8h] [bp-B4h]
  int v718; // [sp+C8h] [bp-B4h]
  int v719; // [sp+CCh] [bp-B0h]
  int v720; // [sp+CCh] [bp-B0h]
  int v721; // [sp+CCh] [bp-B0h]
  int v722; // [sp+CCh] [bp-B0h]
  int v723; // [sp+D0h] [bp-ACh]
  int v724; // [sp+D0h] [bp-ACh]
  int v725; // [sp+D0h] [bp-ACh]
  int v726; // [sp+D0h] [bp-ACh]
  int v727; // [sp+D4h] [bp-A8h]
  _DWORD *v728; // [sp+D4h] [bp-A8h]
  int v729; // [sp+D4h] [bp-A8h]
  int v730; // [sp+D4h] [bp-A8h]
  int v731; // [sp+D8h] [bp-A4h]
  int v732; // [sp+D8h] [bp-A4h]
  int v733; // [sp+D8h] [bp-A4h]
  int v734; // [sp+D8h] [bp-A4h]
  int v735; // [sp+D8h] [bp-A4h]
  int v736; // [sp+DCh] [bp-A0h]
  _DWORD *v737; // [sp+DCh] [bp-A0h]
  int v738; // [sp+DCh] [bp-A0h]
  int v739; // [sp+DCh] [bp-A0h]
  int v740; // [sp+E0h] [bp-9Ch]
  int v741; // [sp+E0h] [bp-9Ch]
  int v742; // [sp+E4h] [bp-98h]
  int v743; // [sp+E4h] [bp-98h]
  _DWORD *v744; // [sp+E4h] [bp-98h]
  int v745; // [sp+E8h] [bp-94h]
  int v746; // [sp+E8h] [bp-94h]
  int v747; // [sp+ECh] [bp-90h]
  int v748; // [sp+ECh] [bp-90h]
  int v749; // [sp+F0h] [bp-8Ch]
  int v750; // [sp+F0h] [bp-8Ch]
  int v751; // [sp+F0h] [bp-8Ch]
  int v752; // [sp+F0h] [bp-8Ch]
  int v753; // [sp+F0h] [bp-8Ch]
  _DWORD *v754; // [sp+F0h] [bp-8Ch]
  int v755; // [sp+F4h] [bp-88h]
  unsigned int v756; // [sp+F4h] [bp-88h]
  int v757; // [sp+F4h] [bp-88h]
  int v758; // [sp+F4h] [bp-88h]
  int v759; // [sp+F4h] [bp-88h]
  int v760; // [sp+F4h] [bp-88h]
  int v761; // [sp+F4h] [bp-88h]
  _DWORD *v762; // [sp+F4h] [bp-88h]
  int v763; // [sp+F8h] [bp-84h]
  int v764; // [sp+F8h] [bp-84h]
  int v765; // [sp+F8h] [bp-84h]
  int v766; // [sp+F8h] [bp-84h]
  int v767; // [sp+FCh] [bp-80h]
  int v768; // [sp+FCh] [bp-80h]
  int v769; // [sp+FCh] [bp-80h]
  int v770; // [sp+FCh] [bp-80h]
  int v771; // [sp+FCh] [bp-80h]
  _DWORD *v772; // [sp+FCh] [bp-80h]
  int v773; // [sp+100h] [bp-7Ch]
  int v774; // [sp+100h] [bp-7Ch]
  int v775; // [sp+100h] [bp-7Ch]
  int v776; // [sp+100h] [bp-7Ch]
  _DWORD *v777; // [sp+100h] [bp-7Ch]
  int v778; // [sp+104h] [bp-78h]
  int v779; // [sp+104h] [bp-78h]
  int v780; // [sp+104h] [bp-78h]
  int v781; // [sp+104h] [bp-78h]
  int v782; // [sp+104h] [bp-78h]
  int v783; // [sp+108h] [bp-74h]
  int v784; // [sp+108h] [bp-74h]
  int v785; // [sp+108h] [bp-74h]
  int v786; // [sp+10Ch] [bp-70h]
  int v787; // [sp+10Ch] [bp-70h]
  int v788; // [sp+10Ch] [bp-70h]
  int v789; // [sp+110h] [bp-6Ch]
  _DWORD *v790; // [sp+118h] [bp-64h]
  int v791; // [sp+11Ch] [bp-60h]
  int v792; // [sp+120h] [bp-5Ch]
  int v793; // [sp+124h] [bp-58h]
  int v794; // [sp+128h] [bp-54h]
  int v795; // [sp+12Ch] [bp-50h]
  int v796; // [sp+130h] [bp-4Ch]
  int v797; // [sp+134h] [bp-48h]
  int v798; // [sp+138h] [bp-44h]
  int v799; // [sp+13Ch] [bp-40h]
  int v800; // [sp+140h] [bp-3Ch]
  int v801; // [sp+144h] [bp-38h]
  int v802; // [sp+148h] [bp-34h]
  int v803; // [sp+14Ch] [bp-30h]
  int v804; // [sp+150h] [bp-2Ch]
  int v805; // [sp+154h] [bp-28h]
  int v806; // [sp+158h] [bp-24h]
  int v807; // [sp+15Ch] [bp-20h]
  int v808; // [sp+160h] [bp-1Ch]
  int v809; // [sp+164h] [bp-18h]
  int v810; // [sp+168h] [bp-14h]

  v4 = a1[37];
  v5 = a2[1];
  v6 = a1[38];
  v7 = a1[40];
  v8 = a2[3];
  v9 = a1[39];
  v10 = a2[2];
  v790 = a1;
  v11 = v6 ^ v5;
  v12 = (v6 ^ v5) >> 24;
  v810 = v4;
  v585 = *a2;
  v13 = (unsigned __int8)(v6 ^ v5);
  v723 = v4;
  v14 = v4 ^ *a2;
  v800 = v6;
  v15 = v7 ^ v8;
  v16 = v9 ^ v10;
  v443 = v8;
  v802 = v7;
  v801 = v9;
  v17 = (v7 ^ v8) >> 24;
  v18 = (v9 ^ v10) >> 24;
  v19 = &dword_F3268[BYTE2(v16)];
  v384 = a2;
  v599 = v10;
  v20 = BYTE1(v16);
  v392 = &dword_F3268[v12];
  v21 = (unsigned __int8)v16;
  v420 = &dword_F3268[v18];
  v573 = v5;
  v22 = &dword_F3268[BYTE1(v14)];
  v23 = dword_F3268[HIBYTE(v14) + 256] ^ dword_F3268[v13];
  v558 = a2[4];
  v452 = a2[5];
  v24 = dword_F3268[v17 + 256] ^ dword_F3268[(unsigned __int8)v14] ^ v558 ^ dword_F3268[BYTE1(v11) + 512];
  v369 = &dword_F3268[BYTE2(v14)];
  v25 = dword_F3268[v20 + 512];
  v26 = dword_F3268[v21];
  v796 = v790[33];
  v27 = v24 ^ v19[768];
  v28 = v23 ^ v452 ^ v25 ^ dword_F3268[BYTE2(v15) + 768];
  v797 = v790[34];
  v798 = v790[35];
  v805 = v790[43];
  v803 = v790[41];
  v804 = v790[42];
  v799 = v790[36];
  v806 = v790[44];
  v791 = v790[45];
  v792 = v790[46];
  v807 = v790[47];
  v526 = a2[6];
  v808 = v790[48];
  v29 = v420;
  v421 = &dword_F3268[BYTE1(v28)];
  v566 = a2[7];
  v30 = v22[512] ^ dword_F3268[(unsigned __int8)v15] ^ v29[256] ^ v566 ^ dword_F3268[BYTE2(v11) + 768];
  v31 = v392[256] ^ v26 ^ v526 ^ dword_F3268[BYTE1(v15) + 512] ^ v369[768];
  v32 = dword_F3268[(unsigned __int8)v28] ^ dword_F3268[HIBYTE(v27) + 256];
  v393 = a2[9];
  v33 = dword_F3268[(unsigned __int8)v31] ^ dword_F3268[HIBYTE(v28) + 256];
  v34 = dword_F3268[BYTE2(v28) + 768];
  v411 = a2[11];
  v461 = a2[8];
  v579 = a2[10];
  v35 = dword_F3268[BYTE1(v31) + 512] ^ v32 ^ v393;
  v36 = dword_F3268[BYTE1(v30) + 512] ^ v33 ^ v579 ^ dword_F3268[BYTE2(v27) + 768];
  v37 = dword_F3268[(unsigned __int8)v30] ^ dword_F3268[HIBYTE(v31) + 256] ^ v411 ^ dword_F3268[BYTE1(v27) + 512];
  v38 = dword_F3268[(unsigned __int8)v27]
      ^ dword_F3268[HIBYTE(v30) + 256]
      ^ v461
      ^ v421[512]
      ^ dword_F3268[BYTE2(v31) + 768];
  v39 = v35 ^ dword_F3268[BYTE2(v30) + 768];
  v40 = dword_F3268[((v37 ^ v34) >> 24) + 256];
  v429 = dword_F3268[BYTE2(v36) + 768];
  v494 = v384[12];
  v41 = dword_F3268[HIBYTE(v36) + 256];
  v42 = dword_F3268[(unsigned __int8)v36];
  v43 = dword_F3268[(unsigned __int8)(v37 ^ v34)];
  v469 = v384[13];
  v370 = v384[14];
  v477 = v384[15];
  v44 = dword_F3268[BYTE1(v36) + 512]
      ^ dword_F3268[(unsigned __int8)v39]
      ^ dword_F3268[HIBYTE(v38) + 256]
      ^ v469
      ^ dword_F3268[(unsigned __int8)((v37 ^ v34) >> 16) + 768];
  v45 = dword_F3268[(unsigned __int8)((unsigned __int16)(v37 ^ v34) >> 8) + 512]
      ^ v42
      ^ dword_F3268[HIBYTE(v39) + 256]
      ^ v370
      ^ dword_F3268[BYTE2(v38) + 768];
  v46 = v43 ^ v41 ^ v477 ^ dword_F3268[BYTE1(v38) + 512] ^ dword_F3268[BYTE2(v39) + 768];
  v47 = v40 ^ dword_F3268[(unsigned __int8)v38] ^ v494 ^ dword_F3268[BYTE1(v39) + 512] ^ v429;
  v697 = dword_F3268[(unsigned __int8)v44]
       ^ dword_F3268[HIBYTE(v47) + 256]
       ^ v797
       ^ dword_F3268[BYTE1(v45) + 512]
       ^ dword_F3268[BYTE2(v46) + 768];
  v740 = v808;
  v635 = dword_F3268[BYTE2(v44) + 768];
  v613 = dword_F3268[HIBYTE(v44) + 256] ^ dword_F3268[(unsigned __int8)v45] ^ v798 ^ dword_F3268[BYTE1(v46) + 512];
  v422 = v384[17];
  v694 = dword_F3268[HIBYTE(v46) + 256]
       ^ dword_F3268[(unsigned __int8)v47]
       ^ v796
       ^ dword_F3268[BYTE1(v44) + 512]
       ^ dword_F3268[BYTE2(v45) + 768];
  v625 = dword_F3268[BYTE2(v47) + 768];
  v549 = dword_F3268[HIBYTE(v45) + 256] ^ dword_F3268[(unsigned __int8)v46] ^ v799 ^ dword_F3268[BYTE1(v47) + 512];
  v48 = v384[16];
  v534 = v384[18];
  v402 = v384[19];
  v747 = v807;
  v488 = v48;
  v502 = v384[21];
  v430 = v384[23];
  v539 = v384[20];
  v508 = v384[22];
  v49 = dword_F3268[(unsigned __int8)(v808 ^ v402)]
      ^ dword_F3268[((v807 ^ v534) >> 24) + 256]
      ^ v430
      ^ dword_F3268[(unsigned __int8)(BYTE1(v791) ^ BYTE1(v48)) + 512]
      ^ dword_F3268[(unsigned __int8)((v792 ^ v422) >> 16) + 768];
  v50 = dword_F3268[(unsigned __int8)((unsigned __int16)(v792 ^ v422) >> 8) + 512]
      ^ dword_F3268[(unsigned __int8)(v791 ^ v48)]
      ^ dword_F3268[((v808 ^ v402) >> 24) + 256]
      ^ v539
      ^ dword_F3268[(unsigned __int8)((v807 ^ v534) >> 16) + 768];
  v51 = dword_F3268[(unsigned __int8)((v791 ^ v48) >> 16) + 768]
      ^ dword_F3268[(unsigned __int8)(v807 ^ v534)]
      ^ dword_F3268[((v792 ^ v422) >> 24) + 256]
      ^ v508
      ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v808 ^ v402) >> 8) + 512];
  v52 = dword_F3268[(unsigned __int8)(v792 ^ v422)]
      ^ dword_F3268[((v791 ^ v48) >> 24) + 256]
      ^ v502
      ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v807 ^ v534) >> 8) + 512]
      ^ dword_F3268[(unsigned __int8)((v808 ^ v402) >> 16) + 768];
  v516 = v384[24];
  v437 = v384[25];
  v594 = v384[26];
  v606 = v384[27];
  v53 = dword_F3268[(unsigned __int8)v49]
      ^ dword_F3268[HIBYTE(v51) + 256]
      ^ v606
      ^ dword_F3268[BYTE1(v50) + 512]
      ^ dword_F3268[BYTE2(v52) + 768];
  v54 = dword_F3268[(unsigned __int8)v51]
      ^ dword_F3268[HIBYTE(v52) + 256]
      ^ v594
      ^ dword_F3268[BYTE1(v49) + 512]
      ^ dword_F3268[BYTE2(v50) + 768];
  v55 = dword_F3268[HIBYTE(v49) + 256]
      ^ dword_F3268[(unsigned __int8)v50]
      ^ v516
      ^ dword_F3268[BYTE1(v52) + 512]
      ^ dword_F3268[BYTE2(v51) + 768];
  v56 = dword_F3268[(unsigned __int8)v52]
      ^ dword_F3268[HIBYTE(v50) + 256]
      ^ v437
      ^ dword_F3268[BYTE1(v51) + 512]
      ^ dword_F3268[BYTE2(v49) + 768];
  v652 = dword_F3268[(unsigned __int8)v56];
  v676 = dword_F3268[HIBYTE(v56) + 256];
  v57 = dword_F3268[(unsigned __int8)v53];
  v58 = dword_F3268[(unsigned __int8)v54];
  v59 = dword_F3268[BYTE1(v53) + 512];
  v513 = v384[28];
  v60 = v384[30];
  v61 = v384[31];
  v385 = v384[29];
  v522 = v60;
  v544 = v61;
  v62 = dword_F3268[BYTE2(v53) + 768];
  v63 = dword_F3268[BYTE2(v54) + 768]
      ^ dword_F3268[HIBYTE(v53) + 256]
      ^ dword_F3268[(unsigned __int8)v55]
      ^ v513
      ^ dword_F3268[BYTE1(v56) + 512];
  v64 = dword_F3268[BYTE2(v56) + 768] ^ v57 ^ dword_F3268[HIBYTE(v54) + 256] ^ v61 ^ dword_F3268[BYTE1(v55) + 512];
  v65 = v652 ^ dword_F3268[HIBYTE(v55) + 256] ^ v385 ^ dword_F3268[BYTE1(v54) + 512] ^ v62;
  v66 = v58 ^ v676 ^ v60 ^ v59 ^ dword_F3268[BYTE2(v55) + 768];
  v706 = dword_F3268[HIBYTE(v64) + 256]
       ^ dword_F3268[(unsigned __int8)v63]
       ^ v803
       ^ dword_F3268[BYTE1(v65) + 512]
       ^ dword_F3268[BYTE2(v66) + 768];
  v793 = v790[49];
  v709 = dword_F3268[(unsigned __int8)v65]
       ^ dword_F3268[HIBYTE(v63) + 256]
       ^ v804
       ^ dword_F3268[BYTE1(v66) + 512]
       ^ dword_F3268[BYTE2(v64) + 768];
  v795 = v790[52];
  v794 = v790[50];
  v809 = v790[51];
  v719 = dword_F3268[(unsigned __int8)v64]
       ^ dword_F3268[HIBYTE(v66) + 256]
       ^ v806
       ^ dword_F3268[BYTE1(v63) + 512]
       ^ dword_F3268[BYTE2(v65) + 768];
  v700 = v613 ^ v625;
  v712 = dword_F3268[(unsigned __int8)v66]
       ^ dword_F3268[HIBYTE(v65) + 256]
       ^ v805
       ^ dword_F3268[BYTE1(v64) + 512]
       ^ dword_F3268[BYTE2(v63) + 768];
  v704 = v549 ^ v635;
  v745 = v792;
  v742 = v791;
  v736 = v802;
  v731 = v801;
  v727 = v800;
  v550 = 0;
  do
  {
    v67 = dword_F3268[HIBYTE(v599) + 256] ^ dword_F3268[(unsigned __int8)v443];
    v68 = dword_F3268[HIBYTE(v443) + 256] ^ dword_F3268[(unsigned __int8)v585];
    v69 = dword_F3268[BYTE1(v573) + 512];
    v70 = dword_F3268[BYTE2(v573) + 768];
    v71 = dword_F3268[(unsigned __int8)v573]
        ^ dword_F3268[HIBYTE(v585) + 256]
        ^ v513
        ^ dword_F3268[BYTE1(v599) + 512]
        ^ dword_F3268[BYTE2(v443) + 768];
    v72 = dword_F3268[HIBYTE(v573) + 256] ^ dword_F3268[(unsigned __int8)v599] ^ v385 ^ dword_F3268[BYTE1(v443) + 512];
    v444 = v71;
    v73 = v72 ^ dword_F3268[BYTE2(v585) + 768];
    v574 = v73;
    v74 = v67 ^ v522 ^ dword_F3268[BYTE1(v585) + 512] ^ v70;
    v586 = v74;
    v600 = v68 ^ v544 ^ v69 ^ dword_F3268[BYTE2(v599) + 768];
    if ( !v550 )
    {
      v444 = v71 ^ v793;
      v574 = v73 ^ v794;
      v586 = v74 ^ v809;
      v600 ^= ~v795;
    }
    v75 = dword_F3268[HIBYTE(v526) + 256];
    v76 = dword_F3268[HIBYTE(v452) + 256] ^ dword_F3268[(unsigned __int8)v526];
    v77 = dword_F3268[(unsigned __int8)v558] ^ dword_F3268[HIBYTE(v566) + 256] ^ dword_F3268[BYTE1(v452) + 512];
    v78 = dword_F3268[((v600 ^ (unsigned int)v704) >> 24) + 256]
        ^ dword_F3268[(unsigned __int8)(v444 ^ v694)]
        ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v574 ^ v697) >> 8) + 512]
        ^ dword_F3268[(unsigned __int8)((v586 ^ (unsigned int)v700) >> 16) + 768];
    v79 = dword_F3268[BYTE2(v452) + 768];
    v80 = dword_F3268[(unsigned __int8)((unsigned __int16)(v600 ^ v704) >> 8) + 512]
        ^ dword_F3268[(unsigned __int8)(v586 ^ v700)]
        ^ dword_F3268[((v574 ^ (unsigned int)v697) >> 24) + 256]
        ^ dword_F3268[(unsigned __int8)((v444 ^ (unsigned int)v694) >> 16) + 768];
    v81 = dword_F3268[HIBYTE(v558) + 256]
        ^ dword_F3268[(unsigned __int8)v452]
        ^ dword_F3268[BYTE1(v526) + 512]
        ^ dword_F3268[BYTE2(v566) + 768]
        ^ v444;
    v82 = dword_F3268[BYTE2(v526) + 768];
    v453 = v81;
    v83 = dword_F3268[(unsigned __int8)((unsigned __int16)(v444 ^ v694) >> 8) + 512]
        ^ dword_F3268[(unsigned __int8)(v600 ^ v704)]
        ^ dword_F3268[((v586 ^ (unsigned int)v700) >> 24) + 256]
        ^ dword_F3268[(unsigned __int8)((v574 ^ (unsigned int)v697) >> 16) + 768];
    v527 = v76 ^ dword_F3268[BYTE1(v566) + 512] ^ dword_F3268[BYTE2(v558) + 768] ^ v574;
    v84 = v75 ^ dword_F3268[(unsigned __int8)v566] ^ dword_F3268[BYTE1(v558) + 512] ^ v79 ^ v586;
    v559 = v84;
    v567 = v77 ^ v82 ^ v600;
    if ( v550 == 1 )
    {
      v453 = v81 ^ v795;
      v527 ^= v809;
      v559 = v84 ^ v794;
      v567 ^= ~v793;
    }
    v85 = BYTE2(v453) ^ BYTE2(v78);
    v86 = dword_F3268[((v444 ^ (unsigned int)v694) >> 24) + 256]
        ^ dword_F3268[(unsigned __int8)(v574 ^ v697)]
        ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v586 ^ v700) >> 8) + 512]
        ^ dword_F3268[(unsigned __int8)((v600 ^ (unsigned int)v704) >> 16) + 768]
        ^ v527;
    v87 = dword_F3268[(unsigned __int8)v411];
    v749 = dword_F3268[(unsigned __int8)((unsigned __int16)(v453 ^ v78) >> 8) + 512];
    v636 = dword_F3268[(unsigned __int8)(v453 ^ v78)];
    v614 = dword_F3268[HIBYTE(v411) + 256]
         ^ dword_F3268[(unsigned __int8)v461]
         ^ dword_F3268[BYTE1(v393) + 512]
         ^ dword_F3268[BYTE2(v579) + 768]
         ^ v567;
    v88 = dword_F3268[BYTE1(v461) + 512];
    v677 = dword_F3268[BYTE2(v461) + 768];
    v689 = dword_F3268[BYTE2(v393) + 768];
    v683 = dword_F3268[((v453 ^ (unsigned int)v78) >> 24) + 256];
    v89 = dword_F3268[(unsigned __int8)v579] ^ dword_F3268[HIBYTE(v393) + 256] ^ dword_F3268[BYTE1(v411) + 512];
    v412 = dword_F3268[(unsigned __int8)v393]
         ^ dword_F3268[HIBYTE(v461) + 256]
         ^ dword_F3268[BYTE1(v579) + 512]
         ^ dword_F3268[BYTE2(v411) + 768]
         ^ v453;
    v626 = dword_F3268[(unsigned __int8)(v567 ^ v83)]
         ^ dword_F3268[((v559 ^ (unsigned int)v80) >> 24) + 256]
         ^ v614
         ^ v749
         ^ dword_F3268[BYTE2(v86) + 768];
    v462 = v636
         ^ dword_F3268[((v567 ^ (unsigned int)v83) >> 24) + 256]
         ^ v412
         ^ dword_F3268[BYTE1(v86) + 512]
         ^ dword_F3268[(unsigned __int8)(BYTE2(v559) ^ BYTE2(v80)) + 768];
    v394 = v89 ^ v677 ^ v527;
    v90 = dword_F3268[(unsigned __int8)v86]
        ^ v683
        ^ v394
        ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v559 ^ v80) >> 8) + 512]
        ^ dword_F3268[(unsigned __int8)((v567 ^ (unsigned int)v83) >> 16) + 768];
    v580 = v87 ^ dword_F3268[HIBYTE(v579) + 256] ^ v88 ^ v689 ^ v559;
    v91 = dword_F3268[(unsigned __int8)(v559 ^ v80)]
        ^ dword_F3268[HIBYTE(v86) + 256]
        ^ v580
        ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v567 ^ v83) >> 8) + 512]
        ^ dword_F3268[v85 + 768];
    v92 = &dword_F3268[BYTE1(v477)];
    v637 = dword_F3268[BYTE2(v477) + 768]
         ^ dword_F3268[HIBYTE(v494) + 256]
         ^ dword_F3268[(unsigned __int8)v469]
         ^ dword_F3268[BYTE1(v370) + 512]
         ^ v412;
    v663 = dword_F3268[HIBYTE(v370) + 256];
    v653 = dword_F3268[(unsigned __int8)v477];
    v93 = dword_F3268[(unsigned __int8)v370];
    v94 = dword_F3268[BYTE2(v370) + 768];
    v371 = dword_F3268[HIBYTE(v626) + 256]
         ^ dword_F3268[(unsigned __int8)v462]
         ^ v637
         ^ dword_F3268[BYTE1(v90) + 512]
         ^ dword_F3268[BYTE2(v91) + 768];
    v669 = dword_F3268[HIBYTE(v477) + 256];
    v478 = v93;
    v684 = v94;
    v95 = (unsigned __int8)v91;
    v644 = dword_F3268[HIBYTE(v91) + 256];
    v96 = dword_F3268[BYTE1(v469) + 512] ^ dword_F3268[(unsigned __int8)v494] ^ v669;
    v97 = dword_F3268[BYTE1(v494) + 512] ^ v653 ^ v663 ^ dword_F3268[BYTE2(v469) + 768];
    v98 = v92[512] ^ v478 ^ dword_F3268[HIBYTE(v469) + 256] ^ dword_F3268[BYTE2(v494) + 768];
    v670 = dword_F3268[BYTE2(v90) + 768];
    v479 = dword_F3268[BYTE1(v91) + 512];
    v495 = dword_F3268[BYTE2(v626) + 768];
    v99 = dword_F3268[BYTE1(v626) + 512];
    v100 = dword_F3268[(unsigned __int8)v626] ^ v644;
    v627 = v98 ^ v394;
    v654 = v96 ^ v684 ^ v614;
    v101 = dword_F3268[(unsigned __int8)v90] ^ dword_F3268[HIBYTE(v462) + 256] ^ v98 ^ v394;
    v645 = v97 ^ v580;
    v102 = dword_F3268[v95] ^ dword_F3268[HIBYTE(v90) + 256] ^ v97 ^ v580 ^ v99;
    v103 = v100 ^ v654 ^ dword_F3268[BYTE1(v462) + 512];
    v104 = v101 ^ v479 ^ v495;
    v105 = v102 ^ dword_F3268[BYTE2(v462) + 768];
    v106 = v103 ^ v670;
    v107 = dword_F3268[(unsigned __int8)v488] ^ dword_F3268[HIBYTE(v402) + 256] ^ dword_F3268[BYTE1(v422) + 512];
    v463 = &dword_F3268[HIBYTE(v105)];
    v671 = dword_F3268[BYTE1(v488) + 512]
         ^ dword_F3268[(unsigned __int8)v402]
         ^ dword_F3268[HIBYTE(v534) + 256]
         ^ dword_F3268[BYTE2(v422) + 768]
         ^ v97
         ^ v580;
    v664 = dword_F3268[(unsigned __int8)v422]
         ^ dword_F3268[HIBYTE(v488) + 256]
         ^ dword_F3268[BYTE1(v534) + 512]
         ^ dword_F3268[BYTE2(v402) + 768]
         ^ v637;
    v423 = dword_F3268[BYTE1(v402) + 512]
         ^ dword_F3268[(unsigned __int8)v534]
         ^ dword_F3268[HIBYTE(v422) + 256]
         ^ dword_F3268[BYTE2(v488) + 768]
         ^ v98
         ^ v394;
    v678 = v107 ^ dword_F3268[BYTE2(v534) + 768] ^ v654;
    v108 = dword_F3268[BYTE1(v105) + 512];
    v109 = dword_F3268[(unsigned __int8)v105];
    v690 = dword_F3268[BYTE2(v105) + 768];
    v755 = dword_F3268[BYTE2(v106) + 768];
    v110 = &dword_F3268[BYTE1(v106)];
    v767 = dword_F3268[BYTE2(v104) + 768];
    v111 = dword_F3268[HIBYTE(v106) + 256] ^ dword_F3268[(unsigned __int8)v371] ^ dword_F3268[BYTE1(v104) + 512];
    v470 = v109 ^ dword_F3268[HIBYTE(v104) + 256];
    v763 = dword_F3268[BYTE2(v371) + 768];
    v535 = dword_F3268[BYTE1(v371) + 512];
    v489 = dword_F3268[(unsigned __int8)v104] ^ dword_F3268[HIBYTE(v371) + 256] ^ v108;
    v496 = dword_F3268[(unsigned __int8)v106] ^ v463[256];
    v112 = dword_F3268[HIBYTE(v430) + 256] ^ dword_F3268[(unsigned __int8)v539] ^ dword_F3268[BYTE1(v502) + 512];
    v113 = dword_F3268[HIBYTE(v502) + 256]
         ^ dword_F3268[(unsigned __int8)v508]
         ^ dword_F3268[BYTE1(v430) + 512]
         ^ dword_F3268[BYTE2(v539) + 768];
    v403 = dword_F3268[HIBYTE(v508) + 256] ^ dword_F3268[(unsigned __int8)v430] ^ dword_F3268[BYTE1(v539) + 512];
    v431 = dword_F3268[(unsigned __int8)v502]
         ^ dword_F3268[HIBYTE(v539) + 256]
         ^ dword_F3268[BYTE1(v508) + 512]
         ^ dword_F3268[BYTE2(v430) + 768]
         ^ v664;
    v750 = v112 ^ dword_F3268[BYTE2(v508) + 768] ^ v678;
    v685 = v113 ^ v423;
    v509 = v403 ^ dword_F3268[BYTE2(v502) + 768] ^ v671;
    v404 = dword_F3268[((v671 ^ (unsigned int)v712) >> 24) + 256]
         ^ dword_F3268[(unsigned __int8)(v678 ^ v719)]
         ^ v750
         ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v664 ^ v706) >> 8) + 512]
         ^ dword_F3268[(unsigned __int8)((v423 ^ (unsigned int)v709) >> 16) + 768];
    v114 = dword_F3268[(unsigned __int8)((unsigned __int16)(v671 ^ v712) >> 8) + 512]
         ^ dword_F3268[((v664 ^ (unsigned int)v706) >> 24) + 256]
         ^ dword_F3268[(unsigned __int8)(v423 ^ v709)]
         ^ v113
         ^ v423
         ^ dword_F3268[(unsigned __int8)((v678 ^ (unsigned int)v719) >> 16) + 768];
    v372 = dword_F3268[((v678 ^ (unsigned int)v719) >> 24) + 256]
         ^ dword_F3268[(unsigned __int8)(v664 ^ v706)]
         ^ v431
         ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v423 ^ v709) >> 8) + 512]
         ^ dword_F3268[(unsigned __int8)((v671 ^ (unsigned int)v712) >> 16) + 768];
    v115 = dword_F3268[((v423 ^ (unsigned int)v709) >> 24) + 256]
         ^ dword_F3268[(unsigned __int8)(v671 ^ v712)]
         ^ v509
         ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v678 ^ v719) >> 8) + 512]
         ^ dword_F3268[(unsigned __int8)((v664 ^ (unsigned int)v706) >> 16) + 768];
    v480 = v470 ^ v110[512];
    v471 = v496 ^ v535;
    v497 = v111 ^ v690;
    v116 = dword_F3268[HIBYTE(v516) + 256] ^ dword_F3268[(unsigned __int8)v437] ^ dword_F3268[BYTE1(v594) + 512];
    v117 = dword_F3268[BYTE2(v516) + 768]
         ^ dword_F3268[HIBYTE(v437) + 256]
         ^ dword_F3268[(unsigned __int8)v594]
         ^ dword_F3268[BYTE1(v606) + 512];
    v503 = dword_F3268[HIBYTE(v606) + 256]
         ^ dword_F3268[(unsigned __int8)v516]
         ^ dword_F3268[BYTE1(v437) + 512]
         ^ dword_F3268[BYTE2(v594) + 768];
    v438 = dword_F3268[HIBYTE(v594) + 256]
         ^ dword_F3268[(unsigned __int8)v606]
         ^ dword_F3268[BYTE1(v516) + 512]
         ^ dword_F3268[BYTE2(v437) + 768];
    v595 = v116 ^ dword_F3268[BYTE2(v606) + 768] ^ v431;
    v464 = v438 ^ v509;
    v118 = dword_F3268[BYTE1(v372) + 512];
    v607 = v117 ^ v113 ^ v423;
    v691 = v503 ^ v750;
    v119 = dword_F3268[(unsigned __int8)v114]
         ^ dword_F3268[HIBYTE(v372) + 256]
         ^ v607
         ^ dword_F3268[BYTE1(v115) + 512]
         ^ dword_F3268[BYTE2(v404) + 768];
    v120 = dword_F3268[BYTE1(v404) + 512]
         ^ dword_F3268[(unsigned __int8)v115]
         ^ dword_F3268[HIBYTE(v114) + 256]
         ^ v438
         ^ v509
         ^ dword_F3268[BYTE2(v372) + 768];
    v373 = dword_F3268[HIBYTE(v404) + 256]
         ^ dword_F3268[(unsigned __int8)v372]
         ^ v595
         ^ dword_F3268[BYTE1(v114) + 512]
         ^ dword_F3268[BYTE2(v115) + 768];
    v121 = dword_F3268[HIBYTE(v115) + 256]
         ^ dword_F3268[(unsigned __int8)v404]
         ^ v503
         ^ v750
         ^ v118
         ^ dword_F3268[BYTE2(v114) + 768];
    v122 = dword_F3268[HIBYTE(v385) + 256] ^ dword_F3268[(unsigned __int8)v522] ^ dword_F3268[BYTE1(v544) + 512];
    v123 = dword_F3268[(unsigned __int8)v385]
         ^ dword_F3268[HIBYTE(v513) + 256]
         ^ dword_F3268[BYTE1(v522) + 512]
         ^ dword_F3268[BYTE2(v544) + 768];
    v124 = dword_F3268[(unsigned __int8)v513]
         ^ dword_F3268[HIBYTE(v544) + 256]
         ^ dword_F3268[BYTE1(v385) + 512]
         ^ dword_F3268[BYTE2(v522) + 768];
    v743 = v742 ^ v497;
    v746 = v745 ^ v489 ^ v755;
    v748 = v747 ^ v480 ^ v763;
    BYTE2(v115) = BYTE2(v385);
    v386 = dword_F3268[(unsigned __int8)v119]
         ^ dword_F3268[HIBYTE(v373) + 256]
         ^ dword_F3268[BYTE1(v120) + 512]
         ^ dword_F3268[BYTE2(v121) + 768];
    v741 = v740 ^ v471 ^ v767;
    v405 = dword_F3268[HIBYTE(v121) + 256]
         ^ dword_F3268[(unsigned __int8)v373]
         ^ dword_F3268[BYTE1(v119) + 512]
         ^ dword_F3268[BYTE2(v120) + 768];
    v504 = dword_F3268[(unsigned __int8)v121]
         ^ dword_F3268[HIBYTE(v120) + 256]
         ^ dword_F3268[BYTE1(v373) + 512]
         ^ dword_F3268[BYTE2(v119) + 768];
    v472 = v123 ^ v595;
    v481 = v122 ^ dword_F3268[BYTE2(v513) + 768] ^ v607;
    v540 = v124 ^ v691;
    v536 = dword_F3268[BYTE2(v115) + 768]
         ^ dword_F3268[HIBYTE(v522) + 256]
         ^ dword_F3268[(unsigned __int8)v544]
         ^ dword_F3268[BYTE1(v513) + 512]
         ^ v438
         ^ v509;
    if ( v550 == 2 )
    {
      v472 ^= v809;
      v481 ^= v795;
      v536 ^= v793;
      v540 ^= ~v794;
    }
    v125 = v746 ^ v574 ^ v464;
    v490 = v444 ^ v607;
    v126 = v743 ^ v444 ^ v607;
    v127 = v586 ^ v691;
    v128 = v748 ^ v586 ^ v691;
    v587 = v574 ^ v464;
    v129 = v741 ^ v600 ^ v472;
    v756 = v127;
    v764 = v567 ^ v444 ^ v607;
    v601 = v600 ^ v472;
    v498 = v453 ^ v481;
    v130 = dword_F3268[(unsigned __int8)v120]
         ^ dword_F3268[HIBYTE(v119) + 256]
         ^ dword_F3268[BYTE1(v121) + 512]
         ^ dword_F3268[BYTE2(v373) + 768]
         ^ v536;
    v131 = v504 ^ v540;
    v505 = v559 ^ v540;
    v439 = dword_F3268[BYTE2(v128) + 768]
         ^ dword_F3268[BYTE1(v125) + 512]
         ^ dword_F3268[(unsigned __int8)v126]
         ^ v453
         ^ v481
         ^ dword_F3268[HIBYTE(v129) + 256];
    v454 = dword_F3268[HIBYTE(v128) + 256]
         ^ v764
         ^ dword_F3268[BYTE1(v126) + 512]
         ^ dword_F3268[BYTE2(v125) + 768]
         ^ dword_F3268[(unsigned __int8)v129];
    v374 = v527 ^ v536;
    v132 = dword_F3268[BYTE1(v128) + 512]
         ^ dword_F3268[HIBYTE(v126) + 256]
         ^ dword_F3268[(unsigned __int8)v125]
         ^ v527
         ^ v536
         ^ dword_F3268[BYTE2(v129) + 768];
    v445 = dword_F3268[(unsigned __int8)v128]
         ^ dword_F3268[HIBYTE(v125) + 256]
         ^ dword_F3268[BYTE2(v126) + 768]
         ^ v559
         ^ v540
         ^ dword_F3268[BYTE1(v129) + 512];
    v528 = dword_F3268[((v405 ^ (unsigned int)v472) >> 24) + 256];
    v133 = (unsigned __int8)(v386 ^ v481);
    v523 = dword_F3268[(unsigned __int8)((unsigned __int16)(v386 ^ v481) >> 8) + 512];
    v545 = v394 ^ v127;
    v575 = dword_F3268[(unsigned __int8)((unsigned __int16)(v405 ^ v472) >> 8) + 512];
    v134 = dword_F3268[(unsigned __int8)((v386 ^ (unsigned int)v481) >> 16) + 768];
    v395 = v614 ^ v498;
    v135 = dword_F3268[((v386 ^ (unsigned int)v481) >> 24) + 256] ^ dword_F3268[(unsigned __int8)v130];
    v136 = dword_F3268[(unsigned __int8)((v405 ^ (unsigned int)v472) >> 16) + 768];
    v387 = v412 ^ v587;
    v137 = dword_F3268[(unsigned __int8)(v405 ^ v472)];
    v778 = v134;
    v406 = v637 ^ v374;
    v615 = v580 ^ v601;
    v517 = v423 ^ v580 ^ v601;
    v424 = v137;
    v138 = dword_F3268[HIBYTE(v439) + 256]
         ^ v545
         ^ dword_F3268[(unsigned __int8)v132]
         ^ dword_F3268[BYTE2(v454) + 768]
         ^ dword_F3268[BYTE1(v445) + 512];
    v139 = dword_F3268[HIBYTE(v454) + 256]
         ^ dword_F3268[(unsigned __int8)v439]
         ^ v412
         ^ v587
         ^ dword_F3268[BYTE1(v132) + 512]
         ^ dword_F3268[BYTE2(v445) + 768];
    v140 = dword_F3268[(unsigned __int8)v454]
         ^ v395
         ^ dword_F3268[BYTE1(v439) + 512]
         ^ dword_F3268[HIBYTE(v445) + 256]
         ^ dword_F3268[BYTE2(v132) + 768];
    v141 = dword_F3268[BYTE1(v454) + 512]
         ^ dword_F3268[(unsigned __int8)v445]
         ^ v580
         ^ v601
         ^ dword_F3268[BYTE2(v439) + 768]
         ^ dword_F3268[HIBYTE(v132) + 256];
    v142 = v637 ^ v374;
    v638 = v727 ^ dword_F3268[v133] ^ v528 ^ dword_F3268[BYTE1(v130) + 512] ^ dword_F3268[BYTE2(v131) + 768];
    v143 = v135 ^ dword_F3268[BYTE1(v131) + 512] ^ v136;
    v144 = v424 ^ dword_F3268[HIBYTE(v131) + 256];
    v145 = dword_F3268[(unsigned __int8)v131] ^ dword_F3268[HIBYTE(v130) + 256] ^ v575 ^ v778;
    v568 = v678 ^ v142;
    v425 = v671 ^ v395;
    v672 = v731 ^ v143;
    v679 = v736 ^ v145;
    v529 = dword_F3268[BYTE1(v141) + 512];
    v455 = dword_F3268[(unsigned __int8)v139]
         ^ v142
         ^ dword_F3268[BYTE1(v138) + 512]
         ^ dword_F3268[HIBYTE(v140) + 256]
         ^ dword_F3268[BYTE2(v141) + 768];
    v732 = dword_F3268[HIBYTE(v141) + 256];
    v514 = v664 ^ v545;
    v665 = v723 ^ v144 ^ v523 ^ dword_F3268[BYTE2(v130) + 768];
    v146 = v645;
    v646 = dword_F3268[BYTE2(v138) + 768];
    v147 = v509;
    v560 = v654 ^ v412 ^ v587;
    v510 = v146 ^ v764;
    v148 = v146 ^ v764 ^ dword_F3268[HIBYTE(v138) + 256] ^ dword_F3268[(unsigned __int8)v141];
    v446 = v147 ^ v560;
    v655 = dword_F3268[(unsigned __int8)v455];
    v413 = v627 ^ v505;
    v576 = v750 ^ v514;
    v432 = v431 ^ v627 ^ v505;
    v149 = dword_F3268[(unsigned __int8)v138]
         ^ dword_F3268[HIBYTE(v139) + 256]
         ^ v627
         ^ v505
         ^ v529
         ^ dword_F3268[BYTE2(v140) + 768];
    v150 = v148 ^ dword_F3268[BYTE2(v139) + 768] ^ dword_F3268[BYTE1(v140) + 512];
    v151 = dword_F3268[BYTE1(v139) + 512] ^ dword_F3268[(unsigned __int8)v140] ^ v560 ^ v646 ^ v732;
    v628 = dword_F3268[((v638 ^ v517) >> 24) + 256]
         ^ dword_F3268[(unsigned __int8)(v672 ^ v425)]
         ^ v147
         ^ v560
         ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v736 ^ v145 ^ v568) >> 8) + 512]
         ^ dword_F3268[(unsigned __int8)((v665 ^ v514) >> 16) + 768];
    v440 = v685 ^ v146 ^ v764;
    v152 = dword_F3268[(unsigned __int8)((v638 ^ v517) >> 16) + 768]
         ^ dword_F3268[(unsigned __int8)(v736 ^ v145 ^ v568)]
         ^ dword_F3268[((v672 ^ v425) >> 24) + 256]
         ^ v750
         ^ v514
         ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v665 ^ v514) >> 8) + 512];
    v728 = &dword_F3268[HIBYTE(v455)];
    v153 = &dword_F3268[BYTE1(v455)];
    v154 = dword_F3268[((v736 ^ v145 ^ v568) >> 24) + 256]
         ^ dword_F3268[(unsigned __int8)(v665 ^ v514)]
         ^ v432
         ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v638 ^ v517) >> 8) + 512]
         ^ dword_F3268[(unsigned __int8)((v672 ^ v425) >> 16) + 768];
    v773 = dword_F3268[BYTE2(v150) + 768];
    v155 = dword_F3268[(unsigned __int8)(v638 ^ v517)]
         ^ dword_F3268[((v665 ^ v514) >> 24) + 256]
         ^ v440
         ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v672 ^ v425) >> 8) + 512]
         ^ dword_F3268[(unsigned __int8)((v736 ^ v145 ^ v568) >> 16) + 768];
    v737 = &dword_F3268[BYTE2(v455)];
    v724 = dword_F3268[BYTE1(v149) + 512];
    v524 = v691 ^ v432;
    v456 = v595 ^ v517;
    v647 = v607 ^ v425;
    v581 = v464 ^ v568;
    v786 = dword_F3268[BYTE2(v149) + 768];
    v465 = v472 ^ v440;
    v783 = dword_F3268[HIBYTE(v149) + 256];
    v530 = v481 ^ v446;
    v692 = dword_F3268[(unsigned __int8)v149];
    v473 = v536 ^ v750 ^ v514;
    v482 = v540 ^ v595 ^ v517;
    v733 = dword_F3268[BYTE2(v151) + 768];
    v751 = v719 ^ dword_F3268[(unsigned __int8)v151] ^ v153[512];
    v608 = v728[256];
    v713 = v712 ^ dword_F3268[(unsigned __int8)v150] ^ dword_F3268[BYTE1(v151) + 512];
    v156 = dword_F3268[(unsigned __int8)v152]
         ^ dword_F3268[HIBYTE(v628) + 256]
         ^ v524
         ^ dword_F3268[BYTE1(v154) + 512]
         ^ dword_F3268[BYTE2(v155) + 768];
    v157 = dword_F3268[BYTE2(v628) + 768]
         ^ dword_F3268[HIBYTE(v152) + 256]
         ^ dword_F3268[(unsigned __int8)v154]
         ^ v595
         ^ v517
         ^ dword_F3268[BYTE1(v155) + 512];
    v158 = dword_F3268[BYTE2(v152) + 768]
         ^ dword_F3268[HIBYTE(v154) + 256]
         ^ dword_F3268[(unsigned __int8)v155]
         ^ v647
         ^ dword_F3268[BYTE1(v628) + 512];
    v159 = dword_F3268[HIBYTE(v155) + 256]
         ^ dword_F3268[(unsigned __int8)v628]
         ^ v581
         ^ dword_F3268[BYTE1(v152) + 512]
         ^ dword_F3268[BYTE2(v154) + 768];
    v537 = dword_F3268[(unsigned __int8)v157]
         ^ dword_F3268[HIBYTE(v156) + 256]
         ^ v465
         ^ dword_F3268[BYTE1(v158) + 512]
         ^ dword_F3268[BYTE2(v159) + 768];
    v596 = dword_F3268[(unsigned __int8)v156]
         ^ dword_F3268[HIBYTE(v159) + 256]
         ^ v482
         ^ dword_F3268[BYTE1(v157) + 512]
         ^ dword_F3268[BYTE2(v158) + 768];
    v160 = v587;
    v541 = dword_F3268[HIBYTE(v157) + 256]
         ^ dword_F3268[(unsigned __int8)v158]
         ^ v530
         ^ dword_F3268[BYTE1(v159) + 512]
         ^ dword_F3268[BYTE2(v156) + 768];
    v588 = dword_F3268[(unsigned __int8)v159]
         ^ dword_F3268[HIBYTE(v158) + 256]
         ^ v473
         ^ dword_F3268[BYTE1(v156) + 512]
         ^ dword_F3268[BYTE2(v157) + 768];
    v729 = dword_F3268[(unsigned __int8)v537];
    v161 = v709 ^ v608 ^ v692;
    v162 = dword_F3268[BYTE2(v756) + 768];
    v609 = v655 ^ dword_F3268[HIBYTE(v151) + 256];
    v686 = dword_F3268[BYTE1(v756) + 512];
    v163 = dword_F3268[HIBYTE(v160) + 256] ^ dword_F3268[(unsigned __int8)v756] ^ dword_F3268[BYTE2(v490) + 768];
    v164 = dword_F3268[BYTE1(v490) + 512] ^ dword_F3268[BYTE2(v160) + 768] ^ dword_F3268[HIBYTE(v756) + 256];
    v757 = dword_F3268[BYTE1(v601) + 512];
    v165 = v162 ^ dword_F3268[BYTE1(v160) + 512] ^ dword_F3268[(unsigned __int8)v490] ^ dword_F3268[HIBYTE(v601) + 256];
    v789 = dword_F3268[BYTE2(v601) + 768];
    v166 = v161 ^ v733;
    v167 = (unsigned __int8)v588;
    v734 = dword_F3268[HIBYTE(v596) + 256];
    v168 = v706 ^ v609;
    v710 = v751 ^ dword_F3268[HIBYTE(v150) + 256] ^ v786;
    v610 = (unsigned __int8)v541;
    v707 = v713 ^ v737[768] ^ v783;
    v693 = v166 ^ dword_F3268[BYTE1(v150) + 512];
    v629 = dword_F3268[HIBYTE(v537) + 256];
    v720 = dword_F3268[HIBYTE(v588) + 256];
    v169 = v164 ^ v473 ^ dword_F3268[(unsigned __int8)v601];
    v170 = dword_F3268[HIBYTE(v541) + 256];
    v602 = v169;
    v171 = &dword_F3268[BYTE2(v541)];
    v738 = dword_F3268[BYTE1(v541) + 512];
    v172 = dword_F3268[HIBYTE(v490) + 256] ^ dword_F3268[(unsigned __int8)v160] ^ v686;
    v768 = dword_F3268[BYTE2(v588) + 768];
    v656 = dword_F3268[BYTE1(v588) + 512];
    v589 = v482 ^ v165;
    v542 = v163 ^ v530 ^ v757;
    v173 = dword_F3268[v167] ^ v170;
    v174 = v764;
    v752 = dword_F3268[BYTE1(v596) + 512];
    v779 = dword_F3268[BYTE2(v596) + 768];
    v758 = dword_F3268[BYTE1(v537) + 512];
    v175 = (unsigned __int8)v764;
    v176 = v773;
    v774 = v171[768];
    v687 = v168 ^ v724 ^ v176;
    v714 = dword_F3268[(unsigned __int8)v596];
    v765 = dword_F3268[BYTE2(v537) + 768];
    v701 = v700 ^ v173;
    v491 = v172 ^ v465 ^ v789;
    v177 = dword_F3268[v175] ^ dword_F3268[HIBYTE(v505) + 256];
    v178 = BYTE1(v374);
    v179 = &dword_F3268[BYTE2(v505)];
    v180 = dword_F3268[(unsigned __int8)v505]
         ^ dword_F3268[HIBYTE(v374) + 256]
         ^ dword_F3268[BYTE1(v174) + 512]
         ^ dword_F3268[BYTE2(v498) + 768];
    v181 = dword_F3268[(unsigned __int8)v374]
         ^ dword_F3268[HIBYTE(v498) + 256]
         ^ dword_F3268[BYTE2(v174) + 768]
         ^ dword_F3268[BYTE1(v505) + 512];
    v506 = v177 ^ v169 ^ dword_F3268[BYTE1(v498) + 512] ^ dword_F3268[BYTE2(v374) + 768];
    v375 = v181 ^ v491;
    v182 = dword_F3268[(unsigned __int8)v498] ^ dword_F3268[HIBYTE(v174) + 256] ^ dword_F3268[v178 + 512];
    v499 = v180 ^ v542;
    v538 = v179[768] ^ v182 ^ v589;
    v183 = dword_F3268[v610] ^ v629;
    v184 = dword_F3268[(unsigned __int8)((unsigned __int16)(v707 ^ v169) >> 8) + 512]
         ^ dword_F3268[(unsigned __int8)(v693 ^ v542)]
         ^ v180
         ^ v542
         ^ dword_F3268[(unsigned __int8)((v710 ^ (unsigned int)v589) >> 16) + 768]
         ^ dword_F3268[((v687 ^ (unsigned int)v491) >> 24) + 256];
    v597 = dword_F3268[((v693 ^ (unsigned int)v542) >> 24) + 256]
         ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v710 ^ v589) >> 8) + 512]
         ^ v506
         ^ dword_F3268[(unsigned __int8)(v707 ^ v169)]
         ^ dword_F3268[(unsigned __int8)((v687 ^ (unsigned int)v491) >> 16) + 768];
    v185 = v545;
    v546 = dword_F3268[((v710 ^ (unsigned int)v589) >> 24) + 256]
         ^ v181
         ^ v491
         ^ dword_F3268[(unsigned __int8)(v687 ^ v491)]
         ^ dword_F3268[(unsigned __int8)((v707 ^ (unsigned int)v169) >> 16) + 768]
         ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v693 ^ v542) >> 8) + 512];
    v630 = dword_F3268[((v707 ^ (unsigned int)v169) >> 24) + 256]
         ^ dword_F3268[(unsigned __int8)(v710 ^ v589)]
         ^ v538
         ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v687 ^ v491) >> 8) + 512]
         ^ dword_F3268[(unsigned __int8)((v693 ^ (unsigned int)v542) >> 16) + 768];
    v657 = v183 ^ v697 ^ v656;
    v725 = v714 ^ v720;
    v186 = dword_F3268[BYTE1(v185) + 512]
         ^ dword_F3268[(unsigned __int8)v387]
         ^ dword_F3268[HIBYTE(v395) + 256]
         ^ dword_F3268[BYTE2(v615) + 768];
    v187 = dword_F3268[HIBYTE(v387) + 256]
         ^ dword_F3268[(unsigned __int8)v185]
         ^ dword_F3268[BYTE1(v615) + 512]
         ^ dword_F3268[BYTE2(v395) + 768];
    v188 = dword_F3268[BYTE2(v387) + 768]
         ^ dword_F3268[HIBYTE(v185) + 256]
         ^ dword_F3268[(unsigned __int8)v615]
         ^ dword_F3268[BYTE1(v395) + 512];
    v189 = dword_F3268[HIBYTE(v597) + 256];
    v190 = dword_F3268[BYTE1(v387) + 512] ^ dword_F3268[BYTE2(v185) + 768];
    v388 = dword_F3268[HIBYTE(v184) + 256];
    v191 = &dword_F3268[HIBYTE(v615)];
    v616 = dword_F3268[BYTE2(v184) + 768];
    v192 = dword_F3268[BYTE1(v184) + 512] ^ dword_F3268[(unsigned __int8)v546];
    v193 = dword_F3268[(unsigned __int8)v395];
    v396 = v188 ^ v499;
    v194 = dword_F3268[(unsigned __int8)v184];
    v195 = dword_F3268[BYTE1(v597) + 512];
    v196 = (unsigned __int8)v597;
    v611 = v186 ^ v538;
    v197 = &dword_F3268[BYTE2(v597)];
    v598 = v187 ^ v375;
    v198 = v190 ^ v193 ^ v191[256];
    v199 = dword_F3268[v196];
    v200 = dword_F3268[BYTE2(v546) + 768];
    v201 = v194 ^ v188 ^ v499 ^ v195 ^ dword_F3268[HIBYTE(v546) + 256] ^ dword_F3268[BYTE2(v630) + 768];
    v202 = v189 ^ v611 ^ dword_F3268[(unsigned __int8)v630] ^ v616 ^ dword_F3268[BYTE1(v546) + 512];
    v547 = v506 ^ v198;
    v203 = v192 ^ v187 ^ v375 ^ v197[768] ^ dword_F3268[HIBYTE(v630) + 256];
    v204 = v200 ^ dword_F3268[BYTE1(v630) + 512] ^ v199 ^ v388 ^ v506 ^ v198;
    v715 = v187
         ^ v375
         ^ dword_F3268[BYTE1(v510) + 512]
         ^ dword_F3268[BYTE2(v560) + 768]
         ^ dword_F3268[(unsigned __int8)v413]
         ^ dword_F3268[HIBYTE(v406) + 256];
    v389 = dword_F3268[(unsigned __int8)v203]
         ^ v715
         ^ dword_F3268[BYTE1(v201) + 512]
         ^ dword_F3268[HIBYTE(v202) + 256]
         ^ dword_F3268[BYTE2(v204) + 768];
    v617 = dword_F3268[(unsigned __int8)v560]
         ^ dword_F3268[HIBYTE(v510) + 256]
         ^ dword_F3268[BYTE1(v406) + 512]
         ^ dword_F3268[BYTE2(v413) + 768]
         ^ v506
         ^ v198;
    v205 = dword_F3268[(unsigned __int8)v406]
         ^ dword_F3268[BYTE2(v510) + 768]
         ^ dword_F3268[HIBYTE(v560) + 256]
         ^ dword_F3268[BYTE1(v413) + 512];
    v206 = dword_F3268[BYTE2(v201) + 768];
    v207 = dword_F3268[BYTE2(v203) + 768] ^ v617 ^ dword_F3268[HIBYTE(v201) + 256] ^ dword_F3268[(unsigned __int8)v204];
    v511 = dword_F3268[(unsigned __int8)v510]
         ^ dword_F3268[BYTE1(v560) + 512]
         ^ dword_F3268[HIBYTE(v413) + 256]
         ^ dword_F3268[BYTE2(v406) + 768]
         ^ v396;
    v784 = dword_F3268[(unsigned __int8)v389];
    v721 = v205 ^ v611;
    v208 = dword_F3268[BYTE1(v204) + 512]
         ^ dword_F3268[HIBYTE(v203) + 256]
         ^ dword_F3268[(unsigned __int8)v201]
         ^ v511
         ^ dword_F3268[BYTE2(v202) + 768];
    v209 = v207 ^ dword_F3268[BYTE1(v202) + 512];
    v407 = v206
         ^ dword_F3268[BYTE1(v203) + 512]
         ^ dword_F3268[(unsigned __int8)v202]
         ^ v205
         ^ v611
         ^ dword_F3268[HIBYTE(v204) + 256];
    v210 = dword_F3268[(unsigned __int8)v568] ^ dword_F3268[HIBYTE(v425) + 256] ^ dword_F3268[BYTE1(v514) + 512];
    v561 = dword_F3268[BYTE2(v517) + 768];
    v787 = dword_F3268[BYTE2(v568) + 768];
    v698 = v657 ^ v779;
    v211 = &dword_F3268[BYTE1(v425)];
    v212 = dword_F3268[(unsigned __int8)v517];
    v213 = dword_F3268[BYTE2(v425) + 768];
    v426 = dword_F3268[HIBYTE(v517) + 256]
         ^ dword_F3268[(unsigned __int8)v425]
         ^ dword_F3268[BYTE2(v514) + 768]
         ^ dword_F3268[BYTE1(v568) + 512]
         ^ v511;
    v214 = dword_F3268[(unsigned __int8)v514] ^ dword_F3268[HIBYTE(v568) + 256] ^ dword_F3268[BYTE1(v517) + 512];
    v518 = v211[512];
    v215 = v210 ^ v561;
    v216 = v212 ^ dword_F3268[HIBYTE(v514) + 256];
    v562 = dword_F3268[HIBYTE(v407) + 256];
    v702 = v701 ^ v752 ^ v765;
    v217 = v704 ^ v725 ^ v758;
    v726 = dword_F3268[BYTE2(v407) + 768];
    v515 = v215 ^ v617;
    v218 = v729 ^ v734 ^ v694 ^ v738;
    v219 = (unsigned __int8)v407;
    v569 = dword_F3268[BYTE1(v208) + 512];
    v220 = v216 ^ v518;
    v780 = dword_F3268[BYTE1(v209) + 512];
    v705 = v217 ^ v774;
    v519 = v214 ^ v213 ^ v205 ^ v611;
    v730 = dword_F3268[BYTE1(v407) + 512];
    v735 = dword_F3268[BYTE2(v389) + 768];
    v408 = v220 ^ v787 ^ v715;
    v759 = dword_F3268[BYTE1(v389) + 512];
    v221 = v218 ^ v768;
    v390 = v638 ^ dword_F3268[HIBYTE(v389) + 256];
    v769 = dword_F3268[HIBYTE(v208) + 256];
    v788 = dword_F3268[BYTE2(v208) + 768];
    v695 = v221;
    v739 = v679 ^ dword_F3268[v219];
    v639 = dword_F3268[HIBYTE(v446) + 256]
         ^ dword_F3268[(unsigned __int8)v576]
         ^ dword_F3268[BYTE2(v440) + 768]
         ^ dword_F3268[BYTE1(v432) + 512]
         ^ v215
         ^ v617;
    v631 = v408
         ^ dword_F3268[BYTE2(v576) + 768]
         ^ dword_F3268[BYTE1(v446) + 512]
         ^ dword_F3268[(unsigned __int8)v440]
         ^ dword_F3268[HIBYTE(v432) + 256];
    v222 = dword_F3268[(unsigned __int8)((unsigned __int16)(v217 ^ v774 ^ v519) >> 8) + 512]
         ^ dword_F3268[(unsigned __int8)(v702 ^ v215 ^ v617)]
         ^ dword_F3268[((v698 ^ (unsigned int)v426) >> 24) + 256]
         ^ v639
         ^ dword_F3268[(unsigned __int8)((v221 ^ (unsigned int)v408) >> 16) + 768];
    v753 = v519
         ^ dword_F3268[(unsigned __int8)v432]
         ^ dword_F3268[BYTE1(v440) + 512]
         ^ dword_F3268[BYTE2(v446) + 768]
         ^ dword_F3268[HIBYTE(v576) + 256];
    v680 = dword_F3268[(unsigned __int8)v446]
         ^ dword_F3268[HIBYTE(v440) + 256]
         ^ dword_F3268[BYTE1(v576) + 512]
         ^ dword_F3268[BYTE2(v432) + 768]
         ^ v426;
    v223 = dword_F3268[(unsigned __int8)((v698 ^ (unsigned int)v426) >> 16) + 768]
         ^ dword_F3268[((v702 ^ v215 ^ (unsigned int)v617) >> 24) + 256]
         ^ dword_F3268[(unsigned __int8)(v217 ^ v774 ^ v519)]
         ^ v753
         ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v695 ^ v408) >> 8) + 512];
    v224 = dword_F3268[((v695 ^ (unsigned int)v408) >> 24) + 256]
         ^ dword_F3268[(unsigned __int8)(v698 ^ v426)]
         ^ v680
         ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v702 ^ v215 ^ v617) >> 8) + 512]
         ^ dword_F3268[(unsigned __int8)((v217 ^ v774 ^ (unsigned int)v519) >> 16) + 768];
    v225 = dword_F3268[(unsigned __int8)((v702 ^ v215 ^ (unsigned int)v617) >> 16) + 768]
         ^ dword_F3268[((v217 ^ v774 ^ (unsigned int)v519) >> 24) + 256]
         ^ dword_F3268[(unsigned __int8)(v695 ^ v408)]
         ^ v631
         ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v698 ^ v426) >> 8) + 512];
    v441 = dword_F3268[(unsigned __int8)v456]
         ^ dword_F3268[HIBYTE(v524) + 256]
         ^ dword_F3268[BYTE1(v647) + 512]
         ^ dword_F3268[BYTE2(v581) + 768]
         ^ v753;
    v433 = v390 ^ dword_F3268[(unsigned __int8)v208];
    v226 = dword_F3268[HIBYTE(v647) + 256] ^ dword_F3268[(unsigned __int8)v581] ^ dword_F3268[BYTE1(v524) + 512];
    v227 = dword_F3268[(unsigned __int8)v524] ^ dword_F3268[HIBYTE(v581) + 256];
    v525 = dword_F3268[(unsigned __int8)v647]
         ^ dword_F3268[HIBYTE(v456) + 256]
         ^ dword_F3268[BYTE1(v581) + 512]
         ^ dword_F3268[BYTE2(v524) + 768]
         ^ v631;
    v414 = dword_F3268[(unsigned __int8)v223]
         ^ dword_F3268[HIBYTE(v222) + 256]
         ^ v441
         ^ dword_F3268[BYTE1(v225) + 512]
         ^ dword_F3268[BYTE2(v224) + 768];
    v391 = v226 ^ dword_F3268[BYTE2(v456) + 768] ^ v680;
    v228 = dword_F3268[(unsigned __int8)v225]
         ^ dword_F3268[HIBYTE(v223) + 256]
         ^ v525
         ^ dword_F3268[BYTE1(v224) + 512]
         ^ dword_F3268[BYTE2(v222) + 768];
    v648 = dword_F3268[BYTE1(v456) + 512] ^ v227 ^ dword_F3268[BYTE2(v647) + 768] ^ v639;
    v229 = dword_F3268[HIBYTE(v224) + 256]
         ^ dword_F3268[(unsigned __int8)v222]
         ^ v648
         ^ dword_F3268[BYTE1(v223) + 512]
         ^ dword_F3268[BYTE2(v225) + 768];
    v447 = v730 ^ dword_F3268[(unsigned __int8)v209] ^ v672;
    v457 = dword_F3268[BYTE1(v222) + 512]
         ^ dword_F3268[HIBYTE(v225) + 256]
         ^ dword_F3268[(unsigned __int8)v224]
         ^ v391
         ^ dword_F3268[BYTE2(v223) + 768];
    v658 = dword_F3268[(unsigned __int8)v530]
         ^ dword_F3268[HIBYTE(v465) + 256]
         ^ dword_F3268[BYTE1(v473) + 512]
         ^ dword_F3268[BYTE2(v482) + 768]
         ^ v525;
    v230 = v433 ^ v726;
    v727 = v433 ^ v726 ^ v780;
    v736 = v739 ^ v759 ^ dword_F3268[HIBYTE(v209) + 256] ^ v788;
    v599 = v602 ^ v441;
    v731 = v447 ^ v735 ^ v769;
    v573 = v542 ^ v648;
    v443 = v589 ^ v658;
    v723 = v784 ^ v562 ^ v665 ^ v569 ^ dword_F3268[BYTE2(v209) + 768];
    v434 = dword_F3268[HIBYTE(v414) + 256]
         ^ dword_F3268[(unsigned __int8)v228]
         ^ v658
         ^ dword_F3268[BYTE1(v457) + 512]
         ^ dword_F3268[BYTE2(v229) + 768];
    v585 = v491 ^ v391;
    v231 = dword_F3268[(unsigned __int8)v465] ^ dword_F3268[BYTE1(v530) + 512] ^ dword_F3268[BYTE2(v473) + 768];
    v232 = dword_F3268[BYTE1(v465) + 512] ^ dword_F3268[BYTE2(v530) + 768];
    v233 = dword_F3268[(unsigned __int8)v473] ^ dword_F3268[HIBYTE(v530) + 256] ^ dword_F3268[BYTE2(v465) + 768];
    v234 = dword_F3268[HIBYTE(v473) + 256];
    v474 = dword_F3268[BYTE1(v228) + 512];
    v235 = dword_F3268[BYTE2(v228) + 768];
    v236 = v441 ^ v231 ^ dword_F3268[HIBYTE(v482) + 256];
    v775 = dword_F3268[BYTE2(v457) + 768];
    v526 = v506 ^ v236;
    v760 = v236;
    v237 = dword_F3268[(unsigned __int8)v457] ^ dword_F3268[HIBYTE(v228) + 256];
    v673 = v648 ^ v232 ^ v234 ^ dword_F3268[(unsigned __int8)v482];
    v666 = v233 ^ dword_F3268[BYTE1(v482) + 512] ^ v391;
    v238 = dword_F3268[(unsigned __int8)v229] ^ dword_F3268[HIBYTE(v457) + 256] ^ v673;
    v558 = v375 ^ v666;
    v452 = v499 ^ v673;
    v566 = v538 ^ v491 ^ v391;
    v239 = dword_F3268[(unsigned __int8)v414] ^ dword_F3268[HIBYTE(v229) + 256] ^ v236 ^ v474 ^ v775;
    v240 = v238 ^ dword_F3268[BYTE1(v414) + 512] ^ v235;
    v241 = v237 ^ v666 ^ dword_F3268[BYTE1(v229) + 512] ^ dword_F3268[BYTE2(v414) + 768];
    v242 = dword_F3268[((v723 ^ v491 ^ (unsigned int)v391) >> 24) + 256]
         ^ dword_F3268[(unsigned __int8)(v230 ^ v780 ^ v542 ^ v648)]
         ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v731 ^ v599) >> 8) + 512]
         ^ v499
         ^ v673
         ^ dword_F3268[(unsigned __int8)((v736 ^ v443) >> 16) + 768];
    v475 = dword_F3268[(unsigned __int8)(v731 ^ v599)]
         ^ v506
         ^ v236
         ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v736 ^ v443) >> 8) + 512]
         ^ dword_F3268[((v230 ^ v780 ^ v542 ^ (unsigned int)v648) >> 24) + 256]
         ^ dword_F3268[(unsigned __int8)((v723 ^ v491 ^ (unsigned int)v391) >> 16) + 768];
    v243 = dword_F3268[(unsigned __int8)((v230 ^ v780 ^ v542 ^ (unsigned int)v648) >> 16) + 768];
    v376 = dword_F3268[(unsigned __int8)(v723 ^ v491 ^ v391)]
         ^ v375
         ^ v666
         ^ dword_F3268[((v736 ^ v443) >> 24) + 256]
         ^ dword_F3268[(unsigned __int8)((v731 ^ v599) >> 16) + 768];
    v244 = dword_F3268[(unsigned __int8)(v736 ^ v443)]
         ^ dword_F3268[((v731 ^ v599) >> 24) + 256]
         ^ v538
         ^ v585
         ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v723 ^ v585) >> 8) + 512];
    v781 = dword_F3268[BYTE2(v240) + 768];
    v543 = dword_F3268[BYTE1(v240) + 512];
    v492 = dword_F3268[BYTE1(v241) + 512];
    v245 = v376 ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v727 ^ v573) >> 8) + 512];
    v377 = v243 ^ v244;
    v246 = dword_F3268[HIBYTE(v241) + 256] ^ dword_F3268[(unsigned __int8)v240];
    v393 = v396 ^ v599;
    v411 = v611 ^ v558;
    v461 = v598 ^ v573;
    v579 = v547 ^ v443;
    v507 = dword_F3268[BYTE2(v241) + 768];
    v247 = dword_F3268[HIBYTE(v240) + 256] ^ dword_F3268[(unsigned __int8)v239];
    v483 = dword_F3268[(unsigned __int8)v241] ^ dword_F3268[HIBYTE(v434) + 256];
    v248 = dword_F3268[((v243 ^ (unsigned int)v244) >> 24) + 256];
    v249 = dword_F3268[(unsigned __int8)v245]
         ^ dword_F3268[BYTE1(v242) + 512]
         ^ v598
         ^ v573
         ^ dword_F3268[BYTE2(v475) + 768];
    v250 = dword_F3268[(unsigned __int8)((unsigned __int16)(v243 ^ v244) >> 8) + 512];
    v251 = dword_F3268[BYTE1(v475) + 512]
         ^ v393
         ^ dword_F3268[(unsigned __int8)v242]
         ^ dword_F3268[HIBYTE(v245) + 256]
         ^ dword_F3268[BYTE2(v377) + 768];
    v378 = dword_F3268[HIBYTE(v475) + 256]
         ^ v611
         ^ v558
         ^ dword_F3268[(unsigned __int8)v377]
         ^ dword_F3268[BYTE2(v242) + 768]
         ^ dword_F3268[BYTE1(v245) + 512];
    v252 = v249 ^ v248;
    v253 = dword_F3268[(unsigned __int8)v475]
         ^ dword_F3268[HIBYTE(v242) + 256]
         ^ v547
         ^ v443
         ^ v250
         ^ dword_F3268[BYTE2(v245) + 768];
    v494 = v715 ^ v452;
    v254 = dword_F3268[(unsigned __int8)v434] ^ dword_F3268[HIBYTE(v239) + 256] ^ v743 ^ v492;
    v488 = v408 ^ v393;
    v422 = v426 ^ v547 ^ v443;
    v402 = v519 ^ v715 ^ v452;
    v534 = v515 ^ v411;
    v742 = v254 ^ v781;
    v747 = v246 ^ v748 ^ dword_F3268[BYTE1(v239) + 512] ^ dword_F3268[BYTE2(v434) + 768];
    v740 = v247 ^ v741 ^ dword_F3268[BYTE1(v434) + 512] ^ v507;
    v745 = v483 ^ v746 ^ v543 ^ dword_F3268[BYTE2(v239) + 768];
    v255 = v715
         ^ v452
         ^ dword_F3268[(unsigned __int8)(v249 ^ v248)]
         ^ dword_F3268[BYTE1(v251) + 512]
         ^ dword_F3268[HIBYTE(v378) + 256];
    v256 = v254 ^ v781 ^ v488;
    v520 = v747 ^ v515 ^ v611 ^ v558;
    v716 = dword_F3268[(unsigned __int8)v253];
    v612 = dword_F3268[BYTE1(v253) + 512];
    v257 = (unsigned __int8)v378;
    v548 = v255 ^ dword_F3268[BYTE2(v253) + 768];
    v770 = dword_F3268[HIBYTE(v253) + 256];
    v258 = &dword_F3268[BYTE1(v378)];
    v435 = &dword_F3268[BYTE2(v378)];
    v477 = v721 ^ v598 ^ v573;
    v370 = v617 ^ v566;
    v618 = v435[768];
    v469 = v511 ^ v526;
    v430 = v753 ^ v488;
    v259 = dword_F3268[BYTE1(v252) + 512] ^ dword_F3268[v257];
    v508 = v639 ^ v477;
    v260 = v680;
    v681 = dword_F3268[(unsigned __int8)v548];
    v502 = v260 ^ v370;
    v539 = v631 ^ v469;
    v261 = dword_F3268[BYTE2(v256) + 768]
         ^ dword_F3268[((v745 ^ v422) >> 24) + 256]
         ^ dword_F3268[(unsigned __int8)v520]
         ^ v639
         ^ v477
         ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v740 ^ v402) >> 8) + 512];
    v262 = dword_F3268[(unsigned __int8)((v745 ^ v422) >> 16) + 768]
         ^ dword_F3268[HIBYTE(v520) + 256]
         ^ dword_F3268[(unsigned __int8)(v740 ^ v402)]
         ^ v753
         ^ v488
         ^ dword_F3268[BYTE1(v256) + 512];
    v263 = dword_F3268[(unsigned __int8)((v740 ^ v402) >> 16) + 768]
         ^ dword_F3268[HIBYTE(v256) + 256]
         ^ dword_F3268[(unsigned __int8)(v745 ^ v422)]
         ^ v260
         ^ v370
         ^ dword_F3268[BYTE1(v520) + 512];
    v264 = v259 ^ v477 ^ dword_F3268[BYTE2(v251) + 768] ^ v770;
    v265 = v618;
    v619 = dword_F3268[HIBYTE(v251) + 256] ^ v370 ^ v716 ^ dword_F3268[BYTE2(v252) + 768] ^ v258[512];
    v266 = dword_F3268[(unsigned __int8)v251] ^ dword_F3268[HIBYTE(v252) + 256] ^ v469 ^ v612 ^ v265;
    v632 = dword_F3268[((v740 ^ v402) >> 24) + 256]
         ^ dword_F3268[(unsigned __int8)v256]
         ^ v631
         ^ v469
         ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v745 ^ v422) >> 8) + 512]
         ^ dword_F3268[BYTE2(v520) + 768];
    v782 = dword_F3268[HIBYTE(v266) + 256];
    v766 = dword_F3268[(unsigned __int8)v264];
    v267 = dword_F3268[HIBYTE(v264) + 256];
    v640 = dword_F3268[BYTE1(v266) + 512];
    v785 = dword_F3268[BYTE2(v266) + 768];
    v722 = dword_F3268[BYTE2(v264) + 768];
    v516 = v525 ^ v422;
    v268 = dword_F3268[BYTE1(v264) + 512];
    v606 = v441 ^ v539;
    v717 = dword_F3268[(unsigned __int8)v266];
    v594 = v648 ^ v402;
    v269 = dword_F3268[HIBYTE(v548) + 256];
    v437 = v391 ^ v515 ^ v411;
    v771 = dword_F3268[HIBYTE(v619) + 256];
    v513 = v658 ^ v260 ^ v370;
    v270 = &dword_F3268[BYTE2(v548)];
    v271 = &dword_F3268[BYTE1(v548)];
    v544 = v760 ^ v525 ^ v422;
    v385 = v666 ^ v508;
    v761 = v271[512];
    v659 = v268 ^ dword_F3268[(unsigned __int8)v619];
    v522 = v673 ^ v753 ^ v488;
    v674 = dword_F3268[BYTE2(v619) + 768];
    v776 = dword_F3268[BYTE1(v619) + 512];
    ++v550;
    v649 = v698 ^ v269;
    v272 = dword_F3268[HIBYTE(v632) + 256] ^ dword_F3268[(unsigned __int8)v263];
    v273 = dword_F3268[(unsigned __int8)v262] ^ dword_F3268[HIBYTE(v261) + 256];
    v274 = &dword_F3268[BYTE1(v261)];
    v275 = dword_F3268[BYTE2(v632) + 768]
         ^ dword_F3268[HIBYTE(v263) + 256]
         ^ dword_F3268[(unsigned __int8)v261]
         ^ v594
         ^ dword_F3268[BYTE1(v262) + 512];
    v276 = dword_F3268[BYTE2(v261) + 768]
         ^ dword_F3268[(unsigned __int8)v632]
         ^ dword_F3268[HIBYTE(v262) + 256]
         ^ v516
         ^ dword_F3268[BYTE1(v263) + 512];
    v277 = dword_F3268[BYTE2(v263) + 768] ^ v273 ^ v606 ^ dword_F3268[BYTE1(v632) + 512];
    v620 = v267 ^ v681 ^ v695;
    v278 = dword_F3268[BYTE2(v262) + 768] ^ v272 ^ v437 ^ v274[512];
    v279 = dword_F3268[(unsigned __int8)v277]
         ^ dword_F3268[HIBYTE(v275) + 256]
         ^ v544
         ^ dword_F3268[BYTE1(v276) + 512]
         ^ dword_F3268[BYTE2(v278) + 768];
    v280 = dword_F3268[HIBYTE(v277) + 256]
         ^ dword_F3268[(unsigned __int8)v276]
         ^ v513
         ^ dword_F3268[BYTE1(v278) + 512]
         ^ dword_F3268[BYTE2(v275) + 768];
    v281 = dword_F3268[BYTE1(v275) + 512]
         ^ dword_F3268[HIBYTE(v276) + 256]
         ^ dword_F3268[(unsigned __int8)v278]
         ^ v666
         ^ v508
         ^ dword_F3268[BYTE2(v277) + 768];
    v282 = dword_F3268[BYTE1(v277) + 512]
         ^ dword_F3268[HIBYTE(v278) + 256]
         ^ dword_F3268[(unsigned __int8)v275]
         ^ v522
         ^ dword_F3268[BYTE2(v276) + 768];
    v283 = dword_F3268[(unsigned __int8)v282];
    v284 = dword_F3268[HIBYTE(v282) + 256];
    v285 = dword_F3268[HIBYTE(v279) + 256] ^ dword_F3268[(unsigned __int8)v280];
    v286 = BYTE1(v280);
    v667 = dword_F3268[BYTE1(v281) + 512];
    v287 = dword_F3268[BYTE1(v282) + 512];
    v288 = dword_F3268[HIBYTE(v280) + 256] ^ dword_F3268[(unsigned __int8)v281];
    v289 = dword_F3268[BYTE2(v282) + 768];
    v290 = dword_F3268[BYTE2(v280) + 768];
    v291 = v659 ^ v702;
    v660 = dword_F3268[BYTE2(v281) + 768];
    v292 = dword_F3268[HIBYTE(v281) + 256] ^ v283 ^ v707;
    v293 = v284 ^ dword_F3268[(unsigned __int8)v279] ^ v710 ^ dword_F3268[v286 + 512];
    v704 = v705 ^ v766 ^ v761 ^ v771 ^ v785;
    v700 = v291 ^ v270[768] ^ v782;
    v694 = v620 ^ v640 ^ v674;
    v697 = v649 ^ v717 ^ v722 ^ v776;
    v706 = v285 ^ v687 ^ v667 ^ v289;
    v712 = v292 ^ dword_F3268[BYTE1(v279) + 512] ^ v290;
    v709 = v287 ^ v288 ^ v693 ^ dword_F3268[BYTE2(v279) + 768];
    v719 = v293 ^ v660;
  }
  while ( v550 != 3 );
  v294 = dword_F3268[BYTE1(v599) + 512];
  v295 = dword_F3268[HIBYTE(v599) + 256];
  v296 = dword_F3268[(unsigned __int8)v599] ^ dword_F3268[HIBYTE(v573) + 256] ^ v385 ^ dword_F3268[BYTE1(v443) + 512];
  v603 = dword_F3268[HIBYTE(v443) + 256]
       ^ dword_F3268[(unsigned __int8)v585]
       ^ v544
       ^ dword_F3268[BYTE1(v573) + 512]
       ^ dword_F3268[BYTE2(v599) + 768];
  v297 = dword_F3268[(unsigned __int8)v443];
  v298 = dword_F3268[(unsigned __int8)v573] ^ dword_F3268[HIBYTE(v585) + 256] ^ v513 ^ v294;
  v299 = dword_F3268[BYTE1(v585) + 512];
  v590 = v296 ^ dword_F3268[BYTE2(v585) + 768];
  v551 = v298 ^ dword_F3268[BYTE2(v443) + 768];
  v300 = BYTE2(v566);
  v448 = HIBYTE(v566);
  v301 = v297 ^ v295 ^ v522 ^ v299 ^ dword_F3268[BYTE2(v573) + 768];
  v302 = dword_F3268[(unsigned __int8)v566] ^ dword_F3268[HIBYTE(v526) + 256] ^ dword_F3268[BYTE1(v558) + 512];
  v303 = dword_F3268[BYTE1(v452) + 512];
  v304 = dword_F3268[(unsigned __int8)v526] ^ dword_F3268[HIBYTE(v452) + 256] ^ dword_F3268[BYTE1(v566) + 512];
  v305 = v452;
  v458 = dword_F3268[(unsigned __int8)v558];
  v570 = v303;
  v306 = dword_F3268[BYTE2(v305) + 768] ^ v302;
  v307 = dword_F3268[(unsigned __int8)v305] ^ dword_F3268[HIBYTE(v558) + 256];
  v633 = dword_F3268[((v551 ^ (unsigned int)v694) >> 24) + 256];
  v563 = v304 ^ dword_F3268[BYTE2(v558) + 768] ^ v590;
  v308 = v307 ^ dword_F3268[BYTE1(v526) + 512] ^ dword_F3268[v300 + 768];
  v309 = dword_F3268[(unsigned __int8)((v590 ^ (unsigned int)v697) >> 16) + 768];
  v577 = v306 ^ v301;
  v661 = dword_F3268[(unsigned __int8)((v551 ^ (unsigned int)v694) >> 16) + 768];
  v310 = dword_F3268[(unsigned __int8)((unsigned __int16)(v590 ^ v697) >> 8) + 512]
       ^ dword_F3268[(unsigned __int8)(v551 ^ v694)];
  BYTE1(v304) = BYTE1(v551) ^ BYTE1(v694);
  v552 = v308 ^ v551;
  v311 = v458 ^ dword_F3268[v448 + 256] ^ v570 ^ dword_F3268[BYTE2(v526) + 768];
  v459 = dword_F3268[(unsigned __int8)(v590 ^ v697)]
       ^ v563
       ^ v633
       ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v301 ^ v700) >> 8) + 512]
       ^ dword_F3268[(unsigned __int8)((v603 ^ (unsigned int)v704) >> 16) + 768];
  v571 = v311 ^ v603;
  v449 = v310
       ^ v552
       ^ dword_F3268[((v603 ^ (unsigned int)v704) >> 24) + 256]
       ^ dword_F3268[(unsigned __int8)((v301 ^ (unsigned int)v700) >> 16) + 768];
  v641 = dword_F3268[HIBYTE(v411) + 256];
  v531 = v661
       ^ v577
       ^ dword_F3268[((v590 ^ (unsigned int)v697) >> 24) + 256]
       ^ dword_F3268[(unsigned __int8)(v301 ^ v700)]
       ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v603 ^ v704) >> 8) + 512];
  v312 = &dword_F3268[BYTE2(v411)];
  v591 = &dword_F3268[BYTE1(v411)];
  v621 = (unsigned __int8)v411;
  v415 = dword_F3268[HIBYTE(v393) + 256];
  v313 = v309
       ^ dword_F3268[(unsigned __int8)(v603 ^ v704)]
       ^ v311
       ^ v603
       ^ dword_F3268[((v301 ^ (unsigned int)v700) >> 24) + 256]
       ^ dword_F3268[BYTE1(v304) + 512];
  v604 = v312[768];
  v314 = dword_F3268[(unsigned __int8)v461] ^ v641 ^ dword_F3268[BYTE1(v393) + 512];
  v650 = dword_F3268[BYTE2(v531) + 768];
  v315 = dword_F3268[(unsigned __int8)v393] ^ dword_F3268[HIBYTE(v461) + 256] ^ dword_F3268[BYTE1(v579) + 512];
  v634 = dword_F3268[BYTE1(v459) + 512];
  v316 = &dword_F3268[BYTE2(v393)];
  v317 = dword_F3268[BYTE2(v461) + 768];
  v318 = v591;
  v592 = dword_F3268[BYTE1(v461) + 512];
  v319 = v318[512];
  v397 = dword_F3268[v621];
  v320 = dword_F3268[(unsigned __int8)v459];
  v321 = dword_F3268[BYTE2(v459) + 768];
  v466 = v314 ^ dword_F3268[BYTE2(v579) + 768] ^ v571;
  v322 = HIBYTE(v459);
  v460 = dword_F3268[(unsigned __int8)v579] ^ v415 ^ v319 ^ v317 ^ v563;
  v622 = dword_F3268[BYTE1(v449) + 512];
  v416 = v315 ^ v604 ^ v552;
  v323 = v634 ^ dword_F3268[(unsigned __int8)v449];
  v553 = dword_F3268[(unsigned __int8)v531];
  v324 = v397 ^ dword_F3268[HIBYTE(v579) + 256];
  v564 = dword_F3268[BYTE1(v313) + 512];
  v582 = dword_F3268[BYTE2(v449) + 768];
  v398 = dword_F3268[BYTE1(v531) + 512] ^ v320 ^ v460 ^ dword_F3268[HIBYTE(v449) + 256] ^ dword_F3268[BYTE2(v313) + 768];
  v450 = v316[768] ^ v324 ^ v592 ^ v577;
  v532 = dword_F3268[(unsigned __int8)v313] ^ dword_F3268[HIBYTE(v531) + 256] ^ v466 ^ v321 ^ v622;
  v325 = v323 ^ v416 ^ v650 ^ dword_F3268[HIBYTE(v313) + 256];
  v326 = &dword_F3268[HIBYTE(v477)];
  BYTE1(v314) = BYTE1(v477);
  v327 = BYTE2(v477);
  v328 = dword_F3268[v322 + 256] ^ v553;
  v554 = dword_F3268[HIBYTE(v469) + 256];
  v642 = &dword_F3268[BYTE2(v469)];
  v329 = v328 ^ v450 ^ v564 ^ v582;
  v651 = &dword_F3268[HIBYTE(v398)];
  v330 = dword_F3268[(unsigned __int8)v469] ^ dword_F3268[HIBYTE(v494) + 256];
  v583 = dword_F3268[BYTE1(v398) + 512];
  v331 = dword_F3268[(unsigned __int8)v477] ^ dword_F3268[HIBYTE(v370) + 256] ^ dword_F3268[BYTE1(v494) + 512];
  v332 = (unsigned __int8)v398;
  v484 = dword_F3268[BYTE1(v469) + 512];
  v476 = dword_F3268[BYTE1(v314) + 512];
  v333 = BYTE2(v398);
  v334 = dword_F3268[(unsigned __int8)v494] ^ v326[256] ^ v484;
  v485 = v330 ^ dword_F3268[BYTE1(v370) + 512] ^ dword_F3268[v327 + 768] ^ v416;
  v399 = v331 ^ v642[768] ^ v450;
  v417 = v334 ^ dword_F3268[BYTE2(v370) + 768] ^ v466;
  v379 = dword_F3268[(unsigned __int8)v370] ^ v554 ^ v476 ^ dword_F3268[BYTE2(v494) + 768] ^ v460;
  v335 = dword_F3268[HIBYTE(v329) + 256];
  v336 = dword_F3268[(unsigned __int8)v329]
       ^ v399
       ^ v651[256]
       ^ dword_F3268[BYTE2(v325) + 768]
       ^ dword_F3268[BYTE1(v532) + 512];
  v337 = dword_F3268[v332]
       ^ dword_F3268[HIBYTE(v325) + 256]
       ^ v379
       ^ dword_F3268[BYTE1(v329) + 512]
       ^ dword_F3268[BYTE2(v532) + 768];
  v338 = dword_F3268[BYTE2(v329) + 768]
       ^ v485
       ^ dword_F3268[(unsigned __int8)v325]
       ^ v583
       ^ dword_F3268[HIBYTE(v532) + 256];
  v339 = dword_F3268[BYTE1(v325) + 512] ^ dword_F3268[(unsigned __int8)v532] ^ v417 ^ dword_F3268[v333 + 768] ^ v335;
  v555 = dword_F3268[HIBYTE(v339) + 256];
  v578 = dword_F3268[BYTE2(v339) + 768];
  v623 = dword_F3268[(unsigned __int8)v339];
  v565 = dword_F3268[HIBYTE(v338) + 256];
  v533 = v810 ^ v742;
  v500 = dword_F3268[(unsigned __int8)v338];
  v340 = dword_F3268[(unsigned __int8)v488]
       ^ dword_F3268[HIBYTE(v402) + 256]
       ^ dword_F3268[BYTE1(v422) + 512]
       ^ dword_F3268[BYTE2(v534) + 768]
       ^ v417;
  v380 = dword_F3268[(unsigned __int8)v534]
       ^ dword_F3268[HIBYTE(v422) + 256]
       ^ dword_F3268[BYTE1(v402) + 512]
       ^ dword_F3268[BYTE2(v488) + 768]
       ^ v379;
  v341 = dword_F3268[HIBYTE(v488) + 256]
       ^ dword_F3268[(unsigned __int8)v422]
       ^ dword_F3268[BYTE1(v534) + 512]
       ^ dword_F3268[BYTE2(v402) + 768]
       ^ v485;
  v342 = dword_F3268[HIBYTE(v534) + 256]
       ^ dword_F3268[(unsigned __int8)v402]
       ^ dword_F3268[BYTE1(v488) + 512]
       ^ dword_F3268[BYTE2(v422) + 768]
       ^ v399;
  v744 = &dword_F3268[(unsigned __int8)((v380 ^ (unsigned int)v709) >> 16)];
  v682 = &dword_F3268[(v380 ^ (unsigned int)v709) >> 24];
  v754 = &dword_F3268[(v342 ^ (unsigned int)v712) >> 24];
  v668 = &dword_F3268[(v341 ^ (unsigned int)v706) >> 24];
  v662 = (unsigned __int8)(v380 ^ v709);
  v675 = &dword_F3268[(unsigned __int8)((unsigned __int16)(v342 ^ v712) >> 8)];
  v762 = &dword_F3268[(unsigned __int8)((v342 ^ (unsigned int)v712) >> 16)];
  v486 = dword_F3268[(unsigned __int8)((unsigned __int16)(v380 ^ v709) >> 8) + 512]
       ^ dword_F3268[(unsigned __int8)(v341 ^ v706)];
  v772 = &dword_F3268[(unsigned __int8)((v341 ^ (unsigned int)v706) >> 16)];
  v777 = &dword_F3268[(unsigned __int8)((unsigned __int16)(v341 ^ v706) >> 8)];
  v688 = (unsigned __int8)(v342 ^ v712);
  v343 = v801
       ^ v747
       ^ dword_F3268[(unsigned __int8)v336]
       ^ dword_F3268[BYTE1(v339) + 512]
       ^ dword_F3268[BYTE2(v338) + 768];
  v344 = v802 ^ v740 ^ v623 ^ dword_F3268[BYTE1(v338) + 512] ^ dword_F3268[HIBYTE(v336) + 256];
  v593 = v796 ^ v706;
  v605 = v797 ^ v709;
  v624 = v798 ^ v712;
  v708 = v803 ^ v694;
  v711 = v804 ^ v697;
  v718 = v805 ^ v700;
  v696 = dword_F3268[BYTE1(v336) + 512] ^ v800 ^ v745 ^ v565 ^ dword_F3268[(unsigned __int8)v337] ^ v578;
  v703 = dword_F3268[BYTE2(v337) + 768] ^ v344;
  v699 = dword_F3268[HIBYTE(v337) + 256] ^ v343;
  v643 = dword_F3268[BYTE2(v336) + 768] ^ v533 ^ v500 ^ v555 ^ dword_F3268[BYTE1(v337) + 512];
  v409 = dword_F3268[(unsigned __int8)v502]
       ^ dword_F3268[HIBYTE(v539) + 256]
       ^ dword_F3268[BYTE1(v508) + 512]
       ^ dword_F3268[BYTE2(v430) + 768]
       ^ v341;
  v418 = dword_F3268[(unsigned __int8)v508]
       ^ dword_F3268[HIBYTE(v502) + 256]
       ^ dword_F3268[BYTE1(v430) + 512]
       ^ dword_F3268[BYTE2(v539) + 768]
       ^ v380;
  v427 = dword_F3268[HIBYTE(v430) + 256]
       ^ dword_F3268[(unsigned __int8)v539]
       ^ dword_F3268[BYTE1(v502) + 512]
       ^ dword_F3268[BYTE2(v508) + 768]
       ^ v340;
  v345 = dword_F3268[(unsigned __int8)((v340 ^ (unsigned int)v719) >> 16) + 768];
  v346 = dword_F3268[v662] ^ v418 ^ v668[256] ^ v675[512];
  v451 = dword_F3268[(unsigned __int8)v430]
       ^ dword_F3268[HIBYTE(v508) + 256]
       ^ dword_F3268[BYTE1(v539) + 512]
       ^ dword_F3268[BYTE2(v502) + 768]
       ^ v342;
  v400 = v777[512] ^ v744[768] ^ dword_F3268[(unsigned __int8)(v340 ^ v719)] ^ v427 ^ v754[256];
  v347 = v682[256]
       ^ v451
       ^ dword_F3268[v688]
       ^ dword_F3268[(unsigned __int8)(BYTE1(v340) ^ BYTE1(v719)) + 512]
       ^ v772[768];
  v572 = (unsigned __int8)v516;
  v381 = v486 ^ v409 ^ dword_F3268[((v340 ^ (unsigned int)v719) >> 24) + 256] ^ v762[768];
  v436 = v346 ^ v345;
  v556 = &dword_F3268[BYTE1(v516)];
  v493 = dword_F3268[(unsigned __int8)((unsigned __int16)(v346 ^ v345) >> 8) + 512];
  v584 = &dword_F3268[BYTE1(v437)];
  v348 = dword_F3268[HIBYTE(v516) + 256];
  v349 = &dword_F3268[BYTE2(v437)];
  v350 = dword_F3268[HIBYTE(v437) + 256];
  v467 = dword_F3268[BYTE2(v606) + 768];
  v512 = dword_F3268[BYTE2(v516) + 768];
  v351 = dword_F3268[(unsigned __int8)v437];
  v521 = dword_F3268[(unsigned __int8)(v346 ^ v345)];
  v442 = dword_F3268[BYTE1(v594) + 512];
  v352 = v351 ^ v348 ^ v794;
  v501 = v349[768];
  v353 = dword_F3268[(unsigned __int8)v400];
  v354 = &dword_F3268[BYTE2(v400)];
  v355 = dword_F3268[BYTE1(v400) + 512];
  v356 = dword_F3268[(unsigned __int8)v381] ^ dword_F3268[HIBYTE(v400) + 256] ^ v409 ^ v352 ^ v442 ^ v467;
  v410 = v409 ^ v352 ^ v442 ^ v467;
  v401 = v584[512] ^ dword_F3268[v572] ^ dword_F3268[HIBYTE(v606) + 256] ^ ~v809 ^ dword_F3268[BYTE2(v594) + 768] ^ v427;
  v419 = v418 ^ dword_F3268[(unsigned __int8)v594] ^ v350 ^ v793 ^ dword_F3268[BYTE1(v606) + 512] ^ v512;
  v428 = v451 ^ dword_F3268[(unsigned __int8)v606] ^ dword_F3268[HIBYTE(v594) + 256] ^ v795 ^ v556[512] ^ v501;
  v357 = v356 ^ v493 ^ dword_F3268[BYTE2(v347) + 768];
  v358 = v521 ^ dword_F3268[HIBYTE(v381) + 256] ^ v419 ^ dword_F3268[BYTE1(v347) + 512] ^ v354[768];
  v359 = dword_F3268[(unsigned __int8)v347]
       ^ dword_F3268[HIBYTE(v436) + 256]
       ^ v428
       ^ v355
       ^ dword_F3268[BYTE2(v381) + 768];
  v382 = v353 ^ dword_F3268[HIBYTE(v347) + 256] ^ v401 ^ dword_F3268[BYTE1(v381) + 512] ^ dword_F3268[BYTE2(v436) + 768];
  v468 = dword_F3268[HIBYTE(v382) + 256];
  v487 = dword_F3268[BYTE2(v359) + 768];
  v557 = (unsigned __int8)v382;
  BYTE1(v347) = BYTE1(v382);
  v383 = dword_F3268[BYTE2(v382) + 768];
  v360 = dword_F3268[HIBYTE(v358) + 256]
       ^ dword_F3268[HIBYTE(v522) + 256]
       ^ dword_F3268[(unsigned __int8)v544]
       ^ dword_F3268[BYTE1(v513) + 512]
       ^ dword_F3268[BYTE2(v385) + 768]
       ^ v428
       ^ dword_F3268[(unsigned __int8)v359]
       ^ dword_F3268[BYTE1(v347) + 512]
       ^ dword_F3268[BYTE2(v357) + 768];
  v361 = dword_F3268[HIBYTE(v385) + 256]
       ^ dword_F3268[(unsigned __int8)v522]
       ^ dword_F3268[BYTE1(v544) + 512]
       ^ dword_F3268[BYTE2(v513) + 768]
       ^ v419
       ^ dword_F3268[(unsigned __int8)v358]
       ^ dword_F3268[HIBYTE(v357) + 256]
       ^ dword_F3268[BYTE1(v359) + 512];
  v362 = dword_F3268[BYTE1(v385) + 512]
       ^ dword_F3268[(unsigned __int8)v513]
       ^ dword_F3268[HIBYTE(v544) + 256]
       ^ dword_F3268[BYTE2(v522) + 768]
       ^ v401
       ^ dword_F3268[v557]
       ^ dword_F3268[HIBYTE(v359) + 256]
       ^ dword_F3268[BYTE1(v357) + 512]
       ^ dword_F3268[BYTE2(v358) + 768];
  v363 = dword_F3268[(unsigned __int8)v385]
       ^ dword_F3268[HIBYTE(v513) + 256]
       ^ dword_F3268[BYTE1(v522) + 512]
       ^ dword_F3268[BYTE2(v544) + 768]
       ^ v410
       ^ dword_F3268[(unsigned __int8)v357]
       ^ v468
       ^ dword_F3268[BYTE1(v358) + 512]
       ^ v487;
  v364 = v808
       ^ v736
       ^ dword_F3268[(unsigned __int8)v362]
       ^ dword_F3268[HIBYTE(v360) + 256]
       ^ dword_F3268[BYTE1(v363) + 512]
       ^ dword_F3268[(unsigned __int8)((v361 ^ v383) >> 16) + 768];
  v365 = v792
       ^ v727
       ^ dword_F3268[(unsigned __int8)(v361 ^ v383)]
       ^ dword_F3268[HIBYTE(v363) + 256]
       ^ dword_F3268[BYTE1(v360) + 512]
       ^ dword_F3268[BYTE2(v362) + 768];
  v366 = v807
       ^ v731
       ^ dword_F3268[(unsigned __int8)v360]
       ^ dword_F3268[((v361 ^ v383) >> 24) + 256]
       ^ dword_F3268[BYTE1(v362) + 512]
       ^ dword_F3268[BYTE2(v363) + 768];
  v367 = v791
       ^ v723
       ^ dword_F3268[(unsigned __int8)v363]
       ^ dword_F3268[HIBYTE(v362) + 256]
       ^ dword_F3268[(unsigned __int8)((unsigned __int16)(v361 ^ v383) >> 8) + 512]
       ^ dword_F3268[BYTE2(v360) + 768];
  v790[33] = v593;
  v790[47] = v366;
  v790[39] = v699;
  v790[36] = v799 ^ v719;
  v790[34] = v605;
  v790[41] = v708;
  v790[37] = v643;
  v790[45] = v367;
  v790[46] = v365;
  v790[48] = v364;
  v790[38] = v696;
  v790[40] = v703;
  v790[35] = v624;
  v790[42] = v711;
  v790[43] = v718;
  v790[44] = v806 ^ v704;
  return v696;
}
// F3268: using guessed type _DWORD dword_F3268[1014];

//----- (000CD6F8) --------------------------------------------------------
_DWORD *__fastcall sph_shavite224_0(_DWORD *result, char *src, unsigned int a3)
{
  unsigned int v3; // r6
  _DWORD *v4; // r7
  int v5; // r5
  size_t v7; // r4
  char *v8; // r0
  int v9; // r3

  v3 = a3;
  v4 = result;
  v5 = result[16];
  while ( v3 )
  {
    v7 = 64 - v5;
    v8 = (char *)v4 + v5;
    if ( 64 - v5 >= v3 )
      v7 = v3;
    v5 += v7;
    result = memcpy(v8, src, v7);
    v3 -= v7;
    src += v7;
    if ( v5 == 64 )
    {
      v5 = 0;
      v9 = v4[25] + 512;
      v4[25] = v9;
      if ( !v9 )
        ++v4[26];
      result = (_DWORD *)sub_C13E8(v4, v4);
    }
  }
  v4[16] = v5;
  return result;
}

//----- (000CD77C) --------------------------------------------------------
unsigned int *__fastcall sph_shavite384_0(unsigned int *result, char *src, unsigned int a3)
{
  unsigned int v3; // r6
  unsigned int *v4; // r7
  unsigned int i; // r5
  size_t v7; // r4
  char *v8; // r0
  int v9; // r3
  int v10; // r3
  int v11; // r3

  v3 = a3;
  v4 = result;
  for ( i = result[32]; v3; result = (unsigned int *)sub_C6880(v4, v4) )
  {
    while ( 1 )
    {
      v7 = 128 - i;
      v8 = (char *)v4 + i;
      if ( 128 - i >= v3 )
        v7 = v3;
      i += v7;
      result = (unsigned int *)memcpy(v8, src, v7);
      v3 -= v7;
      src += v7;
      if ( i == 128 )
        break;
      if ( !v3 )
        goto LABEL_12;
    }
    i = 0;
    v9 = v4[49] + 1024;
    v4[49] = v9;
    if ( !v9 )
    {
      v10 = v4[50] + 1;
      v4[50] = v10;
      if ( !v10 )
      {
        v11 = v4[51] + 1;
        v4[51] = v11;
        if ( !v11 )
          ++v4[52];
      }
    }
  }
LABEL_12:
  v4[32] = i;
  return result;
}

//----- (000CD834) --------------------------------------------------------
unsigned int __fastcall sub_CD834(int a1, char a2, int a3, int a4, unsigned int a5)
{
  unsigned int v7; // r12
  int v8; // r8
  int v9; // r7
  void *v10; // r0
  int v11; // r1
  int v12; // r3
  unsigned int *v13; // r4
  unsigned int *v14; // r1
  unsigned int v15; // t1
  unsigned int result; // r0

  v7 = *(_DWORD *)(a1 + 64);
  v8 = *(_DWORD *)(a1 + 104);
  v9 = a3 + *(_DWORD *)(a1 + 100) + 8 * v7;
  *(_DWORD *)(a1 + 100) = v9;
  if ( v7 | a3 )
  {
    v10 = (void *)(a1 + v7 + 1);
    *(_BYTE *)(a1 + v7) = -(128 >> a3) & a2 | (128 >> a3);
    if ( v7 <= 0x35 )
    {
      memset(v10, 0, 53 - v7);
    }
    else
    {
      memset(v10, 0, 63 - v7);
      sub_C13E8((_DWORD *)a1, (_DWORD *)a1);
      memset((void *)a1, 0, 0x36u);
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 100) = 0;
    }
  }
  else
  {
    *(_BYTE *)a1 = 0x80;
    memset((void *)(a1 + 1), 0, 0x35u);
    *(_DWORD *)(a1 + 104) = 0;
    *(_DWORD *)(a1 + 100) = 0;
  }
  *(_BYTE *)(a1 + 58) = v8;
  *(_BYTE *)(a1 + 55) = BYTE1(v9);
  *(_BYTE *)(a1 + 57) = HIBYTE(v9);
  *(_BYTE *)(a1 + 59) = BYTE1(v8);
  *(_BYTE *)(a1 + 56) = BYTE2(v9);
  *(_BYTE *)(a1 + 60) = BYTE2(v8);
  *(_BYTE *)(a1 + 63) = a5 >> 3;
  *(_BYTE *)(a1 + 54) = v9;
  *(_BYTE *)(a1 + 61) = HIBYTE(v8);
  *(_BYTE *)(a1 + 62) = 32 * a5;
  sub_C13E8((_DWORD *)a1, (_DWORD *)a1);
  v11 = a1 + 4 * a5;
  v12 = a4;
  v13 = (unsigned int *)(a1 + 68);
  v14 = (unsigned int *)(v11 + 68);
  do
  {
    v15 = *v13++;
    v12 += 4;
    *(_DWORD *)(v12 - 4) = v15;
    result = HIWORD(v15);
  }
  while ( v14 != v13 );
  return result;
}

//----- (000CD988) --------------------------------------------------------
unsigned int __fastcall sub_CD988(int a1, char a2, int a3, int a4, unsigned int a5)
{
  unsigned int v7; // r12
  int v8; // r10
  int v9; // r9
  int v10; // r8
  int v11; // r7
  void *v12; // r0
  unsigned int *v13; // r1
  _DWORD *v14; // r0
  int v15; // r4
  int v16; // r3
  unsigned int v17; // t1
  unsigned int result; // r0

  v7 = *(_DWORD *)(a1 + 128);
  v8 = *(_DWORD *)(a1 + 200);
  v9 = *(_DWORD *)(a1 + 204);
  v10 = *(_DWORD *)(a1 + 208);
  v11 = a3 + *(_DWORD *)(a1 + 196) + 8 * v7;
  *(_DWORD *)(a1 + 196) = v11;
  if ( v7 | a3 )
  {
    v12 = (void *)(a1 + v7 + 1);
    *(_BYTE *)(a1 + v7) = -(128 >> a3) & a2 | (128 >> a3);
    if ( v7 <= 0x6D )
    {
      memset(v12, 0, 109 - v7);
    }
    else
    {
      memset(v12, 0, 127 - v7);
      sub_C6880((_DWORD *)a1, (unsigned int *)a1);
      memset((void *)a1, 0, 0x6Eu);
      *(_DWORD *)(a1 + 208) = 0;
      *(_DWORD *)(a1 + 204) = 0;
      *(_DWORD *)(a1 + 200) = 0;
      *(_DWORD *)(a1 + 196) = 0;
    }
  }
  else
  {
    *(_BYTE *)a1 = 0x80;
    memset((void *)(a1 + 1), 0, 0x6Du);
    *(_DWORD *)(a1 + 208) = 0;
    *(_DWORD *)(a1 + 204) = 0;
    *(_DWORD *)(a1 + 200) = 0;
    *(_DWORD *)(a1 + 196) = 0;
  }
  *(_BYTE *)(a1 + 111) = BYTE1(v11);
  *(_BYTE *)(a1 + 112) = BYTE2(v11);
  *(_BYTE *)(a1 + 114) = v8;
  *(_BYTE *)(a1 + 118) = v9;
  *(_BYTE *)(a1 + 122) = v10;
  *(_BYTE *)(a1 + 113) = HIBYTE(v11);
  *(_BYTE *)(a1 + 115) = BYTE1(v8);
  *(_BYTE *)(a1 + 119) = BYTE1(v9);
  *(_BYTE *)(a1 + 120) = BYTE2(v9);
  *(_BYTE *)(a1 + 116) = BYTE2(v8);
  *(_BYTE *)(a1 + 123) = BYTE1(v10);
  v13 = (unsigned int *)a1;
  *(_BYTE *)(a1 + 124) = BYTE2(v10);
  v14 = (_DWORD *)a1;
  *(_BYTE *)(a1 + 127) = a5 >> 3;
  v15 = a1 + 128;
  *(_BYTE *)(v15 - 18) = v11;
  *(_BYTE *)(v15 - 11) = HIBYTE(v8);
  *(_BYTE *)(v15 - 7) = HIBYTE(v9);
  *(_BYTE *)(v15 - 3) = HIBYTE(v10);
  *(_BYTE *)(v15 - 2) = 32 * a5;
  sub_C6880(v14, v13);
  v16 = a4;
  do
  {
    v17 = *(_DWORD *)(v15 + 4);
    v15 += 4;
    v16 += 4;
    *(_DWORD *)(v16 - 4) = v17;
    result = v17 >> 8;
  }
  while ( a4 + 4 * a5 != v16 );
  return result;
}

//----- (000CDB28) --------------------------------------------------------
int __fastcall sph_shavite224_init_0(_DWORD *a1)
{
  a1[16] = 0;
  a1[25] = 0;
  a1[17] = 1735717660;
  a1[18] = -1727340016;
  a1[19] = -931315084;
  a1[20] = -917216399;
  a1[26] = 0;
  a1[21] = 1655877288;
  a1[22] = 1264058840;
  a1[23] = 460335200;
  a1[24] = -2077282281;
  return 1655877288;
}

//----- (000CDB7C) --------------------------------------------------------
int __fastcall sph_shavite224_close(_DWORD *a1, int a2)
{
  sub_CD834((int)a1, 0, 0, a2, 7u);
  a1[16] = 0;
  a1[25] = 0;
  a1[26] = 0;
  a1[17] = 1735717660;
  a1[18] = -1727340016;
  a1[19] = -931315084;
  a1[20] = -917216399;
  a1[21] = 1655877288;
  a1[22] = 1264058840;
  a1[23] = 460335200;
  a1[24] = -2077282281;
  return 1655877288;
}

//----- (000CDBEC) --------------------------------------------------------
int __fastcall sph_shavite224_addbits_and_close(_DWORD *a1, char a2, int a3, int a4)
{
  sub_CD834((int)a1, a2, a3, a4, 7u);
  a1[16] = 0;
  a1[25] = 0;
  a1[26] = 0;
  a1[17] = 1735717660;
  a1[18] = -1727340016;
  a1[19] = -931315084;
  a1[20] = -917216399;
  a1[21] = 1655877288;
  a1[22] = 1264058840;
  a1[23] = 460335200;
  a1[24] = -2077282281;
  return 1655877288;
}

//----- (000CDC50) --------------------------------------------------------
int __fastcall sph_shavite256_init(_DWORD *a1)
{
  a1[16] = 0;
  a1[25] = 0;
  a1[17] = 1237007943;
  a1[18] = 645170701;
  a1[19] = -1464626516;
  a1[20] = 35308774;
  a1[26] = 0;
  a1[21] = 1083343823;
  a1[22] = 1645108614;
  a1[23] = 1838325195;
  a1[24] = -1765004661;
  return 1083343823;
}

//----- (000CDCA4) --------------------------------------------------------
int __fastcall sph_shavite256_close(_DWORD *a1, int a2)
{
  sub_CD834((int)a1, 0, 0, a2, 8u);
  a1[16] = 0;
  a1[25] = 0;
  a1[26] = 0;
  a1[17] = 1237007943;
  a1[18] = 645170701;
  a1[19] = -1464626516;
  a1[20] = 35308774;
  a1[21] = 1083343823;
  a1[22] = 1645108614;
  a1[23] = 1838325195;
  a1[24] = -1765004661;
  return 1083343823;
}

//----- (000CDD14) --------------------------------------------------------
int __fastcall sph_shavite256_addbits_and_close(_DWORD *a1, char a2, int a3, int a4)
{
  sub_CD834((int)a1, a2, a3, a4, 8u);
  a1[16] = 0;
  a1[25] = 0;
  a1[26] = 0;
  a1[17] = 1237007943;
  a1[18] = 645170701;
  a1[19] = -1464626516;
  a1[20] = 35308774;
  a1[21] = 1083343823;
  a1[22] = 1645108614;
  a1[23] = 1838325195;
  a1[24] = -1765004661;
  return 1083343823;
}

//----- (000CDD78) --------------------------------------------------------
int __fastcall sph_shavite384_init_0(_DWORD *a1)
{
  int *v2; // r4
  _DWORD *v3; // lr
  int result; // r0
  int v5; // r1
  int v6; // r2
  int v7; // r3

  v2 = (int *)&unk_F42A8;
  v3 = a1 + 33;
  do
  {
    v3 += 4;
    result = *v2;
    v5 = v2[1];
    v6 = v2[2];
    v7 = v2[3];
    v2 += 4;
    *(v3 - 4) = result;
    *(v3 - 3) = v5;
    *(v3 - 2) = v6;
    *(v3 - 1) = v7;
  }
  while ( v2 != (int *)&unk_F42E8 );
  a1[32] = 0;
  a1[49] = 0;
  a1[50] = 0;
  a1[51] = 0;
  a1[52] = 0;
  return result;
}

//----- (000CDDD8) --------------------------------------------------------
int __fastcall sph_shavite384_close(_DWORD *a1, int a2)
{
  int *v2; // r4
  _DWORD *v4; // lr
  int result; // r0
  int v6; // r1
  int v7; // r2
  int v8; // r3

  v2 = (int *)&unk_F42A8;
  sub_CD988((int)a1, 0, 0, a2, 0xCu);
  v4 = a1 + 33;
  do
  {
    v4 += 4;
    result = *v2;
    v6 = v2[1];
    v7 = v2[2];
    v8 = v2[3];
    v2 += 4;
    *(v4 - 4) = result;
    *(v4 - 3) = v6;
    *(v4 - 2) = v7;
    *(v4 - 1) = v8;
  }
  while ( v2 != (int *)&unk_F42E8 );
  a1[32] = 0;
  a1[49] = 0;
  a1[50] = 0;
  a1[51] = 0;
  a1[52] = 0;
  return result;
}

//----- (000CDE54) --------------------------------------------------------
int __fastcall sph_shavite384_addbits_and_close(_DWORD *a1, char a2, int a3, int a4)
{
  int *v4; // r4
  _DWORD *v6; // lr
  int result; // r0
  int v8; // r1
  int v9; // r2
  int v10; // r3

  v4 = (int *)&unk_F42A8;
  sub_CD988((int)a1, a2, a3, a4, 0xCu);
  v6 = a1 + 33;
  do
  {
    v6 += 4;
    result = *v4;
    v8 = v4[1];
    v9 = v4[2];
    v10 = v4[3];
    v4 += 4;
    *(v6 - 4) = result;
    *(v6 - 3) = v8;
    *(v6 - 2) = v9;
    *(v6 - 1) = v10;
  }
  while ( v4 != (int *)&unk_F42E8 );
  a1[32] = 0;
  a1[49] = 0;
  a1[50] = 0;
  a1[51] = 0;
  a1[52] = 0;
  return result;
}

//----- (000CDEC4) --------------------------------------------------------
int __fastcall sph_shavite512_init(_DWORD *a1)
{
  int *v2; // r4
  _DWORD *v3; // lr
  int result; // r0
  int v5; // r1
  int v6; // r2
  int v7; // r3

  v2 = (int *)&unk_F42E8;
  v3 = a1 + 33;
  do
  {
    v3 += 4;
    result = *v2;
    v5 = v2[1];
    v6 = v2[2];
    v7 = v2[3];
    v2 += 4;
    *(v3 - 4) = result;
    *(v3 - 3) = v5;
    *(v3 - 2) = v6;
    *(v3 - 1) = v7;
  }
  while ( v2 != (int *)&unk_F4328 );
  a1[32] = 0;
  a1[49] = 0;
  a1[50] = 0;
  a1[51] = 0;
  a1[52] = 0;
  return result;
}

//----- (000CDF24) --------------------------------------------------------
int __fastcall sph_shavite512_close(_DWORD *a1, int a2)
{
  int *v2; // r4
  _DWORD *v4; // lr
  int result; // r0
  int v6; // r1
  int v7; // r2
  int v8; // r3

  v2 = (int *)&unk_F42E8;
  sub_CD988((int)a1, 0, 0, a2, 0x10u);
  v4 = a1 + 33;
  do
  {
    v4 += 4;
    result = *v2;
    v6 = v2[1];
    v7 = v2[2];
    v8 = v2[3];
    v2 += 4;
    *(v4 - 4) = result;
    *(v4 - 3) = v6;
    *(v4 - 2) = v7;
    *(v4 - 1) = v8;
  }
  while ( v2 != (int *)&unk_F4328 );
  a1[32] = 0;
  a1[49] = 0;
  a1[50] = 0;
  a1[51] = 0;
  a1[52] = 0;
  return result;
}

//----- (000CDFA0) --------------------------------------------------------
int __fastcall sph_shavite512_addbits_and_close(_DWORD *a1, char a2, int a3, int a4)
{
  int *v4; // r4
  _DWORD *v6; // lr
  int result; // r0
  int v8; // r1
  int v9; // r2
  int v10; // r3

  v4 = (int *)&unk_F42E8;
  sub_CD988((int)a1, a2, a3, a4, 0x10u);
  v6 = a1 + 33;
  do
  {
    v6 += 4;
    result = *v4;
    v8 = v4[1];
    v9 = v4[2];
    v10 = v4[3];
    v4 += 4;
    *(v6 - 4) = result;
    *(v6 - 3) = v8;
    *(v6 - 2) = v9;
    *(v6 - 1) = v10;
  }
  while ( v4 != (int *)&unk_F4328 );
  a1[32] = 0;
  a1[49] = 0;
  a1[50] = 0;
  a1[51] = 0;
  a1[52] = 0;
  return result;
}

//----- (000CE010) --------------------------------------------------------
int __fastcall sub_CE010(unsigned __int8 *a1, int a2)
{
  int v2; // r10
  int v3; // r9
  int v4; // r8
  int v5; // r7
  int v6; // r4
  unsigned int v7; // r1
  unsigned int v8; // r6
  int v9; // r2
  int v10; // r12
  unsigned int v11; // r3
  int v12; // r5
  int v13; // r1
  int v14; // lr
  int v15; // r2
  int v16; // r9
  unsigned int v17; // r10
  int v18; // r9
  int v19; // r0
  int v20; // r8
  int v21; // r2
  int v22; // r11
  int v23; // r8
  int v24; // r10
  unsigned int v25; // r1
  int v26; // r5
  unsigned int v27; // r9
  int v28; // r3
  int v29; // r2
  int v30; // r12
  int v31; // r0
  int v32; // r7
  int v33; // r8
  int v34; // r5
  int v35; // r4
  int v36; // lr
  int v37; // r12
  int v38; // r0
  unsigned int v39; // r3
  int v40; // r12
  int v41; // r1
  int v42; // r0
  int v43; // r7
  int v44; // r8
  int v45; // r3
  int v46; // r6
  int v47; // r4
  int v48; // r1
  int v49; // r0
  int v50; // lr
  int v51; // r0
  int v52; // r12
  int v53; // r2
  int v54; // r10
  int v55; // r1
  int v56; // r8
  int v57; // r12
  unsigned int v58; // r9
  int v59; // r4
  int v60; // r1
  int v61; // r7
  int v62; // r8
  int v63; // r3
  int *v64; // r2
  int v65; // r1
  _DWORD *v66; // r0
  int v67; // r4
  unsigned int v68; // r3
  int v69; // r3
  int v70; // r4
  int v71; // r7
  int v72; // r3
  int v73; // r1
  int v74; // r5
  int v75; // r12
  int v76; // r9
  int v77; // r9
  int v78; // r8
  int v79; // r8
  int v80; // r10
  int v81; // r9
  int v82; // r7
  int v83; // r3
  unsigned int v84; // r0
  unsigned int v85; // r6
  int v86; // r1
  int v87; // lr
  unsigned int v88; // r2
  int v89; // r11
  int v90; // r10
  int v91; // r5
  int v92; // r0
  unsigned int v93; // r7
  int v94; // r4
  int v95; // r1
  int v96; // r8
  int v97; // r1
  int v98; // r12
  int v99; // r7
  int v100; // r0
  unsigned int v101; // r6
  int v102; // r2
  unsigned int v103; // r1
  int v104; // r8
  int v105; // lr
  int v106; // r12
  int v107; // r5
  int v108; // r0
  int v109; // r5
  int v110; // r9
  int v111; // r12
  int v112; // r2
  int v113; // r0
  int v114; // lr
  int v115; // r4
  unsigned int v116; // r1
  int v117; // r4
  int v118; // r9
  int v119; // r5
  int v120; // r8
  int v121; // r10
  int v122; // r12
  int v123; // r6
  int v124; // r0
  int v125; // r2
  int v126; // r5
  int v127; // r7
  int v128; // lr
  int v129; // r11
  int v130; // r2
  int v131; // r8
  int v132; // r7
  int v133; // r9
  int v134; // r0
  int v135; // r4
  int v136; // lr
  unsigned int v137; // r9
  int v138; // r10
  int v139; // r3
  int v140; // r8
  int v141; // r7
  _DWORD *v142; // r3
  int *v143; // r2
  int v144; // r5
  int v145; // r7
  int v146; // r1
  int v147; // r6
  int v148; // r5
  int v149; // r6
  int v150; // r1
  int v151; // r0
  int v152; // r4
  int v153; // lr
  int v154; // r8
  int v155; // r9
  _DWORD *v156; // r1
  int *v157; // r3
  int v158; // r12
  _DWORD *v159; // r7
  int v160; // r4
  int v161; // r12
  int v162; // r5
  int v163; // r11
  int v164; // r11
  int v165; // r10
  int v166; // r10
  int v167; // r8
  int v168; // r12
  int v169; // lr
  int v170; // r4
  int v171; // r0
  int v172; // r5
  int v173; // r6
  int v174; // r5
  int v175; // r8
  int v176; // r7
  unsigned int v177; // r3
  unsigned int v178; // r4
  int v179; // r0
  int v180; // r10
  int v181; // lr
  int v182; // r3
  unsigned int v183; // r11
  int v184; // r10
  int v185; // r2
  int v186; // r8
  int v187; // r7
  int v188; // r9
  int v189; // r2
  int v190; // r12
  int v191; // r7
  int v192; // r6
  int v193; // r4
  int v194; // r7
  unsigned int v195; // r5
  int v196; // r3
  int v197; // r11
  unsigned int v198; // r4
  int v199; // lr
  int v200; // r5
  int v201; // r12
  int v202; // r11
  int v203; // r8
  int v204; // r12
  int v205; // r5
  int v206; // r3
  int v207; // r10
  int v208; // r2
  unsigned int v209; // r11
  int v210; // r4
  int v211; // r5
  int v212; // r10
  int v213; // r6
  int v214; // r9
  int v215; // lr
  int v216; // r2
  int v217; // r3
  int v218; // r12
  int v219; // r6
  int v220; // r5
  int v221; // r7
  int v222; // r4
  int v223; // r8
  int v224; // r3
  int v225; // r10
  int v226; // r12
  int v227; // r7
  int v228; // r5
  int v229; // r0
  unsigned int v230; // r9
  int v231; // lr
  int v232; // r4
  int v233; // r8
  int *v234; // r3
  int v235; // r12
  _DWORD *v236; // r0
  int v237; // r7
  int v238; // r6
  int v239; // r10
  int v240; // r5
  int v241; // r4
  int v242; // r9
  int v243; // lr
  int v244; // r8
  int v245; // r12
  int v246; // r6
  int v247; // r5
  int v248; // r8
  int v249; // r9
  int v250; // r6
  int v251; // r5
  int v252; // r2
  int v253; // r7
  int v254; // r8
  unsigned int v255; // r0
  int v256; // r10
  unsigned int v257; // r4
  int v258; // r11
  int v259; // r8
  int v260; // lr
  int v261; // r0
  int v262; // r9
  int v263; // r12
  int v264; // r10
  int v265; // r3
  unsigned int v266; // r11
  unsigned int v267; // lr
  int v268; // r4
  int v269; // r3
  unsigned int v270; // r5
  unsigned int v271; // r4
  int v272; // lr
  int v273; // r0
  int v274; // r7
  int v275; // r12
  unsigned int v276; // r9
  int v277; // r5
  int v278; // r12
  int v279; // r7
  int v280; // lr
  int v281; // r0
  int v282; // r6
  int v283; // r10
  int v284; // r5
  int v285; // r0
  int v286; // r12
  unsigned int v287; // r4
  int v288; // r0
  int v289; // r4
  int v290; // r5
  int v291; // r7
  int v292; // r9
  int v293; // r12
  int v294; // r5
  int v295; // r7
  int v296; // lr
  int v297; // r8
  int v298; // r12
  int v299; // r6
  int v300; // r5
  int v301; // r7
  int v302; // r4
  int v303; // r10
  int v304; // r12
  int v305; // r8
  int v306; // r7
  int v307; // lr
  _DWORD *v308; // r6
  int *v309; // r2
  int v310; // r12
  int v311; // r5
  int v312; // r8
  int v313; // r7
  int v314; // r4
  int v315; // r8
  int v316; // r0
  int v317; // r12
  int v318; // r5
  int v319; // lr
  int v320; // r9
  int v321; // r10
  int *v322; // r3
  int v323; // r2
  int v324; // r12
  int v325; // r6
  int v326; // r0
  int v327; // r10
  int v328; // r0
  int v329; // r11
  int v330; // r4
  int v331; // lr
  int v332; // r0
  int v333; // r7
  int v334; // r2
  int v335; // r4
  int v336; // r12
  int v337; // r6
  int v338; // r8
  int *v339; // r3
  _DWORD *v340; // r12
  int v341; // r2
  int v342; // r7
  int v343; // r6
  int v344; // r11
  int v345; // r11
  int v346; // r10
  int v347; // r0
  int v348; // r1
  int v349; // r2
  int v350; // r5
  int v351; // r4
  int v352; // r6
  int *v353; // r1
  unsigned __int16 *v354; // r0
  int j; // r2
  int v356; // t1
  int v357; // t1
  int v358; // r2
  int v359; // r3
  int v360; // r9
  int v361; // r4
  int v362; // r1
  int v363; // r9
  int v364; // r8
  int v365; // r10
  int v366; // r0
  int v367; // r1
  int v368; // r2
  int v369; // r5
  int v370; // r4
  int v371; // lr
  int v372; // r12
  int v373; // r9
  int v374; // r4
  int v375; // r12
  int v376; // r1
  int v377; // r10
  int v378; // r4
  int v379; // r6
  int v380; // r0
  int v381; // lr
  int v382; // r5
  int v383; // r12
  int v384; // r9
  int v385; // r0
  int v386; // r1
  int v387; // r12
  int v388; // r5
  int v389; // r2
  int v390; // r4
  int v391; // lr
  int v392; // r0
  int v393; // r12
  int v394; // r2
  int v395; // r2
  int v396; // lr
  int v397; // r8
  int v398; // r0
  int v399; // r7
  int v400; // r6
  int v401; // r1
  int v402; // r5
  int v403; // t2
  int v404; // r1
  int v405; // r4
  int v406; // r5
  int v407; // r8
  int v408; // r2
  int v409; // r9
  int v410; // r2
  int v411; // r4
  int v412; // r0
  int v413; // r6
  int v414; // r12
  int v415; // lr
  int v416; // r5
  int v417; // r10
  int v418; // r4
  int v419; // r10
  int v420; // r9
  int v421; // r8
  int v422; // lr
  int v423; // r0
  int v424; // r12
  int v425; // r5
  int v426; // r7
  int v427; // r12
  int v428; // lr
  int v429; // r4
  int v430; // r12
  int v431; // r5
  int v432; // r1
  int v433; // r6
  int v434; // lr
  int v435; // r2
  int v436; // r9
  int v437; // t2
  int v438; // r2
  int v439; // r1
  int v440; // r4
  int v441; // r1
  int v442; // r12
  int v443; // lr
  int v444; // r9
  int v445; // r12
  int v446; // r0
  int v447; // r6
  int v448; // r1
  int v449; // r2
  int v450; // r1
  int v451; // r3
  int v452; // r12
  int v453; // r3
  int v454; // r4
  int v455; // r2
  int v456; // r0
  int v457; // r1
  int v458; // r3
  int v459; // r1
  int v460; // r2
  int v461; // r12
  int v462; // r0
  int v463; // r3
  int v464; // r1
  int v465; // r0
  int v466; // r2
  int v467; // r5
  int v468; // r4
  int v469; // r12
  int v470; // lr
  int v471; // r7
  int v472; // r4
  int v473; // r2
  int v474; // r1
  int v475; // r3
  int v476; // r0
  int v477; // r4
  int v478; // r10
  int v479; // r1
  int v480; // lr
  int v481; // r7
  int v482; // r12
  int v483; // r4
  int v484; // r1
  int v485; // lr
  int v486; // r2
  int v487; // r4
  int v488; // r10
  int v489; // r2
  int v490; // r3
  int v491; // r5
  int v492; // r0
  int v493; // lr
  int v494; // r1
  int v495; // r12
  int v496; // r3
  int v497; // r12
  int v498; // r1
  int v499; // r3
  int v500; // r12
  int v501; // r0
  int v502; // r2
  int v503; // r4
  int v504; // r3
  int v505; // r12
  int v506; // r0
  int v507; // r1
  int v508; // r2
  int v509; // r2
  int v510; // lr
  int v511; // r0
  int v512; // r3
  int v513; // r1
  int v514; // r0
  int v515; // r4
  int v516; // r6
  int v517; // r9
  int v518; // r8
  int v519; // r10
  int v520; // r2
  int v521; // r3
  int v522; // r6
  int v523; // r11
  int v524; // r5
  int v525; // r4
  int v526; // r3
  int v527; // r12
  int v528; // r1
  int v529; // r0
  int v530; // r7
  int v531; // r3
  int v532; // r2
  int v533; // r1
  int v534; // r7
  int v535; // r5
  int v536; // r0
  int v537; // r1
  int v538; // r2
  int v539; // r7
  int v540; // r6
  int v541; // r3
  int v542; // r5
  int result; // r0
  unsigned __int16 *v544; // r0
  int *v545; // r1
  int i; // r2
  int v547; // t1
  int v548; // t1
  int v549; // r2
  int v550; // r3
  int v552; // [sp+4h] [bp-2D8h]
  int v553; // [sp+4h] [bp-2D8h]
  int v554; // [sp+4h] [bp-2D8h]
  int v555; // [sp+4h] [bp-2D8h]
  int v556; // [sp+4h] [bp-2D8h]
  int v557; // [sp+4h] [bp-2D8h]
  int v558; // [sp+4h] [bp-2D8h]
  int v559; // [sp+4h] [bp-2D8h]
  int v560; // [sp+4h] [bp-2D8h]
  int v561; // [sp+4h] [bp-2D8h]
  int v562; // [sp+4h] [bp-2D8h]
  int v563; // [sp+4h] [bp-2D8h]
  int v564; // [sp+4h] [bp-2D8h]
  int v565; // [sp+4h] [bp-2D8h]
  int v566; // [sp+4h] [bp-2D8h]
  int v567; // [sp+4h] [bp-2D8h]
  int v568; // [sp+8h] [bp-2D4h]
  int v569; // [sp+8h] [bp-2D4h]
  int v570; // [sp+8h] [bp-2D4h]
  int v571; // [sp+8h] [bp-2D4h]
  int v572; // [sp+8h] [bp-2D4h]
  int v573; // [sp+8h] [bp-2D4h]
  int v574; // [sp+8h] [bp-2D4h]
  int v575; // [sp+8h] [bp-2D4h]
  int v576; // [sp+8h] [bp-2D4h]
  int v577; // [sp+8h] [bp-2D4h]
  int v578; // [sp+8h] [bp-2D4h]
  int v579; // [sp+8h] [bp-2D4h]
  int v580; // [sp+8h] [bp-2D4h]
  int v581; // [sp+8h] [bp-2D4h]
  int v582; // [sp+8h] [bp-2D4h]
  int v583; // [sp+8h] [bp-2D4h]
  int v584; // [sp+8h] [bp-2D4h]
  int v585; // [sp+8h] [bp-2D4h]
  int v586; // [sp+8h] [bp-2D4h]
  int v587; // [sp+8h] [bp-2D4h]
  int v588; // [sp+Ch] [bp-2D0h]
  int v589; // [sp+Ch] [bp-2D0h]
  int v590; // [sp+Ch] [bp-2D0h]
  int v591; // [sp+Ch] [bp-2D0h]
  int v592; // [sp+Ch] [bp-2D0h]
  int v593; // [sp+Ch] [bp-2D0h]
  int v594; // [sp+Ch] [bp-2D0h]
  int v595; // [sp+Ch] [bp-2D0h]
  int v596; // [sp+Ch] [bp-2D0h]
  int v597; // [sp+Ch] [bp-2D0h]
  int v598; // [sp+Ch] [bp-2D0h]
  int v599; // [sp+Ch] [bp-2D0h]
  int v600; // [sp+Ch] [bp-2D0h]
  int v601; // [sp+Ch] [bp-2D0h]
  int v602; // [sp+Ch] [bp-2D0h]
  int v603; // [sp+Ch] [bp-2D0h]
  int v604; // [sp+Ch] [bp-2D0h]
  int v605; // [sp+10h] [bp-2CCh]
  int v606; // [sp+10h] [bp-2CCh]
  int v607; // [sp+10h] [bp-2CCh]
  int v608; // [sp+10h] [bp-2CCh]
  int v609; // [sp+10h] [bp-2CCh]
  int v610; // [sp+10h] [bp-2CCh]
  int v611; // [sp+10h] [bp-2CCh]
  int v612; // [sp+10h] [bp-2CCh]
  int v613; // [sp+10h] [bp-2CCh]
  int v614; // [sp+10h] [bp-2CCh]
  int v615; // [sp+10h] [bp-2CCh]
  int v616; // [sp+10h] [bp-2CCh]
  int v617; // [sp+10h] [bp-2CCh]
  int v618; // [sp+10h] [bp-2CCh]
  int v619; // [sp+10h] [bp-2CCh]
  int v620; // [sp+10h] [bp-2CCh]
  int v621; // [sp+10h] [bp-2CCh]
  int v622; // [sp+10h] [bp-2CCh]
  int v623; // [sp+10h] [bp-2CCh]
  int v624; // [sp+10h] [bp-2CCh]
  int v625; // [sp+14h] [bp-2C8h]
  int v626; // [sp+14h] [bp-2C8h]
  int v627; // [sp+14h] [bp-2C8h]
  int v628; // [sp+14h] [bp-2C8h]
  int v629; // [sp+14h] [bp-2C8h]
  int v630; // [sp+14h] [bp-2C8h]
  int v631; // [sp+14h] [bp-2C8h]
  int v632; // [sp+14h] [bp-2C8h]
  int v633; // [sp+14h] [bp-2C8h]
  int v634; // [sp+14h] [bp-2C8h]
  int v635; // [sp+14h] [bp-2C8h]
  int v636; // [sp+14h] [bp-2C8h]
  int v637; // [sp+14h] [bp-2C8h]
  int v638; // [sp+14h] [bp-2C8h]
  int v639; // [sp+14h] [bp-2C8h]
  int v640; // [sp+14h] [bp-2C8h]
  int v641; // [sp+14h] [bp-2C8h]
  int v642; // [sp+18h] [bp-2C4h]
  int v643; // [sp+18h] [bp-2C4h]
  int v644; // [sp+18h] [bp-2C4h]
  int v645; // [sp+18h] [bp-2C4h]
  int v646; // [sp+18h] [bp-2C4h]
  int v647; // [sp+18h] [bp-2C4h]
  int v648; // [sp+18h] [bp-2C4h]
  int v649; // [sp+18h] [bp-2C4h]
  int v650; // [sp+18h] [bp-2C4h]
  int v651; // [sp+18h] [bp-2C4h]
  int v652; // [sp+18h] [bp-2C4h]
  int v653; // [sp+18h] [bp-2C4h]
  int v654; // [sp+18h] [bp-2C4h]
  int v655; // [sp+18h] [bp-2C4h]
  int v656; // [sp+18h] [bp-2C4h]
  int v657; // [sp+1Ch] [bp-2C0h]
  int v658; // [sp+1Ch] [bp-2C0h]
  int v659; // [sp+1Ch] [bp-2C0h]
  int v660; // [sp+1Ch] [bp-2C0h]
  int v661; // [sp+1Ch] [bp-2C0h]
  int v662; // [sp+1Ch] [bp-2C0h]
  int v663; // [sp+1Ch] [bp-2C0h]
  int v664; // [sp+1Ch] [bp-2C0h]
  int v665; // [sp+1Ch] [bp-2C0h]
  int v666; // [sp+1Ch] [bp-2C0h]
  int v667; // [sp+1Ch] [bp-2C0h]
  int v668; // [sp+1Ch] [bp-2C0h]
  int v669; // [sp+1Ch] [bp-2C0h]
  int v670; // [sp+1Ch] [bp-2C0h]
  int v671; // [sp+1Ch] [bp-2C0h]
  int v672; // [sp+1Ch] [bp-2C0h]
  int v673; // [sp+1Ch] [bp-2C0h]
  int v674; // [sp+20h] [bp-2BCh]
  int v675; // [sp+20h] [bp-2BCh]
  int v676; // [sp+20h] [bp-2BCh]
  int v677; // [sp+20h] [bp-2BCh]
  int v678; // [sp+20h] [bp-2BCh]
  int v679; // [sp+20h] [bp-2BCh]
  int v680; // [sp+20h] [bp-2BCh]
  int v681; // [sp+20h] [bp-2BCh]
  int v682; // [sp+20h] [bp-2BCh]
  int v683; // [sp+20h] [bp-2BCh]
  int v684; // [sp+20h] [bp-2BCh]
  int v685; // [sp+20h] [bp-2BCh]
  int v686; // [sp+20h] [bp-2BCh]
  int v687; // [sp+20h] [bp-2BCh]
  int v688; // [sp+20h] [bp-2BCh]
  int v689; // [sp+24h] [bp-2B8h]
  unsigned int v690; // [sp+24h] [bp-2B8h]
  int v691; // [sp+24h] [bp-2B8h]
  int v692; // [sp+24h] [bp-2B8h]
  int v693; // [sp+24h] [bp-2B8h]
  int v694; // [sp+24h] [bp-2B8h]
  int v695; // [sp+24h] [bp-2B8h]
  int v696; // [sp+24h] [bp-2B8h]
  int v697; // [sp+24h] [bp-2B8h]
  int v698; // [sp+24h] [bp-2B8h]
  int v699; // [sp+24h] [bp-2B8h]
  int v700; // [sp+24h] [bp-2B8h]
  int v701; // [sp+24h] [bp-2B8h]
  int v702; // [sp+24h] [bp-2B8h]
  int v703; // [sp+24h] [bp-2B8h]
  int v704; // [sp+24h] [bp-2B8h]
  int v705; // [sp+24h] [bp-2B8h]
  int v706; // [sp+28h] [bp-2B4h]
  int v707; // [sp+28h] [bp-2B4h]
  int v708; // [sp+28h] [bp-2B4h]
  int v709; // [sp+28h] [bp-2B4h]
  int v710; // [sp+28h] [bp-2B4h]
  int v711; // [sp+28h] [bp-2B4h]
  int v712; // [sp+28h] [bp-2B4h]
  int v713; // [sp+28h] [bp-2B4h]
  int v714; // [sp+28h] [bp-2B4h]
  int v715; // [sp+2Ch] [bp-2B0h]
  int v716; // [sp+2Ch] [bp-2B0h]
  unsigned int v717; // [sp+2Ch] [bp-2B0h]
  int v718; // [sp+2Ch] [bp-2B0h]
  int v719; // [sp+2Ch] [bp-2B0h]
  int v720; // [sp+2Ch] [bp-2B0h]
  int v721; // [sp+2Ch] [bp-2B0h]
  int v722; // [sp+2Ch] [bp-2B0h]
  int v723; // [sp+2Ch] [bp-2B0h]
  int v724; // [sp+2Ch] [bp-2B0h]
  int v725; // [sp+2Ch] [bp-2B0h]
  int v726; // [sp+2Ch] [bp-2B0h]
  int v727; // [sp+2Ch] [bp-2B0h]
  int v728; // [sp+2Ch] [bp-2B0h]
  int v729; // [sp+2Ch] [bp-2B0h]
  int v730; // [sp+30h] [bp-2ACh]
  int v731; // [sp+30h] [bp-2ACh]
  int v732; // [sp+30h] [bp-2ACh]
  unsigned int v733; // [sp+30h] [bp-2ACh]
  int v734; // [sp+30h] [bp-2ACh]
  int v735; // [sp+30h] [bp-2ACh]
  int v736; // [sp+30h] [bp-2ACh]
  int v737; // [sp+30h] [bp-2ACh]
  int v738; // [sp+30h] [bp-2ACh]
  int v739; // [sp+30h] [bp-2ACh]
  int v740; // [sp+30h] [bp-2ACh]
  unsigned int v741; // [sp+34h] [bp-2A8h]
  unsigned int v742; // [sp+34h] [bp-2A8h]
  unsigned int v743; // [sp+34h] [bp-2A8h]
  int v744; // [sp+34h] [bp-2A8h]
  int v745; // [sp+34h] [bp-2A8h]
  int v746; // [sp+34h] [bp-2A8h]
  int v747; // [sp+34h] [bp-2A8h]
  int v748; // [sp+34h] [bp-2A8h]
  int v749; // [sp+34h] [bp-2A8h]
  int v750; // [sp+34h] [bp-2A8h]
  int v751; // [sp+34h] [bp-2A8h]
  int v752; // [sp+34h] [bp-2A8h]
  int v753; // [sp+34h] [bp-2A8h]
  int v754; // [sp+38h] [bp-2A4h]
  int v755; // [sp+38h] [bp-2A4h]
  int v756; // [sp+38h] [bp-2A4h]
  int v757; // [sp+38h] [bp-2A4h]
  unsigned int v758; // [sp+38h] [bp-2A4h]
  int v759; // [sp+38h] [bp-2A4h]
  int v760; // [sp+38h] [bp-2A4h]
  int v761; // [sp+38h] [bp-2A4h]
  int v762; // [sp+38h] [bp-2A4h]
  int v763; // [sp+38h] [bp-2A4h]
  int v764; // [sp+38h] [bp-2A4h]
  int v765; // [sp+38h] [bp-2A4h]
  int v766; // [sp+38h] [bp-2A4h]
  int v767; // [sp+38h] [bp-2A4h]
  int v768; // [sp+3Ch] [bp-2A0h]
  int v769; // [sp+3Ch] [bp-2A0h]
  int v770; // [sp+3Ch] [bp-2A0h]
  int v771; // [sp+3Ch] [bp-2A0h]
  int v772; // [sp+3Ch] [bp-2A0h]
  int v773; // [sp+3Ch] [bp-2A0h]
  int v774; // [sp+3Ch] [bp-2A0h]
  int v775; // [sp+3Ch] [bp-2A0h]
  int v776; // [sp+3Ch] [bp-2A0h]
  int v777; // [sp+3Ch] [bp-2A0h]
  int v778; // [sp+3Ch] [bp-2A0h]
  int v779; // [sp+3Ch] [bp-2A0h]
  int v780; // [sp+3Ch] [bp-2A0h]
  int v781; // [sp+40h] [bp-29Ch]
  int v782; // [sp+40h] [bp-29Ch]
  int v783; // [sp+40h] [bp-29Ch]
  int v784; // [sp+40h] [bp-29Ch]
  int v785; // [sp+40h] [bp-29Ch]
  int v786; // [sp+40h] [bp-29Ch]
  int v787; // [sp+40h] [bp-29Ch]
  int v788; // [sp+40h] [bp-29Ch]
  int v789; // [sp+40h] [bp-29Ch]
  int v790; // [sp+40h] [bp-29Ch]
  int v791; // [sp+40h] [bp-29Ch]
  int v792; // [sp+44h] [bp-298h]
  int v793; // [sp+44h] [bp-298h]
  int v794; // [sp+44h] [bp-298h]
  int v795; // [sp+44h] [bp-298h]
  int v796; // [sp+44h] [bp-298h]
  int v797; // [sp+44h] [bp-298h]
  int v798; // [sp+44h] [bp-298h]
  int v799; // [sp+44h] [bp-298h]
  int v800; // [sp+44h] [bp-298h]
  int v801; // [sp+44h] [bp-298h]
  int v802; // [sp+44h] [bp-298h]
  unsigned int v803; // [sp+48h] [bp-294h]
  unsigned int v804; // [sp+48h] [bp-294h]
  int v805; // [sp+48h] [bp-294h]
  unsigned int v806; // [sp+48h] [bp-294h]
  int v807; // [sp+48h] [bp-294h]
  int v808; // [sp+48h] [bp-294h]
  int v809; // [sp+48h] [bp-294h]
  int v810; // [sp+4Ch] [bp-290h]
  int v811; // [sp+4Ch] [bp-290h]
  unsigned int v812; // [sp+4Ch] [bp-290h]
  int v813; // [sp+4Ch] [bp-290h]
  int v814; // [sp+4Ch] [bp-290h]
  int v815; // [sp+4Ch] [bp-290h]
  int v816; // [sp+4Ch] [bp-290h]
  int v817; // [sp+50h] [bp-28Ch]
  int v818; // [sp+50h] [bp-28Ch]
  int v819; // [sp+50h] [bp-28Ch]
  unsigned int v820; // [sp+50h] [bp-28Ch]
  int v821; // [sp+50h] [bp-28Ch]
  int v822; // [sp+54h] [bp-288h]
  int v823; // [sp+54h] [bp-288h]
  int v824; // [sp+54h] [bp-288h]
  int v825; // [sp+58h] [bp-284h]
  int *v826; // [sp+58h] [bp-284h]
  int v827; // [sp+58h] [bp-284h]
  int v828; // [sp+58h] [bp-284h]
  int *v829; // [sp+5Ch] [bp-280h]
  int v830; // [sp+5Ch] [bp-280h]
  int v831; // [sp+60h] [bp-27Ch]
  int v832; // [sp+60h] [bp-27Ch]
  int v834; // [sp+64h] [bp-278h]
  int v835; // [sp+68h] [bp-274h]
  int v836; // [sp+6Ch] [bp-270h]
  int v837; // [sp+70h] [bp-26Ch]
  int v838; // [sp+74h] [bp-268h]
  int v839; // [sp+78h] [bp-264h]
  int v840; // [sp+7Ch] [bp-260h]
  int v841; // [sp+80h] [bp-25Ch]
  int v842; // [sp+84h] [bp-258h]
  int v843; // [sp+88h] [bp-254h]
  int v844; // [sp+8Ch] [bp-250h]
  int v845; // [sp+90h] [bp-24Ch]
  int v846; // [sp+94h] [bp-248h]
  int v847; // [sp+98h] [bp-244h]
  int v848; // [sp+D4h] [bp-208h] BYREF
  int v849; // [sp+D8h] [bp-204h] BYREF
  int v850; // [sp+DCh] [bp-200h]
  int v851; // [sp+E0h] [bp-1FCh]
  int v852; // [sp+E4h] [bp-1F8h]
  int v853; // [sp+E8h] [bp-1F4h]
  int v854; // [sp+ECh] [bp-1F0h]
  int v855; // [sp+F0h] [bp-1ECh]
  int v856; // [sp+F4h] [bp-1E8h]
  int v857; // [sp+F8h] [bp-1E4h]
  int v858; // [sp+FCh] [bp-1E0h]
  int v859; // [sp+100h] [bp-1DCh]
  int v860; // [sp+104h] [bp-1D8h]
  int v861; // [sp+108h] [bp-1D4h] BYREF
  int v862; // [sp+10Ch] [bp-1D0h]
  int v863; // [sp+110h] [bp-1CCh]
  int v864; // [sp+114h] [bp-1C8h]
  int v865; // [sp+118h] [bp-1C4h] BYREF
  unsigned int v866; // [sp+11Ch] [bp-1C0h]
  int v867; // [sp+120h] [bp-1BCh]
  unsigned int v868; // [sp+124h] [bp-1B8h]
  int v869; // [sp+128h] [bp-1B4h]
  int v870; // [sp+12Ch] [bp-1B0h]
  int v871; // [sp+130h] [bp-1ACh]
  unsigned int v872; // [sp+134h] [bp-1A8h]
  int v873; // [sp+138h] [bp-1A4h]
  unsigned int v874; // [sp+13Ch] [bp-1A0h]
  int v875; // [sp+140h] [bp-19Ch]
  unsigned int v876; // [sp+144h] [bp-198h]
  int v877; // [sp+148h] [bp-194h] BYREF
  int v878; // [sp+14Ch] [bp-190h]
  int v879; // [sp+150h] [bp-18Ch]
  unsigned int v880; // [sp+154h] [bp-188h]
  int v881; // [sp+158h] [bp-184h] BYREF
  int v882; // [sp+15Ch] [bp-180h]
  int v883; // [sp+160h] [bp-17Ch]
  int v884; // [sp+164h] [bp-178h]
  int v885; // [sp+168h] [bp-174h]
  int v886; // [sp+16Ch] [bp-170h]
  int v887; // [sp+170h] [bp-16Ch]
  int v888; // [sp+174h] [bp-168h]
  int v889; // [sp+178h] [bp-164h]
  int v890; // [sp+17Ch] [bp-160h]
  int v891; // [sp+180h] [bp-15Ch]
  int v892; // [sp+184h] [bp-158h]
  int v893; // [sp+188h] [bp-154h]
  int v894; // [sp+18Ch] [bp-150h]
  int v895; // [sp+190h] [bp-14Ch]
  int v896; // [sp+194h] [bp-148h]
  int v897; // [sp+198h] [bp-144h]
  unsigned int v898; // [sp+19Ch] [bp-140h]
  int v899; // [sp+1A0h] [bp-13Ch]
  unsigned int v900; // [sp+1A4h] [bp-138h]
  int v901; // [sp+1A8h] [bp-134h]
  int v902; // [sp+1ACh] [bp-130h]
  int v903; // [sp+1B0h] [bp-12Ch]
  unsigned int v904; // [sp+1B4h] [bp-128h]
  int v905; // [sp+1B8h] [bp-124h]
  int v906; // [sp+1BCh] [bp-120h]
  int v907; // [sp+1C0h] [bp-11Ch]
  unsigned int v908; // [sp+1C4h] [bp-118h]
  int v909; // [sp+1C8h] [bp-114h] BYREF
  int v910; // [sp+1CCh] [bp-110h]
  int v911; // [sp+1D0h] [bp-10Ch]
  unsigned int v912; // [sp+1D4h] [bp-108h]
  int v913; // [sp+1D8h] [bp-104h]
  int v914; // [sp+1DCh] [bp-100h]
  int v915; // [sp+1E0h] [bp-FCh]
  int v916; // [sp+1E4h] [bp-F8h]
  int v917; // [sp+1E8h] [bp-F4h]
  int v918; // [sp+1ECh] [bp-F0h]
  int v919; // [sp+1F0h] [bp-ECh]
  int v920; // [sp+1F4h] [bp-E8h]
  int v921; // [sp+1F8h] [bp-E4h]
  int v922; // [sp+1FCh] [bp-E0h]
  int v923; // [sp+200h] [bp-DCh]
  int v924; // [sp+204h] [bp-D8h]
  int v925; // [sp+208h] [bp-D4h]
  int v926; // [sp+20Ch] [bp-D0h]
  int v927; // [sp+210h] [bp-CCh]
  int v928; // [sp+214h] [bp-C8h]
  int v929; // [sp+218h] [bp-C4h]
  unsigned int v930; // [sp+21Ch] [bp-C0h]
  int v931; // [sp+220h] [bp-BCh]
  unsigned int v932; // [sp+224h] [bp-B8h]
  int v933; // [sp+228h] [bp-B4h]
  int v934; // [sp+22Ch] [bp-B0h]
  int v935; // [sp+230h] [bp-ACh]
  unsigned int v936; // [sp+234h] [bp-A8h]
  int v937; // [sp+238h] [bp-A4h]
  unsigned int v938; // [sp+23Ch] [bp-A0h]
  int v939; // [sp+240h] [bp-9Ch]
  unsigned int v940; // [sp+244h] [bp-98h]
  int v941; // [sp+248h] [bp-94h]
  int v942; // [sp+24Ch] [bp-90h]
  int v943; // [sp+250h] [bp-8Ch]
  unsigned int v944; // [sp+254h] [bp-88h]
  int v945; // [sp+258h] [bp-84h]
  unsigned int v946; // [sp+25Ch] [bp-80h]
  int v947; // [sp+260h] [bp-7Ch]
  int v948; // [sp+264h] [bp-78h]
  int v949; // [sp+268h] [bp-74h]
  int v950; // [sp+26Ch] [bp-70h]
  int v951; // [sp+270h] [bp-6Ch]
  int v952; // [sp+274h] [bp-68h]
  int v953; // [sp+278h] [bp-64h]
  unsigned int v954; // [sp+27Ch] [bp-60h]
  int v955; // [sp+280h] [bp-5Ch]
  int v956; // [sp+284h] [bp-58h]
  int v957; // [sp+288h] [bp-54h]
  int v958; // [sp+28Ch] [bp-50h]
  int v959; // [sp+290h] [bp-4Ch]
  int v960; // [sp+294h] [bp-48h]
  int v961; // [sp+298h] [bp-44h]
  int v962; // [sp+29Ch] [bp-40h]
  int v963; // [sp+2A0h] [bp-3Ch]
  int v964; // [sp+2A4h] [bp-38h]
  int v965; // [sp+2A8h] [bp-34h]
  int v966; // [sp+2ACh] [bp-30h]
  int v967; // [sp+2B0h] [bp-2Ch]
  int v968; // [sp+2B4h] [bp-28h]
  int v969; // [sp+2B8h] [bp-24h]
  unsigned int v970; // [sp+2BCh] [bp-20h]
  int v971; // [sp+2C0h] [bp-1Ch]
  int v972; // [sp+2C4h] [bp-18h]
  int v973; // [sp+2C8h] [bp-14h]
  int v974; // [sp+2CCh] [bp-10h]
  int v975; // [sp+2D0h] [bp-Ch]
  _DWORD v976[2]; // [sp+2D4h] [bp-8h] BYREF

  v2 = a1[56];
  v3 = a1[24];
  v4 = a1[60];
  v5 = a1[28];
  v568 = a1[16];
  v6 = a1[48];
  v689 = a1[44];
  v625 = a1[52];
  v657 = a1[40];
  v605 = a1[20];
  v588 = a1[8];
  v642 = a1[32];
  v7 = (unsigned __int8)(((_BYTE)v2 << 6) + 4 * v3) - ((unsigned int)((v2 << 6) + 4 * v3) >> 8);
  v552 = *a1;
  v8 = (unsigned __int8)(((_BYTE)v6 << 6) + 4 * v568) - ((unsigned int)((v6 << 6) + 4 * v568) >> 8);
  v674 = a1[36];
  v9 = 16 * v657 + v588;
  v10 = v588 - 16 * v657;
  v11 = (unsigned __int8)(4 * v2 + ((_BYTE)v3 << 6)) - ((unsigned int)(4 * v2 + (v3 << 6)) >> 8);
  v12 = 2 * (v9 + v7);
  v13 = 32 * (v9 - v7);
  v803 = (unsigned __int8)(((_BYTE)v4 << 6) + 4 * v5) - ((unsigned int)((v4 << 6) + 4 * v5) >> 8);
  v14 = a1[12];
  v15 = 16 * v642 + v552;
  v768 = v3 + v2;
  v16 = 16 * v3 - 16 * v2;
  v17 = 4 * v4 + (v5 << 6);
  v781 = v16;
  v18 = 16 * v4;
  v19 = v552 - 16 * v642;
  v792 = v5 + v4;
  v20 = v15 + v8;
  v810 = 16 * v5 - v18;
  v21 = v15 - v8;
  v22 = v12 + v20;
  v858 = v20 - v12;
  v854 = v13 + v21;
  v23 = (unsigned __int8)v17 - (v17 >> 8);
  v862 = v21 - v13;
  v24 = a1[4];
  v25 = (unsigned __int8)(((_BYTE)v625 << 6) + 4 * v605) - ((unsigned int)((v625 << 6) + 4 * v605) >> 8);
  v26 = 8 * (v10 + v11);
  v817 = v23;
  v27 = (unsigned __int8)(4 * v6 + ((_BYTE)v568 << 6)) - ((unsigned int)(4 * v6 + (v568 << 6)) >> 8);
  v28 = v10 - v11;
  v29 = 16 * v568 - 16 * v6;
  v715 = v568 + v6;
  v30 = v19 + v27;
  v850 = v22;
  v28 <<= 7;
  v730 = v605 + v625;
  v31 = v19 - v27;
  v754 = 16 * v605 - 16 * v625;
  v852 = v26 + v30;
  v860 = v30 - v26;
  v741 = (unsigned __int8)(4 * v625 + ((_BYTE)v605 << 6)) - ((unsigned int)(4 * v625 + (v605 << 6)) >> 8);
  v32 = 16 * v689 + v14;
  v569 = v14 - 16 * v689;
  v33 = v588 - v657;
  v34 = v588 + v657;
  v35 = v14 - v689;
  v36 = v14 + v689;
  v856 = v28 + v31;
  v37 = 16 * v674 + v24;
  v864 = v31 - v28;
  v38 = 2 * (v32 + v803);
  v589 = 32 * (v32 - v803);
  v626 = v24 - 16 * v674;
  v658 = v37 - v25;
  v39 = v38 + v37 + v25;
  v874 = v37 + v25 - v38;
  v40 = v552 + v642;
  v41 = 4 * (v33 + v781);
  v42 = v552 - v642 + v29;
  v690 = v39;
  v43 = v552 - v642 - v29;
  v866 = v39;
  v851 = v41 + v42;
  v44 = (v33 - v781) << 6;
  v859 = v42 - v41;
  v45 = 16 * (v34 - v768);
  v46 = 4 * (v35 + v810);
  v606 = (v35 - v810) << 6;
  v47 = (v569 - v817) << 7;
  v48 = v24 - v674;
  v553 = 8 * (v569 + v817);
  v49 = v36 - v792;
  v50 = v36 + v792;
  v570 = 16 * v49;
  v51 = v40 + v715;
  v52 = v40 - v715;
  v53 = v24 + v674 - v730;
  v855 = v44 + v43;
  v643 = v24 + v674 + v730;
  v857 = v51 - (v34 + v768);
  v54 = v24 - v674 + v754;
  v55 = v48 - v754;
  v863 = v43 - v44;
  v56 = v51 + v34 + v768;
  v873 = v643 - v50;
  v867 = v46 + v54;
  v853 = v45 + v52;
  v861 = v52 - v45;
  v57 = 120;
  v878 = v658 - v589;
  v875 = v54 - v46;
  v870 = v589 + v658;
  v868 = v553 + v626 + v741;
  v58 = v47 + v626 - v741;
  v876 = v626 + v741 - v553;
  v880 = v626 - v741 - v47;
  v59 = v606 + v55;
  v879 = v55 - v606;
  v60 = v56 + v643 + v50;
  v61 = v56 - (v643 + v50);
  v871 = v59;
  v62 = v570 + v53;
  v63 = v53 - v570;
  v849 = v60;
  v64 = &v849;
  v877 = v63;
  v65 = 2;
  v66 = &unk_F4328;
  v67 = 60;
  v872 = v58;
  v865 = v61;
  v869 = v62;
  v68 = v690;
  while ( 1 )
  {
    v69 = v68 * v67;
    v70 = v64[2];
    v71 = v64[18] * v65;
    v72 = (unsigned __int16)v69 + (v69 >> 16);
    v73 = v64[3];
    v74 = (unsigned __int16)v71 + (v71 >> 16);
    v75 = (unsigned __int16)(*((_WORD *)v64 + 38) * v57) + ((v64[19] * v57) >> 16);
    v64[2] = v70 + v74;
    v64[18] = v70 - v74;
    v64[3] = v73 + v75;
    v64[19] = v73 - v75;
    v64[1] = v72 + v22;
    v64[17] = v22 - v72;
    if ( &v861 == v64 )
      break;
    v76 = v64[20];
    v66 += 32;
    v64 += 4;
    v67 = v66[8];
    v65 = v66[16];
    v57 = v66[24];
    v22 = v64[1];
    v68 = v64[17];
    v77 = (unsigned __int16)(v76 * *(_WORD *)v66) + ((v76 * *v66) >> 16);
    v78 = *v64 - v77;
    *v64 += v77;
    v64[16] = v78;
  }
  v79 = a1[62];
  v80 = a1[58];
  v81 = a1[26];
  v82 = a1[30];
  v571 = a1[18];
  v607 = a1[22];
  v659 = a1[42];
  v83 = a1[10];
  v627 = a1[54];
  v691 = a1[46];
  v769 = a1[50];
  v644 = a1[34];
  v84 = (unsigned __int8)(((_BYTE)v80 << 6) + 4 * v81) - ((unsigned int)((v80 << 6) + 4 * v81) >> 8);
  v554 = a1[2];
  v85 = (unsigned __int8)(((_BYTE)v769 << 6) + 4 * v571) - ((unsigned int)((v769 << 6) + 4 * v571) >> 8);
  v675 = a1[38];
  v86 = 16 * v659 + v83;
  v87 = v83 - 16 * v659;
  v88 = (unsigned __int8)(4 * v80 + ((_BYTE)v81 << 6)) - ((unsigned int)(4 * v80 + (v81 << 6)) >> 8);
  v89 = 16 * v81 - 16 * v80;
  v782 = v81 + v80;
  v90 = v82 + v79;
  v804 = (unsigned __int8)(((_BYTE)v79 << 6) + 4 * v82) - ((unsigned int)((v79 << 6) + 4 * v82) >> 8);
  v91 = 2 * (v86 + v84);
  v811 = 16 * v82 - 16 * v79;
  v92 = 32 * (v86 - v84);
  v93 = 4 * v79 + (v82 << 6);
  v94 = a1[14];
  v95 = 16 * v644 + v554;
  v96 = v95 + v85;
  v97 = v95 - v85;
  v825 = v91 + v96;
  v98 = v554 - 16 * v644;
  v882 = v91 + v96;
  v818 = (unsigned __int8)v93 - (v93 >> 8);
  v890 = v96 - v91;
  v886 = v92 + v97;
  v894 = v97 - v92;
  v99 = a1[6];
  v100 = 8 * (v87 + v88);
  v101 = (unsigned __int8)(4 * v769 + ((_BYTE)v571 << 6)) - ((unsigned int)(4 * v769 + (v571 << 6)) >> 8);
  v793 = v90;
  v102 = (v87 - v88) << 7;
  v103 = (unsigned __int8)(((_BYTE)v627 << 6) + 4 * v607) - ((unsigned int)((v627 << 6) + 4 * v607) >> 8);
  v716 = v571 + v769;
  v104 = 16 * v571 - 16 * v769;
  v105 = v98 + v101;
  v106 = v98 - v101;
  v731 = v607 + v627;
  v755 = 16 * v607 - 16 * v627;
  v107 = v100 + v105;
  v742 = (unsigned __int8)(4 * v627 + ((_BYTE)v607 << 6)) - ((unsigned int)(4 * v627 + (v607 << 6)) >> 8);
  v892 = v105 - v100;
  v108 = v102 + v106;
  v896 = v106 - v102;
  v884 = v107;
  v109 = 16 * v691 + v94;
  v608 = v94 - 16 * v691;
  v110 = v83 - v659;
  v111 = v83 + v659;
  v112 = v94 - v691;
  v888 = v108;
  v692 = v94 + v691;
  v628 = v99 - 16 * v675;
  v113 = 2 * (v109 + v804);
  v572 = 32 * (v109 - v804);
  v114 = 16 * v675 + v99;
  v115 = v114 + v103;
  v660 = v114 - v103;
  v116 = v113 + v114 + v103;
  v906 = v115 - v113;
  v117 = 4 * (v110 + v89);
  v118 = (v110 - v89) << 6;
  v119 = v554 - v644 + v104;
  v120 = v554 - v644 - v104;
  v891 = v119 - v117;
  v121 = 16 * (v111 - v782);
  v122 = v111 + v782;
  v123 = v112 + v811;
  v883 = v117 + v119;
  v898 = v116;
  v124 = v99 - v675;
  v590 = (v112 - v811) << 6;
  v125 = v99 + v675;
  v123 *= 4;
  v126 = 8 * (v608 + v818);
  v609 = (v608 - v818) << 7;
  v127 = v554 + v644 + v716;
  v128 = v554 + v644 - v716;
  v129 = v125 + v731;
  v130 = v125 - v731;
  v887 = v118 + v120;
  v895 = v120 - v118;
  v131 = v127 + v122;
  v889 = v127 - v122;
  v132 = v129 + v692 + v793;
  v133 = v124 + v755;
  v134 = v124 - v755;
  v899 = v123 + v133;
  v885 = v121 + v128;
  v135 = 120;
  v893 = v128 - v121;
  v136 = 2;
  v907 = v133 - v123;
  v902 = v572 + v660;
  v910 = v660 - v572;
  v137 = v628 + v742 - v126;
  v900 = v126 + v628 + v742;
  v138 = v825;
  v904 = v609 + v628 - v742;
  v912 = v628 - v742 - v609;
  v139 = 16 * (v692 - v793);
  v903 = v590 + v134;
  v881 = v131 + v132;
  v140 = v131 - v132;
  v141 = v130 - v139;
  v901 = v139 + v130;
  v142 = &unk_F4328;
  v143 = &v849;
  v144 = 60;
  v908 = v137;
  v911 = v134 - v590;
  v905 = v129 - (v692 + v793);
  v897 = v140;
  v909 = v141;
  while ( 1 )
  {
    v145 = v143[50];
    v146 = v116 * v144;
    v147 = v143[51];
    v143 += 4;
    v148 = v143[30];
    v149 = v147 * v135;
    v150 = (unsigned __int16)v146 + (v146 >> 16);
    v151 = v143[31];
    v152 = (unsigned __int16)(v145 * v136) + ((v145 * v136) >> 16);
    v153 = (unsigned __int16)v149 + (v149 >> 16);
    v143[30] = v148 + v152;
    v143[46] = v148 - v152;
    v143[31] = v151 + v153;
    v143[47] = v151 - v153;
    v143[29] = v150 + v138;
    v143[45] = v138 - v150;
    if ( &v865 == v143 )
      break;
    v142 += 32;
    v154 = v143[32];
    v144 = v142[8];
    v136 = v142[16];
    v135 = v142[24];
    v138 = v143[33];
    v116 = v143[49];
    v155 = (unsigned __int16)(*((_WORD *)v143 + 96) * *(_WORD *)v142) + ((v143[48] * *v142) >> 16);
    v143[32] = v154 + v155;
    v143[48] = v154 - v155;
  }
  v156 = &unk_F4368;
  v157 = &v849;
  v158 = v849 - v881;
  v849 += v881;
  v159 = &unk_F4368;
  v881 = v158;
  v160 = 190;
  v161 = 46;
  v162 = 60;
  while ( 1 )
  {
    v159 += 16;
    v166 = v157[1];
    v167 = v157[33] * v161;
    v168 = v157[2];
    v169 = (unsigned __int16)v167 + (v167 >> 16);
    v170 = (unsigned __int16)(*((_WORD *)v157 + 70) * v160) + ((v157[35] * v160) >> 16);
    v171 = v157[3];
    v172 = (unsigned __int16)(*((_WORD *)v157 + 68) * v162) + ((v157[34] * v162) >> 16);
    v157[1] = v166 + v169;
    v157[33] = v166 - v169;
    v157[2] = v168 + v172;
    v157[34] = v168 - v172;
    v157[3] = v171 + v170;
    v157[35] = v171 - v170;
    if ( &v877 == v157 )
      break;
    v163 = v157[36];
    v157 += 4;
    v161 = *(v159 - 12);
    v162 = *(v159 - 8);
    v160 = *(v159 - 4);
    v164 = (unsigned __int16)(v163 * *((_WORD *)v159 - 32)) + ((v163 * *(v159 - 16)) >> 16);
    v165 = *v157 - v164;
    *v157 += v164;
    v157[32] = v165;
  }
  v826 = v143;
  v173 = a1[61];
  v174 = a1[29];
  v610 = a1[53];
  v591 = a1[21];
  v645 = a1[41];
  v573 = a1[17];
  v175 = a1[57];
  v176 = a1[25];
  v743 = 4 * v173 + (v174 << 6);
  v756 = a1[49];
  v629 = a1[33];
  v177 = (unsigned __int8)(((_BYTE)v175 << 6) + 4 * v176) - ((unsigned int)((v175 << 6) + 4 * v176) >> 8);
  v555 = a1[1];
  v178 = (unsigned __int8)(((_BYTE)v756 << 6) + 4 * v573) - ((unsigned int)((v756 << 6) + 4 * v573) >> 8);
  v179 = a1[9];
  v661 = a1[37];
  v180 = 16 * v645 + v179;
  v181 = 2 * (v180 + v177);
  v770 = v179 - 16 * v645;
  v182 = 32 * (v180 - v177);
  v183 = (unsigned __int8)(4 * v175 + ((_BYTE)v176 << 6)) - ((unsigned int)(4 * v175 + (v176 << 6)) >> 8);
  v812 = (unsigned __int8)(((_BYTE)v173 << 6) + 4 * v174) - ((unsigned int)((v173 << 6) + 4 * v174) >> 8);
  v184 = a1[13];
  v185 = 16 * v175;
  v186 = v176 + v175;
  v187 = 16 * v176 - v185;
  v188 = 16 * v629 + v555;
  v189 = a1[45];
  v783 = v187;
  v732 = v186;
  v190 = v555 - 16 * v629;
  v191 = 16 * v173;
  v805 = v174 + v173;
  v192 = v188 + v178;
  v193 = v188 - v178;
  v819 = 16 * v174 - v191;
  v831 = v181 + v192;
  v914 = v181 + v192;
  v922 = v192 - v181;
  v822 = (unsigned __int8)v743 - (v743 >> 8);
  v918 = v182 + v193;
  v194 = a1[5];
  v926 = v193 - v182;
  v195 = (unsigned __int8)(4 * v756 + ((_BYTE)v573 << 6)) - ((unsigned int)(4 * v756 + (v573 << 6)) >> 8);
  v196 = 8 * (v770 + v183);
  v197 = (v770 - v183) << 7;
  v198 = (unsigned __int8)(((_BYTE)v610 << 6) + 4 * v591) - ((unsigned int)((v610 << 6) + 4 * v591) >> 8);
  v676 = v573 + v756;
  v574 = 16 * v573 - 16 * v756;
  v199 = v190 + v195;
  v200 = v190 - v195;
  v744 = v591 + v610;
  v757 = 16 * v591 - 16 * v610;
  v916 = v196 + v199;
  v201 = v197 + v200;
  v202 = v200 - v197;
  v924 = v199 - v196;
  v203 = 16 * v189 + v184;
  v717 = (unsigned __int8)(4 * v610 + ((_BYTE)v591 << 6)) - ((unsigned int)(4 * v610 + (v591 << 6)) >> 8);
  v920 = v201;
  v204 = 2 * (v203 + v812);
  v205 = 16 * v661 + v194;
  v794 = v184 - 16 * v189;
  v206 = v184 - v189;
  v207 = v184 + v189;
  v208 = v205 - v198;
  v592 = v207;
  v928 = v202;
  v938 = v205 + v198 - v204;
  v209 = v204 + v205 + v198;
  v611 = 32 * (v203 - v812);
  v693 = v194 - 16 * v661;
  v210 = v555 + v629;
  v211 = 4 * (v179 - v645 + v783);
  v771 = v208;
  v212 = (v179 - v645 - v783) << 6;
  v213 = v555 - v629 + v574;
  v930 = v209;
  v214 = v555 - v629 - v574;
  v215 = v179 + v645 + v732;
  v216 = 16 * (v179 + v645 - v732);
  v915 = v211 + v213;
  v575 = 4 * (v206 + v819);
  v630 = (v206 - v819) << 6;
  v923 = v213 - v211;
  v217 = v194 + v661;
  v218 = v194 - v661;
  v219 = 8 * (v794 + v822);
  v220 = v592 + v805;
  v593 = 16 * (v592 - v805);
  v221 = v210 + v676;
  v222 = v210 - v676;
  v223 = v217 + v744;
  v224 = v217 - v744;
  v919 = v212 + v214;
  v927 = v214 - v212;
  v225 = v218 + v757;
  v921 = v221 - v215;
  v226 = v218 - v757;
  v556 = v221 + v215;
  v917 = v216 + v222;
  v227 = v223 + v220;
  v228 = v223 - v220;
  v931 = v575 + v225;
  v942 = v771 - v611;
  v932 = v219 + v693 + v717;
  v229 = (v794 - v822) << 7;
  v934 = v611 + v771;
  v230 = v229 + v693 - v717;
  v944 = v693 - v717 - v229;
  v935 = v630 + v226;
  v943 = v226 - v630;
  v231 = 2;
  v925 = v222 - v216;
  v232 = 60;
  v913 = v556 + v227;
  v933 = v593 + v224;
  v233 = v224 - v593;
  v929 = v556 - v227;
  v234 = &v849;
  v235 = 120;
  v236 = &unk_F4328;
  v237 = v831;
  v939 = v225 - v575;
  v940 = v693 + v717 - v219;
  v936 = v230;
  v937 = v228;
  v941 = v233;
  while ( 1 )
  {
    v238 = v234[82];
    v239 = v209 * v232;
    v240 = v234[83];
    v234 += 4;
    v241 = v234[62];
    v242 = v238 * v231;
    v243 = v234[63];
    v244 = v240 * v235;
    v245 = (unsigned __int16)v239 + (v239 >> 16);
    v246 = (unsigned __int16)v242 + (v242 >> 16);
    v247 = (unsigned __int16)v244 + (v244 >> 16);
    v234[62] = v241 + v246;
    v234[78] = v241 - v246;
    v234[63] = v243 + v247;
    v234[79] = v243 - v247;
    v234[61] = v245 + v237;
    v234[77] = v237 - v245;
    if ( v826 == v234 )
      break;
    v236 += 32;
    v248 = v234[64];
    v232 = v236[8];
    v231 = v236[16];
    v235 = v236[24];
    v237 = v234[65];
    v209 = v234[81];
    v249 = (unsigned __int16)(*((_WORD *)v234 + 160) * *(_WORD *)v236) + ((v234[80] * *v236) >> 16);
    v234[64] = v248 + v249;
    v234[80] = v248 - v249;
  }
  v829 = v234;
  v250 = a1[63];
  v251 = a1[31];
  v612 = a1[23];
  v576 = a1[19];
  v758 = 4 * v250 + (v251 << 6);
  v252 = a1[11];
  v631 = a1[55];
  v677 = a1[47];
  v772 = a1[51];
  v253 = a1[27];
  v254 = a1[59];
  v646 = a1[35];
  v784 = a1[43];
  v255 = (unsigned __int8)(((_BYTE)v254 << 6) + 4 * v253) - ((unsigned int)((v254 << 6) + 4 * v253) >> 8);
  v557 = a1[3];
  v662 = a1[39];
  v256 = 16 * v784 + v252;
  v795 = v252 - 16 * v784;
  v257 = (unsigned __int8)(((_BYTE)v772 << 6) + 4 * v576) - ((unsigned int)((v772 << 6) + 4 * v576) >> 8);
  v258 = 16 * v254;
  v806 = (unsigned __int8)(4 * v254 + ((_BYTE)v253 << 6)) - ((unsigned int)(4 * v254 + (v253 << 6)) >> 8);
  v259 = v253 + v254;
  v260 = 2 * (v256 + v255);
  v261 = 32 * (v256 - v255);
  v262 = 16 * v646 + v557;
  v263 = v557 - 16 * v646;
  v820 = (unsigned __int8)(((_BYTE)v250 << 6) + 4 * v251) - ((unsigned int)((v250 << 6) + 4 * v251) >> 8);
  v264 = a1[15];
  v265 = 16 * v253 - v258;
  v813 = v251 + v250;
  v266 = v260 + v262 + v257;
  v745 = v265;
  v823 = 16 * v251 - 16 * v250;
  v267 = v262 + v257 - v260;
  v268 = v262 - v257;
  v954 = v267;
  v946 = v266;
  v958 = v268 - v261;
  v269 = a1[7];
  v950 = v261 + v268;
  v270 = (unsigned __int8)(4 * v772 + ((_BYTE)v576 << 6)) - ((unsigned int)(4 * v772 + (v576 << 6)) >> 8);
  v827 = (unsigned __int8)v758 - (v758 >> 8);
  v271 = (unsigned __int8)(((_BYTE)v631 << 6) + 4 * v612) - ((unsigned int)((v631 << 6) + 4 * v612) >> 8);
  v272 = (v795 - v806) << 7;
  v273 = 8 * (v795 + v806);
  v694 = v576 + v772;
  v718 = 16 * v576 - 16 * v772;
  v274 = v263 + v270;
  v275 = v263 - v270;
  v759 = v612 + v631;
  v773 = 16 * v612 - 16 * v631;
  v276 = (unsigned __int8)(4 * v631 + ((_BYTE)v612 << 6)) - ((unsigned int)(4 * v631 + (v612 << 6)) >> 8);
  v948 = v273 + v274;
  v613 = v264 - 16 * v677;
  v277 = v272 + v275;
  v278 = v275 - v272;
  v956 = v274 - v273;
  v279 = v252 - v784;
  v280 = v252 + v784;
  v733 = v276;
  v281 = 16 * v677 + v264;
  v952 = v277;
  v282 = v264 - v677;
  v283 = v264 + v677;
  v960 = v278;
  v284 = 2 * (v281 + v820);
  v632 = 32 * (v281 - v820);
  v285 = 16 * v662 + v269;
  v286 = v285 + v271;
  v785 = v285 - v271;
  v287 = v285 + v271 - v284;
  v288 = v284 + v286;
  v970 = v287;
  v678 = v269 - 16 * v662;
  v962 = v284 + v286;
  v289 = v557 + v646;
  v290 = 4 * (v279 + v745);
  v577 = (v279 - v745) << 6;
  v291 = v557 - v646 + v718;
  v292 = v557 - v646 - v718;
  v293 = v290 + v291;
  v294 = v291 - v290;
  v295 = v280 - v259;
  v296 = v280 + v259;
  v947 = v293;
  v558 = 16 * v295;
  v297 = v269 + v662;
  v594 = 4 * (v282 + v823);
  v647 = (v282 - v823) << 6;
  v298 = v269 - v662;
  v955 = v294;
  v299 = 8 * (v613 + v827);
  v663 = (v613 - v827) << 7;
  v300 = v283 + v813;
  v614 = 16 * (v283 - v813);
  v301 = v289 + v694;
  v302 = v289 - v694;
  v719 = v297 - v759;
  v695 = v297 + v759;
  v951 = v577 + v292;
  v303 = v298 + v773;
  v304 = v298 - v773;
  v959 = v292 - v577;
  v305 = v301 + v296;
  v953 = v301 - v296;
  v306 = v695 + v300;
  v969 = v695 - v300;
  v957 = v302 - v558;
  v963 = v594 + v303;
  v966 = v632 + v785;
  v974 = v785 - v632;
  v964 = v299 + v678 + v733;
  v976[0] = v678 - v733 - v663;
  v967 = v647 + v304;
  v975 = v304 - v647;
  v945 = v305 + v695 + v300;
  v307 = 120;
  v972 = v678 + v733 - v299;
  v308 = &unk_F4328;
  v309 = &v849;
  v965 = v614 + v719;
  v310 = 2;
  v949 = v558 + v302;
  v311 = 60;
  v971 = v303 - v594;
  v968 = v663 + v678 - v733;
  v961 = v305 - v306;
  v973 = v719 - v614;
  while ( 1 )
  {
    v312 = v309[114];
    v313 = v309[115];
    v309 += 4;
    v314 = v309[94];
    v315 = v312 * v310;
    v316 = (unsigned __int16)(v288 * v311) + ((v288 * v311) >> 16);
    v317 = v309[95];
    v318 = (unsigned __int16)v315 + (v315 >> 16);
    v319 = (unsigned __int16)(v313 * v307) + ((v313 * v307) >> 16);
    v309[94] = v314 + v318;
    v309[110] = v314 - v318;
    v309[95] = v317 + v319;
    v309[111] = v317 - v319;
    v309[93] = v316 + v266;
    v309[109] = v266 - v316;
    if ( v829 == v309 )
      break;
    v308 += 32;
    v320 = v309[96];
    v311 = v308[8];
    v310 = v308[16];
    v266 = v309[97];
    v288 = v309[113];
    v321 = (unsigned __int16)(*((_WORD *)v309 + 224) * *(_WORD *)v308) + ((v309[112] * *v308) >> 16);
    v307 = v308[24];
    v309[96] = v320 + v321;
    v309[112] = v320 - v321;
  }
  v322 = &v849;
  v323 = 190;
  v324 = 60;
  v325 = 46;
  v326 = v913 - v945;
  v913 += v945;
  v945 = v326;
  while ( 1 )
  {
    v330 = v322[98];
    v322 += 4;
    v156 += 16;
    v331 = v322[61];
    v332 = v322[62];
    v333 = v322[95] * v323;
    v334 = v322[63];
    v335 = (unsigned __int16)(v330 * v324) + ((v330 * v324) >> 16);
    v336 = (unsigned __int16)v333 + (v333 >> 16);
    v337 = (unsigned __int16)(*((_WORD *)v322 + 186) * v325) + ((v322[93] * v325) >> 16);
    v322[61] = v331 + v337;
    v322[93] = v331 - v337;
    v322[62] = v332 + v335;
    v322[94] = v332 - v335;
    v322[63] = v334 + v336;
    v322[95] = v334 - v336;
    if ( &v881 == v322 )
      break;
    v327 = v322[64];
    v325 = *(v156 - 12);
    v324 = *(v156 - 8);
    v328 = v322[96] * *(v156 - 16);
    v323 = *(v156 - 4);
    v329 = (unsigned __int16)v328 + (v328 >> 16);
    v322[64] = v327 + v329;
    v322[96] = v327 - v329;
  }
  v338 = 46;
  v339 = &v849;
  v340 = &unk_F4348;
  v341 = v849 - v913;
  v342 = 226;
  v849 += v913;
  v913 = v341;
  v343 = 139;
  while ( 1 )
  {
    v340 += 8;
    v347 = v339[1];
    v348 = v339[2];
    v349 = v339[3];
    v350 = (unsigned __int16)(*((_WORD *)v339 + 132) * v338) + ((v339[66] * v338) >> 16);
    v351 = (unsigned __int16)(*((_WORD *)v339 + 134) * v342) + ((v339[67] * v342) >> 16);
    v352 = (unsigned __int16)(*((_WORD *)v339 + 130) * v343) + ((v339[65] * v343) >> 16);
    v339[1] = v347 + v352;
    v339[65] = v347 - v352;
    v339[2] = v348 + v350;
    v339[66] = v348 - v350;
    v339[3] = v349 + v351;
    v339[67] = v349 - v351;
    if ( &v909 == v339 )
      break;
    v344 = v339[68];
    v339 += 4;
    v343 = *(v340 - 6);
    v338 = *(v340 - 4);
    v342 = *(v340 - 2);
    v345 = (unsigned __int16)(v344 * *((_WORD *)v340 - 16)) + ((v344 * *(v340 - 8)) >> 16);
    v346 = *v339 - v345;
    *v339 += v345;
    v339[64] = v346;
  }
  if ( a2 )
  {
    v544 = (unsigned __int16 *)&unk_F4828;
    v545 = &v848;
    for ( i = 2; ; i = v547 )
    {
      v548 = v545[1];
      ++v545;
      v549 = (unsigned __int16)(i + v548) + ((i + v548) >> 16);
      v550 = (unsigned __int8)(v549 - BYTE1(v549)) - (((unsigned __int8)v549 - (v549 >> 8)) >> 8);
      if ( v550 > 128 )
        v550 -= 257;
      *v545 = v550;
      if ( v545 == v976 )
        break;
      v547 = v544[1];
      ++v544;
    }
  }
  else
  {
    v353 = &v848;
    v354 = (unsigned __int16 *)&unk_F4728;
    for ( j = 1; ; j = v356 )
    {
      v357 = v353[1];
      ++v353;
      v358 = (unsigned __int16)(j + v357) + ((j + v357) >> 16);
      v359 = (unsigned __int8)(v358 - BYTE1(v358)) - (((unsigned __int8)v358 - (v358 >> 8)) >> 8);
      if ( v359 > 128 )
        v359 -= 257;
      *v353 = v359;
      if ( v976 == v353 )
        break;
      v356 = v354[1];
      ++v354;
    }
  }
  v830 = *((_DWORD *)a1 + 24);
  v832 = *((_DWORD *)a1 + 25);
  v824 = *((_DWORD *)a1 + 22);
  v828 = *((_DWORD *)a1 + 23);
  v834 = *((_DWORD *)a1 + 26);
  v836 = *((_DWORD *)a1 + 28);
  v837 = *((_DWORD *)a1 + 29);
  v839 = *((_DWORD *)a1 + 31);
  v835 = *((_DWORD *)a1 + 27);
  v838 = *((_DWORD *)a1 + 30);
  v840 = *((_DWORD *)a1 + 32);
  v360 = *((_DWORD *)a1 + 18) ^ *((_DWORD *)a1 + 1);
  v841 = *((_DWORD *)a1 + 17);
  v559 = *(_DWORD *)a1 ^ v841;
  v842 = *((_DWORD *)a1 + 18);
  v844 = *((_DWORD *)a1 + 20);
  v615 = v844 ^ *((_DWORD *)a1 + 3);
  v843 = *((_DWORD *)a1 + 19);
  v361 = v834 ^ *((_DWORD *)a1 + 9);
  v664 = v830 ^ *((_DWORD *)a1 + 7);
  v845 = *((_DWORD *)a1 + 21);
  v720 = v835 ^ *((_DWORD *)a1 + 10);
  v734 = v836 ^ *((_DWORD *)a1 + 11);
  v679 = v845 ^ *((_DWORD *)a1 + 4);
  v696 = v824 ^ *((_DWORD *)a1 + 5);
  v706 = v828 ^ *((_DWORD *)a1 + 6);
  v362 = (v696 ^ v361) & v360;
  v363 = __ROR4__(v360, 29);
  v364 = v363
       + __ROR4__(
           (unsigned __int16)(185 * v881)
         + 12124160 * v882
         + (v837 ^ *((_DWORD *)a1 + 12))
         + ((v679 ^ v832 ^ *((_DWORD *)a1 + 8)) & v559 ^ v832 ^ *((_DWORD *)a1 + 8)),
           9);
  v560 = __ROR4__(v559, 29);
  v365 = __ROR4__(v843 ^ *((_DWORD *)a1 + 2), 29);
  v578 = __ROR4__(v615, 29);
  v366 = v365
       + __ROR4__(
           (unsigned __int16)(185 * v887)
         + 12124160 * v888
         + (v840 ^ *((_DWORD *)a1 + 15))
         + ((v664 ^ v734) & v615 ^ v734),
           9);
  v746 = v363;
  v367 = v560
       + __ROR4__((unsigned __int16)(185 * v883) + 12124160 * v884 + (v838 ^ *((_DWORD *)a1 + 13)) + (v362 ^ v361), 9);
  v368 = v578
       + __ROR4__(
           (unsigned __int16)(185 * v885)
         + 12124160 * v886
         + (v839 ^ *((_DWORD *)a1 + 14))
         + ((v706 ^ v720) & (v843 ^ *((_DWORD *)a1 + 2)) ^ v720),
           9);
  v760 = v365;
  v616 = __ROR4__(v367, 9);
  v595 = __ROR4__(v364, 9);
  v633 = __ROR4__(v368, 9);
  v648 = __ROR4__(v366, 9);
  v369 = v633
       + __ROR4__(
           (unsigned __int16)(185 * v897)
         + 12124160 * v898
         + (v832 ^ *((_DWORD *)a1 + 8))
         + ((v679 ^ v560) & v364 ^ v679),
           15);
  v370 = v648 + __ROR4__((unsigned __int16)(185 * v899) + 12124160 * v900 + v361 + ((v696 ^ v363) & v367 ^ v696), 15);
  v371 = v595 + __ROR4__((unsigned __int16)(185 * v901) + 12124160 * v902 + v720 + ((v706 ^ v365) & v368 ^ v706), 15);
  v372 = v616 + __ROR4__((unsigned __int16)(185 * v903) + 12124160 * v904 + v734 + ((v664 ^ v578) & v366 ^ v664), 15);
  v796 = __ROR4__(v370, 15);
  v373 = (v746 ^ v616) & v370 ^ v746;
  v786 = __ROR4__(v369, 15);
  v814 = __ROR4__(v372, 15);
  v807 = __ROR4__(v371, 15);
  v374 = (unsigned __int16)(185 * v855) + 12124160 * v856 + v664 + ((v578 ^ v648) & v372 ^ v578);
  v375 = v796 + __ROR4__((unsigned __int16)(185 * v853) + 12124160 * v854 + v706 + ((v365 ^ v633) & v371 ^ v365), 5);
  v376 = v807 + __ROR4__((unsigned __int16)(185 * v851) + 12124160 * v852 + v696 + v373, 5);
  v377 = v814 + __ROR4__((unsigned __int16)(185 * v849) + 12124160 * v850 + v679 + ((v560 ^ v595) & v369 ^ v560), 5);
  v378 = v786 + __ROR4__(v374, 5);
  v665 = __ROR4__(v377, 5);
  v680 = __ROR4__(v376, 5);
  v707 = __ROR4__(v378, 5);
  v697 = __ROR4__(v375, 5);
  v379 = v680 + __ROR4__((unsigned __int16)(185 * v865) + 12124160 * v866 + v560 + ((v595 ^ v786) & v377 ^ v595), 29);
  v380 = v665 + __ROR4__((unsigned __int16)(185 * v867) + 12124160 * v868 + v746 + (v376 & (v616 ^ v796) ^ v616), 29);
  v381 = v707 + __ROR4__((unsigned __int16)(185 * v869) + 12124160 * v870 + v760 + ((v633 ^ v807) & v375 ^ v633), 29);
  v382 = v697 + __ROR4__((unsigned __int16)(185 * v871) + 12124160 * v872 + v578 + ((v648 ^ v814) & v378 ^ v648), 29);
  v761 = __ROR4__(v382, 29);
  v721 = __ROR4__(v379, 29);
  v747 = __ROR4__(v381, 29);
  v735 = __ROR4__(v380, 29);
  v383 = (unsigned __int16)(185 * v907) + 12124160 * v908 + v616 + ((v680 | v380) & v796 | v380 & v680);
  v384 = v747
       + __ROR4__((unsigned __int16)(185 * v905) + 12124160 * v906 + v595 + ((v665 | v379) & v786 | v379 & v665), 9);
  v385 = v721
       + __ROR4__((unsigned __int16)(185 * v909) + 12124160 * v910 + v633 + ((v697 | v381) & v807 | v381 & v697), 9);
  v386 = v735
       + __ROR4__((unsigned __int16)(185 * v911) + 12124160 * v912 + v648 + ((v707 | v382) & v814 | v382 & v707), 9);
  v387 = v761 + __ROR4__(v383, 9);
  v634 = __ROR4__(v387, 9);
  v649 = __ROR4__(v385, 9);
  v821 = __ROR4__(v384, 9);
  v774 = __ROR4__(v386, 9);
  v388 = v774
       + __ROR4__((unsigned __int16)(185 * v889) + 12124160 * v890 + v786 + ((v721 | v384) & v665 | v384 & v721), 15);
  v389 = v634
       + __ROR4__((unsigned __int16)(185 * v893) + 12124160 * v894 + v807 + ((v747 | v385) & v697 | v385 & v747), 15);
  v390 = v649
       + __ROR4__((unsigned __int16)(185 * v891) + 12124160 * v892 + v796 + ((v735 | v387) & v680 | v387 & v735), 15);
  v391 = v821
       + __ROR4__((unsigned __int16)(185 * v895) + 12124160 * v896 + v814 + ((v761 | v386) & v707 | v386 & v761), 15);
  v392 = v649 | v389;
  v797 = v649 & v389;
  v579 = __ROR4__(v390, 15);
  v596 = __ROR4__(v389, 15);
  v561 = __ROR4__(v388, 15);
  v617 = __ROR4__(v391, 15);
  v393 = v579
       + __ROR4__((unsigned __int16)(185 * v873) + 12124160 * v874 + v665 + ((v821 | v388) & v721 | v821 & v388), 5);
  v394 = (unsigned __int16)(185 * v875) + 12124160 * v876 + v680 + ((v634 | v390) & v735 | v634 & v390);
  v681 = v617 + __ROR4__((unsigned __int16)(185 * v877) + 12124160 * v878 + v697 + (v392 & v747 | v797), 5);
  v395 = v561 + __ROR4__(v394, 5);
  v396 = v596
       + __ROR4__((unsigned __int16)(185 * v879) + 12124160 * v880 + v707 + ((v774 | v391) & v761 | v774 & v391), 5);
  v397 = (v596 | v681) & v649 | v596 & v681;
  v666 = __ROR4__(v393, 5);
  v398 = v681;
  v682 = __ROR4__(v395, 5);
  v698 = __ROR4__(v398, 5);
  v708 = __ROR4__(v396, 5);
  v399 = v708
       + __ROR4__((unsigned __int16)(185 * v859) + 12124160 * v860 + v735 + ((v579 | v395) & v634 | v579 & v395), 29);
  v400 = v666 + __ROR4__((unsigned __int16)(185 * v861) + 12124160 * v862 + v747 + v397, 29);
  v401 = v698
       + __ROR4__((unsigned __int16)(185 * v857) + 12124160 * v858 + v721 + ((v561 | v393) & v821 | v561 & v393), 29);
  v402 = v682
       + __ROR4__((unsigned __int16)(185 * v863) + 12124160 * v864 + v761 + ((v617 | v396) & v774 | v617 & v396), 29);
  v722 = __ROR4__(v401, 4);
  v762 = __ROR4__(v402, 4);
  v748 = __ROR4__(v400, 4);
  v736 = __ROR4__(v399, 4);
  v403 = __ROR4__((unsigned __int16)(185 * v975) + 12124160 * v976[0] + v774 + ((v617 ^ v708) & v402 ^ v617), 13);
  v404 = v762 + __ROR4__((unsigned __int16)(185 * v969) + 12124160 * v970 + v821 + ((v561 ^ v666) & v401 ^ v561), 13);
  v405 = v736 + __ROR4__((unsigned __int16)(185 * v973) + 12124160 * v974 + v649 + ((v596 ^ v698) & v400 ^ v596), 13);
  v406 = v748 + __ROR4__((unsigned __int16)(185 * v971) + 12124160 * v972 + v634 + ((v579 ^ v682) & v399 ^ v579), 13);
  v407 = (v698 ^ v748) & v405;
  v408 = v617;
  v635 = __ROR4__(v722 + v403, 13);
  v618 = __ROR4__(v405, 13);
  v409 = (unsigned __int16)(185 * v943) + 12124160 * v944 + v408;
  v410 = v596;
  v597 = __ROR4__(v406, 13);
  v411 = v618 + __ROR4__(v409 + ((v708 ^ v762) & (v722 + v403) ^ v708), 10);
  v412 = v635 + __ROR4__((unsigned __int16)(185 * v941) + 12124160 * v942 + v410 + (v407 ^ v698), 10);
  v413 = __ROR4__(v404, 13);
  v414 = v597 + __ROR4__((unsigned __int16)(185 * v937) + 12124160 * v938 + v561 + ((v666 ^ v722) & v404 ^ v666), 10);
  v415 = v413 + __ROR4__((unsigned __int16)(185 * v939) + 12124160 * v940 + v579 + ((v682 ^ v736) & v406 ^ v682), 10);
  v798 = __ROR4__(v411, 10);
  v775 = __ROR4__(v415, 10);
  v416 = v708;
  v709 = __ROR4__(v414, 10);
  v787 = __ROR4__(v412, 10);
  v417 = (unsigned __int16)(185 * v951) + 12124160 * v952 + v416 + ((v762 ^ v635) & v411 ^ v762);
  v418 = v787 + __ROR4__((unsigned __int16)(185 * v945) + 12124160 * v946 + v666 + ((v722 ^ v413) & v414 ^ v722), 25);
  v419 = v775 + __ROR4__(v417, 25);
  v420 = v798 + __ROR4__((unsigned __int16)(185 * v947) + 12124160 * v948 + v682 + ((v736 ^ v597) & v415 ^ v736), 25);
  v421 = v709 + __ROR4__((unsigned __int16)(185 * v949) + 12124160 * v950 + v698 + ((v748 ^ v618) & v412 ^ v748), 25);
  v683 = __ROR4__(v419, 25);
  v650 = __ROR4__(v420, 25);
  v580 = __ROR4__(v418, 25);
  v667 = __ROR4__(v421, 25);
  v422 = v683 + __ROR4__((unsigned __int16)(185 * v913) + 12124160 * v914 + v722 + ((v413 ^ v709) & v418 ^ v413), 4);
  v423 = v650 + __ROR4__((unsigned __int16)(185 * v917) + 12124160 * v918 + v748 + ((v618 ^ v787) & v421 ^ v618), 4);
  v424 = v667 + __ROR4__((unsigned __int16)(185 * v915) + 12124160 * v916 + v736 + ((v597 ^ v775) & v420 ^ v597), 4);
  v723 = __ROR4__(v422, 4);
  v699 = __ROR4__(v424, 4);
  v425 = (unsigned __int16)(185 * v923) + 12124160 * v924 + v597 + ((v650 | v424) & v775 | v424 & v650);
  v426 = v699
       + __ROR4__((unsigned __int16)(185 * v921) + 12124160 * v922 + v413 + ((v580 | v422) & v709 | v580 & v422), 13);
  v427 = v580 + __ROR4__((unsigned __int16)(185 * v919) + 12124160 * v920 + v762 + (v419 & (v635 ^ v798) ^ v635), 4);
  v737 = __ROR4__(v423, 4);
  v428 = __ROR4__(v427, 4);
  v429 = v428
       + __ROR4__((unsigned __int16)(185 * v925) + 12124160 * v926 + v618 + ((v667 | v423) & v787 | v423 & v667), 13);
  v749 = v428;
  v430 = v737
       + __ROR4__((unsigned __int16)(185 * v927) + 12124160 * v928 + v635 + ((v683 | v427) & v798 | v683 & v427), 13);
  v431 = v723 + __ROR4__(v425, 13);
  v432 = __ROR4__(v429, 13);
  v433 = v432
       + __ROR4__((unsigned __int16)(185 * v953) + 12124160 * v954 + v709 + ((v723 | v426) & v580 | v723 & v426), 10);
  v598 = __ROR4__(v426, 13);
  v434 = (unsigned __int16)(185 * v955) + 12124160 * v956 + v775;
  v776 = v432;
  v619 = __ROR4__(v431, 13);
  v763 = __ROR4__(v430, 13);
  v435 = (unsigned __int16)(185 * v929) + 12124160 * v930 + v580 + ((v598 | v433) & v723 | v598 & v433);
  v562 = __ROR4__(v433, 10);
  v788 = v598
       + __ROR4__((unsigned __int16)(185 * v957) + 12124160 * v958 + v787 + ((v737 | v429) & v667 | v429 & v737), 10);
  v581 = v763 + __ROR4__(v434 + ((v699 | v431) & v650 | v431 & v699), 10);
  v436 = v619
       + __ROR4__((unsigned __int16)(185 * v959) + 12124160 * v960 + v798 + ((v749 | v430) & v683 | v430 & v749), 10);
  v636 = __ROR4__(v436, 10);
  v437 = __ROR4__(v435, 25);
  v710 = __ROR4__(v636 + v437, 25);
  v724 = (unsigned __int16)(185 * v961)
       + 12124160 * v962
       + v723
       + ((v562 | (v636 + v437)) & v598 | v562 & (v636 + v437));
  v799 = (unsigned __int16)(233 * v857) + 15269888 * v921 + v598;
  v808 = (unsigned __int16)(233 * v859) + 15269888 * v923 + v619;
  v815 = (unsigned __int16)(233 * v861) + 15269888 * v925 + v432;
  v438 = v562
       + __ROR4__((unsigned __int16)(185 * v935) + 12124160 * v936 + v683 + ((v763 | v436) & v749 | v763 & v436), 25);
  v846 = (unsigned __int16)(233 * v865) + 15269888 * v929 + v562;
  v847 = (unsigned __int16)(233 * v871) + 15269888 * v935 + v636;
  v439 = (unsigned __int16)(185 * v931) + 12124160 * v932 + v650 + ((v619 | v581) & v699 | v619 & v581);
  v440 = v776;
  v582 = __ROR4__(v581, 10);
  v599 = __ROR4__(v788, 10);
  v441 = v599 + __ROR4__(v439, 25);
  v442 = v582
       + __ROR4__((unsigned __int16)(185 * v933) + 12124160 * v934 + v667 + ((v776 | v788) & v737 | v776 & v788), 25);
  v777 = (unsigned __int16)(233 * v867) + 15269888 * v931 + v582;
  v789 = (unsigned __int16)(233 * v869) + 15269888 * v933 + v599;
  v651 = (unsigned __int16)(185 * v963) + 12124160 * v964 + v699;
  v700 = __ROR4__(v441, 25);
  v443 = __ROR4__(v442, 25);
  v444 = __ROR4__(v438, 25);
  v445 = v444
       + __ROR4__((unsigned __int16)(185 * v965) + 12124160 * v966 + v737 + ((v599 | v442) & v440 | v599 & v442), 4);
  v446 = v443
       + __ROR4__((unsigned __int16)(185 * v967) + 12124160 * v968 + v749 + ((v636 | v438) & v763 | v636 & v438), 4);
  v447 = v700 + __ROR4__(v724, 4);
  v684 = __ROR4__(v446, 3);
  v448 = v710 + __ROR4__(v651 + ((v582 | v441) & v619 | v441 & v582), 4);
  v668 = __ROR4__(v445, 3);
  v620 = __ROR4__(v447, 3);
  v652 = __ROR4__(v448, 3);
  v449 = v668 + __ROR4__(v799 + ((v562 ^ v710) & v447 ^ v562), 23);
  v450 = v684 + __ROR4__(v808 + (v448 & (v582 ^ v700) ^ v582), 23);
  v563 = __ROR4__(v449, 23);
  v451 = v652 + __ROR4__((unsigned __int16)(233 * v863) + 15269888 * v927 + v763 + ((v636 ^ v444) & v446 ^ v636), 23);
  v452 = v620 + __ROR4__(v815 + (v445 & (v443 ^ v599) ^ v599), 23);
  v637 = __ROR4__(v451, 23);
  v583 = __ROR4__(v450, 23);
  v600 = __ROR4__(v452, 23);
  v453 = v563 + __ROR4__(v847 + (v451 & (v444 ^ v684) ^ v444), 17);
  v454 = v637 + __ROR4__(v846 + (v449 & (v710 ^ v620) ^ v710), 17);
  v455 = v600 + __ROR4__(v777 + (v450 & (v700 ^ v652) ^ v700), 17);
  v456 = v583 + __ROR4__(v789 + (v452 & (v443 ^ v668) ^ v443), 17);
  v750 = __ROR4__(v454, 17);
  v790 = __ROR4__(v453, 17);
  v778 = __ROR4__(v456, 17);
  v764 = __ROR4__(v455, 17);
  v457 = (v684 ^ v637) & v453;
  v458 = v750 + __ROR4__((unsigned __int16)(233 * v907) + 15269888 * v971 + v700 + (v455 & (v652 ^ v583) ^ v652), 27);
  v459 = v778 + __ROR4__((unsigned __int16)(233 * v911) + 15269888 * v975 + v444 + (v457 ^ v684), 27);
  v460 = v764 + __ROR4__((unsigned __int16)(233 * v905) + 15269888 * v969 + v710 + (v454 & (v620 ^ v563) ^ v620), 27);
  v461 = v790 + __ROR4__((unsigned __int16)(233 * v909) + 15269888 * v973 + v443 + ((v668 ^ v600) & v456 ^ v668), 27);
  v701 = __ROR4__(v460, 27);
  v711 = __ROR4__(v458, 27);
  v725 = __ROR4__(v461, 27);
  v738 = __ROR4__(v459, 27);
  v462 = (v583 ^ v764) & v458 ^ v583;
  v463 = v725 + __ROR4__((unsigned __int16)(233 * v881) + 15269888 * v945 + v620 + ((v563 ^ v750) & v460 ^ v563), 3);
  v464 = v711 + __ROR4__((unsigned __int16)(233 * v887) + 15269888 * v951 + v684 + (v459 & (v637 ^ v790) ^ v637), 3);
  v465 = v738 + __ROR4__((unsigned __int16)(233 * v883) + 15269888 * v947 + v652 + v462, 3);
  v466 = v701 + __ROR4__((unsigned __int16)(233 * v885) + 15269888 * v949 + v668 + ((v600 ^ v778) & v461 ^ v600), 3);
  v621 = __ROR4__(v463, 3);
  v685 = __ROR4__(v464, 3);
  v669 = __ROR4__(v466, 3);
  v653 = __ROR4__(v465, 3);
  v467 = v685
       + __ROR4__((unsigned __int16)(233 * v897) + 15269888 * v961 + v563 + ((v701 | v463) & v750 | v463 & v701), 23);
  v468 = v669
       + __ROR4__((unsigned __int16)(233 * v899) + 15269888 * v963 + v583 + ((v711 | v465) & v764 | v465 & v711), 23);
  v469 = v653
       + __ROR4__((unsigned __int16)(233 * v901) + 15269888 * v965 + v600 + ((v725 | v466) & v778 | v466 & v725), 23);
  v470 = v621
       + __ROR4__((unsigned __int16)(233 * v903) + 15269888 * v967 + v637 + ((v738 | v464) & v790 | v464 & v738), 23);
  v564 = __ROR4__(v468, 23);
  v800 = __ROR4__(v467, 23);
  v584 = __ROR4__(v469, 23);
  v601 = __ROR4__(v470, 23);
  v471 = (v653 | v468) & v711 | v468 & v653;
  v472 = v564
       + __ROR4__((unsigned __int16)(233 * v889) + 15269888 * v953 + v750 + ((v621 | v467) & v701 | v467 & v621), 17);
  v473 = v800 + __ROR4__((unsigned __int16)(233 * v891) + 15269888 * v955 + v764 + v471, 17);
  v474 = v584
       + __ROR4__((unsigned __int16)(233 * v895) + 15269888 * v959 + v790 + ((v685 | v470) & v738 | v470 & v685), 17);
  v638 = __ROR4__(v472, 17);
  v475 = v601
       + __ROR4__((unsigned __int16)(233 * v893) + 15269888 * v957 + v778 + ((v669 | v469) & v725 | v469 & v669), 17);
  v751 = __ROR4__(v473, 17);
  v765 = __ROR4__(v475, 17);
  v779 = __ROR4__(v474, 17);
  v848 = 233 * v856;
  v476 = v765
       + __ROR4__((unsigned __int16)(233 * v849) + 15269888 * v913 + v701 + ((v800 | v472) & v621 | v472 & v800), 27);
  v477 = v638
       + __ROR4__((unsigned __int16)(233 * v853) + 15269888 * v917 + v725 + ((v584 | v475) & v669 | v475 & v584), 27);
  v478 = v779
       + __ROR4__((unsigned __int16)(233 * v851) + 15269888 * v915 + v711 + ((v564 | v473) & v653 | v473 & v564), 27);
  v479 = v751
       + __ROR4__((unsigned __int16)(233 * v855) + 15269888 * v919 + v738 + ((v601 | v474) & v685 | v474 & v601), 27);
  v702 = __ROR4__(v476, 27);
  v712 = __ROR4__(v478, 27);
  v726 = __ROR4__(v477, 27);
  v739 = __ROR4__(v479, 27);
  v480 = v739
       + __ROR4__((unsigned __int16)(233 * v873) + 15269888 * v937 + v621 + ((v638 | v476) & v800 | v476 & v638), 3);
  v481 = v726
       + __ROR4__((unsigned __int16)(233 * v875) + 15269888 * v939 + v653 + ((v751 | v478) & v564 | v478 & v751), 3);
  v482 = v702
       + __ROR4__((unsigned __int16)(233 * v879) + 15269888 * v943 + v685 + ((v779 | v479) & v601 | v479 & v779), 3);
  v622 = __ROR4__(v480, 28);
  v686 = __ROR4__(v482, 28);
  v654 = __ROR4__(v481, 28);
  v483 = v712
       + __ROR4__((unsigned __int16)(233 * v877) + 15269888 * v941 + v669 + ((v765 | v477) & v584 | v477 & v765), 3);
  v670 = __ROR4__(v483, 28);
  v484 = (unsigned __int16)(233 * v898) + 15269888 * v962 + v800 + ((v638 ^ v702) & v480 ^ v638);
  v801 = v686 + __ROR4__((unsigned __int16)(233 * v902) + 15269888 * v966 + v584 + ((v765 ^ v726) & v483 ^ v765), 19);
  v485 = v654 + __ROR4__(v484, 19);
  v486 = v670 + __ROR4__((unsigned __int16)(233 * v904) + 15269888 * v968 + v601 + ((v779 ^ v739) & v482 ^ v779), 19);
  v487 = v622 + __ROR4__((unsigned __int16)(233 * v900) + 15269888 * v964 + v564 + ((v751 ^ v712) & v481 ^ v751), 19);
  v791 = __ROR4__(v486, 19);
  v585 = __ROR4__(v487, 19);
  v565 = __ROR4__(v485, 19);
  v602 = __ROR4__(v801, 19);
  v488 = v602 + __ROR4__((unsigned __int16)(233 * v850) + 15269888 * v914 + v638 + ((v702 ^ v622) & v485 ^ v702), 22);
  v489 = v585 + __ROR4__((unsigned __int16)(233 * v856) + 15269888 * v920 + v779 + (v486 & (v739 ^ v686) ^ v739), 22);
  v490 = v565 + __ROR4__((unsigned __int16)(233 * v854) + 15269888 * v918 + v765 + ((v726 ^ v670) & v801 ^ v726), 22);
  v491 = v791 + __ROR4__((unsigned __int16)(233 * v852) + 15269888 * v916 + v751 + (v487 & (v712 ^ v654) ^ v712), 22);
  v752 = __ROR4__(v488, 22);
  v802 = __ROR4__(v489, 22);
  v766 = __ROR4__(v491, 22);
  v780 = __ROR4__(v490, 22);
  v492 = v802 + __ROR4__((unsigned __int16)(233 * v858) + 15269888 * v922 + v702 + ((v622 ^ v565) & v488 ^ v622), 7);
  v493 = v780 + __ROR4__((unsigned __int16)(233 * v860) + 15269888 * v924 + v712 + (v491 & (v654 ^ v585) ^ v654), 7);
  v639 = __ROR4__(v492, 7);
  v494 = v752 + __ROR4__((unsigned __int16)(233 * v864) + 15269888 * v928 + v739 + ((v686 ^ v791) & v489 ^ v686), 7);
  v495 = v766 + __ROR4__((unsigned __int16)(233 * v862) + 15269888 * v926 + v726 + ((v670 ^ v602) & v490 ^ v670), 7);
  v703 = __ROR4__(v493, 7);
  v713 = __ROR4__(v495, 7);
  v727 = __ROR4__(v494, 7);
  v496 = (unsigned __int16)(233 * v910) + 15269888 * v974 + v670 + (v495 & (v602 ^ v780) ^ v602);
  v497 = (unsigned __int16)(233 * v912) + 15269888 * v976[0] + v686 + (v494 & (v802 ^ v791) ^ v791);
  v671 = v703 + __ROR4__((unsigned __int16)(233 * v906) + 15269888 * v970 + v622 + ((v565 ^ v752) & v492 ^ v565), 28);
  v498 = v639 + __ROR4__((unsigned __int16)(233 * v908) + 15269888 * v972 + v654 + ((v585 ^ v766) & v493 ^ v585), 28);
  v809 = __ROR4__(v671, 28);
  v499 = v727 + __ROR4__(v496, 28);
  v500 = v713 + __ROR4__(v497, 28);
  v623 = __ROR4__(v499, 28);
  v816 = __ROR4__(v498, 28);
  v655 = __ROR4__(v500, 28);
  v501 = v623
       + __ROR4__((unsigned __int16)(233 * v874) + 15269888 * v938 + v565 + ((v639 | v671) & v752 | v671 & v639), 19);
  v502 = v809
       + __ROR4__((unsigned __int16)(233 * v878) + 15269888 * v942 + v602 + ((v713 | v499) & v780 | v499 & v713), 19);
  v503 = v655
       + __ROR4__((unsigned __int16)(233 * v876) + 15269888 * v940 + v585 + ((v703 | v498) & v766 | v498 & v703), 19);
  v504 = v816
       + __ROR4__((unsigned __int16)(233 * v880) + 15269888 * v944 + v791 + ((v727 | v500) & v802 | v500 & v727), 19);
  v603 = __ROR4__(v501, 19);
  v740 = __ROR4__(v504, 19);
  v672 = __ROR4__(v503, 19);
  v687 = __ROR4__(v502, 19);
  v505 = v740
       + __ROR4__((unsigned __int16)(233 * v890) + 15269888 * v954 + v752 + ((v809 | v501) & v639 | v809 & v501), 22);
  v506 = v603
       + __ROR4__((unsigned __int16)(233 * v896) + 15269888 * v960 + v802 + ((v655 | v504) & v727 | v504 & v655), 22);
  v507 = v687
       + __ROR4__((unsigned __int16)(233 * v892) + 15269888 * v956 + v766 + ((v816 | v503) & v703 | v503 & v816), 22);
  v508 = v672
       + __ROR4__((unsigned __int16)(233 * v894) + 15269888 * v958 + v780 + ((v623 | v502) & v713 | v623 & v502), 22);
  v767 = __ROR4__(v505, 22);
  v753 = __ROR4__(v507, 22);
  v566 = __ROR4__(v508, 22);
  v586 = __ROR4__(v506, 22);
  v509 = v586
       + __ROR4__((unsigned __int16)(233 * v886) + 15269888 * v950 + v713 + ((v687 | v508) & v623 | v508 & v687), 7);
  v510 = (unsigned __int16)(233 * v888) + 15269888 * v952 + v727 + ((v740 | v506) & v655 | v506 & v740);
  v511 = v753
       + __ROR4__((unsigned __int16)(233 * v882) + 15269888 * v946 + v639 + ((v603 | v505) & v809 | v505 & v603), 7);
  v512 = v566 + __ROR4__(v510, 7);
  v513 = v767
       + __ROR4__((unsigned __int16)(233 * v884) + 15269888 * v948 + v703 + ((v672 | v507) & v816 | v507 & v672), 7);
  v640 = __ROR4__(v511, 7);
  v704 = __ROR4__(v513, 7);
  v728 = __ROR4__(v509, 7);
  v714 = __ROR4__(v512, 7);
  v514 = v728
       + __ROR4__((unsigned __int16)(233 * v866) + 15269888 * v930 + v809 + ((v767 | v511) & v603 | v511 & v767), 28);
  v515 = v704
       + __ROR4__((unsigned __int16)(233 * v872) + 15269888 * v936 + v655 + ((v586 | v512) & v740 | v512 & v586), 28);
  v516 = v640
       + __ROR4__((unsigned __int16)(233 * v870) + 15269888 * v934 + v623 + ((v566 | v509) & v687 | v509 & v566), 28);
  v517 = __ROR4__(v515, 28);
  v518 = v714
       + __ROR4__((unsigned __int16)(233 * v868) + 15269888 * v932 + v816 + ((v753 | v513) & v672 | v513 & v753), 28);
  v519 = __ROR4__(v516, 28);
  v624 = __ROR4__(v514, 28);
  v656 = __ROR4__(v518, 28);
  v520 = (v566 ^ v728) & v516;
  v521 = (v586 ^ v714) & v515;
  v522 = v517 + __ROR4__((v514 & (v767 ^ v640) ^ v767) + v841 + v603, 19);
  v523 = v728;
  v604 = __ROR4__(v522, 19);
  v524 = v519 + __ROR4__(((v753 ^ v704) & v518 ^ v753) + v842 + v672, 19);
  v525 = v656 + __ROR4__((v520 ^ v566) + v843 + v687, 19);
  v688 = __ROR4__(v524, 19);
  v526 = v624 + __ROR4__((v521 ^ v586) + v844 + v740, 19);
  v673 = __ROR4__(v525, 19);
  v527 = __ROR4__(v526, 19);
  v528 = ((v728 ^ v519) & v525 ^ v728) + v828 + v566;
  v529 = v688 + __ROR4__(((v640 ^ v624) & v522 ^ v640) + v845 + v767, 22);
  v530 = (v526 & (v714 ^ v517) ^ v714) + v830 + v586;
  v567 = __ROR4__(v529, 22);
  v531 = v604 + __ROR4__(((v704 ^ v656) & v524 ^ v704) + v824 + v753, 22);
  v532 = v527 + __ROR4__(v528, 22);
  v587 = __ROR4__(v532, 22);
  v533 = v673 + __ROR4__(v530, 22);
  v729 = __ROR4__(v533, 22);
  v534 = v832 + v640;
  v641 = __ROR4__(v531, 22);
  v535 = (v533 & (v517 ^ v527) ^ v517) + v836 + v714;
  v536 = v587 + __ROR4__((v529 & (v624 ^ v604) ^ v624) + v534, 7);
  v537 = v567 + __ROR4__((v532 & (v519 ^ v673) ^ v519) + v835 + v523, 7);
  v538 = v641 + __ROR4__(v535, 7);
  v539 = __ROR4__(v536, 7);
  v540 = __ROR4__(v538, 7);
  v541 = v729 + __ROR4__((v531 & (v656 ^ v688) ^ v656) + v834 + v704, 7);
  v542 = __ROR4__(v537, 7);
  v705 = __ROR4__(v541, 7);
  result = v540 + __ROR4__((v536 & (v604 ^ v567) ^ v604) + v837 + v624, 28);
  *((_DWORD *)a1 + 17) = result;
  *((_DWORD *)a1 + 25) = v567;
  *((_DWORD *)a1 + 18) = v542 + __ROR4__((v541 & (v688 ^ v641) ^ v688) + v838 + v656, 28);
  *((_DWORD *)a1 + 26) = v641;
  *((_DWORD *)a1 + 29) = v604;
  *((_DWORD *)a1 + 27) = v587;
  *((_DWORD *)a1 + 31) = v673;
  *((_DWORD *)a1 + 21) = v539;
  *((_DWORD *)a1 + 24) = v540;
  *((_DWORD *)a1 + 23) = v542;
  *((_DWORD *)a1 + 28) = v729;
  *((_DWORD *)a1 + 30) = v688;
  *((_DWORD *)a1 + 32) = v527;
  *((_DWORD *)a1 + 20) = v539 + __ROR4__((v538 & (v527 ^ v729) ^ v527) + v840 + v517, 28);
  *((_DWORD *)a1 + 19) = v705 + __ROR4__((v537 & (v587 ^ v673) ^ v673) + v839 + v519, 28);
  *((_DWORD *)a1 + 22) = v705;
  return result;
}

//----- (000D2A5C) --------------------------------------------------------
unsigned __int8 *__fastcall sph_simd224_0(unsigned __int8 *result, char *src, size_t a3)
{
  size_t v3; // r6
  unsigned __int8 *v4; // r5
  int v6; // r0
  size_t v7; // r4
  unsigned __int8 *v8; // r0
  size_t v9; // r4
  int v10; // r3

  v3 = a3;
  if ( a3 )
  {
    v4 = result;
    do
    {
      while ( 1 )
      {
        v6 = *((_DWORD *)v4 + 16);
        v7 = 64 - v6;
        v8 = &v4[v6];
        if ( v7 >= v3 )
          v7 = v3;
        v3 -= v7;
        result = (unsigned __int8 *)memcpy(v8, src, v7);
        src += v7;
        v9 = v7 + *((_DWORD *)v4 + 16);
        *((_DWORD *)v4 + 16) = v9;
        if ( v9 == 64 )
          break;
        if ( !v3 )
          return result;
      }
      result = (unsigned __int8 *)sub_CE010(v4, 0);
      v10 = *((_DWORD *)v4 + 33);
      *((_DWORD *)v4 + 16) = 0;
      *((_DWORD *)v4 + 33) = ++v10;
      if ( !v10 )
        ++*((_DWORD *)v4 + 34);
    }
    while ( v3 );
  }
  return result;
}

//----- (000D2AF4) --------------------------------------------------------
unsigned int __fastcall sub_D2AF4(_DWORD *s, char a2, int a3, int a4, int a5)
{
  int v6; // r0
  int v9; // r8
  char *v11; // r6
  unsigned int v12; // r3
  unsigned __int8 *v13; // r0
  int v14; // r12
  char *v15; // r4
  char *v16; // r6
  int v17; // r2
  int v18; // r3
  int v19; // r3
  unsigned int v20; // t1
  unsigned int result; // r0

  v6 = s[16];
  v9 = v6 | a3;
  if ( v6 | a3 )
  {
    memset((char *)s + v6, 0, 64 - v6);
    *((_BYTE *)s + s[16]) = a2 & (-1 << (8 - a3));
    sub_CE010((unsigned __int8 *)s, 0);
    v9 = s[16];
  }
  v11 = (char *)&s[a5];
  memset(s, 0, 0x40u);
  v12 = s[33];
  v13 = (unsigned __int8 *)s;
  v14 = s[34];
  v15 = (char *)(s + 17);
  v16 = v11 + 68;
  v12 <<= 9;
  v17 = a3 + v12 + 8 * v9;
  v18 = (v12 >> 23) + (v14 << 9);
  *(v15 - 68) = v17;
  *(v15 - 64) = v18;
  *(v15 - 67) = BYTE1(v17);
  *(v15 - 61) = HIBYTE(v18);
  *(v15 - 66) = BYTE2(v17);
  *(v15 - 65) = HIBYTE(v17);
  *(v15 - 63) = BYTE1(v18);
  *(v15 - 62) = BYTE2(v18);
  sub_CE010(v13, 1);
  v19 = a4;
  do
  {
    v20 = *(_DWORD *)v15;
    v15 += 4;
    v19 += 4;
    *(_DWORD *)(v19 - 4) = v20;
    result = v20 >> 8;
  }
  while ( v16 != v15 );
  return result;
}

//----- (000D2BFC) --------------------------------------------------------
int __fastcall sub_D2BFC(unsigned __int8 *a1, _DWORD *a2)
{
  int v3; // r7
  int v4; // r8
  int v5; // r0
  int v6; // r12
  unsigned int v7; // r5
  int v8; // r3
  unsigned int v9; // r4
  int v10; // r10
  unsigned int v11; // r2
  int v12; // r11
  unsigned int v13; // r8
  int v14; // r5
  int v15; // r10
  int v16; // r4
  unsigned int v17; // lr
  int v18; // r6
  int v19; // r9
  int v20; // r7
  int v21; // r12
  int v22; // r3
  int v23; // r0
  int v24; // r6
  int v25; // r11
  int v26; // r12
  int v27; // r5
  int v28; // r2
  int v29; // r10
  int v30; // r3
  int v31; // r8
  int v32; // r3
  int v33; // r0
  int v34; // r7
  int v35; // r10
  int v36; // r12
  int v37; // r11
  int v38; // r9
  int v39; // lr
  int v40; // r0
  int v41; // r6
  int v42; // r7
  int v43; // lr
  int v44; // r12
  int v45; // r2
  unsigned int v46; // r5
  unsigned int v47; // r4
  unsigned int v48; // r0
  int v49; // r3
  int v50; // r11
  int v51; // r6
  int v52; // r5
  int v53; // r7
  int v54; // r8
  unsigned int v55; // r9
  int v56; // r12
  int v57; // r4
  int v58; // r10
  int v59; // lr
  int v60; // r0
  int v61; // r2
  int v62; // r8
  int v63; // r9
  int v64; // r4
  int v65; // r0
  int v66; // r3
  int v67; // r11
  int v68; // r5
  int v69; // r10
  int v70; // r2
  int v71; // r6
  int v72; // r4
  int v73; // r12
  int v74; // r3
  int v75; // r0
  int v76; // r7
  int v77; // lr
  int v78; // r8
  int v79; // r2
  int v80; // r11
  int v81; // r6
  int v82; // r2
  int v83; // lr
  int v84; // r9
  int v85; // r12
  _DWORD *v86; // r5
  _DWORD *v87; // r4
  int v88; // r7
  int v89; // r8
  int v90; // r10
  int v91; // r12
  int v92; // r8
  int v93; // r7
  int v94; // lr
  int v95; // r0
  int v96; // r12
  int v97; // r12
  int v98; // r0
  int v99; // r6
  int v100; // r7
  int v101; // lr
  int v102; // r4
  int v103; // r9
  unsigned int v104; // r10
  unsigned int v105; // r3
  int v106; // r8
  int v107; // r0
  int v108; // r8
  int v109; // r10
  unsigned int v110; // r12
  unsigned int v111; // r6
  int v112; // r8
  int v113; // r11
  int v114; // r2
  int v115; // r3
  int v116; // r0
  int v117; // r5
  int v118; // r4
  int v119; // r8
  int v120; // r12
  int v121; // lr
  int v122; // r9
  int v123; // r7
  int v124; // r10
  int v125; // r2
  int v126; // r3
  int v127; // r5
  int v128; // r6
  int v129; // r12
  int v130; // r0
  int v131; // lr
  int v132; // r7
  int v133; // r6
  int v134; // r0
  int v135; // r12
  int v136; // r3
  unsigned int v137; // r5
  unsigned int v138; // r11
  int v139; // r8
  unsigned int v140; // lr
  int v141; // r2
  int v142; // r3
  int v143; // r6
  int v144; // r7
  int v145; // r9
  int v146; // r5
  int v147; // r9
  int v148; // r4
  int v149; // r0
  int v150; // r12
  int v151; // r10
  int v152; // r2
  int v153; // r7
  int v154; // r8
  int v155; // r5
  int v156; // r7
  int v157; // r6
  int v158; // r0
  int v159; // r3
  int v160; // r9
  int v161; // r12
  int v162; // r11
  int v163; // r6
  unsigned int v164; // r7
  unsigned int v165; // lr
  unsigned int v166; // r10
  unsigned int v167; // r2
  int v168; // r10
  _DWORD *v169; // r6
  _DWORD *v170; // r3
  _DWORD *v171; // r4
  int v172; // r8
  int v173; // r7
  int v174; // lr
  int v175; // r10
  int v176; // r11
  int v177; // r0
  int v178; // r2
  int v179; // lr
  int v180; // r5
  int v181; // r12
  int v182; // r0
  int v183; // r2
  int v184; // r0
  int v185; // r0
  _DWORD *v186; // r6
  int v187; // r12
  _DWORD *v188; // r5
  int v189; // r7
  int v190; // r2
  int v191; // r8
  int v192; // r0
  int v193; // r1
  int v194; // r2
  int v195; // lr
  int v196; // r1
  int v197; // r2
  int v198; // r8
  int v199; // r4
  int result; // r0
  unsigned __int8 *v201; // [sp+0h] [bp-2Ch]
  int v202; // [sp+0h] [bp-2Ch]
  int v203; // [sp+4h] [bp-28h]
  int v204; // [sp+4h] [bp-28h]
  int v205; // [sp+4h] [bp-28h]
  int v206; // [sp+4h] [bp-28h]
  int v207; // [sp+8h] [bp-24h]
  int v208; // [sp+8h] [bp-24h]
  int v209; // [sp+8h] [bp-24h]
  int v210; // [sp+8h] [bp-24h]
  int v211; // [sp+8h] [bp-24h]
  int v212; // [sp+10h] [bp-1Ch]
  int v213; // [sp+10h] [bp-1Ch]
  int v214; // [sp+10h] [bp-1Ch]
  int v215; // [sp+14h] [bp-18h]
  int v216; // [sp+14h] [bp-18h]
  int v217; // [sp+14h] [bp-18h]
  int v218; // [sp+14h] [bp-18h]
  int v219; // [sp+14h] [bp-18h]
  unsigned int v220; // [sp+14h] [bp-18h]
  int v221; // [sp+18h] [bp-14h]
  int v222; // [sp+18h] [bp-14h]
  int v223; // [sp+18h] [bp-14h]
  int v224; // [sp+18h] [bp-14h]
  int v225; // [sp+18h] [bp-14h]
  int v226; // [sp+1Ch] [bp-10h]
  int v227; // [sp+1Ch] [bp-10h]
  int v228; // [sp+1Ch] [bp-10h]
  int v229; // [sp+20h] [bp-Ch]
  int v230; // [sp+20h] [bp-Ch]
  int v231; // [sp+20h] [bp-Ch]
  int v232; // [sp+20h] [bp-Ch]
  int v233; // [sp+24h] [bp-8h]

  v3 = a1[112];
  v4 = a1[48];
  v5 = a1[96];
  v6 = a1[32];
  v7 = 4 * v3 + (v4 << 6);
  v207 = a1[64];
  v8 = a1[16];
  v9 = (unsigned __int8)(((_BYTE)v3 << 6) + 4 * v4) - ((unsigned int)((v3 << 6) + 4 * v4) >> 8);
  v10 = 16 * a1[80];
  v215 = a1[80];
  v201 = a1;
  v11 = (unsigned __int8)(((_BYTE)v5 << 6) + 4 * v6) - ((unsigned int)((v5 << 6) + 4 * v6) >> 8);
  v203 = *a1;
  v12 = 16 * v4 - 16 * v3;
  v221 = v4 + v3;
  v13 = v8 + v10 + v9;
  v14 = (unsigned __int8)v7 - (v7 >> 8);
  v229 = 32 * (v8 + v10 - v9);
  v15 = v8 - v10;
  v16 = 16 * v6 - 16 * v5;
  v17 = (unsigned __int8)(4 * v5 + ((_BYTE)v6 << 6)) - ((unsigned int)(4 * v5 + (v6 << 6)) >> 8);
  v18 = v203 + 16 * v207;
  v19 = v203 - 16 * v207;
  v13 *= 2;
  v20 = v6 + v5;
  v21 = v8 - v215;
  v22 = v8 + v215;
  v23 = v18 + v11;
  v212 = v18 - v11;
  v24 = v21 + v12;
  v25 = v21 - v12;
  v26 = v15 + v14;
  v24 *= 4;
  v27 = (v15 - v14) << 7;
  v233 = v25 << 6;
  v28 = v22 - v221;
  v29 = v22 + v221;
  v30 = v23 + v13;
  v31 = v23 - v13;
  a2[1] = v30;
  v28 *= 16;
  v216 = v29;
  v32 = v203 + v207 - v20;
  v33 = v203 + v207 + v20;
  v34 = 8 * v26;
  v35 = v203 - v207 + v16;
  v36 = v19 + v17;
  v37 = v203 - v207 - v16;
  v38 = v19 - v17;
  a2[2] = v35 + v24;
  a2[3] = v36 + v34;
  a2[12] = v32 - v28;
  a2[6] = v37 + v233;
  a2[9] = v31;
  a2[7] = v38 + v27;
  v39 = v33 - v216;
  v40 = v33 + v216;
  a2[15] = v38 - v27;
  *a2 = v40;
  a2[10] = v35 - v24;
  a2[11] = v36 - v34;
  a2[4] = v32 + v28;
  a2[5] = v212 + v229;
  a2[13] = v212 - v229;
  a2[14] = v37 - v233;
  a2[8] = v39;
  v41 = v201[120];
  v42 = v201[56];
  v43 = v201[104];
  v44 = v201[40];
  v204 = v40;
  v45 = v201[24];
  v46 = 4 * v41 + (v42 << 6);
  v47 = (unsigned __int8)(((_BYTE)v41 << 6) + 4 * v42) - ((unsigned int)((v41 << 6) + 4 * v42) >> 8);
  v222 = v201[88];
  v208 = v201[72];
  v48 = (unsigned __int8)(((_BYTE)v43 << 6) + 4 * v44) - ((unsigned int)((v43 << 6) + 4 * v44) >> 8);
  v49 = v201[8];
  v226 = v42 + v41;
  v50 = 16 * v42 - 16 * v41;
  v51 = 2 * (v45 + 16 * v222 + v47);
  v52 = (unsigned __int8)v46 - (v46 >> 8);
  v230 = 32 * (v45 + 16 * v222 - v47);
  v53 = v44 + v43;
  v213 = v49 - 16 * v208;
  v54 = v49 + 16 * v208;
  v55 = 4 * v43 + (v44 << 6);
  v56 = 16 * v44 - 16 * v43;
  v57 = v54 + v48;
  v58 = v45 - 16 * v222;
  v59 = (unsigned __int8)v55 - (v55 >> 8);
  v217 = v54 - v48;
  v60 = v45 - v222;
  v61 = v45 + v222;
  v62 = v57 + v51;
  v63 = (v60 - v50) << 6;
  a2[25] = v57 - v51;
  v64 = 4 * (v60 + v50);
  v65 = v49 + v208;
  v66 = v49 - v208;
  a2[17] = v62;
  v67 = v58 + v52;
  v68 = v58 - v52;
  v69 = v61 - v226;
  v70 = v61 + v226;
  v71 = v66 + v56 + v64;
  v72 = v66 + v56 - v64;
  v73 = v66 - v56;
  v67 *= 8;
  v74 = v65 + v53;
  v75 = v65 - v53;
  v69 *= 16;
  v76 = v213 + v59;
  v68 <<= 7;
  v77 = v213 - v59;
  a2[18] = v71;
  v78 = v74 + v70;
  a2[24] = v74 - v70;
  v79 = v76 + v67;
  v80 = v76 - v67;
  v209 = v79;
  a2[28] = v75 - v69;
  a2[26] = v72;
  v81 = 120;
  a2[29] = v217 - v230;
  a2[22] = v73 + v63;
  v82 = v77 + v68;
  v83 = v77 - v68;
  a2[23] = v82;
  v84 = v73 - v63;
  v85 = v204 + v78;
  v86 = &unk_F4328;
  v87 = a2;
  a2[19] = v209;
  a2[20] = v75 + v69;
  v88 = 60;
  a2[16] = v204 - v78;
  v89 = 2;
  a2[27] = v80;
  a2[21] = v217 + v230;
  a2[30] = v84;
  a2[31] = v83;
  *a2 = v85;
  while ( 1 )
  {
    v90 = v87[1];
    v91 = v87[2];
    v92 = (unsigned __int16)(*((_WORD *)v87 + 36) * v89) + ((v87[18] * v89) >> 16);
    v93 = (unsigned __int16)(*((_WORD *)v87 + 34) * v88) + ((v87[17] * v88) >> 16);
    v94 = (unsigned __int16)(*((_WORD *)v87 + 38) * v81) + ((v87[19] * v81) >> 16);
    v95 = v87[3];
    v87[1] = v90 + v93;
    v87[17] = v90 - v93;
    v87[2] = v91 + v92;
    v87[18] = v91 - v92;
    v87[3] = v95 + v94;
    v87[19] = v95 - v94;
    if ( a2 + 12 == v87 )
      break;
    v96 = v86[32];
    v87 += 4;
    v86 += 32;
    v97 = (unsigned __int16)(v96 * *((_WORD *)v87 + 32)) + ((v96 * v87[16]) >> 16);
    v98 = *v87 - v97;
    *v87 += v97;
    v87[16] = v98;
    v88 = v86[8];
    v89 = v86[16];
    v81 = v86[24];
  }
  v99 = v201[116];
  v100 = v201[52];
  v101 = v201[100];
  v102 = v201[36];
  v103 = v201[20];
  v218 = v201[84];
  v210 = v201[68];
  v104 = (unsigned __int8)(((_BYTE)v99 << 6) + 4 * v100) - ((unsigned int)((v99 << 6) + 4 * v100) >> 8);
  v105 = 4 * v99 + (v100 << 6);
  v205 = v201[4];
  v106 = v103 + 16 * v218;
  v107 = v106 + v104;
  v108 = v106 - v104;
  v109 = 16 * v100 - 16 * v99;
  v227 = v100 + v99;
  v110 = (unsigned __int8)(((_BYTE)v101 << 6) + 4 * v102) - ((unsigned int)((v101 << 6) + 4 * v102) >> 8);
  v111 = (unsigned __int8)(4 * v101 + ((_BYTE)v102 << 6)) - ((unsigned int)(4 * v101 + (v102 << 6)) >> 8);
  v231 = 32 * v108;
  v112 = v205 + 16 * v210;
  v107 *= 2;
  v113 = v205 - 16 * v210;
  v114 = (unsigned __int8)v105 - (v105 >> 8);
  v115 = v112 + v110 + v107;
  v214 = 16 * v102 - 16 * v101;
  v116 = v112 + v110 - v107;
  v117 = v103 - 16 * v218;
  v118 = v102 + v101;
  v119 = v112 - v110;
  a2[41] = v116;
  v120 = v103 - v218;
  v121 = v103 + v218;
  v122 = v103 - v218 + v109;
  v123 = 8 * (v117 + v114);
  v124 = (v120 - v109) << 6;
  a2[33] = v115;
  v125 = (v117 - v114) << 7;
  v223 = 16 * (v121 - v227);
  v126 = v113 + v111;
  v219 = v121 + v227;
  v122 *= 4;
  a2[37] = v119 + v231;
  v127 = v113 - v111;
  v128 = v205 - v210 + v214;
  v129 = v205 - v210 - v214;
  v130 = v205 + v210 - v118;
  v131 = v205 + v210 + v118;
  a2[35] = v126 + v123;
  a2[45] = v119 - v231;
  a2[40] = v131 - v219;
  a2[39] = v127 + v125;
  a2[38] = v129 + v124;
  a2[36] = v130 + v223;
  a2[32] = v131 + v219;
  a2[43] = v126 - v123;
  a2[47] = v127 - v125;
  a2[34] = v128 + v122;
  a2[42] = v128 - v122;
  a2[46] = v129 - v124;
  a2[44] = v130 - v223;
  v132 = v201[124];
  v133 = v201[60];
  v134 = v201[108];
  v135 = v201[44];
  v206 = v201[76];
  v211 = v131 + v219;
  v136 = v201[28];
  v228 = v201[92];
  v202 = v201[12];
  v137 = (unsigned __int8)(((_BYTE)v132 << 6) + 4 * v133) - ((unsigned int)((v132 << 6) + 4 * v133) >> 8);
  v138 = (unsigned __int8)(4 * v132 + ((_BYTE)v133 << 6)) - ((unsigned int)(4 * v132 + (v133 << 6)) >> 8);
  v139 = v136 + 16 * v228;
  v140 = (unsigned __int8)(((_BYTE)v134 << 6) + 4 * v135) - ((unsigned int)((v134 << 6) + 4 * v135) >> 8);
  v141 = v136 - 16 * v228;
  v224 = v136;
  v142 = v133 + v132;
  v232 = 32 * (v139 - v137);
  v143 = 16 * v133 - 16 * v132;
  v144 = 2 * (v139 + v137);
  v145 = v202 + 16 * v206;
  v146 = v145 + v140;
  v147 = v145 - v140;
  v220 = (unsigned __int8)(4 * v134 + ((_BYTE)v135 << 6)) - ((unsigned int)(4 * v134 + (v135 << 6)) >> 8);
  v148 = 16 * v134;
  v149 = v135 + v134;
  v150 = 16 * v135 - v148;
  a2[49] = v146 + v144;
  v151 = 8 * (v141 + v138);
  v152 = (v141 - v138) << 7;
  a2[57] = v146 - v144;
  v153 = v224 + v228;
  v154 = 4 * (v224 - v228 + v143);
  v225 = (v224 - v228 - v143) << 6;
  v155 = v153 - v142;
  v156 = v153 + v142;
  v157 = v202 + v206 + v149;
  v158 = v202 + v206 - v149;
  v155 *= 16;
  a2[53] = v147 + v232;
  v159 = v202 - 16 * v206;
  a2[61] = v147 - v232;
  v160 = v202 - v206 + v150;
  v161 = v202 - v206 - v150;
  v162 = v157 + v156;
  v163 = v157 - v156;
  v164 = v159 + v220 + v151;
  v165 = v159 + v220 - v151;
  v166 = v159 - v220 + v152;
  v167 = v159 - v220 - v152;
  a2[55] = v166;
  v168 = v160 + v154;
  a2[56] = v163;
  v169 = &unk_F4328;
  v170 = a2;
  a2[54] = v161 + v225;
  a2[52] = v158 + v155;
  a2[51] = v164;
  a2[59] = v165;
  a2[58] = v160 - v154;
  v171 = a2;
  v172 = 120;
  v173 = 2;
  v174 = 60;
  a2[63] = v167;
  a2[50] = v168;
  a2[62] = v161 - v225;
  a2[60] = v158 - v155;
  a2[32] = v211 + v162;
  a2[48] = v211 - v162;
  while ( 1 )
  {
    v175 = v171[49];
    v171 += 4;
    v176 = v171[29];
    v177 = v171[30];
    v178 = v171[31];
    v179 = (unsigned __int16)(v175 * v174) + ((v175 * v174) >> 16);
    v180 = (unsigned __int16)(*((_WORD *)v171 + 92) * v173) + ((v171[46] * v173) >> 16);
    v181 = (unsigned __int16)(*((_WORD *)v171 + 94) * v172) + ((v171[47] * v172) >> 16);
    v171[29] = v176 + v179;
    v171[45] = v176 - v179;
    v171[30] = v177 + v180;
    v171[46] = v177 - v180;
    v171[31] = v178 + v181;
    v171[47] = v178 - v181;
    if ( a2 + 16 == v171 )
      break;
    v182 = v169[32];
    v169 += 32;
    v183 = v171[32];
    v184 = (unsigned __int16)(v182 * *((_WORD *)v171 + 96)) + ((v182 * v171[48]) >> 16);
    v171[32] = v183 + v184;
    v171[48] = v183 - v184;
    v174 = v169[8];
    v173 = v169[16];
    v172 = v169[24];
  }
  v185 = a2[32];
  v186 = a2 + 28;
  v187 = 190;
  v188 = &unk_F4368;
  v189 = 60;
  v190 = *a2 - v185;
  *a2 += v185;
  a2[32] = v190;
  v191 = 46;
  while ( 1 )
  {
    v188 += 16;
    v195 = v170[1];
    v196 = v170[2];
    v197 = v170[3];
    v198 = (unsigned __int16)(*((_WORD *)v170 + 66) * v191) + ((v170[33] * v191) >> 16);
    v199 = (unsigned __int16)(*((_WORD *)v170 + 68) * v189) + ((v170[34] * v189) >> 16);
    result = (unsigned __int16)(v170[35] * v187) + ((v170[35] * v187) >> 16);
    v170[1] = v195 + v198;
    v170[33] = v195 - v198;
    v170[2] = v196 + v199;
    v170[34] = v196 - v199;
    v170[3] = v197 + result;
    v170[35] = v197 - result;
    if ( v170 == v186 )
      break;
    v170 += 4;
    v192 = *(v188 - 16) * v170[32];
    v193 = (unsigned __int16)v192 + (v192 >> 16);
    v194 = *v170 - v193;
    *v170 += v193;
    v170[32] = v194;
    v191 = *(v188 - 12);
    v189 = *(v188 - 8);
    v187 = *(v188 - 4);
  }
  return result;
}

//----- (000D3600) --------------------------------------------------------
int __fastcall sub_D3600(int a1, int a2)
{
  int *v4; // r3
  _DWORD *v5; // r5
  int v6; // r9
  int v7; // r7
  int v8; // r2
  _DWORD *v9; // r12
  int v10; // r0
  int v11; // r11
  int v12; // r11
  int v13; // r10
  int v14; // r10
  int v15; // r2
  int v16; // r1
  int v17; // r0
  int v18; // r7
  int v19; // r6
  int v20; // r8
  int *v21; // r3
  int v22; // r0
  int v23; // r7
  int v24; // r6
  int v25; // r10
  int v26; // r2
  int v27; // r11
  int v28; // r2
  int v29; // r0
  int v30; // r6
  int v31; // r1
  int v32; // r2
  int v33; // r6
  int v34; // r7
  int v35; // lr
  int *v36; // r3
  _DWORD *v37; // r12
  int v38; // r8
  int v39; // r0
  int v40; // r7
  int v41; // r6
  int v42; // r11
  int v43; // r11
  int v44; // r10
  int v45; // r0
  int v46; // r1
  int v47; // r2
  int v48; // r6
  int v49; // r7
  int v50; // r5
  int *v51; // r1
  unsigned __int16 *v52; // r0
  int j; // r2
  int v54; // t1
  int v55; // t1
  int v56; // r2
  int v57; // r3
  int v58; // r1
  int v59; // r4
  int v60; // r2
  int v61; // r0
  int v62; // r9
  int v63; // r7
  int v64; // r12
  int v65; // r0
  int v66; // r10
  int v67; // r2
  int v68; // lr
  int v69; // r8
  int v70; // r6
  int v71; // r4
  int v72; // r7
  int v73; // r5
  int v74; // r10
  int v75; // r2
  int v76; // r7
  int v77; // r4
  int v78; // r12
  int v79; // r0
  int v80; // r6
  int v81; // r2
  int v82; // r1
  int v83; // r7
  int v84; // r5
  int v85; // r8
  int v86; // r6
  int v87; // r12
  int v88; // r8
  int v89; // r2
  int v90; // r9
  int v91; // r5
  int v92; // r4
  int v93; // lr
  int v94; // r1
  int v95; // r2
  int v96; // r4
  int v97; // r5
  int v98; // r0
  int v99; // r1
  int v100; // r2
  int v101; // r4
  int v102; // r10
  int v103; // r8
  int v104; // r6
  int v105; // r5
  int v106; // lr
  int v107; // r7
  int v108; // r2
  int v109; // r2
  int v110; // r10
  int v111; // r12
  int v112; // r0
  int v113; // r1
  int v114; // r8
  int v115; // r0
  int v116; // r12
  int v117; // r7
  int v118; // r6
  int v119; // r9
  int v120; // r6
  int v121; // r10
  int v122; // r0
  int v123; // r12
  int v124; // r4
  int v125; // r9
  int v126; // r2
  int v127; // r8
  int v128; // r10
  int v129; // lr
  int v130; // r12
  int v131; // r0
  int v132; // r1
  int v133; // r4
  int v134; // lr
  int v135; // r4
  int v136; // r0
  int v137; // r5
  int v138; // r6
  int v139; // r2
  int v140; // r8
  int v141; // lr
  int v142; // r0
  int v143; // lr
  int v144; // r12
  int v145; // r8
  int v146; // r5
  int v147; // r9
  int v148; // r10
  int v149; // r0
  int v150; // lr
  int v151; // r6
  int v152; // r9
  int v153; // r7
  int v154; // r2
  int v155; // r1
  int v156; // r8
  int v157; // r5
  int v158; // r4
  int v159; // lr
  int v160; // r12
  int v161; // r7
  int v162; // r2
  int v163; // lr
  int v164; // r2
  int v165; // r10
  int v166; // r7
  int v167; // r1
  int v168; // r4
  int v169; // lr
  int v170; // r1
  int v171; // r12
  int v172; // r9
  int v173; // r6
  int v174; // r1
  int v175; // r7
  int v176; // r6
  int v177; // r2
  int v178; // r7
  int v179; // r10
  int v180; // r7
  int v181; // r4
  int v182; // r1
  int v183; // r5
  int v184; // t2
  int v185; // r7
  int v186; // r2
  int v187; // r5
  int v188; // r8
  int v189; // r7
  int v190; // r8
  int v191; // r2
  int v192; // r0
  int v193; // r4
  int v194; // r12
  int v195; // r12
  int v196; // r8
  int v197; // r9
  int v198; // r1
  int v199; // r5
  int v200; // r3
  int v201; // r4
  int v202; // r2
  int v203; // lr
  int v204; // r7
  int v205; // r6
  int v206; // r12
  int v207; // lr
  int v208; // r2
  int v209; // r1
  int v210; // r7
  int v211; // r10
  int v212; // r9
  int v213; // lr
  int v214; // r3
  int v215; // r2
  int v216; // r7
  int v217; // r12
  int v218; // r0
  int v219; // r3
  int v220; // r4
  int v221; // r6
  int v222; // r5
  int v223; // r1
  int v224; // lr
  int v225; // r2
  int v226; // lr
  int v227; // r0
  int v228; // r3
  int v229; // r6
  int v230; // r0
  int v231; // r12
  int v232; // r3
  int v233; // r4
  int v234; // r8
  int v235; // r9
  int v236; // lr
  int v237; // r0
  int v238; // r7
  int v239; // r10
  int v240; // r5
  int v241; // r3
  int v242; // r4
  int v243; // r10
  int v244; // r9
  int v245; // r1
  int v246; // r5
  int v247; // r3
  int v248; // r2
  int v249; // r0
  int v250; // r12
  int v251; // r6
  int v252; // r1
  int v253; // r2
  int v254; // r10
  int v255; // r2
  int v256; // r9
  int v257; // r3
  int v258; // lr
  int v259; // r12
  int v260; // r4
  int v261; // r12
  int v262; // r1
  int v263; // r9
  int v264; // r7
  int v265; // r8
  int v266; // r12
  int v267; // r10
  int v268; // r4
  int v269; // r5
  int v270; // r0
  int v271; // lr
  int v272; // r1
  int v273; // r3
  int v274; // r4
  int v275; // r2
  int v276; // r10
  int v277; // lr
  int v278; // r7
  int v279; // r9
  int v280; // r12
  int v281; // r3
  int v282; // r0
  int v283; // r1
  int v284; // r7
  int v285; // r3
  int v286; // lr
  int v287; // r1
  int v288; // r8
  int v289; // r2
  int v290; // r7
  int v291; // r10
  int v292; // r3
  int v293; // r0
  int v294; // r7
  int v295; // r3
  int v296; // r6
  int v297; // r10
  int v298; // r12
  int v299; // r0
  int v300; // r3
  int v301; // lr
  int v302; // r12
  int v303; // r3
  int v304; // r0
  int v305; // r4
  int v306; // r9
  int v307; // r5
  int v308; // r7
  int v309; // r12
  int v310; // r8
  int v311; // r0
  int v312; // r4
  int v313; // r3
  int v314; // r1
  int v315; // r10
  int v316; // r5
  int v317; // r11
  int v318; // r12
  int v319; // r2
  int v320; // r4
  int v321; // r10
  int v322; // r12
  int v323; // r2
  int v324; // r1
  int v325; // lr
  int v326; // r9
  int v327; // r5
  int v328; // r12
  int v329; // r0
  int v330; // r8
  int v331; // r7
  int v332; // r6
  int v333; // r11
  int v334; // r3
  int v335; // lr
  int v336; // r9
  int v337; // r0
  int v338; // r3
  int v339; // r6
  int v340; // r7
  int v341; // r5
  int v342; // r1
  int v343; // r3
  int v344; // r2
  int v345; // r12
  int v346; // r2
  int v347; // r3
  int v348; // r4
  int v349; // lr
  int v350; // r6
  int v351; // r10
  int v352; // r12
  int v353; // r1
  int v354; // r2
  int v355; // r2
  int v356; // r0
  int v357; // r12
  int v358; // lr
  int v359; // r5
  int v360; // r3
  int v361; // r7
  int v362; // r8
  int v363; // r9
  int result; // r0
  unsigned __int16 *v365; // r0
  int *v366; // r1
  int i; // r2
  int v368; // t1
  int v369; // t1
  int v370; // r2
  int v371; // r3
  int v372; // [sp+0h] [bp-59Ch]
  int v373; // [sp+0h] [bp-59Ch]
  int v374; // [sp+0h] [bp-59Ch]
  int v375; // [sp+0h] [bp-59Ch]
  int v376; // [sp+0h] [bp-59Ch]
  int v377; // [sp+0h] [bp-59Ch]
  int v378; // [sp+0h] [bp-59Ch]
  int v379; // [sp+0h] [bp-59Ch]
  int v380; // [sp+0h] [bp-59Ch]
  int v381; // [sp+0h] [bp-59Ch]
  int v382; // [sp+0h] [bp-59Ch]
  int v383; // [sp+0h] [bp-59Ch]
  int v384; // [sp+0h] [bp-59Ch]
  int v385; // [sp+0h] [bp-59Ch]
  int v386; // [sp+0h] [bp-59Ch]
  int v387; // [sp+4h] [bp-598h]
  int v388; // [sp+4h] [bp-598h]
  int v389; // [sp+4h] [bp-598h]
  int v390; // [sp+4h] [bp-598h]
  int v391; // [sp+4h] [bp-598h]
  int v392; // [sp+4h] [bp-598h]
  int v393; // [sp+4h] [bp-598h]
  int v394; // [sp+4h] [bp-598h]
  int v395; // [sp+4h] [bp-598h]
  int v396; // [sp+4h] [bp-598h]
  int v397; // [sp+4h] [bp-598h]
  int v398; // [sp+4h] [bp-598h]
  int v399; // [sp+4h] [bp-598h]
  int v400; // [sp+8h] [bp-594h]
  int v401; // [sp+8h] [bp-594h]
  int v402; // [sp+8h] [bp-594h]
  int v403; // [sp+8h] [bp-594h]
  int v404; // [sp+8h] [bp-594h]
  int v405; // [sp+8h] [bp-594h]
  int v406; // [sp+8h] [bp-594h]
  int v407; // [sp+8h] [bp-594h]
  int v408; // [sp+8h] [bp-594h]
  int v409; // [sp+8h] [bp-594h]
  int v410; // [sp+8h] [bp-594h]
  int v411; // [sp+8h] [bp-594h]
  int v412; // [sp+8h] [bp-594h]
  int v413; // [sp+8h] [bp-594h]
  int v414; // [sp+8h] [bp-594h]
  int v415; // [sp+Ch] [bp-590h]
  int v416; // [sp+Ch] [bp-590h]
  int v417; // [sp+Ch] [bp-590h]
  int v418; // [sp+Ch] [bp-590h]
  int v419; // [sp+Ch] [bp-590h]
  int v420; // [sp+Ch] [bp-590h]
  int v421; // [sp+Ch] [bp-590h]
  int v422; // [sp+Ch] [bp-590h]
  int v423; // [sp+Ch] [bp-590h]
  int v424; // [sp+Ch] [bp-590h]
  int v425; // [sp+Ch] [bp-590h]
  int v426; // [sp+Ch] [bp-590h]
  int v427; // [sp+Ch] [bp-590h]
  int v428; // [sp+10h] [bp-58Ch]
  int v429; // [sp+10h] [bp-58Ch]
  int v430; // [sp+10h] [bp-58Ch]
  int v431; // [sp+10h] [bp-58Ch]
  int v432; // [sp+10h] [bp-58Ch]
  int v433; // [sp+10h] [bp-58Ch]
  int v434; // [sp+10h] [bp-58Ch]
  int v435; // [sp+10h] [bp-58Ch]
  int v436; // [sp+10h] [bp-58Ch]
  int v437; // [sp+10h] [bp-58Ch]
  int v438; // [sp+10h] [bp-58Ch]
  int v439; // [sp+10h] [bp-58Ch]
  int v440; // [sp+14h] [bp-588h]
  int v441; // [sp+14h] [bp-588h]
  int v442; // [sp+14h] [bp-588h]
  int v443; // [sp+14h] [bp-588h]
  int v444; // [sp+14h] [bp-588h]
  int v445; // [sp+14h] [bp-588h]
  int v446; // [sp+14h] [bp-588h]
  int v447; // [sp+14h] [bp-588h]
  int v448; // [sp+14h] [bp-588h]
  int v449; // [sp+14h] [bp-588h]
  int v450; // [sp+14h] [bp-588h]
  int v451; // [sp+14h] [bp-588h]
  int v452; // [sp+18h] [bp-584h]
  int v453; // [sp+18h] [bp-584h]
  int v454; // [sp+18h] [bp-584h]
  int v455; // [sp+18h] [bp-584h]
  int v456; // [sp+18h] [bp-584h]
  int v457; // [sp+18h] [bp-584h]
  int v458; // [sp+18h] [bp-584h]
  int v459; // [sp+18h] [bp-584h]
  int v460; // [sp+18h] [bp-584h]
  int v461; // [sp+18h] [bp-584h]
  int v462; // [sp+18h] [bp-584h]
  int v463; // [sp+1Ch] [bp-580h]
  int v464; // [sp+1Ch] [bp-580h]
  int v465; // [sp+1Ch] [bp-580h]
  int v466; // [sp+1Ch] [bp-580h]
  int v467; // [sp+1Ch] [bp-580h]
  int v468; // [sp+1Ch] [bp-580h]
  int v469; // [sp+1Ch] [bp-580h]
  int v470; // [sp+1Ch] [bp-580h]
  int v471; // [sp+1Ch] [bp-580h]
  int v472; // [sp+1Ch] [bp-580h]
  int v473; // [sp+1Ch] [bp-580h]
  int v474; // [sp+1Ch] [bp-580h]
  int v475; // [sp+1Ch] [bp-580h]
  int v476; // [sp+20h] [bp-57Ch]
  int v477; // [sp+20h] [bp-57Ch]
  int v478; // [sp+20h] [bp-57Ch]
  int v479; // [sp+20h] [bp-57Ch]
  int v480; // [sp+20h] [bp-57Ch]
  int v481; // [sp+20h] [bp-57Ch]
  int v482; // [sp+20h] [bp-57Ch]
  int v483; // [sp+20h] [bp-57Ch]
  int v484; // [sp+20h] [bp-57Ch]
  int v485; // [sp+20h] [bp-57Ch]
  int v486; // [sp+20h] [bp-57Ch]
  int v487; // [sp+24h] [bp-578h]
  int v488; // [sp+24h] [bp-578h]
  int v489; // [sp+24h] [bp-578h]
  int v490; // [sp+24h] [bp-578h]
  int v491; // [sp+24h] [bp-578h]
  int v492; // [sp+24h] [bp-578h]
  int v493; // [sp+24h] [bp-578h]
  int v494; // [sp+24h] [bp-578h]
  int v495; // [sp+24h] [bp-578h]
  int v496; // [sp+24h] [bp-578h]
  int v497; // [sp+24h] [bp-578h]
  int v498; // [sp+28h] [bp-574h]
  int v499; // [sp+28h] [bp-574h]
  int v500; // [sp+28h] [bp-574h]
  int v501; // [sp+28h] [bp-574h]
  int v502; // [sp+28h] [bp-574h]
  int v503; // [sp+28h] [bp-574h]
  int v504; // [sp+28h] [bp-574h]
  int v505; // [sp+28h] [bp-574h]
  int v506; // [sp+28h] [bp-574h]
  int v507; // [sp+28h] [bp-574h]
  int v508; // [sp+28h] [bp-574h]
  int v509; // [sp+2Ch] [bp-570h]
  int v510; // [sp+2Ch] [bp-570h]
  int v511; // [sp+2Ch] [bp-570h]
  int v512; // [sp+2Ch] [bp-570h]
  int v513; // [sp+2Ch] [bp-570h]
  int v514; // [sp+2Ch] [bp-570h]
  int v515; // [sp+2Ch] [bp-570h]
  int v516; // [sp+2Ch] [bp-570h]
  int v517; // [sp+2Ch] [bp-570h]
  int v518; // [sp+2Ch] [bp-570h]
  int v519; // [sp+2Ch] [bp-570h]
  int v520; // [sp+2Ch] [bp-570h]
  int v521; // [sp+2Ch] [bp-570h]
  int v522; // [sp+30h] [bp-56Ch]
  int v523; // [sp+30h] [bp-56Ch]
  int v524; // [sp+30h] [bp-56Ch]
  int v525; // [sp+30h] [bp-56Ch]
  int v526; // [sp+30h] [bp-56Ch]
  int v527; // [sp+30h] [bp-56Ch]
  int v528; // [sp+30h] [bp-56Ch]
  int v529; // [sp+30h] [bp-56Ch]
  int v530; // [sp+30h] [bp-56Ch]
  int v531; // [sp+30h] [bp-56Ch]
  int v532; // [sp+30h] [bp-56Ch]
  int v533; // [sp+30h] [bp-56Ch]
  int v534; // [sp+30h] [bp-56Ch]
  int v535; // [sp+34h] [bp-568h]
  int v536; // [sp+34h] [bp-568h]
  int v537; // [sp+34h] [bp-568h]
  int v538; // [sp+34h] [bp-568h]
  int v539; // [sp+34h] [bp-568h]
  int v540; // [sp+34h] [bp-568h]
  int v541; // [sp+34h] [bp-568h]
  int v542; // [sp+34h] [bp-568h]
  int v543; // [sp+34h] [bp-568h]
  int v544; // [sp+34h] [bp-568h]
  int v545; // [sp+38h] [bp-564h]
  int v546; // [sp+38h] [bp-564h]
  int v547; // [sp+38h] [bp-564h]
  int v548; // [sp+38h] [bp-564h]
  int v549; // [sp+38h] [bp-564h]
  int v550; // [sp+38h] [bp-564h]
  int v551; // [sp+38h] [bp-564h]
  int v552; // [sp+38h] [bp-564h]
  int v553; // [sp+38h] [bp-564h]
  int v554; // [sp+3Ch] [bp-560h]
  int v555; // [sp+3Ch] [bp-560h]
  int v556; // [sp+3Ch] [bp-560h]
  int v557; // [sp+3Ch] [bp-560h]
  int v558; // [sp+3Ch] [bp-560h]
  int v559; // [sp+3Ch] [bp-560h]
  int v560; // [sp+3Ch] [bp-560h]
  int v561; // [sp+3Ch] [bp-560h]
  int v562; // [sp+3Ch] [bp-560h]
  int v563; // [sp+3Ch] [bp-560h]
  int v564; // [sp+3Ch] [bp-560h]
  int v565; // [sp+40h] [bp-55Ch]
  int v566; // [sp+40h] [bp-55Ch]
  int v567; // [sp+40h] [bp-55Ch]
  int v568; // [sp+40h] [bp-55Ch]
  int v569; // [sp+40h] [bp-55Ch]
  int v570; // [sp+40h] [bp-55Ch]
  int v571; // [sp+40h] [bp-55Ch]
  int v572; // [sp+40h] [bp-55Ch]
  int v573; // [sp+40h] [bp-55Ch]
  int v574; // [sp+40h] [bp-55Ch]
  int v575; // [sp+40h] [bp-55Ch]
  int v576; // [sp+44h] [bp-558h]
  int v577; // [sp+44h] [bp-558h]
  int v578; // [sp+44h] [bp-558h]
  int v579; // [sp+44h] [bp-558h]
  int v580; // [sp+44h] [bp-558h]
  int v581; // [sp+44h] [bp-558h]
  int v582; // [sp+44h] [bp-558h]
  int v583; // [sp+44h] [bp-558h]
  int v584; // [sp+44h] [bp-558h]
  int v585; // [sp+44h] [bp-558h]
  int v586; // [sp+44h] [bp-558h]
  int v587; // [sp+48h] [bp-554h]
  int v588; // [sp+48h] [bp-554h]
  int v589; // [sp+48h] [bp-554h]
  int v590; // [sp+48h] [bp-554h]
  int v591; // [sp+48h] [bp-554h]
  int v592; // [sp+48h] [bp-554h]
  int v593; // [sp+48h] [bp-554h]
  int v594; // [sp+48h] [bp-554h]
  int v595; // [sp+48h] [bp-554h]
  int v596; // [sp+48h] [bp-554h]
  int v597; // [sp+48h] [bp-554h]
  int v598; // [sp+4Ch] [bp-550h]
  int v599; // [sp+4Ch] [bp-550h]
  int v600; // [sp+4Ch] [bp-550h]
  int v601; // [sp+4Ch] [bp-550h]
  int v602; // [sp+4Ch] [bp-550h]
  int v603; // [sp+4Ch] [bp-550h]
  int v604; // [sp+4Ch] [bp-550h]
  int v605; // [sp+4Ch] [bp-550h]
  int v606; // [sp+4Ch] [bp-550h]
  int v607; // [sp+4Ch] [bp-550h]
  int v608; // [sp+4Ch] [bp-550h]
  int v609; // [sp+4Ch] [bp-550h]
  int v610; // [sp+50h] [bp-54Ch]
  int v611; // [sp+50h] [bp-54Ch]
  int v612; // [sp+50h] [bp-54Ch]
  int v613; // [sp+50h] [bp-54Ch]
  int v614; // [sp+50h] [bp-54Ch]
  int v615; // [sp+50h] [bp-54Ch]
  int v616; // [sp+50h] [bp-54Ch]
  int v617; // [sp+50h] [bp-54Ch]
  int v618; // [sp+50h] [bp-54Ch]
  int v619; // [sp+50h] [bp-54Ch]
  int v620; // [sp+50h] [bp-54Ch]
  int v621; // [sp+50h] [bp-54Ch]
  int v622; // [sp+50h] [bp-54Ch]
  int v623; // [sp+50h] [bp-54Ch]
  int v624; // [sp+54h] [bp-548h]
  int v625; // [sp+54h] [bp-548h]
  int v626; // [sp+54h] [bp-548h]
  int v627; // [sp+54h] [bp-548h]
  int v628; // [sp+54h] [bp-548h]
  int v629; // [sp+54h] [bp-548h]
  int v630; // [sp+54h] [bp-548h]
  int v631; // [sp+54h] [bp-548h]
  int v632; // [sp+54h] [bp-548h]
  int v633; // [sp+54h] [bp-548h]
  int v634; // [sp+54h] [bp-548h]
  int v635; // [sp+54h] [bp-548h]
  int v636; // [sp+54h] [bp-548h]
  int v637; // [sp+54h] [bp-548h]
  int v638; // [sp+54h] [bp-548h]
  int v639; // [sp+58h] [bp-544h]
  int v640; // [sp+58h] [bp-544h]
  int v641; // [sp+58h] [bp-544h]
  int v642; // [sp+58h] [bp-544h]
  int v643; // [sp+58h] [bp-544h]
  int v644; // [sp+58h] [bp-544h]
  int v645; // [sp+58h] [bp-544h]
  int v646; // [sp+58h] [bp-544h]
  int v647; // [sp+58h] [bp-544h]
  int v648; // [sp+58h] [bp-544h]
  int v649; // [sp+58h] [bp-544h]
  int v650; // [sp+58h] [bp-544h]
  int v651; // [sp+5Ch] [bp-540h]
  int v652; // [sp+5Ch] [bp-540h]
  int v653; // [sp+5Ch] [bp-540h]
  int v654; // [sp+5Ch] [bp-540h]
  int v655; // [sp+5Ch] [bp-540h]
  int v656; // [sp+5Ch] [bp-540h]
  int v657; // [sp+5Ch] [bp-540h]
  int v658; // [sp+5Ch] [bp-540h]
  int v659; // [sp+5Ch] [bp-540h]
  int v660; // [sp+5Ch] [bp-540h]
  int v661; // [sp+5Ch] [bp-540h]
  int v662; // [sp+5Ch] [bp-540h]
  int v663; // [sp+60h] [bp-53Ch]
  int v664; // [sp+60h] [bp-53Ch]
  int v665; // [sp+60h] [bp-53Ch]
  int v666; // [sp+60h] [bp-53Ch]
  int v667; // [sp+60h] [bp-53Ch]
  int v668; // [sp+60h] [bp-53Ch]
  int v669; // [sp+60h] [bp-53Ch]
  int v670; // [sp+60h] [bp-53Ch]
  int v671; // [sp+60h] [bp-53Ch]
  int v672; // [sp+60h] [bp-53Ch]
  int v673; // [sp+60h] [bp-53Ch]
  int v674; // [sp+60h] [bp-53Ch]
  int v675; // [sp+60h] [bp-53Ch]
  int v676; // [sp+60h] [bp-53Ch]
  int v677; // [sp+64h] [bp-538h]
  int v678; // [sp+64h] [bp-538h]
  int v679; // [sp+64h] [bp-538h]
  int v680; // [sp+64h] [bp-538h]
  int v681; // [sp+64h] [bp-538h]
  int v682; // [sp+64h] [bp-538h]
  int v683; // [sp+64h] [bp-538h]
  int v684; // [sp+64h] [bp-538h]
  int v685; // [sp+64h] [bp-538h]
  int v686; // [sp+64h] [bp-538h]
  int v687; // [sp+64h] [bp-538h]
  int v688; // [sp+64h] [bp-538h]
  int v689; // [sp+68h] [bp-534h]
  int v690; // [sp+68h] [bp-534h]
  int v691; // [sp+68h] [bp-534h]
  int v692; // [sp+68h] [bp-534h]
  int v693; // [sp+68h] [bp-534h]
  int v694; // [sp+68h] [bp-534h]
  int v695; // [sp+68h] [bp-534h]
  int v696; // [sp+68h] [bp-534h]
  int v697; // [sp+68h] [bp-534h]
  int v698; // [sp+68h] [bp-534h]
  int v699; // [sp+68h] [bp-534h]
  int v700; // [sp+68h] [bp-534h]
  int v701; // [sp+68h] [bp-534h]
  int v702; // [sp+6Ch] [bp-530h]
  int v703; // [sp+6Ch] [bp-530h]
  int v704; // [sp+6Ch] [bp-530h]
  int v705; // [sp+6Ch] [bp-530h]
  int v706; // [sp+6Ch] [bp-530h]
  int v707; // [sp+6Ch] [bp-530h]
  int v708; // [sp+6Ch] [bp-530h]
  int v709; // [sp+6Ch] [bp-530h]
  int v710; // [sp+6Ch] [bp-530h]
  int v711; // [sp+6Ch] [bp-530h]
  int v712; // [sp+6Ch] [bp-530h]
  int v713; // [sp+70h] [bp-52Ch]
  int v714; // [sp+70h] [bp-52Ch]
  int v715; // [sp+70h] [bp-52Ch]
  int v716; // [sp+70h] [bp-52Ch]
  int v717; // [sp+70h] [bp-52Ch]
  int v718; // [sp+70h] [bp-52Ch]
  int v719; // [sp+70h] [bp-52Ch]
  int v720; // [sp+70h] [bp-52Ch]
  int v721; // [sp+70h] [bp-52Ch]
  int v722; // [sp+70h] [bp-52Ch]
  int v723; // [sp+70h] [bp-52Ch]
  int v724; // [sp+70h] [bp-52Ch]
  int v725; // [sp+74h] [bp-528h]
  int v726; // [sp+74h] [bp-528h]
  int v727; // [sp+74h] [bp-528h]
  int v728; // [sp+74h] [bp-528h]
  int v729; // [sp+74h] [bp-528h]
  int v730; // [sp+74h] [bp-528h]
  int v731; // [sp+74h] [bp-528h]
  int v732; // [sp+74h] [bp-528h]
  int v733; // [sp+74h] [bp-528h]
  int v734; // [sp+74h] [bp-528h]
  int v735; // [sp+74h] [bp-528h]
  int v736; // [sp+78h] [bp-524h]
  int v737; // [sp+78h] [bp-524h]
  int v738; // [sp+78h] [bp-524h]
  int v739; // [sp+78h] [bp-524h]
  int v740; // [sp+78h] [bp-524h]
  int v741; // [sp+78h] [bp-524h]
  int v742; // [sp+78h] [bp-524h]
  int v743; // [sp+78h] [bp-524h]
  int v744; // [sp+78h] [bp-524h]
  int v745; // [sp+78h] [bp-524h]
  int v746; // [sp+78h] [bp-524h]
  int v747; // [sp+78h] [bp-524h]
  int v748; // [sp+7Ch] [bp-520h]
  int v749; // [sp+7Ch] [bp-520h]
  int v750; // [sp+7Ch] [bp-520h]
  int v751; // [sp+7Ch] [bp-520h]
  int v752; // [sp+7Ch] [bp-520h]
  int v753; // [sp+7Ch] [bp-520h]
  int v754; // [sp+7Ch] [bp-520h]
  int v755; // [sp+7Ch] [bp-520h]
  int v756; // [sp+7Ch] [bp-520h]
  int v757; // [sp+7Ch] [bp-520h]
  int v758; // [sp+80h] [bp-51Ch]
  int v759; // [sp+80h] [bp-51Ch]
  int v760; // [sp+80h] [bp-51Ch]
  int v761; // [sp+80h] [bp-51Ch]
  int v762; // [sp+80h] [bp-51Ch]
  int v763; // [sp+80h] [bp-51Ch]
  int v764; // [sp+80h] [bp-51Ch]
  int v765; // [sp+80h] [bp-51Ch]
  int v766; // [sp+80h] [bp-51Ch]
  int v767; // [sp+80h] [bp-51Ch]
  int v768; // [sp+80h] [bp-51Ch]
  int v769; // [sp+80h] [bp-51Ch]
  int v770; // [sp+80h] [bp-51Ch]
  int v771; // [sp+80h] [bp-51Ch]
  int v772; // [sp+84h] [bp-518h]
  int v773; // [sp+84h] [bp-518h]
  int v774; // [sp+84h] [bp-518h]
  int v775; // [sp+84h] [bp-518h]
  int v776; // [sp+84h] [bp-518h]
  int v777; // [sp+84h] [bp-518h]
  int v778; // [sp+84h] [bp-518h]
  int v779; // [sp+84h] [bp-518h]
  int v780; // [sp+84h] [bp-518h]
  int v781; // [sp+84h] [bp-518h]
  int v782; // [sp+88h] [bp-514h]
  int v783; // [sp+88h] [bp-514h]
  int v784; // [sp+88h] [bp-514h]
  int v785; // [sp+88h] [bp-514h]
  int v786; // [sp+88h] [bp-514h]
  int v787; // [sp+88h] [bp-514h]
  int v788; // [sp+88h] [bp-514h]
  int v789; // [sp+88h] [bp-514h]
  int v790; // [sp+8Ch] [bp-510h]
  int v791; // [sp+8Ch] [bp-510h]
  int v792; // [sp+8Ch] [bp-510h]
  int v793; // [sp+8Ch] [bp-510h]
  int v794; // [sp+8Ch] [bp-510h]
  int v795; // [sp+8Ch] [bp-510h]
  int v796; // [sp+90h] [bp-50Ch]
  int v797; // [sp+90h] [bp-50Ch]
  int v798; // [sp+90h] [bp-50Ch]
  int v799; // [sp+90h] [bp-50Ch]
  int v800; // [sp+90h] [bp-50Ch]
  int v801; // [sp+94h] [bp-508h]
  int v802; // [sp+94h] [bp-508h]
  int v803; // [sp+94h] [bp-508h]
  int v804; // [sp+94h] [bp-508h]
  int v805; // [sp+98h] [bp-504h]
  int v806; // [sp+98h] [bp-504h]
  int v807; // [sp+98h] [bp-504h]
  int v808; // [sp+98h] [bp-504h]
  int v809; // [sp+9Ch] [bp-500h]
  int v810; // [sp+9Ch] [bp-500h]
  int v811; // [sp+9Ch] [bp-500h]
  int v812; // [sp+9Ch] [bp-500h]
  int v814; // [sp+A4h] [bp-4F8h]
  int v815; // [sp+A8h] [bp-4F4h]
  int v816; // [sp+ACh] [bp-4F0h]
  int v817; // [sp+B0h] [bp-4ECh]
  int v818; // [sp+B4h] [bp-4E8h]
  int v819; // [sp+B8h] [bp-4E4h]
  int v820; // [sp+BCh] [bp-4E0h]
  int v821; // [sp+C0h] [bp-4DCh]
  int v822; // [sp+C4h] [bp-4D8h]
  int v823; // [sp+C8h] [bp-4D4h]
  int v824; // [sp+CCh] [bp-4D0h]
  int v825; // [sp+D0h] [bp-4CCh]
  int v826; // [sp+D4h] [bp-4C8h]
  int v827; // [sp+D8h] [bp-4C4h]
  int v828; // [sp+DCh] [bp-4C0h]
  int v829; // [sp+E0h] [bp-4BCh]
  int v830; // [sp+E4h] [bp-4B8h]
  int v831; // [sp+E8h] [bp-4B4h]
  int v832; // [sp+ECh] [bp-4B0h]
  int v833; // [sp+F0h] [bp-4ACh]
  int v834; // [sp+F4h] [bp-4A8h]
  int v835; // [sp+F8h] [bp-4A4h]
  int v836; // [sp+FCh] [bp-4A0h]
  int v837; // [sp+100h] [bp-49Ch]
  int v838; // [sp+104h] [bp-498h]
  int v839; // [sp+108h] [bp-494h]
  int v840; // [sp+10Ch] [bp-490h]
  int v841; // [sp+110h] [bp-48Ch]
  int v842; // [sp+114h] [bp-488h]
  int v843; // [sp+118h] [bp-484h]
  int v844; // [sp+11Ch] [bp-480h]
  int v845; // [sp+120h] [bp-47Ch]
  int v846; // [sp+124h] [bp-478h]
  int v847; // [sp+124h] [bp-478h]
  int v848; // [sp+124h] [bp-478h]
  int v849; // [sp+124h] [bp-478h]
  int v850; // [sp+128h] [bp-474h]
  int v851; // [sp+128h] [bp-474h]
  int v852; // [sp+12Ch] [bp-470h]
  int v853; // [sp+12Ch] [bp-470h]
  int v854; // [sp+12Ch] [bp-470h]
  int v855; // [sp+12Ch] [bp-470h]
  int v856; // [sp+130h] [bp-46Ch]
  int v857; // [sp+134h] [bp-468h]
  int v858; // [sp+134h] [bp-468h]
  int v859; // [sp+138h] [bp-464h]
  int v860; // [sp+13Ch] [bp-460h]
  int v861; // [sp+13Ch] [bp-460h]
  int v862; // [sp+140h] [bp-45Ch]
  int v863; // [sp+144h] [bp-458h]
  int v864; // [sp+150h] [bp-44Ch]
  int v865; // [sp+154h] [bp-448h]
  int v866; // [sp+154h] [bp-448h]
  int v867; // [sp+194h] [bp-408h] BYREF
  int v868; // [sp+198h] [bp-404h] BYREF
  int v869; // [sp+19Ch] [bp-400h]
  int v870; // [sp+1A0h] [bp-3FCh]
  int v871; // [sp+1A4h] [bp-3F8h]
  int v872; // [sp+1A8h] [bp-3F4h]
  int v873; // [sp+1ACh] [bp-3F0h]
  int v874; // [sp+1B0h] [bp-3ECh]
  int v875; // [sp+1B4h] [bp-3E8h]
  int v876; // [sp+1B8h] [bp-3E4h]
  int v877; // [sp+1BCh] [bp-3E0h]
  int v878; // [sp+1C0h] [bp-3DCh]
  int v879; // [sp+1C4h] [bp-3D8h]
  int v880; // [sp+1C8h] [bp-3D4h]
  int v881; // [sp+1CCh] [bp-3D0h]
  int v882; // [sp+1D0h] [bp-3CCh]
  int v883; // [sp+1D4h] [bp-3C8h]
  int v884; // [sp+1D8h] [bp-3C4h]
  int v885; // [sp+1DCh] [bp-3C0h]
  int v886; // [sp+1E0h] [bp-3BCh]
  int v887; // [sp+1E4h] [bp-3B8h]
  int v888; // [sp+1E8h] [bp-3B4h]
  int v889; // [sp+1ECh] [bp-3B0h]
  int v890; // [sp+1F0h] [bp-3ACh]
  int v891; // [sp+1F4h] [bp-3A8h]
  int v892; // [sp+1F8h] [bp-3A4h]
  int v893; // [sp+1FCh] [bp-3A0h]
  int v894; // [sp+200h] [bp-39Ch]
  int v895; // [sp+204h] [bp-398h]
  int v896; // [sp+208h] [bp-394h]
  int v897; // [sp+20Ch] [bp-390h]
  int v898; // [sp+210h] [bp-38Ch]
  int v899; // [sp+214h] [bp-388h]
  int v900; // [sp+218h] [bp-384h]
  int v901; // [sp+21Ch] [bp-380h]
  int v902; // [sp+220h] [bp-37Ch]
  int v903; // [sp+224h] [bp-378h]
  int v904; // [sp+228h] [bp-374h]
  int v905; // [sp+22Ch] [bp-370h]
  int v906; // [sp+230h] [bp-36Ch]
  int v907; // [sp+234h] [bp-368h]
  int v908; // [sp+238h] [bp-364h]
  int v909; // [sp+23Ch] [bp-360h]
  int v910; // [sp+240h] [bp-35Ch]
  int v911; // [sp+244h] [bp-358h]
  int v912; // [sp+248h] [bp-354h]
  int v913; // [sp+24Ch] [bp-350h]
  int v914; // [sp+250h] [bp-34Ch]
  int v915; // [sp+254h] [bp-348h]
  int v916; // [sp+258h] [bp-344h]
  int v917; // [sp+25Ch] [bp-340h]
  int v918; // [sp+260h] [bp-33Ch]
  int v919; // [sp+264h] [bp-338h]
  int v920; // [sp+268h] [bp-334h]
  int v921; // [sp+26Ch] [bp-330h]
  int v922; // [sp+270h] [bp-32Ch]
  int v923; // [sp+274h] [bp-328h]
  int v924; // [sp+278h] [bp-324h]
  int v925; // [sp+27Ch] [bp-320h]
  int v926; // [sp+280h] [bp-31Ch]
  int v927; // [sp+284h] [bp-318h]
  int v928; // [sp+288h] [bp-314h] BYREF
  int v929; // [sp+28Ch] [bp-310h]
  int v930; // [sp+290h] [bp-30Ch]
  int v931; // [sp+294h] [bp-308h]
  int v932; // [sp+298h] [bp-304h] BYREF
  int v933; // [sp+29Ch] [bp-300h]
  int v934; // [sp+2A0h] [bp-2FCh]
  int v935; // [sp+2A4h] [bp-2F8h]
  int v936; // [sp+2A8h] [bp-2F4h]
  int v937; // [sp+2ACh] [bp-2F0h]
  int v938; // [sp+2B0h] [bp-2ECh]
  int v939; // [sp+2B4h] [bp-2E8h]
  int v940; // [sp+2B8h] [bp-2E4h]
  int v941; // [sp+2BCh] [bp-2E0h]
  int v942; // [sp+2C0h] [bp-2DCh]
  int v943; // [sp+2C4h] [bp-2D8h]
  int v944; // [sp+2C8h] [bp-2D4h]
  int v945; // [sp+2CCh] [bp-2D0h]
  int v946; // [sp+2D0h] [bp-2CCh]
  int v947; // [sp+2D4h] [bp-2C8h]
  int v948; // [sp+2D8h] [bp-2C4h]
  int v949; // [sp+2DCh] [bp-2C0h]
  int v950; // [sp+2E0h] [bp-2BCh]
  int v951; // [sp+2E4h] [bp-2B8h]
  int v952; // [sp+2E8h] [bp-2B4h]
  int v953; // [sp+2ECh] [bp-2B0h]
  int v954; // [sp+2F0h] [bp-2ACh]
  int v955; // [sp+2F4h] [bp-2A8h]
  int v956; // [sp+2F8h] [bp-2A4h]
  int v957; // [sp+2FCh] [bp-2A0h]
  int v958; // [sp+300h] [bp-29Ch]
  int v959; // [sp+304h] [bp-298h]
  int v960; // [sp+308h] [bp-294h]
  int v961; // [sp+30Ch] [bp-290h]
  int v962; // [sp+310h] [bp-28Ch]
  int v963; // [sp+314h] [bp-288h]
  int v964; // [sp+318h] [bp-284h]
  int v965; // [sp+31Ch] [bp-280h]
  int v966; // [sp+320h] [bp-27Ch]
  int v967; // [sp+324h] [bp-278h]
  int v968; // [sp+328h] [bp-274h]
  int v969; // [sp+32Ch] [bp-270h]
  int v970; // [sp+330h] [bp-26Ch]
  int v971; // [sp+334h] [bp-268h]
  int v972; // [sp+338h] [bp-264h]
  int v973; // [sp+33Ch] [bp-260h]
  int v974; // [sp+340h] [bp-25Ch]
  int v975; // [sp+344h] [bp-258h]
  int v976; // [sp+348h] [bp-254h]
  int v977; // [sp+34Ch] [bp-250h]
  int v978; // [sp+350h] [bp-24Ch]
  int v979; // [sp+354h] [bp-248h]
  int v980; // [sp+358h] [bp-244h]
  int v981; // [sp+35Ch] [bp-240h]
  int v982; // [sp+360h] [bp-23Ch]
  int v983; // [sp+364h] [bp-238h]
  int v984; // [sp+368h] [bp-234h]
  int v985; // [sp+36Ch] [bp-230h]
  int v986; // [sp+370h] [bp-22Ch]
  int v987; // [sp+374h] [bp-228h]
  int v988; // [sp+378h] [bp-224h]
  int v989; // [sp+37Ch] [bp-220h]
  int v990; // [sp+380h] [bp-21Ch]
  int v991; // [sp+384h] [bp-218h]
  int v992; // [sp+388h] [bp-214h] BYREF
  int v993; // [sp+38Ch] [bp-210h]
  int v994; // [sp+390h] [bp-20Ch]
  int v995; // [sp+394h] [bp-208h]
  int v996; // [sp+398h] [bp-204h] BYREF
  int v997; // [sp+39Ch] [bp-200h]
  int v998; // [sp+3A0h] [bp-1FCh]
  int v999; // [sp+3A4h] [bp-1F8h]
  int v1000; // [sp+3A8h] [bp-1F4h]
  int v1001; // [sp+3ACh] [bp-1F0h]
  int v1002; // [sp+3B0h] [bp-1ECh]
  int v1003; // [sp+3B4h] [bp-1E8h]
  int v1004; // [sp+3B8h] [bp-1E4h]
  int v1005; // [sp+3BCh] [bp-1E0h]
  int v1006; // [sp+3C0h] [bp-1DCh]
  int v1007; // [sp+3C4h] [bp-1D8h]
  int v1008; // [sp+3C8h] [bp-1D4h]
  int v1009; // [sp+3CCh] [bp-1D0h]
  int v1010; // [sp+3D0h] [bp-1CCh]
  int v1011; // [sp+3D4h] [bp-1C8h]
  int v1012; // [sp+3D8h] [bp-1C4h]
  int v1013; // [sp+3DCh] [bp-1C0h]
  int v1014; // [sp+3E0h] [bp-1BCh]
  int v1015; // [sp+3E4h] [bp-1B8h]
  int v1016; // [sp+3E8h] [bp-1B4h]
  int v1017; // [sp+3ECh] [bp-1B0h]
  int v1018; // [sp+3F0h] [bp-1ACh]
  int v1019; // [sp+3F4h] [bp-1A8h]
  int v1020; // [sp+3F8h] [bp-1A4h]
  int v1021; // [sp+3FCh] [bp-1A0h]
  int v1022; // [sp+400h] [bp-19Ch]
  int v1023; // [sp+404h] [bp-198h]
  int v1024; // [sp+408h] [bp-194h]
  int v1025; // [sp+40Ch] [bp-190h]
  int v1026; // [sp+410h] [bp-18Ch]
  int v1027; // [sp+414h] [bp-188h]
  int v1028; // [sp+418h] [bp-184h]
  int v1029; // [sp+41Ch] [bp-180h]
  int v1030; // [sp+420h] [bp-17Ch]
  int v1031; // [sp+424h] [bp-178h]
  int v1032; // [sp+428h] [bp-174h]
  int v1033; // [sp+42Ch] [bp-170h]
  int v1034; // [sp+430h] [bp-16Ch]
  int v1035; // [sp+434h] [bp-168h]
  int v1036; // [sp+438h] [bp-164h]
  int v1037; // [sp+43Ch] [bp-160h]
  int v1038; // [sp+440h] [bp-15Ch]
  int v1039; // [sp+444h] [bp-158h]
  int v1040; // [sp+448h] [bp-154h]
  int v1041; // [sp+44Ch] [bp-150h]
  int v1042; // [sp+450h] [bp-14Ch]
  int v1043; // [sp+454h] [bp-148h]
  int v1044; // [sp+458h] [bp-144h]
  int v1045; // [sp+45Ch] [bp-140h]
  int v1046; // [sp+460h] [bp-13Ch]
  int v1047; // [sp+464h] [bp-138h]
  int v1048; // [sp+468h] [bp-134h]
  int v1049; // [sp+46Ch] [bp-130h]
  int v1050; // [sp+470h] [bp-12Ch]
  int v1051; // [sp+474h] [bp-128h]
  int v1052; // [sp+478h] [bp-124h]
  int v1053; // [sp+47Ch] [bp-120h]
  int v1054; // [sp+480h] [bp-11Ch]
  int v1055; // [sp+484h] [bp-118h]
  int v1056; // [sp+488h] [bp-114h]
  int v1057; // [sp+48Ch] [bp-110h]
  int v1058; // [sp+490h] [bp-10Ch]
  int v1059; // [sp+494h] [bp-108h]
  int v1060; // [sp+498h] [bp-104h] BYREF
  int v1061; // [sp+49Ch] [bp-100h]
  int v1062; // [sp+4A0h] [bp-FCh]
  int v1063; // [sp+4A4h] [bp-F8h]
  int v1064; // [sp+4A8h] [bp-F4h]
  int v1065; // [sp+4ACh] [bp-F0h]
  int v1066; // [sp+4B0h] [bp-ECh]
  int v1067; // [sp+4B4h] [bp-E8h]
  int v1068; // [sp+4B8h] [bp-E4h]
  int v1069; // [sp+4BCh] [bp-E0h]
  int v1070; // [sp+4C0h] [bp-DCh]
  int v1071; // [sp+4C4h] [bp-D8h]
  int v1072; // [sp+4C8h] [bp-D4h]
  int v1073; // [sp+4CCh] [bp-D0h]
  int v1074; // [sp+4D0h] [bp-CCh]
  int v1075; // [sp+4D4h] [bp-C8h]
  int v1076; // [sp+4D8h] [bp-C4h]
  int v1077; // [sp+4DCh] [bp-C0h]
  int v1078; // [sp+4E0h] [bp-BCh]
  int v1079; // [sp+4E4h] [bp-B8h]
  int v1080; // [sp+4E8h] [bp-B4h]
  int v1081; // [sp+4ECh] [bp-B0h]
  int v1082; // [sp+4F0h] [bp-ACh]
  int v1083; // [sp+4F4h] [bp-A8h]
  int v1084; // [sp+4F8h] [bp-A4h]
  int v1085; // [sp+4FCh] [bp-A0h]
  int v1086; // [sp+500h] [bp-9Ch]
  int v1087; // [sp+504h] [bp-98h]
  int v1088; // [sp+508h] [bp-94h]
  int v1089; // [sp+50Ch] [bp-90h]
  int v1090; // [sp+510h] [bp-8Ch]
  int v1091; // [sp+514h] [bp-88h]
  int v1092; // [sp+518h] [bp-84h]
  int v1093; // [sp+51Ch] [bp-80h]
  int v1094; // [sp+520h] [bp-7Ch]
  int v1095; // [sp+524h] [bp-78h]
  int v1096; // [sp+528h] [bp-74h]
  int v1097; // [sp+52Ch] [bp-70h]
  int v1098; // [sp+530h] [bp-6Ch]
  int v1099; // [sp+534h] [bp-68h]
  int v1100; // [sp+538h] [bp-64h]
  int v1101; // [sp+53Ch] [bp-60h]
  int v1102; // [sp+540h] [bp-5Ch]
  int v1103; // [sp+544h] [bp-58h]
  int v1104; // [sp+548h] [bp-54h]
  int v1105; // [sp+54Ch] [bp-50h]
  int v1106; // [sp+550h] [bp-4Ch]
  int v1107; // [sp+554h] [bp-48h]
  int v1108; // [sp+558h] [bp-44h]
  int v1109; // [sp+55Ch] [bp-40h]
  int v1110; // [sp+560h] [bp-3Ch]
  int v1111; // [sp+564h] [bp-38h]
  int v1112; // [sp+568h] [bp-34h]
  int v1113; // [sp+56Ch] [bp-30h]
  int v1114; // [sp+570h] [bp-2Ch]
  int v1115; // [sp+574h] [bp-28h]
  int v1116; // [sp+578h] [bp-24h]
  int v1117; // [sp+57Ch] [bp-20h]
  int v1118; // [sp+580h] [bp-1Ch]
  int v1119; // [sp+584h] [bp-18h]
  int v1120; // [sp+588h] [bp-14h]
  int v1121; // [sp+58Ch] [bp-10h]
  int v1122; // [sp+590h] [bp-Ch]
  _DWORD v1123[2]; // [sp+594h] [bp-8h] BYREF

  sub_D2BFC((unsigned __int8 *)a1, &v868);
  sub_D2BFC((unsigned __int8 *)(a1 + 2), &v932);
  v4 = &v868;
  v5 = &unk_F4348;
  v6 = 226;
  v7 = 46;
  v8 = v868 - v932;
  v868 += v932;
  v9 = &unk_F4348;
  v932 = v8;
  v10 = 139;
  while ( 1 )
  {
    v9 += 8;
    v14 = v4[1];
    v15 = v4[3];
    v16 = v4[2];
    v17 = (unsigned __int16)(*((_WORD *)v4 + 130) * v10) + ((v4[65] * v10) >> 16);
    v18 = (unsigned __int16)(*((_WORD *)v4 + 132) * v7) + ((v4[66] * v7) >> 16);
    v19 = (unsigned __int16)(*((_WORD *)v4 + 134) * v6) + ((v4[67] * v6) >> 16);
    v4[1] = v14 + v17;
    v4[65] = v14 - v17;
    v4[2] = v16 + v18;
    v4[66] = v16 - v18;
    v4[3] = v15 + v19;
    v4[67] = v15 - v19;
    if ( &v928 == v4 )
      break;
    v11 = v4[68];
    v4 += 4;
    v10 = *(v9 - 6);
    v7 = *(v9 - 4);
    v6 = *(v9 - 2);
    v12 = (unsigned __int16)(v11 * *((_WORD *)v9 - 16)) + ((v11 * *(v9 - 8)) >> 16);
    v13 = *v4 - v12;
    *v4 += v12;
    v4[64] = v13;
  }
  v20 = 226;
  sub_D2BFC((unsigned __int8 *)(a1 + 1), &v996);
  sub_D2BFC((unsigned __int8 *)(a1 + 3), &v1060);
  v21 = &v868;
  v22 = v996 + v1060;
  v1060 = v996 - v1060;
  v996 = v22;
  v23 = 139;
  v24 = 46;
  while ( 1 )
  {
    v28 = v21[194];
    v21 += 4;
    v5 += 8;
    v29 = v21[125];
    v30 = v28 * v24;
    v31 = v21[126];
    v32 = v21[127];
    v33 = (unsigned __int16)v30 + (v30 >> 16);
    v34 = (unsigned __int16)(*((_WORD *)v21 + 378) * v23) + ((v21[189] * v23) >> 16);
    v35 = (unsigned __int16)(*((_WORD *)v21 + 382) * v20) + ((v21[191] * v20) >> 16);
    v21[125] = v29 + v34;
    v21[189] = v29 - v34;
    v21[126] = v31 + v33;
    v21[190] = v31 - v33;
    v21[127] = v32 + v35;
    v21[191] = v32 - v35;
    if ( &v932 == v21 )
      break;
    v25 = v21[128];
    v23 = *(v5 - 6);
    v24 = *(v5 - 4);
    v26 = v21[192] * *(v5 - 8);
    v20 = *(v5 - 2);
    v27 = (unsigned __int16)v26 + (v26 >> 16);
    v21[128] = v25 + v27;
    v21[192] = v25 - v27;
  }
  v36 = &v868;
  v37 = &unk_F4338;
  v38 = 45;
  v39 = v868 + v996;
  v996 = v868 - v996;
  v868 = v39;
  v40 = 41;
  v41 = 139;
  while ( 1 )
  {
    v37 += 4;
    v45 = v36[1];
    v46 = v36[2];
    v47 = v36[3];
    v48 = (unsigned __int16)(*((_WORD *)v36 + 260) * v41) + ((v36[130] * v41) >> 16);
    v49 = (unsigned __int16)(*((_WORD *)v36 + 258) * v40) + ((v36[129] * v40) >> 16);
    v50 = (unsigned __int16)(*((_WORD *)v36 + 262) * v38) + ((v36[131] * v38) >> 16);
    v36[1] = v45 + v49;
    v36[129] = v45 - v49;
    v36[2] = v46 + v48;
    v36[130] = v46 - v48;
    v36[3] = v47 + v50;
    v36[131] = v47 - v50;
    if ( &v992 == v36 )
      break;
    v42 = v36[132];
    v36 += 4;
    v40 = *(v37 - 3);
    v41 = *(v37 - 2);
    v38 = *(v37 - 1);
    v43 = (unsigned __int16)(v42 * *((_WORD *)v37 - 8)) + ((v42 * *(v37 - 4)) >> 16);
    v44 = *v36 - v43;
    *v36 += v43;
    v36[128] = v44;
  }
  if ( a2 )
  {
    v365 = (unsigned __int16 *)&unk_F4B28;
    v366 = &v867;
    for ( i = 2; ; i = v368 )
    {
      v369 = v366[1];
      ++v366;
      v370 = (unsigned __int16)(i + v369) + ((i + v369) >> 16);
      v371 = (unsigned __int8)(v370 - BYTE1(v370)) - (((unsigned __int8)v370 - (v370 >> 8)) >> 8);
      if ( v371 > 128 )
        v371 -= 257;
      *v366 = v371;
      if ( v1123 == v366 )
        break;
      v368 = v365[1];
      ++v365;
    }
  }
  else
  {
    v51 = &v867;
    v52 = (unsigned __int16 *)&unk_F4928;
    for ( j = 1; ; j = v54 )
    {
      v55 = v51[1];
      ++v51;
      v56 = (unsigned __int16)(j + v55) + ((j + v55) >> 16);
      v57 = (unsigned __int8)(v56 - BYTE1(v56)) - (((unsigned __int8)v56 - (v56 >> 8)) >> 8);
      if ( v57 > 128 )
        v57 -= 257;
      *v51 = v57;
      if ( v1123 == v51 )
        break;
      v54 = v52[1];
      ++v52;
    }
  }
  v814 = *(_DWORD *)(a1 + 152);
  v815 = *(_DWORD *)(a1 + 156);
  v816 = *(_DWORD *)(a1 + 160);
  v817 = *(_DWORD *)(a1 + 164);
  v818 = *(_DWORD *)(a1 + 168);
  v819 = *(_DWORD *)(a1 + 172);
  v820 = *(_DWORD *)(a1 + 176);
  v822 = *(_DWORD *)(a1 + 184);
  v823 = *(_DWORD *)(a1 + 188);
  v824 = *(_DWORD *)(a1 + 192);
  v825 = *(_DWORD *)(a1 + 196);
  v826 = *(_DWORD *)(a1 + 200);
  v821 = *(_DWORD *)(a1 + 180);
  v828 = *(_DWORD *)(a1 + 208);
  v827 = *(_DWORD *)(a1 + 204);
  v829 = *(_DWORD *)(a1 + 212);
  v830 = *(_DWORD *)(a1 + 216);
  v833 = *(_DWORD *)(a1 + 228);
  v832 = *(_DWORD *)(a1 + 224);
  v831 = *(_DWORD *)(a1 + 220);
  v834 = *(_DWORD *)(a1 + 232);
  v835 = *(_DWORD *)(a1 + 236);
  v838 = *(_DWORD *)(a1 + 248);
  v837 = *(_DWORD *)(a1 + 244);
  v836 = *(_DWORD *)(a1 + 240);
  v839 = *(_DWORD *)(a1 + 252);
  v840 = *(_DWORD *)(a1 + 256);
  v841 = *(_DWORD *)(a1 + 132);
  v842 = *(_DWORD *)(a1 + 136);
  v843 = *(_DWORD *)(a1 + 140);
  v387 = v842 ^ *(_DWORD *)(a1 + 4);
  v400 = v843 ^ *(_DWORD *)(a1 + 8);
  v844 = *(_DWORD *)(a1 + 144);
  v372 = v841 ^ *(_DWORD *)a1;
  v415 = v844 ^ *(_DWORD *)(a1 + 12);
  v428 = *(_DWORD *)(a1 + 148) ^ *(_DWORD *)(a1 + 16);
  v463 = v816 ^ *(_DWORD *)(a1 + 28);
  v845 = *(_DWORD *)(a1 + 148);
  v576 = v818 ^ *(_DWORD *)(a1 + 36);
  v440 = v814 ^ *(_DWORD *)(a1 + 20);
  v452 = v815 ^ *(_DWORD *)(a1 + 24);
  v565 = v817 ^ *(_DWORD *)(a1 + 32);
  v587 = v820 ^ *(_DWORD *)(a1 + 44);
  v598 = v821 ^ *(_DWORD *)(a1 + 48);
  v610 = v822 ^ *(_DWORD *)(a1 + 52);
  v58 = *(_DWORD *)(a1 + 76);
  v639 = v824 ^ *(_DWORD *)(a1 + 60);
  v624 = v823 ^ *(_DWORD *)(a1 + 56);
  v677 = v830 ^ *(_DWORD *)(a1 + 84);
  v663 = v829 ^ *(_DWORD *)(a1 + 80);
  v509 = v831 ^ *(_DWORD *)(a1 + 88);
  v689 = v832 ^ *(_DWORD *)(a1 + 92);
  v522 = v826 ^ *(_DWORD *)(a1 + 68);
  v476 = v825 ^ *(_DWORD *)(a1 + 64);
  v651 = v819 ^ *(_DWORD *)(a1 + 40);
  v702 = v827 ^ *(_DWORD *)(a1 + 72);
  v59 = (v576 ^ v522) & v387;
  v60 = (v651 ^ v702) & v400;
  v846 = (v624 ^ v509) & v452;
  v61 = (v639 ^ v689) & v463;
  v713 = (v587 ^ v828 ^ v58) & v415;
  v62 = (v598 ^ v663) & v428;
  v772 = (v610 ^ v677) & v440;
  v63 = (unsigned __int16)(185 * v932) + 12124160 * v933 + (v833 ^ *(_DWORD *)(a1 + 96)) + ((v565 ^ v476) & v372 ^ v476);
  v373 = __ROR4__(v372, 29);
  v388 = __ROR4__(v387, 29);
  v401 = __ROR4__(v400, 29);
  v453 = __ROR4__(v452, 29);
  v464 = __ROR4__(v463, 29);
  v416 = __ROR4__(v415, 29);
  v429 = __ROR4__(v428, 29);
  v441 = __ROR4__(v440, 29);
  v498 = v373
       + __ROR4__((unsigned __int16)(185 * v934) + 12124160 * v935 + (v834 ^ *(_DWORD *)(a1 + 100)) + (v59 ^ v522), 9);
  v487 = v388 + __ROR4__(v63, 9);
  v64 = v464
      + __ROR4__((unsigned __int16)(185 * v944) + 12124160 * v945 + (v839 ^ *(_DWORD *)(a1 + 120)) + (v846 ^ v509), 9);
  v736 = v453
       + __ROR4__((unsigned __int16)(185 * v946) + 12124160 * v947 + (v840 ^ *(_DWORD *)(a1 + 124)) + (v61 ^ v689), 9);
  v554 = v416
       + __ROR4__((unsigned __int16)(185 * v936) + 12124160 * v937 + (v835 ^ *(_DWORD *)(a1 + 104)) + (v60 ^ v702), 9);
  v65 = v401
      + __ROR4__(
          (unsigned __int16)(185 * v938) + 12124160 * v939 + (v836 ^ *(_DWORD *)(a1 + 108)) + (v713 ^ v828 ^ v58),
          9);
  v714 = v441
       + __ROR4__((unsigned __int16)(185 * v940) + 12124160 * v941 + (v837 ^ *(_DWORD *)(a1 + 112)) + (v62 ^ v663), 9);
  v725 = v429
       + __ROR4__((unsigned __int16)(185 * v942) + 12124160 * v943 + (v838 ^ *(_DWORD *)(a1 + 116)) + (v772 ^ v677), 9);
  v66 = (v565 ^ v373) & v487;
  v67 = (v576 ^ v388) & v498;
  v68 = (v651 ^ v401) & v554;
  v69 = (v639 ^ v464) & v736;
  v70 = (v598 ^ v429) & v714;
  v545 = __ROR4__(v64, 9);
  v71 = v487;
  v748 = (unsigned __int16)(185 * v964) + 12124160 * v965 + v476;
  v488 = __ROR4__(v498, 9);
  v477 = __ROR4__(v71, 9);
  v510 = __ROR4__(v65, 9);
  v499 = __ROR4__(v554, 9);
  v555 = __ROR4__(v736, 9);
  v737 = (unsigned __int16)(185 * v966) + 12124160 * v967 + v522;
  v523 = __ROR4__(v714, 9);
  v72 = (unsigned __int16)(185 * v968) + 12124160 * v969 + v702 + (v68 ^ v651);
  v73 = (unsigned __int16)(185 * v978) + 12124160 * v979 + v689;
  v535 = __ROR4__(v725, 9);
  v690 = (unsigned __int16)(185 * v974) + 12124160 * v975 + v677;
  v74 = v545 + __ROR4__(v748 + (v66 ^ v565), 15);
  v703 = v477
       + __ROR4__(
           (unsigned __int16)(185 * v976)
         + 12124160 * v977
         + (v831 ^ *(_DWORD *)(a1 + 88))
         + ((v624 ^ v453) & v64 ^ v624),
           15);
  v715 = v488 + __ROR4__(v73 + (v69 ^ v639), 15);
  v75 = v555 + __ROR4__(v737 + (v67 ^ v576), 15);
  v76 = v523 + __ROR4__(v72, 15);
  v678 = v499 + __ROR4__((unsigned __int16)(185 * v972) + 12124160 * v973 + v663 + (v70 ^ v598), 15);
  v664 = v535
       + __ROR4__((unsigned __int16)(185 * v970) + 12124160 * v971 + (v828 ^ v58) + ((v587 ^ v416) & v65 ^ v587), 15);
  v691 = v510 + __ROR4__(v690 + ((v610 ^ v441) & v725 ^ v610), 15);
  v758 = __ROR4__(v75, 15);
  v749 = __ROR4__(v74, 15);
  v773 = __ROR4__(v76, 15);
  v782 = __ROR4__(v664, 15);
  v801 = __ROR4__(v703, 15);
  v790 = __ROR4__(v678, 15);
  v796 = __ROR4__(v691, 15);
  v805 = __ROR4__(v715, 15);
  v77 = (unsigned __int16)(185 * v878) + 12124160 * v879 + v610 + ((v441 ^ v535) & v691 ^ v441);
  v78 = (unsigned __int16)(185 * v882) + 12124160 * v883 + v639 + ((v464 ^ v555) & v715 ^ v464);
  v79 = v773 + __ROR4__((unsigned __int16)(185 * v868) + 12124160 * v869 + v565 + ((v373 ^ v477) & v74 ^ v373), 5);
  v80 = v749 + __ROR4__((unsigned __int16)(185 * v872) + 12124160 * v873 + v651 + ((v401 ^ v499) & v76 ^ v401), 5);
  v611 = v782 + __ROR4__((unsigned __int16)(185 * v870) + 12124160 * v871 + v576 + ((v388 ^ v488) & v75 ^ v388), 5);
  v81 = v758 + __ROR4__((unsigned __int16)(185 * v874) + 12124160 * v875 + v587 + ((v416 ^ v510) & v664 ^ v416), 5);
  v640 = v790 + __ROR4__((unsigned __int16)(185 * v880) + 12124160 * v881 + v624 + ((v453 ^ v545) & v703 ^ v453), 5);
  v625 = v805 + __ROR4__(v77, 5);
  v652 = v801 + __ROR4__((unsigned __int16)(185 * v876) + 12124160 * v877 + v598 + ((v429 ^ v523) & v678 ^ v429), 5);
  v665 = v796 + __ROR4__(v78, 5);
  v588 = __ROR4__(v80, 5);
  v577 = __ROR4__(v611, 5);
  v599 = __ROR4__(v81, 5);
  v566 = __ROR4__(v79, 5);
  v82 = v611 & (v488 ^ v758);
  v83 = (v545 ^ v801) & v640;
  v84 = (v499 ^ v773) & v80 ^ v499;
  v641 = __ROR4__(v640, 5);
  v85 = (v535 ^ v796) & v625 ^ v535;
  v626 = __ROR4__(v625, 5);
  v86 = v373;
  v374 = v85;
  v87 = (unsigned __int16)(185 * v908) + 12124160 * v909 + v429 + ((v523 ^ v790) & v652 ^ v523);
  v612 = __ROR4__(v652, 5);
  v653 = __ROR4__(v665, 5);
  v88 = v566 + __ROR4__((unsigned __int16)(185 * v906) + 12124160 * v907 + v416 + (v81 & (v510 ^ v782) ^ v510), 29);
  v89 = v599 + __ROR4__((unsigned __int16)(185 * v900) + 12124160 * v901 + v86 + (v79 & (v477 ^ v749) ^ v477), 29);
  v90 = v641 + __ROR4__((unsigned __int16)(185 * v910) + 12124160 * v911 + v441 + v374, 29);
  v91 = v577 + __ROR4__((unsigned __int16)(185 * v904) + 12124160 * v905 + v401 + v84, 29);
  v92 = v588 + __ROR4__((unsigned __int16)(185 * v902) + 12124160 * v903 + v388 + (v82 ^ v488), 29);
  v402 = v626 + __ROR4__((unsigned __int16)(185 * v912) + 12124160 * v913 + v453 + (v83 ^ v545), 29);
  v375 = v653 + __ROR4__(v87, 29);
  v93 = v612 + __ROR4__((unsigned __int16)(185 * v914) + 12124160 * v915 + v464 + ((v555 ^ v805) & v665 ^ v555), 29);
  v809 = __ROR4__(v91, 29);
  v679 = __ROR4__(v92, 29);
  v692 = __ROR4__(v88, 29);
  v666 = __ROR4__(v89, 29);
  v716 = __ROR4__(v90, 29);
  v726 = __ROR4__(v402, 29);
  v704 = __ROR4__(v375, 29);
  v738 = __ROR4__(v93, 29);
  v94 = v809 + __ROR4__((unsigned __int16)(185 * v994) + 12124160 * v995 + v555 + ((v653 | v93) & v805 | v653 & v93), 9);
  v95 = v716 + __ROR4__((unsigned __int16)(185 * v980) + 12124160 * v981 + v477 + ((v566 | v89) & v749 | v89 & v566), 9);
  v417 = v666
       + __ROR4__((unsigned __int16)(185 * v990) + 12124160 * v991 + v535 + ((v626 | v90) & v796 | v626 & v90), 9);
  v430 = v692
       + __ROR4__((unsigned __int16)(185 * v992) + 12124160 * v993 + v545 + ((v641 | v402) & v801 | v402 & v641), 9);
  v389 = v726
       + __ROR4__((unsigned __int16)(185 * v986) + 12124160 * v987 + v510 + ((v599 | v88) & v782 | v88 & v599), 9);
  v403 = v679
       + __ROR4__((unsigned __int16)(185 * v988) + 12124160 * v989 + v523 + ((v612 | v375) & v790 | v612 & v375), 9);
  v96 = v704 + __ROR4__((unsigned __int16)(185 * v982) + 12124160 * v983 + v488 + ((v577 | v92) & v758 | v92 & v577), 9);
  v376 = v738
       + __ROR4__((unsigned __int16)(185 * v984) + 12124160 * v985 + v499 + ((v588 | v91) & v773 | v91 & v588), 9);
  v865 = v738 & v94;
  v864 = (v738 | v94) & v653;
  v546 = __ROR4__(v94, 9);
  v478 = __ROR4__(v96, 9);
  v489 = __ROR4__(v376, 9);
  v500 = __ROR4__(v389, 9);
  v511 = __ROR4__(v403, 9);
  v524 = __ROR4__(v417, 9);
  v536 = __ROR4__(v430, 9);
  v97 = (unsigned __int16)(185 * v958) + 12124160 * v959 + v796 + ((v716 | v417) & v626 | v716 & v417);
  v98 = v546
      + __ROR4__((unsigned __int16)(185 * v948) + 12124160 * v949 + v749 + ((v666 | v95) & v566 | v666 & v95), 15);
  v99 = (unsigned __int16)(185 * v950) + 12124160 * v951 + v758 + ((v679 | v96) & v577 | v679 & v96);
  v404 = v500
       + __ROR4__((unsigned __int16)(185 * v956) + 12124160 * v957 + v790 + ((v704 | v403) & v612 | v704 & v403), 15);
  v418 = v511
       + __ROR4__((unsigned __int16)(185 * v954) + 12124160 * v955 + v782 + ((v692 | v389) & v599 | v692 & v389), 15);
  v442 = v489 + __ROR4__(v97, 15);
  v100 = __ROR4__(v95, 9);
  v454 = v478
       + __ROR4__((unsigned __int16)(185 * v960) + 12124160 * v961 + v801 + ((v726 | v430) & v641 | v726 & v430), 15);
  v101 = v524
       + __ROR4__((unsigned __int16)(185 * v952) + 12124160 * v953 + v773 + ((v809 | v376) & v588 | v809 & v376), 15);
  v465 = v100 + __ROR4__((unsigned __int16)(185 * v962) + 12124160 * v963 + v805 + (v864 | v865), 15);
  v390 = v536 + __ROR4__(v99, 15);
  v750 = v100;
  v102 = v478 | v390;
  v774 = v478 & v390;
  v802 = v500 & v418;
  v103 = (v500 | v418) & v692;
  v847 = v511 & v404;
  v104 = (v511 | v404) & v704;
  v857 = v536 & v454;
  v105 = (v536 | v454) & v726;
  v106 = v546 & v465;
  v860 = (v546 | v465) & v738;
  v852 = v524 & v442;
  v107 = (v524 | v442) & v716;
  v556 = (unsigned __int16)(185 * v916) + 12124160 * v917 + v566;
  v567 = (v100 | v98) & v666 | v100 & v98;
  v108 = v404;
  v405 = __ROR4__(v101, 15);
  v377 = __ROR4__(v98, 15);
  v391 = __ROR4__(v390, 15);
  v431 = __ROR4__(v108, 15);
  v419 = __ROR4__(v418, 15);
  v443 = __ROR4__(v442, 15);
  v455 = __ROR4__(v454, 15);
  v109 = v102 & v679 | v774;
  v466 = __ROR4__(v465, 15);
  v110 = v431 + __ROR4__(v567 + v556, 5);
  v111 = (unsigned __int16)(185 * v922) + 12124160 * v923 + v599 + (v103 | v802);
  v112 = (unsigned __int16)(185 * v926) + 12124160 * v927 + v626 + (v107 | v852);
  v113 = v443 + __ROR4__((unsigned __int16)(185 * v918) + 12124160 * v919 + v577 + v109, 5);
  v600 = v377 + __ROR4__((unsigned __int16)(185 * v924) + 12124160 * v925 + v612 + (v104 | v847), 5);
  v627 = v405 + __ROR4__((unsigned __int16)(185 * v928) + 12124160 * v929 + v641 + (v105 | v857), 5);
  v114 = v419 + __ROR4__((unsigned __int16)(185 * v930) + 12124160 * v931 + v653 + (v860 | v106), 5);
  v578 = v455
       + __ROR4__((unsigned __int16)(185 * v920) + 12124160 * v921 + v588 + ((v489 | v101) & v809 | v489 & v101), 5);
  v589 = v466 + __ROR4__(v111, 5);
  v613 = v391 + __ROR4__(v112, 5);
  v557 = __ROR4__(v110, 5);
  v568 = __ROR4__(v113, 5);
  v115 = (v455 | v627) & v536 | v455 & v627;
  v116 = v431 & v600;
  v853 = (v431 | v600) & v511;
  v856 = v443 & v613;
  v117 = (v443 | v613) & v524;
  v848 = v419 & v589;
  v118 = (v419 | v589) & v500;
  v628 = __ROR4__(v627, 5);
  v642 = __ROR4__(v114, 5);
  v601 = __ROR4__(v600, 5);
  v614 = __ROR4__(v613, 5);
  v119 = (unsigned __int16)(185 * v888) + 12124160 * v889 + v809 + ((v405 | v578) & v489 | v405 & v578);
  v579 = __ROR4__(v578, 5);
  v590 = __ROR4__(v589, 5);
  v120 = (unsigned __int16)(185 * v890) + 12124160 * v891 + v692 + (v118 | v848);
  v121 = v568
       + __ROR4__((unsigned __int16)(185 * v884) + 12124160 * v885 + v666 + ((v377 | v110) & v750 | v110 & v377), 29);
  v122 = v642 + __ROR4__((unsigned __int16)(185 * v896) + 12124160 * v897 + v726 + v115, 29);
  v693 = v557
       + __ROR4__((unsigned __int16)(185 * v886) + 12124160 * v887 + v679 + ((v391 | v113) & v478 | v113 & v391), 29);
  v123 = v614 + __ROR4__((unsigned __int16)(185 * v892) + 12124160 * v893 + v704 + (v853 | v116), 29);
  v667 = v590 + __ROR4__(v119, 29);
  v124 = v628
       + __ROR4__((unsigned __int16)(185 * v898) + 12124160 * v899 + v738 + ((v466 | v114) & v546 | v466 & v114), 29);
  v739 = v601 + __ROR4__((unsigned __int16)(185 * v894) + 12124160 * v895 + v716 + (v117 | v856), 29);
  v727 = v579 + __ROR4__(v120, 29);
  v125 = (v431 ^ v601) & v123;
  v126 = (v377 ^ v557) & v121;
  v127 = (v391 ^ v568) & v693;
  v654 = __ROR4__(v121, 4);
  v705 = __ROR4__(v122, 4);
  v717 = __ROR4__(v124, 4);
  v680 = __ROR4__(v123, 4);
  v849 = (v455 ^ v628) & v122 ^ v455;
  v810 = (unsigned __int16)(185 * v1120) + 12124160 * v1121 + v536;
  v791 = (v405 ^ v579) & v667 ^ v405;
  v668 = __ROR4__(v667, 4);
  v537 = __ROR4__(v693, 4);
  v128 = (unsigned __int16)(185 * v1112) + 12124160 * v1113 + v489;
  v694 = __ROR4__(v739, 4);
  v490 = __ROR4__(v727, 4);
  v129 = (unsigned __int16)(185 * v1110) + 12124160 * v1111 + v478;
  v130 = (unsigned __int16)(185 * v1114) + 12124160 * v1115 + v500 + ((v419 ^ v590) & v727 ^ v419);
  v131 = (unsigned __int16)(185 * v1118) + 12124160 * v1119 + v524 + ((v443 ^ v614) & v739 ^ v443);
  v132 = (unsigned __int16)(185 * v1122) + 12124160 * v1123[0] + v546 + ((v466 ^ v642) & v124 ^ v466);
  v133 = (unsigned __int16)(185 * v1116) + 12124160 * v1117 + v511 + (v125 ^ v431);
  v479 = v705 + __ROR4__((unsigned __int16)(185 * v1108) + 12124160 * v1109 + v750 + (v126 ^ v377), 13);
  v501 = v654 + __ROR4__(v810 + v849, 13);
  v134 = v717 + __ROR4__(v129 + (v127 ^ v391), 13);
  v512 = v680 + __ROR4__(v128 + v791, 13);
  v525 = v694 + __ROR4__(v130, 13);
  v135 = v668 + __ROR4__(v133, 13);
  v547 = v490 + __ROR4__(v131, 13);
  v728 = v537 + __ROR4__(v132, 13);
  v136 = (v568 ^ v537) & v134;
  v137 = (v628 ^ v705) & v501;
  v740 = (unsigned __int16)(185 * v1044) + 12124160 * v1045 + v377;
  v138 = (v557 ^ v654) & v479 ^ v557;
  v378 = __ROR4__(v479, 13);
  v792 = (unsigned __int16)(185 * v1056) + 12124160 * v1057 + v455;
  v502 = __ROR4__(v501, 13);
  v456 = __ROR4__(v512, 13);
  v139 = v405;
  v406 = __ROR4__(v134, 13);
  v480 = __ROR4__(v525, 13);
  v140 = (unsigned __int16)(185 * v1050) + 12124160 * v1051 + v419;
  v141 = v391;
  v392 = __ROR4__(v135, 13);
  v142 = (unsigned __int16)(185 * v1046) + 12124160 * v1047 + v141 + (v136 ^ v568);
  v751 = (unsigned __int16)(185 * v1054) + 12124160 * v1055 + v443;
  v444 = __ROR4__(v728, 13);
  v420 = __ROR4__(v547, 13);
  v143 = (unsigned __int16)(185 * v1052) + 12124160 * v1053 + v431 + ((v601 ^ v680) & v135 ^ v601);
  v144 = (unsigned __int16)(185 * v1058) + 12124160 * v1059 + v466 + ((v642 ^ v717) & v728 ^ v642);
  v432 = v456 + __ROR4__(v740 + v138, 10);
  v145 = v406 + __ROR4__(v140 + ((v590 ^ v490) & v525 ^ v590), 10);
  v513 = v378 + __ROR4__((unsigned __int16)(185 * v1048) + 12124160 * v1049 + v139 + ((v579 ^ v668) & v512 ^ v579), 10);
  v467 = v480 + __ROR4__(v142, 10);
  v526 = v444 + __ROR4__(v751 + ((v614 ^ v694) & v547 ^ v614), 10);
  v146 = v392 + __ROR4__(v792 + (v137 ^ v628), 10);
  v147 = v502 + __ROR4__(v143, 10);
  v148 = v420 + __ROR4__(v144, 10);
  v752 = __ROR4__(v145, 10);
  v783 = __ROR4__(v146, 10);
  v729 = __ROR4__(v432, 10);
  v149 = (unsigned __int16)(185 * v1066) + 12124160 * v1067 + v590;
  v775 = __ROR4__(v526, 10);
  v793 = __ROR4__(v148, 10);
  v741 = __ROR4__(v513, 10);
  v591 = __ROR4__(v467, 10);
  v759 = __ROR4__(v147, 10);
  v150 = (unsigned __int16)(185 * v1068) + 12124160 * v1069 + v601 + ((v680 ^ v392) & v147 ^ v680);
  v151 = v752 + __ROR4__((unsigned __int16)(185 * v1060) + 12124160 * v1061 + v557 + ((v654 ^ v378) & v432 ^ v654), 25);
  v514 = v591 + __ROR4__((unsigned __int16)(185 * v1064) + 12124160 * v1065 + v579 + ((v668 ^ v456) & v513 ^ v668), 25);
  v152 = v759 + __ROR4__((unsigned __int16)(185 * v1074) + 12124160 * v1075 + v642 + ((v717 ^ v444) & v148 ^ v717), 25);
  v153 = v729 + __ROR4__(v149 + ((v490 ^ v480) & v145 ^ v490), 25);
  v154 = v783 + __ROR4__((unsigned __int16)(185 * v1070) + 12124160 * v1071 + v614 + ((v694 ^ v420) & v526 ^ v694), 25);
  v155 = v775 + __ROR4__((unsigned __int16)(185 * v1072) + 12124160 * v1073 + v628 + ((v705 ^ v502) & v146 ^ v705), 25);
  v468 = v741 + __ROR4__((unsigned __int16)(185 * v1062) + 12124160 * v1063 + v568 + ((v537 ^ v406) & v467 ^ v537), 25);
  v156 = v793 + __ROR4__(v150, 25);
  v157 = (v420 ^ v775) & v154;
  v433 = __ROR4__(v151, 25);
  v548 = __ROR4__(v154, 25);
  v158 = (v480 ^ v752) & v153;
  v527 = __ROR4__(v153, 25);
  v558 = __ROR4__(v155, 25);
  v159 = (v456 ^ v741) & v514;
  v160 = (v406 ^ v591) & v468;
  v161 = v490;
  v491 = __ROR4__(v156, 25);
  v515 = __ROR4__(v514, 25);
  v569 = __ROR4__(v152, 25);
  v469 = __ROR4__(v468, 25);
  v162 = (unsigned __int16)(185 * v998) + 12124160 * v999 + v537;
  v538 = v548 + __ROR4__((unsigned __int16)(185 * v996) + 12124160 * v997 + v654 + (v151 & (v378 ^ v729) ^ v378), 4);
  v629 = v433 + __ROR4__((unsigned __int16)(185 * v1006) + 12124160 * v1007 + v694 + (v157 ^ v420), 4);
  v643 = v527 + __ROR4__((unsigned __int16)(185 * v1008) + 12124160 * v1009 + v705 + ((v502 ^ v783) & v155 ^ v502), 4);
  v602 = v558 + __ROR4__((unsigned __int16)(185 * v1002) + 12124160 * v1003 + v161 + (v158 ^ v480), 4);
  v580 = v515 + __ROR4__((unsigned __int16)(185 * v1010) + 12124160 * v1011 + v717 + ((v444 ^ v793) & v152 ^ v444), 4);
  v163 = v569 + __ROR4__((unsigned __int16)(185 * v1000) + 12124160 * v1001 + v668 + (v159 ^ v456), 4);
  v615 = v469 + __ROR4__((unsigned __int16)(185 * v1004) + 12124160 * v1005 + v680 + ((v392 ^ v759) & v156 ^ v392), 4);
  v164 = v491 + __ROR4__(v162 + (v160 ^ v406), 4);
  v165 = (v569 | v580) & v793;
  v655 = (unsigned __int16)(185 * v1012) + 12124160 * v1013 + v378;
  v166 = (v433 | v538) & v729 | v433 & v538;
  v379 = __ROR4__(v538, 4);
  v669 = (unsigned __int16)(185 * v1014) + 12124160 * v1015 + v406;
  v681 = (unsigned __int16)(185 * v1016) + 12124160 * v1017 + v456;
  v706 = (unsigned __int16)(185 * v1018) + 12124160 * v1019 + v480;
  v407 = __ROR4__(v164, 4);
  v806 = (unsigned __int16)(185 * v1022) + 12124160 * v1023 + v420;
  v167 = v569 & v580;
  v581 = __ROR4__(v580, 4);
  v421 = __ROR4__(v163, 4);
  v457 = __ROR4__(v602, 4);
  v811 = (unsigned __int16)(185 * v1024) + 12124160 * v1025 + v502;
  v168 = (v515 | v163) & v741 | v515 & v163;
  v481 = __ROR4__(v615, 4);
  v503 = __ROR4__(v629, 4);
  v539 = __ROR4__(v643, 4);
  v169 = v811 + ((v558 | v643) & v783 | v558 & v643);
  v170 = (unsigned __int16)(185 * v1026) + 12124160 * v1027 + v444 + (v165 | v167);
  v171 = v581 + __ROR4__(v655 + v166, 13);
  v644 = v457
       + __ROR4__((unsigned __int16)(185 * v1020) + 12124160 * v1021 + v392 + ((v491 | v615) & v759 | v491 & v615), 13);
  v603 = v481 + __ROR4__(v706 + ((v527 | v602) & v752 | v527 & v602), 13);
  v616 = v421 + __ROR4__(v806 + ((v548 | v629) & v775 | v548 & v629), 13);
  v445 = v503 + __ROR4__(v681 + v168, 13);
  v393 = v407 + __ROR4__(v169, 13);
  v682 = v379 + __ROR4__(v170, 13);
  v172 = v539 + __ROR4__(v669 + ((v469 | v164) & v591 | v469 & v164), 13);
  v630 = __ROR4__(v171, 13);
  v173 = __ROR4__(v644, 13);
  v174 = v173
       + __ROR4__((unsigned __int16)(185 * v1076) + 12124160 * v1077 + v729 + ((v379 | v171) & v433 | v379 & v171), 10);
  v656 = v173;
  v760 = v630
       + __ROR4__((unsigned __int16)(185 * v1084) + 12124160 * v1085 + v759 + ((v481 | v644) & v491 | v644 & v481), 10);
  v175 = (unsigned __int16)(185 * v1028) + 12124160 * v1029 + v433;
  v434 = __ROR4__(v172, 13);
  v176 = v175 + ((v630 | v174) & v379 | v630 & v174);
  v695 = __ROR4__(v174, 10);
  v177 = (unsigned __int16)(185 * v1078) + 12124160 * v1079 + v591 + ((v407 | v172) & v469 | v407 & v172);
  v178 = (v421 | v445) & v515 | v421 & v445;
  v446 = __ROR4__(v445, 13);
  v179 = (unsigned __int16)(185 * v1080) + 12124160 * v1081 + v741 + v178;
  v592 = __ROR4__(v603, 13);
  v180 = (v457 | v603) & v527 | v457 & v603;
  v604 = __ROR4__(v616, 13);
  v718 = v604 + __ROR4__(v177, 10);
  v181 = (v503 | v616) & v548 | v503 & v616;
  v670 = __ROR4__(v393, 13);
  v645 = v670 + __ROR4__(v179, 10);
  v617 = __ROR4__(v682, 13);
  v730 = v434 + __ROR4__((unsigned __int16)(185 * v1086) + 12124160 * v1087 + v775 + v181, 10);
  v182 = v446
       + __ROR4__((unsigned __int16)(185 * v1088) + 12124160 * v1089 + v783 + ((v539 | v393) & v558 | v539 & v393), 10);
  v183 = __ROR4__(v718, 10);
  v742 = v592
       + __ROR4__((unsigned __int16)(185 * v1090) + 12124160 * v1091 + v793 + ((v581 | v682) & v569 | v581 & v682), 10);
  v683 = v183 + __ROR4__(v176, 25);
  v184 = __ROR4__((unsigned __int16)(185 * v1082) + 12124160 * v1083 + v752 + v180, 10);
  v185 = v630;
  v631 = v183;
  v850 = (unsigned __int16)(233 * v888) + 15269888 * v1016 + v446;
  v854 = (unsigned __int16)(233 * v890) + 15269888 * v1018 + v592;
  v186 = (unsigned __int16)(185 * v1040) + 12124160 * v1041 + v558;
  v394 = __ROR4__(v182, 10);
  v784 = (unsigned __int16)(185 * v1036) + 12124160 * v1037 + v491;
  v559 = (unsigned __int16)(185 * v1034) + 12124160 * v1035 + v527;
  v794 = (unsigned __int16)(185 * v1038) + 12124160 * v1039 + v548;
  v797 = (unsigned __int16)(185 * v1042) + 12124160 * v1043 + v569;
  v528 = __ROR4__(v742, 10);
  v776 = v528 + __ROR4__(v186 + ((v670 | v182) & v539 | v182 & v670), 25);
  v707 = __ROR4__(v776, 25);
  v187 = v707
       + __ROR4__((unsigned __int16)(185 * v1092) + 12124160 * v1093 + v379 + ((v695 | v683) & v185 | v695 & v683), 4);
  v684 = __ROR4__(v683, 25);
  v549 = __ROR4__(v187, 3);
  v859 = (unsigned __int16)(233 * v898) + 15269888 * v1026 + v617;
  v719 = v695
       + __ROR4__((unsigned __int16)(185 * v1030) + 12124160 * v1031 + v469 + ((v434 | v718) & v407 | v434 & v718), 25);
  v380 = __ROR4__(v645, 10);
  v188 = v760;
  v492 = __ROR4__(v760, 10);
  v858 = (unsigned __int16)(233 * v896) + 15269888 * v1024 + v670;
  v761 = (unsigned __int16)(233 * v884) + 15269888 * v1012 + v185 + ((v695 ^ v684) & v187 ^ v695);
  v189 = v784 + ((v656 | v188) & v481 | v656 & v188);
  v190 = __ROR4__(v617 + v184, 10);
  v191 = v190
       + __ROR4__((unsigned __int16)(185 * v1032) + 12124160 * v1033 + v515 + ((v446 | v645) & v421 | v446 & v645), 25);
  v470 = v190;
  v516 = __ROR4__(v730, 10);
  v570 = v516 + __ROR4__(v189, 25);
  v192 = v380 + __ROR4__(v559 + ((v592 | (v617 + v184)) & v457 | v592 & (v617 + v184)), 25);
  v193 = v492 + __ROR4__(v794 + ((v604 | v730) & v503 | v604 & v730), 25);
  v194 = v797 + ((v617 | v742) & v581 | v617 & v742);
  v798 = (unsigned __int16)(233 * v900) + 15269888 * v1028 + v695;
  v195 = v394 + __ROR4__(v194, 25);
  v861 = (unsigned __int16)(233 * v904) + 15269888 * v1032 + v380;
  v812 = (unsigned __int16)(233 * v902) + 15269888 * v1030 + v631;
  v196 = v446;
  v447 = __ROR4__(v191, 25);
  v696 = __ROR4__(v570, 25);
  v731 = v696
       + __ROR4__((unsigned __int16)(185 * v1096) + 12124160 * v1097 + v421 + ((v380 | v191) & v196 | v191 & v380), 4);
  v560 = __ROR4__(v731, 3);
  v862 = (unsigned __int16)(233 * v906) + 15269888 * v1034 + v470;
  v743 = (unsigned __int16)(185 * v1094) + 12124160 * v1095 + v407;
  v197 = v560 + __ROR4__(v761, 23);
  v646 = __ROR4__(v197, 23);
  v753 = (unsigned __int16)(185 * v1098) + 12124160 * v1099 + v457;
  v803 = (v684 ^ v549) & v197 ^ v684;
  v866 = (unsigned __int16)(233 * v914) + 15269888 * v1042 + v528;
  v863 = (unsigned __int16)(233 * v908) + 15269888 * v1036 + v492;
  v785 = (unsigned __int16)(233 * v910) + 15269888 * v1038 + v516;
  v408 = __ROR4__(v719, 25);
  v458 = __ROR4__(v195, 25);
  v422 = __ROR4__(v192, 25);
  v198 = (unsigned __int16)(185 * v1102) + 12124160 * v1103 + v503 + ((v516 | v193) & v604 | v516 & v193);
  v199 = __ROR4__(v193, 25);
  v200 = v199 + __ROR4__(v753 + ((v470 | v192) & v592 | v192 & v470), 4);
  v201 = v447
       + __ROR4__((unsigned __int16)(185 * v1100) + 12124160 * v1101 + v481 + ((v492 | v570) & v656 | v492 & v570), 4);
  v202 = v458 + __ROR4__(v743 + ((v631 | v719) & v434 | v631 & v719), 4);
  v203 = v408
       + __ROR4__((unsigned __int16)(185 * v1106) + 12124160 * v1107 + v581 + ((v528 | v195) & v617 | v195 & v528), 4);
  v204 = v684
       + __ROR4__((unsigned __int16)(185 * v1104) + 12124160 * v1105 + v539 + ((v394 | v776) & v670 | v394 & v776), 4);
  v482 = __ROR4__(v202, 3);
  v504 = __ROR4__(v200, 3);
  v540 = __ROR4__(v201, 3);
  v618 = v422 + __ROR4__(v198, 4);
  v571 = __ROR4__(v618, 3);
  v582 = __ROR4__(v204, 3);
  v671 = v203;
  v593 = __ROR4__(v203, 3);
  v205 = v549 + __ROR4__(v850 + ((v380 ^ v447) & v731 ^ v380), 23);
  v206 = v504 + __ROR4__((unsigned __int16)(233 * v886) + 15269888 * v1014 + v434 + (v202 & (v631 ^ v408) ^ v631), 23);
  v207 = v482 + __ROR4__(v854 + ((v470 ^ v422) & v200 ^ v470), 23);
  v208 = v582 + __ROR4__((unsigned __int16)(233 * v892) + 15269888 * v1020 + v656 + ((v492 ^ v696) & v201 ^ v492), 23);
  v632 = v593 + __ROR4__((unsigned __int16)(233 * v894) + 15269888 * v1022 + v604 + ((v516 ^ v199) & v618 ^ v516), 23);
  v209 = v571 + __ROR4__(v859 + ((v528 ^ v458) & v671 ^ v528), 23);
  v210 = v540 + __ROR4__(v858 + (v204 & (v394 ^ v707) ^ v394), 23);
  v471 = __ROR4__(v205, 23);
  v381 = __ROR4__(v206, 23);
  v493 = __ROR4__(v207, 23);
  v619 = __ROR4__(v209, 23);
  v517 = __ROR4__(v208, 23);
  v605 = __ROR4__(v210, 23);
  v529 = __ROR4__(v632, 23);
  v211 = v381 + __ROR4__(v861 + ((v447 ^ v560) & v205 ^ v447), 17);
  v212 = v471 + __ROR4__(v812 + (v206 & (v408 ^ v482) ^ v408), 17);
  v657 = v646 + __ROR4__(v862 + (v207 & (v422 ^ v504) ^ v422), 17);
  v213 = v493 + __ROR4__(v798 + v803, 17);
  v214 = v785 + (v632 & (v199 ^ v571) ^ v199);
  v633 = v517 + __ROR4__(v866 + ((v458 ^ v593) & v209 ^ v458), 17);
  v720 = v605 + __ROR4__(v214, 17);
  v215 = v619 + __ROR4__(v863 + (v208 & (v696 ^ v540) ^ v696), 17);
  v216 = v529 + __ROR4__((unsigned __int16)(233 * v912) + 15269888 * v1040 + v394 + (v210 & (v707 ^ v582) ^ v707), 17);
  v777 = __ROR4__(v211, 17);
  v807 = __ROR4__(v633, 17);
  v395 = __ROR4__(v213, 17);
  v799 = __ROR4__(v720, 17);
  v786 = __ROR4__(v657, 17);
  v804 = __ROR4__(v216, 17);
  v795 = __ROR4__(v215, 17);
  v762 = __ROR4__(v212, 17);
  v217 = v762 + __ROR4__((unsigned __int16)(233 * v988) + 15269888 * v1116 + v696 + ((v540 ^ v517) & v215 ^ v540), 27);
  v218 = v795 + __ROR4__((unsigned __int16)(233 * v982) + 15269888 * v1110 + v408 + ((v482 ^ v381) & v212 ^ v482), 27);
  v219 = v807 + __ROR4__((unsigned __int16)(233 * v984) + 15269888 * v1112 + v447 + ((v560 ^ v471) & v211 ^ v560), 27);
  v672 = __ROR4__(v219, 27);
  v220 = v777 + __ROR4__((unsigned __int16)(233 * v994) + 15269888 * v1122 + v458 + (v633 & (v593 ^ v619) ^ v593), 27);
  v732 = __ROR4__(v220, 27);
  v409 = v799 + __ROR4__((unsigned __int16)(233 * v980) + 15269888 * v1108 + v684 + (v213 & (v549 ^ v646) ^ v549), 27);
  v221 = v395 + __ROR4__((unsigned __int16)(233 * v990) + 15269888 * v1118 + v199 + ((v571 ^ v529) & v720 ^ v571), 27);
  v222 = v804 + __ROR4__((unsigned __int16)(233 * v986) + 15269888 * v1114 + v422 + ((v504 ^ v493) & v657 ^ v504), 27);
  v223 = v786 + __ROR4__((unsigned __int16)(233 * v992) + 15269888 * v1120 + v707 + ((v582 ^ v605) & v216 ^ v582), 27);
  v634 = __ROR4__(v409, 27);
  v708 = __ROR4__(v221, 27);
  v685 = __ROR4__(v222, 27);
  v697 = __ROR4__(v217, 27);
  v658 = __ROR4__(v218, 27);
  v721 = __ROR4__(v223, 27);
  v224 = v409;
  v423 = v672 + __ROR4__((unsigned __int16)(233 * v942) + 15269888 * v1070 + v571 + ((v529 ^ v799) & v221 ^ v529), 3);
  v410 = v708 + __ROR4__((unsigned __int16)(233 * v936) + 15269888 * v1064 + v560 + (v219 & (v471 ^ v777) ^ v471), 3);
  v435 = v634 + __ROR4__((unsigned __int16)(233 * v946) + 15269888 * v1074 + v593 + ((v619 ^ v807) & v220 ^ v619), 3);
  v225 = v685 + __ROR4__((unsigned __int16)(233 * v940) + 15269888 * v1068 + v540 + (v217 & (v517 ^ v795) ^ v517), 3);
  v226 = v732 + __ROR4__((unsigned __int16)(233 * v932) + 15269888 * v1060 + v549 + (v224 & (v646 ^ v395) ^ v646), 3);
  v227 = (unsigned __int16)(233 * v934) + 15269888 * v1062 + v482 + (v218 & (v381 ^ v762) ^ v381);
  v228 = v658 + __ROR4__((unsigned __int16)(233 * v944) + 15269888 * v1072 + v582 + ((v605 ^ v804) & v223 ^ v605), 3);
  v229 = v697 + __ROR4__((unsigned __int16)(233 * v938) + 15269888 * v1066 + v504 + ((v493 ^ v786) & v222 ^ v493), 3);
  v483 = __ROR4__(v226, 3);
  v230 = v721 + __ROR4__(v227, 3);
  v561 = __ROR4__(v225, 3);
  v505 = __ROR4__(v230, 3);
  v541 = __ROR4__(v410, 3);
  v550 = __ROR4__(v229, 3);
  v572 = __ROR4__(v423, 3);
  v583 = __ROR4__(v228, 3);
  v594 = __ROR4__(v435, 3);
  v231 = v721 & v228;
  v855 = (v721 | v228) & v804;
  v232 = (v658 | v230) & v762 | v230 & v658;
  v233 = (unsigned __int16)(233 * v972) + 15269888 * v1100 + v517 + ((v697 | v225) & v795 | v697 & v225);
  v234 = v505
       + __ROR4__((unsigned __int16)(233 * v974) + 15269888 * v1102 + v529 + ((v708 | v423) & v799 | v708 & v423), 23);
  v235 = (unsigned __int16)(233 * v964) + 15269888 * v1092 + v646 + ((v634 | v226) & v395 | v226 & v634);
  v236 = v541 + __ROR4__((unsigned __int16)(233 * v976) + 15269888 * v1104 + v605 + (v855 | v231), 23);
  v237 = v583
       + __ROR4__((unsigned __int16)(233 * v968) + 15269888 * v1096 + v471 + ((v672 | v410) & v777 | v672 & v410), 23);
  v238 = v550
       + __ROR4__((unsigned __int16)(233 * v978) + 15269888 * v1106 + v619 + ((v732 | v435) & v807 | v435 & v732), 23);
  v239 = v561 + __ROR4__(v235, 23);
  v240 = v594
       + __ROR4__((unsigned __int16)(233 * v970) + 15269888 * v1098 + v493 + ((v685 | v229) & v786 | v229 & v685), 23);
  v241 = v572 + __ROR4__((unsigned __int16)(233 * v966) + 15269888 * v1094 + v381 + v232, 23);
  v518 = __ROR4__(v241, 23);
  v242 = v483 + __ROR4__(v233, 23);
  v494 = __ROR4__(v239, 23);
  v606 = __ROR4__(v240, 23);
  v530 = __ROR4__(v237, 23);
  v647 = __ROR4__(v234, 23);
  v620 = __ROR4__(v242, 23);
  v754 = __ROR4__(v238, 23);
  v744 = __ROR4__(v236, 23);
  v382 = (v483 | v239) & v634 | v483 & v239;
  v243 = v530
       + __ROR4__((unsigned __int16)(233 * v954) + 15269888 * v1082 + v786 + ((v550 | v240) & v685 | v550 & v240), 17);
  v244 = v647
       + __ROR4__((unsigned __int16)(233 * v956) + 15269888 * v1084 + v795 + ((v561 | v242) & v697 | v561 & v242), 17);
  v245 = v744
       + __ROR4__((unsigned __int16)(233 * v962) + 15269888 * v1090 + v807 + ((v594 | v238) & v732 | v238 & v594), 17);
  v246 = v518 + __ROR4__((unsigned __int16)(233 * v948) + 15269888 * v1076 + v395 + v382, 17);
  v383 = __ROR4__(v246, 17);
  v247 = v494
       + __ROR4__((unsigned __int16)(233 * v950) + 15269888 * v1078 + v762 + ((v505 | v241) & v658 | v505 & v241), 17);
  v248 = v606
       + __ROR4__((unsigned __int16)(233 * v952) + 15269888 * v1080 + v777 + ((v541 | v237) & v672 | v237 & v541), 17);
  v249 = v754
       + __ROR4__((unsigned __int16)(233 * v960) + 15269888 * v1088 + v804 + ((v583 | v236) & v721 | v583 & v236), 17);
  v250 = v620
       + __ROR4__((unsigned __int16)(233 * v958) + 15269888 * v1086 + v799 + ((v572 | v234) & v708 | v572 & v234), 17);
  v459 = __ROR4__(v249, 17);
  v411 = __ROR4__(v248, 17);
  v436 = __ROR4__(v244, 17);
  v396 = __ROR4__(v247, 17);
  v424 = __ROR4__(v243, 17);
  v448 = __ROR4__(v250, 17);
  v472 = __ROR4__(v245, 17);
  v251 = v754 & v245;
  v808 = (v754 | v245) & v594;
  v252 = v459
       + __ROR4__((unsigned __int16)(233 * v868) + 15269888 * v996 + v634 + ((v494 | v246) & v483 | v246 & v494), 27);
  v763 = v436
       + __ROR4__((unsigned __int16)(233 * v872) + 15269888 * v1000 + v672 + ((v530 | v248) & v541 | v248 & v530), 27);
  v253 = (unsigned __int16)(233 * v874) + 15269888 * v1002 + v685 + ((v606 | v243) & v550 | v243 & v606);
  v254 = v411
       + __ROR4__((unsigned __int16)(233 * v876) + 15269888 * v1004 + v697 + ((v620 | v244) & v561 | v244 & v620), 27);
  v255 = v448 + __ROR4__(v253, 27);
  v256 = v424
       + __ROR4__((unsigned __int16)(233 * v878) + 15269888 * v1006 + v708 + ((v647 | v250) & v572 | v250 & v647), 27);
  v257 = v472
       + __ROR4__((unsigned __int16)(233 * v870) + 15269888 * v998 + v658 + ((v518 | v247) & v505 | v247 & v518), 27);
  v258 = v383
       + __ROR4__((unsigned __int16)(233 * v880) + 15269888 * v1008 + v721 + ((v744 | v249) & v583 | v744 & v249), 27);
  v259 = v396 + __ROR4__((unsigned __int16)(233 * v882) + 15269888 * v1010 + v732 + (v808 | v251), 27);
  v635 = __ROR4__(v252, 27);
  v673 = __ROR4__(v763, 27);
  v686 = __ROR4__(v255, 27);
  v659 = __ROR4__(v257, 27);
  v709 = __ROR4__(v256, 27);
  v722 = __ROR4__(v258, 27);
  v733 = __ROR4__(v259, 27);
  v698 = __ROR4__(v254, 27);
  v260 = (unsigned __int16)(233 * v930) + 15269888 * v1058 + v594 + ((v472 | v259) & v754 | v472 & v259);
  v261 = v733
       + __ROR4__((unsigned __int16)(233 * v926) + 15269888 * v1054 + v572 + ((v448 | v256) & v647 | v448 & v256), 3);
  v262 = v673
       + __ROR4__((unsigned __int16)(233 * v916) + 15269888 * v1044 + v483 + ((v383 | v252) & v494 | v383 & v252), 3);
  v263 = v635
       + __ROR4__((unsigned __int16)(233 * v920) + 15269888 * v1048 + v541 + ((v411 | v763) & v530 | v411 & v763), 3);
  v264 = v686
       + __ROR4__((unsigned __int16)(233 * v918) + 15269888 * v1046 + v505 + ((v396 | v257) & v518 | v396 & v257), 3);
  v265 = v261;
  v266 = v722
       + __ROR4__((unsigned __int16)(233 * v924) + 15269888 * v1052 + v561 + ((v436 | v254) & v620 | v436 & v254), 3);
  v267 = v659
       + __ROR4__((unsigned __int16)(233 * v922) + 15269888 * v1050 + v550 + ((v424 | v255) & v606 | v424 & v255), 3);
  v778 = v698
       + __ROR4__((unsigned __int16)(233 * v928) + 15269888 * v1056 + v583 + ((v459 | v258) & v744 | v459 & v258), 3);
  v551 = __ROR4__(v267, 28);
  v787 = v709 + __ROR4__(v260, 3);
  v484 = __ROR4__(v262, 28);
  v506 = __ROR4__(v264, 28);
  v573 = __ROR4__(v265, 28);
  v584 = __ROR4__(v778, 28);
  v595 = __ROR4__(v787, 28);
  v562 = __ROR4__(v266, 28);
  v542 = __ROR4__(v263, 28);
  v268 = (unsigned __int16)(233 * v969) + 15269888 * v1097 + v530 + ((v411 ^ v673) & v263 ^ v411);
  v269 = v584 + __ROR4__((unsigned __int16)(233 * v975) + 15269888 * v1103 + v647 + ((v448 ^ v709) & v265 ^ v448), 19);
  v270 = v542 + __ROR4__((unsigned __int16)(233 * v967) + 15269888 * v1095 + v518 + ((v396 ^ v659) & v264 ^ v396), 19);
  v531 = v551 + __ROR4__((unsigned __int16)(233 * v965) + 15269888 * v1093 + v494 + ((v383 ^ v635) & v262 ^ v383), 19);
  v271 = v573 + __ROR4__((unsigned __int16)(233 * v977) + 15269888 * v1105 + v744 + (v778 & (v459 ^ v722) ^ v459), 19);
  v272 = v484 + __ROR4__((unsigned __int16)(233 * v971) + 15269888 * v1099 + v606 + ((v424 ^ v686) & v267 ^ v424), 19);
  v764 = v595 + __ROR4__((unsigned __int16)(233 * v973) + 15269888 * v1101 + v620 + (v266 & (v436 ^ v698) ^ v436), 19);
  v273 = v562 + __ROR4__((unsigned __int16)(233 * v979) + 15269888 * v1107 + v754 + ((v472 ^ v733) & v787 ^ v472), 19);
  v495 = __ROR4__(v531, 19);
  v274 = v506 + __ROR4__(v268, 19);
  v607 = __ROR4__(v272, 19);
  v745 = __ROR4__(v271, 19);
  v519 = __ROR4__(v270, 19);
  v621 = __ROR4__(v764, 19);
  v648 = __ROR4__(v269, 19);
  v755 = __ROR4__(v273, 19);
  v275 = v531 & (v635 ^ v484);
  v532 = __ROR4__(v274, 19);
  v276 = v519 + __ROR4__((unsigned __int16)(233 * v877) + 15269888 * v1005 + v436 + (v764 & (v698 ^ v562) ^ v698), 22);
  v277 = v607 + __ROR4__((unsigned __int16)(233 * v881) + 15269888 * v1009 + v459 + (v271 & (v722 ^ v584) ^ v722), 22);
  v278 = v745 + __ROR4__((unsigned __int16)(233 * v875) + 15269888 * v1003 + v424 + (v272 & (v686 ^ v551) ^ v686), 22);
  v279 = v495 + __ROR4__((unsigned __int16)(233 * v879) + 15269888 * v1007 + v448 + (v269 & (v709 ^ v573) ^ v709), 22);
  v280 = v621 + __ROR4__((unsigned __int16)(233 * v871) + 15269888 * v999 + v396 + (v270 & (v659 ^ v506) ^ v659), 22);
  v281 = v532 + __ROR4__((unsigned __int16)(233 * v883) + 15269888 * v1011 + v472 + (v273 & (v733 ^ v595) ^ v733), 22);
  v282 = v648 + __ROR4__((unsigned __int16)(233 * v869) + 15269888 * v997 + v383 + (v275 ^ v635), 22);
  v765 = v755 + __ROR4__((unsigned __int16)(233 * v873) + 15269888 * v1001 + v411 + (v274 & (v673 ^ v542) ^ v673), 22);
  v437 = __ROR4__(v276, 22);
  v384 = __ROR4__(v282, 22);
  v425 = __ROR4__(v278, 22);
  v283 = (v551 ^ v607) & v278;
  v473 = __ROR4__(v281, 22);
  v449 = __ROR4__(v279, 22);
  v397 = __ROR4__(v280, 22);
  v412 = __ROR4__(v765, 22);
  v460 = __ROR4__(v277, 22);
  v284 = (v595 ^ v755) & v281;
  v285 = (v584 ^ v745) & v277;
  v286 = v449 + __ROR4__((unsigned __int16)(233 * v889) + 15269888 * v1017 + v673 + (v765 & (v542 ^ v532) ^ v542), 7);
  v287 = v437 + __ROR4__((unsigned __int16)(233 * v891) + 15269888 * v1019 + v686 + (v283 ^ v551), 7);
  v288 = v425 + __ROR4__((unsigned __int16)(233 * v893) + 15269888 * v1021 + v698 + (v276 & (v562 ^ v621) ^ v562), 7);
  v699 = __ROR4__(v288, 7);
  v289 = v412 + __ROR4__((unsigned __int16)(233 * v895) + 15269888 * v1023 + v709 + (v279 & (v573 ^ v648) ^ v573), 7);
  v766 = v473 + __ROR4__((unsigned __int16)(233 * v885) + 15269888 * v1013 + v635 + (v282 & (v484 ^ v495) ^ v484), 7);
  v687 = __ROR4__(v287, 7);
  v290 = v384 + __ROR4__((unsigned __int16)(233 * v899) + 15269888 * v1027 + v733 + (v284 ^ v595), 7);
  v734 = __ROR4__(v290, 7);
  v291 = v460 + __ROR4__((unsigned __int16)(233 * v887) + 15269888 * v1015 + v659 + ((v506 ^ v519) & v280 ^ v506), 7);
  v636 = __ROR4__(v766, 7);
  v292 = v397 + __ROR4__((unsigned __int16)(233 * v897) + 15269888 * v1025 + v722 + (v285 ^ v584), 7);
  v710 = __ROR4__(v289, 7);
  v660 = __ROR4__(v291, 7);
  v674 = __ROR4__(v286, 7);
  v723 = __ROR4__(v292, 7);
  v293 = v290 & (v755 ^ v473) ^ v755;
  v294 = (unsigned __int16)(233 * v993) + 15269888 * v1121 + v584 + ((v745 ^ v460) & v292 ^ v745);
  v779 = v636 + __ROR4__((unsigned __int16)(233 * v989) + 15269888 * v1117 + v562 + ((v621 ^ v437) & v288 ^ v621), 28);
  v295 = v699 + __ROR4__((unsigned __int16)(233 * v981) + 15269888 * v1109 + v484 + ((v495 ^ v384) & v766 ^ v495), 28);
  v296 = v687 + __ROR4__((unsigned __int16)(233 * v995) + 15269888 * v1123[0] + v595 + v293, 28);
  v767 = v734 + __ROR4__((unsigned __int16)(233 * v987) + 15269888 * v1115 + v551 + ((v607 ^ v425) & v287 ^ v607), 28);
  v297 = v710 + __ROR4__((unsigned __int16)(233 * v983) + 15269888 * v1111 + v506 + (v291 & (v519 ^ v397) ^ v519), 28);
  v800 = v660 + __ROR4__((unsigned __int16)(233 * v991) + 15269888 * v1119 + v573 + ((v648 ^ v449) & v289 ^ v648), 28);
  v788 = v674 + __ROR4__(v294, 28);
  v298 = v723 + __ROR4__((unsigned __int16)(233 * v985) + 15269888 * v1113 + v542 + (v286 & (v532 ^ v412) ^ v532), 28);
  v543 = __ROR4__(v298, 28);
  v552 = __ROR4__(v767, 28);
  v485 = __ROR4__(v295, 28);
  v574 = __ROR4__(v800, 28);
  v507 = __ROR4__(v297, 28);
  v563 = __ROR4__(v779, 28);
  v585 = __ROR4__(v788, 28);
  v596 = __ROR4__(v296, 28);
  v299 = (v636 | v295) & v384 | v636 & v295;
  v851 = (v674 | v298) & v412;
  v300 = v298 & v674;
  v301 = v485
       + __ROR4__((unsigned __int16)(233 * v919) + 15269888 * v1047 + v519 + ((v660 | v297) & v397 | v297 & v660), 19);
  v302 = v543
       + __ROR4__((unsigned __int16)(233 * v923) + 15269888 * v1051 + v607 + ((v687 | v767) & v425 | v687 & v767), 19);
  v303 = v552 + __ROR4__((unsigned __int16)(233 * v921) + 15269888 * v1049 + v532 + (v851 | v300), 19);
  v304 = v507 + __ROR4__((unsigned __int16)(233 * v917) + 15269888 * v1045 + v495 + v299, 19);
  v768 = v563
       + __ROR4__((unsigned __int16)(233 * v927) + 15269888 * v1055 + v648 + ((v710 | v800) & v449 | v710 & v800), 19);
  v780 = v574
       + __ROR4__((unsigned __int16)(233 * v925) + 15269888 * v1053 + v621 + ((v699 | v779) & v437 | v699 & v779), 19);
  v305 = v585
       + __ROR4__((unsigned __int16)(233 * v931) + 15269888 * v1059 + v755 + ((v734 | v296) & v473 | v296 & v734), 19);
  v306 = v596
       + __ROR4__((unsigned __int16)(233 * v929) + 15269888 * v1057 + v745 + ((v723 | v788) & v460 | v723 & v788), 19);
  v520 = __ROR4__(v301, 19);
  v496 = __ROR4__(v304, 19);
  v533 = __ROR4__(v303, 19);
  v746 = __ROR4__(v306, 19);
  v608 = __ROR4__(v302, 19);
  v622 = __ROR4__(v780, 19);
  v756 = __ROR4__(v305, 19);
  v649 = __ROR4__(v768, 19);
  v867 = 233 * v915;
  v307 = (v596 | v305) & v734 | v305 & v596;
  v308 = (v552 | v302) & v687 | v552 & v302;
  v309 = v746
       + __ROR4__((unsigned __int16)(233 * v949) + 15269888 * v1077 + v384 + ((v485 | v304) & v636 | v304 & v485), 22);
  v310 = v756
       + __ROR4__((unsigned __int16)(233 * v951) + 15269888 * v1079 + v397 + ((v507 | v301) & v660 | v507 & v301), 22);
  v311 = v649 + __ROR4__((unsigned __int16)(233 * v955) + 15269888 * v1083 + v425 + v308, 22);
  v312 = v622
       + __ROR4__((unsigned __int16)(233 * v953) + 15269888 * v1081 + v412 + ((v543 | v303) & v674 | v303 & v543), 22);
  v313 = v533
       + __ROR4__((unsigned __int16)(233 * v957) + 15269888 * v1085 + v437 + ((v563 | v780) & v699 | v563 & v780), 22);
  v385 = __ROR4__(v309, 22);
  v314 = v496
       + __ROR4__((unsigned __int16)(233 * v961) + 15269888 * v1089 + v460 + ((v585 | v306) & v723 | v306 & v585), 22);
  v315 = v608
       + __ROR4__((unsigned __int16)(233 * v959) + 15269888 * v1087 + v449 + ((v574 | v768) & v710 | v574 & v768), 22);
  v398 = __ROR4__(v310, 22);
  v316 = v520 + __ROR4__((unsigned __int16)(233 * v963) + 15269888 * v1091 + v473 + v307, 22);
  v413 = __ROR4__(v312, 22);
  v426 = __ROR4__(v311, 22);
  v438 = __ROR4__(v313, 22);
  v461 = __ROR4__(v314, 22);
  v450 = __ROR4__(v315, 22);
  v317 = (v496 | v309) & v485;
  v474 = __ROR4__(v316, 22);
  v769 = v496 & v309;
  v318 = (v533 | v312) & v543 | v533 & v312;
  v789 = (v649 | v315) & v574;
  v319 = v649 & v315;
  v320 = v413 + __ROR4__((unsigned __int16)(233 * v933) + 15269888 * v1061 + v636 + (v317 | v769), 7);
  v321 = v398
       + __ROR4__((unsigned __int16)(233 * v939) + 15269888 * v1067 + v687 + ((v608 | v311) & v552 | v311 & v608), 7);
  v322 = v385 + __ROR4__((unsigned __int16)(233 * v937) + 15269888 * v1065 + v674 + v318, 7);
  v323 = v474 + __ROR4__((unsigned __int16)(233 * v943) + 15269888 * v1071 + v710 + (v789 | v319), 7);
  v324 = v438
       + __ROR4__((unsigned __int16)(233 * v945) + 15269888 * v1073 + v723 + ((v746 | v314) & v585 | v314 & v746), 7);
  v781 = v461
       + __ROR4__((unsigned __int16)(233 * v941) + 15269888 * v1069 + v699 + ((v622 | v313) & v563 | v313 & v622), 7);
  v675 = __ROR4__(v322, 7);
  v700 = __ROR4__(v781, 7);
  v325 = v426
       + __ROR4__((unsigned __int16)(233 * v935) + 15269888 * v1063 + v660 + ((v520 | v310) & v507 | v520 & v310), 7);
  v724 = __ROR4__(v324, 7);
  v326 = v450
       + __ROR4__((unsigned __int16)(233 * v947) + 15269888 * v1075 + v734 + ((v756 | v316) & v596 | v316 & v756), 7);
  v637 = __ROR4__(v320, 7);
  v661 = __ROR4__(v325, 7);
  v688 = __ROR4__(v321, 7);
  v711 = __ROR4__(v323, 7);
  v735 = __ROR4__(v326, 7);
  v327 = v711
       + __ROR4__((unsigned __int16)(233 * v913) + 15269888 * v1041 + v585 + ((v461 | v324) & v746 | v461 & v324), 28);
  v328 = v661
       + __ROR4__((unsigned __int16)(233 * v905) + 15269888 * v1033 + v543 + ((v413 | v322) & v533 | v322 & v413), 28);
  v329 = v675
       + __ROR4__((unsigned __int16)(233 * v903) + 15269888 * v1031 + v507 + ((v398 | v325) & v520 | v325 & v398), 28);
  v330 = v637
       + __ROR4__((unsigned __int16)(233 * v907) + 15269888 * v1035 + v552 + ((v426 | v321) & v608 | v321 & v426), 28);
  v331 = v700
       + __ROR4__((unsigned __int16)(233 * v915) + 15269888 * v1043 + v596 + ((v474 | v326) & v756 | v474 & v326), 28);
  v332 = v724
       + __ROR4__((unsigned __int16)(233 * v911) + 15269888 * v1039 + v574 + ((v450 | v323) & v649 | v450 & v323), 28);
  v333 = v688
       + __ROR4__((unsigned __int16)(233 * v901) + 15269888 * v1029 + v485 + ((v385 | v320) & v496 | v320 & v385), 28);
  v597 = __ROR4__(v331, 28);
  v334 = v735
       + __ROR4__((unsigned __int16)(233 * v909) + 15269888 * v1037 + v563 + ((v438 | v781) & v622 | v781 & v438), 28);
  v508 = __ROR4__(v329, 28);
  v486 = __ROR4__(v333, 28);
  v575 = __ROR4__(v332, 28);
  v544 = __ROR4__(v328, 28);
  v564 = __ROR4__(v334, 28);
  v553 = __ROR4__(v330, 28);
  v586 = __ROR4__(v327, 28);
  v335 = (v334 & (v438 ^ v700) ^ v438) + v845 + v622;
  v336 = (v398 ^ v661) & v329 ^ v398;
  v337 = v486 + __ROR4__((v332 & (v450 ^ v711) ^ v450) + v814 + v649, 19);
  v338 = (v327 & (v461 ^ v724) ^ v461) + v815 + v746;
  v770 = v575 + __ROR4__((v333 & (v385 ^ v637) ^ v385) + v841 + v496, 19);
  v339 = v586 + __ROR4__(((v426 ^ v688) & v330 ^ v426) + v844 + v608, 19);
  v340 = v544 + __ROR4__(((v474 ^ v735) & v331 ^ v474) + v816 + v756, 19);
  v341 = v564 + __ROR4__(v336 + v842 + v520, 19);
  v342 = v597 + __ROR4__(((v413 ^ v675) & v328 ^ v413) + v843 + v533, 19);
  v343 = v553 + __ROR4__(v338, 19);
  v344 = v508 + __ROR4__(v335, 19);
  v497 = __ROR4__(v770, 19);
  v757 = __ROR4__(v340, 19);
  v623 = __ROR4__(v344, 19);
  v609 = __ROR4__(v339, 19);
  v521 = __ROR4__(v341, 19);
  v747 = __ROR4__(v343, 19);
  v650 = __ROR4__(v337, 19);
  v534 = __ROR4__(v342, 19);
  v345 = (v344 & (v700 ^ v564) ^ v700) + v821 + v438;
  v346 = (v342 & (v675 ^ v544) ^ v675) + v819 + v413;
  v347 = v521 + __ROR4__((v343 & (v724 ^ v586) ^ v724) + v823 + v461, 22);
  v348 = v497 + __ROR4__((v340 & (v735 ^ v597) ^ v735) + v824 + v474, 22);
  v349 = v757 + __ROR4__(((v637 ^ v486) & v770 ^ v637) + v817 + v385, 22);
  v350 = v623 + __ROR4__((v339 & (v688 ^ v553) ^ v688) + v820 + v426, 22);
  v351 = v747 + __ROR4__((v341 & (v661 ^ v508) ^ v661) + v818 + v398, 22);
  v352 = v609 + __ROR4__(v345, 22);
  v353 = v534 + __ROR4__((v337 & (v711 ^ v575) ^ v711) + v822 + v450, 22);
  v439 = __ROR4__(v352, 22);
  v399 = __ROR4__(v351, 22);
  v354 = v650 + __ROR4__(v346, 22);
  v386 = __ROR4__(v349, 22);
  v451 = __ROR4__(v353, 22);
  v462 = __ROR4__(v347, 22);
  v427 = __ROR4__(v350, 22);
  v414 = __ROR4__(v354, 22);
  v475 = __ROR4__(v348, 22);
  v355 = v462 + __ROR4__((v354 & (v544 ^ v534) ^ v544) + v827 + v675, 7);
  v356 = v451 + __ROR4__((v351 & (v508 ^ v521) ^ v508) + v826 + v661, 7);
  v357 = v386 + __ROR4__((v352 & (v564 ^ v623) ^ v564) + v829 + v700, 7);
  v358 = v439 + __ROR4__((v349 & (v486 ^ v497) ^ v486) + v825 + v637, 7);
  v359 = v427 + __ROR4__(((v597 ^ v757) & v348 ^ v597) + v832 + v735, 7);
  v638 = v399 + __ROR4__((v353 & (v575 ^ v650) ^ v575) + v830 + v711, 7);
  v771 = __ROR4__(v357, 7);
  v360 = v414 + __ROR4__((v347 & (v586 ^ v747) ^ v586) + v831 + v724, 7);
  v361 = v475 + __ROR4__(((v553 ^ v609) & v350 ^ v553) + v828 + v688, 7);
  v662 = __ROR4__(v355, 7);
  v701 = __ROR4__(v360, 7);
  v676 = __ROR4__(v361, 7);
  v712 = __ROR4__(v359, 7);
  v362 = __ROR4__(v358, 7);
  v363 = __ROR4__(v356, 7);
  *(_DWORD *)(a1 + 132) = v363 + __ROR4__((v358 & (v497 ^ v386) ^ v497) + v833 + v486, 28);
  *(_DWORD *)(a1 + 164) = v362;
  *(_DWORD *)(a1 + 168) = v363;
  *(_DWORD *)(a1 + 200) = v399;
  *(_DWORD *)(a1 + 232) = v521;
  *(_DWORD *)(a1 + 196) = v386;
  *(_DWORD *)(a1 + 212) = v439;
  *(_DWORD *)(a1 + 180) = v771;
  *(_DWORD *)(a1 + 216) = v451;
  *(_DWORD *)(a1 + 228) = v497;
  *(_DWORD *)(a1 + 236) = v534;
  *(_DWORD *)(a1 + 256) = v757;
  *(_DWORD *)(a1 + 152) = v771 + __ROR4__((v638 & (v650 ^ v451) ^ v650) + v838 + v575, 28);
  *(_DWORD *)(a1 + 240) = v609;
  *(_DWORD *)(a1 + 136) = v362 + __ROR4__((v356 & (v521 ^ v399) ^ v521) + v834 + v508, 28);
  *(_DWORD *)(a1 + 204) = v414;
  result = __ROR4__(v638, 7);
  *(_DWORD *)(a1 + 220) = v462;
  *(_DWORD *)(a1 + 208) = v427;
  *(_DWORD *)(a1 + 172) = v662;
  *(_DWORD *)(a1 + 244) = v623;
  *(_DWORD *)(a1 + 248) = v650;
  *(_DWORD *)(a1 + 252) = v747;
  *(_DWORD *)(a1 + 148) = result + __ROR4__((v357 & (v623 ^ v439) ^ v623) + v837 + v564, 28);
  *(_DWORD *)(a1 + 184) = result;
  *(_DWORD *)(a1 + 188) = v701;
  *(_DWORD *)(a1 + 224) = v475;
  *(_DWORD *)(a1 + 144) = v662 + __ROR4__((v361 & (v609 ^ v427) ^ v609) + v836 + v553, 28);
  *(_DWORD *)(a1 + 140) = v676 + __ROR4__((v355 & (v534 ^ v414) ^ v534) + v835 + v544, 28);
  *(_DWORD *)(a1 + 176) = v676;
  *(_DWORD *)(a1 + 160) = v701 + __ROR4__((v359 & (v757 ^ v475) ^ v757) + v840 + v597, 28);
  *(_DWORD *)(a1 + 156) = v712 + __ROR4__((v360 & (v747 ^ v462) ^ v747) + v839 + v586, 28);
  *(_DWORD *)(a1 + 192) = v712;
  return result;
}

//----- (000DBAD4) --------------------------------------------------------
_DWORD *__fastcall sph_simd384_0(_DWORD *result, char *src, size_t a3)
{
  size_t v3; // r6
  _DWORD *v4; // r5
  int v6; // r0
  size_t v7; // r4
  char *v8; // r0
  size_t v9; // r4
  int v10; // r3

  v3 = a3;
  if ( a3 )
  {
    v4 = result;
    do
    {
      while ( 1 )
      {
        v6 = v4[32];
        v7 = 128 - v6;
        v8 = (char *)v4 + v6;
        if ( v7 >= v3 )
          v7 = v3;
        v3 -= v7;
        result = memcpy(v8, src, v7);
        src += v7;
        v9 = v7 + v4[32];
        v4[32] = v9;
        if ( v9 == 128 )
          break;
        if ( !v3 )
          return result;
      }
      result = (_DWORD *)sub_D3600((int)v4, 0);
      v10 = v4[65];
      v4[32] = 0;
      v4[65] = ++v10;
      if ( !v10 )
        ++v4[66];
    }
    while ( v3 );
  }
  return result;
}

//----- (000DBB6C) --------------------------------------------------------
unsigned int __fastcall sub_DBB6C(_DWORD *s, char a2, int a3, int a4, int a5)
{
  int v6; // r0
  int v9; // r8
  unsigned int v11; // r3
  int v12; // r0
  int v13; // r12
  char *v14; // r5
  int v15; // r2
  int v16; // r3
  int v17; // r3
  unsigned int v18; // t1
  unsigned int result; // r0

  v6 = s[32];
  v9 = v6 | a3;
  if ( v6 | a3 )
  {
    memset((char *)s + v6, 0, 128 - v6);
    *((_BYTE *)s + s[32]) = a2 & (-1 << (8 - a3));
    sub_D3600((int)s, 0);
    v9 = s[32];
  }
  memset(s, 0, 0x80u);
  v11 = s[65];
  v12 = (int)s;
  v13 = s[66];
  v14 = (char *)(s + 32);
  v11 <<= 10;
  v15 = a3 + v11 + 8 * v9;
  v16 = (v11 >> 22) + (v13 << 10);
  *(v14 - 128) = v15;
  *(v14 - 124) = v16;
  *(v14 - 127) = BYTE1(v15);
  *(v14 - 121) = HIBYTE(v16);
  *(v14 - 126) = BYTE2(v15);
  *(v14 - 125) = HIBYTE(v15);
  *(v14 - 123) = BYTE1(v16);
  *(v14 - 122) = BYTE2(v16);
  sub_D3600(v12, 1);
  v17 = a4;
  do
  {
    v18 = *((_DWORD *)v14 + 1);
    v14 += 4;
    v17 += 4;
    *(_DWORD *)(v17 - 4) = v18;
    result = v18 >> 8;
  }
  while ( a4 + 4 * a5 != v17 );
  return result;
}

//----- (000DBC70) --------------------------------------------------------
int __fastcall sph_simd224_init_0(_DWORD *a1)
{
  int *v2; // r4
  _DWORD *v3; // lr
  int result; // r0
  int v5; // r1
  int v6; // r2
  int v7; // r3

  v2 = (int *)&unk_F4D28;
  v3 = a1 + 17;
  do
  {
    v3 += 4;
    result = *v2;
    v5 = v2[1];
    v6 = v2[2];
    v7 = v2[3];
    v2 += 4;
    *(v3 - 4) = result;
    *(v3 - 3) = v5;
    *(v3 - 2) = v6;
    *(v3 - 1) = v7;
  }
  while ( v2 != (int *)&unk_F4D68 );
  a1[34] = 0;
  a1[33] = 0;
  a1[16] = 0;
  return result;
}

//----- (000DBCC8) --------------------------------------------------------
int __fastcall sph_simd224_addbits_and_close(_DWORD *a1, char a2, int a3, int a4)
{
  int *v4; // r4
  _DWORD *v6; // lr
  int result; // r0
  int v8; // r1
  int v9; // r2
  int v10; // r3

  v4 = (int *)&unk_F4D28;
  sub_D2AF4(a1, a2, a3, a4, 7);
  v6 = a1 + 17;
  do
  {
    v6 += 4;
    result = *v4;
    v8 = v4[1];
    v9 = v4[2];
    v10 = v4[3];
    v4 += 4;
    *(v6 - 4) = result;
    *(v6 - 3) = v8;
    *(v6 - 2) = v9;
    *(v6 - 1) = v10;
  }
  while ( v4 != (int *)&unk_F4D68 );
  a1[34] = 0;
  a1[33] = 0;
  a1[16] = 0;
  return result;
}

//----- (000DBD30) --------------------------------------------------------
int __fastcall sph_simd224_close(_DWORD *a1, int a2)
{
  return sph_simd224_addbits_and_close(a1, 0, 0, a2);
}

//----- (000DBD40) --------------------------------------------------------
int __fastcall sph_simd256_init(_DWORD *a1)
{
  int *v2; // r4
  _DWORD *v3; // lr
  int result; // r0
  int v5; // r1
  int v6; // r2
  int v7; // r3

  v2 = (int *)&unk_F4D68;
  v3 = a1 + 17;
  do
  {
    v3 += 4;
    result = *v2;
    v5 = v2[1];
    v6 = v2[2];
    v7 = v2[3];
    v2 += 4;
    *(v3 - 4) = result;
    *(v3 - 3) = v5;
    *(v3 - 2) = v6;
    *(v3 - 1) = v7;
  }
  while ( v2 != (int *)&unk_F4DA8 );
  a1[34] = 0;
  a1[33] = 0;
  a1[16] = 0;
  return result;
}

//----- (000DBD98) --------------------------------------------------------
int __fastcall sph_simd256_addbits_and_close(_DWORD *a1, char a2, int a3, int a4)
{
  int *v4; // r4
  _DWORD *v6; // lr
  int result; // r0
  int v8; // r1
  int v9; // r2
  int v10; // r3

  v4 = (int *)&unk_F4D68;
  sub_D2AF4(a1, a2, a3, a4, 8);
  v6 = a1 + 17;
  do
  {
    v6 += 4;
    result = *v4;
    v8 = v4[1];
    v9 = v4[2];
    v10 = v4[3];
    v4 += 4;
    *(v6 - 4) = result;
    *(v6 - 3) = v8;
    *(v6 - 2) = v9;
    *(v6 - 1) = v10;
  }
  while ( v4 != (int *)&unk_F4DA8 );
  a1[34] = 0;
  a1[33] = 0;
  a1[16] = 0;
  return result;
}

//----- (000DBE00) --------------------------------------------------------
int __fastcall sph_simd256_close(_DWORD *a1, int a2)
{
  return sph_simd256_addbits_and_close(a1, 0, 0, a2);
}

//----- (000DBE10) --------------------------------------------------------
void *__fastcall sph_simd384_init(_DWORD *a1)
{
  void *result; // r0

  result = memcpy(a1 + 33, &unk_F4DA8, 0x80u);
  a1[66] = 0;
  a1[65] = 0;
  a1[32] = 0;
  return result;
}

//----- (000DBE44) --------------------------------------------------------
void *__fastcall sph_simd384_addbits_and_close(_DWORD *a1, char a2, int a3, int a4)
{
  void *result; // r0

  sub_DBB6C(a1, a2, a3, a4, 12);
  result = memcpy(a1 + 33, &unk_F4DA8, 0x80u);
  a1[66] = 0;
  a1[65] = 0;
  a1[32] = 0;
  return result;
}

//----- (000DBE88) --------------------------------------------------------
void *__fastcall sph_simd384_close(_DWORD *a1, int a2)
{
  return sph_simd384_addbits_and_close(a1, 0, 0, a2);
}

//----- (000DBE98) --------------------------------------------------------
void *__fastcall sph_simd512_init(_DWORD *a1)
{
  void *result; // r0

  result = memcpy(a1 + 33, &unk_F4E28, 0x80u);
  a1[66] = 0;
  a1[65] = 0;
  a1[32] = 0;
  return result;
}

//----- (000DBECC) --------------------------------------------------------
void *__fastcall sph_simd512_addbits_and_close(_DWORD *a1, char a2, int a3, int a4)
{
  void *result; // r0

  sub_DBB6C(a1, a2, a3, a4, 16);
  result = memcpy(a1 + 33, &unk_F4E28, 0x80u);
  a1[66] = 0;
  a1[65] = 0;
  a1[32] = 0;
  return result;
}

//----- (000DBF10) --------------------------------------------------------
void *__fastcall sph_simd512_close(_DWORD *a1, int a2)
{
  return sph_simd512_addbits_and_close(a1, 0, 0, a2);
}

//----- (000DBF20) --------------------------------------------------------
void __fastcall sub_DBF20(int a1)
{
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 36));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 60));
  pthread_cond_destroy((pthread_cond_t *)(a1 + 88));
  pthread_cond_destroy((pthread_cond_t *)(a1 + 136));
  free(*(void **)(a1 + 12));
  free((void *)a1);
}

//----- (000DBF5C) --------------------------------------------------------
_DWORD *__fastcall sub_DBF5C(_DWORD *result, int *a2, unsigned int a3)
{
  unsigned int v4; // r1
  unsigned int v5; // r3
  _DWORD *v6; // t0
  _DWORD *v7; // r6
  int v8; // r5
  void *v9; // r8
  int v10; // r11
  const void *v11; // r10
  unsigned int v12; // r7
  size_t v13; // r5
  char *v14; // r0
  char *v15; // r9
  size_t v16; // r2
  char *v17; // r7
  int v18; // r1
  int v19; // r3
  size_t v20; // r2
  const void *v21; // r1
  size_t v22; // r10
  char *v23; // r7
  char *v24; // r0

  v6 = a2 + 1;
  v4 = a2[1];
  v5 = v6[1];
  v7 = result;
  v8 = *a2;
  v9 = (void *)a2[3];
  if ( a3 >= v5 )
    a3 = v5;
  v10 = a2[4];
  v11 = (const void *)a2[5];
  v12 = a2[6];
  if ( a3 > v4 )
  {
    v13 = a3 + v8;
    v14 = (char *)malloc(v13);
    v15 = v14;
    if ( (unsigned int)v11 >= v12 )
    {
      v20 = v10 - (_DWORD)v11;
      v21 = v11;
      v22 = v12 - (_DWORD)v9;
      v23 = &v14[v20];
      memcpy(v14, v21, v20);
      v24 = v23;
      v17 = &v23[v22];
      memcpy(v24, v9, v22);
    }
    else
    {
      v16 = v12 - (_DWORD)v11;
      v17 = &v14[v12 - (_DWORD)v11];
      memcpy(v14, v11, v16);
    }
    a2[6] = (int)v17;
    free(v9);
    v18 = a2[6];
    v19 = *a2;
    a2[4] = (int)&v15[v13];
    v7[1] = &v15[v13];
    a2[3] = (int)v15;
    a2[5] = (int)v15;
    *v7 = v15;
    v7[2] = v15;
    v7[3] = v18;
    v7[4] = v19;
    return v7;
  }
  else
  {
    *result = v9;
    result[1] = v10;
    result[2] = v11;
    result[3] = v12;
    result[4] = v8;
  }
  return result;
}

//----- (000DC040) --------------------------------------------------------
int __fastcall pipe_elem_size(int a1)
{
  return *(_DWORD *)a1;
}

//----- (000DC048) --------------------------------------------------------
_DWORD *__fastcall pipe_new(int a1, int a2)
{
  _DWORD *v3; // r4
  unsigned int v4; // r7
  char *v6; // r0
  bool v7; // zf
  char *v8; // r8
  int v9; // r5
  unsigned int v10; // r3
  int v11; // r1
  int v12; // r2
  void *v14; // r0

  if ( !a1 )
    return 0;
  v4 = 32 * a1;
  v3 = malloc(0xB8u);
  v6 = (char *)malloc(32 * a1);
  v7 = v6 == 0;
  if ( v6 )
    v7 = v3 == 0;
  v8 = v6;
  if ( v7 )
  {
    v14 = v3;
    v3 = 0;
    free(v14);
    free(v8);
  }
  else
  {
    if ( a2 )
    {
      v9 = a1 + a2 * a1;
      if ( v9 < v4 )
        v9 = 32 * a1;
      if ( v9 >= 0 )
      {
        v10 = v9 - 1;
        v11 = 5;
        v12 = 1;
        do
        {
          --v11;
          v10 |= v10 >> v12;
          v12 *= 2;
        }
        while ( v11 );
        v9 = v10 + 1;
      }
    }
    else
    {
      v9 = -1;
    }
    memset(v3, 0, 0xB8u);
    v3[4] = &v8[v4];
    v3[7] = 1;
    v3[8] = 1;
    v3[6] = &v8[a1];
    *v3 = a1;
    v3[1] = v4;
    v3[2] = v9;
    v3[3] = v8;
    v3[5] = v8;
    pthread_mutex_init((pthread_mutex_t *)(v3 + 9), 0);
    pthread_mutex_init((pthread_mutex_t *)(v3 + 15), 0);
    pthread_cond_init((pthread_cond_t *)(v3 + 22), 0);
    pthread_cond_init((pthread_cond_t *)(v3 + 34), 0);
  }
  return v3;
}

//----- (000DC154) --------------------------------------------------------
int __fastcall pipe_producer_new(int a1)
{
  pthread_mutex_t *v1; // r5

  v1 = (pthread_mutex_t *)(a1 + 36);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 36));
  ++*(_DWORD *)(a1 + 28);
  pthread_mutex_unlock(v1);
  return a1;
}

//----- (000DC184) --------------------------------------------------------
int __fastcall pipe_consumer_new(int a1)
{
  pthread_mutex_t *v1; // r5

  v1 = (pthread_mutex_t *)(a1 + 60);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 60));
  ++*(_DWORD *)(a1 + 32);
  pthread_mutex_unlock(v1);
  return a1;
}

//----- (000DC1B4) --------------------------------------------------------
void __fastcall pipe_free(int a1)
{
  pthread_mutex_t *v1; // r5
  pthread_mutex_t *v3; // r7
  int v4; // r6
  int v5; // r5

  v1 = (pthread_mutex_t *)(a1 + 36);
  v3 = (pthread_mutex_t *)(a1 + 60);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 36));
  v4 = *(_DWORD *)(a1 + 28) - 1;
  *(_DWORD *)(a1 + 28) = v4;
  pthread_mutex_unlock(v1);
  pthread_mutex_lock(v3);
  v5 = *(_DWORD *)(a1 + 32) - 1;
  *(_DWORD *)(a1 + 32) = v5;
  pthread_mutex_unlock(v3);
  if ( v5 )
  {
    if ( !v4 )
      pthread_cond_broadcast((pthread_cond_t *)(a1 + 88));
  }
  else
  {
    free(*(void **)(a1 + 12));
    *(_DWORD *)(a1 + 12) = 0;
    if ( v4 )
      pthread_cond_broadcast((pthread_cond_t *)(a1 + 136));
    else
      sub_DBF20(a1);
  }
}

//----- (000DC244) --------------------------------------------------------
void __fastcall pipe_producer_free(int a1)
{
  pthread_mutex_t *v1; // r6
  int v3; // r4
  int v4; // r6

  v1 = (pthread_mutex_t *)(a1 + 36);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 36));
  v3 = *(_DWORD *)(a1 + 28) - 1;
  *(_DWORD *)(a1 + 28) = v3;
  pthread_mutex_unlock(v1);
  if ( !v3 )
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 60));
    v4 = *(_DWORD *)(a1 + 32);
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 60));
    if ( v4 )
      pthread_cond_broadcast((pthread_cond_t *)(a1 + 88));
    else
      sub_DBF20(a1);
  }
}

//----- (000DC2AC) --------------------------------------------------------
void __fastcall pipe_consumer_free(int a1)
{
  pthread_mutex_t *v1; // r6
  int v3; // r4
  int v4; // r6

  v1 = (pthread_mutex_t *)(a1 + 60);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 60));
  v3 = *(_DWORD *)(a1 + 32) - 1;
  *(_DWORD *)(a1 + 32) = v3;
  pthread_mutex_unlock(v1);
  if ( !v3 )
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 36));
    v4 = *(_DWORD *)(a1 + 28);
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 36));
    if ( v4 )
      pthread_cond_broadcast((pthread_cond_t *)(a1 + 136));
    else
      sub_DBF20(a1);
  }
}

//----- (000DC314) --------------------------------------------------------
_DWORD *__fastcall _pipe_push(_DWORD *result, char *a2, size_t a3)
{
  size_t v3; // r11
  int *v4; // r9
  unsigned int v5; // r1
  unsigned int v6; // r6
  char *v7; // r4
  unsigned int v8; // r7
  unsigned int v9; // r8
  int v10; // r2
  int v11; // r5
  int v12; // r3
  int v13; // r1
  _BOOL4 v14; // r2
  char *v15; // r1
  unsigned int v16; // r10
  unsigned int v17; // r5
  char *v18; // r0
  size_t v19; // r6
  size_t v20; // r2
  char *v21; // r1
  pthread_cond_t *v22; // r0
  int v23; // r2
  _BOOL4 v24; // r2
  int v25; // r2
  char *v26; // r0
  unsigned int v27; // r0
  int v28; // r3
  unsigned int v29; // r2
  int v30; // r2
  int v31; // r3
  char *v32; // r0
  pthread_mutex_t *mutex; // [sp+0h] [bp-3Ch]
  int v34; // [sp+4h] [bp-38h]
  int v36; // [sp+Ch] [bp-30h]
  pthread_mutex_t *v37; // [sp+10h] [bp-2Ch]
  pthread_cond_t *cond; // [sp+14h] [bp-28h]
  unsigned int v39; // [sp+18h] [bp-24h]
  int v40; // [sp+18h] [bp-24h]
  _DWORD v41[6]; // [sp+24h] [bp-18h] BYREF

  v3 = a3;
  v36 = *result;
  if ( a3 )
  {
    v4 = result;
    mutex = (pthread_mutex_t *)(result + 15);
    cond = (pthread_cond_t *)(result + 34);
    v37 = (pthread_mutex_t *)(result + 9);
    while ( 1 )
    {
      pthread_mutex_lock(mutex);
      v6 = v4[5];
      v7 = (char *)v4[6];
      v8 = v4[4];
      v9 = *v4;
      v34 = v4[3];
      if ( v6 >= (unsigned int)v7 )
      {
        v10 = v4[3];
        v5 = v8 - v6;
      }
      else
      {
        v10 = (int)&v7[-v6];
      }
      v11 = v4[2];
      v12 = *v4;
      if ( v6 >= (unsigned int)v7 )
        v10 = (int)&v7[v5 - v10];
      v13 = v4[8];
      v14 = v10 - v9 == v11;
      if ( !v13 )
        v14 = 0;
      if ( v14 )
      {
        do
        {
          pthread_cond_wait(cond, mutex);
          v6 = v4[5];
          v7 = (char *)v4[6];
          v8 = v4[4];
          v9 = *v4;
          v23 = (int)&v7[-v6];
          v11 = v4[2];
          if ( v6 >= (unsigned int)v7 )
            v23 = (int)&v7[v8 - v6 - v4[3]];
          v13 = v4[8];
          v12 = *v4;
          v24 = v23 - v9 == v11;
          if ( !v13 )
            v24 = 0;
        }
        while ( v24 );
        v34 = v4[3];
      }
      if ( !v13 )
        break;
      if ( v6 < (unsigned int)v7 )
        v15 = &v7[-v6];
      else
        v15 = (char *)(v8 - v6);
      if ( v6 >= (unsigned int)v7 )
        v15 = &v7[(_DWORD)v15 - v34];
      v16 = v8 - v34 - v9;
      if ( v16 < (unsigned int)&v15[v3 - v9] )
      {
        pthread_mutex_lock(v37);
        v6 = v4[5];
        v7 = (char *)v4[6];
        v8 = v4[4];
        v34 = v4[3];
        if ( v6 >= (unsigned int)v7 )
        {
          v25 = v4[3];
          v26 = (char *)(v8 - v6);
        }
        else
        {
          v26 = &v7[-v6];
        }
        if ( v6 >= (unsigned int)v7 )
          v26 = &v7[(_DWORD)v26 - v25];
        v39 = (unsigned int)&v26[v3 - *v4];
        v27 = v39 / v9;
        v28 = *v4;
        if ( v16 < v39 )
        {
          v29 = v27 + 1;
          if ( (int)(v27 + 1) >= 0 )
          {
            v30 = 5;
            v31 = 1;
            do
            {
              --v30;
              v27 |= v27 >> v31;
              v31 *= 2;
            }
            while ( v30 );
            v29 = v27 + 1;
          }
          sub_DBF5C(v41, v4, v29 * v9);
          v8 = v41[1];
          v6 = v41[2];
          v34 = v41[0];
          v7 = (char *)v41[3];
          v28 = v41[4];
        }
        v40 = v28;
        pthread_mutex_unlock(v37);
        v12 = v40;
      }
      if ( v6 >= (unsigned int)v7 )
      {
        v21 = a2;
        v20 = v11 - (_DWORD)&v7[v8 - v6 - v34 - v12];
        if ( v20 >= v3 )
          v20 = v3;
        v17 = v20;
      }
      else
      {
        v17 = v11 - (_DWORD)&v7[-v6 - v12];
        v18 = v7;
        if ( v17 >= v3 )
          v17 = v3;
        if ( v8 - (unsigned int)v7 >= v17 )
          v19 = v17;
        else
          v19 = v8 - (_DWORD)v7;
        v7 += v19;
        memcpy(v18, a2, v19);
        v20 = v17 - v19;
        v21 = &a2[v19];
      }
      if ( v20 )
      {
        if ( v8 <= (unsigned int)v7 )
          v7 = &v7[v34 - v8];
        v32 = v7;
        v7 += v20;
        memcpy(v32, v21, v20);
      }
      if ( v8 <= (unsigned int)v7 )
        v7 = &v7[v34 - v8];
      v4[6] = (int)v7;
      pthread_mutex_unlock(mutex);
      v22 = (pthread_cond_t *)(v4 + 22);
      if ( v36 == v17 )
        result = (_DWORD *)pthread_cond_signal(v22);
      else
        result = (_DWORD *)pthread_cond_broadcast(v22);
      v3 -= v17;
      if ( !v3 )
        return result;
      a2 += v17;
      v36 = *v4;
    }
    return (_DWORD *)pthread_mutex_unlock(mutex);
  }
  return result;
}
// DC388: variable 'v5' is possibly undefined
// DC528: variable 'v25' is possibly undefined

//----- (000DC624) --------------------------------------------------------
_DWORD *__fastcall pipe_push(_DWORD *a1, char *a2, int a3)
{
  return _pipe_push(a1, a2, *a1 * a3);
}

//----- (000DC630) --------------------------------------------------------
unsigned int __fastcall pipe_pop(int *a1, char *a2, int a3)
{
  unsigned int v3; // r9
  unsigned int v5; // r4
  size_t v6; // r4
  size_t v7; // r7
  const void *v8; // r1
  unsigned int v9; // r5
  unsigned int v10; // r3
  int v11; // r5
  pthread_cond_t *v12; // r0
  unsigned int v13; // r5
  unsigned int v14; // r6
  int v15; // r3
  unsigned int v16; // r10
  unsigned int v17; // r8
  unsigned int v18; // r4
  unsigned int v19; // r1
  int v20; // r2
  unsigned int v22; // r3
  unsigned int v23; // r12
  int v24; // r1
  int v25; // lr
  bool v26; // cf
  unsigned int v27; // r0
  int v28; // r2
  unsigned int v29; // r2
  char *v30; // r5
  char *v31; // r1
  unsigned int v32; // r5
  pthread_mutex_t *mutex; // [sp+4h] [bp-38h]
  unsigned int v35; // [sp+8h] [bp-34h]
  unsigned int v36; // [sp+Ch] [bp-30h]
  size_t n; // [sp+10h] [bp-2Ch]
  pthread_mutex_t *v38; // [sp+14h] [bp-28h]
  unsigned int v39; // [sp+18h] [bp-24h]
  pthread_cond_t *cond; // [sp+1Ch] [bp-20h]
  int v41[7]; // [sp+20h] [bp-1Ch] BYREF

  v3 = *a1 * a3;
  v39 = *a1;
  if ( v3 )
  {
    mutex = (pthread_mutex_t *)(a1 + 9);
    v35 = 0;
    cond = (pthread_cond_t *)(a1 + 22);
    v38 = (pthread_mutex_t *)(a1 + 15);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 9));
    while ( 1 )
    {
      v13 = a1[5];
      v14 = a1[6];
      v15 = a1[3];
      v16 = a1[4];
      v17 = *a1;
      if ( v13 < v14 )
      {
        v5 = v14 - v13;
        if ( v17 != v14 - v13 )
          goto LABEL_4;
      }
      else
      {
        v18 = v14 - v15;
        v19 = v16 - v13;
        if ( v17 != v14 - v15 + v16 - v13 )
          goto LABEL_30;
      }
      do
      {
        if ( !a1[7] )
          break;
        pthread_cond_wait(cond, mutex);
        v13 = a1[5];
        v14 = a1[6];
        v15 = a1[3];
        v16 = a1[4];
        v17 = *a1;
        v20 = v14 - v13;
        if ( v13 >= v14 )
          v20 = v14 - v15 + v16 - v13;
      }
      while ( v17 == v20 );
      if ( v13 < v14 )
      {
        v5 = v14 - v13;
LABEL_4:
        v6 = v5 - v17;
        if ( !v6 )
          goto LABEL_31;
        goto LABEL_5;
      }
      v18 = v14 - v15;
      v19 = v16 - v13;
LABEL_30:
      v6 = v18 + v19 - v17;
      if ( !v6 )
      {
LABEL_31:
        pthread_mutex_unlock(mutex);
        return v35 / v39;
      }
LABEL_5:
      v7 = v16 - v13 - v17;
      if ( v6 >= v3 )
        v6 = v3;
      v36 = v15;
      if ( v7 >= v6 )
        v7 = v6;
      v8 = (const void *)(v13 + v17);
      v9 = v13 + v7;
      n = v6 - v7;
      memcpy(a2, v8, v7);
      v10 = v36;
      if ( v16 <= v9 )
        v9 = v36 + v9 - v16;
      if ( v6 != v7 )
      {
        v30 = (char *)(v9 + v17);
        if ( v16 <= (unsigned int)v30 )
          v30 = &v30[v36 - v16];
        v31 = v30;
        v32 = (unsigned int)&v30[n];
        memcpy(&a2[v7], v31, n);
        v10 = v36;
        if ( v16 <= v32 )
          v32 = v36 + v32 - v16;
        v9 = v32 - v17;
        if ( v36 > v9 )
          v9 = v16 - (v36 - v9);
      }
      a1[5] = v9;
      if ( v14 > v9 )
        v11 = v14 - v9;
      else
        v11 = v14 - v10 + v16 - v9;
      if ( v11 - v17 <= (v16 - v10 - v17) >> 2 )
      {
        pthread_mutex_unlock(mutex);
        pthread_mutex_lock(v38);
        pthread_mutex_lock(mutex);
        v22 = a1[6];
        v23 = a1[5];
        v24 = a1[3];
        v25 = a1[4];
        v26 = v23 >= v22;
        v27 = *a1;
        if ( v23 < v22 )
          v22 -= v23;
        v28 = v25 - v24;
        if ( v26 )
        {
          v24 = v22 - v24;
          v22 = v25 - v23;
        }
        v29 = v28 - v27;
        if ( v26 )
          v22 += v24;
        if ( v22 - v27 <= v29 >> 2 )
          sub_DBF5C(v41, a1, v29 >> 1);
        pthread_mutex_unlock(mutex);
        pthread_mutex_unlock(v38);
      }
      else
      {
        pthread_mutex_unlock(mutex);
      }
      v12 = (pthread_cond_t *)(a1 + 34);
      if ( v6 == *a1 )
        pthread_cond_signal(v12);
      else
        pthread_cond_broadcast(v12);
      v3 -= v6;
      a2 += v6;
      v35 += v6;
      if ( !v3 )
        return v35 / v39;
      pthread_mutex_lock(mutex);
    }
  }
  return v3;
}

//----- (000DC8F8) --------------------------------------------------------
unsigned int __fastcall pipe_pop_eager(int a1, char *a2, int a3)
{
  unsigned int v3; // r11
  unsigned int v4; // r6
  pthread_mutex_t *v5; // r10
  unsigned int v7; // r5
  unsigned int v8; // r7
  unsigned int v9; // r9
  unsigned int v10; // r3
  unsigned int v11; // r2
  unsigned int v12; // r2
  size_t v13; // r8
  const void *v14; // r1
  char *v15; // r5
  unsigned int v16; // r1
  unsigned int v17; // r3
  bool v18; // cc
  pthread_mutex_t *v19; // r0
  unsigned int v20; // r5
  pthread_cond_t *v21; // r0
  unsigned int v23; // r1
  unsigned int v24; // r2
  int v25; // r2
  char *v26; // r5
  char *v27; // r1
  char *v28; // r5
  unsigned int v29; // r3
  unsigned int v30; // r12
  int v31; // r1
  int v32; // lr
  bool v33; // cf
  unsigned int v34; // r0
  int v35; // r2
  unsigned int v36; // r2
  unsigned int v37; // [sp+0h] [bp-2Ch]
  unsigned int v39; // [sp+8h] [bp-24h]
  size_t n; // [sp+Ch] [bp-20h]
  int v41[7]; // [sp+10h] [bp-1Ch] BYREF

  v3 = *(_DWORD *)a1;
  v4 = *(_DWORD *)a1 * a3;
  if ( !v4 )
    return v4;
  v5 = (pthread_mutex_t *)(a1 + 36);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 36));
  v7 = *(_DWORD *)(a1 + 20);
  v8 = *(_DWORD *)(a1 + 24);
  v9 = *(_DWORD *)a1;
  v37 = *(_DWORD *)(a1 + 12);
  v10 = *(_DWORD *)(a1 + 16);
  if ( v7 >= v8 )
  {
    v23 = v10 - v7;
    v24 = v8 - v37;
    if ( v9 != v8 - v37 + v10 - v7 )
      goto LABEL_33;
  }
  else
  {
    v11 = v8 - v7;
    if ( v9 != v8 - v7 )
      goto LABEL_4;
  }
  if ( *(_DWORD *)(a1 + 28) )
  {
    do
    {
      pthread_cond_wait((pthread_cond_t *)(a1 + 88), v5);
      v9 = *(_DWORD *)a1;
      v10 = *(_DWORD *)(a1 + 16);
      v7 = *(_DWORD *)(a1 + 20);
      v8 = *(_DWORD *)(a1 + 24);
      v25 = v8 - v7;
      if ( v7 >= v8 )
        v25 = v8 - *(_DWORD *)(a1 + 12) + v10 - v7;
    }
    while ( v9 == v25 && *(_DWORD *)(a1 + 28) );
    v37 = *(_DWORD *)(a1 + 12);
  }
  if ( v8 > v7 )
  {
    v11 = v8 - v7;
    goto LABEL_4;
  }
  v23 = v10 - v7;
  v24 = v8 - v37;
LABEL_33:
  v11 = v24 + v23;
LABEL_4:
  v12 = v11 - v9;
  if ( v12 )
  {
    v13 = v10 - v7 - v9;
    if ( v4 >= v12 )
      v4 = v12;
    v39 = v10;
    if ( v13 >= v4 )
      v13 = v4;
    v14 = (const void *)(v7 + v9);
    v15 = (char *)(v7 + v13);
    n = v4 - v13;
    memcpy(a2, v14, v13);
    v17 = v39;
    if ( (unsigned int)v15 >= v39 )
      v15 = &v15[v37 - v39];
    if ( v4 != v13 )
    {
      v26 = &v15[v9];
      if ( (unsigned int)v26 >= v39 )
        v26 = &v26[v37 - v39];
      v27 = v26;
      v28 = &v26[n];
      memcpy(&a2[v13], v27, n);
      v17 = v39;
      if ( (unsigned int)v28 >= v39 )
        v28 = &v28[v37 - v39];
      v15 = &v28[-v9];
      if ( v37 > (unsigned int)v15 )
        v15 = (char *)(v39 - (v37 - (_DWORD)v15));
    }
    v18 = v8 > (unsigned int)v15;
    if ( v8 <= (unsigned int)v15 )
      v16 = v37;
    v19 = v5;
    *(_DWORD *)(a1 + 20) = v15;
    if ( v8 > (unsigned int)v15 )
      v20 = v8 - (_DWORD)v15;
    else
      v20 = v17 - (_DWORD)v15;
    if ( !v18 )
      v20 += v8 - v16;
    if ( v20 - v9 <= (v17 - v37 - v9) >> 2 )
    {
      pthread_mutex_unlock(v5);
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 60));
      pthread_mutex_lock(v5);
      v29 = *(_DWORD *)(a1 + 24);
      v30 = *(_DWORD *)(a1 + 20);
      v31 = *(_DWORD *)(a1 + 12);
      v32 = *(_DWORD *)(a1 + 16);
      v33 = v30 >= v29;
      v34 = *(_DWORD *)a1;
      if ( v30 < v29 )
        v29 -= v30;
      v35 = v32 - v31;
      if ( v33 )
      {
        v31 = v29 - v31;
        v29 = v32 - v30;
      }
      v36 = v35 - v34;
      if ( v33 )
        v29 += v31;
      if ( v29 - v34 <= v36 >> 2 )
        sub_DBF5C(v41, (int *)a1, v36 >> 1);
      pthread_mutex_unlock(v5);
      v19 = (pthread_mutex_t *)(a1 + 60);
    }
    pthread_mutex_unlock(v19);
    v21 = (pthread_cond_t *)(a1 + 136);
    if ( v4 == *(_DWORD *)a1 )
      pthread_cond_signal(v21);
    else
      pthread_cond_broadcast(v21);
    v4 /= v3;
  }
  else
  {
    v4 = 0;
    pthread_mutex_unlock(v5);
  }
  return v4;
}
// DC9D0: variable 'v16' is possibly undefined

//----- (000DCBA8) --------------------------------------------------------
int __fastcall pipe_reserve(pthread_mutex_t *mutex, int a2)
{
  int lock; // r5
  pthread_mutex_t *v3; // r6
  pthread_mutex_t *v5; // r7
  pthread_mutex_t *v6; // r0
  unsigned int v7; // r5
  unsigned int v8; // r3
  unsigned int spins; // r1
  int kind; // r2
  bool v11; // cf
  _DWORD v13[7]; // [sp+0h] [bp-1Ch] BYREF

  v3 = (pthread_mutex_t *)((char *)mutex + 60);
  lock = mutex->__lock;
  v5 = (pthread_mutex_t *)((char *)mutex + 36);
  v6 = (pthread_mutex_t *)((char *)mutex + 60);
  v7 = lock * a2;
  if ( !v7 )
    v7 = 32;
  pthread_mutex_lock(v6);
  pthread_mutex_lock(v5);
  v8 = mutex[1].__lock;
  spins = mutex->__spins;
  kind = mutex->__kind;
  v11 = spins >= v8;
  if ( spins < v8 )
    v8 -= spins;
  else
    kind = v8 - kind;
  if ( v11 )
    v8 = kind + mutex->__nusers - spins;
  if ( v7 > v8 - mutex->__lock )
    sub_DBF5C(v13, &mutex->__lock, v7);
  pthread_mutex_unlock(v5);
  return pthread_mutex_unlock(v3);
}

//----- (000DCE94) --------------------------------------------------------
int __fastcall sub_DCE94(unsigned int a1, unsigned int a2)
{
  if ( !a2 )
    JUMPOUT(0xDCE8A);
  return a1 / a2;
}
// DCE96: control flows out of bounds to DCE8A

//----- (000DCEB0) --------------------------------------------------------
int __fastcall sub_DCEB0(int a1, unsigned int a2)
{
  if ( !a2 )
    JUMPOUT(0xDD7C4);
  return divsi3_skip_div0_test(a1, a2);
}
// DD140: control flows out of bounds to DD7C4

//----- (000DCEB6) --------------------------------------------------------
int __fastcall divsi3_skip_div0_test(int result, unsigned int a2)
{
  char v2; // nf
  signed int v3; // r12
  unsigned int v4; // r3

  v3 = result ^ a2;
  if ( v2 )
    a2 = -a2;
  if ( a2 == 1 )
  {
    if ( (v3 ^ result) < 0 )
      return -result;
  }
  else
  {
    v4 = result;
    if ( result < 0 )
      v4 = -result;
    if ( v4 <= a2 )
    {
      if ( v4 < a2 )
        result = 0;
      if ( v4 == a2 )
        return (v3 >> 31) | 1;
    }
    else if ( (a2 & (a2 - 1)) != 0 )
    {
      return ((int (__fastcall *)(_DWORD))((char *)&loc_DCEF8 + 16 * (31 - (__clz(a2) - __clz(v4)))))(0);
    }
    else
    {
      result = v4 >> (31 - __clz(a2));
      if ( v3 < 0 )
        return -result;
    }
  }
  return result;
}
// DCEBA: variable 'v2' is possibly undefined

//----- (000DD144) --------------------------------------------------------
int __fastcall sub_DD144(int a1, unsigned int a2)
{
  if ( !a2 )
    JUMPOUT(0xDD7C4);
  return divsi3_skip_div0_test(a1, a2);
}
// DD140: control flows out of bounds to DD7C4

//----- (000DD46C) --------------------------------------------------------
int __fastcall sub_DD46C(__int64 a1)
{
  if ( a1 )
    JUMPOUT(0xDD492);
  return a1;
}
// DD47A: control flows out of bounds to DD492

//----- (000DD47C) --------------------------------------------------------
int __fastcall sub_DD47C(__int64 a1)
{
  bool v1; // cf
  int v2; // off
  int v3; // r4
  bool v4; // zf
  unsigned int v5; // r3
  int v6; // r3
  bool v7; // cc
  int v8; // r2
  unsigned int v9; // r12
  int v10; // r4
  int v11; // r4
  char v12; // r4
  int v13; // r4
  unsigned int v14; // r12
  int v15; // r2
  int v16; // r2

  if ( !a1 )
    return a1;
  if ( a1 < 0 )
  {
    v1 = (_DWORD)a1 == 0;
    LODWORD(a1) = -(int)a1;
    HIDWORD(a1) -= 2 * HIDWORD(a1) + !v1;
  }
  v13 = 1074;
  v14 = HIDWORD(a1) >> 22;
  if ( HIDWORD(a1) >> 22 )
  {
    v15 = 3;
    if ( HIDWORD(a1) >> 25 )
      v15 = 6;
    if ( HIDWORD(a1) >> 28 )
      v15 += 3;
    v16 = v15 + (HIDWORD(a1) >> 31);
    v14 = (_DWORD)a1 << (32 - v16);
    LODWORD(a1) = ((unsigned int)a1 >> v16) | (HIDWORD(a1) << (32 - v16));
    HIDWORD(a1) >>= v16;
    v13 = v16 + 1074;
  }
  if ( HIDWORD(a1) >= 0x100000 )
  {
    if ( HIDWORD(a1) >= 0x200000 )
    {
      v1 = a1 & 1;
      LODWORD(a1) = a1 >> 1;
      v14 = (v14 >> 1) | (v1 << 31);
      if ( (unsigned int)((v13 + 1) << 21) >= 0xFFC00000 )
      {
        LODWORD(a1) = 0;
        return a1;
      }
    }
    goto LABEL_13;
  }
  v1 = __CFSHL__(v14, 1);
  v14 *= 2;
  v2 = v1 + (_DWORD)a1;
  v1 = __CFADD__(v1, (_DWORD)a1) | __CFADD__((_DWORD)a1, v2);
  LODWORD(a1) = a1 + v2;
  HIDWORD(a1) += v1 + HIDWORD(a1);
  v3 = v13 - 1;
  if ( (a1 & 0x10000000000000LL) != 0 )
  {
LABEL_13:
    v1 = v14 >= 0x80000000;
    if ( v14 == 0x80000000 )
      v1 = a1 & 1;
    LODWORD(a1) = v1 + (_DWORD)a1;
    return a1;
  }
  v4 = HIDWORD(a1) == 0;
  if ( !HIDWORD(a1) )
  {
    HIDWORD(a1) = a1;
    LODWORD(a1) = 0;
  }
  v5 = __clz(HIDWORD(a1));
  if ( v4 )
    v5 += 32;
  v6 = v5 - 11;
  v8 = v6 - 32;
  v7 = v6 <= 32;
  if ( v6 >= 32 )
    goto LABEL_25;
  v7 = v8 <= -12;
  if ( v8 <= -12 )
  {
    LOBYTE(v8) = v6;
LABEL_25:
    if ( v7 )
      LOBYTE(v14) = 32 - v8;
    HIDWORD(a1) <<= v8;
    v9 = (unsigned int)a1 >> v14;
    if ( v7 )
    {
      HIDWORD(a1) |= v9;
      LODWORD(a1) = (_DWORD)a1 << v8;
    }
    goto LABEL_29;
  }
  LODWORD(a1) = HIDWORD(a1) << v6;
  HIDWORD(a1) >>= 32 - v6;
LABEL_29:
  v7 = v3 < v6;
  v10 = v3 - v6;
  if ( v7 )
  {
    v11 = ~v10;
    v7 = v11 < 31;
    v12 = v11 - 31;
    if ( v7 )
      LODWORD(a1) = ((unsigned int)a1 >> (v12 + 32)) | (HIDWORD(a1) << -v12);
    else
      LODWORD(a1) = HIDWORD(a1) >> v12;
  }
  return a1;
}

//----- (000DD668) --------------------------------------------------------
int __fastcall sub_DD668(__int64 a1)
{
  if ( a1 )
    JUMPOUT(0xDD68C);
  return a1;
}
// DD674: control flows out of bounds to DD68C

//----- (000DD794) --------------------------------------------------------
int __fastcall sub_DD794(unsigned __int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // [sp+8h] [bp-8h] BYREF

  if ( a2 )
    return _udivmoddi4(a1, a2, &v3);
  if ( a1 )
    HIDWORD(a1) = -1;
  LODWORD(v3) = HIDWORD(a1);
  return raise(8);
}

//----- (000DD838) --------------------------------------------------------
int __fastcall _udivmoddi4(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 *a3)
{
  bool v3; // cf
  unsigned __int64 v4; // r4
  unsigned int v5; // r12
  unsigned int v6; // r1
  unsigned int v7; // r12
  char v8; // r8
  char v9; // r9
  unsigned __int64 v10; // r6
  unsigned __int64 v11; // r6
  unsigned int v12; // r2
  int v13; // off

  v3 = a1 >= a2;
  LODWORD(v4) = a1;
  if ( a1 < a2 )
    LODWORD(a1) = 0;
  HIDWORD(v4) = HIDWORD(a1);
  if ( !v3 )
    goto LABEL_16;
  v5 = __clz(HIDWORD(a2));
  if ( HIDWORD(a2) )
  {
    v6 = __clz(HIDWORD(a1));
    if ( HIDWORD(v4) )
      goto LABEL_7;
    goto LABEL_19;
  }
  v6 = __clz(HIDWORD(a1));
  v5 = __clz(a2) + 32;
  if ( !HIDWORD(v4) )
LABEL_19:
    v6 = __clz(v4) + 32;
LABEL_7:
  v7 = v5 - v6;
  v8 = v7 - 32;
  v9 = 32 - v7;
  v10 = a2 << v7;
  if ( v4 >= a2 << v7 )
  {
    LODWORD(a1) = 1 << v7;
    v4 -= v10;
    HIDWORD(a1) = (1 << v8) | (1u >> v9);
  }
  else
  {
    a1 = 0;
  }
  if ( v7 )
  {
    v11 = v10 >> 1;
    v12 = v7;
    do
    {
      while ( v4 >= v11 )
      {
        v4 = 2 * (v4 - v11) + 1;
        if ( !--v12 )
          goto LABEL_15;
      }
      v13 = (v4 + (unsigned int)v4) >> 32;
      LODWORD(v4) = 2 * v4;
      HIDWORD(v4) += v13;
      --v12;
    }
    while ( v12 );
LABEL_15:
    v3 = __CFADD__((_DWORD)a1, (_DWORD)v4);
    LODWORD(a1) = a1 + v4;
    LODWORD(v4) = ((unsigned int)v4 >> v7) | (HIDWORD(v4) << v9) | (HIDWORD(v4) >> v8);
    HIDWORD(a1) += v3 + HIDWORD(v4);
    HIDWORD(v4) >>= v7;
    a1 -= v4 << v7;
  }
LABEL_16:
  if ( a3 )
    *a3 = v4;
  return a1;
}
// DD838: invalid function type 'UDItype __fastcall _udivmoddi4(UDItype n, UDItype d, UDItype *rp)' has been ignored

//----- (000DD950) --------------------------------------------------------
int __fastcall init(int a1, int a2, int a3)
{
  int result; // r0
  int (__fastcall **v7)(int, int, int); // r5
  int v8; // r6
  int i; // r4
  int (__fastcall *v10)(int, int, int); // t1

  result = init_proc();
  v7 = (int (__fastcall **)(int, int, int))&off_105EF0;
  v8 = &off_105EF4 - &off_105EF0;
  if ( v8 )
  {
    for ( i = 0; i != v8; ++i )
    {
      v10 = *v7++;
      result = v10(a1, a2, a3);
    }
  }
  return result;
}
// 105EF0: using guessed type _UNKNOWN *off_105EF0;
// 105EF4: using guessed type _UNKNOWN *off_105EF4;

//----- (000DD990) --------------------------------------------------------
// Alternative name is '_fini'
void term_proc()
{
  ;
}

// nfuncs=1751 queued=1421 decompiled=1421 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 1421 function(s)"
